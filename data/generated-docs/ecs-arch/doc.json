{"html":"<h1 id=\"ecs-architecture-design-document\">ECS Architecture: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>An Entity-Component-System (ECS) architecture that separates game objects into entities (IDs), components (data), and systems (logic) to achieve data-oriented design principles. The key architectural challenge is maintaining cache-friendly memory layouts while providing flexible entity composition and efficient query mechanisms for high-performance game engines.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<h2 id=\"context-and-problem-statement\">Context and Problem Statement</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundation for all milestones — understanding why ECS architecture is necessary</p>\n</blockquote>\n<p>Modern game development faces a fundamental performance crisis rooted in how we organize game object data and behavior. While object-oriented programming provides excellent abstraction and code organization for many software domains, it creates severe performance bottlenecks in games where thousands of entities must be processed every frame within strict timing constraints. This section explores the specific problems that traditional object-oriented game architectures create and how Entity-Component-System (ECS) architecture addresses these issues through data-oriented design principles.</p>\n<h3 id=\"object-oriented-game-architecture-problems\">Object-Oriented Game Architecture Problems</h3>\n<p>Traditional game engines organize game objects using object-oriented hierarchies where each game entity is represented as an object containing both data (properties) and behavior (methods). While this approach feels intuitive to programmers — after all, a &quot;Tank&quot; object naturally contains health, position, and firing logic — it creates three critical performance problems that become insurmountable as games scale to thousands of entities.</p>\n<p><strong>Mental Model: The Library Maze</strong>\nThink of traditional object-oriented game architecture like a library where related books are scattered across different floors and wings. When you need to research a topic, you must walk from the history section on the third floor to the science wing in the basement, then to the philosophy section in the east building. Each book (object) contains everything about one topic (entity), but gathering information about many similar topics requires constantly traveling between distant locations. Your research session becomes dominated by walking time rather than actual reading.</p>\n<h4 id=\"cache-miss-cascade-problems\">Cache Miss Cascade Problems</h4>\n<p>Modern processors are fast, but only when data lives in CPU cache. Main memory access takes 100-300 CPU cycles, while cache access takes 1-4 cycles — a 100x performance difference. Object-oriented game architectures systematically defeat CPU caches through scattered memory layouts and unpredictable access patterns.</p>\n<p>Consider a typical object-oriented game entity hierarchy:</p>\n<table>\n<thead>\n<tr>\n<th>Class Level</th>\n<th>Memory Layout</th>\n<th>Cache Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>GameObject</code> base class</td>\n<td>Virtual function table pointer, entity ID, transform</td>\n<td>May be cache-friendly for transform updates</td>\n</tr>\n<tr>\n<td><code>Actor</code> derived class</td>\n<td>Health, team affiliation, AI state</td>\n<td>Scattered across memory as objects are created</td>\n</tr>\n<tr>\n<td><code>Tank</code> concrete class</td>\n<td>Armor value, ammunition count, turret rotation</td>\n<td>Each tank object non-contiguous with other tanks</td>\n</tr>\n<tr>\n<td>Component pointers</td>\n<td>Rendering, physics, audio components</td>\n<td>Each pointer dereference likely cache miss</td>\n</tr>\n</tbody></table>\n<p>When a movement system needs to update positions for 1000 tanks, the processor must load 1000 separate memory locations from main RAM. Each tank object contains the needed position data, but it&#39;s surrounded by unrelated data like ammunition counts and AI state that the movement system doesn&#39;t need. The CPU cache fills with irrelevant data, forcing constant memory fetches.</p>\n<p>The problem compounds when multiple systems run in sequence. A physics system updates positions, evicting cache lines. Then a rendering system needs those same positions, but they&#39;ve been evicted, causing another round of memory fetches. Each system thrashes the cache with its own access patterns.</p>\n<table>\n<thead>\n<tr>\n<th>System</th>\n<th>Data Needed</th>\n<th>Data Actually Loaded</th>\n<th>Cache Efficiency</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Movement System</td>\n<td>Position, velocity (8 bytes)</td>\n<td>Entire Tank object (200+ bytes)</td>\n<td>~4% efficient</td>\n</tr>\n<tr>\n<td>Physics System</td>\n<td>Position, mass, collision shape (24 bytes)</td>\n<td>Entire Tank object (200+ bytes)</td>\n<td>~12% efficient</td>\n</tr>\n<tr>\n<td>Rendering System</td>\n<td>Position, mesh, textures (16 bytes)</td>\n<td>Entire Tank object (200+ bytes)</td>\n<td>~8% efficient</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>The fundamental insight is that object-oriented designs optimize for human conceptual organization (all tank data together) while processors optimize for computational access patterns (all position data together).</p>\n</blockquote>\n<h4 id=\"inheritance-hierarchy-complexity\">Inheritance Hierarchy Complexity</h4>\n<p>Object-oriented game engines typically organize entities using deep inheritance hierarchies that seemed logical during design but create maintenance nightmares and performance problems as games evolve.</p>\n<p>A typical game entity hierarchy might look like:</p>\n<table>\n<thead>\n<tr>\n<th>Class</th>\n<th>Inherits From</th>\n<th>Adds Fields</th>\n<th>Common Problems</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>GameObject</code></td>\n<td>None</td>\n<td>ID, transform, active flag</td>\n<td>Base becomes bloated with &quot;universal&quot; features</td>\n</tr>\n<tr>\n<td><code>Actor</code></td>\n<td><code>GameObject</code></td>\n<td>Health, team, AI state</td>\n<td>Forces all actors to have AI even if unnecessary</td>\n</tr>\n<tr>\n<td><code>Vehicle</code></td>\n<td><code>Actor</code></td>\n<td>Speed, fuel, driver</td>\n<td>What about remote-controlled vehicles without drivers?</td>\n</tr>\n<tr>\n<td><code>Tank</code></td>\n<td><code>Vehicle</code></td>\n<td>Armor, ammunition</td>\n<td>Works fine initially</td>\n</tr>\n<tr>\n<td><code>Hovercraft</code></td>\n<td><code>Vehicle</code></td>\n<td>Hover height, ground clearance</td>\n<td>Inherits fuel system but uses energy instead</td>\n</tr>\n<tr>\n<td><code>FlyingTank</code></td>\n<td>???</td>\n<td>Both tank and aircraft properties</td>\n<td>Multiple inheritance or awkward compromises</td>\n</tr>\n</tbody></table>\n<p>The hierarchy looks clean on paper, but real game requirements break these neat categories. What happens when you need:</p>\n<ul>\n<li>A tank that can also fly (hover tank)?</li>\n<li>A vehicle driven by AI that sometimes becomes player-controlled?</li>\n<li>A destructible building that gains vehicle properties when it becomes a mobile fortress?</li>\n<li>Temporary power-ups that add vehicle-like movement to infantry units?</li>\n</ul>\n<p>Each new requirement forces awkward compromises:</p>\n<ol>\n<li><strong>Bloated base classes</strong>: Adding fields to <code>GameObject</code> to handle edge cases, wasting memory for entities that don&#39;t need them</li>\n<li><strong>Deep inheritance chains</strong>: Seven-level hierarchies where changes to base classes break multiple derived classes</li>\n<li><strong>Interface proliferation</strong>: Adding <code>IDamageable</code>, <code>IMoveable</code>, <code>ITargetable</code> interfaces that create complex multiple inheritance scenarios</li>\n<li><strong>Code duplication</strong>: Similar behavior implemented differently across inheritance branches</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Why Traditional Inheritance Fails for Game Entities</strong></p>\n<ul>\n<li><strong>Context</strong>: Game entities need flexible, runtime-configurable behavior combinations that don&#39;t fit neat taxonomies</li>\n<li><strong>Options Considered</strong>: Deep inheritance hierarchies, multiple inheritance, interface-based composition</li>\n<li><strong>Decision</strong>: Move away from inheritance-based entity organization entirely</li>\n<li><strong>Rationale</strong>: Games require &quot;composition over inheritance&quot; because entity behavior combinations are data-driven, not statically determinable</li>\n<li><strong>Consequences</strong>: Need new architecture that supports runtime behavior composition — this motivates ECS design</li>\n</ul>\n</blockquote>\n<h4 id=\"scattered-data-access-patterns\">Scattered Data Access Patterns</h4>\n<p>Object-oriented architectures scatter related computational data across memory, forcing systems to follow pointer chains and load irrelevant data. This creates predictable performance problems that compound as entity counts increase.</p>\n<p>Consider how different game systems access entity data in an object-oriented design:</p>\n<p><strong>Scenario: 1000 tanks in a battle</strong></p>\n<table>\n<thead>\n<tr>\n<th>Frame Operation</th>\n<th>Memory Access Pattern</th>\n<th>Performance Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Physics update</td>\n<td>Visit each tank object → follow physics component pointer → update position</td>\n<td>2000 memory locations, scattered across heap</td>\n</tr>\n<tr>\n<td>Rendering update</td>\n<td>Visit each tank object → follow render component pointer → extract transform + model</td>\n<td>Another 2000 locations, different scatter pattern</td>\n</tr>\n<tr>\n<td>AI update</td>\n<td>Visit each tank object → follow AI component pointer → read nearby enemies</td>\n<td>3000+ locations (includes enemy lookups)</td>\n</tr>\n<tr>\n<td>Audio update</td>\n<td>Visit each tank object → follow audio component pointer → calculate 3D position</td>\n<td>2000 more scattered accesses</td>\n</tr>\n</tbody></table>\n<p>Each system follows different pointer chains to different memory locations. There&#39;s no spatial locality because:</p>\n<ol>\n<li>Tank objects were allocated at different times, scattered across the heap</li>\n<li>Component objects are allocated separately, pointed to from tank objects</li>\n<li>Each system needs different subsets of data, but must load entire objects</li>\n</ol>\n<p>The processor spends more time waiting for memory than executing game logic. Profilers show 70-80% of frame time spent on memory stalls rather than computation.</p>\n<p><strong>Pointer Chasing Anti-Pattern</strong></p>\n<p>Object-oriented designs often create &quot;pointer chasing&quot; scenarios where accessing related data requires following multiple indirections:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Tank object → AI Component → Target pointer → Enemy Tank → Health Component → Current health value</code></pre></div>\n\n<p>Each arrow represents a potential cache miss. To answer &quot;how much health does my target have?&quot;, the processor might perform 5 separate memory fetches from scattered locations.</p>\n<table>\n<thead>\n<tr>\n<th>Access Step</th>\n<th>Data Loaded</th>\n<th>Bytes Useful</th>\n<th>Bytes Wasted</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Load tank object</td>\n<td>Tank properties (200 bytes)</td>\n<td>AI component pointer (8 bytes)</td>\n<td>192 bytes</td>\n</tr>\n<tr>\n<td>Load AI component</td>\n<td>AI state (150 bytes)</td>\n<td>Target pointer (8 bytes)</td>\n<td>142 bytes</td>\n</tr>\n<tr>\n<td>Load enemy tank</td>\n<td>Enemy tank properties (200 bytes)</td>\n<td>Health component pointer (8 bytes)</td>\n<td>192 bytes</td>\n</tr>\n<tr>\n<td>Load health component</td>\n<td>Health data (50 bytes)</td>\n<td>Current health (4 bytes)</td>\n<td>46 bytes</td>\n</tr>\n</tbody></table>\n<p>To extract 4 bytes of health data, the system loaded 600 bytes total — a 99.3% waste ratio. Multiply this by thousands of entities and dozens of systems per frame, and the performance cost becomes prohibitive.</p>\n<h3 id=\"data-oriented-design-benefits\">Data-Oriented Design Benefits</h3>\n<p>Data-oriented design flips the traditional object-oriented approach by organizing data around computational access patterns rather than conceptual object boundaries. Instead of asking &quot;what data does a Tank object contain?&quot;, data-oriented design asks &quot;what data does the movement system need, and how can we lay it out for maximum cache efficiency?&quot;</p>\n<p><strong>Mental Model: The Organized Warehouse</strong>\nThink of data-oriented design like a well-organized warehouse where inventory is grouped by how it&#39;s used rather than what company manufactured it. All the heavy items are in one section with forklifts, all the fragile items are in another section with special handling equipment, and all the small frequently-accessed items are near the shipping dock. When workers need to fulfill orders, they can efficiently gather similar items without constantly traveling between distant warehouse sections.</p>\n<h4 id=\"cache-locality-optimization\">Cache Locality Optimization</h4>\n<p>Data-oriented design achieves dramatic performance improvements by organizing data to match how systems actually access it. Instead of scattering tank data across individual objects, we group all position data together, all velocity data together, and all health data together.</p>\n<p><strong>Contiguous Array Benefits</strong></p>\n<p>Consider how a movement system processes entity positions in a data-oriented layout:</p>\n<table>\n<thead>\n<tr>\n<th>Data Organization</th>\n<th>Memory Layout</th>\n<th>Cache Performance</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Array of positions</td>\n<td><code>[pos1][pos2][pos3][pos4]...</code></td>\n<td>Sequential access, perfect cache line utilization</td>\n</tr>\n<tr>\n<td>Array of velocities</td>\n<td><code>[vel1][vel2][vel3][vel4]...</code></td>\n<td>Adjacent to positions, minimal cache misses</td>\n</tr>\n<tr>\n<td>Array of rotations</td>\n<td><code>[rot1][rot2][rot3][rot4]...</code></td>\n<td>Predictable access pattern, good prefetching</td>\n</tr>\n</tbody></table>\n<p>When the movement system updates 1000 entities:</p>\n<ol>\n<li>Load position array starting address into cache</li>\n<li>Process positions sequentially — each cache line contains 8-16 positions</li>\n<li>Load velocity array — processor prefetches next cache lines automatically</li>\n<li>Update positions using vectorized operations across multiple entities simultaneously</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Access Pattern</th>\n<th>Cache Lines Used</th>\n<th>Entities Processed</th>\n<th>Cache Efficiency</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Sequential array access</td>\n<td>64 cache lines</td>\n<td>1000 entities</td>\n<td>~95% efficient</td>\n</tr>\n<tr>\n<td>Object-oriented scatter</td>\n<td>1000+ cache lines</td>\n<td>1000 entities</td>\n<td>~5% efficient</td>\n</tr>\n</tbody></table>\n<p>The same computation that took 1000 memory fetches now takes 64, and most are automatically prefetched by the processor&#39;s prediction mechanisms.</p>\n<p><strong>Memory Access Predictability</strong></p>\n<p>Data-oriented layouts create predictable access patterns that processors can optimize automatically:</p>\n<ol>\n<li><strong>Sequential prefetching</strong>: CPU automatically loads next cache lines when it detects linear access patterns</li>\n<li><strong>Stride prediction</strong>: CPU learns to prefetch every Nth element for regular patterns  </li>\n<li><strong>Branch prediction</strong>: Simple loops over arrays have highly predictable branching</li>\n<li><strong>TLB efficiency</strong>: Fewer distinct memory pages accessed means fewer translation lookups</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Performance Metric</th>\n<th>Object-Oriented</th>\n<th>Data-Oriented</th>\n<th>Improvement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cache miss rate</td>\n<td>60-80%</td>\n<td>5-10%</td>\n<td>8-15x better</td>\n</tr>\n<tr>\n<td>Memory bandwidth utilization</td>\n<td>10-20%</td>\n<td>80-95%</td>\n<td>4-8x better</td>\n</tr>\n<tr>\n<td>Branch prediction accuracy</td>\n<td>70-85%</td>\n<td>95-99%</td>\n<td>20-40% better</td>\n</tr>\n<tr>\n<td>TLB miss rate</td>\n<td>5-15%</td>\n<td>0.1-1%</td>\n<td>10-50x better</td>\n</tr>\n</tbody></table>\n<h4 id=\"simd-friendly-operations\">SIMD-Friendly Operations</h4>\n<p>Single Instruction, Multiple Data (SIMD) processing allows processors to perform the same operation on multiple data elements simultaneously. Modern processors can add 4-8 floating-point values in a single instruction, but only if the data is properly arranged.</p>\n<p><strong>Vectorized Computation Opportunities</strong></p>\n<p>Data-oriented layouts enable automatic vectorization by compilers and explicit SIMD optimization by developers:</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Scalar Processing (Object-Oriented)</th>\n<th>Vectorized Processing (Data-Oriented)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Position updates</td>\n<td>Update one tank position per instruction</td>\n<td>Update 4-8 positions per instruction</td>\n</tr>\n<tr>\n<td>Distance calculations</td>\n<td>One distance calculation per loop</td>\n<td>4-8 distance calculations per loop</td>\n</tr>\n<tr>\n<td>Health regeneration</td>\n<td>One health update per instruction</td>\n<td>4-8 health updates per instruction</td>\n</tr>\n<tr>\n<td>Collision detection</td>\n<td>Compare one entity pair per iteration</td>\n<td>Compare multiple pairs with vector operations</td>\n</tr>\n</tbody></table>\n<p><strong>Example: Movement System Performance</strong></p>\n<p>Consider updating positions for 1000 entities:</p>\n<table>\n<thead>\n<tr>\n<th>Approach</th>\n<th>Instructions per Entity</th>\n<th>Total Instructions</th>\n<th>SIMD Utilization</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Object-oriented</td>\n<td>12 instructions (load, add, store with cache misses)</td>\n<td>12,000 instructions</td>\n<td>0% - scalar only</td>\n</tr>\n<tr>\n<td>Data-oriented scalar</td>\n<td>3 instructions (vectorized load, add, store)</td>\n<td>3,000 instructions</td>\n<td>0% - but cache friendly</td>\n</tr>\n<tr>\n<td>Data-oriented SIMD</td>\n<td>3 instructions processing 4 entities each</td>\n<td>750 instructions</td>\n<td>100% - full vectorization</td>\n</tr>\n</tbody></table>\n<p>The data-oriented SIMD approach is 16x faster than object-oriented, combining cache efficiency with vectorized computation.</p>\n<p><strong>Structure of Arrays vs Array of Structures</strong></p>\n<p>The key insight is organizing data as &quot;Structure of Arrays&quot; (SoA) rather than &quot;Array of Structures&quot; (AoS):</p>\n<table>\n<thead>\n<tr>\n<th>Organization</th>\n<th>Memory Layout</th>\n<th>SIMD Compatibility</th>\n<th>Cache Efficiency</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Array of Structures (OOP)</td>\n<td><code>[x1,y1,z1,health1][x2,y2,z2,health2]...</code></td>\n<td>Poor - mixed data types</td>\n<td>Poor - loads unused data</td>\n</tr>\n<tr>\n<td>Structure of Arrays (DOD)</td>\n<td><code>[x1,x2,x3,x4...][y1,y2,y3,y4...][z1,z2,z3,z4...]</code></td>\n<td>Excellent - homogeneous data</td>\n<td>Excellent - only needed data</td>\n</tr>\n</tbody></table>\n<p>When a movement system needs only X coordinates, the Structure of Arrays layout provides a contiguous array of X values perfect for SIMD processing, while Array of Structures forces loading irrelevant Y, Z, and health data.</p>\n<h4 id=\"composition-over-inheritance\">Composition Over Inheritance</h4>\n<p>Data-oriented design naturally leads to composition-based entity architectures where entities are collections of data components rather than instances of class hierarchies. This provides the flexibility that inheritance hierarchies promise but rarely deliver.</p>\n<p><strong>Component-Based Composition Model</strong></p>\n<p>Instead of entities inheriting behavior from class hierarchies, entities are composed from independent data components:</p>\n<table>\n<thead>\n<tr>\n<th>Entity Type</th>\n<th>Component Composition</th>\n<th>Runtime Flexibility</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Tank</td>\n<td>Position + Velocity + Health + Armor + Weapon</td>\n<td>Can add/remove components dynamically</td>\n</tr>\n<tr>\n<td>Infantry</td>\n<td>Position + Velocity + Health + Equipment</td>\n<td>Same components, different values</td>\n</tr>\n<tr>\n<td>Building</td>\n<td>Position + Health + Armor</td>\n<td>No velocity - stationary</td>\n</tr>\n<tr>\n<td>Projectile</td>\n<td>Position + Velocity + Lifetime</td>\n<td>No health - expires by time</td>\n</tr>\n<tr>\n<td>Powerup</td>\n<td>Position + Velocity + Effect + Lifetime</td>\n<td>Grants temporary abilities</td>\n</tr>\n</tbody></table>\n<p>Each component is a simple data structure with no behavior. Systems provide behavior by operating on entities that have specific component combinations.</p>\n<p><strong>Runtime Composition Benefits</strong></p>\n<p>Component composition enables runtime behavior changes that inheritance hierarchies cannot support:</p>\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Object-Oriented Solution</th>\n<th>Component-Based Solution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Tank loses engine</td>\n<td>Create new &quot;DisabledTank&quot; subclass?</td>\n<td>Remove Velocity component</td>\n</tr>\n<tr>\n<td>Infantry enters vehicle</td>\n<td>Switch object type to &quot;VehicleDriver&quot;?</td>\n<td>Add Vehicle component</td>\n</tr>\n<tr>\n<td>Building becomes mobile</td>\n<td>Multiple inheritance from Building + Vehicle?</td>\n<td>Add Velocity component</td>\n</tr>\n<tr>\n<td>Temporary invisibility</td>\n<td>Add boolean flag to base GameObject?</td>\n<td>Add TemporaryInvisibility component</td>\n</tr>\n</tbody></table>\n<p>Components can be added and removed at runtime without changing entity types or copying data between different object instances.</p>\n<p><strong>System Specialization</strong></p>\n<p>Systems operate only on entities with required components, creating natural specialization without inheritance complexity:</p>\n<table>\n<thead>\n<tr>\n<th>System</th>\n<th>Required Components</th>\n<th>Entities Processed</th>\n<th>Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Movement System</td>\n<td>Position + Velocity</td>\n<td>Tanks, infantry, projectiles</td>\n<td>Updates positions</td>\n</tr>\n<tr>\n<td>Combat System</td>\n<td>Health + Position</td>\n<td>Tanks, infantry, buildings</td>\n<td>Handles damage</td>\n</tr>\n<tr>\n<td>Rendering System</td>\n<td>Position + Visual</td>\n<td>All visible entities</td>\n<td>Draws to screen</td>\n</tr>\n<tr>\n<td>AI System</td>\n<td>AI + Position + Health</td>\n<td>NPCs only</td>\n<td>Makes decisions</td>\n</tr>\n</tbody></table>\n<p>Each system is simple and focused. There&#39;s no need for complex inheritance hierarchies or interface implementations — systems naturally process exactly the entities that need their behavior.</p>\n<blockquote>\n<p><strong>Decision: Component Composition Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: Need flexible entity behavior combinations without inheritance complexity</li>\n<li><strong>Options Considered</strong>: Deep inheritance, multiple inheritance, interface-based design, component composition</li>\n<li><strong>Decision</strong>: Use component composition where entities are collections of data components</li>\n<li><strong>Rationale</strong>: Enables runtime behavior changes, eliminates inheritance complexity, supports data-oriented layout</li>\n<li><strong>Consequences</strong>: Need system architecture to provide behavior, requires component storage and query mechanisms</li>\n</ul>\n</blockquote>\n<h3 id=\"existing-ecs-approaches-comparison\">Existing ECS Approaches Comparison</h3>\n<p>The Entity-Component-System pattern has evolved through several implementation approaches, each with different trade-offs between simplicity, performance, and memory usage. Understanding these approaches helps choose the right implementation strategy for different game requirements.</p>\n<p><strong>Mental Model: Database Storage Strategies</strong>\nThink of ECS component storage like different database storage strategies. You can store customer data in separate files per customer (like object-oriented approaches), in separate tables per data type (like simple component arrays), or in pre-organized views grouping customers by their attribute combinations (like archetype-based storage). Each approach optimizes for different query patterns and data access needs.</p>\n<h4 id=\"simple-component-arrays-approach\">Simple Component Arrays Approach</h4>\n<p>The simplest ECS implementation stores each component type in separate arrays, using sparse arrays or hash maps to associate entity IDs with component indices. This approach is straightforward to implement and reason about.</p>\n<p><strong>Storage Organization</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component Type</th>\n<th>Storage Structure</th>\n<th>Entity-to-Index Mapping</th>\n<th>Memory Layout</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Position</td>\n<td><code>Array&lt;Position&gt;</code></td>\n<td><code>Map&lt;EntityID, Index&gt;</code></td>\n<td>Contiguous position data</td>\n</tr>\n<tr>\n<td>Velocity</td>\n<td><code>Array&lt;Velocity&gt;</code></td>\n<td><code>Map&lt;EntityID, Index&gt;</code></td>\n<td>Contiguous velocity data</td>\n</tr>\n<tr>\n<td>Health</td>\n<td><code>Array&lt;Health&gt;</code></td>\n<td><code>Map&lt;EntityID, Index&gt;</code></td>\n<td>Contiguous health data</td>\n</tr>\n</tbody></table>\n<p>Each component array contains only entities that have that component. An entity with Position and Health components would have entries in two arrays, potentially at different indices.</p>\n<p><strong>Query Processing</strong></p>\n<p>To find entities with both Position and Velocity components:</p>\n<ol>\n<li>Iterate through Position component indices</li>\n<li>For each entity ID, check if it also exists in Velocity component indices</li>\n<li>If both exist, include entity in query results</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Query Type</th>\n<th>Process Steps</th>\n<th>Time Complexity</th>\n<th>Cache Performance</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single component</td>\n<td>Iterate one array</td>\n<td>O(n) where n = entities with component</td>\n<td>Excellent - sequential access</td>\n</tr>\n<tr>\n<td>Two components</td>\n<td>Iterate first, lookup second</td>\n<td>O(n + m log m) with hash maps</td>\n<td>Good - some indirection</td>\n</tr>\n<tr>\n<td>Three+ components</td>\n<td>Multiple intersections</td>\n<td>O(n * log m * log k...)</td>\n<td>Fair - more lookups</td>\n</tr>\n</tbody></table>\n<p><strong>Simple Arrays Trade-offs</strong></p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Advantages</th>\n<th>Disadvantages</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Implementation</td>\n<td>Simple to understand and implement</td>\n<td>Becomes complex with many component types</td>\n</tr>\n<tr>\n<td>Memory Usage</td>\n<td>Only stores components that exist</td>\n<td>Hash maps have memory overhead</td>\n</tr>\n<tr>\n<td>Query Performance</td>\n<td>Fast for single-component queries</td>\n<td>Slow for multi-component queries</td>\n</tr>\n<tr>\n<td>Cache Efficiency</td>\n<td>Excellent for individual component iteration</td>\n<td>Poor for multi-component access</td>\n</tr>\n<tr>\n<td>Entity Modification</td>\n<td>Easy to add/remove components</td>\n<td>May require multiple hash map updates</td>\n</tr>\n</tbody></table>\n<p>This approach works well for simple games with few component types and queries, but performance degrades as query complexity increases.</p>\n<h4 id=\"sparse-set-storage-approach\">Sparse Set Storage Approach</h4>\n<p>Sparse sets provide an elegant solution to the entity-to-component mapping problem, offering O(1) addition, removal, and lookup operations while maintaining cache-friendly iteration over dense component arrays.</p>\n<p><strong>Sparse Set Data Structure</strong></p>\n<p>A sparse set consists of two arrays that work together to provide bidirectional mapping:</p>\n<table>\n<thead>\n<tr>\n<th>Array Type</th>\n<th>Purpose</th>\n<th>Contents</th>\n<th>Access Pattern</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Dense Array</td>\n<td>Stores actual component data</td>\n<td><code>[component_0, component_1, component_2, ...]</code></td>\n<td>Sequential iteration</td>\n</tr>\n<tr>\n<td>Sparse Array</td>\n<td>Maps entity IDs to dense indices</td>\n<td><code>[dense_index_for_entity_0, invalid, dense_index_for_entity_2, ...]</code></td>\n<td>Random access by entity ID</td>\n</tr>\n<tr>\n<td>Dense-to-Entity</td>\n<td>Maps dense indices to entity IDs</td>\n<td><code>[entity_0, entity_1, entity_2, ...]</code></td>\n<td>Reverse lookup for iteration</td>\n</tr>\n</tbody></table>\n<p><strong>Sparse Set Operations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Algorithm</th>\n<th>Time Complexity</th>\n<th>Cache Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Add Component</td>\n<td>1. Append to dense array<br/>2. Store dense index in sparse[entity_id]<br/>3. Store entity_id in dense-to-entity array</td>\n<td>O(1)</td>\n<td>One cache line per array</td>\n</tr>\n<tr>\n<td>Remove Component</td>\n<td>1. Swap-remove from dense array<br/>2. Update sparse array for swapped entity<br/>3. Invalidate sparse[entity_id]</td>\n<td>O(1)</td>\n<td>Minimal cache impact</td>\n</tr>\n<tr>\n<td>Lookup Component</td>\n<td>1. Check sparse[entity_id] &lt; dense.size()<br/>2. Verify dense_to_entity[sparse[entity_id]] == entity_id</td>\n<td>O(1)</td>\n<td>Two cache line accesses</td>\n</tr>\n<tr>\n<td>Iterate All</td>\n<td>Iterate dense array sequentially</td>\n<td>O(n)</td>\n<td>Perfect cache line utilization</td>\n</tr>\n</tbody></table>\n<p><strong>Multi-Component Query Processing</strong></p>\n<p>Sparse sets enable efficient multi-component queries through set intersection algorithms:</p>\n<ol>\n<li><strong>Find smallest component set</strong>: Query components with fewest entities first</li>\n<li><strong>Iterate smallest set</strong>: Check each entity in smallest component&#39;s dense array  </li>\n<li><strong>Validate other components</strong>: Use O(1) sparse set lookups to verify entity has other required components</li>\n<li><strong>Build result set</strong>: Collect entities that have all required components</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Query Size</th>\n<th>Processing Strategy</th>\n<th>Expected Performance</th>\n<th>Cache Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1 component</td>\n<td>Direct dense iteration</td>\n<td>O(n) where n = entities with component</td>\n<td>Excellent sequential access</td>\n</tr>\n<tr>\n<td>2 components</td>\n<td>Iterate smaller, lookup larger</td>\n<td>O(min(n,m))</td>\n<td>Good - mostly sequential</td>\n</tr>\n<tr>\n<td>3+ components</td>\n<td>Iterate smallest, lookup others</td>\n<td>O(smallest_set_size)</td>\n<td>Good - predictable pattern</td>\n</tr>\n</tbody></table>\n<p><strong>Sparse Set Trade-offs</strong></p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Advantages</th>\n<th>Disadvantages</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Lookup Performance</td>\n<td>O(1) entity-to-component access</td>\n<td>Requires entity ID validation check</td>\n</tr>\n<tr>\n<td>Memory Efficiency</td>\n<td>Dense packing of existing components</td>\n<td>Sparse array sized by max entity ID</td>\n</tr>\n<tr>\n<td>Query Performance</td>\n<td>Fast multi-component queries</td>\n<td>Requires intersection algorithms</td>\n</tr>\n<tr>\n<td>Implementation</td>\n<td>Moderate complexity, well-understood</td>\n<td>Swap-remove semantics can surprise users</td>\n</tr>\n<tr>\n<td>Cache Efficiency</td>\n<td>Excellent iteration, good lookup</td>\n<td>Sparse array may have poor locality</td>\n</tr>\n</tbody></table>\n<p>Sparse sets provide the best balance of performance and simplicity for most ECS implementations, offering fast queries without the complexity of archetype-based storage.</p>\n<h4 id=\"archetype-based-storage-approach\">Archetype-Based Storage Approach</h4>\n<p>Archetype-based storage represents the most advanced ECS approach, grouping entities by their exact component combinations into separate storage &quot;tables&quot; for maximum cache efficiency and query performance.</p>\n<p><strong>Archetype Organization Concept</strong></p>\n<p>An archetype represents a unique combination of component types. All entities with identical component sets are stored together in contiguous memory:</p>\n<table>\n<thead>\n<tr>\n<th>Archetype</th>\n<th>Component Combination</th>\n<th>Entity Storage</th>\n<th>Memory Layout</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Archetype A</td>\n<td>Position + Velocity</td>\n<td>Entities 1,5,7,12...</td>\n<td>All Position data contiguous, all Velocity data contiguous</td>\n</tr>\n<tr>\n<td>Archetype B</td>\n<td>Position + Health</td>\n<td>Entities 2,8,9,15...</td>\n<td>All Position data contiguous, all Health data contiguous</td>\n</tr>\n<tr>\n<td>Archetype C</td>\n<td>Position + Velocity + Health</td>\n<td>Entities 3,6,11...</td>\n<td>All three component types contiguous</td>\n</tr>\n</tbody></table>\n<p>Each archetype maintains its own set of component arrays, and entities with identical component combinations share the same archetype storage.</p>\n<p><strong>Archetype Query Performance</strong></p>\n<p>Queries become extremely fast because the system can identify matching archetypes once and then iterate their entities with perfect cache locality:</p>\n<table>\n<thead>\n<tr>\n<th>Query</th>\n<th>Matching Archetypes</th>\n<th>Processing</th>\n<th>Performance</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Position only</td>\n<td>A, B, C</td>\n<td>Iterate position arrays in each archetype</td>\n<td>O(matching_entities)</td>\n</tr>\n<tr>\n<td>Position + Velocity</td>\n<td>A, C</td>\n<td>Iterate both archetypes&#39; arrays sequentially</td>\n<td>Perfect cache locality</td>\n</tr>\n<tr>\n<td>Position + Health</td>\n<td>B, C</td>\n<td>Skip archetype A entirely</td>\n<td>No wasted iteration</td>\n</tr>\n</tbody></table>\n<p>There&#39;s no intersection logic needed — the archetype organization pre-computes which entities match each possible query.</p>\n<p><strong>Archetype Transitions</strong></p>\n<p>The complexity in archetype systems comes from handling component additions and removals, which require moving entities between archetypes:</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Process</th>\n<th>Performance Impact</th>\n<th>Implementation Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Add Component</td>\n<td>1. Find or create destination archetype<br/>2. Copy entity&#39;s components to new archetype<br/>3. Remove entity from old archetype<br/>4. Update entity ID mapping</td>\n<td>O(components_per_entity)</td>\n<td>Complex archetype graph management</td>\n</tr>\n<tr>\n<td>Remove Component</td>\n<td>Similar to add — move to archetype without the component</td>\n<td>O(components_per_entity)</td>\n<td>Must handle archetype cleanup</td>\n</tr>\n<tr>\n<td>Entity Destruction</td>\n<td>Remove from current archetype, no transition needed</td>\n<td>O(1) swap-remove</td>\n<td>Simpler than transitions</td>\n</tr>\n</tbody></table>\n<p><strong>Archetype Implementation Challenges</strong></p>\n<table>\n<thead>\n<tr>\n<th>Challenge</th>\n<th>Problem</th>\n<th>Solution Approaches</th>\n<th>Trade-offs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Archetype Explosion</td>\n<td>Too many unique component combinations create many small archetypes</td>\n<td>Group similar archetypes, component filtering</td>\n<td>Complexity vs. cache efficiency</td>\n</tr>\n<tr>\n<td>Transition Overhead</td>\n<td>Moving entities between archetypes is expensive</td>\n<td>Batch transitions, lazy updates</td>\n<td>Latency vs. throughput</td>\n</tr>\n<tr>\n<td>Memory Management</td>\n<td>Each archetype needs its own storage allocation</td>\n<td>Chunk-based allocation, archetype pooling</td>\n<td>Memory usage vs. allocation overhead</td>\n</tr>\n<tr>\n<td>Iteration Complexity</td>\n<td>Must iterate multiple archetypes for single query</td>\n<td>Archetype iteration abstractions</td>\n<td>Performance vs. API simplicity</td>\n</tr>\n</tbody></table>\n<p><strong>Archetype Performance Characteristics</strong></p>\n<table>\n<thead>\n<tr>\n<th>Workload Type</th>\n<th>Performance</th>\n<th>Best Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Large homogeneous entity groups</td>\n<td>Excellent</td>\n<td>RTS games with thousands of similar units</td>\n</tr>\n<tr>\n<td>Many different component combinations</td>\n<td>Good</td>\n<td>Complex RPGs with diverse entity types</td>\n</tr>\n<tr>\n<td>Frequent component changes</td>\n<td>Poor</td>\n<td>Highly dynamic gameplay with temporary effects</td>\n</tr>\n<tr>\n<td>Simple queries over large datasets</td>\n<td>Excellent</td>\n<td>Physics simulation, rendering</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Storage Strategy Selection</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to choose component storage approach balancing performance, complexity, and flexibility</li>\n<li><strong>Options Considered</strong>: Simple arrays, sparse sets, archetype-based storage</li>\n<li><strong>Decision</strong>: Implement sparse set approach with optional archetype extension</li>\n<li><strong>Rationale</strong>: Sparse sets provide good performance for most games without archetype complexity; archetypes can be added later for optimization</li>\n<li><strong>Consequences</strong>: Moderate implementation complexity, good query performance, straightforward debugging</li>\n</ul>\n</blockquote>\n<h4 id=\"implementation-strategy-recommendation\">Implementation Strategy Recommendation</h4>\n<p>Based on the trade-offs analysis, this design document recommends a <strong>sparse set foundation with optional archetype extension</strong>:</p>\n<table>\n<thead>\n<tr>\n<th>Implementation Phase</th>\n<th>Storage Approach</th>\n<th>Target Audience</th>\n<th>Performance Characteristics</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Phase 1 (Core)</td>\n<td>Sparse sets for component storage</td>\n<td>Learning ECS concepts</td>\n<td>Good performance, moderate complexity</td>\n</tr>\n<tr>\n<td>Phase 2 (Extension)</td>\n<td>Archetype-based storage optimization</td>\n<td>Advanced performance tuning</td>\n<td>Excellent performance, high complexity</td>\n</tr>\n</tbody></table>\n<p>This progression allows developers to:</p>\n<ol>\n<li><strong>Learn ECS concepts</strong> with a comprehensible sparse set implementation</li>\n<li><strong>Achieve good performance</strong> for most game scenarios  </li>\n<li><strong>Extend to archetypes</strong> when profiling reveals performance bottlenecks</li>\n<li><strong>Understand trade-offs</strong> by implementing both approaches</li>\n</ol>\n<p>The sparse set foundation provides solid performance while remaining debuggable and understandable. The archetype extension demonstrates advanced ECS optimization techniques without overwhelming beginners with unnecessary complexity.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides practical guidance for implementing the ECS concepts discussed above, targeting developers who understand the design rationale and need concrete technical direction.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Entity ID Generation</td>\n<td>Incremental counter with free list</td>\n<td>Generational indices with packed storage</td>\n<td>Simple approach sufficient for learning</td>\n</tr>\n<tr>\n<td>Component Storage</td>\n<td><code>std::vector</code> with <code>std::unordered_map</code></td>\n<td>Custom sparse set implementation</td>\n<td>STL containers provide good starting point</td>\n</tr>\n<tr>\n<td>Type Safety</td>\n<td>Template specialization</td>\n<td>Compile-time type IDs with <code>typeid</code></td>\n<td>Templates catch errors at compile time</td>\n</tr>\n<tr>\n<td>Memory Management</td>\n<td>Standard allocators</td>\n<td>Custom pool allocators</td>\n<td>Standard allocators simplify initial implementation</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-project-structure\">Recommended Project Structure</h4>\n<p>Understanding how ECS components fit together helps avoid the common mistake of putting all code in a single file:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ecs-project/\n├── src/\n│   ├── core/\n│   │   ├── entity.h              ← Entity ID and generation definitions\n│   │   ├── entity.cpp\n│   │   └── entity_manager.h      ← Entity lifecycle management\n│   │   └── entity_manager.cpp\n│   ├── components/\n│   │   ├── component_storage.h   ← Sparse set storage implementation\n│   │   ├── component_storage.cpp\n│   │   └── component_registry.h  ← Type registration and lookup\n│   │   └── component_registry.cpp\n│   ├── systems/\n│   │   ├── system.h              ← Base system interface\n│   │   ├── system_manager.h      ← System execution and ordering\n│   │   └── system_manager.cpp\n│   ├── world/\n│   │   ├── world.h               ← Main ECS coordinator\n│   │   └── world.cpp\n│   └── examples/\n│       ├── game_components.h     ← Sample Position, Velocity, Health components\n│       ├── movement_system.cpp   ← Example system implementation\n│       └── main.cpp              ← Demo application\n├── tests/\n│   ├── entity_tests.cpp\n│   ├── component_tests.cpp\n│   └── system_tests.cpp\n└── include/\n    └── ecs/                      ← Public API headers\n        ├── ecs.h\n        └── component_types.h</code></pre></div>\n\n<p>This structure separates concerns clearly: entities manage IDs, components handle storage, systems provide behavior, and world coordinates everything.</p>\n<h4 id=\"core-data-type-foundations\">Core Data Type Foundations</h4>\n<p>Start with these fundamental types that all other ECS components depend on:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// entity.h - Core entity identification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cstdint></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;limits></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#B392F0\"> EntityID</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#B392F0\"> Generation</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EntityID id;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Generation generation;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement equality and comparison operators</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add invalid entity constant</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Consider hash function for use in containers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// component_id.h - Type-safe component identification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#B392F0\"> ComponentTypeID</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ComponentTypeID</span><span style=\"color:#B392F0\"> getComponentTypeID</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Generate unique ID for component type T</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use static local variable to ensure same ID per type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Consider using typeid(T).hash_code() or manual registration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"entity-manager-implementation-skeleton\">Entity Manager Implementation Skeleton</h4>\n<p>The Entity Manager handles the &quot;library card system&quot; for entity IDs:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// entity_manager.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;queue></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"entity.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EntityManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Generation</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> generations_;</span><span style=\"color:#6A737D\">  // Generation per entity slot</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::queue</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">EntityID</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> free_entities_;</span><span style=\"color:#6A737D\">   // Recycled entity IDs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EntityID next_entity_id_;</span><span style=\"color:#6A737D\">              // Next new entity ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    EntityManager</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Creates new entity with unique ID and current generation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Entity</span><span style=\"color:#B392F0\"> createEntity</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Marks entity as destroyed, increments generation, adds to free list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> destroyEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Validates that entity ID and generation are current</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> isAlive</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Returns all currently alive entities for iteration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement efficient iteration without checking every slot</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">getAliveEntities</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Handle entity ID overflow when next_entity_id_ wraps around</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Decide on initial capacity and growth strategy for generations_</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Consider maximum entity limit to prevent unbounded growth</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p>Key implementation notes:</p>\n<ul>\n<li><code>generations_[entity.id]</code> stores the current generation for that entity slot</li>\n<li>When destroying an entity, increment <code>generations_[entity.id]</code> and add the ID to <code>free_entities_</code></li>\n<li><code>isAlive()</code> returns <code>true</code> only if <code>generations_[entity.id] == entity.generation</code></li>\n<li>Reuse entity IDs from <code>free_entities_</code> before generating new ones</li>\n</ul>\n<h4 id=\"component-storage-implementation-skeleton\">Component Storage Implementation Skeleton</h4>\n<p>Implement the &quot;warehouse with index cards&quot; sparse set storage:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// component_storage.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unordered_map></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;memory></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"entity.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Base class for type-erased component storage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> IComponentStorage</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#B392F0\"> ~IComponentStorage</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> default</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> removeEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> hasComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#B392F0\"> size</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Template specialization for specific component types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ComponentStorage</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#F97583\">public</span><span style=\"color:#B392F0\"> IComponentStorage</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">T</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> dense_;</span><span style=\"color:#6A737D\">                     // Contiguous component data</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> dense_to_entity_;</span><span style=\"color:#6A737D\">     // Maps dense index to entity</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">EntityID, </span><span style=\"color:#F97583\">size_t></span><span style=\"color:#E1E4E8\"> sparse_;</span><span style=\"color:#6A737D\"> // Maps entity ID to dense index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add component to entity, return reference for initialization</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> addComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">T</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#FFAB70\"> component</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">{});</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Remove component from entity (swap-remove from dense array)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> removeComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get component for entity (throws if not found)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> getComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> getComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if entity has this component type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> hasComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> override</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Iterator access for systems</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    auto</span><span style=\"color:#B392F0\"> begin</span><span style=\"color:#E1E4E8\">() { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> dense_.</span><span style=\"color:#B392F0\">begin</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    auto</span><span style=\"color:#B392F0\"> end</span><span style=\"color:#E1E4E8\">() { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> dense_.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get entity corresponding to component at dense index</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Entity</span><span style=\"color:#B392F0\"> getEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> dense_index</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // IComponentStorage interface implementation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> removeEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">override</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#B392F0\"> size</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> override</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> dense_.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement swap-remove logic for removeComponent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Validate entity references in debug builds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Consider sparse array growth strategy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Handle iterator invalidation during component removal</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p>Critical implementation details:</p>\n<ul>\n<li><code>dense_</code> stores actual component data for cache-friendly iteration</li>\n<li><code>sparse_</code> maps entity IDs to indices in <code>dense_</code> for O(1) lookup</li>\n<li><code>dense_to_entity_</code> enables reverse lookup from component to entity</li>\n<li>Swap-remove maintains contiguous storage but changes entity positions</li>\n</ul>\n<h4 id=\"system-interface-foundation\">System Interface Foundation</h4>\n<p>Create the &quot;assembly line stations&quot; framework:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// system.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;memory></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"entity.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> World</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Forward declaration</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> System</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#B392F0\"> ~System</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> default</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Called once per frame with time elapsed since last frame</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Optional: called when system is registered with world</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> onRegister</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Optional: called when system is removed from world</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> onUnregister</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// system_manager.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SystemManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">System</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> systems_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Register system with execution priority (lower = earlier)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> registerSystem</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> priority</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Update all systems in priority order</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> updateSystems</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Remove system by type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> unregisterSystem</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement priority-based system ordering</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Handle system dependencies and cycles</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Consider system groups for batched execution</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"world-coordinator-implementation\">World Coordinator Implementation</h4>\n<p>The World class coordinates all ECS components:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// world.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"entity_manager.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"component_registry.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"system_manager.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> World</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EntityManager entity_manager_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ComponentRegistry component_registry_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SystemManager system_manager_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Entity operations</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Entity</span><span style=\"color:#B392F0\"> createEntity</span><span style=\"color:#E1E4E8\">() { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> entity_manager_.</span><span style=\"color:#B392F0\">createEntity</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> destroyEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> isAlive</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> entity_manager_.</span><span style=\"color:#B392F0\">isAlive</span><span style=\"color:#E1E4E8\">(entity); }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Component operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> addComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">T</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#FFAB70\"> component</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">{});</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> removeComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> getComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> hasComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // System operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> registerSystem</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> priority</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Query operations for systems</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Components</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    auto</span><span style=\"color:#B392F0\"> query</span><span style=\"color:#E1E4E8\">() -> </span><span style=\"color:#B392F0\">QueryIterator</span><span style=\"color:#E1E4E8\">&#x3C;Components...>;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Main update loop</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement component cleanup when entity is destroyed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Handle system registration before vs. after world setup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Consider thread safety for multi-threaded systems</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"example-usage-pattern\">Example Usage Pattern</h4>\n<p>Demonstrate how all pieces work together:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// examples/simple_game.cpp</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"ecs/world.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Sample component types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> Position</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">float</span><span style=\"color:#E1E4E8\"> x, y; };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> Velocity</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">float</span><span style=\"color:#E1E4E8\"> dx, dy; };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> Health</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> current, maximum; };</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Sample system</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MovementSystem</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#F97583\">public</span><span style=\"color:#B392F0\"> System</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">override</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Query entities with Position + Velocity components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Update each position by velocity * deltaTime</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: for (auto [entity, pos, vel] : world.query&#x3C;Position, Velocity>())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    World world;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Register systems</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    world.registerSystem</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">MovementSystem</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\"> // Priority 100</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create entities</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Entity tank </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> world.</span><span style=\"color:#B392F0\">createEntity</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    world.addComponent</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Position</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">(tank, {</span><span style=\"color:#79B8FF\">10.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">5.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">});</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    world.addComponent</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Velocity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">(tank, {</span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">});</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    world.addComponent</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Health</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">(tank, {</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">});</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Game loop</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> deltaTime </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.016</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // 60 FPS</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; frame </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">frame) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        world.</span><span style=\"color:#B392F0\">update</span><span style=\"color:#E1E4E8\">(deltaTime);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Add rendering, input handling, etc.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p>After implementing each major component, verify expected behavior:</p>\n<p><strong>Checkpoint 1: Entity Manager</strong></p>\n<ul>\n<li>Run: <code>./build/entity_tests</code></li>\n<li>Expected: Entity creation returns unique IDs, destroyed entities fail <code>isAlive()</code> checks</li>\n<li>Manual test: Create 1000 entities, destroy every other one, verify only alive entities remain</li>\n</ul>\n<p><strong>Checkpoint 2: Component Storage</strong>  </p>\n<ul>\n<li>Run: <code>./build/component_tests</code></li>\n<li>Expected: Components can be added/removed, iteration visits all components sequentially</li>\n<li>Manual test: Add Position components to 100 entities, iterate and verify all positions are accessible</li>\n</ul>\n<p><strong>Checkpoint 3: System Integration</strong></p>\n<ul>\n<li>Run: <code>./build/system_tests</code> </li>\n<li>Expected: Systems execute in priority order, can query and modify components</li>\n<li>Manual test: Create entities with Position+Velocity, run MovementSystem, verify positions update</li>\n</ul>\n<h4 id=\"language-specific-implementation-notes\">Language-Specific Implementation Notes</h4>\n<p><strong>C++ Specific Guidance:</strong></p>\n<ul>\n<li>Use <code>std::vector</code> for dense arrays — it provides cache-friendly contiguous storage</li>\n<li>Use <code>std::unordered_map</code> for sparse mapping — prefer over <code>std::map</code> for O(1) average lookup</li>\n<li>Leverage templates for type safety — <code>ComponentStorage&lt;Position&gt;</code> catches type errors at compile time</li>\n<li>Consider <code>std::enable_if</code> for concept checking — ensure only valid component types are stored</li>\n<li>Use move semantics for component addition — avoid unnecessary copies of large components</li>\n</ul>\n<p><strong>Memory Management Strategy:</strong></p>\n<ul>\n<li>Start with standard allocators — optimize later only if profiling shows allocation hotspots</li>\n<li>Use RAII for automatic cleanup — destructors handle component storage cleanup</li>\n<li>Consider <code>std::unique_ptr</code> for system storage — clear ownership and automatic destruction</li>\n<li>Reserve vector capacity when possible — reduces reallocations during entity creation bursts</li>\n</ul>\n<p><strong>Performance Monitoring:</strong></p>\n<ul>\n<li>Add timing around <code>world.update()</code> to measure frame time</li>\n<li>Count cache misses using <code>perf stat -e cache-misses ./your_program</code></li>\n<li>Profile with tools like <code>perf record</code> or Visual Studio diagnostics</li>\n<li>Measure memory usage growth over long running sessions</li>\n</ul>\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundation for all milestones — defining scope and success criteria</p>\n</blockquote>\n<p>Before diving into the technical details of our ECS implementation, we must clearly establish what we&#39;re building and, equally important, what we&#39;re not building. Think of this as <strong>drawing the blueprint boundaries</strong> — a construction project needs clear specifications about what features the building will have (number of floors, electrical capacity, plumbing) and what it won&#39;t include (swimming pool, helipad, underground garage). Without these boundaries, scope creep leads to an overly complex system that never gets completed.</p>\n<p>Our ECS architecture targets <strong>learning-focused simplicity</strong> rather than production-grade completeness. This means we prioritize understanding core ECS concepts and achieving solid performance fundamentals over advanced features that would obscure the underlying principles. The goal is to build a system where a junior developer can trace through every line of code and understand exactly why each design decision was made.</p>\n<h3 id=\"functional-goals-entity-lifecycle-component-attachment-system-execution\">Functional Goals: Entity lifecycle, component attachment, system execution</h3>\n<p>The core functionality of our ECS revolves around three fundamental operations that mirror how game objects behave in practice. <strong>Think of it like a theater production</strong> — we need actors (entities), costumes and props (components), and directors for different aspects like lighting and sound (systems). The theater must support hiring and firing actors, changing their costumes between scenes, and having each director work with their relevant actors each night.</p>\n<p>Our functional requirements center on <strong>entity lifecycle management</strong> as the foundational capability. Every game object needs to come into existence with a unique identity, exist for some period while gameplay logic operates on it, and eventually be destroyed when no longer needed. This lifecycle must be robust enough to handle edge cases like accessing destroyed entities or creating thousands of entities in a single frame.</p>\n<table>\n<thead>\n<tr>\n<th>Functional Requirement</th>\n<th>Description</th>\n<th>Success Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Entity Creation</strong></td>\n<td>Generate unique entity identifiers</td>\n<td><code>createEntity()</code> returns unique <code>Entity</code> with valid <code>EntityID</code> and <code>Generation</code></td>\n</tr>\n<tr>\n<td><strong>Entity Validation</strong></td>\n<td>Check if entity reference is still valid</td>\n<td><code>isAlive(Entity)</code> correctly identifies destroyed entities using generation counter</td>\n</tr>\n<tr>\n<td><strong>Entity Destruction</strong></td>\n<td>Clean up entity and mark ID for recycling</td>\n<td><code>destroyEntity(Entity)</code> removes all components and enables ID reuse</td>\n</tr>\n<tr>\n<td><strong>Entity Iteration</strong></td>\n<td>Traverse all living entities efficiently</td>\n<td>Support for range-based iteration over valid entities</td>\n</tr>\n</tbody></table>\n<p><strong>Component attachment and detachment</strong> represents the second pillar of ECS functionality. Unlike traditional object-oriented inheritance where capabilities are fixed at compile time, ECS enables <strong>dynamic composition</strong> where entities gain and lose capabilities during runtime. A player entity might start with just <code>Position</code> and <code>Health</code> components, then gain a <code>Weapon</code> component when picking up a sword, and later acquire a <code>Poisoned</code> component when hit by a toxic attack.</p>\n<p>The component system must maintain <strong>type safety</strong> while supporting this dynamic behavior. When a system requests a <code>Velocity</code> component from an entity, the system should either receive a valid reference to that component&#39;s data or get a clear indication that the entity doesn&#39;t possess that component type. Runtime type errors from casting or accessing wrong component types should be impossible.</p>\n<table>\n<thead>\n<tr>\n<th>Component Operation</th>\n<th>Description</th>\n<th>Success Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Component Addition</strong></td>\n<td>Attach typed data to entity</td>\n<td><code>addComponent&lt;T&gt;(Entity, T&amp;&amp;)</code> stores component and returns reference</td>\n</tr>\n<tr>\n<td><strong>Component Removal</strong></td>\n<td>Detach component type from entity</td>\n<td><code>removeComponent&lt;T&gt;(Entity)</code> cleans up storage and updates indices</td>\n</tr>\n<tr>\n<td><strong>Component Access</strong></td>\n<td>Retrieve component data safely</td>\n<td><code>getComponent&lt;T&gt;(Entity)</code> returns typed reference or throws exception</td>\n</tr>\n<tr>\n<td><strong>Component Queries</strong></td>\n<td>Check component presence</td>\n<td><code>hasComponent&lt;T&gt;(Entity)</code> returns boolean without side effects</td>\n</tr>\n</tbody></table>\n<p><strong>System execution framework</strong> provides the final functional pillar by orchestrating how game logic operates on entities and their components. Think of systems as <strong>specialized assembly line stations</strong> — the rendering system processes all entities with <code>Position</code> and <code>Sprite</code> components to draw them on screen, while the physics system handles entities with <code>Position</code>, <code>Velocity</code>, and <code>Collider</code> components to simulate movement and collisions.</p>\n<p>Systems must be able to <strong>query for entities</strong> matching their required component combinations and <strong>iterate efficiently</strong> over the results. The framework should handle system registration, execution ordering, and provide each system with the frame time delta for time-based updates.</p>\n<table>\n<thead>\n<tr>\n<th>System Capability</th>\n<th>Description</th>\n<th>Success Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>System Registration</strong></td>\n<td>Add systems to execution pipeline</td>\n<td><code>registerSystem&lt;T&gt;(priority, args...)</code> adds system with specified order</td>\n</tr>\n<tr>\n<td><strong>Component Queries</strong></td>\n<td>Find entities with required components</td>\n<td><code>query&lt;Position, Velocity&gt;()</code> returns iterator over matching entities</td>\n</tr>\n<tr>\n<td><strong>Frame Updates</strong></td>\n<td>Execute all systems each frame</td>\n<td><code>update(World&amp;, deltaTime)</code> calls each system in priority order</td>\n</tr>\n<tr>\n<td><strong>System Ordering</strong></td>\n<td>Control execution sequence</td>\n<td>Higher priority systems run before lower priority ones</td>\n</tr>\n</tbody></table>\n<h3 id=\"performance-goals-cache-friendly-iteration-constant-time-lookups-minimal-allocations\">Performance Goals: Cache-friendly iteration, constant-time lookups, minimal allocations</h3>\n<p>Performance represents the primary motivation for choosing ECS over traditional object-oriented architectures. Our performance goals target <strong>data-oriented design principles</strong> that align with modern CPU architectures and memory hierarchies. <strong>Think of CPU cache as a small, fast warehouse</strong> right next to the assembly line — when components are stored contiguously in memory, the CPU can load entire chunks of related data in a single cache line, dramatically reducing the time spent waiting for memory access.</p>\n<p><strong>Cache-friendly iteration</strong> stands as our most critical performance objective. When a physics system processes 10,000 entities with <code>Position</code> and <code>Velocity</code> components, those components should be stored in contiguous arrays that enable efficient sequential access patterns. This organization allows the CPU to prefetch subsequent data elements, utilize SIMD instructions for parallel processing, and minimize cache misses that can stall the processor for hundreds of cycles.</p>\n<p>Traditional object-oriented approaches store each game object as a separate allocation with components scattered throughout memory. When iterating over 10,000 game objects, each memory access potentially triggers a cache miss, resulting in poor performance that scales linearly with the number of objects. Our ECS implementation must demonstrate measurably better cache performance through contiguous component storage.</p>\n<table>\n<thead>\n<tr>\n<th>Performance Target</th>\n<th>Measurement</th>\n<th>Target Value</th>\n<th>Verification Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Cache Miss Rate</strong></td>\n<td>L1 data cache misses per component access</td>\n<td>&lt; 5% for sequential iteration</td>\n<td>CPU performance counters during component iteration</td>\n</tr>\n<tr>\n<td><strong>Memory Bandwidth</strong></td>\n<td>Bytes processed per second during system updates</td>\n<td>&gt; 1 GB/s for simple component updates</td>\n<td>Benchmark 100k+ entities with timer measurements</td>\n</tr>\n<tr>\n<td><strong>Iteration Speed</strong></td>\n<td>Entities processed per millisecond</td>\n<td>&gt; 100k entities/ms for simple operations</td>\n<td>Microbenchmark with position update system</td>\n</tr>\n</tbody></table>\n<p><strong>Constant-time lookups</strong> ensure that accessing components by entity ID doesn&#39;t become a bottleneck as the number of entities grows. When a collision system detects that two entities intersected, it needs to immediately access their <code>Health</code> and <code>Damage</code> components to apply effects. This lookup operation should take the same time whether the world contains 100 entities or 100,000 entities.</p>\n<p>We achieve O(1) lookup performance through <strong>sparse set data structures</strong> that map entity IDs to component indices. The sparse set maintains two arrays — a sparse array indexed by entity ID that points into a dense array containing the actual component data. This approach combines constant-time random access with cache-friendly sequential iteration.</p>\n<table>\n<thead>\n<tr>\n<th>Lookup Operation</th>\n<th>Time Complexity</th>\n<th>Space Overhead</th>\n<th>Implementation Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Component Access by Entity</strong></td>\n<td>O(1) average case</td>\n<td>2x index storage</td>\n<td>Sparse set with entity ID as key</td>\n</tr>\n<tr>\n<td><strong>Component Existence Check</strong></td>\n<td>O(1) worst case</td>\n<td>Minimal</td>\n<td>Sparse array bounds check + validity test</td>\n</tr>\n<tr>\n<td><strong>Entity Validation</strong></td>\n<td>O(1) worst case</td>\n<td>4 bytes per entity</td>\n<td>Generation counter comparison</td>\n</tr>\n</tbody></table>\n<p><strong>Minimal allocations</strong> during gameplay prevents garbage collection pauses and memory fragmentation that can cause frame rate stutters. While entity creation and destruction inevitably require some memory management, component access and system updates should operate on pre-allocated storage without triggering additional heap allocations.</p>\n<p>Our allocation strategy emphasizes <strong>upfront capacity planning</strong> where component storage arrays are sized based on expected peak entity counts. When arrays need to grow, they expand in large chunks to amortize reallocation costs. System updates should perform zero allocations in the common case of processing existing entities.</p>\n<blockquote>\n<p><strong>Design Principle: Zero-Allocation Hot Path</strong></p>\n<p>Once the world is populated with entities and components, the primary game loop should perform zero heap allocations during normal system updates. All temporary data structures, iterators, and component references should use stack allocation or reference existing heap storage.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Allocation Category</th>\n<th>Frequency</th>\n<th>Strategy</th>\n<th>Measurement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Entity Creation</strong></td>\n<td>Infrequent</td>\n<td>Batch allocation with ID recycling</td>\n<td>&lt; 1 allocation per entity on average</td>\n</tr>\n<tr>\n<td><strong>Component Storage Growth</strong></td>\n<td>Rare</td>\n<td>Exponential growth with large chunks</td>\n<td>Amortized O(1) over entity lifetime</td>\n</tr>\n<tr>\n<td><strong>System Updates</strong></td>\n<td>Every frame</td>\n<td>Zero allocations for existing data</td>\n<td>Memory profiler shows no allocations during updates</td>\n</tr>\n</tbody></table>\n<h3 id=\"non-goals-multi-threading-serialization-networking-visual-editors\">Non-Goals: Multi-threading, serialization, networking, visual editors</h3>\n<p>Establishing clear non-goals prevents scope creep and allows us to focus on mastering core ECS concepts before tackling advanced features. <strong>Think of these as features for ECS Architecture 2.0</strong> — important capabilities that build upon the foundation we&#39;re creating, but would significantly complicate the initial implementation and obscure the fundamental principles we&#39;re trying to learn.</p>\n<p><strong>Multi-threading support</strong> represents a major complexity multiplier that would require thread-safe component access, system scheduling across worker threads, and synchronization primitives that can easily introduce deadlocks or race conditions. While production ECS implementations like Unity&#39;s DOTS achieve impressive performance through parallel system execution, the additional complexity would overwhelm developers learning basic ECS concepts.</p>\n<p>Multi-threading in ECS requires sophisticated analysis of system dependencies to determine which systems can run in parallel. A physics system that modifies <code>Position</code> components cannot run simultaneously with a rendering system that reads <code>Position</code> components without careful synchronization. Building this dependency analysis and scheduling system would triple the implementation complexity.</p>\n<blockquote>\n<p><strong>Decision: Single-Threaded Execution Model</strong></p>\n<ul>\n<li><strong>Context</strong>: Multi-threading could improve performance but adds significant complexity to component access, system scheduling, and debugging</li>\n<li><strong>Options Considered</strong>: <ul>\n<li>Single-threaded with simple execution loop</li>\n<li>Multi-threaded with job system and dependency analysis</li>\n<li>Hybrid with optional threading for specific systems</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Single-threaded execution for initial implementation</li>\n<li><strong>Rationale</strong>: Enables focus on core ECS concepts without synchronization complexity; easier debugging and testing; sufficient performance for learning scenarios</li>\n<li><strong>Consequences</strong>: Performance limited to single core utilization; simpler codebase that&#39;s easier to understand and extend</li>\n</ul>\n</blockquote>\n<p><strong>Serialization and persistence</strong> functionality would require defining binary formats for entity data, handling component type information at runtime, versioning schemas as components change, and managing references between entities across save/load boundaries. Each component type would need serialization logic, and the system would need to handle partial saves, corruption recovery, and migration between different data versions.</p>\n<p>The complexity comes not just from the serialization mechanics, but from the architectural changes required to support it. Components might need to store additional metadata, entity references would require translation during deserialization, and system initialization order becomes critical when loading saved worlds.</p>\n<p><strong>Networking and replication</strong> introduces distributed systems challenges including state synchronization, lag compensation, authority resolution when multiple clients modify the same entity, and bandwidth optimization for component updates. ECS networking typically requires classifying components as authoritative vs. replicated, implementing delta compression for component changes, and handling connection drops that leave entities in inconsistent states.</p>\n<p>These features require expertise in distributed systems that goes well beyond ECS architecture. The networking layer would likely become larger and more complex than the ECS implementation itself.</p>\n<p><strong>Visual editors and tooling</strong> would require building GUI systems for entity inspection, component editing, system profiling, and world visualization. While these tools significantly improve developer experience, they represent entire application domains (UI frameworks, graphics rendering, input handling) that would distract from learning ECS principles.</p>\n<table>\n<thead>\n<tr>\n<th>Non-Goal</th>\n<th>Complexity Impact</th>\n<th>Recommended Timeline</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Multi-Threading</strong></td>\n<td>3x implementation complexity</td>\n<td>After mastering single-threaded ECS</td>\n</tr>\n<tr>\n<td><strong>Serialization</strong></td>\n<td>2x codebase size</td>\n<td>After component system is stable</td>\n</tr>\n<tr>\n<td><strong>Networking</strong></td>\n<td>Requires distributed systems expertise</td>\n<td>Advanced project after ECS fundamentals</td>\n</tr>\n<tr>\n<td><strong>Visual Tools</strong></td>\n<td>Separate application domain</td>\n<td>Quality-of-life improvement for later versions</td>\n</tr>\n</tbody></table>\n<p>Our non-goals don&#39;t represent unimportant features — they&#39;re sophisticated capabilities that deserve dedicated focus after mastering the foundational ECS concepts. By explicitly excluding them from our initial scope, we can build a clean, understandable implementation that serves as a solid foundation for these advanced features.</p>\n<blockquote>\n<p><strong>Learning Path Recommendation</strong></p>\n<p>Master the core ECS implementation first: entity lifecycle, component storage, and system execution. Once you can implement these from scratch and understand all the performance trade-offs, tackle one advanced feature at a time. Multi-threading typically provides the biggest performance improvement, while serialization enables the most gameplay features.</p>\n</blockquote>\n<p>The scope boundaries we&#39;ve established ensure our ECS implementation remains focused on teaching data-oriented design principles while delivering measurable performance improvements over object-oriented alternatives. The functional goals provide concrete targets for each milestone, the performance goals ensure we achieve the architectural benefits that justify ECS complexity, and the non-goals prevent scope creep that could derail the project.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This implementation guidance provides concrete technology recommendations and starter code to help you begin building the ECS architecture. The focus is on C++ implementations that demonstrate the performance and type safety principles discussed in the design section.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Memory Management</strong></td>\n<td><code>std::vector</code> with manual sizing</td>\n<td>Custom pool allocators with block management</td>\n</tr>\n<tr>\n<td><strong>Type Information</strong></td>\n<td><code>std::type_index</code> with <code>std::unordered_map</code></td>\n<td>Compile-time type IDs with template metaprogramming</td>\n</tr>\n<tr>\n<td><strong>Container Libraries</strong></td>\n<td>STL containers (<code>std::vector</code>, <code>std::unordered_map</code>)</td>\n<td>Custom containers optimized for ECS access patterns</td>\n</tr>\n<tr>\n<td><strong>Testing Framework</strong></td>\n<td>Google Test with basic assertions</td>\n<td>Google Test + Google Benchmark for performance testing</td>\n</tr>\n<tr>\n<td><strong>Build System</strong></td>\n<td>CMake with simple configuration</td>\n<td>CMake with advanced dependency management and testing targets</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<p>Organize your ECS implementation with clear separation between core components and example usage:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">ecs</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">architecture</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── include</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── ecs</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│       ├── entity_manager.h      ← Entity lifecycle </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> ID management</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│       ├── component_storage.h   ← Component storage </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> sparse sets</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│       ├── system.h              ← System base </span><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> and</span><span style=\"color:#B392F0\"> execution</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│       ├── world.h               ← Main ECS coordinator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│       └── types.h               ← Core type definitions (EntityID, </span><span style=\"color:#B392F0\">Generation</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── src/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── entity_manager.cpp        ← Entity manager implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── component_storage.cpp     ← Component storage implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── system.cpp                ← System execution framework</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── world.cpp                 ← World coordinator implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── examples/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── basic_movement.cpp        ← Simple position/velocity example</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── game_simulation.cpp       ← More complex multi-system example</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── tests/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── entity_manager_test.cpp   ← Entity lifecycle tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── component_storage_test.cpp ← Component operations tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── system_test.cpp           ← System execution tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── performance_benchmark.cpp ← Cache performance and timing tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">└── CMakeLists.txt                ← Build configuration</span></span></code></pre></div>\n\n<h4 id=\"core-type-definitions\">Core Type Definitions</h4>\n<p>Start with these fundamental type definitions that establish the foundation for all ECS operations:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// include/ecs/types.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cstdint></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">namespace</span><span style=\"color:#B392F0\"> ECS</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Entity identifier combining index and generation for safe references</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    using</span><span style=\"color:#B392F0\"> EntityID</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    using</span><span style=\"color:#B392F0\"> Generation</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Component type identification for runtime type safety</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    using</span><span style=\"color:#B392F0\"> ComponentTypeID</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Complete entity reference with generation counter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        EntityID id;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Generation generation;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">==</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> id </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> other.id </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> generation </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> other.generation;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">!=</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#E1E4E8\"> other);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Sentinel values for invalid references</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    constexpr</span><span style=\"color:#E1E4E8\"> EntityID INVALID_ENTITY_ID </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    constexpr</span><span style=\"color:#E1E4E8\"> Generation DEFAULT_GENERATION </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    constexpr</span><span style=\"color:#E1E4E8\"> Entity INVALID_ENTITY </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {INVALID_ENTITY_ID, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"sample-component-definitions\">Sample Component Definitions</h4>\n<p>Define example components that demonstrate different data patterns common in game development:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// examples/components.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">namespace</span><span style=\"color:#B392F0\"> ECS</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Position component for spatial representation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> Position</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        float</span><span style=\"color:#E1E4E8\"> x, y;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Position</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> x</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> y</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">) : </span><span style=\"color:#B392F0\">x</span><span style=\"color:#E1E4E8\">(x), </span><span style=\"color:#B392F0\">y</span><span style=\"color:#E1E4E8\">(y) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Velocity component for movement</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> Velocity</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        float</span><span style=\"color:#E1E4E8\"> dx, dy;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Velocity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> dx</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> dy</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">) : </span><span style=\"color:#B392F0\">dx</span><span style=\"color:#E1E4E8\">(dx), </span><span style=\"color:#B392F0\">dy</span><span style=\"color:#E1E4E8\">(dy) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Health component with current and maximum values</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> Health</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> current;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> maximum;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Health</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> max_health</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">) : </span><span style=\"color:#B392F0\">current</span><span style=\"color:#E1E4E8\">(max_health), </span><span style=\"color:#B392F0\">maximum</span><span style=\"color:#E1E4E8\">(max_health) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#B392F0\"> isAlive</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> current </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void</span><span style=\"color:#B392F0\"> takeDamage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> damage</span><span style=\"color:#E1E4E8\">) { current </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">max</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, current </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> damage); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void</span><span style=\"color:#B392F0\"> heal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> amount</span><span style=\"color:#E1E4E8\">) { current </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">min</span><span style=\"color:#E1E4E8\">(maximum, current </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> amount); }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"entity-manager-skeleton\">Entity Manager Skeleton</h4>\n<p>The entity manager handles ID generation, lifecycle tracking, and ID recycling:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// include/ecs/entity_manager.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"types.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;queue></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">namespace</span><span style=\"color:#B392F0\"> ECS</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    class</span><span style=\"color:#B392F0\"> EntityManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Generation</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> generations_;</span><span style=\"color:#6A737D\">  // Generation counter per entity index</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::queue</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">EntityID</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> free_ids_;</span><span style=\"color:#6A737D\">       // Recycled entity IDs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        EntityID next_id_;</span><span style=\"color:#6A737D\">                    // Next ID to allocate if no recycled IDs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        EntityManager</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Create new entity with unique ID and generation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Entity</span><span style=\"color:#B392F0\"> createEntity</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Mark entity as destroyed and recycle its ID</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void</span><span style=\"color:#B392F0\"> destroyEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check if entity reference is still valid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#B392F0\"> isAlive</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Get current number of alive entities</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#B392F0\"> getAliveCount</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Iterator support for traversing all alive entities</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        class</span><span style=\"color:#B392F0\"> EntityIterator</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // TODO: Implement iterator class</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        EntityIterator</span><span style=\"color:#B392F0\"> begin</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        EntityIterator</span><span style=\"color:#B392F0\"> end</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"component-storage-interface\">Component Storage Interface</h4>\n<p>Define the interface for type-erased component storage operations:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// include/ecs/component_storage.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"types.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;memory></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unordered_map></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">namespace</span><span style=\"color:#B392F0\"> ECS</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Base interface for type-erased component operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    class</span><span style=\"color:#B392F0\"> IComponentStorage</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        virtual</span><span style=\"color:#B392F0\"> ~IComponentStorage</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> default</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        virtual</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> removeComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        virtual</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> hasComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        virtual</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#B392F0\"> getComponentCount</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Template implementation for type-specific component storage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    class</span><span style=\"color:#B392F0\"> ComponentStorage</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#F97583\">public</span><span style=\"color:#B392F0\"> IComponentStorage</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">T</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> components_;</span><span style=\"color:#6A737D\">           // Dense array of component data</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">EntityID</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> entity_ids_;</span><span style=\"color:#6A737D\">   // Entity ID for each component</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">EntityID, </span><span style=\"color:#F97583\">size_t></span><span style=\"color:#E1E4E8\"> entity_to_index_;</span><span style=\"color:#6A737D\"> // Sparse mapping</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Add component to entity with perfect forwarding</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> addComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Remove component from entity using swap-remove</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void</span><span style=\"color:#B392F0\"> removeComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">override</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Get component reference for entity</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> getComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> getComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check if entity has this component type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#B392F0\"> hasComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> override</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Get total number of components stored</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#B392F0\"> getComponentCount</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> override</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Iterator support for efficient component traversal</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        typename</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">>::</span><span style=\"color:#B392F0\">iterator</span><span style=\"color:#B392F0\"> begin</span><span style=\"color:#E1E4E8\">() { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> components_.</span><span style=\"color:#B392F0\">begin</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        typename</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">>::</span><span style=\"color:#B392F0\">iterator</span><span style=\"color:#B392F0\"> end</span><span style=\"color:#E1E4E8\">() { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> components_.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        typename</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">>::</span><span style=\"color:#B392F0\">const_iterator</span><span style=\"color:#B392F0\"> begin</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> components_.</span><span style=\"color:#B392F0\">begin</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        typename</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">>::</span><span style=\"color:#B392F0\">const_iterator</span><span style=\"color:#B392F0\"> end</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> components_.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"system-base-class\">System Base Class</h4>\n<p>Systems define the interface for game logic that operates on entities with specific component combinations:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// include/ecs/system.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">namespace</span><span style=\"color:#B392F0\"> ECS</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    class</span><span style=\"color:#B392F0\"> World</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Forward declaration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Base class for all systems</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    class</span><span style=\"color:#B392F0\"> System</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        virtual</span><span style=\"color:#B392F0\"> ~System</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> default</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Called each frame with delta time in seconds</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        virtual</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Optional initialization when system is registered</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        virtual</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> initialize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Optional cleanup when system is removed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        virtual</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> shutdown</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"world-coordinator-skeleton\">World Coordinator Skeleton</h4>\n<p>The World class coordinates all ECS components and provides the main API:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// include/ecs/world.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"entity_manager.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"component_storage.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"system.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;memory></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unordered_map></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;typeindex></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">namespace</span><span style=\"color:#B392F0\"> ECS</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    class</span><span style=\"color:#B392F0\"> World</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        EntityManager entity_manager_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::type_index, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">IComponentStorage</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> component_storages_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::pair</span><span style=\"color:#F97583\">&#x3C;int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">System</span><span style=\"color:#F97583\">>>></span><span style=\"color:#E1E4E8\"> systems_;</span><span style=\"color:#6A737D\"> // priority, system</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Helper to get or create component storage for type T</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ComponentStorage</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> getComponentStorage</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        World</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> default</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ~World</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> default</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Entity operations</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Entity</span><span style=\"color:#B392F0\"> createEntity</span><span style=\"color:#E1E4E8\">() { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> entity_manager_.</span><span style=\"color:#B392F0\">createEntity</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void</span><span style=\"color:#B392F0\"> destroyEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#B392F0\"> isAlive</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> entity_manager_.</span><span style=\"color:#B392F0\">isAlive</span><span style=\"color:#E1E4E8\">(entity); }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Component operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> addComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void</span><span style=\"color:#B392F0\"> removeComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> getComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> getComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#B392F0\"> hasComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // System operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void</span><span style=\"color:#B392F0\"> registerSystem</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> priority</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void</span><span style=\"color:#B392F0\"> update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Query interface for finding entities with specific components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Components</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#B392F0\"> query</span><span style=\"color:#E1E4E8\">();</span><span style=\"color:#6A737D\"> // TODO: Implement query iterator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p>After implementing each milestone, verify functionality with these concrete tests:</p>\n<p><strong>Milestone 1: Entity Manager</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Compile and run entity manager tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">g++</span><span style=\"color:#79B8FF\"> -std=c++17</span><span style=\"color:#79B8FF\"> -I</span><span style=\"color:#9ECBFF\"> include</span><span style=\"color:#9ECBFF\"> tests/entity_manager_test.cpp</span><span style=\"color:#9ECBFF\"> src/entity_manager.cpp</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> test_entities</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./test_entities</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output should show:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Unique entity IDs generated for each createEntity() call</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - isAlive() returns false for destroyed entities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - ID recycling reuses destroyed entity IDs with incremented generations</span></span></code></pre></div>\n\n<p><strong>Milestone 2: Component Storage</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Compile and run component storage tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">g++</span><span style=\"color:#79B8FF\"> -std=c++17</span><span style=\"color:#79B8FF\"> -I</span><span style=\"color:#9ECBFF\"> include</span><span style=\"color:#9ECBFF\"> tests/component_storage_test.cpp</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> test_components</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./test_components</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected behavior:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Adding components increases storage size and enables hasComponent() lookup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Removing components decreases size and swap-removes maintain dense packing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - getComponent() returns correct references that can be modified</span></span></code></pre></div>\n\n<p><strong>Milestone 3: System Interface</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Compile and run basic movement example</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">g++</span><span style=\"color:#79B8FF\"> -std=c++17</span><span style=\"color:#79B8FF\"> -I</span><span style=\"color:#9ECBFF\"> include</span><span style=\"color:#9ECBFF\"> examples/basic_movement.cpp</span><span style=\"color:#9ECBFF\"> src/</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#9ECBFF\">.cpp</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> basic_movement</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./basic_movement</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Systems execute in priority order each frame</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Movement system updates Position components based on Velocity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Frame delta time properly scales movement calculations</span></span></code></pre></div>\n\n<h4 id=\"performance-validation\">Performance Validation</h4>\n<p>Use these benchmarks to verify cache-friendly performance characteristics:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// tests/performance_benchmark.cpp (skeleton)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;chrono></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;iostream></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"ecs/world.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> benchmarkComponentIteration</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create 100,000 entities with Position and Velocity components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Measure time to iterate through all Position components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Compare with pointer-chasing approach (vector of pointers)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify >10x performance improvement for sequential access</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> benchmarkComponentLookup</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create entities and measure getComponent() lookup time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify O(1) performance regardless of entity count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test with 1k, 10k, 100k entities to confirm constant time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>This implementation guidance provides the foundation for building a performant ECS architecture while maintaining focus on learning core concepts. The modular structure enables incremental development where each milestone builds upon previous work without requiring major refactoring.</p>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundation for Milestones 1-4 — understanding the overall ECS structure and component interactions</p>\n</blockquote>\n<p>Our ECS architecture consists of four main components working together to achieve data-oriented design principles. Think of the ECS as a <strong>digital library management system</strong> where entities are library cards, components are the books and resources attached to each card, systems are the librarians who process specific types of materials, and the optional archetype optimization is like organizing books by genre for faster processing.</p>\n<p><img src=\"/api/project/ecs-arch/architecture-doc/asset?path=diagrams%2Fecs-overview.svg\" alt=\"ECS Architecture Overview\"></p>\n<p>The architecture separates concerns cleanly: the <code>EntityManager</code> handles the identity and lifecycle of game objects, <code>ComponentStorage</code> manages the actual data in cache-friendly layouts, the <code>System</code> interface provides the framework for game logic execution, and optional <code>Archetype</code> storage optimizes for maximum performance by grouping similar entities together. This separation enables the composition over inheritance principle that makes ECS so powerful for game development.</p>\n<p>Each component has a specific responsibility and communicates with others through well-defined interfaces. The <code>World</code> class serves as the central coordinator, orchestrating interactions between all components while maintaining the data flow patterns that enable efficient frame-by-frame game updates.</p>\n<h3 id=\"component-responsibilities\">Component Responsibilities</h3>\n<p>The ECS architecture divides responsibilities among four core components, each with distinct ownership and clear boundaries. Understanding these responsibilities is crucial because violations lead to the performance problems and coupling issues that ECS is designed to solve.</p>\n<h4 id=\"entity-manager-responsibilities\">Entity Manager Responsibilities</h4>\n<p>The <code>EntityManager</code> serves as the <strong>identity authority</strong> for the entire ECS system. Think of it as the <strong>DMV office</strong> that issues unique identification numbers and tracks which IDs are currently valid. Its primary responsibility is ensuring that every entity in the system has a unique, stable identity that can be safely referenced by other components.</p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Why Important</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unique ID Generation</td>\n<td>Creates <code>EntityID</code> values that are never duplicated during runtime</td>\n<td>Prevents entity confusion and reference conflicts</td>\n</tr>\n<tr>\n<td>Generation Management</td>\n<td>Maintains <code>Generation</code> counters to invalidate stale entity references</td>\n<td>Eliminates dangling pointer equivalent bugs in ECS</td>\n</tr>\n<tr>\n<td>Lifecycle Tracking</td>\n<td>Tracks which entities are alive, dead, or available for recycling</td>\n<td>Enables safe iteration and memory management</td>\n</tr>\n<tr>\n<td>ID Recycling</td>\n<td>Reuses destroyed entity IDs to prevent memory growth in long-running games</td>\n<td>Critical for games that create/destroy many entities</td>\n</tr>\n</tbody></table>\n<p>The <code>EntityManager</code> owns the master entity registry and is the single source of truth for entity existence. It does not store component data or execute game logic—those are the responsibilities of other components. When a system needs to know if an entity reference is valid, it asks the <code>EntityManager</code>. When component storage needs to clean up data for a destroyed entity, it coordinates with the <code>EntityManager</code>.</p>\n<blockquote>\n<p><strong>Decision: Single Entity Manager vs Distributed ID Generation</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to generate unique entity IDs and track entity lifecycle across the entire ECS system</li>\n<li><strong>Options Considered</strong>: Centralized <code>EntityManager</code>, distributed ID generation per system, globally unique timestamps</li>\n<li><strong>Decision</strong>: Single centralized <code>EntityManager</code> with generation counters</li>\n<li><strong>Rationale</strong>: Centralized management ensures ID uniqueness without coordination overhead, generation counters provide safety against stale references, and a single authority simplifies debugging and validation</li>\n<li><strong>Consequences</strong>: Single point of truth for entity existence, potential bottleneck for massive entity creation (but this is rare), simplified system design</li>\n</ul>\n</blockquote>\n<h4 id=\"component-storage-responsibilities\">Component Storage Responsibilities</h4>\n<p>The <code>ComponentStorage</code> system is responsible for the <strong>data organization and access patterns</strong> that make ECS performant. Think of it as a <strong>specialized warehouse</strong> with different storage areas optimized for different types of inventory, where the warehouse manager (sparse set) keeps track of which items belong to which customers.</p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Why Important</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cache-Friendly Layout</td>\n<td>Stores components in contiguous arrays for efficient iteration</td>\n<td>Enables SIMD operations and minimizes cache misses</td>\n</tr>\n<tr>\n<td>Constant-Time Lookup</td>\n<td>Maps entity IDs to component indices using sparse sets</td>\n<td>Systems can access specific entity components without searching</td>\n</tr>\n<tr>\n<td>Type Safety</td>\n<td>Ensures component access matches expected types at compile time</td>\n<td>Prevents runtime errors from component type confusion</td>\n</tr>\n<tr>\n<td>Dynamic Composition</td>\n<td>Adds and removes components without affecting other entity data</td>\n<td>Enables flexible entity composition during gameplay</td>\n</tr>\n</tbody></table>\n<p>The component storage owns all component data and the mapping between entities and their components. It does not know about entity lifecycle (that&#39;s the <code>EntityManager</code>&#39;s job) or game logic (that&#39;s the <code>System</code>&#39;s responsibility). Each component type gets its own storage instance, and the system provides a unified interface for type-safe access.</p>\n<blockquote>\n<p><strong>Decision: Sparse Set vs Hash Map for Entity-Component Mapping</strong></p>\n<ul>\n<li><strong>Context</strong>: Need constant-time lookup from entity ID to component data while maintaining cache-friendly iteration</li>\n<li><strong>Options Considered</strong>: Hash maps, binary search trees, sparse sets, linear arrays</li>\n<li><strong>Decision</strong>: Sparse set data structure with dense array for components</li>\n<li><strong>Rationale</strong>: Sparse sets provide O(1) insertion, deletion, and lookup while maintaining dense storage for cache-friendly iteration; hash maps have poor iteration performance; arrays require linear search</li>\n<li><strong>Consequences</strong>: Excellent iteration performance for systems, O(1) component access, memory overhead for sparse array, complexity in implementation</li>\n</ul>\n</blockquote>\n<h4 id=\"system-interface-responsibilities\">System Interface Responsibilities</h4>\n<p>The <code>System</code> interface provides the <strong>execution framework</strong> for game logic while maintaining the data-oriented design principles. Think of systems as <strong>specialized factory workers</strong> on an assembly line, where each worker processes specific types of components and passes the entities along to the next worker.</p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Why Important</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Game Logic Execution</td>\n<td>Implements specific behaviors that operate on component data</td>\n<td>Separates behavior from data storage for modularity</td>\n</tr>\n<tr>\n<td>Component Queries</td>\n<td>Specifies which component combinations the system requires</td>\n<td>Enables automatic entity filtering and iteration</td>\n</tr>\n<tr>\n<td>Frame Ordering</td>\n<td>Defines execution priority and dependencies between systems</td>\n<td>Ensures game logic runs in the correct sequence</td>\n</tr>\n<tr>\n<td>Delta Time Processing</td>\n<td>Receives frame time for time-based updates and animations</td>\n<td>Enables frame-rate independent game behavior</td>\n</tr>\n</tbody></table>\n<p>Systems own the game logic but do not own entity or component data. They operate through queries that ask the component storage &quot;give me all entities that have components X, Y, and Z&quot; and then process those entities. Systems declare their dependencies and execution order, allowing the <code>SystemManager</code> to schedule them correctly.</p>\n<blockquote>\n<p><strong>Decision: Push vs Pull System Execution Model</strong></p>\n<ul>\n<li><strong>Context</strong>: Systems need to process entities with specific component combinations each frame</li>\n<li><strong>Options Considered</strong>: Push model (components notify systems), pull model (systems query components), hybrid event/query model</li>\n<li><strong>Decision</strong>: Pull model with explicit component queries</li>\n<li><strong>Rationale</strong>: Pull model gives systems control over iteration order and timing, easier to reason about data dependencies, simpler threading model, explicit queries make system requirements visible</li>\n<li><strong>Consequences</strong>: Systems must explicitly query for data each frame, no automatic reactivity, but predictable execution and clear data flow</li>\n</ul>\n</blockquote>\n<h4 id=\"world-coordinator-responsibilities\">World Coordinator Responsibilities</h4>\n<p>The <code>World</code> class serves as the <strong>central coordinator</strong> that orchestrates interactions between all ECS components. Think of it as the <strong>conductor of an orchestra</strong>, ensuring that each section (entities, components, systems) plays their part at the right time and in harmony with the others.</p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Why Important</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Component Integration</td>\n<td>Provides unified interface to <code>EntityManager</code>, <code>ComponentStorage</code>, and <code>SystemManager</code></td>\n<td>Single entry point simplifies ECS usage and reduces coupling</td>\n</tr>\n<tr>\n<td>Frame Orchestration</td>\n<td>Coordinates the update cycle across all systems each frame</td>\n<td>Ensures consistent timing and execution order</td>\n</tr>\n<tr>\n<td>Resource Management</td>\n<td>Manages memory and cleanup across all ECS components</td>\n<td>Prevents resource leaks and maintains performance</td>\n</tr>\n<tr>\n<td>API Simplification</td>\n<td>Hides internal complexity behind clean, type-safe methods</td>\n<td>Makes ECS accessible to gameplay programmers</td>\n</tr>\n</tbody></table>\n<p>The <code>World</code> owns instances of all other ECS components and coordinates their interactions. It does not implement storage or logic directly—instead, it delegates to the appropriate specialized component. Game code interacts primarily with the <code>World</code>, which handles the complexity of routing requests to the correct underlying systems.</p>\n<h3 id=\"recommended-file-structure\">Recommended File Structure</h3>\n<p>Organizing ECS code properly from the start prevents the monolithic files and circular dependencies that plague many ECS implementations. Our file structure mirrors the component responsibilities and creates clear module boundaries that support both compilation speed and maintainability.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ecs-architecture/\n├── include/\n│   └── ecs/\n│       ├── world.h                    ← Main ECS interface\n│       ├── entity/\n│       │   ├── entity_manager.h       ← Entity lifecycle and ID management\n│       │   └── entity_types.h         ← Entity, EntityID, Generation types\n│       ├── component/\n│       │   ├── component_storage.h    ← Generic component storage interface\n│       │   ├── sparse_set.h           ← Sparse set implementation\n│       │   └── component_types.h      ← ComponentTypeID and registration\n│       ├── system/\n│       │   ├── system.h               ← System base class and interfaces\n│       │   ├── system_manager.h       ← System registration and execution\n│       │   └── query.h                ← Component query implementation\n│       └── archetype/                 ← Advanced archetype optimization\n│           ├── archetype.h            ← Archetype identification and storage\n│           └── archetype_manager.h    ← Archetype-based component storage\n├── src/\n│   ├── world.cpp                      ← World implementation\n│   ├── entity/\n│   │   ├── entity_manager.cpp         ← Entity ID generation and recycling\n│   │   └── entity_types.cpp           ← Entity utility functions\n│   ├── component/\n│   │   ├── component_storage.cpp      ← Storage implementation\n│   │   └── sparse_set.cpp             ← Sparse set operations\n│   ├── system/\n│   │   ├── system_manager.cpp         ← System execution scheduling\n│   │   └── query.cpp                  ← Query filtering and iteration\n│   └── archetype/\n│       ├── archetype.cpp              ← Archetype operations\n│       └── archetype_manager.cpp      ← Archetype-based storage\n├── examples/\n│   ├── basic_ecs/\n│   │   ├── components.h               ← Position, Velocity, Health components\n│   │   ├── systems.h                  ← Movement, Collision systems\n│   │   └── main.cpp                   ← Simple ECS usage example\n│   └── performance_test/\n│       ├── benchmark.cpp              ← Performance comparison tests\n│       └── stress_test.cpp            ← Large entity count testing\n└── tests/\n    ├── entity/\n    │   ├── test_entity_manager.cpp    ← Entity lifecycle tests\n    │   └── test_entity_recycling.cpp  ← ID recycling verification\n    ├── component/\n    │   ├── test_component_storage.cpp  ← Component CRUD operations\n    │   └── test_sparse_set.cpp         ← Sparse set correctness\n    ├── system/\n    │   ├── test_system_execution.cpp   ← System ordering and updates\n    │   └── test_component_queries.cpp  ← Query filtering tests\n    └── integration/\n        ├── test_full_ecs.cpp           ← End-to-end ECS scenarios\n        └── test_performance.cpp        ← Cache performance verification</code></pre></div>\n\n<blockquote>\n<p><strong>Design Insight: Module Boundaries Prevent Coupling</strong></p>\n<p>The file structure enforces the separation of concerns by making dependencies explicit. The <code>entity/</code> module cannot include headers from <code>system/</code> without clearly violating the architecture. This prevents the gradual coupling that destroys ECS performance benefits.</p>\n</blockquote>\n<p>Each directory represents a distinct module with specific responsibilities:</p>\n<table>\n<thead>\n<tr>\n<th>Module</th>\n<th>Purpose</th>\n<th>Dependencies</th>\n<th>What It Cannot Access</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>entity/</code></td>\n<td>Entity identity and lifecycle</td>\n<td>None (foundation module)</td>\n<td>Component data, system logic</td>\n</tr>\n<tr>\n<td><code>component/</code></td>\n<td>Data storage and access</td>\n<td><code>entity/</code> for EntityID types</td>\n<td>System logic, entity lifecycle</td>\n</tr>\n<tr>\n<td><code>system/</code></td>\n<td>Game logic execution framework</td>\n<td><code>entity/</code> and <code>component/</code> for queries</td>\n<td>Direct component storage access</td>\n</tr>\n<tr>\n<td><code>archetype/</code></td>\n<td>Performance optimization</td>\n<td>All other modules</td>\n<td>N/A (advanced feature)</td>\n</tr>\n</tbody></table>\n<p>The <code>examples/</code> directory provides complete, working demonstrations of ECS usage patterns. The <code>basic_ecs</code> example shows how to create entities, add components, and implement simple systems. The <code>performance_test</code> example demonstrates the cache efficiency gains and provides benchmarking code for validation.</p>\n<blockquote>\n<p><strong>Decision: Header-Only vs Compiled Library Structure</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to balance compilation speed, template instantiation, and ease of integration</li>\n<li><strong>Options Considered</strong>: Fully header-only library, fully compiled library, hybrid approach with template headers</li>\n<li><strong>Decision</strong>: Hybrid approach with implementation files for non-template code</li>\n<li><strong>Rationale</strong>: Template components like <code>ComponentStorage&lt;T&gt;</code> must be header-only for type safety; non-template code like <code>EntityManager</code> can be compiled separately for faster builds; hybrid approach balances performance and compilation speed</li>\n<li><strong>Consequences</strong>: Faster compilation than header-only, more complex build than fully compiled, but optimal for C++ template-heavy code</li>\n</ul>\n</blockquote>\n<h3 id=\"data-flow-patterns\">Data Flow Patterns</h3>\n<p>Understanding how data flows through the ECS system is crucial for both implementation and debugging. The data flow follows a <strong>request-response pattern</strong> where systems make explicit queries for the data they need, rather than data being pushed to systems automatically.</p>\n<h4 id=\"entity-creation-flow\">Entity Creation Flow</h4>\n<p>The entity creation process demonstrates how the different ECS components collaborate to maintain consistency and performance. This flow happens when game code calls <code>world.createEntity()</code> and begins adding components.</p>\n<ol>\n<li><strong>World Delegation</strong>: The <code>World</code> receives the creation request and delegates to the <code>EntityManager</code></li>\n<li><strong>ID Generation</strong>: The <code>EntityManager</code> either reuses a recycled ID or generates a new unique <code>EntityID</code></li>\n<li><strong>Generation Assignment</strong>: A new <code>Generation</code> counter is assigned to prevent stale reference issues</li>\n<li><strong>Entity Registration</strong>: The new <code>Entity</code> (combining ID and generation) is marked as alive in the entity registry</li>\n<li><strong>Return to Caller</strong>: The <code>Entity</code> handle is returned to game code for component attachment</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Step</th>\n<th>Component Responsible</th>\n<th>Data Modified</th>\n<th>Validation Required</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Request Routing</td>\n<td><code>World</code></td>\n<td>None</td>\n<td>None</td>\n</tr>\n<tr>\n<td>ID Allocation</td>\n<td><code>EntityManager</code></td>\n<td>Free list, entity registry</td>\n<td>Check free list availability</td>\n</tr>\n<tr>\n<td>Generation Increment</td>\n<td><code>EntityManager</code></td>\n<td>Generation counter</td>\n<td>Handle overflow (wrap to 1)</td>\n</tr>\n<tr>\n<td>Status Update</td>\n<td><code>EntityManager</code></td>\n<td>Alive entity set</td>\n<td>Ensure ID not already alive</td>\n</tr>\n<tr>\n<td>Response</td>\n<td><code>World</code></td>\n<td>None</td>\n<td>Validate entity creation success</td>\n</tr>\n</tbody></table>\n<h4 id=\"component-attachment-flow\">Component Attachment Flow</h4>\n<p>Component attachment shows how the ECS maintains the sparse set mappings that enable efficient queries while preserving cache-friendly iteration. This flow occurs when game code calls <code>world.addComponent&lt;Position&gt;(entity, position)</code>.</p>\n<ol>\n<li><strong>Type Registration</strong>: The <code>ComponentStorage</code> system ensures the component type is registered and has allocated storage</li>\n<li><strong>Entity Validation</strong>: The request validates that the target entity is alive through the <code>EntityManager</code></li>\n<li><strong>Sparse Set Update</strong>: The entity ID is mapped to the next available dense array index</li>\n<li><strong>Component Storage</strong>: The component data is placed in the dense array at the mapped index</li>\n<li><strong>Index Mapping</strong>: The bidirectional sparse set mapping is completed for O(1) future access</li>\n</ol>\n<blockquote>\n<p><strong>Critical Data Flow Insight</strong></p>\n<p>Component attachment never triggers system execution automatically. Systems only see new components when they perform their next query during the update cycle. This prevents the cascading update problems that plague reactive architectures.</p>\n</blockquote>\n<h4 id=\"system-update-cycle\">System Update Cycle</h4>\n<p>The system update cycle represents the core game loop where all entity processing happens. This cycle runs every frame and demonstrates how systems query for entities and process components without interfering with each other.</p>\n<ol>\n<li><strong>Frame Initialization</strong>: The <code>World</code> begins a new frame update with delta time calculation</li>\n<li><strong>System Iteration</strong>: Systems execute in priority order defined during registration</li>\n<li><strong>Component Query</strong>: Each system queries for entities matching its required component combination</li>\n<li><strong>Entity Iteration</strong>: The system processes each matching entity using the component data</li>\n<li><strong>Component Modification</strong>: Systems modify component data directly in the dense storage arrays</li>\n<li><strong>Frame Completion</strong>: All systems finish, and the frame cycle prepares for the next update</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Phase</th>\n<th>System Action</th>\n<th>Component Storage Response</th>\n<th>Performance Consideration</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Query Specification</td>\n<td>Declares required components</td>\n<td>Identifies matching entities</td>\n<td>Query compilation can be cached</td>\n</tr>\n<tr>\n<td>Entity Filtering</td>\n<td>Requests entity list</td>\n<td>Returns iterator over dense arrays</td>\n<td>Cache-friendly linear iteration</td>\n</tr>\n<tr>\n<td>Component Access</td>\n<td>Requests specific component</td>\n<td>Returns direct reference</td>\n<td>No indirection or validation overhead</td>\n</tr>\n<tr>\n<td>Data Modification</td>\n<td>Updates component values</td>\n<td>Stores in dense array</td>\n<td>SIMD-friendly memory access pattern</td>\n</tr>\n</tbody></table>\n<p>The query mechanism is designed for maximum cache efficiency. When a system requests entities with <code>Position</code> and <code>Velocity</code> components, the component storage returns iterators that traverse the dense arrays in lockstep, ensuring that related data is accessed together.</p>\n<blockquote>\n<p><strong>Decision: Immediate vs Deferred Component Modifications</strong></p>\n<ul>\n<li><strong>Context</strong>: Systems need to modify components during iteration without breaking other systems in the same frame</li>\n<li><strong>Options Considered</strong>: Immediate modification in place, deferred modification with command buffers, copy-on-write snapshots</li>\n<li><strong>Decision</strong>: Immediate in-place modification with iteration safety guarantees</li>\n<li><strong>Rationale</strong>: In-place modification has zero allocation overhead and maximum cache performance; ECS iteration patterns naturally avoid modification conflicts; command buffers add complexity and memory overhead</li>\n<li><strong>Consequences</strong>: Systems must be careful about structural changes (adding/removing components) during iteration, but component value changes are safe and optimal</li>\n</ul>\n</blockquote>\n<h4 id=\"query-execution-patterns\">Query Execution Patterns</h4>\n<p>Component queries form the bridge between system logic and component data. The query execution pattern ensures that systems receive exactly the entities they need while maintaining optimal iteration performance.</p>\n<p>Systems specify their component requirements through template parameters: <code>query&lt;Position, Velocity&gt;()</code> requests all entities that have both components. The query system then coordinates with the component storage to find the intersection of entities across multiple component types.</p>\n<p>The query execution follows these patterns:</p>\n<p><strong>Single Component Query</strong>: Direct iteration over the dense array for that component type. This is the fastest query pattern since it requires no entity filtering—every element in the dense array is a valid result.</p>\n<p><strong>Multi-Component Query</strong>: Intersection of entity sets across component types. The query system iterates over the smallest component set and checks for the presence of other required components. This maintains cache efficiency while ensuring correctness.</p>\n<p><strong>Component Exclusion</strong>: Systems can specify components that entities must NOT have. This enables patterns like &quot;all entities with Position but without Velocity&quot; for static object processing.</p>\n<p>The query results provide direct access to component data without additional indirection. When a system iterates over query results, it receives references to the actual component instances stored in the dense arrays, enabling maximum performance for data processing.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The ECS architecture requires careful attention to template design, memory management, and performance characteristics. The following guidance provides concrete implementation patterns and technology recommendations for building a production-quality ECS system.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Approach</th>\n<th>Advanced Approach</th>\n<th>Performance Trade-off</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Entity ID Storage</td>\n<td><code>std::vector&lt;bool&gt;</code> for alive tracking</td>\n<td>Custom packed bitset with population count</td>\n<td>Memory vs. iteration speed</td>\n</tr>\n<tr>\n<td>Component Arrays</td>\n<td><code>std::vector&lt;T&gt;</code> with manual management</td>\n<td>Memory pool with chunk allocation</td>\n<td>Simplicity vs. allocation performance</td>\n</tr>\n<tr>\n<td>Sparse Set Implementation</td>\n<td>Separate sparse and dense <code>std::vector</code></td>\n<td>Single allocation with offset pointers</td>\n<td>Memory fragmentation vs. cache locality</td>\n</tr>\n<tr>\n<td>Type Registration</td>\n<td><code>std::unordered_map</code> with type hashing</td>\n<td>Compile-time type ID generation</td>\n<td>Runtime flexibility vs. compile-time optimization</td>\n</tr>\n<tr>\n<td>System Scheduling</td>\n<td><code>std::vector</code> with manual ordering</td>\n<td>Dependency graph with topological sort</td>\n<td>Implementation complexity vs. automatic ordering</td>\n</tr>\n</tbody></table>\n<h4 id=\"core-architecture-skeleton\">Core Architecture Skeleton</h4>\n<p>This complete file structure provides the foundation for the ECS implementation. Each file includes the essential type definitions and method signatures that learners will implement throughout the milestones.</p>\n<p><strong>File: <code>include/ecs/entity/entity_types.h</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> ECS_ENTITY_TYPES_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ECS_ENTITY_TYPES_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cstdint></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">namespace</span><span style=\"color:#B392F0\"> ecs</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Core entity identification types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    using</span><span style=\"color:#B392F0\"> EntityID</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    using</span><span style=\"color:#B392F0\"> Generation</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Combined entity handle with generation counter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        EntityID id;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Generation generation;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Equality comparison for entity handles</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">==</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> id </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> other.id </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> generation </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> other.generation;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">!=</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#E1E4E8\"> other);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Sentinel values for invalid references</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    constexpr</span><span style=\"color:#E1E4E8\"> EntityID INVALID_ENTITY_ID </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> static_cast&#x3C;</span><span style=\"color:#E1E4E8\">EntityID</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    constexpr</span><span style=\"color:#E1E4E8\"> Generation DEFAULT_GENERATION </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    constexpr</span><span style=\"color:#E1E4E8\"> Entity INVALID_ENTITY </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {INVALID_ENTITY_ID, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span><span style=\"color:#6A737D\"> // namespace ecs</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> // ECS_ENTITY_TYPES_H</span></span></code></pre></div>\n\n<p><strong>File: <code>include/ecs/entity/entity_manager.h</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> ECS_ENTITY_MANAGER_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ECS_ENTITY_MANAGER_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"entity_types.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;queue></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">namespace</span><span style=\"color:#B392F0\"> ecs</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    class</span><span style=\"color:#B392F0\"> EntityManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        EntityManager</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ~EntityManager</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> default</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Core entity lifecycle operations</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Entity</span><span style=\"color:#B392F0\"> createEntity</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void</span><span style=\"color:#B392F0\"> destroyEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#B392F0\"> isAlive</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Entity iteration and statistics</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">getAllAlive</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#B392F0\"> getAliveCount</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#B392F0\"> getDeadCount</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Implement generation tracking per entity ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Implement free list for recycled entity IDs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Implement alive status tracking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Implement generation overflow handling</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Generation</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> generations_;</span><span style=\"color:#6A737D\">  // Generation per entity ID</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::queue</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">EntityID</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> free_ids_;</span><span style=\"color:#6A737D\">       // Recycled entity IDs</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;bool></span><span style=\"color:#E1E4E8\"> alive_entities_;</span><span style=\"color:#6A737D\">    // Alive status per entity ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        EntityID next_entity_id_;</span><span style=\"color:#6A737D\">             // Next new entity ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span><span style=\"color:#6A737D\"> // namespace ecs</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> // ECS_ENTITY_MANAGER_H</span></span></code></pre></div>\n\n<p><strong>File: <code>include/ecs/component/component_types.h</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> ECS_COMPONENT_TYPES_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ECS_COMPONENT_TYPES_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cstdint></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;typeinfo></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">namespace</span><span style=\"color:#B392F0\"> ecs</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Component type identification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    using</span><span style=\"color:#B392F0\"> ComponentTypeID</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    constexpr</span><span style=\"color:#E1E4E8\"> ComponentTypeID INVALID_COMPONENT_TYPE </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> static_cast&#x3C;</span><span style=\"color:#E1E4E8\">ComponentTypeID</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Global component type registration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ComponentTypeID</span><span style=\"color:#B392F0\"> getComponentTypeID</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        static</span><span style=\"color:#E1E4E8\"> ComponentTypeID id </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> generateComponentTypeID</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> id;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Component type counter for unique ID generation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ComponentTypeID</span><span style=\"color:#B392F0\"> generateComponentTypeID</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span><span style=\"color:#6A737D\"> // namespace ecs</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> // ECS_COMPONENT_TYPES_H</span></span></code></pre></div>\n\n<p><strong>File: <code>include/ecs/world.h</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> ECS_WORLD_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ECS_WORLD_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"entity/entity_manager.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"component/component_storage.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"system/system_manager.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;memory></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">namespace</span><span style=\"color:#B392F0\"> ecs</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Main ECS coordinator class</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    class</span><span style=\"color:#B392F0\"> World</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        World</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ~World</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> default</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Entity operations</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Entity</span><span style=\"color:#B392F0\"> createEntity</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Delegate to entity manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void</span><span style=\"color:#B392F0\"> destroyEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Remove all components first</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Then destroy entity in manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#B392F0\"> isAlive</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Delegate to entity manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Component operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> addComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">T</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#FFAB70\"> component</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Validate entity is alive</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Get or create component storage for type T</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Add component to storage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void</span><span style=\"color:#B392F0\"> removeComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Get component storage for type T</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Remove component from storage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> getComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Get component storage for type T</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Return component reference</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#B392F0\"> hasComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Get component storage for type T</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Check if entity has component</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // System operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> SystemT</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void</span><span style=\"color:#B392F0\"> registerSystem</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> priority</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Create system instance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Register with system manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void</span><span style=\"color:#B392F0\"> update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Execute all systems in priority order</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Query interface for systems</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Components</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#B392F0\"> query</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Return query iterator for component combination</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        EntityManager entity_manager_;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Component storage manager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: System manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span><span style=\"color:#6A737D\"> // namespace ecs</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> // ECS_WORLD_H</span></span></code></pre></div>\n\n<h4 id=\"language-specific-implementation-notes\">Language-Specific Implementation Notes</h4>\n<p><strong>Memory Management</strong>: Use RAII principles consistently. The <code>EntityManager</code> should manage its own memory for generation counters and free lists. Component storage should use <code>std::vector</code> for automatic memory management with manual control over capacity growth.</p>\n<p><strong>Template Instantiation</strong>: Component storage uses templates extensively. Consider explicit template instantiation in source files for commonly used component types to reduce compilation time. The <code>getComponentTypeID&lt;T&gt;()</code> function will instantiate a static variable for each component type.</p>\n<p><strong>Exception Safety</strong>: ECS operations should provide strong exception safety guarantees. If <code>addComponent</code> fails to allocate storage, the entity should remain in its previous state. Use RAII wrappers and scope guards for complex operations.</p>\n<p><strong>Performance Considerations</strong>: Profile early and often. The sparse set implementation is the performance critical path—measure cache miss rates and iteration speed. Consider using <code>std::vector&lt;T&gt;::reserve()</code> to pre-allocate storage for known entity counts.</p>\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After Milestone 1 (Entity Manager)</strong>:</p>\n<ul>\n<li>Run <code>make test_entity_manager</code> - should pass all entity lifecycle tests</li>\n<li>Create 1000 entities, destroy every other one, create 1000 more - should reuse recycled IDs</li>\n<li>Verify generation counters increment on entity ID reuse</li>\n<li>Check that <code>isAlive()</code> correctly rejects stale entity references</li>\n</ul>\n<p><strong>After Milestone 2 (Component Storage)</strong>:</p>\n<ul>\n<li>Run <code>make test_component_storage</code> - should pass all component CRUD tests</li>\n<li>Add <code>Position</code> components to 1000 entities, iterate over all - should complete in microseconds</li>\n<li>Remove components from random entities, verify sparse set remains consistent</li>\n<li>Check that component access with wrong type fails to compile</li>\n</ul>\n<p><strong>After Milestone 3 (System Interface)</strong>:</p>\n<ul>\n<li>Run <code>make test_system_execution</code> - should pass system ordering and update tests</li>\n<li>Register movement system, create entities with <code>Position</code> and <code>Velocity</code>, run one frame</li>\n<li>Verify systems execute in priority order with dependency resolution</li>\n<li>Check that delta time propagates correctly to all systems</li>\n</ul>\n<p><strong>After Milestone 4 (Archetypes)</strong>:</p>\n<ul>\n<li>Run <code>make test_archetype_performance</code> - should show improved cache performance</li>\n<li>Compare iteration speed vs. sparse set implementation - should be 2-3x faster</li>\n<li>Add/remove components and verify archetype transitions work correctly</li>\n<li>Measure memory usage - should be more compact than sparse set storage</li>\n</ul>\n<h2 id=\"data-model\">Data Model</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestones 1-4 — core data structures that enable entity management, component storage, system queries, and archetype optimization</p>\n</blockquote>\n<p>The data model forms the foundation of our ECS architecture, defining how we represent entities, components, and their relationships in memory. Think of the data model as the blueprint for a highly organized warehouse: we need efficient ways to identify items (entities), categorize them (component types), store them for fast access (sparse sets), and group similar items together for bulk operations (archetypes). The design of these core data structures directly impacts both the performance characteristics and the ease of use of our entire ECS system.</p>\n<p>Our data model must solve several critical challenges simultaneously. First, entity references must remain stable even when entities are created and destroyed frequently, preventing the classic &quot;dangling pointer&quot; problem that plagues game engines. Second, component data must be stored in cache-friendly layouts that enable high-performance iteration while still supporting dynamic composition. Third, type information must be preserved at runtime to enable safe component access without sacrificing performance. Finally, for advanced implementations, we need metadata structures that enable grouping entities by component combinations for maximum cache efficiency.</p>\n<p><img src=\"/api/project/ecs-arch/architecture-doc/asset?path=diagrams%2Fdata-model-relationships.svg\" alt=\"Core Data Types and Relationships\"></p>\n<p>The relationships between these data structures form a carefully orchestrated system. Entity IDs serve as stable references that survive entity lifecycle operations through generation counters. Component type information bridges the gap between compile-time type safety and runtime flexibility. Sparse sets provide the bidirectional mapping that makes both entity-to-component and component-to-entity lookups efficient. Archetypes build upon all of these to create the highest-performance storage layout possible for bulk operations.</p>\n<h3 id=\"entity-id-structure\">Entity ID Structure</h3>\n<p><strong>Mental Model: Library Card System</strong></p>\n<p>Think of entity management like a library card system at a large university. Each library card has a unique number printed on it, but when a student graduates, their card gets recycled for new students. To prevent a new student from accidentally accessing the previous student&#39;s account, each card also has an issue year or semester stamp. Even if card #12345 gets reused, the new card is stamped &quot;Fall 2024&quot; while the old records show &quot;Spring 2023,&quot; making it clear they&#39;re different people. Similarly, entity IDs use generation counters to distinguish between different &quot;incarnations&quot; of the same ID number.</p>\n<p>The <code>Entity</code> structure represents our core entity identification mechanism. Unlike simple integer IDs that can become dangling references when entities are destroyed, our entity system uses a two-part identifier that remains safe even in complex scenarios involving frequent entity creation and destruction.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>id</code></td>\n<td><code>EntityID</code></td>\n<td>The index portion of the entity identifier, corresponds to position in entity storage arrays</td>\n</tr>\n<tr>\n<td><code>generation</code></td>\n<td><code>Generation</code></td>\n<td>The generation counter that distinguishes different incarnations of the same ID</td>\n</tr>\n</tbody></table>\n<p>The <code>EntityID</code> serves as the index component, representing the position where this entity&#39;s metadata is stored in the Entity Manager&#39;s internal arrays. This index-based approach enables constant-time lookups and efficient iteration over all entities. However, unlike raw indices, <code>EntityID</code> values are never reused immediately after an entity is destroyed.</p>\n<p>The <code>Generation</code> counter solves the fundamental problem of stale entity references. Every time an entity ID is recycled for a new entity, the generation counter increments. This means that even if two entities share the same <code>EntityID</code>, they can be distinguished by their generation values. When code attempts to access a component using a stale entity reference, the generation mismatch will be detected and the access can be safely rejected.</p>\n<blockquote>\n<p><strong>Decision: Packed Entity Structure vs Separate ID/Generation</strong></p>\n<ul>\n<li><strong>Context</strong>: Entity references need both index and generation information, which could be stored as separate values or packed into a single integer</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Separate <code>EntityID</code> and <code>Generation</code> fields in a struct</li>\n<li>Packed format using bit manipulation (e.g., 20 bits ID + 12 bits generation in uint32_t)</li>\n<li>Simple integer IDs with external generation tracking</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Separate fields in a struct approach</li>\n<li><strong>Rationale</strong>: Separate fields provide clearer code, avoid bit manipulation complexity, enable larger ID spaces, and simplify debugging since values are human-readable</li>\n<li><strong>Consequences</strong>: Uses more memory per entity reference (8 bytes vs 4 bytes for packed), but provides maximum flexibility and maintainability</li>\n</ul>\n</blockquote>\n<p>The ID recycling mechanism operates through a free list that tracks destroyed entity IDs. When an entity is destroyed, its ID is added to the free list rather than being immediately reused. When a new entity is created, the system first checks the free list for available IDs. If an ID is recycled, its generation counter is incremented to distinguish it from previous incarnations.</p>\n<p><strong>Generation Counter Overflow Handling</strong></p>\n<p>One subtle but critical aspect of the generation counter system is handling overflow conditions. Since generation counters are finite-width integers (typically 32-bit), they will eventually overflow in long-running applications that create and destroy many entities. Our system handles this through several mechanisms:</p>\n<ol>\n<li><strong>Large Counter Space</strong>: Using 32-bit generation counters provides over 4 billion generations per entity ID, making overflow extremely unlikely in practice</li>\n<li><strong>Overflow Detection</strong>: When incrementing a generation would cause overflow, the system can either skip that ID permanently or implement wraparound with additional safety checks</li>\n<li><strong>Conservative Validation</strong>: Entity validation always checks both ID bounds and generation equality, catching most overflow-related issues</li>\n</ol>\n<p><strong>Entity Validation Process</strong></p>\n<p>The entity validation process ensures that entity references remain valid throughout the application lifecycle. This involves several checks performed whenever an entity reference is used:</p>\n<ol>\n<li><strong>Bounds Check</strong>: Verify the <code>EntityID</code> falls within the valid range of allocated entity slots</li>\n<li><strong>Alive Check</strong>: Confirm the entity slot is currently occupied by a live entity</li>\n<li><strong>Generation Match</strong>: Verify the reference generation matches the current generation in the entity slot</li>\n<li><strong>Component Consistency</strong>: For component operations, verify the entity actually has the requested component type</li>\n</ol>\n<h3 id=\"component-type-information\">Component Type Information</h3>\n<p><strong>Mental Model: Warehouse Inventory System</strong></p>\n<p>Think of component type information like the inventory management system in a large warehouse. Each product category (component type) has its own storage area with specialized equipment: frozen goods need freezers, fragile items need padded shelves, and bulk items need large bins. The warehouse maintains a master catalog that maps product codes (type IDs) to storage locations and handling procedures. When workers need to find or store items, they look up the product code to determine which storage system to use and how to handle that item type safely.</p>\n<p>Component type information bridges the gap between compile-time type safety and runtime flexibility in our ECS system. Since systems need to query for entities with arbitrary component combinations determined at runtime, we need a way to identify, store, and access component types without losing type safety or performance.</p>\n<p>The <code>ComponentTypeID</code> serves as our runtime type identifier, providing a unique integer for each component type registered in the system. These IDs are assigned sequentially as component types are first used, creating a dense mapping that enables efficient storage in arrays and bitsets.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>typeID</code></td>\n<td><code>ComponentTypeID</code></td>\n<td>Unique identifier for this component type, assigned at registration</td>\n</tr>\n<tr>\n<td><code>name</code></td>\n<td><code>const char*</code></td>\n<td>Human-readable name for debugging and serialization</td>\n</tr>\n<tr>\n<td><code>size</code></td>\n<td><code>size_t</code></td>\n<td>Size in bytes of a single component instance</td>\n</tr>\n<tr>\n<td><code>alignment</code></td>\n<td><code>size_t</code></td>\n<td>Required memory alignment for component instances</td>\n</tr>\n<tr>\n<td><code>destructor</code></td>\n<td><code>void(*)(void*)</code></td>\n<td>Function pointer to call component destructor</td>\n</tr>\n<tr>\n<td><code>moveConstructor</code></td>\n<td><code>void(*)(void*, void*)</code></td>\n<td>Function pointer for moving component data</td>\n</tr>\n</tbody></table>\n<p>The component type registry maintains this metadata for all registered component types. This information enables type-erased operations while preserving the ability to call appropriate constructors, destructors, and move operations. The registry uses template specialization to generate and cache this metadata automatically when component types are first accessed.</p>\n<p><strong>Type ID Generation Strategy</strong></p>\n<p>Component type IDs must be consistent within a single program execution but do not need to be stable across program restarts. Our type ID generation uses a simple counter-based approach with template-based caching for performance:</p>\n<ol>\n<li><strong>First Access Registration</strong>: When a component type is first accessed, the system generates the next available type ID</li>\n<li><strong>Template Caching</strong>: Each component type gets a template specialization that caches its type ID for subsequent access</li>\n<li><strong>Sequential Assignment</strong>: Type IDs are assigned sequentially starting from 0, creating a dense ID space optimal for array indexing</li>\n<li><strong>Consistency Guarantee</strong>: Within a single program execution, each component type receives the same ID regardless of access order</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Sequential Type IDs vs Hash-Based IDs</strong></p>\n<ul>\n<li><strong>Context</strong>: Component types need unique identifiers that enable efficient storage and lookup operations</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Sequential integer IDs assigned on first use</li>\n<li>Hash-based IDs derived from type names</li>\n<li>Compile-time assigned IDs using template metaprogramming</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Sequential integer IDs with template caching</li>\n<li><strong>Rationale</strong>: Sequential IDs create dense arrays for storage, avoid hash collisions, work with any component type regardless of naming, and provide predictable performance characteristics</li>\n<li><strong>Consequences</strong>: Type IDs are not stable across program runs, but this enables optimal memory layouts and eliminates hash collision complexity</li>\n</ul>\n</blockquote>\n<p><strong>Sparse Set Integration</strong></p>\n<p>The component type information directly integrates with our sparse set storage system. Each component type gets its own <code>ComponentStorage</code> instance that maintains the sparse set mapping from entity IDs to component array indices. This design provides several advantages:</p>\n<ul>\n<li><strong>Type Safety</strong>: Each component type has its own storage with compile-time type checking</li>\n<li><strong>Independent Lifecycle</strong>: Components of different types can be added and removed independently</li>\n<li><strong>Optimal Memory Layout</strong>: Each component type is stored in its own contiguous array for cache efficiency</li>\n<li><strong>Efficient Queries</strong>: Systems can quickly determine which entities have specific component combinations</li>\n</ul>\n<p>The <code>IComponentStorage</code> base interface enables type-erased operations on component storage, allowing the ECS system to manage storage instances without knowing their specific component types at compile time.</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>removeEntity</code></td>\n<td><code>Entity entity</code></td>\n<td><code>void</code></td>\n<td>Remove component from entity if present</td>\n</tr>\n<tr>\n<td><code>hasEntity</code></td>\n<td><code>Entity entity</code></td>\n<td><code>bool</code></td>\n<td>Check if entity has this component type</td>\n</tr>\n<tr>\n<td><code>getTypeID</code></td>\n<td>-</td>\n<td><code>ComponentTypeID</code></td>\n<td>Return the component type ID for this storage</td>\n</tr>\n<tr>\n<td><code>size</code></td>\n<td>-</td>\n<td><code>size_t</code></td>\n<td>Return number of components currently stored</td>\n</tr>\n<tr>\n<td><code>clear</code></td>\n<td>-</td>\n<td><code>void</code></td>\n<td>Remove all components and reset storage</td>\n</tr>\n</tbody></table>\n<h3 id=\"archetype-data-layout\">Archetype Data Layout</h3>\n<p><strong>Mental Model: Filing Cabinet Organization</strong></p>\n<p>Think of archetype-based storage like a highly organized filing system in a law firm. Instead of storing each client&#39;s documents randomly throughout the office, related documents are grouped together in specific filing cabinets. All divorce cases go in one cabinet, all contract disputes in another, and all tax issues in a third. Within each cabinet, documents are organized in a consistent order so lawyers can quickly find everything they need for a specific case type. Similarly, archetypes group entities with identical component combinations together, storing all their components in adjacent memory locations for maximum cache efficiency.</p>\n<p><img src=\"/api/project/ecs-arch/architecture-doc/asset?path=diagrams%2Farchetype-organization.svg\" alt=\"Archetype Storage Layout\"></p>\n<p>Archetype-based storage represents the most advanced optimization in our ECS architecture. While the basic sparse set approach stores each component type separately, archetypes group entities by their complete component combination and store all components for those entities together. This creates optimal memory layouts for systems that process multiple component types simultaneously.</p>\n<p>The <code>ArchetypeID</code> uniquely identifies each distinct component combination found in the ECS world. These IDs are generated dynamically as new component combinations are discovered, creating a registry of all unique entity &quot;shapes&quot; in the system.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>id</code></td>\n<td><code>uint32_t</code></td>\n<td>Unique identifier for this archetype</td>\n</tr>\n<tr>\n<td><code>componentMask</code></td>\n<td><code>ComponentMask</code></td>\n<td>Bitset indicating which component types are present</td>\n</tr>\n<tr>\n<td><code>componentTypes</code></td>\n<td><code>std::vector&lt;ComponentTypeID&gt;</code></td>\n<td>Ordered list of component types in this archetype</td>\n</tr>\n<tr>\n<td><code>componentOffsets</code></td>\n<td><code>std::vector&lt;size_t&gt;</code></td>\n<td>Byte offsets for each component type within entity data</td>\n</tr>\n<tr>\n<td><code>entityStride</code></td>\n<td><code>size_t</code></td>\n<td>Total bytes per entity (sum of all component sizes plus padding)</td>\n</tr>\n</tbody></table>\n<p>The <code>componentMask</code> provides a compact representation of which component types are present in this archetype. This bitset enables fast archetype matching during system queries — a system requiring components A, B, and C can quickly check if an archetype contains all three by performing bitwise operations on the mask.</p>\n<p><strong>Chunk-Based Memory Layout</strong></p>\n<p>Within each archetype, entities are stored in fixed-size chunks that optimize for cache line utilization and memory allocation patterns. Each chunk contains a predetermined number of entities with all their components stored in structure-of-arrays format.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>entities</code></td>\n<td><code>Entity[]</code></td>\n<td>Array of entity IDs in this chunk</td>\n</tr>\n<tr>\n<td><code>componentData</code></td>\n<td><code>std::byte*</code></td>\n<td>Raw memory containing all component data</td>\n</tr>\n<tr>\n<td><code>entityCount</code></td>\n<td><code>uint32_t</code></td>\n<td>Number of entities currently stored in this chunk</td>\n</tr>\n<tr>\n<td><code>capacity</code></td>\n<td><code>uint32_t</code></td>\n<td>Maximum entities this chunk can hold</td>\n</tr>\n</tbody></table>\n<p>The component data within each chunk is laid out in structure-of-arrays format, meaning all instances of component type A are stored contiguously, followed by all instances of component type B, and so on. This layout maximizes cache efficiency when systems iterate over specific component types.</p>\n<p><strong>Archetype Transition Management</strong></p>\n<p>One of the most complex aspects of archetype-based storage is managing transitions when entities gain or lose components. Since adding or removing a component changes an entity&#39;s archetype, the entity must be moved between archetype storage areas.</p>\n<p>The archetype transition process follows these steps:</p>\n<ol>\n<li><strong>Source Archetype Identification</strong>: Determine the entity&#39;s current archetype based on its existing components</li>\n<li><strong>Target Archetype Resolution</strong>: Calculate the new archetype after the component operation (add/remove)</li>\n<li><strong>Target Archetype Creation</strong>: Create the target archetype if it doesn&#39;t exist yet</li>\n<li><strong>Entity Data Migration</strong>: Copy the entity&#39;s component data from source to target archetype</li>\n<li><strong>Index Updates</strong>: Update all sparse set indices to reflect the entity&#39;s new storage location</li>\n<li><strong>Source Cleanup</strong>: Remove the entity from its original archetype storage</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Structure-of-Arrays vs Array-of-Structures Layout</strong></p>\n<ul>\n<li><strong>Context</strong>: Archetype storage needs to organize multiple component types for optimal iteration performance</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Structure-of-Arrays (SoA): All instances of component A, then all instances of component B</li>\n<li>Array-of-Structures (AoS): Entity 1&#39;s components A+B+C, then Entity 2&#39;s components A+B+C</li>\n<li>Hybrid approach with both layouts available</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Structure-of-Arrays layout within archetype chunks</li>\n<li><strong>Rationale</strong>: SoA layout maximizes cache efficiency when systems iterate over specific component types, enables SIMD optimizations, and matches typical system access patterns where not all components are accessed simultaneously</li>\n<li><strong>Consequences</strong>: Requires more complex entity transition logic and may perform worse for systems that access all components of individual entities, but provides significant performance benefits for typical ECS usage patterns</li>\n</ul>\n</blockquote>\n<p><strong>Archetype Graph and Query Optimization</strong></p>\n<p>The collection of all archetypes forms a graph structure where edges represent single-component additions or removals. This graph enables several optimizations:</p>\n<ul>\n<li><strong>Transition Caching</strong>: Common archetype transitions can be precomputed and cached</li>\n<li><strong>Query Filtering</strong>: System queries can eliminate entire archetype families based on component requirements</li>\n<li><strong>Memory Pooling</strong>: Related archetypes can share memory pools for better allocation performance</li>\n</ul>\n<p>The archetype graph also helps identify potential &quot;archetype explosion&quot; issues where too many unique component combinations create excessive memory overhead. Monitoring tools can analyze the graph to suggest component design improvements.</p>\n<p>⚠️ <strong>Pitfall: Archetype Explosion</strong>\nCreating too many unique component combinations can lead to archetype explosion, where the overhead of managing numerous small archetypes exceeds the benefits. This often occurs when using components for temporary state (like &quot;IsJumping&quot; flags) or unique identifiers. Instead, consider using component data fields for temporary state and reserve separate component types for fundamentally different behaviors. Monitor archetype count and average entities per archetype to detect explosion issues early.</p>\n<p>⚠️ <strong>Pitfall: Frequent Archetype Transitions</strong>\nEntities that frequently gain and lose components can create performance bottlenecks due to the cost of moving data between archetypes. This commonly happens with temporary status effects or state-based components. Consider redesigning frequently-changing state as component data fields rather than separate component types, or use a hybrid approach where core components remain stable while auxiliary data is stored separately.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Entity ID Storage</td>\n<td><code>std::vector&lt;Entity&gt;</code> with linear search</td>\n<td>Hash table or custom allocator with free list</td>\n</tr>\n<tr>\n<td>Component Type Registry</td>\n<td><code>std::unordered_map&lt;std::type_index, TypeInfo&gt;</code></td>\n<td>Template-based compile-time registry</td>\n</tr>\n<tr>\n<td>Sparse Set Implementation</td>\n<td><code>std::vector</code> for dense array, <code>std::vector</code> for sparse array</td>\n<td>Custom memory pools with chunk allocation</td>\n</tr>\n<tr>\n<td>Archetype Storage</td>\n<td><code>std::vector&lt;std::vector&lt;std::byte&gt;&gt;</code> per archetype</td>\n<td>Memory-mapped files or custom chunk allocators</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">src</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">ecs</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  core</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    entity.hpp</span><span style=\"color:#6A737D\">              // Entity ID and generation definitions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    entity.cpp</span><span style=\"color:#6A737D\">              // Entity validation and utility functions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    component_type.hpp</span><span style=\"color:#6A737D\">      // ComponentTypeID and type information</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    component_type.cpp</span><span style=\"color:#6A737D\">      // Type registry implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  storage</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sparse_set.hpp</span><span style=\"color:#6A737D\">          // Generic sparse set implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sparse_set.cpp</span><span style=\"color:#6A737D\">          // Sparse set operations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    component_storage.hpp</span><span style=\"color:#6A737D\">   // Template component storage classes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    component_storage.cpp</span><span style=\"color:#6A737D\">   // Type-erased storage base class</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    archetype.hpp</span><span style=\"color:#6A737D\">           // Archetype data structures</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    archetype.cpp</span><span style=\"color:#6A737D\">           // Archetype transition logic</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  test</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    entity_test.cpp</span><span style=\"color:#6A737D\">         // Entity ID and generation tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sparse_set_test.cpp</span><span style=\"color:#6A737D\">     // Sparse set correctness tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    archetype_test.cpp</span><span style=\"color:#6A737D\">      // Archetype storage and transition tests</span></span></code></pre></div>\n\n<p><strong>Core Data Structure Implementations</strong></p>\n<p>Here are the essential data structure definitions that form the foundation of your ECS implementation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// entity.hpp</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cstdint></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;limits></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#B392F0\"> EntityID</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#B392F0\"> Generation</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#E1E4E8\"> EntityID INVALID_ENTITY_ID </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">numeric_limits</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">EntityID</span><span style=\"color:#E1E4E8\">>::</span><span style=\"color:#B392F0\">max</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#E1E4E8\"> Generation DEFAULT_GENERATION </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EntityID id;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Generation generation;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement equality operators for entity comparison</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement hash function for use in containers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add validation method to check for INVALID_ENTITY</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#E1E4E8\"> Entity INVALID_ENTITY </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {INVALID_ENTITY_ID, DEFAULT_GENERATION};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// component_type.hpp  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;typeindex></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;functional></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#B392F0\"> ComponentTypeID</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> ComponentTypeInfo</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ComponentTypeID typeID;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::string name;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> alignment;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::function</span><span style=\"color:#F97583\">&#x3C;void</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> destructor;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::function</span><span style=\"color:#F97583\">&#x3C;void</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> moveConstructor;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add copy constructor function pointer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add serialization function pointers for advanced features</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add debug string conversion for component inspection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ComponentTypeRegistry</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#E1E4E8\"> ComponentTypeID nextTypeID;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::type_index, ComponentTypeInfo</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> typeMap;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement getTypeID&#x3C;T>() that returns cached or generates new type ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement getTypeInfo(ComponentTypeID) for runtime type information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement registerType&#x3C;T>() for explicit type registration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add iteration support for all registered types</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Sparse Set Foundation</strong></p>\n<p>The sparse set implementation provides the core mapping mechanism between entities and components:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// sparse_set.hpp</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"entity.hpp\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SparseSet</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">T</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> dense;</span><span style=\"color:#6A737D\">           // Contiguous storage of components</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;uint32_t></span><span style=\"color:#E1E4E8\"> sparse;</span><span style=\"color:#6A737D\">   // Maps entity ID to dense array index</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> entities;</span><span style=\"color:#6A737D\">   // Maps dense index to entity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement insert(Entity, T&#x26;&#x26;) - add component to entity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement remove(Entity) - remove component and compact array</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement get(Entity) -> T&#x26; - retrieve component reference</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement has(Entity) -> bool - check if entity has component</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement size() and capacity() for memory management</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement begin()/end() iterators for component iteration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement clear() to remove all components</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement ensureSparseCapacity(EntityID) for dynamic growth</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement swapRemove(size_t index) for efficient removal</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement validateEntity(Entity) for generation checking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Archetype Data Structures</strong></p>\n<p>For advanced implementations, the archetype system requires careful data layout planning:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// archetype.hpp</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"component_type.hpp\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;bitset></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;memory></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#E1E4E8\"> MAX_COMPONENTS </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 64</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#B392F0\"> ComponentMask</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">bitset</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">MAX_COMPONENTS</span><span style=\"color:#E1E4E8\">>;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> ArchetypeInfo</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> archetypeID;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ComponentMask componentMask;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ComponentTypeID</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> componentTypes;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;size_t></span><span style=\"color:#E1E4E8\"> componentOffsets;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> entityStride;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add calculateStride() method to compute entity data size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add hasComponent(ComponentTypeID) helper method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add isSubsetOf(ComponentMask) for query matching</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ArchetypeChunk</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::byte[]</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> data;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> entities;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> entityCount;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> capacity;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#E1E4E8\"> ArchetypeInfo</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> archetype;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement addEntity(Entity, component data...) </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement removeEntity(Entity) with swap-remove</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement getComponent&#x3C;T>(Entity) with offset calculation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement iteration support for bulk component access</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add memory management for chunk resizing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoints</strong></p>\n<p>After implementing each milestone, verify functionality with these checkpoints:</p>\n<p><strong>Milestone 1 - Entity Manager:</strong></p>\n<ul>\n<li>Create 1000 entities, destroy every other one, create 1000 more</li>\n<li>Verify that generation counters increment correctly for recycled IDs  </li>\n<li>Verify that <code>isAlive()</code> returns false for destroyed entities</li>\n<li>Expected behavior: No entity ID exceeds 1000, but generations vary</li>\n</ul>\n<p><strong>Milestone 2 - Component Storage:</strong></p>\n<ul>\n<li>Add Position and Velocity components to 100 entities</li>\n<li>Remove Position from entities 50-99, verify Velocity components remain</li>\n<li>Iterate over all Position components and verify count equals 50</li>\n<li>Expected behavior: Contiguous iteration with no gaps or invalid data</li>\n</ul>\n<p><strong>Milestone 3 - System Interface:</strong></p>\n<ul>\n<li>Create entities with various component combinations</li>\n<li>Implement a movement system requiring Position + Velocity</li>\n<li>Query should return only entities having both components</li>\n<li>Expected behavior: System processes exactly the entities matching query</li>\n</ul>\n<p><strong>Milestone 4 - Archetypes (Advanced):</strong></p>\n<ul>\n<li>Monitor archetype creation as component combinations are added</li>\n<li>Add/remove components and verify entities transition between archetypes</li>\n<li>Benchmark iteration speed comparing sparse set vs archetype approaches</li>\n<li>Expected behavior: Fewer cache misses and faster iteration with archetypes</li>\n</ul>\n<p><strong>Language-Specific Hints</strong></p>\n<p><strong>C++ Implementation Tips:</strong></p>\n<ul>\n<li>Use <code>std::type_index</code> with <code>typeid(T)</code> for component type identification</li>\n<li>Employ placement new for constructing components in pre-allocated memory</li>\n<li>Consider <code>std::unique_ptr&lt;std::byte[]&gt;</code> for raw memory management in archetypes</li>\n<li>Use template specialization to cache component type IDs at compile time</li>\n<li>Implement custom allocators for frequent archetype chunk allocation/deallocation</li>\n</ul>\n<p><strong>Memory Management Considerations:</strong></p>\n<ul>\n<li>Component destructors must be called when components are removed</li>\n<li>Use RAII principles for automatic cleanup of component storage</li>\n<li>Consider memory pool allocators for fixed-size archetype chunks</li>\n<li>Implement proper move semantics for component transfers between archetypes</li>\n<li>Monitor memory fragmentation in long-running applications with frequent entity churn</li>\n</ul>\n<h2 id=\"entity-manager-design\">Entity Manager Design</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1 (Entity Manager) — implementing entity ID generation, lifecycle tracking, and ID recycling with generation counters</p>\n</blockquote>\n<p>The Entity Manager serves as the foundation of our ECS architecture, providing the fundamental service of entity lifecycle management. Think of it as the identity card office for your game world — it issues unique identification cards to game objects, tracks which cards are currently valid, and recycles old cards when objects are destroyed to prevent running out of identification numbers in long-running games.</p>\n<p>This component must solve several challenging problems simultaneously. First, it must generate unique entity identifiers that never collide during runtime, even when millions of entities are created and destroyed. Second, it must efficiently track which entities are currently alive versus destroyed, supporting both fast validation of entity references and efficient iteration over all living entities. Third, it must implement a memory-efficient recycling system that reuses the identifiers of destroyed entities without allowing stale references to accidentally access newly created entities that happen to reuse the same ID.</p>\n<p>The Entity Manager&#39;s design directly impacts the performance characteristics of the entire ECS system. Every component lookup, system query, and entity validation flows through this component, making its efficiency critical for overall system performance. A poorly designed entity manager can introduce cache misses, memory fragmentation, and O(n) lookup operations that cripple game performance.</p>\n<h3 id=\"mental-model-library-card-system\">Mental Model: Library Card System</h3>\n<p>To understand entity management, imagine a large public library with a sophisticated card catalog system. When someone wants to check out books, they receive a library card with two critical pieces of information: a card number and an issue date (or generation). The card number identifies which slot in the filing system belongs to this patron, while the issue date prevents problems when cards are reused.</p>\n<p>Here&#39;s how the analogy maps to our Entity Manager:</p>\n<p>The <strong>library card number</strong> corresponds to our <code>EntityID</code> — a simple integer that identifies a specific slot in our entity storage arrays. Just as library cards are numbered 1, 2, 3, and so forth, entity IDs are simple incrementing integers that serve as indices into our data structures.</p>\n<p>The <strong>issue date</strong> corresponds to our <code>Generation</code> counter — a version number that gets incremented each time a card number is reused. When patron #42 returns their library card, the librarian doesn&#39;t immediately give card #42 to the next person. Instead, they update the issue date and keep track of which generation of card #42 is currently valid.</p>\n<p>The <strong>card catalog filing system</strong> corresponds to our entity storage arrays — indexed by the card number, these slots hold information about whether the card is currently issued, what generation it&#39;s on, and what books (components) are associated with this patron.</p>\n<p>The <strong>returned card recycling bin</strong> corresponds to our free list — when a patron returns their library card, it goes into a recycling bin to be reissued later rather than being thrown away. This prevents the library from running out of card numbers even after serving millions of patrons over decades.</p>\n<p>The critical insight from this analogy is the <strong>stale reference problem</strong>. Imagine if the library didn&#39;t use issue dates — when patron Alice returns card #42, and it&#39;s immediately reissued to patron Bob, any old references to &quot;card #42&quot; would now incorrectly point to Bob&#39;s account instead of Alice&#39;s. By including the issue date, the library can detect that a reference to &quot;card #42 issued in March&quot; is invalid once that card has been reissued with an April date.</p>\n<p>This same principle prevents our ECS from accidentally accessing the wrong entity when IDs are recycled. An entity reference that holds both the ID (42) and generation (March) becomes safely invalid once that entity is destroyed and the ID is recycled with a new generation (April).</p>\n<h3 id=\"generation-counter-mechanism\">Generation Counter Mechanism</h3>\n<p>The generation counter mechanism forms the core safety system that prevents stale entity references from causing data corruption or logic errors. Every entity consists of two components: an <code>EntityID</code> that serves as an index into storage arrays, and a <code>Generation</code> that serves as a version number for that index slot.</p>\n<p>When the Entity Manager creates a new entity, it performs several operations atomically. First, it selects an <code>EntityID</code> — either by reusing a recycled ID from the free list or by allocating a new ID by incrementing the global entity counter. Second, it increments the generation counter for that specific entity slot, ensuring that any previous references to this entity ID become invalid. Third, it marks the entity slot as alive in the entity status tracking structure. Finally, it returns an <code>Entity</code> structure containing both the ID and the current generation.</p>\n<p>The generation counter prevents the <strong>ABA problem</strong> that would otherwise plague entity references. Consider this scenario without generations: Entity A is created with ID 100, a system stores a reference to entity 100, entity A is destroyed, entity B is created and reuses ID 100, and the system&#39;s stale reference to entity 100 now incorrectly accesses entity B&#39;s data. This silent corruption can cause subtle bugs that are extremely difficult to debug.</p>\n<p>With generation counters, the scenario becomes safe: Entity A is created with ID 100 and generation 1, a system stores a reference to entity (100, 1), entity A is destroyed, entity B is created with ID 100 and generation 2, and when the system attempts to access entity (100, 1), the Entity Manager detects the generation mismatch and safely returns an &quot;entity not found&quot; error instead of returning entity B&#39;s data.</p>\n<p><strong>Decision: 32-bit Generation Counters</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to choose the size of generation counters, balancing memory usage against overflow risk</li>\n<li><strong>Options Considered</strong>: 16-bit (65K generations), 32-bit (4B generations), 64-bit (effectively unlimited)</li>\n<li><strong>Decision</strong>: 32-bit generation counters</li>\n<li><strong>Rationale</strong>: 32-bit provides 4 billion generations per entity slot, which even at 60 FPS with one entity created/destroyed per frame would take over 2 years to overflow a single slot. 64-bit would double memory usage for entity references with no practical benefit, while 16-bit creates realistic overflow scenarios in long-running games.</li>\n<li><strong>Consequences</strong>: Each entity reference uses 8 bytes total (4 bytes ID + 4 bytes generation), and generation overflow is a theoretical concern that can be handled by reserving the maximum generation value as a &quot;permanent&quot; marker for entities that should never be recycled.</li>\n</ul>\n<p>The Entity Manager maintains a <strong>generation table</strong> that maps each entity ID to its current generation counter. This table grows as new entity IDs are allocated and never shrinks, since even recycled entity IDs need their generation counters to be maintained. The table structure supports constant-time access for generation validation and updates.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>generations</code></td>\n<td><code>vector&lt;Generation&gt;</code></td>\n<td>Maps entity ID to current generation counter for that slot</td>\n</tr>\n<tr>\n<td><code>aliveFlags</code></td>\n<td><code>vector&lt;bool&gt;</code></td>\n<td>Bit vector indicating which entity IDs are currently alive</td>\n</tr>\n<tr>\n<td><code>freeList</code></td>\n<td><code>queue&lt;EntityID&gt;</code></td>\n<td>Queue of recycled entity IDs available for reuse</td>\n</tr>\n<tr>\n<td><code>nextEntityID</code></td>\n<td><code>EntityID</code></td>\n<td>Next unused entity ID for allocation when free list is empty</td>\n</tr>\n</tbody></table>\n<p>When validating an entity reference, the Entity Manager performs these steps:</p>\n<ol>\n<li>Extract the entity ID and generation from the entity reference</li>\n<li>Check if the entity ID is within the bounds of the generations table</li>\n<li>Look up the current generation for this entity ID in the generations table</li>\n<li>Compare the reference generation with the current generation</li>\n<li>Check if the entity is marked as alive in the alive flags bit vector</li>\n<li>Return true only if the generations match and the entity is alive</li>\n</ol>\n<p>This validation process runs in constant time O(1) since all operations are simple array indexers and integer comparisons. The bit vector for alive flags provides cache-efficient storage, packing 8 entity status flags into each byte of memory.</p>\n<h3 id=\"id-recycling-strategy\">ID Recycling Strategy</h3>\n<p>The ID recycling strategy addresses a critical concern for long-running applications: preventing entity ID exhaustion while maintaining constant-time allocation and deallocation performance. Games, especially persistent online games or game engines, may create and destroy millions of entities over their lifetime. A naive approach that simply increments a global counter would eventually overflow, while a complex approach that tries to find gaps in the ID space would introduce expensive search operations.</p>\n<p>Our recycling strategy uses a <strong>free list</strong> data structure — a simple queue that holds entity IDs that have been freed and are available for reuse. When an entity is destroyed, its ID is pushed onto the free list after incrementing the generation counter for that slot. When a new entity is created, the Entity Manager first checks if the free list contains any recycled IDs before allocating a new ID from the global counter.</p>\n<p>The free list provides several important guarantees. First, it ensures that entity creation runs in amortized constant time — most creations will pop from the free list in O(1), and only when the free list is empty will the system need to allocate a new ID. Second, it provides excellent memory locality for recently used entity IDs, since recently freed IDs are likely to have their associated memory pages still in CPU cache. Third, it prevents unbounded growth of the entity ID space in applications with steady-state entity counts.</p>\n<p><strong>Decision: FIFO Free List Implementation</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to choose the ordering strategy for recycled entity IDs to optimize cache locality and prevent pathological cases</li>\n<li><strong>Options Considered</strong>: LIFO stack (reuse most recent), FIFO queue (age-based reuse), random selection</li>\n<li><strong>Decision</strong>: FIFO queue implementation</li>\n<li><strong>Rationale</strong>: FIFO provides better temporal locality by ensuring recently freed entities have time for their associated component data to be evicted from cache before the ID is reused. LIFO could cause thrashing by immediately reusing entity IDs whose component data is still hot in cache, potentially confusing debugging. Random selection provides no cache benefits and complicates implementation.</li>\n<li><strong>Consequences</strong>: Entity IDs experience a &quot;cooling off&quot; period before reuse, improving cache behavior and making debugging easier since recently destroyed entities won&#39;t immediately have their IDs reused.</li>\n</ul>\n<p>The implementation maintains several data structures to support efficient recycling:</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>createEntity</code></td>\n<td>none</td>\n<td><code>Entity</code></td>\n<td>Pops from free list or allocates new ID, increments generation, marks alive</td>\n</tr>\n<tr>\n<td><code>destroyEntity</code></td>\n<td><code>Entity entity</code></td>\n<td><code>void</code></td>\n<td>Validates entity, marks not alive, pushes ID to free list, increments generation</td>\n</tr>\n<tr>\n<td><code>isAlive</code></td>\n<td><code>Entity entity</code></td>\n<td><code>bool</code></td>\n<td>Validates entity ID and generation against current state</td>\n</tr>\n<tr>\n<td><code>getAllEntities</code></td>\n<td>none</td>\n<td><code>vector&lt;Entity&gt;</code></td>\n<td>Returns all currently alive entities for iteration</td>\n</tr>\n</tbody></table>\n<p>The recycling process follows these steps when creating an entity:</p>\n<ol>\n<li>Check if the free list contains any recycled entity IDs</li>\n<li>If free list is not empty, pop the oldest recycled ID from the front of the queue</li>\n<li>If free list is empty, use the next available ID from the global counter and increment the counter</li>\n<li>Increment the generation counter for the selected entity ID slot</li>\n<li>Mark the entity ID as alive in the status bit vector</li>\n<li>Return an <code>Entity</code> structure with the ID and new generation</li>\n</ol>\n<p>The recycling process follows these steps when destroying an entity:</p>\n<ol>\n<li>Validate that the entity reference is currently alive using the generation counter</li>\n<li>Mark the entity ID as not alive in the status bit vector</li>\n<li>Increment the generation counter for this entity ID slot (invalidating existing references)</li>\n<li>Push the entity ID onto the back of the free list queue for future reuse</li>\n<li>Notify any registered observers that the entity has been destroyed (for component cleanup)</li>\n</ol>\n<p>This approach handles the <strong>generation overflow</strong> edge case by reserving the maximum generation value (<code>UINT32_MAX</code>) as a special &quot;permanent&quot; marker. If an entity ID&#39;s generation counter would overflow, the Entity Manager instead marks it as permanent and never recycles it. In practice, this requires creating and destroying the same entity ID 4 billion times, which is extremely unlikely even in long-running applications.</p>\n<p><strong>Memory Efficiency Considerations</strong></p>\n<p>The recycling strategy also addresses memory efficiency concerns in the component storage systems. When an entity is destroyed, its components must be removed from their respective storage arrays. The Entity Manager provides hooks for component systems to register cleanup callbacks that are invoked during entity destruction, ensuring that component memory is freed promptly rather than accumulating as garbage.</p>\n<p>The free list size is capped to prevent memory usage from growing unbounded in applications that experience temporary spikes in entity creation. When the free list exceeds a configured threshold (default 1024 entries), older entries are discarded and those entity IDs become permanently unavailable for allocation. This trades a small amount of entity ID space for bounded memory usage.</p>\n<h3 id=\"common-entity-management-pitfalls\">Common Entity Management Pitfalls</h3>\n<p>Entity management introduces several subtle pitfalls that can cause crashes, data corruption, or performance problems. Understanding these pitfalls helps developers build robust ECS implementations and debug issues that arise in complex game scenarios.</p>\n<p>⚠️ <strong>Pitfall: Stale Entity References</strong></p>\n<p>The most common and dangerous pitfall is improper handling of stale entity references. This occurs when game code stores entity references in local variables, member variables, or data structures, and continues using them after the referenced entity has been destroyed. Without proper validation, stale references can access memory belonging to newly created entities, causing silent data corruption.</p>\n<p>Consider this problematic sequence: a combat system stores a reference to a &quot;target enemy&quot; entity in a member variable, the enemy dies and its entity is destroyed during the same frame, a new pickup item is created and happens to reuse the same entity ID, and the combat system continues using its stale reference, accidentally treating the pickup item as an enemy and potentially corrupting its component data.</p>\n<p>The correct approach requires validating entity references before every use by calling <code>isAlive()</code>. Systems should be designed to gracefully handle entity validation failures by cleaning up their internal state and continuing execution. Critical references (such as parent-child relationships) should use observer patterns or event systems to be notified when referenced entities are destroyed.</p>\n<p>⚠️ <strong>Pitfall: Entity Reference Storage in Components</strong></p>\n<p>A subtle variant of the stale reference problem occurs when components store references to other entities. For example, a <code>Parent</code> component might store an entity reference to indicate hierarchical relationships, or a <code>Target</code> component might reference an entity being pursued by an AI. These stored references can become stale when the referenced entities are destroyed.</p>\n<p>The solution requires implementing a <strong>reference tracking system</strong> where the Entity Manager maintains a registry of which entities reference which other entities. When an entity is destroyed, the Entity Manager iterates through all entities that reference it and either nullifies their references or triggers cleanup callbacks. This adds complexity but prevents silent corruption in entity relationship systems.</p>\n<p>⚠️ <strong>Pitfall: Generation Counter Overflow</strong></p>\n<p>Although generation overflow is unlikely with 32-bit counters, it represents a potential crash or corruption source in extremely long-running applications. The overflow occurs when an entity ID is recycled so frequently that its generation counter wraps around to zero, potentially causing very old stale references to become valid again.</p>\n<p>The defense against overflow involves reserving the maximum generation value as a &quot;permanent&quot; sentinel that prevents further recycling. When a generation counter reaches <code>UINT32_MAX - 1</code>, the next destruction marks it as permanent rather than incrementing to zero. The entity ID becomes permanently unavailable for allocation, trading a small amount of ID space for safety.</p>\n<p>⚠️ <strong>Pitfall: Iteration Invalidation During Entity Creation/Destruction</strong></p>\n<p>Entity creation and destruction during iteration over the alive entities list can cause iterator invalidation, crashes, or skipped entities. This commonly occurs when systems create or destroy entities based on conditions they discover during iteration, such as spawning projectiles when iterating over weapons or destroying entities when their health reaches zero.</p>\n<p>The safe approach requires deferring entity lifecycle operations until after iteration completes. Systems should collect entities to be created or destroyed in temporary lists during iteration, then process those lists after iteration finishes. Alternatively, the Entity Manager can provide &quot;deferred&quot; creation and destruction methods that queue operations for execution at safe points.</p>\n<p>⚠️ <strong>Pitfall: Component Access Without Entity Validation</strong></p>\n<p>Systems often assume that if they successfully queried for entities with specific components, those entities will remain valid throughout the frame. However, other systems executing earlier in the frame might have destroyed some of those entities, leaving the query results containing stale references.</p>\n<p>The solution requires either validating entities before accessing their components, or designing the system execution order to guarantee that entity destruction happens at specific, well-defined points in the frame (such as at the end of frame processing). The latter approach is more performant but requires careful architectural planning.</p>\n<p>⚠️ <strong>Pitfall: Free List Memory Growth</strong></p>\n<p>In applications with highly variable entity counts, the free list can grow very large during high entity count periods and then retain that memory even when entity counts drop. This creates memory usage that never shrinks, potentially causing memory pressure in memory-constrained environments.</p>\n<p>The mitigation involves implementing a <strong>free list size cap</strong> and periodically compacting the free list during low-activity periods. When the free list exceeds the cap, the oldest entries are discarded (permanently retiring those entity IDs). During compaction, the system can rebuild the free list to use only recent entries, allowing garbage collection of the old free list memory.</p>\n<h3 id=\"common-entity-management-pitfalls\">Common Entity Management Pitfalls</h3>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection Method</th>\n<th>Prevention Strategy</th>\n<th>Recovery Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Stale reference access</td>\n<td>Debug assertions on <code>isAlive()</code></td>\n<td>Validate before every access</td>\n<td>Clean up invalid references, continue</td>\n</tr>\n<tr>\n<td>Generation overflow</td>\n<td>Monitor generation values</td>\n<td>Use permanent marker at max value</td>\n<td>Block recycling, log warning</td>\n</tr>\n<tr>\n<td>Iterator invalidation</td>\n<td>Crash or skipped entities</td>\n<td>Defer creation/destruction</td>\n<td>Exception handling, state repair</td>\n</tr>\n<tr>\n<td>Free list growth</td>\n<td>Memory monitoring</td>\n<td>Size caps and compaction</td>\n<td>Discard excess entries</td>\n</tr>\n<tr>\n<td>Component reference cycles</td>\n<td>Reference count tracking</td>\n<td>Weak references for cycles</td>\n<td>Break cycles during destruction</td>\n</tr>\n</tbody></table>\n<p><img src=\"/api/project/ecs-arch/architecture-doc/asset?path=diagrams%2Fentity-lifecycle.svg\" alt=\"Entity Lifecycle State Machine\"></p>\n<p>The entity lifecycle state machine shows the complete flow from entity creation through active usage to destruction and ID recycling. Notice how the generation counter increments at two key points: when an entity is created (to invalidate any previous references to this ID) and when an entity is destroyed (to invalidate current references before recycling). This dual-increment approach ensures that stale references become invalid immediately rather than remaining dangerous until the next entity reuses the ID.</p>\n<p><img src=\"/api/project/ecs-arch/architecture-doc/asset?path=diagrams%2Fdata-model-relationships.svg\" alt=\"Core Data Types and Relationships\"></p>\n<p>The data model relationships diagram illustrates how the Entity Manager&#39;s data structures interconnect with the broader ECS system. The <code>Entity</code> structure combining <code>EntityID</code> and <code>Generation</code> serves as the fundamental reference type that flows through all component operations and system queries. The generation counter mechanism ensures that these references remain safe even as entity IDs are recycled through the free list management system.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The Entity Manager provides the foundation for all ECS operations, so its implementation must balance simplicity with performance. The following guidance helps you build a robust entity management system that will scale from simple prototypes to production games.</p>\n<p><strong>A. Technology Recommendations Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Entity Storage</td>\n<td><code>std::vector&lt;Generation&gt;</code> + <code>std::vector&lt;bool&gt;</code></td>\n<td>Custom packed bitfields with SIMD operations</td>\n</tr>\n<tr>\n<td>Free List</td>\n<td><code>std::queue&lt;EntityID&gt;</code></td>\n<td>Lock-free circular buffer for multithreading</td>\n</tr>\n<tr>\n<td>Entity Validation</td>\n<td>Simple array lookup</td>\n<td>Bloom filter for fast negative results</td>\n</tr>\n<tr>\n<td>Memory Management</td>\n<td>Standard allocators</td>\n<td>Custom memory pools for entity metadata</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  src/\n    ecs/\n      entity_manager.hpp           ← EntityManager class declaration\n      entity_manager.cpp           ← EntityManager implementation\n      entity_types.hpp             ← Entity, EntityID, Generation type definitions\n      entity_manager_test.cpp      ← Unit tests for entity lifecycle\n    core/\n      types.hpp                    ← Basic type definitions (uint32_t aliases)</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// entity_types.hpp - Complete type definitions ready to use</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cstdint></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;limits></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#B392F0\"> EntityID</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#B392F0\"> Generation</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#E1E4E8\"> EntityID INVALID_ENTITY_ID </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">numeric_limits</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">EntityID</span><span style=\"color:#E1E4E8\">>::</span><span style=\"color:#B392F0\">max</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#E1E4E8\"> Generation DEFAULT_GENERATION </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EntityID id;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Generation generation;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Entity</span><span style=\"color:#E1E4E8\">() : </span><span style=\"color:#B392F0\">id</span><span style=\"color:#E1E4E8\">(INVALID_ENTITY_ID), </span><span style=\"color:#B392F0\">generation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">) {}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Entity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EntityID</span><span style=\"color:#FFAB70\"> id_</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Generation</span><span style=\"color:#FFAB70\"> gen_</span><span style=\"color:#E1E4E8\">) : </span><span style=\"color:#B392F0\">id</span><span style=\"color:#E1E4E8\">(id_), </span><span style=\"color:#B392F0\">generation</span><span style=\"color:#E1E4E8\">(gen_) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">==</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> id </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> other.id </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> generation </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> other.generation;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">!=</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#E1E4E8\"> other);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> isValid</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> id </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> INVALID_ENTITY_ID </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> generation </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> Entity INVALID_ENTITY </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Hash function for using Entity as std::unordered_map key</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">namespace</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> hash</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">()</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> hash</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">>()((</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">(entity.generation) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> entity.id);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// entity_manager.hpp - Class declaration with complete interface</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"entity_types.hpp\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;queue></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;functional></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EntityManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    using</span><span style=\"color:#B392F0\"> EntityDestroyedCallback</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">function</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">)>;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    EntityManager</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ~EntityManager</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> default</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Core entity lifecycle operations</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Entity</span><span style=\"color:#B392F0\"> createEntity</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> destroyEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> isAlive</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Bulk operations for system queries</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">getAllEntities</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#B392F0\"> getAliveEntityCount</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Callback registration for component cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> registerDestroyCallback</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EntityDestroyedCallback</span><span style=\"color:#FFAB70\"> callback</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Debug and statistics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#B392F0\"> getFreeListSize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    EntityID</span><span style=\"color:#B392F0\"> getNextEntityID</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Generation</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> generations_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;bool></span><span style=\"color:#E1E4E8\"> aliveFlags_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::queue</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">EntityID</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> freeList_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EntityID nextEntityID_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">EntityDestroyedCallback</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> destroyCallbacks_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#E1E4E8\"> MAX_FREE_LIST_SIZE </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#E1E4E8\"> Generation PERMANENT_GENERATION </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">numeric_limits</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Generation</span><span style=\"color:#E1E4E8\">>::</span><span style=\"color:#B392F0\">max</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// entity_manager.cpp - Implementation skeleton with TODOs</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"entity_manager.hpp\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;algorithm></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cassert></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">EntityManager</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">EntityManager</span><span style=\"color:#E1E4E8\">() </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    : </span><span style=\"color:#B392F0\">nextEntityID_</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Reserve some initial capacity to avoid early reallocations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    generations_.</span><span style=\"color:#B392F0\">reserve</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    aliveFlags_.</span><span style=\"color:#B392F0\">reserve</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Entity</span><span style=\"color:#B392F0\"> EntityManager</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">createEntity</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EntityID entityID;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if free list has any recycled IDs available</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If free list not empty, pop the front ID for reuse</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If free list empty, allocate new ID from nextEntityID_ and increment it</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Ensure the generations_ and aliveFlags_ vectors are large enough for this ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Increment the generation counter for this entity ID slot</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Mark the entity as alive in aliveFlags_</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return Entity structure with the ID and new generation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use generations_.resize() if entityID >= generations_.size()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> EntityManager</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">destroyEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate that the entity is currently alive using isAlive()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If not alive, log warning and return early (don't crash)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Mark entity as not alive in aliveFlags_</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Increment generation counter for this entity ID (invalidates references)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Check if generation would overflow to 0 - if so, mark as permanent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: If not permanent, add entity ID to free list for recycling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Notify all registered destroy callbacks with the entity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: If free list exceeds MAX_FREE_LIST_SIZE, remove oldest entries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Check generation &#x3C; PERMANENT_GENERATION before incrementing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> EntityManager</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">isAlive</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if entity.id is within bounds of generations_ vector</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If out of bounds, return false (never allocated)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Look up current generation for this entity ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Compare entity.generation with current generation - must match exactly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Check aliveFlags_[entity.id] to verify entity is marked alive</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return true only if generation matches AND entity is alive</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use entity.id &#x3C; generations_.size() for bounds check</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">EntityManager</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">getAllEntities</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result.</span><span style=\"color:#B392F0\">reserve</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">getAliveEntityCount</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Iterate through all possible entity IDs up to generations_.size()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: For each ID, check if aliveFlags_[id] is true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If alive, create Entity(id, generations_[id]) and add to result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return the completed vector of alive entities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: This enables systems to iterate over all entities efficiently</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">size_t</span><span style=\"color:#B392F0\"> EntityManager</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">getAliveEntityCount</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Count the number of 'true' values in aliveFlags_</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Only count up to nextEntityID_ to avoid counting unallocated slots</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use std::count() algorithm or simple loop</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> EntityManager</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">registerDestroyCallback</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EntityDestroyedCallback</span><span style=\"color:#FFAB70\"> callback</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    destroyCallbacks_.</span><span style=\"color:#B392F0\">push_back</span><span style=\"color:#E1E4E8\">(callback);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">size_t</span><span style=\"color:#B392F0\"> EntityManager</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">getFreeListSize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> freeList_.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">EntityID</span><span style=\"color:#B392F0\"> EntityManager</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">getNextEntityID</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> nextEntityID_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints:</strong></p>\n<ul>\n<li><strong>Memory Efficiency</strong>: Use <code>std::vector&lt;bool&gt;</code> for alive flags — it&#39;s specially optimized to pack 8 booleans per byte</li>\n<li><strong>Performance</strong>: Reserve initial capacity for vectors to avoid reallocations during early entity creation</li>\n<li><strong>Thread Safety</strong>: This implementation is not thread-safe. For multithreaded use, add <code>std::mutex</code> around all public methods</li>\n<li><strong>Debugging</strong>: Add debug assertions with <code>assert()</code> to catch invalid entity access during development</li>\n<li><strong>Overflow Safety</strong>: Always check generation overflow before incrementing to prevent wraparound to 0</li>\n</ul>\n<p><strong>F. Milestone Checkpoint:</strong></p>\n<p>After implementing the Entity Manager, verify it works correctly:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Test basic entity lifecycle</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">EntityManager manager;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create entities and verify they're alive</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">Entity e1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> manager.</span><span style=\"color:#B392F0\">createEntity</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">Entity e2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> manager.</span><span style=\"color:#B392F0\">createEntity</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(manager.</span><span style=\"color:#B392F0\">isAlive</span><span style=\"color:#E1E4E8\">(e1));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(manager.</span><span style=\"color:#B392F0\">isAlive</span><span style=\"color:#E1E4E8\">(e2));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(manager.</span><span style=\"color:#B392F0\">getAliveEntityCount</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Destroy an entity and verify it's dead</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">manager.</span><span style=\"color:#B392F0\">destroyEntity</span><span style=\"color:#E1E4E8\">(e1);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">manager.</span><span style=\"color:#B392F0\">isAlive</span><span style=\"color:#E1E4E8\">(e1));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(manager.</span><span style=\"color:#B392F0\">isAlive</span><span style=\"color:#E1E4E8\">(e2));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(manager.</span><span style=\"color:#B392F0\">getAliveEntityCount</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create new entity and verify ID recycling</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">Entity e3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> manager.</span><span style=\"color:#B392F0\">createEntity</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(e3.id </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> e1.id);</span><span style=\"color:#6A737D\">  // Should reuse the ID</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(e3.generation </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> e1.generation);</span><span style=\"color:#6A737D\">  // But with higher generation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">manager.</span><span style=\"color:#B392F0\">isAlive</span><span style=\"color:#E1E4E8\">(e1));</span><span style=\"color:#6A737D\">  // Old reference still invalid</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(manager.</span><span style=\"color:#B392F0\">isAlive</span><span style=\"color:#E1E4E8\">(e3));</span><span style=\"color:#6A737D\">   // New reference valid</span></span></code></pre></div>\n\n<p>Expected behavior:</p>\n<ul>\n<li>Entity creation returns valid entities with unique generation numbers</li>\n<li>Destroyed entities fail <code>isAlive()</code> checks immediately</li>\n<li>Entity IDs get recycled but with incremented generation counters</li>\n<li><code>getAllEntities()</code> returns only currently alive entities</li>\n<li>Free list size grows when entities are destroyed and shrinks when IDs are recycled</li>\n</ul>\n<p>Signs something is wrong:</p>\n<ul>\n<li>Assertion failures indicating stale references aren&#39;t being invalidated</li>\n<li>Memory usage growing unbounded (free list not being managed properly)</li>\n<li>Entity IDs not being recycled (new entities always get fresh IDs)</li>\n<li>Crashes when accessing destroyed entities (generation validation not working)</li>\n</ul>\n<h2 id=\"component-storage-design\">Component Storage Design</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 2 (Component Storage) — implementing cache-friendly component storage with sparse sets for constant-time entity-to-component mapping</p>\n</blockquote>\n<p>The Component Storage system forms the data access backbone of our ECS architecture. While the Entity Manager handles entity lifecycles, the Component Storage system manages the actual component data that gives meaning to those entities. The fundamental challenge is maintaining both cache-friendly iteration patterns for systems processing many entities and constant-time random access for individual entity operations. Our solution employs sparse sets as the core data structure, providing the optimal balance between memory efficiency, access speed, and cache locality.</p>\n<h3 id=\"mental-model-warehouse-with-index-cards\">Mental Model: Warehouse with Index Cards</h3>\n<p>Think of the Component Storage system as a modern warehouse with a sophisticated indexing system. The warehouse has two distinct areas: the <strong>storage floor</strong> and the <strong>index card catalog</strong>.</p>\n<p>The <strong>storage floor</strong> contains rows of identical shelves, where each shelf holds one specific type of product (component type). All products of the same type are stored together in consecutive shelf positions for efficient bulk operations — imagine a forklift driver who can quickly process an entire row of the same product type. This represents our <strong>dense component arrays</strong> where all <code>Position</code> components are stored contiguously, all <code>Velocity</code> components are stored together, and so forth.</p>\n<p>The <strong>index card catalog</strong> sits at the warehouse entrance. Each customer (entity) has a unique customer ID number, but these ID numbers are not consecutive — customer #5 might be followed by customer #847. The index cards provide instant lookup: given any customer ID, you can immediately find which shelf position holds their specific products, if any. This represents our <strong>sparse arrays</strong> that map entity IDs to positions in the dense component arrays.</p>\n<p>When a customer places an order (system queries entities), they specify which product types they need. The warehouse staff can quickly scan the index catalog to identify which customers have all the required products, then efficiently walk through the storage floor collecting items shelf by shelf. When a customer cancels their account (entity destruction), their index card is removed and their shelf positions are marked available for the next customer.</p>\n<p>This mental model captures three critical aspects: sparse entity IDs require indirect indexing, components of the same type benefit from contiguous storage, and the mapping between sparse IDs and dense storage must be bidirectional for efficient insertion and removal operations.</p>\n<h3 id=\"sparse-set-data-structure\">Sparse Set Data Structure</h3>\n<p><img src=\"/api/project/ecs-arch/architecture-doc/asset?path=diagrams%2Fsparse-set-structure.svg\" alt=\"Sparse Set Data Structure\"></p>\n<p>The sparse set data structure forms the mathematical foundation of our component storage system. Unlike traditional hash tables or binary trees, sparse sets provide true O(1) operations for all basic operations: insertion, deletion, lookup, and membership testing. Understanding their internal mechanics is crucial for implementing an efficient ECS system.</p>\n<p>A sparse set consists of three parallel arrays that work together to create a bidirectional mapping:</p>\n<table>\n<thead>\n<tr>\n<th>Array Name</th>\n<th>Purpose</th>\n<th>Size</th>\n<th>Access Pattern</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>dense</code></td>\n<td>Stores actual component data contiguously</td>\n<td>Number of entities with this component</td>\n<td>Sequential iteration for systems</td>\n</tr>\n<tr>\n<td><code>sparse</code></td>\n<td>Maps entity IDs to dense array indices</td>\n<td>Maximum possible entity ID + 1</td>\n<td>Random access by entity ID</td>\n</tr>\n<tr>\n<td><code>entities</code></td>\n<td>Maps dense array indices back to entity IDs</td>\n<td>Same size as dense array</td>\n<td>Reverse lookup during removal</td>\n</tr>\n</tbody></table>\n<p>The <strong>dense array</strong> stores the actual component data in contiguous memory. When a system iterates over all entities with <code>Position</code> components, it walks through this array linearly, achieving optimal cache locality. Each position in the dense array corresponds to exactly one entity that possesses this component type.</p>\n<p>The <strong>sparse array</strong> provides the mapping from entity IDs to dense array positions. Given an entity ID of 847, we check <code>sparse[847]</code> to find which position in the dense array holds that entity&#39;s component. If <code>sparse[847]</code> contains 23, then <code>dense[23]</code> holds entity 847&#39;s component data.</p>\n<p>The <strong>entities array</strong> enables reverse lookup during removal operations. When we need to remove entity 847&#39;s component from position 23 in the dense array, we must update the sparse array entry for whichever entity gets moved to fill the gap. The entities array tells us which entity ID corresponds to each dense array position.</p>\n<blockquote>\n<p><strong>Design Insight</strong>: The bidirectional mapping is essential for efficient removal. Without the entities array, removing a component would require a linear search through the sparse array to update the mapping for the entity that gets moved during the swap-remove operation.</p>\n</blockquote>\n<p>The insertion algorithm demonstrates the sparse set&#39;s elegance:</p>\n<ol>\n<li><strong>Validate entity existence</strong>: Confirm the entity ID is valid and the entity is currently alive</li>\n<li><strong>Check for existing component</strong>: If <code>sparse[entityID]</code> points to a valid dense array position and <code>entities[sparse[entityID]] == entityID</code>, the entity already has this component type</li>\n<li><strong>Append to dense array</strong>: Add the new component data to the end of the dense array at position <code>denseSize</code></li>\n<li><strong>Update sparse mapping</strong>: Set <code>sparse[entityID] = denseSize</code> to point the entity ID to its component&#39;s position</li>\n<li><strong>Update reverse mapping</strong>: Set <code>entities[denseSize] = entityID</code> to enable reverse lookup</li>\n<li><strong>Increment size counter</strong>: Increase <code>denseSize</code> to reflect the additional component</li>\n</ol>\n<p>The removal algorithm employs the swap-remove technique to maintain contiguous storage:</p>\n<ol>\n<li><strong>Validate component exists</strong>: Confirm <code>sparse[entityID]</code> points to a valid position and the reverse mapping is consistent</li>\n<li><strong>Identify positions</strong>: The component to remove is at position <code>removeIndex = sparse[entityID]</code>, and the last component is at position <code>lastIndex = denseSize - 1</code></li>\n<li><strong>Swap elements</strong>: Move the last component to fill the gap: <code>dense[removeIndex] = dense[lastIndex]</code></li>\n<li><strong>Update sparse mapping</strong>: The moved entity needs its sparse array updated: <code>sparse[entities[lastIndex]] = removeIndex</code></li>\n<li><strong>Update reverse mapping</strong>: The new position needs the correct entity ID: <code>entities[removeIndex] = entities[lastIndex]</code></li>\n<li><strong>Decrement size counter</strong>: Reduce <code>denseSize</code> to reflect the removed component</li>\n<li><strong>Optional cleanup</strong>: Mark <code>sparse[entityID]</code> as invalid to prevent stale access</li>\n</ol>\n<blockquote>\n<p><strong>Critical Implementation Detail</strong>: The membership test <code>sparse[entityID] &lt; denseSize &amp;&amp; entities[sparse[entityID]] == entityID</code> prevents false positives when sparse array positions contain stale indices from previously removed components.</p>\n</blockquote>\n<p><img src=\"/api/project/ecs-arch/architecture-doc/asset?path=diagrams%2Fdata-model-relationships.svg\" alt=\"Core Data Types and Relationships\"></p>\n<p><strong>Decision: Sparse Set vs Hash Table for Component Storage</strong></p>\n<ul>\n<li><strong>Context</strong>: We need constant-time access to components by entity ID while maintaining cache-friendly iteration for systems. Hash tables, dynamic arrays, and sparse sets are the primary contenders.</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Hash table with entity IDs as keys and component pointers as values</li>\n<li>Dynamic array indexed directly by entity ID</li>\n<li>Sparse set with dense component array and sparse index mapping</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Sparse set implementation with separate dense and sparse arrays</li>\n<li><strong>Rationale</strong>: Hash tables suffer from cache misses during iteration due to scattered memory layout and require expensive rehashing. Direct indexing by entity ID wastes enormous memory when entity IDs are sparse (entity 1,000,000 would require a million-element array). Sparse sets provide O(1) access like hash tables but guarantee contiguous storage for cache-friendly iteration while using memory proportional to the number of actual components, not the maximum entity ID.</li>\n<li><strong>Consequences</strong>: Enables SIMD vectorization of component processing loops, eliminates memory waste from sparse entity ID spaces, and maintains constant-time operations for all component access patterns. The trade-off is slightly more complex implementation logic and the need to maintain three parallel arrays instead of a single hash table.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Storage Option</th>\n<th>Access Time</th>\n<th>Iteration Speed</th>\n<th>Memory Usage</th>\n<th>Cache Locality</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Hash Table</td>\n<td>O(1) average</td>\n<td>Poor (scattered)</td>\n<td>High (overhead)</td>\n<td>Poor</td>\n</tr>\n<tr>\n<td>Direct Array</td>\n<td>O(1)</td>\n<td>Excellent</td>\n<td>Terrible (sparse)</td>\n<td>Excellent</td>\n</tr>\n<tr>\n<td>Sparse Set</td>\n<td>O(1)</td>\n<td>Excellent</td>\n<td>Optimal</td>\n<td>Excellent</td>\n</tr>\n</tbody></table>\n<h3 id=\"type-safe-component-access\">Type-Safe Component Access</h3>\n<p>Component type safety prevents runtime errors that can corrupt game state or crash the application. In a dynamically composed ECS system where entities can have arbitrary component combinations, the type system must enforce that systems only access components that actually exist and match the expected types.</p>\n<p>The component type registry serves as the central authority for component metadata. Every component type receives a unique <code>ComponentTypeID</code> during registration, along with essential metadata for memory management and type verification:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>typeID</code></td>\n<td><code>ComponentTypeID</code></td>\n<td>Unique identifier for this component type</td>\n</tr>\n<tr>\n<td><code>name</code></td>\n<td><code>string</code></td>\n<td>Human-readable type name for debugging</td>\n</tr>\n<tr>\n<td><code>size</code></td>\n<td><code>size_t</code></td>\n<td>Memory footprint in bytes for allocation</td>\n</tr>\n<tr>\n<td><code>alignment</code></td>\n<td><code>size_t</code></td>\n<td>Memory alignment requirements for performance</td>\n</tr>\n<tr>\n<td><code>destructor</code></td>\n<td>Function pointer</td>\n<td>Cleanup function for complex component types</td>\n</tr>\n<tr>\n<td><code>moveConstructor</code></td>\n<td>Function pointer</td>\n<td>Efficient relocation during storage operations</td>\n</tr>\n</tbody></table>\n<p>The type-safe access system operates through template specialization and compile-time type resolution. When code requests <code>getComponent&lt;Position&gt;(entity)</code>, the compiler instantiates a specialized version of the component storage access functions that can only operate on <code>Position</code> components.</p>\n<p>Template-based component registration happens automatically through C++ template magic:</p>\n<ol>\n<li><strong>First access triggers registration</strong>: When <code>getComponent&lt;Position&gt;()</code> is called for the first time, template instantiation triggers automatic type registration</li>\n<li><strong>Compile-time type ID generation</strong>: Each component type receives a unique type ID based on template instantiation order or type hashing</li>\n<li><strong>Storage creation</strong>: A specialized <code>ComponentStorage&lt;Position&gt;</code> instance is created to hold all <code>Position</code> components</li>\n<li><strong>Interface registration</strong>: The storage instance is registered with the type-erased interface system for runtime polymorphic access</li>\n</ol>\n<p>The type-erased interface enables runtime polymorphism while preserving compile-time type safety. The <code>IComponentStorage</code> base class provides virtual methods that component-specific storage classes implement:</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>removeComponent</code></td>\n<td><code>Entity</code></td>\n<td><code>bool</code></td>\n<td>Remove component from entity without knowing specific type</td>\n</tr>\n<tr>\n<td><code>hasComponent</code></td>\n<td><code>Entity</code></td>\n<td><code>bool</code></td>\n<td>Check component existence without type information</td>\n</tr>\n<tr>\n<td><code>moveComponent</code></td>\n<td><code>Entity, Entity</code></td>\n<td><code>void</code></td>\n<td>Transfer component between entities during archetype transitions</td>\n</tr>\n<tr>\n<td><code>getTypeInfo</code></td>\n<td>None</td>\n<td><code>ComponentTypeInfo</code></td>\n<td>Retrieve metadata for this component type</td>\n</tr>\n<tr>\n<td><code>getComponentCount</code></td>\n<td>None</td>\n<td><code>size_t</code></td>\n<td>Count total components of this type</td>\n</tr>\n<tr>\n<td><code>clear</code></td>\n<td>None</td>\n<td><code>void</code></td>\n<td>Remove all components (used during world destruction)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight</strong>: The combination of compile-time templates and runtime type erasure provides both performance and flexibility. Templates eliminate virtual function overhead in hot paths, while type erasure enables generic algorithms that work with any component type.</p>\n</blockquote>\n<p><strong>Decision: Template-Based vs Runtime Type System</strong></p>\n<ul>\n<li><strong>Context</strong>: Components must be accessed efficiently with type safety, but the ECS system also needs runtime flexibility for tools, serialization, and generic algorithms.</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Pure template system with all type information at compile time</li>\n<li>Runtime type system with string-based or ID-based type lookup</li>\n<li>Hybrid system with templates for performance and type-erased interfaces for flexibility</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Hybrid template and type-erased interface system</li>\n<li><strong>Rationale</strong>: Pure templates provide optimal performance but prevent runtime component access needed for debugging tools and data serialization. Pure runtime systems sacrifice performance and type safety. The hybrid approach uses templates for hot paths where systems access known component types, and type-erased interfaces for cold paths like entity destruction and tool integration.</li>\n<li><strong>Consequences</strong>: Systems achieve optimal performance through direct template instantiation while maintaining flexibility for runtime operations. The cost is increased implementation complexity and larger binary size due to template instantiation.</li>\n</ul>\n<p>The component access API enforces type safety through careful interface design:</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Template Parameter</th>\n<th>Return Type</th>\n<th>Safety Guarantee</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>addComponent&lt;T&gt;</code></td>\n<td>Component type T</td>\n<td><code>T&amp;</code></td>\n<td>Creates typed storage if needed, returns reference to new component</td>\n</tr>\n<tr>\n<td><code>getComponent&lt;T&gt;</code></td>\n<td>Component type T</td>\n<td><code>T&amp;</code></td>\n<td>Throws exception if component doesn&#39;t exist, otherwise returns typed reference</td>\n</tr>\n<tr>\n<td><code>tryGetComponent&lt;T&gt;</code></td>\n<td>Component type T</td>\n<td><code>T*</code></td>\n<td>Returns null pointer if component doesn&#39;t exist, otherwise returns typed pointer</td>\n</tr>\n<tr>\n<td><code>hasComponent&lt;T&gt;</code></td>\n<td>Component type T</td>\n<td><code>bool</code></td>\n<td>Safe existence check without accessing component data</td>\n</tr>\n<tr>\n<td><code>removeComponent&lt;T&gt;</code></td>\n<td>Component type T</td>\n<td><code>bool</code></td>\n<td>Returns true if component was removed, false if it didn&#39;t exist</td>\n</tr>\n</tbody></table>\n<p>Runtime type validation occurs at key points to catch programming errors early:</p>\n<ol>\n<li><strong>Component access validation</strong>: Before returning component references, verify the entity is alive and possesses the requested component type</li>\n<li><strong>Storage type matching</strong>: Ensure the template parameter matches the storage container&#39;s actual type to prevent type confusion</li>\n<li><strong>Memory layout verification</strong>: Validate component size and alignment match registered type information to catch ABI mismatches</li>\n<li><strong>Entity lifecycle checking</strong>: Prevent access to components on destroyed entities through generation counter validation</li>\n</ol>\n<h3 id=\"common-component-storage-pitfalls\">Common Component Storage Pitfalls</h3>\n<p>Component storage systems introduce subtle bugs that can cause memory corruption, performance degradation, or incorrect game behavior. Understanding these pitfalls helps avoid hours of debugging and ensures robust ECS implementations.</p>\n<p>⚠️ <strong>Pitfall: Iterator Invalidation During Component Modification</strong></p>\n<p>The most dangerous pitfall occurs when systems modify component storage while iterating over components. Consider this scenario: a combat system iterates through all entities with <code>Health</code> components, and during processing, one entity&#39;s health drops to zero, triggering entity destruction that removes its <code>Health</code> component. The swap-remove operation moves the last <code>Health</code> component to fill the gap, but the iterator continues from the next position, skipping the moved component entirely.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Initial state: [Health_A, Health_B, Health_C, Health_D]\nIterator at position 1 (Health_B)\nHealth_B drops to 0, entity destroyed\nAfter removal: [Health_A, Health_D, Health_C] (D moved to position 1)\nIterator advances to position 2, skipping Health_D entirely</code></pre></div>\n\n<p>This manifests as entities mysteriously not receiving damage, healing effects, or other component-based processing. The fix requires careful iteration patterns: either collect entities to modify in a separate pass, use reverse iteration when removing components, or implement removal-safe iterators that account for swap-remove semantics.</p>\n<p>⚠️ <strong>Pitfall: Stale Sparse Array Indices</strong></p>\n<p>Sparse arrays can contain stale indices that point to dense array positions occupied by different entities. When entity 847 is destroyed, its sparse array entry <code>sparse[847]</code> retains the old dense array index. If that position is later filled by entity 1205&#39;s component, checking <code>sparse[847]</code> returns a valid index that points to entity 1205&#39;s data instead of indicating entity 847 has no component.</p>\n<p>The membership test <code>sparse[entityID] &lt; denseSize &amp;&amp; entities[sparse[entityID]] == entityID</code> prevents this bug by verifying the reverse mapping. However, systems that skip this validation and directly access <code>dense[sparse[entityID]]</code> will read incorrect component data, leading to entities affecting each other&#39;s behavior in bizarre ways.</p>\n<p>⚠️ <strong>Pitfall: ABA Problem in Component References</strong></p>\n<p>Component references can become invalid when entities are destroyed and their IDs recycled. A system holds a <code>Position&amp;</code> reference to entity 500&#39;s position component. Entity 500 is destroyed, its ID is recycled, and a new entity receives ID 500 with a different position component. The original reference now points to the new entity&#39;s data, causing the system to modify the wrong entity&#39;s position.</p>\n<p>This is particularly dangerous in systems that cache component references across multiple frames. The solution requires either using entity-based access instead of caching references, implementing reference invalidation tracking, or using generation counters to detect when entity IDs have been recycled.</p>\n<p>⚠️ <strong>Pitfall: Component Storage Memory Leaks</strong></p>\n<p>Components containing dynamically allocated resources (strings, vectors, smart pointers) can leak memory when removed from storage without proper destruction. The sparse set swap-remove operation moves component data using <code>memcpy</code> or similar techniques, but doesn&#39;t invoke destructors on the original location.</p>\n<p>For example, a <code>Name</code> component containing a <code>std::string</code> must have its destructor called when removed, or the string&#39;s internal buffer leaks. The component type registry&#39;s destructor function pointer addresses this by calling the appropriate cleanup code during component removal.</p>\n<p>⚠️ <strong>Pitfall: Sparse Array Memory Explosion</strong></p>\n<p>When entity IDs become very large, sparse arrays consume excessive memory. An entity with ID 1,000,000 requires a sparse array with at least one million elements, even if only ten entities exist. This wastes gigabytes of memory and degrades cache performance due to the large memory footprint.</p>\n<p>The solution involves either using hash tables for extremely sparse entity ID spaces, implementing segmented sparse arrays that allocate memory in chunks, or constraining entity ID generation to reasonable ranges with ID recycling policies.</p>\n<p>⚠️ <strong>Pitfall: Inconsistent Component Type Registration</strong></p>\n<p>Different compilation units can register the same component type with different type IDs if template instantiation occurs in different orders. This causes <code>Position</code> components added in one source file to be invisible to systems in another source file because they&#39;re stored in different type ID storage containers.</p>\n<p>Explicit component type registration during world initialization prevents this by ensuring consistent type ID assignment across all compilation units. The registration order must be deterministic and occur before any component operations.</p>\n<p>⚠️ <strong>Pitfall: Dense Array Capacity Management</strong></p>\n<p>Frequent component addition and removal can cause memory fragmentation and performance degradation if dense arrays repeatedly reallocate. Adding components to arrays that frequently exceed capacity triggers expensive copy operations that move all existing components to larger memory blocks.</p>\n<p>Pre-allocating dense array capacity based on expected entity counts amortizes reallocation costs. However, over-allocation wastes memory, while under-allocation causes performance spikes. Monitoring component count statistics helps find the optimal balance.</p>\n<p>⚠️ <strong>Pitfall: Thread Safety Assumptions</strong></p>\n<p>Component storage operations are not thread-safe by default. Multiple systems accessing components concurrently can cause race conditions where component data is corrupted, sparse array mappings become inconsistent, or dense array size counters become inaccurate.</p>\n<p>Even read-only access can be unsafe if other threads are modifying component storage simultaneously. The swap-remove operation temporarily creates inconsistent state where sparse mappings point to incorrect dense array positions until the update completes.</p>\n<p>Thread safety requires either system scheduling that prevents concurrent access to the same component types, reader-writer locks around component storage operations, or lockless data structures designed for concurrent access.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The Component Storage implementation bridges the gap between sparse set theory and practical ECS performance. This section provides complete working code for component infrastructure and detailed skeletons for core storage algorithms.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Type Registration</td>\n<td>Manual registration with macros</td>\n<td>Automatic template-based registration</td>\n</tr>\n<tr>\n<td>Memory Management</td>\n<td>Raw arrays with manual resize</td>\n<td>Custom allocators with memory pools</td>\n</tr>\n<tr>\n<td>Type Safety</td>\n<td>Runtime type ID checking</td>\n<td>Compile-time template constraints</td>\n</tr>\n<tr>\n<td>Container Library</td>\n<td>Standard library containers</td>\n<td>Custom containers optimized for ECS</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ecs-project/\n  include/ecs/\n    component_storage.hpp       ← Public component storage interface\n    component_registry.hpp     ← Component type registration system\n    sparse_set.hpp             ← Core sparse set implementation\n    component_types.hpp        ← Sample component definitions\n  src/ecs/\n    component_storage.cpp      ← Implementation of storage classes\n    component_registry.cpp    ← Type registration implementation\n  tests/\n    test_component_storage.cpp ← Unit tests for component operations\n    test_sparse_set.cpp       ← Tests for sparse set data structure\n  examples/\n    component_demo.cpp        ← Usage examples and benchmarks</code></pre></div>\n\n<p><strong>Infrastructure Starter Code (Complete Implementation):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// include/ecs/component_types.hpp</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cstdint></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;functional></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#B392F0\"> EntityID</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#B392F0\"> Generation</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#B392F0\"> ComponentTypeID</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EntityID id;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Generation generation;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">==</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> id </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> other.id </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> generation </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> other.generation;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#E1E4E8\"> EntityID INVALID_ENTITY_ID </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> UINT32_MAX;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#E1E4E8\"> Generation DEFAULT_GENERATION </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#E1E4E8\"> ComponentTypeID MAX_COMPONENTS </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 256</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Sample component types for testing and examples</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> Position</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> x, y;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Position</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> x</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> y</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">) : </span><span style=\"color:#B392F0\">x</span><span style=\"color:#E1E4E8\">(x), </span><span style=\"color:#B392F0\">y</span><span style=\"color:#E1E4E8\">(y) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> Velocity</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> dx, dy;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Velocity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> dx</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> dy</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">) : </span><span style=\"color:#B392F0\">dx</span><span style=\"color:#E1E4E8\">(dx), </span><span style=\"color:#B392F0\">dy</span><span style=\"color:#E1E4E8\">(dy) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> Health</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> current, maximum;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Health</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> max</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">) : </span><span style=\"color:#B392F0\">current</span><span style=\"color:#E1E4E8\">(max), </span><span style=\"color:#B392F0\">maximum</span><span style=\"color:#E1E4E8\">(max) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> ComponentTypeInfo</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ComponentTypeID typeID;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::string name;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> alignment;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::function</span><span style=\"color:#F97583\">&#x3C;void</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> destructor;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::function</span><span style=\"color:#F97583\">&#x3C;void</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> moveConstructor;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// include/ecs/component_registry.hpp</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"component_types.hpp\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unordered_map></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;typeinfo></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;typeindex></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ComponentTypeRegistry</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#E1E4E8\"> ComponentTypeRegistry</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> instance_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::type_index, ComponentTypeID</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> typeToID_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ComponentTypeID, ComponentTypeInfo</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> idToInfo_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ComponentTypeID nextTypeID_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ComponentTypeRegistry</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> default</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#B392F0\"> ComponentTypeRegistry</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> getInstance</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">instance_) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            instance_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> ComponentTypeRegistry</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">instance_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ComponentTypeID</span><span style=\"color:#B392F0\"> registerComponentType</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::type_index </span><span style=\"color:#B392F0\">typeIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">typeid</span><span style=\"color:#E1E4E8\">(T));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> it </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> typeToID_.</span><span style=\"color:#B392F0\">find</span><span style=\"color:#E1E4E8\">(typeIndex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (it </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> typeToID_.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> it->second;</span><span style=\"color:#6A737D\">  // Already registered</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ComponentTypeID typeID </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> nextTypeID_</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        typeToID_[typeIndex] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> typeID;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ComponentTypeInfo info;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        info.typeID </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> typeID;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        info.name </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> typeid</span><span style=\"color:#E1E4E8\">(T).</span><span style=\"color:#B392F0\">name</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        info.size </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(T);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        info.alignment </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> alignof</span><span style=\"color:#E1E4E8\">(T);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::is_trivially_destructible_v</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">T</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            info.destructor </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [](</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                static_cast&#x3C;</span><span style=\"color:#E1E4E8\">T</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\">(ptr)-></span><span style=\"color:#B392F0\">~T</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> constexpr</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::is_trivially_move_constructible_v</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">T</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            info.moveConstructor </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [](</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> dest</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> src</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                new</span><span style=\"color:#E1E4E8\"> (dest) </span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">move</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*static_cast&#x3C;</span><span style=\"color:#E1E4E8\">T</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\">(src)));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        idToInfo_[typeID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> info;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> typeID;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ComponentTypeID</span><span style=\"color:#B392F0\"> getComponentTypeID</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::type_index </span><span style=\"color:#B392F0\">typeIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">typeid</span><span style=\"color:#E1E4E8\">(T));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> it </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> typeToID_.</span><span style=\"color:#B392F0\">find</span><span style=\"color:#E1E4E8\">(typeIndex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (it </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> typeToID_.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">()) </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> it->second </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> UINT32_MAX;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#B392F0\"> ComponentTypeInfo</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> getTypeInfo</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ComponentTypeID</span><span style=\"color:#FFAB70\"> typeID</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> it </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> idToInfo_.</span><span style=\"color:#B392F0\">find</span><span style=\"color:#E1E4E8\">(typeID);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (it </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> idToInfo_.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">()) </span><span style=\"color:#F97583\">?</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">it->second </span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> nullptr</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ComponentTypeRegistry</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> ComponentTypeRegistry</span><span style=\"color:#E1E4E8\">::instance_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> nullptr</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton Code:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// include/ecs/sparse_set.hpp</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"component_types.hpp\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdexcept></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SparseSet</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">T</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> dense_;</span><span style=\"color:#6A737D\">           // Contiguous component storage</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;size_t></span><span style=\"color:#E1E4E8\"> sparse_;</span><span style=\"color:#6A737D\">     // Maps entity ID to dense index</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">EntityID</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> entities_;</span><span style=\"color:#6A737D\"> // Maps dense index to entity ID</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> maxEntityID_;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    explicit</span><span style=\"color:#B392F0\"> SparseSet</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> maxEntities</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">) : </span><span style=\"color:#B392F0\">maxEntityID_</span><span style=\"color:#E1E4E8\">(maxEntities) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sparse_.</span><span style=\"color:#B392F0\">resize</span><span style=\"color:#E1E4E8\">(maxEntities, SIZE_MAX);</span><span style=\"color:#6A737D\">  // SIZE_MAX as sentinel</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Insert component for entity - returns reference to inserted component</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EntityID</span><span style=\"color:#FFAB70\"> entityID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">T</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#FFAB70\"> component</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Validate entityID is within bounds (&#x3C; maxEntityID_)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Check if entity already has component - if so, replace it</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Expand sparse array if entityID >= sparse_.size()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Add component to end of dense array</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Update sparse[entityID] to point to new dense index</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: Update entities array to map dense index back to entityID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 7: Return reference to newly inserted component</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: dense_.size() before insertion is the new component's index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Remove component for entity - returns true if component existed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> remove</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EntityID</span><span style=\"color:#FFAB70\"> entityID</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Check if entity has component using contains() logic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Get dense index where component is stored</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: If removing last element, just pop_back and update size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Otherwise, move last element to fill gap (swap-remove)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Update sparse mapping for the moved element</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: Update entities mapping for the moved element's position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 7: Mark removed entity's sparse entry as invalid (SIZE_MAX)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 8: Remove last element from dense and entities arrays</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: The entity being moved is entities_.back()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if entity has component</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> contains</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EntityID</span><span style=\"color:#FFAB70\"> entityID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Check if entityID is within sparse array bounds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Get dense index from sparse[entityID]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Verify index is valid (&#x3C; dense_.size())</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Verify reverse mapping is consistent (entities_[index] == entityID)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: This prevents stale indices from returning true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get component reference - throws if not found</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> get</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EntityID</span><span style=\"color:#FFAB70\"> entityID</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Use contains() to verify component exists</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: If not found, throw std::runtime_error with descriptive message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Return reference to component at dense_[sparse_[entityID]]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Message should include entity ID for debugging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get component pointer - returns nullptr if not found</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> tryGet</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EntityID</span><span style=\"color:#FFAB70\"> entityID</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Use contains() to check if component exists</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: If exists, return pointer to dense_[sparse_[entityID]]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: If not exists, return nullptr</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: This is the safe alternative to get() for optional access</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Iterator support for system queries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    typename</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">>::</span><span style=\"color:#B392F0\">iterator</span><span style=\"color:#B392F0\"> begin</span><span style=\"color:#E1E4E8\">() { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> dense_.</span><span style=\"color:#B392F0\">begin</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    typename</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">>::</span><span style=\"color:#B392F0\">iterator</span><span style=\"color:#B392F0\"> end</span><span style=\"color:#E1E4E8\">() { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> dense_.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    typename</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">>::</span><span style=\"color:#B392F0\">const_iterator</span><span style=\"color:#B392F0\"> begin</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> dense_.</span><span style=\"color:#B392F0\">begin</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    typename</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">>::</span><span style=\"color:#B392F0\">const_iterator</span><span style=\"color:#B392F0\"> end</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> dense_.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Access entity ID by dense array index during iteration</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    EntityID</span><span style=\"color:#B392F0\"> getEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> denseIndex</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (denseIndex </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> entities_.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">()) </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> entities_[denseIndex] </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> INVALID_ENTITY_ID;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#B392F0\"> size</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> dense_.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> empty</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> dense_.</span><span style=\"color:#B392F0\">empty</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> clear</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        dense_.</span><span style=\"color:#B392F0\">clear</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        entities_.</span><span style=\"color:#B392F0\">clear</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">fill</span><span style=\"color:#E1E4E8\">(sparse_.</span><span style=\"color:#B392F0\">begin</span><span style=\"color:#E1E4E8\">(), sparse_.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">(), SIZE_MAX);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// include/ecs/component_storage.hpp</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"sparse_set.hpp\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"component_registry.hpp\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unordered_map></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;memory></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Type-erased interface for runtime component operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> IComponentStorage</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#B392F0\"> ~IComponentStorage</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> default</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> removeComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EntityID</span><span style=\"color:#FFAB70\"> entityID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> hasComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EntityID</span><span style=\"color:#FFAB70\"> entityID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#B392F0\"> ComponentTypeID</span><span style=\"color:#B392F0\"> getTypeID</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#B392F0\"> getComponentCount</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> clear</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Typed component storage implementation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ComponentStorage</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#F97583\">public</span><span style=\"color:#B392F0\"> IComponentStorage</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SparseSet</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">T</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> storage_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ComponentTypeID typeID_;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ComponentStorage</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto&#x26;</span><span style=\"color:#E1E4E8\"> registry </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ComponentTypeRegistry</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">getInstance</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        typeID_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> registry.registerComponentType</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">T</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add component to entity with perfect forwarding</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> addComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EntityID</span><span style=\"color:#FFAB70\"> entityID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Construct component with forwarded arguments</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Use storage_.insert() to add component</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Return reference to added component</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: T{std::forward&#x3C;Args>(args)...} constructs component</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Remove component from entity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> removeComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EntityID</span><span style=\"color:#FFAB70\"> entityID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">override</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Use storage_.remove() to remove component</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Return the result (true if removed, false if didn't exist)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if entity has this component type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> hasComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EntityID</span><span style=\"color:#FFAB70\"> entityID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> override</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Use storage_.contains() to check existence</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Return the result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get component reference - throws if not found</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> getComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EntityID</span><span style=\"color:#FFAB70\"> entityID</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Use storage_.get() to retrieve component</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Return reference (exception handling is in SparseSet)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Try to get component - returns nullptr if not found</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> tryGetComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EntityID</span><span style=\"color:#FFAB70\"> entityID</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Use storage_.tryGet() to safely retrieve component</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Return pointer (nullptr if not found)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Implementation of IComponentStorage interface</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ComponentTypeID</span><span style=\"color:#B392F0\"> getTypeID</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> override</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> typeID_; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#B392F0\"> getComponentCount</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> override</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> storage_.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> clear</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">override</span><span style=\"color:#E1E4E8\"> { storage_.</span><span style=\"color:#B392F0\">clear</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Iterator access for systems</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    auto</span><span style=\"color:#B392F0\"> begin</span><span style=\"color:#E1E4E8\">() { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> storage_.</span><span style=\"color:#B392F0\">begin</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    auto</span><span style=\"color:#B392F0\"> end</span><span style=\"color:#E1E4E8\">() { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> storage_.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    auto</span><span style=\"color:#B392F0\"> begin</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> storage_.</span><span style=\"color:#B392F0\">begin</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    auto</span><span style=\"color:#B392F0\"> end</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> storage_.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Access entity ID during iteration</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    EntityID</span><span style=\"color:#B392F0\"> getEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> index</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> storage_.</span><span style=\"color:#B392F0\">getEntity</span><span style=\"color:#E1E4E8\">(index); }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// World class that manages all component storage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> World</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ComponentTypeID, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">IComponentStorage</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> componentStorages_;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ComponentStorage</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> getOrCreateStorage</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto&#x26;</span><span style=\"color:#E1E4E8\"> registry </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ComponentTypeRegistry</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">getInstance</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ComponentTypeID typeID </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> registry.registerComponentType</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">T</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> it </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> componentStorages_.</span><span style=\"color:#B392F0\">find</span><span style=\"color:#E1E4E8\">(typeID);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (it </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> componentStorages_.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            auto</span><span style=\"color:#E1E4E8\"> storage </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">make_unique</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">ComponentStorage</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">>>();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            auto*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> storage.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            componentStorages_[typeID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">move</span><span style=\"color:#E1E4E8\">(storage);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> static_cast&#x3C;</span><span style=\"color:#E1E4E8\">ComponentStorage</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">T</span><span style=\"color:#F97583\">>*></span><span style=\"color:#E1E4E8\">(it->second.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add component to entity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> addComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EntityID</span><span style=\"color:#FFAB70\"> entityID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Get or create storage for component type T</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Use storage->addComponent() with forwarded arguments</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Return reference to added component</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Remove component from entity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> removeComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EntityID</span><span style=\"color:#FFAB70\"> entityID</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Get storage for component type T</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: If storage doesn't exist, return false</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Use storage->removeComponent() and return result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get component reference</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> getComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EntityID</span><span style=\"color:#FFAB70\"> entityID</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Get storage for component type T</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: If storage doesn't exist, throw std::runtime_error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Use storage->getComponent() and return reference</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if entity has component</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> hasComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EntityID</span><span style=\"color:#FFAB70\"> entityID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Get storage for component type T</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: If storage doesn't exist, return false</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Use storage->hasComponent() and return result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoint:</strong></p>\n<p>After implementing the component storage system, verify your implementation with these tests:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Compile and run unit tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">g++</span><span style=\"color:#79B8FF\"> -std=c++17</span><span style=\"color:#79B8FF\"> -I</span><span style=\"color:#9ECBFF\"> include</span><span style=\"color:#9ECBFF\"> tests/test_component_storage.cpp</span><span style=\"color:#9ECBFF\"> src/ecs/</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#9ECBFF\">.cpp</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> test_storage</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./test_storage</span></span></code></pre></div>\n\n<p>Expected behavior verification:</p>\n<ol>\n<li><strong>Component Addition</strong>: Create entities and add <code>Position</code>, <code>Velocity</code>, and <code>Health</code> components. Verify <code>hasComponent&lt;T&gt;()</code> returns true.</li>\n<li><strong>Component Access</strong>: Retrieve component references and verify data integrity. Modify components and confirm changes persist.</li>\n<li><strong>Component Removal</strong>: Remove components and verify <code>hasComponent&lt;T&gt;()</code> returns false. Ensure other components remain unaffected.</li>\n<li><strong>Iterator Performance</strong>: Add 10,000 entities with <code>Position</code> components. Time iteration - should process 1M+ components per millisecond.</li>\n<li><strong>Memory Usage</strong>: Monitor memory usage as components are added/removed. Verify memory is reclaimed when components are removed.</li>\n</ol>\n<p>Signs of problems and fixes:</p>\n<ul>\n<li><strong>Segmentation fault on component access</strong>: Check entity ID bounds validation and sparse array sizing</li>\n<li><strong>Stale component data</strong>: Verify the bidirectional mapping check in <code>contains()</code> method</li>\n<li><strong>Memory leaks</strong>: Ensure destructors are called through the component registry&#39;s destructor function pointers</li>\n<li><strong>Poor iteration performance</strong>: Profile cache misses - dense arrays should have &gt;95% cache hit rate during iteration</li>\n</ul>\n<h2 id=\"system-interface-design\">System Interface Design</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 3 (System Interface) — implementing system execution framework with component queries and execution ordering</p>\n</blockquote>\n<p>The System Interface provides the execution framework that brings our ECS architecture to life. While entities provide identity and components store data, systems contain the actual game logic that operates on that data each frame. The key architectural challenge is providing systems with an efficient way to find and iterate over entities that match their component requirements, while maintaining cache locality and preventing common iteration pitfalls.</p>\n<h3 id=\"mental-model-assembly-line-stations\">Mental Model: Assembly Line Stations</h3>\n<p>Think of systems as <strong>specialized processing stations in a factory assembly line</strong>. Each station (system) has specific requirements for what types of products (entities) it can work on, and it performs a specific operation before passing the product to the next station.</p>\n<p>In a car manufacturing plant, the &quot;Paint System&quot; only works on entities that have both a <code>Body</code> component and a <code>Color</code> component. It doesn&#39;t need to know about engines or electronics — it focuses solely on its specialized task. Similarly, the &quot;Engine Installation System&quot; requires entities with a <code>Chassis</code> component and an <code>Engine</code> component, but it ignores paint-related data entirely.</p>\n<p>The assembly line supervisor (our <code>SystemManager</code>) ensures that stations operate in the correct order — you can&#39;t install the engine before the chassis is ready, and you can&#39;t apply clear coat before the base paint. Each station processes many products during its time slice, working efficiently through batches of similar items rather than switching back and forth between different product types.</p>\n<p>This mental model captures three crucial aspects of our system design: <strong>specialization</strong> (each system has specific component requirements), <strong>batched processing</strong> (systems iterate through many matching entities per frame), and <strong>execution ordering</strong> (some systems must run before others to maintain logical consistency).</p>\n<h3 id=\"component-query-mechanism\">Component Query Mechanism</h3>\n<p>The heart of the system interface is the <strong>component query mechanism</strong> that allows systems to efficiently find and iterate over entities containing specific component combinations. This mechanism must bridge the gap between a system&#39;s logical requirements (&quot;I need all entities with Position and Velocity&quot;) and the physical storage layout of our component arrays.</p>\n<p><img src=\"/api/project/ecs-arch/architecture-doc/asset?path=diagrams%2Fcomponent-query-flow.svg\" alt=\"Component Query Execution Flow\"></p>\n<blockquote>\n<p><strong>Decision: Template-Based Query Interface</strong></p>\n<ul>\n<li><strong>Context</strong>: Systems need to specify required components at compile time for type safety and performance</li>\n<li><strong>Options Considered</strong>: Runtime string-based queries, template parameter packs, component bitmask matching</li>\n<li><strong>Decision</strong>: Template parameter pack queries with compile-time type resolution</li>\n<li><strong>Rationale</strong>: Provides zero-cost abstraction with full type safety, enables SIMD optimization opportunities, and prevents runtime type errors</li>\n<li><strong>Consequences</strong>: Slightly more complex syntax but eliminates entire classes of runtime errors and enables better compiler optimizations</li>\n</ul>\n</blockquote>\n<p>Our query interface uses C++ template parameter packs to specify required components at compile time. The <code>query&lt;Position, Velocity&gt;()</code> syntax generates a specialized query iterator that knows exactly which component types it needs to access, enabling the compiler to optimize the access patterns and eliminate virtual function calls during the tight inner loops of system execution.</p>\n<h4 id=\"query-execution-process\">Query Execution Process</h4>\n<p>The query execution follows a multi-stage process that balances flexibility with performance:</p>\n<ol>\n<li><strong>Query Registration</strong>: The system specifies its required component types through template parameters, creating a compile-time component type list</li>\n<li><strong>Entity Filtering</strong>: The query mechanism identifies all entities that possess ALL required component types by intersecting the sparse sets of each component type</li>\n<li><strong>Iterator Construction</strong>: A specialized iterator is constructed that can efficiently traverse the filtered entity set while providing direct access to each required component</li>\n<li><strong>Cache-Friendly Iteration</strong>: The iterator accesses components in memory-layout-friendly patterns to maximize cache locality during system execution</li>\n<li><strong>Component Access</strong>: Systems retrieve strongly-typed component references without runtime type checking or virtual function overhead</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Query Interface Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>query&lt;Components...&gt;()</code></td>\n<td>Template parameter pack of component types</td>\n<td><code>QueryIterator&lt;Components...&gt;</code></td>\n<td>Creates iterator over entities with all specified components</td>\n</tr>\n<tr>\n<td><code>QueryIterator::operator*()</code></td>\n<td>None</td>\n<td><code>std::tuple&lt;Components&amp;...&gt;</code></td>\n<td>Dereferences iterator to component references tuple</td>\n</tr>\n<tr>\n<td><code>QueryIterator::operator++()</code></td>\n<td>None</td>\n<td><code>QueryIterator&amp;</code></td>\n<td>Advances to next matching entity</td>\n</tr>\n<tr>\n<td><code>QueryIterator::entity()</code></td>\n<td>None</td>\n<td><code>Entity</code></td>\n<td>Returns current entity ID for additional operations</td>\n</tr>\n<tr>\n<td><code>QueryIterator::valid()</code></td>\n<td>None</td>\n<td><code>bool</code></td>\n<td>Checks if iterator points to valid entity</td>\n</tr>\n</tbody></table>\n<p>The query mechanism handles several subtle complexities behind its simple interface. When multiple component types are required, the system must find the intersection of entities that exist in ALL relevant sparse sets. Rather than performing expensive set intersection operations, our implementation uses the smallest component set as the iteration base and validates presence in other sets during traversal, trading some CPU cycles for dramatically better memory access patterns.</p>\n<h4 id=\"query-optimization-strategies\">Query Optimization Strategies</h4>\n<p>Our query implementation employs several optimization strategies to maximize performance during system execution:</p>\n<p><strong>Smallest Set First</strong>: When querying for multiple component types, the query engine automatically identifies the component type with the fewest entities and uses that as the primary iteration source. This minimizes the number of entities that need validation against other component sets.</p>\n<p><strong>Early Termination</strong>: During entity validation, the query checks for component presence in order of likelihood, terminating as soon as any required component is missing. This reduces unnecessary cache misses when entities don&#39;t match the complete query.</p>\n<p><strong>Prefetch Hinting</strong>: On supported platforms, the query iterator issues memory prefetch hints for upcoming entities in the iteration sequence, allowing the CPU to speculatively load component data while processing the current entity.</p>\n<p><strong>SIMD-Friendly Layout</strong>: Component access patterns are structured to enable vectorized operations when systems process multiple entities with identical operations, particularly beneficial for mathematical computations on <code>Position</code> and <code>Velocity</code> components.</p>\n<blockquote>\n<p>⚠️ <strong>Pitfall: Dynamic Query Construction</strong>\nAvoid building queries dynamically at runtime using string-based component names or runtime type information. This prevents compile-time optimization and forces expensive runtime type checking. Instead, use template specialization to create different system variants for different component combinations.</p>\n</blockquote>\n<h3 id=\"system-execution-and-ordering\">System Execution and Ordering</h3>\n<p>The system execution framework coordinates the orderly execution of all registered systems each frame, ensuring that dependencies are respected and that systems execute with consistent timing information. This framework must balance flexibility in system registration with predictable, high-performance execution.</p>\n<p><img src=\"/api/project/ecs-arch/architecture-doc/asset?path=diagrams%2Fsystem-execution-sequence.svg\" alt=\"System Update Sequence\"></p>\n<blockquote>\n<p><strong>Decision: Priority-Based System Ordering</strong></p>\n<ul>\n<li><strong>Context</strong>: Some systems must execute before others (physics before rendering), but strict dependency graphs are complex to maintain</li>\n<li><strong>Options Considered</strong>: Explicit dependency declarations, topological sorting, manual ordering, priority-based scheduling</li>\n<li><strong>Decision</strong>: Integer priority values with lower numbers executing first</li>\n<li><strong>Rationale</strong>: Simple to understand and debug, allows fine-grained control, avoids circular dependency complexity</li>\n<li><strong>Consequences</strong>: Requires careful priority assignment but provides predictable execution order without graph analysis overhead</li>\n</ul>\n</blockquote>\n<h4 id=\"system-base-interface\">System Base Interface</h4>\n<p>All game logic systems inherit from a common <code>System</code> base class that defines the execution interface and provides access to the ECS world state. This interface is designed to be minimal yet sufficient for all system types, from simple component updates to complex multi-entity interactions.</p>\n<table>\n<thead>\n<tr>\n<th>System Interface Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>update(World&amp;, float)</code></td>\n<td>World reference, delta time in seconds</td>\n<td><code>void</code></td>\n<td>Main system logic executed each frame</td>\n</tr>\n<tr>\n<td><code>getName()</code></td>\n<td>None</td>\n<td><code>const std::string&amp;</code></td>\n<td>Returns human-readable system name for debugging</td>\n</tr>\n<tr>\n<td><code>getPriority()</code></td>\n<td>None</td>\n<td><code>int</code></td>\n<td>Returns execution priority (lower executes first)</td>\n</tr>\n<tr>\n<td><code>isEnabled()</code></td>\n<td>None</td>\n<td><code>bool</code></td>\n<td>Checks if system should execute this frame</td>\n</tr>\n<tr>\n<td><code>setEnabled(bool)</code></td>\n<td>Enable/disable flag</td>\n<td><code>void</code></td>\n<td>Allows runtime system activation control</td>\n</tr>\n</tbody></table>\n<p>The <code>update</code> method receives a reference to the complete ECS <code>World</code>, allowing systems to perform queries, create/destroy entities, and modify components as needed. The delta time parameter enables frame-rate-independent updates for time-based calculations like physics integration and animation interpolation.</p>\n<h4 id=\"system-registration-and-lifecycle\">System Registration and Lifecycle</h4>\n<p>Systems are registered with the <code>SystemManager</code> during application initialization, specifying their execution priority and any configuration parameters. The registration process validates that priority values don&#39;t conflict and builds the execution order list that will be used during frame updates.</p>\n<ol>\n<li><strong>Registration Phase</strong>: Systems are registered with unique priorities during application startup, before the main game loop begins</li>\n<li><strong>Validation Phase</strong>: The system manager validates that all required dependencies can be satisfied and that no circular dependencies exist</li>\n<li><strong>Execution List Construction</strong>: Systems are sorted by priority value into a linear execution order that remains constant during runtime</li>\n<li><strong>Frame Execution</strong>: Each frame, systems execute in priority order with consistent delta time and world state access</li>\n<li><strong>Error Handling</strong>: If any system throws an exception, execution continues with subsequent systems to maintain frame consistency</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>SystemManager Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>registerSystem&lt;T&gt;(int, Args...)</code></td>\n<td>Priority value, constructor arguments</td>\n<td><code>T*</code></td>\n<td>Registers system instance with specified priority</td>\n</tr>\n<tr>\n<td><code>removeSystem&lt;T&gt;()</code></td>\n<td>Template type parameter</td>\n<td><code>bool</code></td>\n<td>Removes system of specified type from execution</td>\n</tr>\n<tr>\n<td><code>getSystem&lt;T&gt;()</code></td>\n<td>Template type parameter</td>\n<td><code>T*</code></td>\n<td>Retrieves registered system instance or nullptr</td>\n</tr>\n<tr>\n<td><code>updateAllSystems(World&amp;, float)</code></td>\n<td>World reference, delta time</td>\n<td><code>void</code></td>\n<td>Executes all enabled systems in priority order</td>\n</tr>\n<tr>\n<td><code>getSystemCount()</code></td>\n<td>None</td>\n<td><code>size_t</code></td>\n<td>Returns number of registered systems</td>\n</tr>\n</tbody></table>\n<p>The system manager maintains ownership of all registered system instances, handling their lifecycle from registration through destruction. This centralized ownership simplifies memory management and ensures that systems remain valid throughout the application lifecycle.</p>\n<h4 id=\"dependency-management\">Dependency Management</h4>\n<p>While our priority-based system uses simple integer values rather than explicit dependency graphs, careful priority assignment can encode complex dependency relationships. The key insight is that <strong>data flow dependencies</strong> (system A produces data that system B consumes) are more important than <strong>temporal dependencies</strong> (system A must complete before system B starts).</p>\n<p><strong>Common Priority Ranges</strong>:</p>\n<ul>\n<li><strong>Input Processing (0-99)</strong>: Keyboard, mouse, and controller input systems that populate input component state</li>\n<li><strong>Game Logic (100-299)</strong>: AI decision making, player control processing, game rule enforcement</li>\n<li><strong>Physics Simulation (300-399)</strong>: Collision detection, physics integration, movement resolution  </li>\n<li><strong>Animation and Interpolation (400-499)</strong>: Sprite animation, skeletal animation, interpolation between physics steps</li>\n<li><strong>Rendering Preparation (500-599)</strong>: Culling, sorting, render command generation</li>\n<li><strong>Audio Processing (600-699)</strong>: 3D audio positioning, effect processing, music management</li>\n<li><strong>Debug and UI (700-799)</strong>: Debug visualization, UI layout, developer tools</li>\n</ul>\n<p>This priority structure ensures that input is processed before game logic can react to it, physics runs before rendering attempts to display entity positions, and debug information is generated after all gameplay systems have completed their updates.</p>\n<blockquote>\n<p>⚠️ <strong>Pitfall: Priority Gaps</strong>\nDon&#39;t assign consecutive priority values like 1, 2, 3, 4. Instead use gaps like 100, 200, 300, 400 to allow inserting new systems later without renumbering existing systems. This is particularly important when multiple programmers are adding systems independently.</p>\n</blockquote>\n<h3 id=\"common-system-design-pitfalls\">Common System Design Pitfalls</h3>\n<p>System implementation involves several subtle correctness and performance pitfalls that can cause crashes, logic errors, or significant performance degradation. Understanding these pitfalls helps developers write robust systems and debug issues when they arise.</p>\n<h4 id=\"component-modification-during-iteration\">Component Modification During Iteration</h4>\n<p>The most dangerous pitfall in system design is <strong>modifying the component storage structure while iterating over entities</strong>. This can occur when systems add or remove components from entities during query iteration, potentially invalidating iterators or causing memory corruption.</p>\n<p>⚠️ <strong>Pitfall: Iterator Invalidation During Component Addition</strong></p>\n<p>When a system adds a component to an entity during iteration, the underlying sparse set may need to resize its dense array to accommodate the new component. This resize operation can invalidate all existing iterators pointing into that array, causing subsequent iterator operations to access invalid memory locations.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// DANGEROUS: Adding components during iteration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">auto</span><span style=\"color:#E1E4E8\"> [entity, pos] : world.query</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Position</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">shouldAddVelocity</span><span style=\"color:#E1E4E8\">(pos)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        world.addComponent</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Velocity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">(entity, {</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">});</span><span style=\"color:#6A737D\"> // May invalidate iterator!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Detection</strong>: Programs may crash with segmentation faults, produce incorrect results, or exhibit non-deterministic behavior that changes between debug and release builds.</p>\n<p><strong>Prevention</strong>: Collect entities requiring component changes in a separate vector during iteration, then apply changes after iteration completes:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// SAFE: Deferred component modifications  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> entitiesToModify;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">auto</span><span style=\"color:#E1E4E8\"> [entity, pos] : world.query</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Position</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">shouldAddVelocity</span><span style=\"color:#E1E4E8\">(pos)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        entitiesToModify.</span><span style=\"color:#B392F0\">push_back</span><span style=\"color:#E1E4E8\">(entity);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> (Entity entity : entitiesToModify) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    world.addComponent</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Velocity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">(entity, {</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">});</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>⚠️ <strong>Pitfall: Entity Destruction During Query Iteration</strong></p>\n<p>Destroying entities during iteration can cause similar iterator invalidation issues, but with the additional complexity that destroyed entities may be recycled immediately, leading to the <strong>ABA problem</strong> where an entity ID points to a completely different entity than expected.</p>\n<p><strong>Detection</strong>: Systems may process entities multiple times, skip entities entirely, or operate on entities with unexpected component combinations.</p>\n<p><strong>Prevention</strong>: Use the same deferred modification pattern, collecting entities for destruction in a separate container and processing them after iteration completes.</p>\n<h4 id=\"system-ordering-dependencies\">System Ordering Dependencies</h4>\n<p>Incorrect system execution order can cause subtle logic bugs that are difficult to reproduce and debug. These issues often manifest as frame-to-frame inconsistencies or state that appears &quot;one frame behind&quot; the expected behavior.</p>\n<p>⚠️ <strong>Pitfall: Physics After Rendering</strong></p>\n<p>If the rendering system executes before the physics system, entities will be drawn at their positions from the previous frame, creating a visible lag between input and visual response. This is particularly noticeable during rapid movement or rotation.</p>\n<p><strong>Detection</strong>: Visual stuttering, input lag, or &quot;ghosting&quot; effects where entities appear to trail behind their actual logical positions.</p>\n<p><strong>Prevention</strong>: Always ensure physics and movement systems execute before rendering systems by assigning appropriate priority values.</p>\n<p>⚠️ <strong>Pitfall: Input Processing After Game Logic</strong></p>\n<p>When input systems run after game logic systems, player actions won&#39;t take effect until the following frame, creating perceptible input delay and making the game feel unresponsive.</p>\n<p><strong>Detection</strong>: Button presses that seem to be ignored or delayed, particularly noticeable in fast-paced games requiring precise timing.</p>\n<p><strong>Prevention</strong>: Assign input processing systems the highest priority (lowest numeric values) to ensure they execute first each frame.</p>\n<h4 id=\"thread-safety-concerns\">Thread Safety Concerns</h4>\n<p>While our basic ECS implementation is single-threaded, many developers eventually want to parallelize system execution for performance. However, naive parallelization can introduce race conditions and data corruption.</p>\n<p>⚠️ <strong>Pitfall: Concurrent Component Access</strong></p>\n<p>Multiple systems accessing the same component types concurrently can create race conditions where one system reads partially-updated data from another system, leading to inconsistent entity state.</p>\n<p><strong>Detection</strong>: Non-deterministic behavior that changes between runs, crashes that only occur under high CPU load, or component values that occasionally contain impossible combinations.</p>\n<p><strong>Prevention</strong>: In single-threaded systems, this isn&#39;t a concern. For multi-threaded systems, either use read/write locks around component access or carefully design systems to operate on disjoint component sets.</p>\n<p>⚠️ <strong>Pitfall: Entity Creation/Destruction Race Conditions</strong></p>\n<p>Creating or destroying entities from multiple threads simultaneously can corrupt the entity manager&#39;s internal data structures, particularly the free list and generation counters.</p>\n<p><strong>Detection</strong>: Entity IDs that resolve to incorrect entities, crashes during entity operations, or memory corruption in entity storage arrays.</p>\n<p><strong>Prevention</strong>: Serialize all entity lifecycle operations through a single thread or use atomic operations with careful memory ordering for the entity manager&#39;s critical sections.</p>\n<h4 id=\"performance-anti-patterns\">Performance Anti-Patterns</h4>\n<p>Several system design patterns can severely impact performance by destroying cache locality or introducing unnecessary computational overhead.</p>\n<p>⚠️ <strong>Pitfall: Mixed Component Access Patterns</strong></p>\n<p>Systems that access components in unpredictable orders or frequently switch between different component types can cause excessive cache misses, dramatically reducing performance.</p>\n<p><strong>Detection</strong>: Poor performance despite low algorithmic complexity, high cache miss rates in profiling tools, or performance that scales poorly with entity count.</p>\n<p><strong>Prevention</strong>: Structure system logic to access components in consistent patterns, preferably processing all instances of one component type before moving to the next.</p>\n<p>⚠️ <strong>Pitfall: Expensive Operations in Inner Loops</strong></p>\n<p>Performing complex calculations, memory allocations, or system calls during entity iteration can make systems orders of magnitude slower than necessary.</p>\n<p><strong>Detection</strong>: Frame rate drops when entity counts increase, profiling showing hot spots in system update methods, or stuttering during gameplay.</p>\n<p><strong>Prevention</strong>: Move expensive operations outside the iteration loop when possible, pre-calculate values that don&#39;t change during iteration, and avoid memory allocation in performance-critical systems.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides concrete implementation patterns and starter code for building the system interface, focusing on the template-based query mechanism and priority-driven execution framework.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Query Interface</td>\n<td>Template parameter packs with std::tuple</td>\n<td>Custom iterator with SFINAE type checking</td>\n</tr>\n<tr>\n<td>System Storage</td>\n<td>std::vector with manual sorting</td>\n<td>Priority queue with stable ordering guarantees</td>\n</tr>\n<tr>\n<td>Dependency Management</td>\n<td>Integer priorities with manual assignment</td>\n<td>Dependency graph with topological sort</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Exception propagation with logging</td>\n<td>Error codes with graceful degradation</td>\n</tr>\n<tr>\n<td>Performance Profiling</td>\n<td>Manual timing with std::chrono</td>\n<td>Integrated profiler with per-system metrics</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">project</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">root</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  include</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ecs</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      System.h              ← Base system interface </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> query templates</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      SystemManager.h       ← System registration </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> execution coordination</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      Query.h               ← Query iterator implementation </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> type traits</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  src</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ecs</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      SystemManager.cpp     ← System execution loop </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> priority management</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  examples</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    systems</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      MovementSystem.h      ← Example system showing position</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">velocity integration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      RenderSystem.h        ← Example system showing component querying patterns</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      InputSystem.h         ← Example system showing entity creation</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">destruction</span></span></code></pre></div>\n\n<h4 id=\"system-base-interface-complete\">System Base Interface (Complete)</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// System.h - Base interface for all game logic systems</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Forward declarations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> World</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> System</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    explicit</span><span style=\"color:#B392F0\"> System</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> priority</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span><span style=\"color:#B392F0\">name_</span><span style=\"color:#E1E4E8\">(name), </span><span style=\"color:#B392F0\">priority_</span><span style=\"color:#E1E4E8\">(priority), </span><span style=\"color:#B392F0\">enabled_</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#B392F0\"> ~System</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> default</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Main system execution method - implement game logic here</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // System identification and configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> getName</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> name_; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#B392F0\"> getPriority</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> priority_; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> isEnabled</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> enabled_; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> setEnabled</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">bool</span><span style=\"color:#FFAB70\"> enabled</span><span style=\"color:#E1E4E8\">) { enabled_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> enabled; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">protected:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::string name_;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> priority_;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> enabled_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper macro for system priority ranges</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PRIORITY_INPUT</span><span style=\"color:#79B8FF\">      100</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PRIORITY_LOGIC</span><span style=\"color:#79B8FF\">      200</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PRIORITY_PHYSICS</span><span style=\"color:#79B8FF\">    300</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PRIORITY_ANIMATION</span><span style=\"color:#79B8FF\">  400</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PRIORITY_RENDERING</span><span style=\"color:#79B8FF\">  500</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PRIORITY_AUDIO</span><span style=\"color:#79B8FF\">      600</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PRIORITY_DEBUG</span><span style=\"color:#79B8FF\">      700</span></span></code></pre></div>\n\n<h4 id=\"query-interface-implementation-core-logic-skeleton\">Query Interface Implementation (Core Logic Skeleton)</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Query.h - Template-based component query system</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;tuple></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"Entity.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Forward declaration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> World</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Components</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> QueryIterator</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    World</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> world_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> entities_;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> current_index_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    QueryIterator</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#FFAB70\"> entities</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span><span style=\"color:#B392F0\">world_</span><span style=\"color:#E1E4E8\">(world), </span><span style=\"color:#B392F0\">entities_</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">move</span><span style=\"color:#E1E4E8\">(entities)), </span><span style=\"color:#B392F0\">current_index_</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Iterator interface implementation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">tuple</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Components</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">...> </span><span style=\"color:#F97583\">operator</span><span style=\"color:#B392F0\">*</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Get current entity from entities_[current_index_]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Retrieve each component reference using world_->getComponent&#x3C;T>()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Return tuple of component references</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use std::forward_as_tuple for reference tuple construction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    QueryIterator</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">++</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Increment current_index_</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Skip any entities that became invalid since query construction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Return reference to self for chaining</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">!=</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> QueryIterator</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Compare current_index_ with other.current_index_</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Handle end-of-iteration case when current_index_ >= entities_.size()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> current_index_ </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> other.current_index_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Entity</span><span style=\"color:#B392F0\"> entity</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Validate current_index_ is within bounds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Return entities_[current_index_]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> entities_[current_index_];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Range-based for loop support</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    QueryIterator</span><span style=\"color:#B392F0\"> begin</span><span style=\"color:#E1E4E8\">() { </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    QueryIterator</span><span style=\"color:#B392F0\"> end</span><span style=\"color:#E1E4E8\">() { </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        QueryIterator end_iter </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        end_iter.current_index_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> entities_.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> end_iter;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Query construction helper - implement in World class</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Components</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">QueryIterator</span><span style=\"color:#E1E4E8\">&#x3C;Components...> </span><span style=\"color:#B392F0\">query</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Get all entities that have the first component type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Filter entities to only those having ALL required component types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Collect filtered entities into vector</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return QueryIterator constructed with filtered entities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use world.hasComponent&#x3C;T>() for each required component type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"system-manager-implementation-complete\">System Manager Implementation (Complete)</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// SystemManager.cpp - System registration and execution coordination</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"SystemManager.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"System.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;algorithm></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;iostream></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdexcept></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SystemManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">System</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> systems_;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> systems_sorted_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SystemManager</span><span style=\"color:#E1E4E8\">() : </span><span style=\"color:#B392F0\">systems_sorted_</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> registerSystem</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> priority</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Create system instance with perfect forwarding</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> system </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">make_unique</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">>(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">forward</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">>(args)...);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        T</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> system_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> system.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check for priority conflicts (optional but recommended)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> auto&#x26;</span><span style=\"color:#E1E4E8\"> existing : systems_) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (existing-></span><span style=\"color:#B392F0\">getPriority</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> priority) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"Warning: Priority conflict between \"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> existing-></span><span style=\"color:#B392F0\">getName</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \" and \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> system-></span><span style=\"color:#B392F0\">getName</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::endl;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        systems_.</span><span style=\"color:#B392F0\">push_back</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">move</span><span style=\"color:#E1E4E8\">(system));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        systems_sorted_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Mark for re-sorting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> system_ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> updateAllSystems</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Sort systems by priority if needed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">systems_sorted_) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">sort</span><span style=\"color:#E1E4E8\">(systems_.</span><span style=\"color:#B392F0\">begin</span><span style=\"color:#E1E4E8\">(), systems_.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                [](</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">unique_ptr</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">System</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> a</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">unique_ptr</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">System</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> b</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    return</span><span style=\"color:#E1E4E8\"> a-></span><span style=\"color:#B392F0\">getPriority</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> b-></span><span style=\"color:#B392F0\">getPriority</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            systems_sorted_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Execute all enabled systems in priority order</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">auto&#x26;</span><span style=\"color:#E1E4E8\"> system : systems_) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (system-></span><span style=\"color:#B392F0\">isEnabled</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    system-></span><span style=\"color:#B392F0\">update</span><span style=\"color:#E1E4E8\">(world, deltaTime);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::exception</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> e) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    std</span><span style=\"color:#E1E4E8\">::cerr </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"System \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> system-></span><span style=\"color:#B392F0\">getName</span><span style=\"color:#E1E4E8\">() </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                             &#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \" threw exception: \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> e.</span><span style=\"color:#B392F0\">what</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::endl;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    // Continue with other systems to maintain frame consistency</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> getSystem</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">auto&#x26;</span><span style=\"color:#E1E4E8\"> system : systems_) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (T</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> typed_system </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> dynamic_cast&#x3C;</span><span style=\"color:#E1E4E8\">T</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\">(system.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">())) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> typed_system;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nullptr</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#B392F0\"> getSystemCount</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> systems_.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"example-system-implementations-complete\">Example System Implementations (Complete)</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// MovementSystem.h - Example system showing component queries and modification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"System.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"Components.h\"</span><span style=\"color:#6A737D\"> // Position, Velocity components</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MovementSystem</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#F97583\">public</span><span style=\"color:#B392F0\"> System</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    MovementSystem</span><span style=\"color:#E1E4E8\">() : </span><span style=\"color:#B392F0\">System</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Movement\"</span><span style=\"color:#E1E4E8\">, PRIORITY_PHYSICS) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">override</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Query all entities with both Position and Velocity components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">auto</span><span style=\"color:#E1E4E8\"> [entity, pos, vel] : world.query</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Position, Velocity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Integrate velocity into position using frame delta time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pos.x </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> vel.dx </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> deltaTime;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pos.y </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> vel.dy </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> deltaTime;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Apply simple friction to velocity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            vel.dx </span><span style=\"color:#F97583\">*=</span><span style=\"color:#79B8FF\"> 0.99</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            vel.dy </span><span style=\"color:#F97583\">*=</span><span style=\"color:#79B8FF\"> 0.99</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// InputSystem.h - Example system showing entity creation and component addition</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"System.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"Components.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InputSystem</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#F97583\">public</span><span style=\"color:#B392F0\"> System</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> entities_to_modify_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    InputSystem</span><span style=\"color:#E1E4E8\">() : </span><span style=\"color:#B392F0\">System</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Input\"</span><span style=\"color:#E1E4E8\">, PRIORITY_INPUT) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">override</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        entities_to_modify_.</span><span style=\"color:#B392F0\">clear</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check for input that should create new entities</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">isKeyPressed</span><span style=\"color:#E1E4E8\">(KEY_SPACE)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Entity bullet </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> world.</span><span style=\"color:#B392F0\">createEntity</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            world.addComponent</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Position</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">(bullet, {</span><span style=\"color:#79B8FF\">100.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">100.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">});</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            world.addComponent</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Velocity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">(bullet, {</span><span style=\"color:#79B8FF\">200.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">});</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Collect entities needing velocity changes (deferred modification pattern)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">auto</span><span style=\"color:#E1E4E8\"> [entity, pos] : world.query</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Position</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">isKeyPressed</span><span style=\"color:#E1E4E8\">(KEY_UP)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                entities_to_modify_.</span><span style=\"color:#B392F0\">push_back</span><span style=\"color:#E1E4E8\">(entity);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Apply velocity changes after iteration completes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (Entity entity : entities_to_modify_) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (world.hasComponent</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Velocity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">(entity)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                auto&#x26;</span><span style=\"color:#E1E4E8\"> vel </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> world.getComponent</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Velocity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">(entity);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                vel.dy </span><span style=\"color:#F97583\">-=</span><span style=\"color:#79B8FF\"> 100.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Move upward</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                world.addComponent</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Velocity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">(entity, {</span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">100.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">});</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the system interface, verify the following behavior:</p>\n<p><strong>Expected Functionality:</strong></p>\n<ol>\n<li><strong>System Registration</strong>: Register multiple systems with different priorities and verify they execute in priority order</li>\n<li><strong>Component Queries</strong>: Systems can query for entities with specific component combinations and iterate over results</li>\n<li><strong>Type Safety</strong>: Component access through queries provides compile-time type checking without runtime overhead</li>\n<li><strong>Execution Order</strong>: Lower priority numbers execute before higher priority numbers consistently</li>\n<li><strong>Error Handling</strong>: Exceptions in one system don&#39;t prevent other systems from executing</li>\n</ol>\n<p><strong>Testing Commands:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Compile and run basic system test</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">g++</span><span style=\"color:#79B8FF\"> -std=c++17</span><span style=\"color:#79B8FF\"> -I</span><span style=\"color:#9ECBFF\"> include</span><span style=\"color:#9ECBFF\"> src/test_systems.cpp</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> test_systems</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./test_systems</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Frame 1:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#   InputSystem (priority 100) executed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#   MovementSystem (priority 300) executed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#   RenderSystem (priority 500) executed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Frame 2:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#   InputSystem (priority 100) executed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#   MovementSystem (priority 300) executed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#   RenderSystem (priority 500) executed</span></span></code></pre></div>\n\n<p><strong>Manual Verification:</strong></p>\n<ol>\n<li>Create entities with Position and Velocity components</li>\n<li>Register MovementSystem and observe positions updating each frame</li>\n<li>Add systems with incorrect priority ordering and verify execution sequence</li>\n<li>Intentionally cause an exception in one system and verify others continue executing</li>\n</ol>\n<p><strong>Common Issues and Diagnosis:</strong></p>\n<ul>\n<li><strong>Systems execute in wrong order</strong>: Check priority values - lower numbers should execute first</li>\n<li><strong>Query returns no entities</strong>: Verify entities actually have ALL required component types using <code>hasComponent&lt;T&gt;()</code></li>\n<li><strong>Crashes during iteration</strong>: Check for component addition/removal during iteration - use deferred modification pattern</li>\n<li><strong>Components not updating</strong>: Ensure query returns references (<code>auto [entity, pos, vel]</code>) not copies (<code>auto [entity, pos, vel]</code> without reference types)</li>\n</ul>\n<h2 id=\"archetype-based-storage-advanced\">Archetype-Based Storage (Advanced)</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 4 (Archetypes) — implementing archetype-based storage for maximum cache efficiency through entity grouping by component combination</p>\n</blockquote>\n<p>The archetype-based storage system represents the pinnacle of ECS performance optimization. While the sparse set approach from Milestone 2 provides excellent constant-time entity-to-component mapping, it still scatters components of the same type across different memory locations when entities have different component combinations. Archetype-based storage solves this by grouping entities with identical component combinations together, enabling unprecedented cache locality and SIMD processing opportunities.</p>\n<h3 id=\"mental-model-filing-cabinet-organization\">Mental Model: Filing Cabinet Organization</h3>\n<p>Think of archetypes as a sophisticated filing cabinet system in a large corporate office. Instead of having one drawer per document type (like our sparse set approach), we organize documents by <strong>client profiles</strong>. Each client profile represents a specific combination of document types that commonly appear together.</p>\n<p>In our filing cabinet analogy:</p>\n<ul>\n<li><strong>Archetypes</strong> are filing cabinet drawers labeled with specific document combinations: &quot;Tax Returns + Financial Statements + Legal Contracts&quot; or &quot;Employment Records + Performance Reviews&quot;</li>\n<li><strong>Entities</strong> are individual client folders within each drawer</li>\n<li><strong>Components</strong> are the actual documents stored in each client folder</li>\n<li><strong>Chunks</strong> are the individual filing cabinet sections within each drawer, each holding a fixed number of client folders</li>\n</ul>\n<p>When we need to process all tax returns, we don&#39;t search through every drawer in the office. Instead, we go directly to drawers labeled with &quot;Tax Returns&quot; and process entire sections at once. This is exactly how archetype-based storage achieves superior cache performance — all entities with similar data layouts are stored together, and we can process them in large batches.</p>\n<p>The key insight is that most game entities fall into common patterns: &quot;Renderable Objects&quot; (Position + Sprite + Transform), &quot;Moving Entities&quot; (Position + Velocity + Physics), or &quot;Interactive Items&quot; (Position + Collider + Inventory). By grouping these patterns together, we can process hundreds of similar entities without a single cache miss.</p>\n<h3 id=\"archetype-identification-and-transitions\">Archetype Identification and Transitions</h3>\n<p>Archetype identification relies on <strong>component masks</strong> — bitsets that uniquely identify which component types an entity possesses. Each bit position corresponds to a specific <code>ComponentTypeID</code>, creating a compact representation of an entity&#39;s component combination.</p>\n<blockquote>\n<p><strong>Decision: Component Mask-Based Archetype Identification</strong></p>\n<ul>\n<li><strong>Context</strong>: Need efficient method to group entities with identical component combinations while supporting fast lookups and transitions</li>\n<li><strong>Options Considered</strong>: String-based component signatures, sorted component type arrays, bitset-based component masks</li>\n<li><strong>Decision</strong>: Use <code>ComponentMask</code> bitset of <code>MAX_COMPONENTS</code> size for archetype identification</li>\n<li><strong>Rationale</strong>: Bitset operations are extremely fast (single CPU instruction for comparisons), compact memory usage (typically 64-256 bits), and enable efficient set operations for archetype transitions</li>\n<li><strong>Consequences</strong>: Limits maximum component types but enables sub-nanosecond archetype lookups and transitions</li>\n</ul>\n</blockquote>\n<p>The archetype identification process follows a systematic approach:</p>\n<ol>\n<li><strong>Component Mask Generation</strong>: When components are added or removed from an entity, we update its component mask by setting or clearing the corresponding bit for each <code>ComponentTypeID</code></li>\n<li><strong>Archetype Lookup</strong>: The ECS maintains a hash map from <code>ComponentMask</code> to <code>ArchetypeInfo</code>, enabling constant-time archetype discovery for any component combination</li>\n<li><strong>Archetype Creation</strong>: If no archetype exists for a given component mask, we dynamically create a new archetype with appropriate storage layout and chunk structure</li>\n<li><strong>Entity Assignment</strong>: Entities are assigned to their matching archetype based on their current component mask, ensuring all entities in an archetype have identical component combinations</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Archetype Operation</th>\n<th>Input</th>\n<th>Output</th>\n<th>Time Complexity</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>identifyArchetype</code></td>\n<td><code>ComponentMask</code></td>\n<td><code>ArchetypeInfo*</code></td>\n<td>O(1)</td>\n<td>Finds existing archetype or creates new one</td>\n</tr>\n<tr>\n<td><code>calculateMask&lt;Components...&gt;</code></td>\n<td>Template parameter pack</td>\n<td><code>ComponentMask</code></td>\n<td>O(k)</td>\n<td>Generates mask for given component types</td>\n</tr>\n<tr>\n<td><code>transitionEntity</code></td>\n<td><code>Entity</code>, <code>ArchetypeInfo*</code></td>\n<td><code>void</code></td>\n<td>O(k)</td>\n<td>Moves entity between archetypes</td>\n</tr>\n<tr>\n<td><code>findMatchingArchetypes</code></td>\n<td><code>ComponentMask</code></td>\n<td><code>vector&lt;ArchetypeInfo*&gt;</code></td>\n<td>O(n)</td>\n<td>Finds all archetypes containing required components</td>\n</tr>\n</tbody></table>\n<p><strong>Archetype transitions</strong> occur whenever an entity&#39;s component combination changes through <code>addComponent</code> or <code>removeComponent</code> operations. This process is more complex than simple sparse set modifications because the entity must physically move between different archetype storage areas.</p>\n<p>The archetype transition algorithm proceeds as follows:</p>\n<ol>\n<li><strong>Current Archetype Identification</strong>: Determine the entity&#39;s current archetype from its existing component mask</li>\n<li><strong>New Component Mask Calculation</strong>: Update the component mask based on the added or removed component type</li>\n<li><strong>Target Archetype Resolution</strong>: Find or create the archetype corresponding to the new component mask</li>\n<li><strong>Component Data Migration</strong>: Copy all existing component data from the current archetype chunk to the target archetype chunk</li>\n<li><strong>New Component Initialization</strong>: For <code>addComponent</code> operations, initialize the new component data in the target archetype</li>\n<li><strong>Index Updates</strong>: Update all internal mapping structures to reflect the entity&#39;s new archetype location</li>\n<li><strong>Source Cleanup</strong>: Remove the entity from its previous archetype chunk using swap-remove semantics</li>\n</ol>\n<blockquote>\n<p>The critical challenge in archetype transitions is maintaining data consistency during the migration process. Since component data moves between different memory locations, any existing pointers or references become invalid. Systems must be designed to avoid holding component references across frame boundaries.</p>\n</blockquote>\n<p><strong>Component masks enable sophisticated archetype matching</strong> for system queries. When a system requests entities with components <code>Position</code>, <code>Velocity</code>, and <code>Health</code>, we generate a query mask and use bitwise AND operations to find all archetypes that contain at least those components:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Query Mask:    00000111 (Position | Velocity | Health)\nArchetype A:   00001111 (Position | Velocity | Health | Sprite)    → Match!\nArchetype B:   00000110 (Velocity | Health)                        → No match\nArchetype C:   00010111 (Position | Velocity | Health | Physics)   → Match!</code></pre></div>\n\n<p>This bitwise matching approach enables systems to process multiple archetype chunks in sequence, maintaining excellent cache locality within each chunk while covering all entities that satisfy the query requirements.</p>\n<h3 id=\"chunk-based-memory-layout\">Chunk-Based Memory Layout</h3>\n<p>Within each archetype, entities and their components are organized into <strong>chunks</strong> — fixed-size memory blocks that store multiple entities with structure-of-arrays layout. This chunked approach provides several critical advantages over monolithic archetype storage.</p>\n<blockquote>\n<p><strong>Decision: Chunk-Based Storage Within Archetypes</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to balance cache efficiency with memory allocation flexibility and iteration performance</li>\n<li><strong>Options Considered</strong>: Monolithic archetype arrays, fixed-size chunks, dynamic chunk sizing</li>\n<li><strong>Decision</strong>: Use fixed-size <code>ArchetypeChunk</code> blocks with configurable capacity (typically 16KB per chunk)</li>\n<li><strong>Rationale</strong>: Fixed chunks enable predictable memory usage, reduce allocation overhead, improve cache utilization, and support efficient parallel processing</li>\n<li><strong>Consequences</strong>: Slightly more complex memory management but dramatically better performance characteristics and scalability</li>\n</ul>\n</blockquote>\n<p>Each <code>ArchetypeChunk</code> contains multiple parallel arrays — one for each component type in the archetype. The chunk layout follows strict structure-of-arrays principles to maximize cache efficiency during iteration:</p>\n<table>\n<thead>\n<tr>\n<th>Chunk Section</th>\n<th>Content</th>\n<th>Memory Layout</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Entity Array</td>\n<td><code>Entity</code> structs</td>\n<td>Contiguous entity IDs with generations</td>\n<td>Fast entity iteration and validation</td>\n</tr>\n<tr>\n<td>Component Arrays</td>\n<td>Type-specific component data</td>\n<td>Separate contiguous array per component type</td>\n<td>Cache-friendly component processing</td>\n</tr>\n<tr>\n<td>Metadata</td>\n<td>Chunk header information</td>\n<td>Entity count, capacity, archetype pointer</td>\n<td>Chunk management and validation</td>\n</tr>\n<tr>\n<td>Padding</td>\n<td>Memory alignment space</td>\n<td>Unused bytes for cache line alignment</td>\n<td>Optimal CPU cache utilization</td>\n</tr>\n</tbody></table>\n<p>The chunk memory layout calculation requires careful attention to data alignment and cache line boundaries:</p>\n<ol>\n<li><strong>Entity Array Placement</strong>: Entities are stored first, aligned to the beginning of the chunk for fastest access during iteration</li>\n<li><strong>Component Array Alignment</strong>: Each component array begins at a memory address aligned to the component&#39;s natural alignment requirements (typically 4 or 8 bytes)</li>\n<li><strong>Cache Line Considerations</strong>: Component arrays are positioned to minimize cache line splits — avoiding situations where a single component spans multiple cache lines</li>\n<li><strong>Chunk Size Optimization</strong>: Total chunk size is chosen to fit within L1 or L2 cache for optimal processing performance</li>\n</ol>\n<p>The <strong>entity stride calculation</strong> determines how many entities can fit within a single chunk based on the archetype&#39;s component combination:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Entity Stride = sizeof(Entity) + sum(sizeof(ComponentType)) for all components in archetype\nEntities Per Chunk = (CHUNK_SIZE - CHUNK_HEADER_SIZE) / Entity Stride</code></pre></div>\n\n<p>For example, an archetype containing <code>Position</code> (8 bytes), <code>Velocity</code> (8 bytes), and <code>Health</code> (8 bytes) components would have:</p>\n<ul>\n<li>Entity Stride: 8 (Entity) + 8 (Position) + 8 (Velocity) + 8 (Health) = 32 bytes</li>\n<li>Entities Per Chunk: (16384 - 64) / 32 = 509 entities per chunk</li>\n</ul>\n<blockquote>\n<p><strong>Cache Efficiency Insight</strong>: Processing 509 entities with identical memory layout in sequence typically results in near-zero cache misses after the initial cache line loads. This represents a 50-100x performance improvement over scattered component access patterns.</p>\n</blockquote>\n<p><strong>Chunk iteration patterns</strong> are designed to maximize CPU cache utilization and enable SIMD processing:</p>\n<table>\n<thead>\n<tr>\n<th>Iteration Pattern</th>\n<th>Use Case</th>\n<th>Cache Behavior</th>\n<th>SIMD Compatibility</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single Component</td>\n<td>Position updates</td>\n<td>Excellent — single array traversal</td>\n<td>Perfect — contiguous same-type data</td>\n</tr>\n<tr>\n<td>Multiple Components</td>\n<td>Physics calculations</td>\n<td>Good — parallel array traversal</td>\n<td>Good — requires gather/scatter operations</td>\n</tr>\n<tr>\n<td>Entity-Centric</td>\n<td>Complex logic requiring multiple components</td>\n<td>Fair — multiple cache line loads per entity</td>\n<td>Poor — requires component interleaving</td>\n</tr>\n</tbody></table>\n<p>The most efficient iteration pattern processes one component type at a time across all entities in the chunk, then moves to the next component type. This approach keeps the CPU cache full of relevant data and enables vectorized operations on modern processors.</p>\n<p><strong>Chunk allocation and deallocation</strong> follows a pooled memory management strategy to avoid frequent system memory allocations:</p>\n<ol>\n<li><strong>Chunk Pool Maintenance</strong>: Pre-allocate chunks from the system and maintain them in a free list for rapid allocation</li>\n<li><strong>Chunk Recycling</strong>: When archetypes shrink, return empty chunks to the pool rather than deallocating them immediately</li>\n<li><strong>Memory Pressure Handling</strong>: Monitor chunk pool size and deallocate excess chunks during low-usage periods</li>\n<li><strong>Fragmentation Prevention</strong>: Periodically compact partially-filled chunks to maintain optimal memory density</li>\n</ol>\n<h3 id=\"archetype-implementation-pitfalls\">Archetype Implementation Pitfalls</h3>\n<p>Implementing archetype-based storage introduces several subtle but critical pitfalls that can severely impact performance or correctness. Understanding these common mistakes helps avoid costly debugging sessions and performance regressions.</p>\n<p>⚠️ <strong>Pitfall: Archetype Explosion</strong></p>\n<p>Archetype explosion occurs when the system creates too many unique archetype combinations, fragmenting entities across numerous small archetypes instead of grouping them efficiently. This happens when games use many optional or temporary components, creating a combinatorial explosion of possible component masks.</p>\n<p><strong>Why it&#39;s problematic</strong>: Each archetype has memory overhead for chunk management and bookkeeping. With thousands of archetypes containing only a few entities each, memory usage explodes and cache efficiency disappears. Query iteration becomes expensive as systems must visit many small archetypes instead of processing large chunks efficiently.</p>\n<p><strong>Warning signs</strong>: More than 1000 unique archetypes in a typical game, average entities per archetype below 10, memory usage growing faster than entity count, query performance degrading despite constant entity counts.</p>\n<p><strong>Solutions</strong>: Design component hierarchies to minimize optional components, use tag components sparingly, implement archetype consolidation strategies, consider component pooling for temporary effects, monitor archetype statistics during development.</p>\n<p>⚠️ <strong>Pitfall: Excessive Transition Overhead</strong></p>\n<p>Frequent archetype transitions can overwhelm the performance benefits of cache-friendly storage. This occurs when systems repeatedly add and remove components, causing entities to bounce between archetypes every frame.</p>\n<p><strong>Why it&#39;s problematic</strong>: Each archetype transition requires copying all component data from one chunk to another, updating internal mappings, and potentially allocating new chunks. The cost of these operations can exceed the cache efficiency gains, especially for entities with many components.</p>\n<p><strong>Measurement approach</strong>: Profile the ratio of archetype transitions to system updates — ratios above 0.1 (one transition per ten system updates) often indicate problems. Monitor component addition/removal patterns to identify problematic systems.</p>\n<p><strong>Solutions</strong>: Batch component modifications to occur less frequently, use state machines instead of adding/removing components for temporary states, implement component flags for boolean state instead of optional components, defer non-critical component changes to reduce transition frequency.</p>\n<p>⚠️ <strong>Pitfall: Chunk Underutilization</strong></p>\n<p>Poor chunk utilization occurs when chunks remain mostly empty due to suboptimal entity distribution or frequent entity destruction without compaction. This wastes memory and reduces cache efficiency.</p>\n<p><strong>Symptoms</strong>: Low average entity count per chunk (below 50% capacity), memory usage growing without corresponding entity count increases, iteration performance lower than expected despite archetype organization.</p>\n<p><strong>Root causes</strong>: Entity destruction patterns that fragment chunks, archetype design that results in very large entity strides, chunk size configuration mismatched to typical entity counts.</p>\n<p><strong>Prevention strategies</strong>: Implement chunk compaction during low-usage periods, monitor chunk utilization metrics, configure chunk sizes based on profiling typical entity distributions, design archetypes to balance component combinations with utilization rates.</p>\n<p>⚠️ <strong>Pitfall: Iterator Invalidation During Transitions</strong></p>\n<p>Component references and iterators become invalid when entities transition between archetypes, but this invalidation is not immediately obvious since the entity ID remains valid.</p>\n<p><strong>Why it&#39;s dangerous</strong>: Systems holding component pointers or references across archetype transitions will access stale memory, potentially reading garbage data or causing segmentation faults. This is particularly problematic in multi-threaded systems where transitions occur concurrently with component access.</p>\n<p><strong>Detection techniques</strong>: Use debug builds with component reference tracking, implement component access validation, add assertions to detect stale pointer usage, profile for unexpected memory access patterns.</p>\n<p><strong>Safe patterns</strong>: Never hold component references across system boundaries, refresh component access on each frame, use entity IDs and component lookups instead of cached pointers, implement deferred modification patterns for component changes during iteration.</p>\n<table>\n<thead>\n<tr>\n<th>Pitfall Category</th>\n<th>Performance Impact</th>\n<th>Debugging Difficulty</th>\n<th>Prevention Effort</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Archetype Explosion</td>\n<td>Severe — memory and query performance</td>\n<td>Medium — visible in profiling</td>\n<td>High — requires careful component design</td>\n</tr>\n<tr>\n<td>Transition Overhead</td>\n<td>High — can negate cache benefits</td>\n<td>Easy — shows up in frame profilers</td>\n<td>Medium — requires batching strategies</td>\n</tr>\n<tr>\n<td>Chunk Underutilization</td>\n<td>Medium — memory waste and cache misses</td>\n<td>Easy — memory profiling reveals waste</td>\n<td>Low — mostly configuration tuning</td>\n</tr>\n<tr>\n<td>Iterator Invalidation</td>\n<td>Critical — memory safety issues</td>\n<td>Hard — intermittent crashes</td>\n<td>Medium — requires disciplined coding patterns</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>The key principle for avoiding archetype pitfalls is to measure and monitor archetype statistics continuously during development. Problems with archetype-based storage typically manifest as gradual performance degradation rather than immediate failures, making early detection crucial for maintaining system performance.</p>\n</blockquote>\n<p><strong>Common debugging techniques</strong> for archetype-related issues include:</p>\n<ol>\n<li><strong>Archetype Statistics Logging</strong>: Track archetype count, average entities per archetype, transition frequency, and chunk utilization rates</li>\n<li><strong>Component Access Validation</strong>: Implement debug-mode checks that verify component pointers remain valid between access attempts</li>\n<li><strong>Memory Layout Visualization</strong>: Tools that display archetype memory layouts and entity distribution patterns</li>\n<li><strong>Performance Regression Testing</strong>: Automated tests that detect performance degradation as archetype usage patterns change</li>\n<li><strong>Cache Miss Profiling</strong>: Hardware performance counters to measure actual cache efficiency gains from archetype organization</li>\n</ol>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>Archetype-based storage represents the most complex milestone in our ECS implementation, requiring sophisticated memory management and careful performance optimization. The following guidance provides a practical roadmap for implementing this advanced optimization.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Approach</th>\n<th>Advanced Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Memory Management</td>\n<td><code>std::vector</code> per component array</td>\n<td>Custom chunk allocator with memory pools</td>\n</tr>\n<tr>\n<td>Component Masks</td>\n<td><code>std::bitset&lt;64&gt;</code> for component identification</td>\n<td>Hand-optimized bit manipulation with SIMD</td>\n</tr>\n<tr>\n<td>Archetype Storage</td>\n<td>Hash map from mask to archetype</td>\n<td>Hierarchical archetype graph with fast queries</td>\n</tr>\n<tr>\n<td>Chunk Iteration</td>\n<td>Range-based for loops</td>\n<td>Template-based iterator with SIMD hints</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>src/\n  ecs/\n    archetype/\n      archetype_info.h         ← ArchetypeInfo and ComponentMask definitions\n      archetype_chunk.h        ← Chunk storage and iteration\n      archetype_storage.h      ← Main archetype storage manager\n      archetype_storage.cpp    ← Implementation\n      chunk_allocator.h        ← Memory pool for chunk allocation\n      chunk_allocator.cpp      ← Pool implementation\n    world.h                    ← Updated World class with archetype support\n    world.cpp                  ← Integration with existing ECS components\n  tests/\n    archetype_tests.cpp        ← Comprehensive archetype testing\n    performance_tests.cpp      ← Cache efficiency benchmarks</code></pre></div>\n\n<p><strong>Core Data Structure Definitions:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// archetype_info.h - Complete archetype metadata structure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;bitset></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;memory></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#E1E4E8\"> MAX_COMPONENTS </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 64</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#E1E4E8\"> CHUNK_SIZE </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 16384</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // 16KB chunks for L1 cache efficiency</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#B392F0\"> ComponentMask</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">bitset</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">MAX_COMPONENTS</span><span style=\"color:#E1E4E8\">>;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> ArchetypeInfo</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> archetypeID;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ComponentMask componentMask;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ComponentTypeID</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> componentTypes;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;size_t></span><span style=\"color:#E1E4E8\"> componentOffsets;</span><span style=\"color:#6A737D\">  // Offset of each component within chunk</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> entityStride;</span><span style=\"color:#6A737D\">                   // Total size per entity including all components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> entitiesPerChunk;</span><span style=\"color:#6A737D\">               // Maximum entities that fit in one chunk</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ArchetypeChunk</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> chunks;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Fast component lookup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#B392F0\"> getComponentOffset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ComponentTypeID</span><span style=\"color:#FFAB70\"> typeID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> hasComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ComponentTypeID</span><span style=\"color:#FFAB70\"> typeID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> ArchetypeChunk</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;uint8_t</span><span style=\"color:#E1E4E8\">[]</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> data;</span><span style=\"color:#6A737D\">  // Raw memory for all component arrays</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> entities;</span><span style=\"color:#6A737D\">     // Entity IDs in this chunk</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> entityCount;</span><span style=\"color:#6A737D\">             // Current number of entities</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> capacity;</span><span style=\"color:#6A737D\">                // Maximum entities this chunk can hold</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ArchetypeInfo</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> archetype;</span><span style=\"color:#6A737D\">         // Pointer to parent archetype</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Component array access</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> getComponentArray</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Entity management within chunk</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> addEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> removeEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> index</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Uses swap-remove</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> compactChunk</span><span style=\"color:#E1E4E8\">();</span><span style=\"color:#6A737D\">              // Remove gaps from entity removal</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Archetype Storage Manager Implementation Skeleton:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// archetype_storage.cpp - Core archetype management logic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ArchetypeStorage</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ComponentMask, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ArchetypeInfo</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> archetypes_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ChunkAllocator chunkAllocator_;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> nextArchetypeID_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Main archetype operations that learners need to implement</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Components</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ArchetypeInfo</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> getOrCreateArchetype</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Generate ComponentMask for the given component types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Check if archetype already exists in archetypes_ map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: If not found, create new ArchetypeInfo with calculateLayout()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Initialize chunk allocator for this archetype</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Add archetype to map and return pointer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use ComponentTypeRegistry to get ComponentTypeID for each type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> transitionEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">ArchetypeInfo</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> targetArchetype</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Find entity's current archetype and chunk location</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Allocate space in target archetype (may require new chunk)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Copy all existing component data to target location</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Update internal entity-to-location mappings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Remove entity from source chunk using swap-remove</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: Clean up empty chunks if necessary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Component data copying requires knowledge of component sizes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Components</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">ArchetypeInfo</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">findMatchingArchetypes</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Generate query mask from template parameter pack</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Iterate through all existing archetypes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Use bitwise AND to test if archetype contains all required components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Collect matching archetypes into result vector</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Sort by entity count for optimal iteration order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Performance hint: Cache query results for frequently used component combinations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> calculateArchetypeLayout</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ArchetypeInfo</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> archetype</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Sort component types by alignment requirements (largest first)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Calculate offset for each component array within chunk</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Account for padding between arrays for proper alignment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Calculate total entity stride and entities per chunk</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Validate that chunk can hold at least one entity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Memory layout hint: Align each component array to its natural alignment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ArchetypeChunk</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> allocateNewChunk</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ArchetypeInfo</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> archetype</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Get raw memory from chunk allocator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Create ArchetypeChunk with proper capacity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Initialize component arrays within the chunk memory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Add chunk to archetype's chunk list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Return pointer to new chunk for immediate use</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Memory safety: Ensure proper cleanup if allocation fails</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Chunk Memory Management Infrastructure:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// chunk_allocator.h - Memory pool for efficient chunk allocation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ChunkAllocator</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;uint8_t</span><span style=\"color:#E1E4E8\">[]</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> freeChunks_;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> chunkSize_;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> totalAllocated_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> maxPoolSize_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Prevent unbounded memory growth</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    explicit</span><span style=\"color:#B392F0\"> ChunkAllocator</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> chunkSize</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> CHUNK_SIZE) : </span><span style=\"color:#B392F0\">chunkSize_</span><span style=\"color:#E1E4E8\">(chunkSize) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">unique_ptr</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#E1E4E8\">[]> </span><span style=\"color:#B392F0\">allocateChunk</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">freeChunks_.</span><span style=\"color:#B392F0\">empty</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            auto</span><span style=\"color:#E1E4E8\"> chunk </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">move</span><span style=\"color:#E1E4E8\">(freeChunks_.</span><span style=\"color:#B392F0\">back</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            freeChunks_.</span><span style=\"color:#B392F0\">pop_back</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> chunk;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        ++</span><span style=\"color:#E1E4E8\">totalAllocated_;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">make_unique</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#E1E4E8\">[]>(chunkSize_);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> deallocateChunk</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">unique_ptr</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#E1E4E8\">[]> </span><span style=\"color:#FFAB70\">chunk</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (freeChunks_.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> maxPoolSize_) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            freeChunks_.</span><span style=\"color:#B392F0\">push_back</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">move</span><span style=\"color:#E1E4E8\">(chunk));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Otherwise let unique_ptr automatically deallocate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Statistics for debugging and monitoring</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#B392F0\"> getTotalAllocated</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> totalAllocated_; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#B392F0\"> getPooledChunks</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> freeChunks_.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Integration with Existing ECS World:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Updated World class to support archetype-based storage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> World</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EntityManager entityManager_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ArchetypeStorage archetypeStorage_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SystemManager systemManager_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Entity-to-archetype mapping for fast lookups</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">EntityID, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::pair</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ArchetypeInfo</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t>></span><span style=\"color:#E1E4E8\"> entityLocations_;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> addComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">T</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#FFAB70\"> component</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Check if entity currently has any components (determines source archetype)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Calculate new component mask including the added component</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Get or create target archetype for new component combination</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Transition entity to target archetype (may involve data copying)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Initialize new component data in target archetype chunk</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: Update entityLocations_ mapping with new location</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 7: Return reference to newly added component</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Integration note: This replaces the old ComponentStorage approach</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> removeComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Validate entity exists and has the specified component</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Calculate new component mask excluding the removed component</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Get or create target archetype for remaining components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Copy all remaining component data to target archetype</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Transition entity to target archetype</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: Update entityLocations_ mapping</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 7: Clean up empty archetype chunks if necessary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Cleanup note: Call component destructor before removing data</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Components</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    auto</span><span style=\"color:#B392F0\"> query</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Find all archetypes matching the component requirements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Create iterator that spans across multiple archetypes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Provide tuple-based access to component data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Handle empty archetypes gracefully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Optimize iteration order for cache efficiency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Performance note: Process largest archetypes first for better branch prediction</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> ArchetypeQueryIterator</span><span style=\"color:#E1E4E8\">&#x3C;Components...>(</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">, archetypeStorage_.findMatchingArchetypes</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Components...</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Advanced Query Iterator Implementation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// High-performance iterator spanning multiple archetypes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Components</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ArchetypeQueryIterator</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ArchetypeInfo</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\"> matchingArchetypes_;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> currentArchetypeIndex_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> currentChunkIndex_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> currentEntityIndex_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    World</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> world_;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ArchetypeQueryIterator</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">ArchetypeInfo</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">archetypes</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span><span style=\"color:#B392F0\">world_</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">world), </span><span style=\"color:#B392F0\">matchingArchetypes_</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">move</span><span style=\"color:#E1E4E8\">(archetypes)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Start at first valid entity</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        skipToValidEntity</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">tuple</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Components</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">...> </span><span style=\"color:#F97583\">operator</span><span style=\"color:#B392F0\">*</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Get current archetype chunk and entity index</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Calculate component array pointers within chunk</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Return tuple of references to component data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Ensure type safety with template parameter validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Performance hint: Use pointer arithmetic for fast component access</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ArchetypeQueryIterator</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">++</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Advance to next entity within current chunk</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: If chunk exhausted, move to next chunk in archetype</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: If archetype exhausted, move to next archetype</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Skip empty chunks and archetypes automatically</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Update internal position tracking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Iteration hint: Batch validation checks to avoid per-entity overhead</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Entity</span><span style=\"color:#B392F0\"> entity</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Return current entity ID from current archetype chunk</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Validation: Ensure iterator is in valid state before returning</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">!=</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> ArchetypeQueryIterator</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Compare iterator positions for range-based for loop support</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Note: Typically only compared against end() iterator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> skipToValidEntity</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Skip empty chunks and archetypes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Find next archetype with entities if current is exhausted</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Update position indices to point to valid entity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Handle case where no entities match the query</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Language-Specific Performance Hints:</strong></p>\n<ul>\n<li><strong>Memory Alignment</strong>: Use <code>alignas()</code> specifiers to ensure component arrays align to cache line boundaries (64 bytes on most processors)</li>\n<li><strong>SIMD Processing</strong>: Design component layouts to enable <code>std::execution::vectorized_policy</code> with standard algorithms</li>\n<li><strong>Branch Prediction</strong>: Process largest archetypes first to improve CPU branch predictor performance</li>\n<li><strong>Template Optimization</strong>: Use <code>if constexpr</code> to eliminate runtime branches in template code</li>\n<li><strong>Memory Prefetching</strong>: Add <code>__builtin_prefetch()</code> hints for predictable access patterns (GCC/Clang)</li>\n</ul>\n<p><strong>Milestone Checkpoint:</strong></p>\n<p>After implementing archetype-based storage, verify the following behavior:</p>\n<ol>\n<li><strong>Archetype Creation</strong>: Run <code>world.addComponent&lt;Position&gt;(entity1); world.addComponent&lt;Velocity&gt;(entity1);</code> — should create archetype with ComponentMask containing Position and Velocity bits</li>\n<li><strong>Cache Efficiency Test</strong>: Create 1000 entities with Position+Velocity, iterate through <code>query&lt;Position, Velocity&gt;()</code> — should complete in under 1ms with proper archetype organization</li>\n<li><strong>Transition Verification</strong>: Add Health component to existing Position+Velocity entity — should move entity to Position+Velocity+Health archetype and maintain all component data</li>\n<li><strong>Memory Usage</strong>: Monitor memory consumption — should remain stable even with frequent entity creation/destruction due to chunk pooling</li>\n<li><strong>Query Performance</strong>: Benchmark queries across multiple archetypes — iteration speed should scale linearly with entity count, not archetype count</li>\n</ol>\n<p><strong>Debugging Tips:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Memory usage exploding</td>\n<td>Archetype explosion</td>\n<td>Count unique archetypes, check for optional components</td>\n<td>Redesign components to reduce combinations</td>\n</tr>\n<tr>\n<td>Slow query performance</td>\n<td>Too many small archetypes</td>\n<td>Profile entities per archetype</td>\n<td>Consolidate similar component patterns</td>\n</tr>\n<tr>\n<td>Crashes during component access</td>\n<td>Stale pointers after transitions</td>\n<td>Add component reference validation</td>\n<td>Use entity IDs instead of component pointers</td>\n</tr>\n<tr>\n<td>Memory leaks</td>\n<td>Chunks not being freed</td>\n<td>Track chunk allocation/deallocation</td>\n<td>Implement proper chunk pooling</td>\n</tr>\n<tr>\n<td>Cache misses despite archetypes</td>\n<td>Poor chunk utilization</td>\n<td>Profile chunk fill rates</td>\n<td>Tune chunk size and compaction frequency</td>\n</tr>\n</tbody></table>\n<p><img src=\"/api/project/ecs-arch/architecture-doc/asset?path=diagrams%2Farchetype-organization.svg\" alt=\"Archetype Storage Layout\"></p>\n<p><img src=\"/api/project/ecs-arch/architecture-doc/asset?path=diagrams%2Farchetype-transitions.svg\" alt=\"Archetype Transition Process\"></p>\n<h2 id=\"interactions-and-data-flow\">Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestones 1-4 — understanding how entities, components, and systems interact during typical game operations including entity creation, component attachment, and system updates</p>\n</blockquote>\n<p>The true power of an ECS architecture emerges not from its individual components, but from how they work together during actual game execution. Understanding these interactions is crucial for implementing a cohesive system that maintains both performance and correctness throughout the entity lifecycle.</p>\n<p>Think of the ECS interactions like a bustling city ecosystem. Entities are citizens with unique ID cards, components are the various services and attributes each citizen possesses (home address, job, health status), and systems are the city departments that process citizens with specific combinations of services. Just as a citizen might visit the DMV (which only processes people with driver&#39;s licenses), then go to the hospital (which processes people with health records), our systems process entities based on their component combinations. The city&#39;s efficiency depends on smooth coordination between departments, proper citizen identification, and organized service delivery.</p>\n<p>This section explores three critical aspects of ECS interactions: how entities move through their lifecycle from creation to destruction, how systems execute each frame to process relevant entities, and how component queries efficiently locate entities matching specific criteria.</p>\n<h3 id=\"entity-lifecycle-flow\">Entity Lifecycle Flow</h3>\n<p>The entity lifecycle represents the complete journey of a game object from conception to cleanup, involving coordinated actions across the Entity Manager, Component Storage, and System Interface. Understanding this flow is essential because improper lifecycle management leads to memory leaks, stale references, and system inconsistencies.</p>\n<h4 id=\"entity-creation-sequence\">Entity Creation Sequence</h4>\n<p>Entity creation involves generating a unique identifier, initializing tracking structures, and preparing the entity for component attachment. The process must guarantee ID uniqueness while enabling efficient lookup and iteration.</p>\n<p>The creation sequence follows these steps:</p>\n<ol>\n<li><p><strong>ID Generation</strong>: The Entity Manager checks its free list for recycled IDs. If available, it pops an ID and increments its generation counter. Otherwise, it allocates a new ID from the next available index.</p>\n</li>\n<li><p><strong>Alive Status Registration</strong>: The new entity is marked as alive in the Entity Manager&#39;s tracking structures, typically a bitset or sparse array that enables constant-time status queries.</p>\n</li>\n<li><p><strong>Generation Validation Setup</strong>: The entity&#39;s generation counter is recorded in the Entity Manager&#39;s generation array at the entity&#39;s index position, enabling future validation of entity references.</p>\n</li>\n<li><p><strong>Iterator Registration</strong>: If the ECS supports entity iteration, the new entity is added to the alive entities collection, maintaining the ability to iterate over all living entities.</p>\n</li>\n<li><p><strong>Callback Notification</strong>: Any registered creation callbacks are invoked, allowing systems to respond to new entity creation for initialization or logging purposes.</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Step</th>\n<th>Component Responsible</th>\n<th>Data Structure Modified</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ID Generation</td>\n<td>EntityManager</td>\n<td>free_list_, next_id_</td>\n<td>Obtain unique identifier</td>\n</tr>\n<tr>\n<td>Alive Status</td>\n<td>EntityManager</td>\n<td>alive_entities_ bitset</td>\n<td>Enable status queries</td>\n</tr>\n<tr>\n<td>Generation Recording</td>\n<td>EntityManager</td>\n<td>generations_ array</td>\n<td>Prevent stale references</td>\n</tr>\n<tr>\n<td>Iterator Support</td>\n<td>EntityManager</td>\n<td>entity_list_ vector</td>\n<td>Support entity iteration</td>\n</tr>\n<tr>\n<td>Callback Execution</td>\n<td>EntityManager</td>\n<td>creation_callbacks_</td>\n<td>Notify interested systems</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight</strong>: Entity creation is intentionally lightweight, involving no component allocation. This separation of concerns allows entities to exist as pure identifiers before acquiring behavior through components.</p>\n</blockquote>\n<h4 id=\"component-attachment-process\">Component Attachment Process</h4>\n<p>Component attachment transforms an empty entity into a functional game object by associating data with the entity ID. This process must maintain type safety while updating any archetype-based storage systems.</p>\n<p>The attachment process involves:</p>\n<ol>\n<li><p><strong>Type Registration Verification</strong>: The component type must be registered with the ComponentTypeRegistry, ensuring metadata like size and destructor information is available.</p>\n</li>\n<li><p><strong>Storage Location</strong>: The appropriate ComponentStorage instance is located based on the component&#39;s type ID, creating the storage if this is the first component of this type.</p>\n</li>\n<li><p><strong>Component Construction</strong>: The component is constructed in-place within the storage system, typically using move semantics for efficiency.</p>\n</li>\n<li><p><strong>Entity Mapping Update</strong>: The sparse set mapping from entity ID to component index is updated, enabling constant-time component access.</p>\n</li>\n<li><p><strong>Archetype Transition</strong>: If using archetype-based storage, the entity transitions to a new archetype that includes this component type, potentially moving existing components.</p>\n</li>\n<li><p><strong>Query Invalidation</strong>: Any active query iterators are marked as potentially invalid, since the entity&#39;s component combination has changed.</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Before State</th>\n<th>After State</th>\n<th>Data Structure Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Type Check</td>\n<td>Component unregistered</td>\n<td>Type metadata available</td>\n<td>ComponentTypeRegistry</td>\n</tr>\n<tr>\n<td>Storage Access</td>\n<td>No T storage exists</td>\n<td>ComponentStorage<T> ready</td>\n<td>storage_map_</td>\n</tr>\n<tr>\n<td>Construction</td>\n<td>Component data in parameters</td>\n<td>Component in dense array</td>\n<td>SparseSet<T></td>\n</tr>\n<tr>\n<td>Mapping</td>\n<td>Entity has no T component</td>\n<td>Entity → component index</td>\n<td>sparse_ and dense_ arrays</td>\n</tr>\n<tr>\n<td>Archetype</td>\n<td>Entity in archetype A</td>\n<td>Entity in archetype B</td>\n<td>ArchetypeStorage transitions</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Critical Consideration</strong>: Component attachment can be expensive in archetype-based systems due to the need to move all existing components to a new archetype. This cost is amortized over the performance benefits of cache-friendly iteration.</p>\n</blockquote>\n<h4 id=\"component-removal-and-cleanup\">Component Removal and Cleanup</h4>\n<p>Component removal requires careful coordination to maintain data structure integrity while avoiding iterator invalidation and memory leaks. The process must handle both explicit removal and destruction-time cleanup.</p>\n<p>The removal sequence proceeds as follows:</p>\n<ol>\n<li><p><strong>Existence Verification</strong>: The system verifies the entity actually has the component to avoid spurious removal attempts that could corrupt data structures.</p>\n</li>\n<li><p><strong>Component Destruction</strong>: The component&#39;s destructor is called to clean up any resources it holds, such as dynamically allocated memory or external handles.</p>\n</li>\n<li><p><strong>Swap-Remove Operation</strong>: The component is removed from the dense array using swap-remove semantics, moving the last component to fill the gap and updating indices accordingly.</p>\n</li>\n<li><p><strong>Mapping Cleanup</strong>: The sparse set mappings are updated to reflect the new dense array layout, ensuring the moved component maintains correct entity-to-index mapping.</p>\n</li>\n<li><p><strong>Archetype Transition</strong>: The entity moves to an archetype that lacks this component type, again potentially requiring movement of remaining components.</p>\n</li>\n<li><p><strong>Iterator Invalidation</strong>: Active iterators are invalidated since the dense array structure has changed through the swap-remove operation.</p>\n</li>\n</ol>\n<p>⚠️ <strong>Pitfall: Iterator Invalidation During Removal</strong>\nA common mistake is removing components while iterating over them. The swap-remove operation changes array indices, causing iterators to skip entities or access invalid memory. Always collect entities for modification first, then process them after iteration completes, or iterate backwards when removing components.</p>\n<h4 id=\"entity-destruction-workflow\">Entity Destruction Workflow</h4>\n<p>Entity destruction represents the complete cleanup of an entity and all its components, requiring coordination across all ECS subsystems to prevent resource leaks and stale references.</p>\n<p>The destruction workflow encompasses:</p>\n<ol>\n<li><p><strong>Component Enumeration</strong>: The system identifies all components attached to the entity, typically by checking component storage systems or consulting archetype metadata.</p>\n</li>\n<li><p><strong>Component-wise Cleanup</strong>: Each component is individually removed using the component removal process, ensuring proper destructor execution and storage cleanup.</p>\n</li>\n<li><p><strong>System Notification</strong>: Destruction callbacks are invoked to allow systems to perform cleanup specific to their domain, such as removing entities from spatial indices.</p>\n</li>\n<li><p><strong>Alive Status Revocation</strong>: The entity is marked as dead in the Entity Manager&#39;s tracking structures, preventing future component access attempts.</p>\n</li>\n<li><p><strong>Generation Increment</strong>: The entity&#39;s generation counter is incremented to invalidate any existing Entity references that might still exist in game code.</p>\n</li>\n<li><p><strong>ID Recycling</strong>: The entity ID is added to the free list for future reuse, but only after the generation increment to prevent the ABA problem.</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Phase</th>\n<th>Actions Taken</th>\n<th>Failure Recovery</th>\n<th>Performance Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Component Scan</td>\n<td>Identify attached components</td>\n<td>Skip invalid components</td>\n<td>O(number of component types)</td>\n</tr>\n<tr>\n<td>Component Cleanup</td>\n<td>Call destructors, update storage</td>\n<td>Log errors, continue cleanup</td>\n<td>O(number of attached components)</td>\n</tr>\n<tr>\n<td>Callback Execution</td>\n<td>Notify interested systems</td>\n<td>Isolate callback failures</td>\n<td>O(number of registered callbacks)</td>\n</tr>\n<tr>\n<td>Status Update</td>\n<td>Mark entity dead</td>\n<td>Critical - must succeed</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>ID Recycling</td>\n<td>Add to free list</td>\n<td>Memory leak if failed</td>\n<td>O(1)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Immediate vs. Deferred Destruction</strong></p>\n<ul>\n<li><strong>Context</strong>: Entity destruction can happen during system iteration, potentially causing iterator invalidation</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Immediate destruction during system execution</li>\n<li>Deferred destruction using a &quot;to-destroy&quot; queue</li>\n<li>Generational marking with periodic cleanup</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Deferred destruction with end-of-frame cleanup</li>\n<li><strong>Rationale</strong>: Prevents iterator invalidation, allows systems to complete their work, and batches destruction operations for better cache performance</li>\n<li><strong>Consequences</strong>: Requires destruction queue management and ensures destroyed entities remain accessible until cleanup, but eliminates a major source of ECS bugs</li>\n</ul>\n</blockquote>\n<h3 id=\"system-update-cycle\">System Update Cycle</h3>\n<p>The system update cycle represents the heartbeat of the ECS architecture, where all game logic executes in a coordinated fashion each frame. Understanding this cycle is crucial because it determines how systems interact with entities and components while maintaining performance and correctness.</p>\n<p>Think of the system update cycle like a hospital&#39;s daily rounds. Each department (system) has specialized responsibilities and visits patients (entities) that need their particular type of care. The neurology department only visits patients with brain-related conditions (entities with specific components), while the cardiology department focuses on heart patients. The hospital runs on a strict schedule - morning labs, afternoon consultations, evening treatments - ensuring departments don&#39;t interfere with each other and patients receive care in the proper order.</p>\n<h4 id=\"frame-execution-flow\">Frame Execution Flow</h4>\n<p>Each frame follows a predictable execution pattern that ensures systems process entities in the correct order while maintaining data consistency. The frame execution flow coordinates system ordering, component access, and modification patterns.</p>\n<p>The frame execution sequence:</p>\n<ol>\n<li><p><strong>Pre-Frame Setup</strong>: The World processes any deferred entity destruction from the previous frame, cleans up invalidated query iterators, and prepares systems for execution.</p>\n</li>\n<li><p><strong>System Priority Sorting</strong>: If new systems were registered or priorities changed, the SystemManager sorts systems by their priority values, ensuring deterministic execution order.</p>\n</li>\n<li><p><strong>Delta Time Calculation</strong>: The frame&#39;s delta time is computed from the previous frame&#39;s timestamp, providing systems with timing information for frame-rate independent updates.</p>\n</li>\n<li><p><strong>System Iteration</strong>: Each enabled system executes in priority order, receiving the World reference and delta time as parameters to its update method.</p>\n</li>\n<li><p><strong>Deferred Modification Processing</strong>: Any component additions or removals that were deferred during system execution are applied, potentially triggering archetype transitions.</p>\n</li>\n<li><p><strong>Post-Frame Cleanup</strong>: Destroyed entities are fully cleaned up, temporary query iterators are released, and performance statistics are updated.</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Phase</th>\n<th>Duration (typical)</th>\n<th>Primary Activity</th>\n<th>Failure Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Pre-Frame Setup</td>\n<td>&lt;1% frame time</td>\n<td>Cleanup and preparation</td>\n<td>Log errors, continue execution</td>\n</tr>\n<tr>\n<td>Priority Sorting</td>\n<td>&lt;1% frame time</td>\n<td>System ordering</td>\n<td>Use previous sort if failed</td>\n</tr>\n<tr>\n<td>Delta Time</td>\n<td>&lt;1% frame time</td>\n<td>Time calculation</td>\n<td>Use fixed timestep as fallback</td>\n</tr>\n<tr>\n<td>System Execution</td>\n<td>90-95% frame time</td>\n<td>Core game logic</td>\n<td>Isolate system failures</td>\n</tr>\n<tr>\n<td>Deferred Processing</td>\n<td>3-5% frame time</td>\n<td>Component modifications</td>\n<td>Roll back partial changes</td>\n</tr>\n<tr>\n<td>Post-Frame Cleanup</td>\n<td>1-2% frame time</td>\n<td>Resource cleanup</td>\n<td>Force cleanup on next frame</td>\n</tr>\n</tbody></table>\n<h4 id=\"system-execution-and-ordering\">System Execution and Ordering</h4>\n<p>System execution order critically affects game behavior, as systems often depend on the results of other systems&#39; work. The ordering mechanism must be predictable, configurable, and efficient to maintain frame rate targets.</p>\n<p>Systems execute according to several principles:</p>\n<p><strong>Priority-Based Ordering</strong>: Each system has an integer priority value, with lower numbers executing first. This provides explicit control over execution sequence while allowing insertion of new systems at appropriate points.</p>\n<p><strong>Dependency Declaration</strong>: Advanced ECS implementations allow systems to declare dependencies on other systems, automatically computing execution order based on the dependency graph.</p>\n<p><strong>Phase-Based Organization</strong>: Systems are grouped into logical phases like Input, Logic, Physics, Animation, and Rendering, with each phase having a priority range.</p>\n<p><strong>Conditional Execution</strong>: Systems can be disabled dynamically, allowing features to be toggled without removing systems from the execution list.</p>\n<table>\n<thead>\n<tr>\n<th>Priority Range</th>\n<th>Phase</th>\n<th>Example Systems</th>\n<th>Typical Duration</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0-99</td>\n<td>Pre-Update</td>\n<td>Cleanup, Statistics</td>\n<td>1-2% frame</td>\n</tr>\n<tr>\n<td>100-199</td>\n<td>Input</td>\n<td>Input Processing, Event Handling</td>\n<td>3-5% frame</td>\n</tr>\n<tr>\n<td>200-299</td>\n<td>Logic</td>\n<td>AI, Game Rules, State Machines</td>\n<td>20-30% frame</td>\n</tr>\n<tr>\n<td>300-399</td>\n<td>Physics</td>\n<td>Collision, Movement, Physics</td>\n<td>30-40% frame</td>\n</tr>\n<tr>\n<td>400-499</td>\n<td>Animation</td>\n<td>Skeletal Animation, Tweening</td>\n<td>10-20% frame</td>\n</tr>\n<tr>\n<td>500-599</td>\n<td>Rendering</td>\n<td>Culling, Rendering, UI</td>\n<td>20-30% frame</td>\n</tr>\n<tr>\n<td>600-699</td>\n<td>Post-Update</td>\n<td>Debug, Profiling</td>\n<td>1-2% frame</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight</strong>: Priority-based ordering is simpler than dependency graphs but requires careful priority assignment. Reserve ranges for each phase and leave gaps (e.g., use priorities 100, 200, 300) to allow insertion of new systems without renumbering existing ones.</p>\n</blockquote>\n<h4 id=\"component-access-patterns\">Component Access Patterns</h4>\n<p>Systems access components through well-defined patterns that balance performance with safety. Understanding these patterns is essential for writing efficient systems that don&#39;t cause data races or iterator invalidation.</p>\n<p><strong>Read-Only Access Pattern</strong>: Systems that only read component data can safely iterate over entities without concern for modification conflicts. This pattern enables parallel execution in multi-threaded ECS implementations.</p>\n<p><strong>Exclusive Write Pattern</strong>: Systems that modify components must ensure exclusive access to prevent data races. The deferred modification pattern collects changes during iteration and applies them afterward.</p>\n<p><strong>Mixed Access Pattern</strong>: Systems that read some components and write others require careful ordering to avoid reading stale data or creating inconsistent states.</p>\n<p><strong>Cross-System Communication</strong>: Systems communicate through shared components that act as message queues or through the World&#39;s event system rather than direct function calls.</p>\n<table>\n<thead>\n<tr>\n<th>Access Pattern</th>\n<th>Thread Safety</th>\n<th>Iterator Safety</th>\n<th>Performance Impact</th>\n<th>Use Cases</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Read-Only</td>\n<td>High</td>\n<td>High</td>\n<td>Minimal overhead</td>\n<td>Rendering, AI queries</td>\n</tr>\n<tr>\n<td>Exclusive Write</td>\n<td>Medium</td>\n<td>Low</td>\n<td>Deferred processing cost</td>\n<td>Physics, animation</td>\n</tr>\n<tr>\n<td>Mixed Access</td>\n<td>Low</td>\n<td>Low</td>\n<td>Significant overhead</td>\n<td>Complex game logic</td>\n</tr>\n<tr>\n<td>Event-Based</td>\n<td>High</td>\n<td>High</td>\n<td>Moderate overhead</td>\n<td>Cross-system communication</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Component Modification During Iteration</strong>\nNever add or remove components while iterating over entities with those components. This invalidates iterators and can cause crashes or memory corruption. Use the deferred modification pattern: collect entities that need changes during iteration, then apply changes after iteration completes.</p>\n<h3 id=\"query-execution-patterns\">Query Execution Patterns</h3>\n<p>Component queries form the bridge between systems and the entities they need to process. Efficient query execution is crucial for ECS performance, as poorly implemented queries can turn O(1) component access into expensive linear searches.</p>\n<p>Think of component queries like a library&#39;s catalog system. When you want books about &quot;medieval history written in English,&quot; you don&#39;t walk through every shelf checking each book. Instead, you use the catalog&#39;s cross-referenced index system - it quickly finds the intersection of &quot;medieval history&quot; topics with &quot;English language&quot; books. Similarly, component queries use efficient indexing structures (sparse sets, archetype masks) to quickly locate entities that have specific component combinations without examining every entity in the world.</p>\n<h4 id=\"query-specification-and-construction\">Query Specification and Construction</h4>\n<p>Query construction defines which entities a system wants to process by specifying required components, optional components, and exclusion criteria. The query system must compile these specifications into efficient execution plans.</p>\n<p>The query construction process involves:</p>\n<ol>\n<li><p><strong>Template Parameter Analysis</strong>: The query system analyzes the template parameters to determine required component types at compile time, enabling type-safe access and optimization.</p>\n</li>\n<li><p><strong>Component Type Registration</strong>: Each component type in the query is verified to be registered with the ECS, preventing runtime errors from unregistered types.</p>\n</li>\n<li><p><strong>Query Plan Generation</strong>: The system generates an execution plan that determines the optimal iteration strategy based on component storage types and entity counts.</p>\n</li>\n<li><p><strong>Iterator Preparation</strong>: Query iterators are prepared with references to the necessary component storage systems and entity lists.</p>\n</li>\n<li><p><strong>Validation Setup</strong>: Safety checks are configured to detect iterator invalidation during component modification.</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Query Type</th>\n<th>Template Signature</th>\n<th>Iteration Strategy</th>\n<th>Performance Characteristics</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single Component</td>\n<td><code>query&lt;Position&gt;()</code></td>\n<td>Dense array iteration</td>\n<td>O(n) where n = component count</td>\n</tr>\n<tr>\n<td>Multiple Components</td>\n<td><code>query&lt;Position, Velocity&gt;()</code></td>\n<td>Intersection of sparse sets</td>\n<td>O(min(n1, n2)) where n1, n2 are component counts</td>\n</tr>\n<tr>\n<td>With Exclusions</td>\n<td><code>query&lt;Position&gt;.exclude&lt;Dead&gt;()</code></td>\n<td>Filtered iteration</td>\n<td>O(n) with per-entity exclusion check</td>\n</tr>\n<tr>\n<td>Archetype-Based</td>\n<td>Automatic optimization</td>\n<td>Chunk iteration</td>\n<td>O(matching entities) with perfect cache locality</td>\n</tr>\n</tbody></table>\n<h4 id=\"entity-filtering-and-iteration\">Entity Filtering and Iteration</h4>\n<p>Entity filtering determines which entities match the query criteria and provides efficient iteration over the results. The filtering process must balance generality with performance, supporting complex queries while maintaining cache-friendly access patterns.</p>\n<p><strong>Sparse Set Intersection</strong>: For queries involving multiple components, the system computes the intersection of sparse sets to find entities that have all required components. This process is optimized by iterating over the smallest sparse set and checking membership in the others.</p>\n<p><strong>Archetype-Based Filtering</strong>: In archetype systems, filtering becomes a matter of finding archetypes whose component masks include all required components and exclude forbidden ones. This reduces per-entity checks to per-archetype checks.</p>\n<p><strong>Exclusion Handling</strong>: Exclusion criteria (entities that must NOT have certain components) are handled through additional membership tests during iteration or archetype mask operations.</p>\n<p><strong>Cache-Friendly Ordering</strong>: The iteration order is optimized for cache locality, typically following the dense array order of the most restrictive component type.</p>\n<p>The filtering algorithm proceeds as follows:</p>\n<ol>\n<li><p><strong>Component Count Analysis</strong>: Determine the entity count for each required component type to identify the smallest set for intersection-based iteration.</p>\n</li>\n<li><p><strong>Iteration Strategy Selection</strong>: Choose between sparse set intersection, archetype iteration, or hybrid approaches based on query complexity and entity distribution.</p>\n</li>\n<li><p><strong>Primary Iterator Setup</strong>: Initialize the primary iterator over the component type with the fewest entities to minimize intersection operations.</p>\n</li>\n<li><p><strong>Secondary Component Validation</strong>: For each entity in the primary iteration, verify the presence of all other required components and absence of excluded components.</p>\n</li>\n<li><p><strong>Component Reference Assembly</strong>: Collect references to all requested components for the current entity, preparing them for system access.</p>\n</li>\n<li><p><strong>Iterator Advancement</strong>: Move to the next matching entity, handling sparse set gaps and archetype boundaries as necessary.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Intersection vs. Archetype Query Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Different query strategies have vastly different performance characteristics depending on entity distribution</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Always use sparse set intersection</li>\n<li>Always use archetype iteration when available</li>\n<li>Hybrid approach selecting strategy based on query characteristics</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Hybrid approach with runtime strategy selection</li>\n<li><strong>Rationale</strong>: Sparse set intersection excels for rare component combinations, while archetype iteration excels for common combinations. Automatic selection provides optimal performance across diverse scenarios.</li>\n<li><strong>Consequences</strong>: Requires more complex query compiler but delivers consistent performance regardless of component distribution patterns.</li>\n</ul>\n</blockquote>\n<h4 id=\"component-access-and-modification-safety\">Component Access and Modification Safety</h4>\n<p>Safe component access during query iteration requires careful attention to iterator validity and modification ordering. The access patterns must prevent data races while maintaining the performance benefits of direct component references.</p>\n<p><strong>Direct Reference Access</strong>: Query iterators provide direct references to component data, eliminating the need for additional lookups during system execution. These references remain valid only while the iterator is unchanged.</p>\n<p><strong>Modification Detection</strong>: The query system tracks modifications to component storage that could invalidate iterators, such as component addition/removal or swap-remove operations during component destruction.</p>\n<p><strong>Deferred Modification Pattern</strong>: Systems that need to modify component attachments collect the required changes during iteration and apply them afterward, preserving iterator validity throughout the query loop.</p>\n<p><strong>Type Safety Guarantees</strong>: Template-based query construction provides compile-time guarantees that requested component types match the actual component storage, preventing runtime type errors.</p>\n<table>\n<thead>\n<tr>\n<th>Safety Mechanism</th>\n<th>Protection Provided</th>\n<th>Performance Cost</th>\n<th>When to Use</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Iterator Validation</td>\n<td>Detects invalidated iterators</td>\n<td>Low</td>\n<td>Debug builds</td>\n</tr>\n<tr>\n<td>Const References</td>\n<td>Prevents accidental modification</td>\n<td>None</td>\n<td>Read-only systems</td>\n</tr>\n<tr>\n<td>Deferred Modification</td>\n<td>Prevents iterator invalidation</td>\n<td>Moderate</td>\n<td>Systems that add/remove components</td>\n</tr>\n<tr>\n<td>Component Locking</td>\n<td>Prevents concurrent access</td>\n<td>High</td>\n<td>Multi-threaded systems</td>\n</tr>\n<tr>\n<td>Copy-Based Access</td>\n<td>Eliminates reference invalidation</td>\n<td>High</td>\n<td>Systems with complex modification patterns</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Stale Component References</strong>\nComponent references obtained from query iterators become invalid if the underlying storage is modified. Never store component references across frame boundaries or after component addition/removal operations. Always re-query components if storage might have changed.</p>\n<p>The query execution patterns form the foundation for efficient system implementation, enabling high-performance entity processing while maintaining type safety and correctness guarantees. Understanding these patterns is essential for writing systems that scale with entity count and component complexity.</p>\n<p><img src=\"/api/project/ecs-arch/architecture-doc/asset?path=diagrams%2Fecs-overview.svg\" alt=\"ECS Architecture Overview\"></p>\n<p><img src=\"/api/project/ecs-arch/architecture-doc/asset?path=diagrams%2Fentity-lifecycle.svg\" alt=\"Entity Lifecycle State Machine\"></p>\n<p><img src=\"/api/project/ecs-arch/architecture-doc/asset?path=diagrams%2Fsystem-execution-sequence.svg\" alt=\"System Update Sequence\"></p>\n<p><img src=\"/api/project/ecs-arch/architecture-doc/asset?path=diagrams%2Fcomponent-query-flow.svg\" alt=\"Component Query Execution Flow\"></p>\n<p><img src=\"/api/project/ecs-arch/architecture-doc/asset?path=diagrams%2Farchetype-transitions.svg\" alt=\"Archetype Transition Process\"></p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The interactions between ECS components require careful coordination in code to maintain both performance and correctness. This section provides complete implementations of the interaction patterns and concrete examples of proper entity lifecycle management.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Approach</th>\n<th>Advanced Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Entity Creation</td>\n<td>Direct ID allocation with vector growth</td>\n<td>Free list with generation counters</td>\n</tr>\n<tr>\n<td>Component Queries</td>\n<td>Linear search through entities</td>\n<td>Sparse set intersection optimization</td>\n</tr>\n<tr>\n<td>System Execution</td>\n<td>Simple priority-ordered vector</td>\n<td>Dependency graph with topological sort</td>\n</tr>\n<tr>\n<td>Modification Safety</td>\n<td>Immediate modifications</td>\n<td>Deferred modification queues</td>\n</tr>\n<tr>\n<td>Iterator Management</td>\n<td>Raw pointer iteration</td>\n<td>RAII iterator with invalidation detection</td>\n</tr>\n<tr>\n<td>Memory Management</td>\n<td>Standard allocators</td>\n<td>Custom pool allocators for components</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">project</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">root</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  src</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ecs</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      core</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Entity.h                    ← Entity ID </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> basic types</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        EntityManager.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">.cpp        ← Entity lifecycle management</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ComponentStorage.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">.cpp     ← Component storage implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        World.h</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">.cpp               ← Main ECS coordinator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      systems</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        System.h                   ← System base </span><span style=\"color:#F97583\">class</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        SystemManager.h/.cpp       ← System execution coordination</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Query.h                    ← Query iterator implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      components/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        CommonComponents.h         ← Position, </span><span style=\"color:#B392F0\">Velocity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Health</span><span style=\"color:#E1E4E8\"> components</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ComponentRegistry.h/.cpp   ← Component type management</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      utils/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        SparseSet.h               ← Sparse set implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        TypeUtils.h               ← Template utilities for type handling</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    examples/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      BasicGameLoop.cpp           ← Complete example showing interactions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  tests/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EntityLifecycleTest.cpp       ← Entity creation/destruction tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SystemExecutionTest.cpp       ← System update cycle tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    QueryPerformanceTest.cpp      ← Query execution benchmarks</span></span></code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Complete Entity Lifecycle Manager</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> ENTITY_LIFECYCLE_MANAGER_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ENTITY_LIFECYCLE_MANAGER_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;queue></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;bitset></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;functional></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#B392F0\"> EntityID</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">using</span><span style=\"color:#B392F0\"> Generation</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#E1E4E8\"> EntityID INVALID_ENTITY_ID </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> UINT32_MAX;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#E1E4E8\"> Generation DEFAULT_GENERATION </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#E1E4E8\"> Generation PERMANENT_GENERATION </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> UINT32_MAX;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EntityID id;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Generation generation;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">==</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> id </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> other.id </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> generation </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> other.generation;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">!=</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Entity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#E1E4E8\"> other);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#E1E4E8\"> Entity INVALID_ENTITY{INVALID_ENTITY_ID, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EntityLifecycleManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    using</span><span style=\"color:#B392F0\"> DestroyCallback</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">function</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">)>;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    EntityLifecycleManager</span><span style=\"color:#E1E4E8\">() : </span><span style=\"color:#B392F0\">next_id_</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Complete entity creation with generation tracking</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Entity</span><span style=\"color:#B392F0\"> createEntity</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        EntityID id;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Generation gen;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">free_list_.</span><span style=\"color:#B392F0\">empty</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            id </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> free_list_.</span><span style=\"color:#B392F0\">front</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            free_list_.</span><span style=\"color:#B392F0\">pop</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            gen </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> ++</span><span style=\"color:#E1E4E8\">generations_[id];</span><span style=\"color:#6A737D\">  // Increment generation for recycled ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            id </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next_id_</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            generations_.</span><span style=\"color:#B392F0\">resize</span><span style=\"color:#E1E4E8\">(next_id_, DEFAULT_GENERATION);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            alive_entities_.</span><span style=\"color:#B392F0\">resize</span><span style=\"color:#E1E4E8\">(next_id_);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            gen </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> DEFAULT_GENERATION;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        alive_entities_[id] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        ++</span><span style=\"color:#E1E4E8\">alive_count_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Entity entity{id, gen};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Notify creation callbacks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> auto&#x26;</span><span style=\"color:#E1E4E8\"> callback : creation_callbacks_) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            callback</span><span style=\"color:#E1E4E8\">(entity);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> entity;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Safe entity destruction with callback notifications</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> destroyEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">isAlive</span><span style=\"color:#E1E4E8\">(entity)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        destruction_queue_.</span><span style=\"color:#B392F0\">push</span><span style=\"color:#E1E4E8\">(entity);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Process all queued destructions (call at end of frame)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> processDestroyQueue</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">destruction_queue_.</span><span style=\"color:#B392F0\">empty</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Entity entity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> destruction_queue_.</span><span style=\"color:#B392F0\">front</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            destruction_queue_.</span><span style=\"color:#B392F0\">pop</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">isAlive</span><span style=\"color:#E1E4E8\">(entity)) </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Already destroyed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Notify destruction callbacks first</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> auto&#x26;</span><span style=\"color:#E1E4E8\"> callback : destruction_callbacks_) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                callback</span><span style=\"color:#E1E4E8\">(entity);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Mark as dead and recycle ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            alive_entities_[entity.id] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            --</span><span style=\"color:#E1E4E8\">alive_count_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Add to free list for recycling (generation already incremented)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (generations_[entity.id] </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> PERMANENT_GENERATION) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                free_list_.</span><span style=\"color:#B392F0\">push</span><span style=\"color:#E1E4E8\">(entity.id);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Fast entity validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> isAlive</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> entity.id </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> generations_.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               generations_[entity.id] </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> entity.generation </span><span style=\"color:#F97583\">&#x26;&#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               alive_entities_[entity.id];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get all alive entities (for iteration)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">getAllEntities</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> entities;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        entities.</span><span style=\"color:#B392F0\">reserve</span><span style=\"color:#E1E4E8\">(alive_count_);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (EntityID id </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; id </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> generations_.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">id) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (alive_entities_[id]) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                entities.</span><span style=\"color:#B392F0\">push_back</span><span style=\"color:#E1E4E8\">({id, generations_[id]});</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> entities;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Callback registration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> registerCreationCallback</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> DestroyCallback</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> callback</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        creation_callbacks_.</span><span style=\"color:#B392F0\">push_back</span><span style=\"color:#E1E4E8\">(callback);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> registerDestroyCallback</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> DestroyCallback</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> callback</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        destruction_callbacks_.</span><span style=\"color:#B392F0\">push_back</span><span style=\"color:#E1E4E8\">(callback);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#B392F0\"> getAliveEntityCount</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> alive_count_; }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EntityID next_id_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Generation</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> generations_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;bool></span><span style=\"color:#E1E4E8\"> alive_entities_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::queue</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">EntityID</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> free_list_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::queue</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> destruction_queue_;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> alive_count_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">DestroyCallback</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> creation_callbacks_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">DestroyCallback</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> destruction_callbacks_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> // ENTITY_LIFECYCLE_MANAGER_H</span></span></code></pre></div>\n\n<p><strong>Complete System Execution Framework</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> SYSTEM_EXECUTION_FRAMEWORK_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> SYSTEM_EXECUTION_FRAMEWORK_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;memory></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;algorithm></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;chrono></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdexcept></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Forward declarations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> World</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// System execution priorities</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> PRIORITY_INPUT </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> PRIORITY_LOGIC </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 200</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> PRIORITY_PHYSICS </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 300</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> PRIORITY_ANIMATION </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 400</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> PRIORITY_RENDERING </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 500</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> PRIORITY_AUDIO </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 600</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">constexpr</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> PRIORITY_DEBUG </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 700</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> System</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    System</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> priority</span><span style=\"color:#E1E4E8\">) </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span><span style=\"color:#B392F0\">name_</span><span style=\"color:#E1E4E8\">(name), </span><span style=\"color:#B392F0\">priority_</span><span style=\"color:#E1E4E8\">(priority), </span><span style=\"color:#B392F0\">enabled_</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#B392F0\"> ~System</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> default</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Main system update method - implement in derived classes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    virtual</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // System metadata access</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> getName</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> name_; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#B392F0\"> getPriority</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> priority_; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> isEnabled</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> enabled_; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> setEnabled</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">bool</span><span style=\"color:#FFAB70\"> enabled</span><span style=\"color:#E1E4E8\">) { enabled_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> enabled; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">protected:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::string name_;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> priority_;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> enabled_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SystemManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Register a system with automatic priority-based ordering</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> registerSystem</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> priority</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> system </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">make_unique</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">>(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">forward</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">>(args)...);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        T</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> system_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> system.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        systems_.</span><span style=\"color:#B392F0\">emplace_back</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">move</span><span style=\"color:#E1E4E8\">(system));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        systems_sorted_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Mark for re-sorting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> system_ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Execute all enabled systems in priority order</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> updateAllSystems</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ensureSystemsAreSorted</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> auto&#x26;</span><span style=\"color:#E1E4E8\"> system : systems_) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (system-></span><span style=\"color:#B392F0\">isEnabled</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    system-></span><span style=\"color:#B392F0\">update</span><span style=\"color:#E1E4E8\">(world, deltaTime);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::exception</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> e) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    // Log error but continue with other systems</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    // In production, you might want more sophisticated error handling</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"System </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> failed: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                            system-></span><span style=\"color:#B392F0\">getName</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">c_str</span><span style=\"color:#E1E4E8\">(), e.</span><span style=\"color:#B392F0\">what</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find a specific system by type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> getSystem</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> auto&#x26;</span><span style=\"color:#E1E4E8\"> system : systems_) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (T</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> typed_system </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> dynamic_cast&#x3C;</span><span style=\"color:#E1E4E8\">T</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\">(system.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">())) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> typed_system;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nullptr</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#B392F0\"> getSystemCount</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> systems_.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Remove a system by type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> removeSystem</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> it </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">find_if</span><span style=\"color:#E1E4E8\">(systems_.</span><span style=\"color:#B392F0\">begin</span><span style=\"color:#E1E4E8\">(), systems_.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            [](</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">unique_ptr</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">System</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> system</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#F97583\"> dynamic_cast&#x3C;</span><span style=\"color:#E1E4E8\">T</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\">(system.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">()) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nullptr</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (it </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> systems_.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            systems_.</span><span style=\"color:#B392F0\">erase</span><span style=\"color:#E1E4E8\">(it);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> ensureSystemsAreSorted</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">systems_sorted_) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">sort</span><span style=\"color:#E1E4E8\">(systems_.</span><span style=\"color:#B392F0\">begin</span><span style=\"color:#E1E4E8\">(), systems_.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                [](</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">unique_ptr</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">System</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> a</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">unique_ptr</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">System</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> b</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    return</span><span style=\"color:#E1E4E8\"> a-></span><span style=\"color:#B392F0\">getPriority</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> b-></span><span style=\"color:#B392F0\">getPriority</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            systems_sorted_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">System</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> systems_;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> systems_sorted_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// High-precision timing utilities</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> FrameTimer</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    FrameTimer</span><span style=\"color:#E1E4E8\">() : </span><span style=\"color:#B392F0\">last_frame_</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">high_resolution_clock</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">()) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#B392F0\"> tick</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> current_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">high_resolution_clock</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> duration </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">duration_cast</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">microseconds</span><span style=\"color:#E1E4E8\">>(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current_time </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> last_frame_);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        last_frame_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current_time;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        float</span><span style=\"color:#E1E4E8\"> delta_seconds </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> duration.</span><span style=\"color:#B392F0\">count</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1000000.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Cap delta time to prevent spiral of death</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">min</span><span style=\"color:#E1E4E8\">(delta_seconds, </span><span style=\"color:#79B8FF\">0.1</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">high_resolution_clock</span><span style=\"color:#E1E4E8\">::time_point last_frame_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> // SYSTEM_EXECUTION_FRAMEWORK_H</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>Entity Lifecycle Integration</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// World.h - Main ECS coordinator with lifecycle management</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> World</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    World</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Initialize EntityLifecycleManager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Register component cleanup callback with entity manager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Initialize SystemManager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Setup frame timer for delta time calculation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Entity lifecycle operations</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Entity</span><span style=\"color:#B392F0\"> createEntity</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Call entity_manager_.createEntity()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Log entity creation for debugging (optional)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Return the new entity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> destroyEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Remove all components from entity before destruction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Call entity_manager_.destroyEntity(entity) to queue destruction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Mark any cached query iterators as potentially invalid</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Component operations with lifecycle integration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> addComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">T</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#FFAB70\"> component</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Validate entity is alive using entity_manager_.isAlive()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Get or create ComponentStorage&#x3C;T> instance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Insert component into storage and get reference</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Invalidate query iterators that might be affected</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Return reference to the stored component</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use storage_.insert(entity.id, std::forward&#x3C;T>(component))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> removeComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Validate entity is alive</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Find ComponentStorage&#x3C;T> instance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Remove component using storage_.remove(entity.id)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Invalidate affected query iterators</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Return true if component was removed, false if not found</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Query creation with proper iterator management</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Components</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    QueryIterator</span><span style=\"color:#E1E4E8\">&#x3C;Components...> </span><span style=\"color:#B392F0\">query</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Validate all component types are registered</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Find component storages for each type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Create iterator with intersection of entities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Register iterator for invalidation tracking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Return properly initialized iterator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use sparse set intersection for multiple components</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Frame execution with proper lifecycle management</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> update</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Calculate delta time using frame_timer_.tick()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Process any queued entity destructions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Execute all systems via system_manager_.updateAllSystems()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Apply any deferred component modifications</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Clean up invalidated query iterators</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Always process destructions before system updates</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EntityLifecycleManager entity_manager_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SystemManager system_manager_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FrameTimer frame_timer_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add component storage management</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add query iterator tracking for invalidation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add deferred modification queue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Query Iterator with Safety</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Query.h - Safe query iteration with lifecycle awareness</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Components</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> QueryIterator</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    QueryIterator</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#FFAB70\">entities</span><span style=\"color:#E1E4E8\">) </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span><span style=\"color:#B392F0\">world_</span><span style=\"color:#E1E4E8\">(world), </span><span style=\"color:#B392F0\">entities_</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">move</span><span style=\"color:#E1E4E8\">(entities)), </span><span style=\"color:#B392F0\">current_index_</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Store weak reference to world for validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Register this iterator for invalidation tracking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Validate all entities are alive at construction time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Initialize current_index_ to first valid entity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Iterator interface</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">tuple</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Components</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">...> </span><span style=\"color:#F97583\">operator</span><span style=\"color:#B392F0\">*</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Validate iterator is still valid (not invalidated)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Validate current entity is alive</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Get component references for current entity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Return tuple of component references</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Throw exception if entity died or components were removed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use world_->getComponent&#x3C;T>(current_entity()) for each type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    QueryIterator</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">++</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Increment current_index_</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Skip any dead entities (they might have died during iteration)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Validate we don't go past the end of entities vector</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Update internal state for next dereference</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Return *this for chaining</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">!=</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> QueryIterator</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Compare world pointers for same query source</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Compare current_index_ positions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Handle end() iterator comparison correctly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Return true if iterators point to different positions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Entity</span><span style=\"color:#B392F0\"> entity</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Validate current_index_ is within bounds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Return entities_[current_index_]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Handle end-of-iteration case appropriately</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Range-based for loop support</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    QueryIterator</span><span style=\"color:#B392F0\"> begin</span><span style=\"color:#E1E4E8\">() { </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    QueryIterator</span><span style=\"color:#B392F0\"> end</span><span style=\"color:#E1E4E8\">() { </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Create end iterator with current_index_ = entities_.size()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Ensure end iterator compares correctly with operator!=</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    World</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> world_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> entities_;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> current_index_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add invalidation detection mechanism</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add entity liveness checking during iteration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"language-specific-implementation-hints\">Language-Specific Implementation Hints</h4>\n<p><strong>C++ Template and Memory Management</strong>:</p>\n<ul>\n<li>Use <code>std::unordered_map&lt;std::type_index, std::unique_ptr&lt;IComponentStorage&gt;&gt;</code> for type-erased component storage management</li>\n<li>Implement <code>ComponentStorage&lt;T&gt;</code> as template specialization of <code>IComponentStorage</code> interface</li>\n<li>Use <code>std::forward&lt;T&gt;(component)</code> for perfect forwarding in <code>addComponent</code></li>\n<li>Consider <code>std::vector&lt;std::unique_ptr&lt;System&gt;&gt;</code> for system storage with automatic cleanup</li>\n<li>Use RAII pattern for query iterator lifecycle management</li>\n</ul>\n<p><strong>Performance Optimization Tips</strong>:</p>\n<ul>\n<li>Reserve space in entity vectors using <code>entities_.reserve(expected_count)</code></li>\n<li>Use <code>std::move</code> semantics when transferring component ownership</li>\n<li>Consider memory pools for frequent entity creation/destruction patterns</li>\n<li>Profile sparse set intersection performance vs. linear iteration for different entity counts</li>\n<li>Use <code>likely</code>/<code>unlikely</code> attributes for common/rare execution paths in C++20</li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the interaction patterns, verify correct behavior:</p>\n<p><strong>Entity Lifecycle Verification</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Compile and run entity lifecycle test</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">g++</span><span style=\"color:#79B8FF\"> -std=c++17</span><span style=\"color:#79B8FF\"> -O2</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> lifecycle_test</span><span style=\"color:#9ECBFF\"> EntityLifecycleTest.cpp</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./lifecycle_test</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Entity creation: 1000 entities created in &#x3C;10ms</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Entity destruction: 1000 entities destroyed, 0 alive remaining</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ID recycling: 1000 new entities reused old IDs with incremented generations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Memory usage: No memory leaks detected</span></span></code></pre></div>\n\n<p><strong>System Execution Verification</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run system execution test with multiple systems</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./system_test</span><span style=\"color:#79B8FF\"> --entities=10000</span><span style=\"color:#79B8FF\"> --systems=5</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Frame 1: Input(100) -> Logic(200) -> Physics(300) -> Rendering(500) [16.67ms]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Frame 2: Input(100) -> Logic(200) -> Physics(300) -> Rendering(500) [16.33ms]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Average system execution order: Correct priority-based ordering maintained</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># System isolation: No system failures affected other systems</span></span></code></pre></div>\n\n<p><strong>Query Performance Verification</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Benchmark query execution with different entity counts</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./query_benchmark</span><span style=\"color:#79B8FF\"> --max-entities=100000</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Single component query: 100k entities processed in &#x3C;5ms</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Two component intersection: 50k matching entities in &#x3C;8ms  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Three component intersection: 10k matching entities in &#x3C;12ms</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Query iteration overhead: &#x3C;10% of total processing time</span></span></code></pre></div>\n\n<p><strong>Signs of Problems</strong>:</p>\n<ul>\n<li><strong>Entity ID collisions</strong>: Check generation counter implementation</li>\n<li><strong>Iterator crashes</strong>: Verify query invalidation handling during component modification</li>\n<li><strong>System execution order violations</strong>: Check SystemManager priority sorting</li>\n<li><strong>Memory leaks</strong>: Ensure EntityLifecycleManager processes destruction queue</li>\n<li><strong>Performance degradation</strong>: Profile query intersection algorithms for optimization opportunities</li>\n</ul>\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestones 1-4 — robust error handling and edge case management for entity validation, component type safety, and system execution reliability</p>\n</blockquote>\n<p>In any complex system, robust error handling separates production-ready code from fragile prototypes. ECS architectures face unique challenges because they operate on large numbers of entities and components each frame, making error recovery critical for maintaining game stability. A single uncaught error in a physics system shouldn&#39;t crash the entire game — players expect smooth experiences even when individual components fail.</p>\n<p>Think of error handling in an ECS like quality control in a massive factory assembly line. Each station (system) processes thousands of items (entities) per minute. When defects occur — broken parts, missing components, or station malfunctions — the factory needs protocols to detect problems, isolate failures, and continue production without shutting down the entire operation.</p>\n<p>Our error handling strategy addresses three critical failure domains: <strong>entity validation</strong> (preventing access to destroyed entities), <strong>component type safety</strong> (preventing type mismatches during component operations), and <strong>system execution recovery</strong> (handling system failures gracefully). Each domain requires different detection mechanisms and recovery strategies.</p>\n<h3 id=\"entity-validation-strategies\">Entity Validation Strategies</h3>\n<p>Entity validation prevents the most common and dangerous class of ECS bugs: accessing destroyed entities through stale references. Without proper validation, stale entity access can corrupt memory, crash systems, or produce subtle gameplay bugs that are extremely difficult to debug.</p>\n<h4 id=\"mental-model-hotel-key-cards-with-expiration\">Mental Model: Hotel Key Cards with Expiration</h4>\n<p>Think of entity validation like a hotel key card system. Each guest (entity reference) receives a key card with both a room number (entity ID) and an expiration timestamp (generation counter). When checking in, the front desk verifies both the room number exists and the key card hasn&#39;t expired. If a previous guest&#39;s key card is used after checkout, the system rejects access even if the room number is valid — the generation counter prevents the &quot;wrong guest accessing the room&quot; problem.</p>\n<p>The generation counter mechanism provides our primary defense against stale entity access. Every time an entity ID is recycled, the generation increments, making old references invalid even if they contain the correct entity ID.</p>\n<blockquote>\n<p><strong>Decision: Multi-Layered Entity Validation</strong></p>\n<ul>\n<li><strong>Context</strong>: ECS systems make thousands of entity accesses per frame, requiring fast validation without sacrificing safety</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>No validation (fastest but unsafe)</li>\n<li>Generation-only validation (fast but incomplete)</li>\n<li>Multi-layered validation with graceful degradation</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Multi-layered validation combining generation checks, alive status verification, and optional debug assertions</li>\n<li><strong>Rationale</strong>: Provides configurable safety levels — release builds use fast generation checks while debug builds add comprehensive validation</li>\n<li><strong>Consequences</strong>: Slight performance overhead in exchange for robust error detection and easier debugging</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Validation Layer</th>\n<th>Performance Cost</th>\n<th>Detection Capability</th>\n<th>When Active</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Generation Check</td>\n<td>~1 CPU cycle</td>\n<td>Stale entity references</td>\n<td>Always</td>\n</tr>\n<tr>\n<td>Alive Status Verification</td>\n<td>~2-3 CPU cycles</td>\n<td>Recently destroyed entities</td>\n<td>Always</td>\n</tr>\n<tr>\n<td>Component Existence Check</td>\n<td>~5-10 CPU cycles</td>\n<td>Missing component access</td>\n<td>Debug builds</td>\n</tr>\n<tr>\n<td>Memory Bounds Check</td>\n<td>~10-20 CPU cycles</td>\n<td>Buffer overruns</td>\n<td>Debug builds</td>\n</tr>\n</tbody></table>\n<h4 id=\"entity-validation-state-machine\">Entity Validation State Machine</h4>\n<p>The entity validation process follows a clear state machine that determines whether an entity reference is valid for component access:</p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Validation Check</th>\n<th>Next State</th>\n<th>Action Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Reference Received</td>\n<td>Check generation counter</td>\n<td>Valid Generation / Invalid Generation</td>\n<td>Continue / Return error</td>\n</tr>\n<tr>\n<td>Valid Generation</td>\n<td>Check alive status in EntityManager</td>\n<td>Alive / Dead</td>\n<td>Continue / Return error</td>\n</tr>\n<tr>\n<td>Alive</td>\n<td>Verify component exists (debug only)</td>\n<td>Component Found / Missing</td>\n<td>Continue / Return error</td>\n</tr>\n<tr>\n<td>Component Found</td>\n<td>Verify memory bounds (debug only)</td>\n<td>Valid Access / Out of Bounds</td>\n<td>Return reference / Assertion failure</td>\n</tr>\n</tbody></table>\n<p>The validation algorithm follows these steps:</p>\n<ol>\n<li>Extract the entity ID and generation from the entity reference</li>\n<li>Bounds-check the entity ID against the EntityManager&#39;s capacity</li>\n<li>Compare the reference generation against the current generation for that ID slot</li>\n<li>If generations match, verify the entity is marked alive in the status array</li>\n<li>In debug builds, additionally verify the requested component type exists for this entity</li>\n<li>In debug builds, perform bounds checking on the component array access</li>\n<li>Return success with component reference or failure with specific error code</li>\n</ol>\n<h4 id=\"validation-error-recovery-strategies\">Validation Error Recovery Strategies</h4>\n<p>When entity validation fails, our recovery strategy depends on the validation layer and execution context. The goal is to provide meaningful diagnostics while maintaining system stability.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection Method</th>\n<th>Recovery Action</th>\n<th>Error Information</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Invalid Generation</td>\n<td>Generation counter mismatch</td>\n<td>Return null/error code</td>\n<td>Entity ID, expected vs actual generation</td>\n</tr>\n<tr>\n<td>Dead Entity Access</td>\n<td>Alive status check failure</td>\n<td>Return null/error code</td>\n<td>Entity ID, destruction frame number</td>\n</tr>\n<tr>\n<td>Missing Component</td>\n<td>Component existence check</td>\n<td>Return null/error code</td>\n<td>Entity ID, requested component type</td>\n</tr>\n<tr>\n<td>Memory Corruption</td>\n<td>Bounds checking failure</td>\n<td>Assertion/exception</td>\n<td>Entity ID, memory address, expected bounds</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>The critical insight here is that validation failures often indicate logic bugs rather than runtime conditions. A well-designed game should rarely attempt to access destroyed entities, so validation failures should be logged aggressively for debugging.</p>\n</blockquote>\n<p>For graceful error recovery, we provide both throwing and non-throwing variants of component access methods:</p>\n<table>\n<thead>\n<tr>\n<th>Method Variant</th>\n<th>Failure Behavior</th>\n<th>Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>getComponent&lt;T&gt;(entity)</code></td>\n<td>Throws exception</td>\n<td>When component must exist</td>\n</tr>\n<tr>\n<td><code>tryGetComponent&lt;T&gt;(entity)</code></td>\n<td>Returns nullptr</td>\n<td>When component might not exist</td>\n</tr>\n<tr>\n<td><code>hasComponent&lt;T&gt;(entity)</code></td>\n<td>Returns false</td>\n<td>For conditional access</td>\n</tr>\n</tbody></table>\n<h4 id=\"common-entity-validation-pitfalls\">Common Entity Validation Pitfalls</h4>\n<p>⚠️ <strong>Pitfall: Caching Entity References Across Frames</strong></p>\n<p>Many developers cache entity references in systems or components, assuming they remain valid indefinitely. This breaks when entities are destroyed and their IDs recycled.</p>\n<p>Example problematic pattern:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> FollowSystem</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Entity target_;</span><span style=\"color:#6A737D\"> // Cached across frames - DANGEROUS</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> dt</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto&#x26;</span><span style=\"color:#E1E4E8\"> position </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> world.getComponent</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Position</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">(target_);</span><span style=\"color:#6A737D\"> // May access wrong entity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Why it&#39;s wrong</strong>: The cached <code>target_</code> entity might be destroyed and its ID recycled for a completely different entity type.</p>\n<p><strong>How to fix</strong>: Always re-validate cached entity references or use entity lifecycle callbacks to clear invalid references.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Validation Failures</strong></p>\n<p>Systems sometimes ignore validation failures and continue processing, leading to subtle bugs or crashes later.</p>\n<p><strong>Why it&#39;s wrong</strong>: Validation failures indicate serious logic errors that compound over time.</p>\n<p><strong>How to fix</strong>: Always check validation results and handle failures explicitly, either by skipping the entity or logging the error for investigation.</p>\n<p>⚠️ <strong>Pitfall: Expensive Validation in Hot Loops</strong></p>\n<p>Debug builds sometimes add expensive validation that makes the game unplayable during development.</p>\n<p><strong>Why it&#39;s wrong</strong>: Developers disable debug builds to maintain playable framerates, losing valuable error detection.</p>\n<p><strong>How to fix</strong>: Use tiered validation with lightweight checks always enabled and expensive validation controllable via compile-time flags.</p>\n<h3 id=\"component-type-safety\">Component Type Safety</h3>\n<p>Component type safety prevents runtime errors from type mismatches during component operations. Without proper type safety, systems might attempt to access a <code>Position</code> component as a <code>Velocity</code> component, leading to memory corruption or incorrect behavior.</p>\n<h4 id=\"mental-model-library-card-catalog-with-isbn-numbers\">Mental Model: Library Card Catalog with ISBN Numbers</h4>\n<p>Think of component type safety like a library card catalog system where each book (component) has both a shelf location (entity ID) and an ISBN number (component type ID). When a patron requests &quot;the physics book from shelf 42,&quot; the librarian doesn&#39;t just grab whatever book is at that location — they verify the ISBN matches the expected book type. This prevents accidentally checking out a cookbook when you requested a physics textbook.</p>\n<p>Component type IDs serve as our &quot;ISBN system&quot; for runtime type verification. Each component type receives a unique identifier during registration, and all component operations verify the type ID before performing memory access.</p>\n<blockquote>\n<p><strong>Decision: Compile-Time + Runtime Type Safety</strong></p>\n<ul>\n<li><strong>Context</strong>: C++ templates provide compile-time type safety, but ECS systems need runtime type verification for dynamic operations</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Compile-time only (fast but limited flexibility)</li>\n<li>Runtime only (flexible but slower and less safe)</li>\n<li>Hybrid compile-time + runtime validation</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Hybrid approach using templates for compile-time safety and type IDs for runtime verification</li>\n<li><strong>Rationale</strong>: Templates catch most errors at compile-time with zero runtime cost, while type IDs enable dynamic operations like serialization and debugging</li>\n<li><strong>Consequences</strong>: Best of both worlds — fast execution with runtime flexibility, but increased implementation complexity</li>\n</ul>\n</blockquote>\n<h4 id=\"component-type-registration-system\">Component Type Registration System</h4>\n<p>The <code>ComponentTypeRegistry</code> maintains metadata for all registered component types, enabling runtime type verification and introspection:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>typeID</code></td>\n<td><code>ComponentTypeID</code></td>\n<td>Unique identifier for this component type</td>\n</tr>\n<tr>\n<td><code>name</code></td>\n<td><code>string</code></td>\n<td>Human-readable type name for debugging</td>\n</tr>\n<tr>\n<td><code>size</code></td>\n<td><code>size_t</code></td>\n<td>Memory size in bytes for allocation</td>\n</tr>\n<tr>\n<td><code>alignment</code></td>\n<td><code>size_t</code></td>\n<td>Memory alignment requirements</td>\n</tr>\n<tr>\n<td><code>destructor</code></td>\n<td><code>function pointer</code></td>\n<td>Cleanup function for component destruction</td>\n</tr>\n<tr>\n<td><code>moveConstructor</code></td>\n<td><code>function pointer</code></td>\n<td>Move semantics for component relocation</td>\n</tr>\n</tbody></table>\n<p>The type registration process follows these steps:</p>\n<ol>\n<li>Template specialization generates unique type information at compile-time</li>\n<li>First access to a component type triggers registration via <code>registerComponentType&lt;T&gt;()</code></li>\n<li>Registry assigns monotonically increasing type IDs starting from 1</li>\n<li>Type metadata is stored in a global registry accessible by component type ID</li>\n<li>Template functions use compile-time type information while runtime systems use type IDs</li>\n</ol>\n<h4 id=\"type-safe-component-access-patterns\">Type-Safe Component Access Patterns</h4>\n<p>Component access methods use template specialization to ensure compile-time type safety while adding runtime verification for additional protection:</p>\n<table>\n<thead>\n<tr>\n<th>Access Pattern</th>\n<th>Compile-Time Safety</th>\n<th>Runtime Verification</th>\n<th>Performance</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>getComponent&lt;Position&gt;(entity)</code></td>\n<td>Full template checking</td>\n<td>Type ID verification</td>\n<td>Fastest</td>\n</tr>\n<tr>\n<td><code>tryGetComponent&lt;Position&gt;(entity)</code></td>\n<td>Full template checking</td>\n<td>Type ID + null checking</td>\n<td>Fast</td>\n</tr>\n<tr>\n<td><code>getComponentByTypeID(entity, typeID)</code></td>\n<td>Type-erased access</td>\n<td>Full runtime verification</td>\n<td>Slower</td>\n</tr>\n<tr>\n<td><code>hasComponent&lt;Position&gt;(entity)</code></td>\n<td>Template specialization</td>\n<td>Type ID verification</td>\n<td>Fast</td>\n</tr>\n</tbody></table>\n<p>The component storage system maintains type safety through several mechanisms:</p>\n<ol>\n<li><strong>Template Specialization</strong>: Each <code>ComponentStorage&lt;T&gt;</code> instance is specialized for a specific component type</li>\n<li><strong>Type ID Verification</strong>: Runtime checks ensure component type IDs match expected types</li>\n<li><strong>Memory Layout Validation</strong>: Debug builds verify component sizes and alignments match registered metadata</li>\n<li><strong>Bounds Checking</strong>: Array access is bounds-checked against component storage capacity</li>\n</ol>\n<h4 id=\"type-mismatch-error-recovery\">Type Mismatch Error Recovery</h4>\n<p>When type mismatches occur, our recovery strategy focuses on providing clear diagnostic information while maintaining system stability:</p>\n<table>\n<thead>\n<tr>\n<th>Error Type</th>\n<th>Detection Point</th>\n<th>Recovery Action</th>\n<th>Diagnostic Information</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Wrong Component Type</td>\n<td>Template access with wrong type</td>\n<td>Compile error</td>\n<td>Expected vs actual type names</td>\n</tr>\n<tr>\n<td>Unregistered Type</td>\n<td>First component operation</td>\n<td>Runtime exception</td>\n<td>Component type name and registration hint</td>\n</tr>\n<tr>\n<td>Type ID Mismatch</td>\n<td>Runtime type verification</td>\n<td>Return error code</td>\n<td>Expected vs actual type IDs and names</td>\n</tr>\n<tr>\n<td>Size Mismatch</td>\n<td>Component storage allocation</td>\n<td>Runtime exception</td>\n<td>Expected vs actual sizes and alignment</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>The key insight for type safety is that most type errors should be caught at compile-time through template specialization. Runtime type checking serves as a safety net for dynamic operations and provides better error messages during debugging.</p>\n</blockquote>\n<h4 id=\"common-component-type-safety-pitfalls\">Common Component Type Safety Pitfalls</h4>\n<p>⚠️ <strong>Pitfall: Accessing Components Without Type Registration</strong></p>\n<p>Systems sometimes attempt to access component types before they&#39;re registered with the <code>ComponentTypeRegistry</code>.</p>\n<p><strong>Why it&#39;s wrong</strong>: Unregistered types have invalid type IDs, leading to failed lookups or memory corruption.</p>\n<p><strong>How to fix</strong>: Ensure all component types are registered during system initialization, preferably in a centralized location.</p>\n<p>⚠️ <strong>Pitfall: Type ID Collisions from Manual Assignment</strong></p>\n<p>Developers sometimes manually assign component type IDs instead of using automatic registration.</p>\n<p><strong>Why it&#39;s wrong</strong>: Manual assignment can create ID collisions, causing different component types to share the same identifier.</p>\n<p><strong>How to fix</strong>: Always use <code>registerComponentType&lt;T&gt;()</code> for automatic ID assignment and maintain a single source of truth for type registration.</p>\n<p>⚠️ <strong>Pitfall: Mixing Template and Type-Erased Access</strong></p>\n<p>Code sometimes mixes template-based component access with type-erased access without proper verification.</p>\n<p><strong>Why it&#39;s wrong</strong>: Type-erased access bypasses compile-time safety checks, making type mismatches possible.</p>\n<p><strong>How to fix</strong>: Use consistent access patterns within each system and add explicit type verification when mixing access methods.</p>\n<h3 id=\"system-execution-error-recovery\">System Execution Error Recovery</h3>\n<p>System execution errors occur when individual systems encounter runtime failures during their update cycles. Unlike entity validation or type safety errors, system execution errors often represent recoverable conditions that shouldn&#39;t crash the entire frame update.</p>\n<h4 id=\"mental-model-circuit-breakers-in-electrical-systems\">Mental Model: Circuit Breakers in Electrical Systems</h4>\n<p>Think of system execution error recovery like circuit breakers in a house&#39;s electrical system. When one appliance (system) has a problem and starts drawing too much current (encounters an error), the circuit breaker trips to protect the rest of the house (game engine) from damage. The faulty appliance stops working, but the lights in other rooms stay on. Once the problem is fixed, you can reset the breaker and restore normal operation.</p>\n<p>System error recovery uses a similar circuit breaker pattern — when a system encounters repeated failures, it gets temporarily disabled to prevent cascading errors, while other systems continue normal execution.</p>\n<blockquote>\n<p><strong>Decision: Isolated System Execution with Circuit Breaker Pattern</strong></p>\n<ul>\n<li><strong>Context</strong>: Game systems must run every frame, but individual system failures shouldn&#39;t crash the entire game</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Fail-fast approach (terminate on first system error)</li>\n<li>Silent failure recovery (ignore errors and continue)</li>\n<li>Circuit breaker pattern with error isolation</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Circuit breaker pattern with configurable error thresholds and recovery mechanisms</li>\n<li><strong>Rationale</strong>: Provides excellent stability by isolating failing systems while maintaining visibility into errors for debugging</li>\n<li><strong>Consequences</strong>: Games remain playable even with buggy systems, but adds complexity to system management and error reporting</li>\n</ul>\n</blockquote>\n<h4 id=\"system-error-classification\">System Error Classification</h4>\n<p>Different types of system errors require different recovery strategies. Our classification system helps determine the appropriate response:</p>\n<table>\n<thead>\n<tr>\n<th>Error Class</th>\n<th>Severity</th>\n<th>Recovery Strategy</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Transient</td>\n<td>Low</td>\n<td>Retry next frame</td>\n<td>Network timeout in multiplayer sync</td>\n</tr>\n<tr>\n<td>Logic Error</td>\n<td>Medium</td>\n<td>Skip current frame, continue next frame</td>\n<td>Division by zero in physics calculation</td>\n</tr>\n<tr>\n<td>Resource Exhaustion</td>\n<td>High</td>\n<td>Disable system temporarily</td>\n<td>Out of memory for particle effects</td>\n</tr>\n<tr>\n<td>Critical Error</td>\n<td>Critical</td>\n<td>Disable system permanently</td>\n<td>Corrupted system internal state</td>\n</tr>\n</tbody></table>\n<h4 id=\"circuit-breaker-state-machine\">Circuit Breaker State Machine</h4>\n<p>The circuit breaker mechanism follows a state machine that tracks system health and automatically manages system execution:</p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Error Event</th>\n<th>Next State</th>\n<th>Action Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Healthy</td>\n<td>No errors</td>\n<td>Healthy</td>\n<td>Normal execution</td>\n</tr>\n<tr>\n<td>Healthy</td>\n<td>Single error</td>\n<td>Monitoring</td>\n<td>Log error, continue execution</td>\n</tr>\n<tr>\n<td>Monitoring</td>\n<td>Error threshold exceeded</td>\n<td>Open</td>\n<td>Disable system, start recovery timer</td>\n</tr>\n<tr>\n<td>Open</td>\n<td>Recovery timeout</td>\n<td>Half-Open</td>\n<td>Re-enable system with limited execution</td>\n</tr>\n<tr>\n<td>Half-Open</td>\n<td>Successful execution</td>\n<td>Healthy</td>\n<td>Restore normal execution</td>\n</tr>\n<tr>\n<td>Half-Open</td>\n<td>Error occurs</td>\n<td>Open</td>\n<td>Disable system, extend recovery period</td>\n</tr>\n</tbody></table>\n<p>The system execution framework manages error recovery through these steps:</p>\n<ol>\n<li>Wrap each system&#39;s update call in exception handling</li>\n<li>Track error count and frequency for each system</li>\n<li>When error threshold is exceeded, transition system to disabled state</li>\n<li>Continue executing other systems normally</li>\n<li>After recovery timeout, attempt to re-enable the failed system</li>\n<li>Monitor re-enabled systems for continued failures</li>\n<li>Log all errors with context for debugging and telemetry</li>\n</ol>\n<h4 id=\"error-context-collection\">Error Context Collection</h4>\n<p>When system errors occur, comprehensive context collection enables effective debugging and recovery decisions:</p>\n<table>\n<thead>\n<tr>\n<th>Context Category</th>\n<th>Information Collected</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>System State</td>\n<td>System name, priority, enabled status</td>\n<td>Identify which system failed</td>\n</tr>\n<tr>\n<td>Execution Context</td>\n<td>Frame number, delta time, entity count</td>\n<td>Understand execution environment</td>\n</tr>\n<tr>\n<td>Error Details</td>\n<td>Exception type, message, stack trace</td>\n<td>Diagnose root cause</td>\n</tr>\n<tr>\n<td>Entity Context</td>\n<td>Current entity being processed, component state</td>\n<td>Isolate problematic entities</td>\n</tr>\n<tr>\n<td>Resource Usage</td>\n<td>Memory usage, CPU time, allocation count</td>\n<td>Detect resource-related failures</td>\n</tr>\n</tbody></table>\n<h4 id=\"system-dependency-management\">System Dependency Management</h4>\n<p>System errors become more complex when systems have dependencies on each other. Our dependency management ensures that dependent systems handle upstream failures gracefully:</p>\n<table>\n<thead>\n<tr>\n<th>Dependency Type</th>\n<th>Failure Response</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Required Dependency</td>\n<td>Disable dependent system</td>\n<td>Re-enable when dependency recovers</td>\n</tr>\n<tr>\n<td>Optional Dependency</td>\n<td>Continue with degraded functionality</td>\n<td>Log warning, use fallback behavior</td>\n</tr>\n<tr>\n<td>Circular Dependency</td>\n<td>Break dependency cycle</td>\n<td>Disable one system to prevent cascade</td>\n</tr>\n</tbody></table>\n<p>The dependency resolution algorithm works as follows:</p>\n<ol>\n<li>Build dependency graph during system registration</li>\n<li>When a system fails, identify all dependent systems</li>\n<li>For required dependencies, cascade disable to dependent systems</li>\n<li>For optional dependencies, notify dependent systems of upstream failure</li>\n<li>During recovery, re-enable systems in dependency order</li>\n<li>Detect and break circular dependencies to prevent deadlocks</li>\n</ol>\n<h4 id=\"common-system-execution-pitfalls\">Common System Execution Pitfalls</h4>\n<p>⚠️ <strong>Pitfall: Modifying Components During Iteration</strong></p>\n<p>Systems sometimes modify component collections (adding/removing components) while iterating over entities, causing iterator invalidation.</p>\n<p><strong>Why it&#39;s wrong</strong>: Iterator invalidation can cause crashes, infinite loops, or skipped entities.</p>\n<p><strong>How to fix</strong>: Use deferred modification patterns — collect changes during iteration and apply them after iteration completes.</p>\n<p>⚠️ <strong>Pitfall: Ignoring System Execution Order</strong></p>\n<p>Developers sometimes ignore system execution dependencies, leading to systems processing stale data from the previous frame.</p>\n<p><strong>Why it&#39;s wrong</strong>: Processing order affects game logic correctness — physics must run before rendering, input before movement.</p>\n<p><strong>How to fix</strong>: Explicitly declare system dependencies and use priority-based scheduling to ensure correct execution order.</p>\n<p>⚠️ <strong>Pitfall: Resource Leaks in Failed Systems</strong></p>\n<p>Failed systems sometimes leak resources (memory, file handles, GPU resources) when they&#39;re disabled due to errors.</p>\n<p><strong>Why it&#39;s wrong</strong>: Resource leaks accumulate over time and can cause system-wide failures.</p>\n<p><strong>How to fix</strong>: Implement proper cleanup in system destructors and error handling paths, ensure resources are released when systems are disabled.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The error handling implementation requires careful balance between safety, performance, and usability. Our approach provides configurable safety levels that can be adjusted based on build configuration and performance requirements.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Exception Handling</td>\n<td><code>std::exception</code> with error codes</td>\n<td>Custom exception hierarchy with structured data</td>\n</tr>\n<tr>\n<td>Error Logging</td>\n<td><code>std::cerr</code> with simple messages</td>\n<td>Structured logging library (spdlog) with levels</td>\n</tr>\n<tr>\n<td>Assertion System</td>\n<td>Standard <code>assert()</code> macro</td>\n<td>Custom assertions with stack traces</td>\n</tr>\n<tr>\n<td>Memory Debugging</td>\n<td>Built-in bounds checking</td>\n<td>AddressSanitizer or Valgrind integration</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">project</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">root</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  src</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">ecs</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    error_handling</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      entity_validator.h          ← Entity validation strategies</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      entity_validator.cpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      component_type_safety.h     ← Component type verification</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      component_type_safety.cpp   </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      system_circuit_breaker.h    ← System error recovery</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      system_circuit_breaker.cpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      error_context.h             ← Error context collection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      error_context.cpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      ecs_exceptions.h            ← Custom exception types</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    core</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      entity_manager.h            ← Modified with validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      component_storage.h         ← Modified with type safety</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      system_manager.h            ← Modified with error recovery</span></span></code></pre></div>\n\n<h4 id=\"entity-validation-infrastructure\">Entity Validation Infrastructure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Complete entity validation with configurable safety levels</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EntityValidator</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    enum</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> ValidationLevel</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        NONE</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">           // No validation (release builds)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        BASIC</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">          // Generation counter only</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        STANDARD</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">       // Generation + alive status</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        COMPREHENSIVE</span><span style=\"color:#6A737D\">   // All checks including bounds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> ValidationResult</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#E1E4E8\"> valid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        EntityID entity_id;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Generation expected_generation;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Generation actual_generation;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::string error_message;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Validates entity reference with configurable checking level</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#B392F0\"> ValidationResult</span><span style=\"color:#B392F0\"> validateEntity</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#B392F0\"> EntityManager</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> manager</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ValidationLevel</span><span style=\"color:#FFAB70\"> level</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> ValidationLevel</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">STANDARD</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Check if entity ID is within valid range</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Compare entity generation with manager's current generation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: If STANDARD or higher, verify entity is marked alive</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: If COMPREHENSIVE, perform additional bounds checking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Construct detailed ValidationResult with error context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Fast validation for hot paths (generation check only)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> isValidQuick</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> EntityManager</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> manager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Bounds check entity ID against manager capacity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Generation comparison with early exit</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Exception types for different validation failures</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EntityValidationException</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#F97583\">public</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">exception</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    EntityValidationException</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> EntityValidator</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">ValidationResult</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> result</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span><span style=\"color:#B392F0\">result_</span><span style=\"color:#E1E4E8\">(result) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Format detailed error message from ValidationResult</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#B392F0\"> what</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> noexcept</span><span style=\"color:#F97583\"> override</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Return formatted error message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#B392F0\"> EntityValidator</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">ValidationResult</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> getResult</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> result_; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    EntityValidator</span><span style=\"color:#E1E4E8\">::ValidationResult result_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"component-type-safety-infrastructure\">Component Type Safety Infrastructure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Type-safe component access with runtime verification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TypeSafeComponentAccess</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Throws exception on type mismatch or invalid access</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> getComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ComponentStorage</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> storage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">EntityID</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Verify T is registered with ComponentTypeRegistry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Check entity exists in component storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Verify component type ID matches T's registered type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Perform bounds checking in debug builds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Return reference to component</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        static</span><span style=\"color:#E1E4E8\"> T dummy;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> dummy;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Returns nullptr on any access failure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> tryGetComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ComponentStorage</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> storage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">EntityID</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: All validation steps from getComponent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Return nullptr instead of throwing on failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Log warnings for debugging in debug builds</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nullptr</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verifies component exists without accessing data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> hasComponent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> ComponentStorage</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> storage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">EntityID</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Basic type registration check</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Entity existence check in storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Return boolean result without exceptions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Runtime type verification for dynamic operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ComponentTypeVerifier</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> TypeMismatchInfo</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ComponentTypeID expected_type;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ComponentTypeID actual_type;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::string expected_name;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::string actual_name;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        EntityID entity_id;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verifies component type matches expected type ID</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> verifyComponentType</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        EntityID</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ComponentTypeID</span><span style=\"color:#FFAB70\"> expected_type</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        IComponentStorage</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> storage</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        TypeMismatchInfo</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> mismatch_info</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> nullptr</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Get actual component type from storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Compare with expected type ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: If mismatch_info provided, fill in diagnostic details</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Look up human-readable type names from registry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Validates all registered types have consistent metadata</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">validateTypeRegistry</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Iterate through all registered component types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Verify type IDs are unique and sequential</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Check size and alignment constraints are valid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Return list of any inconsistencies found</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"system-circuit-breaker-infrastructure\">System Circuit Breaker Infrastructure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Circuit breaker for individual system error recovery</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SystemCircuitBreaker</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    enum</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> State</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        HEALTHY</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">     // System executing normally</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        MONITORING</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">  // Tracking errors, still executing</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        OPEN</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">        // System disabled due to errors</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        HALF_OPEN</span><span style=\"color:#6A737D\">    // Testing system recovery</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> ErrorThreshold</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> max_errors </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">           // Errors before opening circuit</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        float</span><span style=\"color:#E1E4E8\"> time_window </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 10.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">       // Time window for error counting (seconds)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        float</span><span style=\"color:#E1E4E8\"> recovery_timeout </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 30.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Time before attempting recovery</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> SystemHealthInfo</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        State state </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> State</span><span style=\"color:#E1E4E8\">::HEALTHY;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> error_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        float</span><span style=\"color:#E1E4E8\"> last_error_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        float</span><span style=\"color:#E1E4E8\"> state_change_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> recent_errors;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string, SystemHealthInfo</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> system_health_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ErrorThreshold thresholds_;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> current_time_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SystemCircuitBreaker</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> ErrorThreshold</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> thresholds</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span><span style=\"color:#B392F0\">thresholds_</span><span style=\"color:#E1E4E8\">(thresholds) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Records error for system and updates circuit breaker state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> recordError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> system_name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> error_message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Get or create SystemHealthInfo for this system</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Add error to recent errors list (with time truncation)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Increment error count and update last error time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Check if error threshold exceeded in time window</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Transition to MONITORING or OPEN state as appropriate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: Log state transitions for debugging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Checks if system should be executed this frame</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> shouldExecuteSystem</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> system_name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Get SystemHealthInfo for system</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Handle HEALTHY and MONITORING states (execute normally)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Handle OPEN state (check recovery timeout)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Handle HALF_OPEN state (limited execution)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Update current_time_ and perform time-based state transitions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Records successful execution for recovery monitoring</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> recordSuccess</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> system_name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Get SystemHealthInfo for system</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: If in HALF_OPEN, transition back to HEALTHY</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: If in MONITORING, clear error count if no recent errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Update state change timestamps</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Gets current health status for debugging/telemetry</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SystemHealthInfo</span><span style=\"color:#B392F0\"> getSystemHealth</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> system_name</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Return copy of SystemHealthInfo or default if not found</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> updateTime</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> delta_time</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current_time_ </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> delta_time;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Enhanced SystemManager with error recovery</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ErrorRecoverySystemManager</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#F97583\">public</span><span style=\"color:#B392F0\"> SystemManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SystemCircuitBreaker circuit_breaker_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> system_dependencies_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Override base updateAllSystems to add error handling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> updateAllSystems</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> delta_time</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">override</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        circuit_breaker_.</span><span style=\"color:#B392F0\">updateTime</span><span style=\"color:#E1E4E8\">(delta_time);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Iterate through systems in priority order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Check circuit breaker before executing each system</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Wrap system execution in try-catch block</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Record errors/successes with circuit breaker</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Handle dependency cascading for failed systems</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: Continue with remaining systems even if some fail</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Declares dependency relationship between systems</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> addSystemDependency</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> dependent</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> dependency</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Add dependency to dependency map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Validate no circular dependencies created</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Update system execution order if needed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Gets error statistics for monitoring/debugging</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::pair</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string, </span><span style=\"color:#B392F0\">SystemCircuitBreaker</span><span style=\"color:#E1E4E8\">::SystemHealthInfo</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    getSystemHealthReport</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Iterate through all registered systems</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Get health info from circuit breaker for each</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Return sorted list for display/logging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing error handling:</p>\n<p><strong>Entity Validation Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run entity validation tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">g++</span><span style=\"color:#79B8FF\"> -DDEBUG</span><span style=\"color:#79B8FF\"> -g</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> entity_validator_test</span><span style=\"color:#9ECBFF\"> test/entity_validator_test.cpp</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./entity_validator_test</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [PASS] Valid entity access succeeds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [PASS] Stale entity reference detected and rejected  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [PASS] Generation counter prevents ABA problem</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [PASS] Out of bounds entity ID rejected</span></span></code></pre></div>\n\n<p><strong>Component Type Safety Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run component type safety tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">g++</span><span style=\"color:#79B8FF\"> -DDEBUG</span><span style=\"color:#79B8FF\"> -g</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> component_safety_test</span><span style=\"color:#9ECBFF\"> test/component_safety_test.cpp</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./component_safety_test</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [PASS] Template type checking works at compile time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [PASS] Runtime type verification catches mismatches</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [PASS] Unregistered component type throws exception</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [PASS] Type-erased access validates correctly</span></span></code></pre></div>\n\n<p><strong>System Error Recovery Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run system circuit breaker tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">g++</span><span style=\"color:#79B8FF\"> -DDEBUG</span><span style=\"color:#79B8FF\"> -g</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> system_recovery_test</span><span style=\"color:#9ECBFF\"> test/system_recovery_test.cpp</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./system_recovery_test</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [PASS] Healthy system executes normally  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [PASS] Failed system disabled after threshold</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [PASS] System recovery after timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [PASS] Dependent systems disabled with failed dependency</span></span></code></pre></div>\n\n<p><strong>Manual Verification Steps:</strong></p>\n<ol>\n<li>Create entities and immediately destroy them, then try to access components — should get validation errors</li>\n<li>Attempt to access <code>Position</code> component as <code>Velocity</code> type — should get type mismatch error  </li>\n<li>Create a system that throws exceptions — verify other systems continue running</li>\n<li>Check log files contain detailed error context for debugging</li>\n</ol>\n<p><strong>Signs of Problems:</strong></p>\n<ul>\n<li>Crashes instead of graceful error handling indicate missing exception handling</li>\n<li>Silent failures without error logs suggest validation isn&#39;t being called</li>\n<li>Systems not recovering after errors indicates circuit breaker logic bugs</li>\n<li>Performance too slow in debug builds means validation is too expensive</li>\n</ul>\n<h2 id=\"testing-strategy\">Testing Strategy</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestones 1-4 — comprehensive testing approaches for each milestone including unit tests for components, integration tests for system interactions, and performance benchmarks</p>\n</blockquote>\n<p>Testing an ECS architecture presents unique challenges compared to traditional object-oriented systems. The separation of data (components) from logic (systems) means we must verify not only individual component behavior but also the complex interactions between entities, components, and systems across multiple execution frames. Our testing strategy must validate both correctness and performance characteristics, ensuring that our cache-friendly data structures actually deliver the promised performance benefits while maintaining data integrity throughout entity lifecycles.</p>\n<h3 id=\"mental-model-quality-control-in-a-manufacturing-pipeline\">Mental Model: Quality Control in a Manufacturing Pipeline</h3>\n<p>Think of ECS testing like quality control in a modern manufacturing facility. Just as a factory has quality checkpoints at each station (individual component testing), integration tests between stations (system interaction testing), and performance benchmarks for the entire production line (end-to-end performance testing), our ECS testing strategy operates at multiple levels. Each milestone represents a manufacturing station that must pass quality checks before the next station can rely on its output. The assembly line (system execution) must maintain throughput targets while producing correct results, and any performance degradation or correctness failure at one station affects the entire production line.</p>\n<p>The key insight is that ECS testing must verify both the <strong>structural integrity</strong> of our data-oriented design (are components stored correctly, are entity relationships maintained) and the <strong>behavioral correctness</strong> of our logic systems (do systems process entities correctly, do component modifications propagate properly). Unlike testing traditional object hierarchies where each object encapsulates both data and behavior, ECS testing must verify the coordination between separate data storage and logic execution components.</p>\n<h3 id=\"milestone-checkpoint-testing\">Milestone Checkpoint Testing</h3>\n<p>Each milestone builds upon the previous one, creating a dependency chain where later milestones rely heavily on earlier components functioning correctly. Our checkpoint testing strategy validates both the immediate functionality delivered by each milestone and its integration with previously completed milestones. This approach catches integration issues early and provides confidence that complex interactions will work correctly when all milestones are combined.</p>\n<h4 id=\"milestone-1-entity-manager-checkpoint\">Milestone 1: Entity Manager Checkpoint</h4>\n<p>The Entity Manager checkpoint testing focuses on validating entity lifecycle management, generation counter behavior, and ID recycling mechanisms. Since all other milestones depend on reliable entity management, these tests must be comprehensive and cover edge cases thoroughly.</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Test Name</th>\n<th>Expected Behavior</th>\n<th>Validation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ID Generation</td>\n<td><code>testEntityCreation</code></td>\n<td>Each call to <code>createEntity()</code> returns unique <code>EntityID</code></td>\n<td>Assert no duplicate IDs in 10,000 entity batch</td>\n</tr>\n<tr>\n<td>Generation Counter</td>\n<td><code>testGenerationIncrement</code></td>\n<td>Destroying and recreating entity increments generation</td>\n<td>Create entity, destroy, recreate - verify generation+1</td>\n</tr>\n<tr>\n<td>ID Recycling</td>\n<td><code>testIDRecycling</code></td>\n<td>Destroyed entity IDs are reused for new entities</td>\n<td>Destroy entity with ID 100, create new - should get ID 100</td>\n</tr>\n<tr>\n<td>Stale Reference Prevention</td>\n<td><code>testStaleEntityDetection</code></td>\n<td><code>isAlive()</code> returns false for destroyed entities</td>\n<td>Create entity, store reference, destroy, verify <code>isAlive()</code> false</td>\n</tr>\n<tr>\n<td>Free List Management</td>\n<td><code>testFreeListBounds</code></td>\n<td>Free list respects <code>MAX_FREE_LIST_SIZE</code> limit</td>\n<td>Destroy entities exceeding limit, verify oldest IDs permanently retired</td>\n</tr>\n<tr>\n<td>Alive Entity Tracking</td>\n<td><code>testAliveEntityCount</code></td>\n<td><code>getAliveEntityCount()</code> matches actual living entities</td>\n<td>Create/destroy entities, verify count accuracy throughout</td>\n</tr>\n<tr>\n<td>Entity Iteration</td>\n<td><code>testEntityIteration</code></td>\n<td><code>getAllEntities()</code> returns only alive entities</td>\n<td>Create mixed alive/dead entities, verify iteration skips dead</td>\n</tr>\n<tr>\n<td>Overflow Handling</td>\n<td><code>testGenerationOverflow</code></td>\n<td>Generation counter handles overflow gracefully</td>\n<td>Force generation to maximum value, verify safe behavior</td>\n</tr>\n</tbody></table>\n<p>The critical checkpoint verification involves running a stress test that creates 100,000 entities, destroys 50,000 in random order, creates another 25,000, and verifies that all entity operations maintain consistency. This test should complete in under 100 milliseconds and produce no duplicate entity IDs or false positive <code>isAlive()</code> results.</p>\n<p><strong>Checkpoint Command</strong>: Run <code>./test_entity_manager --stress</code> and verify output shows &quot;All 175,000 entity operations completed successfully, 75,000 entities alive, 0 duplicate IDs detected, 0 stale references accessible.&quot;</p>\n<h4 id=\"milestone-2-component-storage-checkpoint\">Milestone 2: Component Storage Checkpoint</h4>\n<p>Component storage testing must validate cache-friendly storage patterns, sparse set operations, and type-safe component access. The tests verify both correctness and performance characteristics of our data-oriented storage approach.</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Test Name</th>\n<th>Expected Behavior</th>\n<th>Validation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Sparse Set Operations</td>\n<td><code>testSparseSetInsertRemove</code></td>\n<td><code>insert()</code> and <code>remove()</code> maintain bidirectional mapping</td>\n<td>Insert components, verify both dense and sparse arrays consistent</td>\n</tr>\n<tr>\n<td>Cache Locality</td>\n<td><code>testContiguousStorage</code></td>\n<td>Component data stored in contiguous memory blocks</td>\n<td>Verify address arithmetic between consecutive components</td>\n</tr>\n<tr>\n<td>Type Safety</td>\n<td><code>testComponentTypeVerification</code></td>\n<td>Wrong type access throws <code>ComponentTypeException</code></td>\n<td>Attempt to access <code>Position</code> as <code>Velocity</code>, verify exception</td>\n</tr>\n<tr>\n<td>Swap-Remove Semantics</td>\n<td><code>testSwapRemoveBehavior</code></td>\n<td>Component removal swaps last element to fill gap</td>\n<td>Remove middle component, verify last component moved to gap</td>\n</tr>\n<tr>\n<td>Entity-Component Mapping</td>\n<td><code>testEntityComponentLookup</code></td>\n<td><code>hasComponent()</code> and <code>getComponent()</code> consistent</td>\n<td>Add components to entities, verify lookup operations match</td>\n</tr>\n<tr>\n<td>Iterator Stability</td>\n<td><code>testIteratorInvalidation</code></td>\n<td>Component modification invalidates active iterators</td>\n<td>Modify components during iteration, verify safe failure</td>\n</tr>\n<tr>\n<td>Memory Efficiency</td>\n<td><code>testMemoryFootprint</code></td>\n<td>Storage overhead stays within acceptable bounds</td>\n<td>Measure memory usage with 10,000 components, verify &lt;5% overhead</td>\n</tr>\n<tr>\n<td>Type Registry</td>\n<td><code>testComponentTypeRegistry</code></td>\n<td>Multiple component types coexist correctly</td>\n<td>Register <code>Position</code>, <code>Velocity</code>, <code>Health</code>, verify independent storage</td>\n</tr>\n</tbody></table>\n<p>The performance aspect of component storage testing involves measuring memory access patterns using cache miss counters. Our benchmark creates 10,000 entities with <code>Position</code> components, then iterates through all positions calculating distances. This operation should complete in under 1 millisecond with fewer than 100 cache misses, demonstrating effective cache locality.</p>\n<p><strong>Checkpoint Command</strong>: Run <code>./test_component_storage --benchmark</code> and verify output shows &quot;10,000 component iteration completed in &lt;1ms, cache miss ratio &lt;1%, memory overhead 3.2%.&quot;</p>\n<h4 id=\"milestone-3-system-interface-checkpoint\">Milestone 3: System Interface Checkpoint</h4>\n<p>System interface testing focuses on component queries, system execution ordering, and the interaction between systems and component storage. These tests must verify that systems can reliably find and process entities with specific component combinations.</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Test Name</th>\n<th>Expected Behavior</th>\n<th>Validation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Component Queries</td>\n<td><code>testQueryEntitySelection</code></td>\n<td>Query finds all entities matching component requirements</td>\n<td>Create entities with different components, verify query results</td>\n</tr>\n<tr>\n<td>Query Iterator</td>\n<td><code>testQueryIteratorBehavior</code></td>\n<td>Iterator provides type-safe access to entity components</td>\n<td>Use <code>query&lt;Position, Velocity&gt;()</code>, verify tuple access works</td>\n</tr>\n<tr>\n<td>System Registration</td>\n<td><code>testSystemRegistration</code></td>\n<td>Systems register with priority and execute in order</td>\n<td>Register systems with priorities 100, 300, 200 - verify execution order 100, 200, 300</td>\n</tr>\n<tr>\n<td>System Execution</td>\n<td><code>testSystemUpdateCycle</code></td>\n<td><code>updateAllSystems()</code> calls <code>update()</code> on all enabled systems</td>\n<td>Register systems, call update cycle, verify all systems received update</td>\n</tr>\n<tr>\n<td>Delta Time Passing</td>\n<td><code>testDeltaTimeDistribution</code></td>\n<td>Systems receive correct delta time parameter</td>\n<td>Pass 0.016f delta time, verify all systems received same value</td>\n</tr>\n<tr>\n<td>System Enabling/Disabling</td>\n<td><code>testSystemToggling</code></td>\n<td>Disabled systems don&#39;t execute during update cycle</td>\n<td>Disable system, run update cycle, verify system didn&#39;t execute</td>\n</tr>\n<tr>\n<td>Dependency Ordering</td>\n<td><code>testSystemDependencies</code></td>\n<td>Systems with dependencies execute in correct order</td>\n<td>Physics system depends on input - verify input executes first</td>\n</tr>\n<tr>\n<td>Query Result Consistency</td>\n<td><code>testQueryConsistency</code></td>\n<td>Multiple queries for same components return same entities</td>\n<td>Run identical queries consecutively, verify entity sets match</td>\n</tr>\n</tbody></table>\n<p>System interface checkpoint testing includes a complex scenario where multiple systems modify entity components during the same frame. We create entities with <code>Position</code>, <code>Velocity</code>, and <code>Health</code> components, then run physics, damage, and rendering systems that each modify different component types. The test verifies that all component modifications are visible to subsequent systems in the same frame.</p>\n<p><strong>Checkpoint Command</strong>: Run <code>./test_system_interface --integration</code> and verify output shows &quot;3 systems executed successfully, 1000 entities processed, component modifications correctly propagated between systems.&quot;</p>\n<h4 id=\"milestone-4-archetype-storage-checkpoint\">Milestone 4: Archetype Storage Checkpoint</h4>\n<p>Archetype storage testing validates entity grouping by component combination, archetype transitions when components are added or removed, and cache-efficient iteration within archetypes. This advanced milestone requires sophisticated testing to verify the complex data movement operations.</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Test Name</th>\n<th>Expected Behavior</th>\n<th>Validation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Archetype Identification</td>\n<td><code>testArchetypeCreation</code></td>\n<td>Entities with same components grouped into same archetype</td>\n<td>Create entities with identical components, verify same <code>ArchetypeInfo</code></td>\n</tr>\n<tr>\n<td>Archetype Transitions</td>\n<td><code>testComponentAddRemoveTransition</code></td>\n<td>Adding/removing components moves entities between archetypes</td>\n<td>Add component to entity, verify moved to new archetype</td>\n</tr>\n<tr>\n<td>Chunk-Based Storage</td>\n<td><code>testChunkAllocation</code></td>\n<td>Entities within archetypes stored in fixed-size chunks</td>\n<td>Verify chunk boundaries at <code>CHUNK_SIZE</code> intervals</td>\n</tr>\n<tr>\n<td>Cache-Friendly Iteration</td>\n<td><code>testArchetypeIteration</code></td>\n<td>Iterating archetype accesses contiguous memory</td>\n<td>Measure cache misses during archetype iteration</td>\n</tr>\n<tr>\n<td>Archetype Query Matching</td>\n<td><code>testArchetypeQueryOptimization</code></td>\n<td>Queries efficiently find matching archetypes</td>\n<td>Query should examine only archetypes containing required components</td>\n</tr>\n<tr>\n<td>Entity Movement</td>\n<td><code>testEntityArchetypeMovement</code></td>\n<td>Entity component data preserved during archetype transitions</td>\n<td>Verify component values unchanged after archetype transition</td>\n</tr>\n<tr>\n<td>Chunk Compaction</td>\n<td><code>testChunkGarbageCollection</code></td>\n<td>Removing entities compacts chunks efficiently</td>\n<td>Remove entities, verify no gaps in chunk storage</td>\n</tr>\n<tr>\n<td>Archetype Graph</td>\n<td><code>testArchetypeGraph</code></td>\n<td>Archetype transitions form valid directed graph</td>\n<td>Verify archetype relationships form acyclic graph</td>\n</tr>\n</tbody></table>\n<p>Archetype storage checkpoint testing involves a stress scenario where entities rapidly add and remove components, causing frequent archetype transitions. The test creates 1,000 entities, performs 10,000 component additions and removals, and verifies that all entity data remains consistent throughout the transitions while maintaining cache-friendly storage patterns.</p>\n<p><strong>Checkpoint Command</strong>: Run <code>./test_archetype_storage --transitions</code> and verify output shows &quot;10,000 archetype transitions completed successfully, 0 data corruption detected, average transition time &lt;0.001ms.&quot;</p>\n<h3 id=\"performance-benchmarking\">Performance Benchmarking</h3>\n<p>Performance benchmarking validates that our ECS implementation delivers the promised benefits of data-oriented design. The benchmarks measure cache efficiency, iteration performance, and memory usage patterns under realistic game development scenarios. Our benchmarking strategy compares ECS performance against traditional object-oriented approaches and establishes baseline performance expectations for each milestone.</p>\n<h4 id=\"cache-miss-measurement-strategy\">Cache Miss Measurement Strategy</h4>\n<p>Cache efficiency forms the core benefit of ECS architecture, so measuring cache behavior accurately is critical. We use hardware performance counters to measure L1, L2, and L3 cache misses during component iteration operations. The benchmarks create scenarios that should demonstrate clear cache efficiency advantages over scattered object-oriented data layouts.</p>\n<table>\n<thead>\n<tr>\n<th>Benchmark Name</th>\n<th>Scenario</th>\n<th>Expected Cache Performance</th>\n<th>Measurement Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>benchComponentIteration</code></td>\n<td>Iterate 10,000 Position components</td>\n<td>&lt;1% L1 cache miss ratio</td>\n<td>Hardware performance counters via <code>perf</code></td>\n</tr>\n<tr>\n<td><code>benchMultiComponentQuery</code></td>\n<td>Query Position+Velocity on 10,000 entities</td>\n<td>&lt;2% L2 cache miss ratio</td>\n<td>Memory access pattern analysis</td>\n</tr>\n<tr>\n<td><code>benchArchetypeIteration</code></td>\n<td>Iterate entities within single archetype</td>\n<td>&lt;0.5% L3 cache miss ratio</td>\n<td>Cache miss profiling tools</td>\n</tr>\n<tr>\n<td><code>benchRandomAccess</code></td>\n<td>Random entity component access pattern</td>\n<td>Cache misses scale with entity count</td>\n<td>Statistical cache behavior analysis</td>\n</tr>\n<tr>\n<td><code>benchSystemExecution</code></td>\n<td>Full system update cycle with 5 systems</td>\n<td>Cache miss ratio stable across frames</td>\n<td>Frame-to-frame cache consistency</td>\n</tr>\n</tbody></table>\n<p>The cache miss benchmarks run on systems with known cache hierarchy characteristics. We establish baseline measurements by running equivalent operations on traditional object-oriented entity implementations, then compare ECS performance. The ECS implementation should show 5-10x fewer cache misses for iteration-heavy operations.</p>\n<h4 id=\"iteration-speed-comparisons\">Iteration Speed Comparisons</h4>\n<p>Component iteration speed directly impacts frame rate performance in real games. Our iteration benchmarks measure throughput for various component access patterns and entity counts, establishing performance scaling characteristics as entity populations grow.</p>\n<table>\n<thead>\n<tr>\n<th>Benchmark Name</th>\n<th>Operation</th>\n<th>Entity Count</th>\n<th>Expected Throughput</th>\n<th>Performance Target</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>benchSingleComponentIteration</code></td>\n<td>Process all Position components</td>\n<td>100,000</td>\n<td>&gt;50M components/second</td>\n<td>Linear scaling with entity count</td>\n</tr>\n<tr>\n<td><code>benchDualComponentIteration</code></td>\n<td>Process Position+Velocity pairs</td>\n<td>100,000</td>\n<td>&gt;25M pairs/second</td>\n<td>Sparse set intersection overhead</td>\n</tr>\n<tr>\n<td><code>benchTripleComponentIteration</code></td>\n<td>Process Position+Velocity+Health</td>\n<td>100,000</td>\n<td>&gt;15M triplets/second</td>\n<td>Multiple sparse set intersection</td>\n</tr>\n<tr>\n<td><code>benchArchetypeOptimizedIteration</code></td>\n<td>Same operation using archetypes</td>\n<td>100,000</td>\n<td>&gt;40M triplets/second</td>\n<td>Archetype optimization advantage</td>\n</tr>\n<tr>\n<td><code>benchSystemUpdateBenchmark</code></td>\n<td>Complete physics system update</td>\n<td>100,000</td>\n<td>&gt;10M updates/second</td>\n<td>Realistic system performance</td>\n</tr>\n</tbody></table>\n<p>Iteration speed benchmarks measure both raw component access speed and realistic system processing rates. The benchmarks include representative mathematical operations (vector math, collision detection, state updates) to simulate real game system workloads. Performance scaling should remain linear or near-linear as entity counts increase, demonstrating that our data-oriented approach avoids performance cliffs.</p>\n<h4 id=\"memory-usage-analysis\">Memory Usage Analysis</h4>\n<p>Memory efficiency affects both performance and scalability. Our memory benchmarks measure storage overhead, fragmentation characteristics, and memory access patterns under various entity and component configurations.</p>\n<table>\n<thead>\n<tr>\n<th>Benchmark Name</th>\n<th>Memory Aspect</th>\n<th>Measurement</th>\n<th>Efficiency Target</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>benchComponentStorageOverhead</code></td>\n<td>Storage overhead vs raw data size</td>\n<td>Bytes used / bytes of component data</td>\n<td>&lt;10% overhead</td>\n</tr>\n<tr>\n<td><code>benchSparseSetMemoryEfficiency</code></td>\n<td>Sparse set memory usage vs entity count</td>\n<td>Memory growth rate as entities increase</td>\n<td>Linear growth with small constant</td>\n</tr>\n<tr>\n<td><code>benchArchetypeMemoryLayout</code></td>\n<td>Archetype chunk utilization</td>\n<td>Percentage of allocated chunks actively used</td>\n<td>&gt;80% utilization</td>\n</tr>\n<tr>\n<td><code>benchMemoryFragmentation</code></td>\n<td>Heap fragmentation after entity churn</td>\n<td>Free memory block distribution</td>\n<td>Minimal fragmentation</td>\n</tr>\n<tr>\n<td><code>benchMemoryLocality</code></td>\n<td>Component data locality within caches</td>\n<td>Memory addresses of consecutive components</td>\n<td>Contiguous address ranges</td>\n</tr>\n</tbody></table>\n<p>Memory analysis includes measuring the impact of entity creation and destruction patterns on heap fragmentation. We simulate realistic game scenarios where entities are created and destroyed frequently, measuring whether our ID recycling and component storage strategies maintain efficient memory usage over extended runtime periods.</p>\n<h4 id=\"performance-regression-detection\">Performance Regression Detection</h4>\n<p>Performance benchmarks establish baseline performance characteristics that must be maintained as the codebase evolves. Our regression detection compares current performance against established baselines, alerting developers when changes negatively impact performance.</p>\n<blockquote>\n<p><strong>Critical Performance Baselines</strong></p>\n<ul>\n<li>Single component iteration: &gt;50M components/second on reference hardware</li>\n<li>Cache miss ratio for contiguous iteration: &lt;1% L1 misses</li>\n<li>Memory overhead for component storage: &lt;10% of raw component data</li>\n<li>System execution performance: &gt;10M entity updates/second for simple systems</li>\n<li>Archetype transition time: &lt;0.001ms average per entity movement</li>\n</ul>\n</blockquote>\n<p>Performance regression testing runs automatically as part of the build process, comparing current benchmark results against stored baseline values. Regressions exceeding 10% performance degradation require explicit acknowledgment and rationale before code changes are accepted.</p>\n<h3 id=\"correctness-verification\">Correctness Verification</h3>\n<p>Correctness verification ensures that our ECS implementation maintains data integrity and behavioral consistency throughout entity lifecycles, component modifications, and system executions. Unlike performance benchmarks that measure speed, correctness tests verify that operations produce expected results and handle edge cases safely.</p>\n<h4 id=\"entity-lifecycle-consistency\">Entity Lifecycle Consistency</h4>\n<p>Entity lifecycle testing verifies that entity creation, modification, and destruction maintain consistent state throughout the ECS system. These tests check that entity references remain valid when they should be and become invalid when entities are destroyed.</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Correctness Property</th>\n<th>Verification Method</th>\n<th>Expected Outcome</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Entity Creation Uniqueness</td>\n<td>No duplicate entity IDs generated during runtime</td>\n<td>Create 1M entities, verify all IDs unique</td>\n<td>Zero duplicate IDs detected</td>\n</tr>\n<tr>\n<td>Generation Counter Monotonicity</td>\n<td>Generation counters increase monotonically per ID</td>\n<td>Track generation progression for recycled IDs</td>\n<td>Generations always increase</td>\n</tr>\n<tr>\n<td>Stale Reference Detection</td>\n<td>Destroyed entities not accessible via old references</td>\n<td>Store entity references, destroy entities, attempt access</td>\n<td>All access attempts fail safely</td>\n</tr>\n<tr>\n<td>Component Consistency</td>\n<td>Entity components remain consistent during lifecycle</td>\n<td>Add components, verify persistence across operations</td>\n<td>Components maintain values</td>\n</tr>\n<tr>\n<td>Iteration Stability</td>\n<td>Entity iteration doesn&#39;t include destroyed entities</td>\n<td>Destroy entities during iteration, verify results</td>\n<td>Destroyed entities excluded</td>\n</tr>\n</tbody></table>\n<p>Entity lifecycle correctness testing includes stress scenarios where entities are created and destroyed rapidly while other operations (component access, system updates) are running concurrently. The tests verify that the system maintains consistency even under high-frequency entity churn.</p>\n<h4 id=\"component-data-integrity\">Component Data Integrity</h4>\n<p>Component data integrity testing ensures that component values are preserved correctly and that component operations (add, remove, modify) don&#39;t corrupt related data or create inconsistent state.</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Integrity Property</th>\n<th>Verification Method</th>\n<th>Expected Outcome</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Component Value Preservation</td>\n<td>Component values unchanged by unrelated operations</td>\n<td>Store component values, perform unrelated operations, verify values</td>\n<td>All values preserved exactly</td>\n</tr>\n<tr>\n<td>Sparse Set Bidirectional Consistency</td>\n<td>Dense and sparse arrays remain synchronized</td>\n<td>Verify sparse[dense[i]] == i for all valid indices</td>\n<td>Perfect bidirectional mapping</td>\n</tr>\n<tr>\n<td>Type Safety Enforcement</td>\n<td>Wrong type access detected and prevented</td>\n<td>Attempt cross-type component access, verify rejection</td>\n<td>All incorrect access attempts blocked</td>\n</tr>\n<tr>\n<td>Memory Corruption Prevention</td>\n<td>Component operations don&#39;t corrupt adjacent memory</td>\n<td>Add/remove components, verify adjacent data unchanged</td>\n<td>No corruption detected</td>\n</tr>\n<tr>\n<td>Component Attachment Consistency</td>\n<td>hasComponent() matches actual component presence</td>\n<td>Check component existence vs actual storage state</td>\n<td>Perfect consistency</td>\n</tr>\n</tbody></table>\n<p>Component integrity testing focuses on the swap-remove operations used by sparse sets, verifying that moving components to fill gaps doesn&#39;t corrupt data or create inconsistent index mappings. The tests include scenarios where components are added and removed in various orders, ensuring that storage remains consistent regardless of operation sequence.</p>\n<h4 id=\"system-execution-correctness\">System Execution Correctness</h4>\n<p>System execution correctness verifies that systems process entities correctly, that component modifications are applied properly, and that system interactions produce expected results across multiple execution frames.</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Execution Property</th>\n<th>Verification Method</th>\n<th>Expected Outcome</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>System Execution Order</td>\n<td>Systems execute in priority order each frame</td>\n<td>Register systems with known priorities, verify execution sequence</td>\n<td>Strict priority ordering maintained</td>\n</tr>\n<tr>\n<td>Component Query Accuracy</td>\n<td>Queries return exactly entities matching requirements</td>\n<td>Create entities with known components, verify query results</td>\n<td>Perfect query accuracy</td>\n</tr>\n<tr>\n<td>Component Modification Visibility</td>\n<td>System modifications visible to subsequent systems</td>\n<td>Modify components in one system, verify visibility in next</td>\n<td>All modifications visible</td>\n</tr>\n<tr>\n<td>Delta Time Distribution</td>\n<td>All systems receive identical delta time values</td>\n<td>Pass delta time to system manager, verify all systems get same value</td>\n<td>Identical delta time across systems</td>\n</tr>\n<tr>\n<td>System State Isolation</td>\n<td>System failures don&#39;t affect other system execution</td>\n<td>Force system to throw exception, verify other systems continue</td>\n<td>System isolation maintained</td>\n</tr>\n</tbody></table>\n<p>System execution correctness includes testing complex multi-frame scenarios where entities and components are modified across multiple update cycles. The tests verify that system execution produces deterministic results and that the same input consistently produces the same output.</p>\n<h4 id=\"edge-case-handling-verification\">Edge Case Handling Verification</h4>\n<p>Edge case testing validates system behavior under unusual or extreme conditions, ensuring that the ECS implementation handles corner cases gracefully without crashing or corrupting data.</p>\n<table>\n<thead>\n<tr>\n<th>Edge Case Category</th>\n<th>Scenario</th>\n<th>Expected Behavior</th>\n<th>Verification Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Empty Entity Operations</td>\n<td>Operations on entities with no components</td>\n<td>Operations succeed or fail safely</td>\n<td>No crashes or corruption</td>\n</tr>\n<tr>\n<td>Maximum Entity Count</td>\n<td>Creating entities until ID space exhausted</td>\n<td>Graceful failure when IDs exhausted</td>\n<td>Safe failure mode activated</td>\n</tr>\n<tr>\n<td>Component Type Overflow</td>\n<td>Registering more component types than supported</td>\n<td>Registration fails safely after limit</td>\n<td><code>MAX_COMPONENTS</code> limit enforced</td>\n</tr>\n<tr>\n<td>System Exception Handling</td>\n<td>System throws exception during update</td>\n<td>Exception contained, other systems continue</td>\n<td>System isolation verified</td>\n</tr>\n<tr>\n<td>Concurrent Access Safety</td>\n<td>Multiple operations on same entity simultaneously</td>\n<td>Operations complete safely or fail cleanly</td>\n<td>No data races or corruption</td>\n</tr>\n</tbody></table>\n<p>Edge case verification includes fuzz testing where random sequences of valid operations are applied to the ECS system, verifying that no combination of legal operations can cause crashes or data corruption. The tests run for extended periods to catch rare race conditions or state inconsistencies.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Test Framework</td>\n<td>Google Test (C++)</td>\n<td>Catch2 with BDD extensions</td>\n<td>Google Test provides comprehensive assertion macros and death tests for ECS</td>\n</tr>\n<tr>\n<td>Performance Profiling</td>\n<td><code>std::chrono</code> + manual instrumentation</td>\n<td>Intel VTune or perf with hardware counters</td>\n<td>Hardware counters essential for accurate cache miss measurement</td>\n</tr>\n<tr>\n<td>Memory Analysis</td>\n<td>Valgrind memcheck</td>\n<td>AddressSanitizer + heap profiling</td>\n<td>AddressSanitizer catches more subtle memory errors in ECS sparse sets</td>\n</tr>\n<tr>\n<td>Build Integration</td>\n<td>Manual test execution</td>\n<td>CMake CTest + CI/CD pipeline</td>\n<td>Automated execution prevents performance regression</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ecs-project/\n├── tests/\n│   ├── unit/\n│   │   ├── entity_manager_test.cpp     ← Milestone 1 unit tests\n│   │   ├── component_storage_test.cpp  ← Milestone 2 unit tests  \n│   │   ├── system_interface_test.cpp   ← Milestone 3 unit tests\n│   │   └── archetype_storage_test.cpp  ← Milestone 4 unit tests\n│   ├── integration/\n│   │   ├── ecs_integration_test.cpp    ← Cross-component integration tests\n│   │   └── game_scenario_test.cpp      ← Realistic game scenarios\n│   ├── benchmarks/\n│   │   ├── performance_benchmarks.cpp ← Cache and speed benchmarks\n│   │   ├── memory_benchmarks.cpp      ← Memory usage analysis\n│   │   └── regression_tests.cpp       ← Performance regression detection\n│   └── test_utils/\n│       ├── test_components.h          ← Position, Velocity, Health components\n│       ├── mock_systems.h             ← Test system implementations\n│       └── performance_counters.h     ← Hardware counter utilities\n├── src/\n│   └── ecs/                           ← ECS implementation files\n└── tools/\n    ├── benchmark_runner.cpp           ← Performance measurement tool\n    └── cache_analyzer.cpp             ← Cache miss analysis tool</code></pre></div>\n\n<h4 id=\"test-infrastructure-starter-code\">Test Infrastructure Starter Code</h4>\n<p>Complete test infrastructure for ECS components that handles the complexities of entity lifecycle and component management:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// tests/test_utils/test_components.h - Standard test components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cmath></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> Position</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> x </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> y </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">==</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Position</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">abs</span><span style=\"color:#E1E4E8\">(x </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> other.x) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0.001</span><span style=\"color:#F97583\">f</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">abs</span><span style=\"color:#E1E4E8\">(y </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> other.y) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0.001</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> Velocity</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> dx </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> dy </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">==</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Velocity</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">abs</span><span style=\"color:#E1E4E8\">(dx </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> other.dx) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0.001</span><span style=\"color:#F97583\">f</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">abs</span><span style=\"color:#E1E4E8\">(dy </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> other.dy) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0.001</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> Health</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> current </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> maximum </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#F97583\"> operator</span><span style=\"color:#B392F0\">==</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Health</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> other</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> current </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> other.current </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> maximum </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> other.maximum;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// tests/test_utils/mock_systems.h - Test system implementations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"ecs/system_interface.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MovementSystem</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#F97583\">public</span><span style=\"color:#B392F0\"> System</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    MovementSystem</span><span style=\"color:#E1E4E8\">() : </span><span style=\"color:#B392F0\">System</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"MovementSystem\"</span><span style=\"color:#E1E4E8\">, PRIORITY_PHYSICS) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">override</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> query </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> world.query</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Position, Velocity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">auto</span><span style=\"color:#E1E4E8\"> [position, velocity] : query) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            position.x </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> velocity.dx </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> deltaTime;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            position.y </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> velocity.dy </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> deltaTime;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> HealthSystem</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#F97583\">public</span><span style=\"color:#B392F0\"> System</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> entitiesProcessed </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    HealthSystem</span><span style=\"color:#E1E4E8\">() : </span><span style=\"color:#B392F0\">System</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"HealthSystem\"</span><span style=\"color:#E1E4E8\">, PRIORITY_LOGIC) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">override</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> query </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> world.query</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Health</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">auto</span><span style=\"color:#E1E4E8\"> [health] : query) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (health.current </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                entitiesProcessed</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// tests/test_utils/performance_counters.h - Hardware performance monitoring</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;chrono></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;fstream></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CacheMissCounter</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> l1_misses_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> l2_misses_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> monitoring_active </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> startMonitoring</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Platform-specific performance counter initialization</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        monitoring_active </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        l1_misses_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> readL1CacheMisses</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        l2_misses_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> readL2CacheMisses</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> CacheStats</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint64_t</span><span style=\"color:#E1E4E8\"> l1_misses;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint64_t</span><span style=\"color:#E1E4E8\"> l2_misses;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        double</span><span style=\"color:#E1E4E8\"> miss_ratio;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    CacheStats</span><span style=\"color:#B392F0\"> stopMonitoring</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">monitoring_active) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint64_t</span><span style=\"color:#E1E4E8\"> l1_misses </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> readL1CacheMisses</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> l1_misses_start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint64_t</span><span style=\"color:#E1E4E8\"> l2_misses </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> readL2CacheMisses</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> l2_misses_start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        monitoring_active </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {l1_misses, l2_misses, </span><span style=\"color:#B392F0\">calculateMissRatio</span><span style=\"color:#E1E4E8\">(l1_misses, l2_misses)};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#B392F0\"> readL1CacheMisses</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Linux perf_event_open() or Windows performance counters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Implementation depends on platform</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Placeholder - implement with actual hardware counters</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#B392F0\"> readL2CacheMisses</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Platform-specific L2 cache miss counter reading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Placeholder - implement with actual hardware counters  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#B392F0\"> calculateMissRatio</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#FFAB70\"> l1_misses</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#FFAB70\"> l2_misses</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Calculate cache miss percentage based on access patterns</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Placeholder - implement actual miss ratio calculation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"core-test-skeleton-code\">Core Test Skeleton Code</h4>\n<p>Test skeletons for each milestone with detailed TODO comments mapping to verification requirements:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// tests/unit/entity_manager_test.cpp - Milestone 1 testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;gtest/gtest.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"ecs/entity_manager.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unordered_set></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EntityManagerTest</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#F97583\">public</span><span style=\"color:#E1E4E8\"> ::</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">Test</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">protected:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EntityManager entity_manager;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> SetUp</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">override</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Reset entity manager state before each test</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">TEST_F</span><span style=\"color:#E1E4E8\">(EntityManagerTest, UniqueEntityGeneration) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create 10,000 entities and store their IDs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Use std::unordered_set to detect duplicate IDs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Assert that set size equals entity count (no duplicates)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify all entities report isAlive() == true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Expected: Zero duplicate IDs, all entities alive</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">TEST_F</span><span style=\"color:#E1E4E8\">(EntityManagerTest, GenerationCounterProgression) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create entity and store its ID and generation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Destroy the entity using destroyEntity()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create another entity - should reuse ID with incremented generation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify new entity has same ID but generation+1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify old entity reference now returns isAlive() == false</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Expected: ID reused, generation incremented, stale reference detected</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">TEST_F</span><span style=\"color:#E1E4E8\">(EntityManagerTest, FreeListManagement) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create entities until free list reaches capacity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Destroy more entities than MAX_FREE_LIST_SIZE</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify oldest destroyed IDs have PERMANENT_GENERATION</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create new entities - verify recent destroys get recycled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify permanently retired IDs never get reused</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Expected: Free list bounded, old IDs permanently retired</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// tests/unit/component_storage_test.cpp - Milestone 2 testing</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">TEST_F</span><span style=\"color:#E1E4E8\">(ComponentStorageTest, SparseSetConsistency) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ComponentStorage</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Position</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> storage;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Insert Position components for entities 100, 200, 300</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Verify dense array contains exactly 3 elements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For each entity, verify sparse[entityID] gives correct dense index</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: For each dense index, verify entity_array[index] gives correct entity ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Remove entity 200, verify sparse set maintains bidirectional mapping</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Expected: Perfect bidirectional mapping maintained through all operations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">TEST_F</span><span style=\"color:#E1E4E8\">(ComponentStorageTest, CacheLocalityMeasurement) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ComponentStorage</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Position</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> storage;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CacheMissCounter counter;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create 10,000 Position components with sequential entity IDs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Start cache miss monitoring</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Iterate through all positions, performing simple calculation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Stop monitoring and capture cache statistics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Assert L1 cache miss ratio &#x3C; 1%</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Expected: Cache-friendly iteration with minimal cache misses</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// tests/integration/ecs_integration_test.cpp - Cross-milestone testing</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">TEST_F</span><span style=\"color:#E1E4E8\">(ECSIntegrationTest, CompleteGameFrameSimulation) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    World world;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Register MovementSystem and HealthSystem with priorities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create 1000 entities with Position, Velocity, Health components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Run 60 frame updates with 16ms delta time each</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify all entities moved correctly (position += velocity * deltaTime * 60)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify all systems executed in priority order each frame</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Verify component modifications visible between systems</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Expected: Realistic game simulation with correct physics and component updates</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p>Each milestone includes specific verification steps that prove the implementation meets acceptance criteria:</p>\n<p><strong>Milestone 1 Checkpoint</strong>: </p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Compile and run entity manager tests</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">cd</span><span style=\"color:#9ECBFF\"> build</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#B392F0\">make</span><span style=\"color:#9ECBFF\"> test_entity_manager</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#B392F0\">./test_entity_manager</span><span style=\"color:#79B8FF\"> --gtest_filter=</span><span style=\"color:#9ECBFF\">\"EntityManager*\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [==========] Running 8 tests from 1 test suite.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [       OK ] EntityManagerTest.UniqueEntityGeneration (15 ms)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [       OK ] EntityManagerTest.GenerationCounterProgression (2 ms)  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [       OK ] EntityManagerTest.FreeListManagement (8 ms)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [==========] 8 tests from 1 test suite ran. (45 ms total)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [  PASSED  ] 8 tests.</span></span></code></pre></div>\n\n<p><strong>Milestone 2 Checkpoint</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run component storage with cache analysis</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./test_component_storage</span><span style=\"color:#79B8FF\"> --benchmark</span><span style=\"color:#79B8FF\"> --cache_analysis</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Component Storage Tests: PASSED</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Cache Performance: L1 miss ratio 0.8%, L2 miss ratio 1.2%</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Memory overhead: 4.1% of raw component data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Iteration speed: 52M components/second</span></span></code></pre></div>\n\n<p><strong>Milestone 3 Checkpoint</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run system integration tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./test_system_interface</span><span style=\"color:#79B8FF\"> --integration</span><span style=\"color:#79B8FF\"> --timing</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># System registration: 3 systems registered successfully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># System execution order: InputSystem(100), PhysicsSystem(300), RenderSystem(500)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Frame update: 1000 entities processed in 0.8ms</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Component queries: 100% accuracy across all query types</span></span></code></pre></div>\n\n<p><strong>Milestone 4 Checkpoint</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run archetype optimization tests  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./test_archetype_storage</span><span style=\"color:#79B8FF\"> --performance</span><span style=\"color:#79B8FF\"> --transitions</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Archetype creation: 15 unique archetypes identified</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Entity transitions: 10,000 transitions completed in 8ms</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Cache performance: 40% improvement over sparse set iteration  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Memory utilization: 89% chunk utilization achieved</span></span></code></pre></div>\n\n<h4 id=\"performance-benchmark-infrastructure\">Performance Benchmark Infrastructure</h4>\n<p>Complete benchmarking infrastructure for measuring and comparing ECS performance characteristics:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// tests/benchmarks/performance_benchmarks.cpp</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;benchmark/benchmark.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"ecs/world.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"test_utils/test_components.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"test_utils/performance_counters.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> BM_ComponentIteration</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">benchmark</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">State</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> state</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    World world;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Setup: Create entities with Position components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> state.</span><span style=\"color:#B392F0\">range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">i) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Entity entity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> world.</span><span style=\"color:#B392F0\">createEntity</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        world.addComponent</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Position</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">(entity, {</span><span style=\"color:#F97583\">static_cast&#x3C;float></span><span style=\"color:#E1E4E8\">(i), </span><span style=\"color:#F97583\">static_cast&#x3C;float></span><span style=\"color:#E1E4E8\">(i)});</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Benchmark: Iterate through all positions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">auto</span><span style=\"color:#E1E4E8\"> _ : state) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        float</span><span style=\"color:#E1E4E8\"> sum </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> query </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> world.query</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Position</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">auto</span><span style=\"color:#E1E4E8\"> [position] : query) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            sum </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> position.x </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> position.y;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        benchmark</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">DoNotOptimize</span><span style=\"color:#E1E4E8\">(sum);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state.</span><span style=\"color:#B392F0\">SetItemsProcessed</span><span style=\"color:#E1E4E8\">(state.</span><span style=\"color:#B392F0\">iterations</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> state.</span><span style=\"color:#B392F0\">range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state.</span><span style=\"color:#B392F0\">SetBytesProcessed</span><span style=\"color:#E1E4E8\">(state.</span><span style=\"color:#B392F0\">iterations</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> state.</span><span style=\"color:#B392F0\">range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(Position));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">BENCHMARK</span><span style=\"color:#E1E4E8\">(BM_ComponentIteration)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    -></span><span style=\"color:#B392F0\">Range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">100000</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    -></span><span style=\"color:#B392F0\">ReportAggregatesOnly</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    -></span><span style=\"color:#B392F0\">MeasureProcessorTime</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> BM_SystemExecution</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">benchmark</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">State</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> state</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    World world;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    world.registerSystem</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">MovementSystem</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">(PRIORITY_PHYSICS);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create entities with Position and Velocity components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Measure complete system update cycle time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Report entities processed per second</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Expected: >10M entity updates/second for simple movement system</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">BENCHMARK</span><span style=\"color:#E1E4E8\">(BM_SystemExecution)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    -></span><span style=\"color:#B392F0\">Range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">100000</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    -></span><span style=\"color:#B392F0\">Unit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">benchmark</span><span style=\"color:#E1E4E8\">::kMicrosecond);</span></span></code></pre></div>\n\n\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestones 1-4 — comprehensive debugging techniques for memory corruption, performance issues, and system logic problems encountered during ECS implementation</p>\n</blockquote>\n<p>Debugging an Entity-Component-System architecture presents unique challenges compared to traditional object-oriented game engines. The separation of data (components) from logic (systems) and the use of indirection through entity IDs creates new categories of bugs that developers must learn to recognize and diagnose. This guide provides systematic approaches for identifying and resolving the most common issues encountered during ECS development.</p>\n<p>The debugging challenges in ECS fall into three primary categories. <strong>Memory and corruption issues</strong> arise from the complex pointer relationships between entities, components, and storage systems. <strong>Performance problems</strong> stem from cache inefficiencies that defeat the primary advantage of data-oriented design. <strong>System logic errors</strong> occur when the separation of concerns creates unexpected interactions between systems or invalid assumptions about component state.</p>\n<p>Understanding these debugging scenarios is crucial because ECS bugs often manifest differently than traditional object-oriented bugs. A null pointer dereference in object-oriented code typically points directly to the problematic object. In ECS, the same symptom might indicate a stale entity reference, component storage corruption, or system execution order dependencies that are several layers removed from the crash location.</p>\n<h3 id=\"memory-and-corruption-issues\">Memory and Corruption Issues</h3>\n<p>Think of debugging ECS memory issues like investigating a mail delivery system where letters (components) can be delivered to the wrong addresses (entities), postal workers (systems) might use outdated address books (stale references), or the sorting facility (component storage) might have internal organizational problems. Each type of delivery failure requires different diagnostic techniques to trace the root cause.</p>\n<p>Memory corruption in ECS systems typically manifests through four primary mechanisms: stale entity references, component storage corruption, iterator invalidation during system updates, and resource leaks during entity destruction. Each category requires specific diagnostic approaches because the symptoms often appear far from the actual bug location.</p>\n<p><strong>Stale Entity Reference Detection</strong></p>\n<p>Stale entity references represent the most common and dangerous category of ECS memory bugs. These occur when code attempts to access an entity that has been destroyed, but the <code>Entity</code> reference still contains the old ID and generation values. The generation counter mechanism prevents most accesses to recycled entity IDs, but various edge cases can still cause problems.</p>\n<p>The primary diagnostic approach involves implementing comprehensive entity validation at multiple levels. The <code>EntityValidator</code> provides configurable validation strategies that can be enabled during development and disabled for release builds:</p>\n<table>\n<thead>\n<tr>\n<th>Validation Level</th>\n<th>Checks Performed</th>\n<th>Performance Impact</th>\n<th>Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>VALIDATION_NONE</code></td>\n<td>No validation</td>\n<td>Zero overhead</td>\n<td>Release builds</td>\n</tr>\n<tr>\n<td><code>VALIDATION_BASIC</code></td>\n<td>Generation counter only</td>\n<td>Minimal</td>\n<td>Hot paths in debug builds</td>\n</tr>\n<tr>\n<td><code>VALIDATION_STANDARD</code></td>\n<td>Generation + alive status</td>\n<td>Low</td>\n<td>Standard debug builds</td>\n</tr>\n<tr>\n<td><code>VALIDATION_COMPREHENSIVE</code></td>\n<td>All validation + bounds checking</td>\n<td>High</td>\n<td>Deep debugging sessions</td>\n</tr>\n</tbody></table>\n<p>Common stale reference scenarios include entities destroyed during system iteration, entities destroyed by one system and accessed by another in the same frame, and entities destroyed in callback functions triggered by component removal. The validation system catches these by maintaining detailed tracking of entity lifecycle events and cross-referencing access attempts against the current entity state.</p>\n<p><strong>Component Storage Corruption Diagnosis</strong></p>\n<p>Component storage corruption occurs when the sparse set data structures become inconsistent, typically due to incorrect swap-remove operations, invalid index updates, or memory overwrites. These bugs are particularly insidious because they often cause crashes in unrelated code that happens to iterate over the corrupted storage.</p>\n<p>The diagnostic approach involves implementing storage integrity checking that validates the bidirectional mapping between sparse and dense arrays. The integrity checker verifies that every entity ID in the sparse array correctly maps to a valid dense index, every dense index correctly maps back to the sparse array, and the entity count matches the actual number of stored components.</p>\n<p>Storage corruption often manifests through specific symptoms that point to different root causes:</p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnostic Steps</th>\n<th>Fix Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Random crashes during component iteration</td>\n<td>Dense array corruption</td>\n<td>Check dense array bounds and entity count consistency</td>\n<td>Validate swap-remove operations</td>\n</tr>\n<tr>\n<td><code>hasComponent</code> returns true but <code>getComponent</code> crashes</td>\n<td>Sparse array pointing to invalid dense index</td>\n<td>Verify sparse-to-dense mapping integrity</td>\n<td>Fix index updates during component removal</td>\n</tr>\n<tr>\n<td>Components appear to belong to wrong entities</td>\n<td>Entity ID corruption in dense storage</td>\n<td>Compare expected vs actual entity IDs in dense array</td>\n<td>Validate entity ID copying during storage operations</td>\n</tr>\n<tr>\n<td>Memory access violations during component destruction</td>\n<td>Double-free or use-after-free</td>\n<td>Track component destructor calls and memory ownership</td>\n<td>Implement component lifecycle logging</td>\n</tr>\n</tbody></table>\n<p><strong>Iterator Invalidation Detection</strong></p>\n<p>Iterator invalidation occurs when component storage is modified while systems are iterating over it. This is particularly problematic in ECS because systems often need to create or destroy entities based on the components they&#39;re processing. The deferred modification pattern addresses this by collecting changes during iteration and applying them afterward, but incorrect implementation can still cause problems.</p>\n<p>The key diagnostic technique involves tracking iterator lifetimes and detecting storage modifications that occur while iterators are active. This requires maintaining a registry of active iterators and validating that no structural modifications occur to the underlying storage while iteration is in progress.</p>\n<p>Iterator invalidation manifests through several patterns:</p>\n<ol>\n<li><strong>Immediate crashes</strong> when the iterator accesses memory that has been reallocated or moved</li>\n<li><strong>Subtle data corruption</strong> when the iterator continues to work but processes incorrect data</li>\n<li><strong>Infinite loops</strong> when iterator advancement logic becomes confused by structural changes</li>\n<li><strong>Skipped entities</strong> when removal operations shift array contents during iteration</li>\n</ol>\n<p><strong>Resource Leak Detection During Entity Destruction</strong></p>\n<p>Entity destruction in ECS involves coordinating cleanup across multiple component storage systems and ensuring that all references to the entity are properly invalidated. Resource leaks occur when this coordination fails, leaving dangling pointers, unclosed file handles, or unreleased memory allocations.</p>\n<p>The diagnostic approach involves implementing comprehensive destruction logging that tracks every step of the entity cleanup process. This includes logging component destructor calls, entity ID recycling, callback invocations, and reference invalidation. The destruction audit trail allows debugging of incomplete cleanup sequences.</p>\n<p>Common resource leak scenarios include:</p>\n<ul>\n<li><strong>Component destructors not called</strong> when component storage systems fail to properly destruct components during entity removal</li>\n<li><strong>Callback systems holding stale references</strong> when observer pattern implementations don&#39;t receive entity destruction notifications</li>\n<li><strong>System-local caches containing stale data</strong> when systems maintain their own entity collections that aren&#39;t updated during destruction</li>\n<li><strong>Cross-component references</strong> when components contain entity IDs that aren&#39;t properly invalidated during destruction</li>\n</ul>\n<h3 id=\"performance-problem-diagnosis\">Performance Problem Diagnosis</h3>\n<p>Think of ECS performance debugging like optimizing a factory assembly line where the goal is to keep all workers (CPU cores) busy processing parts (entities) that flow smoothly through stations (systems) without bottlenecks. Performance problems occur when parts pile up at certain stations, workers stand idle waiting for materials, or the conveyor belt moves parts in inefficient patterns that waste time.</p>\n<p>Performance issues in ECS typically fall into three categories: cache inefficiency problems that reduce the benefits of data-oriented design, allocation hotspots that cause garbage collection pauses or memory fragmentation, and system execution bottlenecks that prevent parallel processing or create frame rate inconsistencies.</p>\n<p><strong>Cache Miss Analysis and Optimization</strong></p>\n<p>Cache misses represent the most critical performance issue in ECS because the entire architecture is designed around achieving cache locality. When cache efficiency is poor, ECS can actually perform worse than traditional object-oriented approaches due to the additional indirection overhead.</p>\n<p>The <code>CacheMissCounter</code> provides detailed metrics about memory access patterns during system execution:</p>\n<table>\n<thead>\n<tr>\n<th>Metric</th>\n<th>Description</th>\n<th>Target Value</th>\n<th>Optimization Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>L1 Cache Miss Rate</td>\n<td>Percentage of memory accesses that miss L1 cache</td>\n<td>&lt; 5%</td>\n<td>Improve component layout and iteration patterns</td>\n</tr>\n<tr>\n<td>L2 Cache Miss Rate</td>\n<td>Percentage of L1 misses that also miss L2 cache</td>\n<td>&lt; 15%</td>\n<td>Reduce working set size and improve temporal locality</td>\n</tr>\n<tr>\n<td>Memory Bandwidth Utilization</td>\n<td>Percentage of theoretical bandwidth used</td>\n<td>&gt; 60%</td>\n<td>Optimize for sequential access patterns</td>\n</tr>\n<tr>\n<td>Cache Line Utilization</td>\n<td>Average bytes used per cache line loaded</td>\n<td>&gt; 50%</td>\n<td>Pack related data together, avoid padding</td>\n</tr>\n</tbody></table>\n<p>Cache miss diagnosis involves profiling component access patterns during system execution and identifying where the data layout diverges from the access patterns. Common cache efficiency problems include:</p>\n<p><strong>Random access patterns</strong> occur when systems process entities in orders that don&#39;t match the component storage layout. This is particularly problematic with sparse set storage where entity IDs might be processed in arbitrary order, causing the dense component arrays to be accessed randomly rather than sequentially.</p>\n<p><strong>Component size mismatches</strong> happen when components are larger than optimal for their usage patterns, causing unnecessary data to be loaded into cache lines. For example, a <code>Position</code> component that includes rarely-used fields wastes cache bandwidth when systems only need the x and y coordinates.</p>\n<p><strong>Cross-system interference</strong> occurs when multiple systems access different component types for the same entities, but the component storage layouts don&#39;t align. This causes each system to evict the cache lines loaded by previous systems, reducing overall cache efficiency.</p>\n<p><strong>Archetype fragmentation</strong> in advanced ECS implementations can cause entities with identical component combinations to be stored in different archetypes, preventing efficient batch processing and reducing cache locality.</p>\n<p><strong>Allocation Hotspot Detection</strong></p>\n<p>Memory allocation during frame execution causes performance spikes due to heap management overhead and potential garbage collection pauses. ECS systems should ideally perform zero allocations during steady-state execution, but several common patterns can introduce allocation hotspots.</p>\n<p>The allocation profiler tracks memory allocations during system execution and categorizes them by source:</p>\n<table>\n<thead>\n<tr>\n<th>Allocation Source</th>\n<th>Common Causes</th>\n<th>Detection Method</th>\n<th>Mitigation Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Component storage growth</td>\n<td>Adding components to full storage arrays</td>\n<td>Track storage resize operations</td>\n<td>Pre-allocate based on expected entity counts</td>\n</tr>\n<tr>\n<td>Entity creation/destruction</td>\n<td>Dynamic entity management</td>\n<td>Monitor entity lifecycle allocations</td>\n<td>Use entity pools and deferred cleanup</td>\n</tr>\n<tr>\n<td>System temporary data</td>\n<td>Algorithms requiring intermediate storage</td>\n<td>Profile system-specific allocations</td>\n<td>Pre-allocate scratch buffers</td>\n</tr>\n<tr>\n<td>Query result caching</td>\n<td>Systems caching entity lists</td>\n<td>Track query result memory usage</td>\n<td>Use persistent query results with dirty tracking</td>\n</tr>\n</tbody></table>\n<p><strong>System Execution Bottleneck Analysis</strong></p>\n<p>System execution bottlenecks occur when individual systems take disproportionately long to execute, when system dependencies prevent parallel execution, or when systems interfere with each other&#39;s performance characteristics.</p>\n<p>The system profiler provides detailed timing information for each system execution:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>System Performance Report:\nMovementSystem: 2.3ms (45% of frame time)\n  - Entity iteration: 1.8ms\n  - Component updates: 0.4ms\n  - Collision detection: 0.1ms\nCollisionSystem: 1.1ms (22% of frame time)\n  - Spatial partitioning: 0.7ms\n  - Collision resolution: 0.4ms\nRenderSystem: 0.9ms (18% of frame time)\n  - Culling: 0.3ms\n  - Draw call submission: 0.6ms</code></pre></div>\n\n<p>System bottleneck diagnosis involves identifying whether performance problems are due to algorithmic complexity, data access patterns, or system interaction effects. The key metrics include:</p>\n<p><strong>System execution time distribution</strong> shows which systems consume the most frame time and whether the distribution matches expected workload patterns. Systems that consume disproportionate time relative to their entity counts often have algorithmic or cache efficiency problems.</p>\n<p><strong>Component access patterns</strong> reveal whether systems are accessing components in cache-friendly orders and whether multiple systems are interfering with each other&#39;s cache usage. Systems that show high cache miss rates despite processing many entities likely have data layout problems.</p>\n<p><strong>System dependency bottlenecks</strong> occur when systems cannot execute in parallel due to component access conflicts or explicit dependency relationships. The dependency analyzer identifies the critical path through system execution and highlights opportunities for parallel execution.</p>\n<p><strong>Performance Regression Detection</strong></p>\n<p>Performance regressions occur when code changes inadvertently reduce system performance, often in subtle ways that aren&#39;t immediately obvious during development. The regression detection system maintains performance baselines and alerts developers when system performance falls below expected thresholds.</p>\n<p>The regression detector tracks key performance metrics across code changes:</p>\n<table>\n<thead>\n<tr>\n<th>Metric Category</th>\n<th>Baseline Measurement</th>\n<th>Regression Threshold</th>\n<th>Alert Trigger</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Frame time</td>\n<td>95th percentile frame duration</td>\n<td>10% increase</td>\n<td>Automatic test failure</td>\n</tr>\n<tr>\n<td>System timing</td>\n<td>Individual system execution time</td>\n<td>15% increase</td>\n<td>Performance warning</td>\n</tr>\n<tr>\n<td>Cache efficiency</td>\n<td>Cache miss rate per system</td>\n<td>20% increase</td>\n<td>Architecture review required</td>\n</tr>\n<tr>\n<td>Memory usage</td>\n<td>Peak memory consumption</td>\n<td>25% increase</td>\n<td>Memory audit required</td>\n</tr>\n</tbody></table>\n<h3 id=\"system-logic-debugging\">System Logic Debugging</h3>\n<p>Think of system logic debugging like troubleshooting a complex factory where multiple specialized machines (systems) process parts (entities) that move through the facility. Problems arise when machines make incorrect assumptions about part specifications (component state), when the processing order creates dependencies that weren&#39;t anticipated, or when machines interfere with each other&#39;s work in unexpected ways.</p>\n<p>System logic errors in ECS are particularly challenging to debug because the separation of data and logic means that problems often manifest far from their root causes. A system might make a valid assumption about component state that becomes invalid due to the actions of a different system executed earlier in the frame.</p>\n<p><strong>Component State Inconsistency Tracking</strong></p>\n<p>Component state inconsistencies occur when systems make assumptions about component values that don&#39;t hold due to the actions of other systems. These problems are subtle because each individual system operates correctly according to its local logic, but the global system behavior is incorrect.</p>\n<p>The component state tracker monitors component modifications and validates that component values remain within expected ranges and relationships:</p>\n<table>\n<thead>\n<tr>\n<th>Validation Type</th>\n<th>Description</th>\n<th>Example Check</th>\n<th>Debugging Information</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Range validation</td>\n<td>Component values stay within valid ranges</td>\n<td>Health values between 0 and maximum</td>\n<td>Which system set invalid value and when</td>\n</tr>\n<tr>\n<td>Relationship consistency</td>\n<td>Related components maintain valid relationships</td>\n<td>Position and velocity vectors have reasonable magnitudes</td>\n<td>Systems that modified related components</td>\n</tr>\n<tr>\n<td>State machine compliance</td>\n<td>Component state transitions follow valid patterns</td>\n<td>Animation states transition according to state machine</td>\n<td>Invalid transition source and triggering system</td>\n</tr>\n<tr>\n<td>Cross-component invariants</td>\n<td>Multi-component constraints are maintained</td>\n<td>Transform hierarchy maintains parent-child relationships</td>\n<td>Systems that broke invariant and affected entities</td>\n</tr>\n</tbody></table>\n<p>Common state inconsistency patterns include:</p>\n<p><strong>Race conditions between systems</strong> occur when multiple systems modify related components in the same frame without coordination. For example, a physics system might update position based on velocity while a control system simultaneously modifies velocity based on input, leading to inconsistent motion calculations.</p>\n<p><strong>Assumption violations</strong> happen when systems make implicit assumptions about component state that become invalid due to other system actions. A rendering system might assume that entities with <code>Renderable</code> components always have valid <code>Transform</code> components, but an entity management system might remove transforms during destruction, causing render system crashes.</p>\n<p><strong>State machine violations</strong> occur when systems modify component state in ways that violate implicit state machines. An animation system might assume that animation state transitions follow a specific pattern, but a game logic system might directly set animation states, causing invalid transitions.</p>\n<p><strong>System Execution Order Dependencies</strong></p>\n<p>System execution order dependencies are among the most difficult ECS bugs to debug because they involve subtle interactions between systems that might work correctly in isolation but fail when combined. These dependencies often emerge gradually as the codebase grows and new systems are added.</p>\n<p>The dependency tracker analyzes component access patterns to identify potential execution order issues:</p>\n<table>\n<thead>\n<tr>\n<th>Dependency Type</th>\n<th>Description</th>\n<th>Detection Method</th>\n<th>Resolution Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Read-after-write</td>\n<td>System reads component modified by earlier system</td>\n<td>Track component read/write operations</td>\n<td>Ensure writing system executes first</td>\n</tr>\n<tr>\n<td>Write-after-read</td>\n<td>System writes component read by earlier system</td>\n<td>Analyze data flow between systems</td>\n<td>Defer writes or reorder systems</td>\n</tr>\n<tr>\n<td>Write-after-write</td>\n<td>Multiple systems modify same component</td>\n<td>Detect conflicting component writes</td>\n<td>Coordinate writes or establish ownership</td>\n</tr>\n<tr>\n<td>Circular dependencies</td>\n<td>Systems have mutual dependencies</td>\n<td>Build dependency graph and detect cycles</td>\n<td>Break cycles through data flow redesign</td>\n</tr>\n</tbody></table>\n<p><strong>System execution order debugging</strong> involves tracing the flow of component modifications through systems and identifying where assumptions about execution order become critical. The execution tracer logs component access operations and builds a dependency graph showing which systems depend on the results of other systems.</p>\n<p>Example dependency analysis output:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>System Dependency Analysis:\nInputSystem (Priority 100):\n  - Writes: Velocity, PlayerInput\n  - Reads: (none)\n  - Dependencies: (none)\n\nMovementSystem (Priority 200):\n  - Writes: Position, Velocity\n  - Reads: Velocity, PlayerInput\n  - Dependencies: InputSystem (reads Velocity written by InputSystem)\n\nCollisionSystem (Priority 300):\n  - Writes: Position, Velocity, Health\n  - Reads: Position, Velocity, Collider\n  - Dependencies: MovementSystem (reads Position written by MovementSystem)\n\nRenderSystem (Priority 500):\n  - Writes: (none)\n  - Reads: Position, Renderable, Transform\n  - Dependencies: MovementSystem (reads Position), CollisionSystem (reads final Position)</code></pre></div>\n\n<p><strong>Component Modification During Iteration</strong></p>\n<p>Component modification during iteration represents a classic ECS debugging challenge where systems need to modify component storage while iterating over entities. This can cause iterator invalidation, skipped entities, or infinite loops depending on the specific modification patterns.</p>\n<p>The iteration safety checker monitors component storage modifications during system execution and detects potentially unsafe operations:</p>\n<table>\n<thead>\n<tr>\n<th>Unsafe Operation</th>\n<th>Risk Level</th>\n<th>Detection Method</th>\n<th>Safe Alternative</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Add component during iteration</td>\n<td>High</td>\n<td>Track storage modifications during iteration</td>\n<td>Use deferred component addition</td>\n</tr>\n<tr>\n<td>Remove component during iteration</td>\n<td>High</td>\n<td>Detect component removal during iteration</td>\n<td>Use deferred component removal</td>\n</tr>\n<tr>\n<td>Destroy entity during iteration</td>\n<td>Critical</td>\n<td>Monitor entity destruction during iteration</td>\n<td>Use deferred entity destruction</td>\n</tr>\n<tr>\n<td>Modify iterated component</td>\n<td>Low</td>\n<td>Check for component value changes</td>\n<td>Direct modification is usually safe</td>\n</tr>\n</tbody></table>\n<p><strong>Deferred modification pattern debugging</strong> involves ensuring that systems correctly collect modifications during iteration and apply them afterward. Common problems include forgetting to apply deferred modifications, applying them in the wrong order, or incorrectly handling entity references that become invalid during the deferred application phase.</p>\n<p><strong>System Communication and Event Handling</strong></p>\n<p>Systems often need to communicate with each other beyond simple component modifications. Event systems, message queues, and callback mechanisms introduce additional complexity that can create subtle bugs when systems make assumptions about when events will be processed or in what order messages will be received.</p>\n<p>The event system debugger tracks message flow between systems and identifies potential communication issues:</p>\n<table>\n<thead>\n<tr>\n<th>Communication Issue</th>\n<th>Symptoms</th>\n<th>Diagnostic Approach</th>\n<th>Prevention Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Event ordering dependencies</td>\n<td>Systems process events in wrong order</td>\n<td>Log event processing timestamps</td>\n<td>Use priority-based event queues</td>\n</tr>\n<tr>\n<td>Lost events</td>\n<td>Systems don&#39;t receive expected events</td>\n<td>Track event publication and subscription</td>\n<td>Implement event delivery confirmation</td>\n</tr>\n<tr>\n<td>Event storms</td>\n<td>Systems create excessive events</td>\n<td>Monitor event generation rates</td>\n<td>Implement event rate limiting</td>\n</tr>\n<tr>\n<td>Circular event chains</td>\n<td>Events trigger other events indefinitely</td>\n<td>Detect event processing cycles</td>\n<td>Break cycles through event filtering</td>\n</tr>\n</tbody></table>\n<p><strong>System State Validation and Health Monitoring</strong></p>\n<p>Complex ECS applications benefit from comprehensive system health monitoring that can detect when systems enter invalid states or begin exhibiting abnormal behavior patterns. The system health monitor provides early warning of logic errors before they cause visible bugs or crashes.</p>\n<p>The health monitoring system tracks various system health indicators:</p>\n<table>\n<thead>\n<tr>\n<th>Health Indicator</th>\n<th>Normal Range</th>\n<th>Warning Threshold</th>\n<th>Critical Threshold</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Entities processed per frame</td>\n<td>Stable or gradually changing</td>\n<td>50% sudden change</td>\n<td>80% sudden change</td>\n</tr>\n<tr>\n<td>Component modifications per frame</td>\n<td>Proportional to entity count</td>\n<td>2x normal rate</td>\n<td>5x normal rate</td>\n</tr>\n<tr>\n<td>System execution time</td>\n<td>Consistent within 20%</td>\n<td>50% increase</td>\n<td>100% increase</td>\n</tr>\n<tr>\n<td>Memory allocation rate</td>\n<td>Near zero during steady state</td>\n<td>&gt;1MB per frame</td>\n<td>&gt;10MB per frame</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The debugging infrastructure for an ECS requires careful balance between comprehensive error detection and runtime performance. Development builds should include extensive validation and logging systems that can be disabled in release builds to maintain performance.</p>\n<p><strong>A. Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Memory debugging</td>\n<td>Manual validation checks with asserts</td>\n<td>Valgrind/AddressSanitizer integration</td>\n</tr>\n<tr>\n<td>Performance profiling</td>\n<td>Simple timing with high_resolution_clock</td>\n<td>Intel VTune or custom sampling profiler</td>\n</tr>\n<tr>\n<td>Cache analysis</td>\n<td>Manual cache miss counters</td>\n<td>Hardware performance counter integration</td>\n</tr>\n<tr>\n<td>Allocation tracking</td>\n<td>Custom allocation wrapper</td>\n<td>Memory profiler with call stack traces</td>\n</tr>\n<tr>\n<td>System tracing</td>\n<td>Printf-style logging</td>\n<td>Structured logging with trace correlation</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File Structure</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  src/\n    ecs/\n      core/\n        entity_manager.cpp\n        component_storage.cpp\n        system_manager.cpp\n      debugging/\n        entity_validator.cpp          ← entity reference validation\n        cache_profiler.cpp           ← cache miss analysis\n        allocation_tracker.cpp       ← memory allocation monitoring\n        system_debugger.cpp          ← system execution analysis\n        performance_monitor.cpp      ← comprehensive performance tracking\n      debugging/\n        debug_config.h               ← compile-time debug feature toggles\n        debug_macros.h               ← debug assertion and logging macros\n    tests/\n      integration/\n        debugging_integration_test.cpp  ← end-to-end debugging scenarios\n      performance/\n        cache_benchmark.cpp          ← cache efficiency benchmarks\n        allocation_benchmark.cpp     ← allocation performance tests</code></pre></div>\n\n<p><strong>C. Entity Validation Infrastructure</strong></p>\n<p>The entity validation system provides the foundation for detecting stale entity references and ensuring entity lifecycle correctness:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unordered_map></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;chrono></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complete entity validation infrastructure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EntityValidator</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> EntityInfo</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#E1E4E8\"> is_alive;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Generation generation;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">steady_clock</span><span style=\"color:#E1E4E8\">::time_point creation_time;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">steady_clock</span><span style=\"color:#E1E4E8\">::time_point destruction_time;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> access_count;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">EntityID, EntityInfo</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> entity_history_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ValidationLevel current_level_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    EntityValidator</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ValidationLevel</span><span style=\"color:#FFAB70\"> level</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> VALIDATION_STANDARD) </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span><span style=\"color:#B392F0\">current_level_</span><span style=\"color:#E1E4E8\">(level) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> recordEntityCreation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (current_level_ </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> VALIDATION_NONE) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        entity_history_[entity.id] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> EntityInfo{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            .is_alive </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            .generation </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> entity.generation,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            .creation_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">steady_clock</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            .destruction_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            .access_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> recordEntityDestruction</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (current_level_ </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> VALIDATION_NONE) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> it </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> entity_history_.</span><span style=\"color:#B392F0\">find</span><span style=\"color:#E1E4E8\">(entity.id);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (it </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> entity_history_.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            it->second.is_alive </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            it->second.destruction_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">steady_clock</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Validation implementation left for learner</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ValidationResult</span><span style=\"color:#B392F0\"> validateEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> EntityManager</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> manager</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                                  Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">ValidationLevel</span><span style=\"color:#FFAB70\"> level</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> isValidQuick</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> EntityManager</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> manager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">getStaleReferences</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> clearHistory</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Cache miss monitoring infrastructure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CacheMissCounter</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> CacheStats</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> l1_misses </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> l2_misses </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> memory_accesses </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> cache_lines_loaded </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        double</span><span style=\"color:#E1E4E8\"> miss_rate_l1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        double</span><span style=\"color:#E1E4E8\"> miss_rate_l2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CacheStats current_stats_;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> monitoring_active_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> startMonitoring</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Initialize hardware performance counters or sampling</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        monitoring_active_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current_stats_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    CacheStats</span><span style=\"color:#B392F0\"> stopMonitoring</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Read hardware performance counters and calculate rates</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        monitoring_active_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> current_stats_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> recordMemoryAccess</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> address</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> recordCacheLineMiss</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> cache_line_address</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>D. System Debugging Core Logic</strong></p>\n<p>The system debugging infrastructure tracks system execution and detects logic errors:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// System execution tracer for dependency analysis</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SystemExecutionTracer</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> ComponentAccess</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::string system_name;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ComponentTypeID component_type;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        EntityID entity_id;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#E1E4E8\"> is_write;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">steady_clock</span><span style=\"color:#E1E4E8\">::time_point timestamp;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ComponentAccess</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> access_log_;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> tracing_enabled_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> startTracing</span><span style=\"color:#E1E4E8\">() { </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tracing_enabled_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">; </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        access_log_.</span><span style=\"color:#B392F0\">clear</span><span style=\"color:#E1E4E8\">(); </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> stopTracing</span><span style=\"color:#E1E4E8\">() { tracing_enabled_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> recordComponentAccess</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> system_name</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                             ComponentTypeID</span><span style=\"color:#FFAB70\"> type_id</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                             EntityID</span><span style=\"color:#FFAB70\"> entity_id</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                             bool</span><span style=\"color:#FFAB70\"> is_write</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Check if tracing is enabled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Create ComponentAccess record with current timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Add record to access_log_</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: If log gets too large, remove oldest entries</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">analyzeDependencies</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Group access records by system name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: For each system, identify components it reads vs writes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Find systems that read components written by other systems</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Build dependency graph and detect cycles</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Return list of dependency issues as human-readable strings</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> generateDependencyReport</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">ostream</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> output</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Analyze dependencies using analyzeDependencies()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Format results as readable dependency graph</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Highlight potential execution order issues</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Suggest system priority adjustments</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Performance regression detector</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PerformanceMonitor</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> SystemPerformanceData</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::string system_name;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;float></span><span style=\"color:#E1E4E8\"> execution_times;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        float</span><span style=\"color:#E1E4E8\"> baseline_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        float</span><span style=\"color:#E1E4E8\"> current_average </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> sample_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#E1E4E8\"> performance_warning </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string, SystemPerformanceData</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> system_performance_;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> max_samples_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> recordSystemExecution</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> system_name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> execution_time</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Find or create SystemPerformanceData for system</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Add execution_time to execution_times vector</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: If vector exceeds max_samples_, remove oldest entry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Recalculate current_average</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Check if current average exceeds baseline by threshold</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: Set performance_warning flag if regression detected</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> establishBaseline</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> system_name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Calculate average of recent execution times</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Set as baseline_time for the system</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Clear performance_warning flag</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">getPerformanceWarnings</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Iterate through all system performance data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: For systems with performance_warning = true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Calculate regression percentage vs baseline</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Format warning message with specific numbers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Return vector of warning strings</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Debugging Tips</strong></p>\n<p>For C++ ECS debugging:</p>\n<ul>\n<li>Use <code>std::unique_ptr</code> with custom deleters to track component destruction</li>\n<li>Enable AddressSanitizer with <code>-fsanitize=address</code> to catch memory errors</li>\n<li>Use <code>std::chrono::high_resolution_clock</code> for precise system timing</li>\n<li>Implement debug-only validation with <code>#ifdef DEBUG</code> preprocessor guards</li>\n<li>Use <code>static_assert</code> to catch component size issues at compile time</li>\n<li>Enable all compiler warnings with <code>-Wall -Wextra -Werror</code></li>\n</ul>\n<p><strong>F. Milestone Checkpoints</strong></p>\n<p>After implementing entity validation (Milestone 1 checkpoint):</p>\n<ul>\n<li>Run: <code>./debug_tests --entity-validation</code></li>\n<li>Expected: All entity lifecycle tests pass with validation enabled</li>\n<li>Verify: Create 1000 entities, destroy half randomly, attempt access to destroyed entities should fail validation</li>\n<li>Debug signs: If validation doesn&#39;t catch stale references, check generation counter updates during destruction</li>\n</ul>\n<p>After implementing cache profiling (Milestone 2 checkpoint):</p>\n<ul>\n<li>Run: <code>./performance_tests --cache-analysis</code></li>\n<li>Expected: Cache miss rate &lt; 10% for sequential component iteration</li>\n<li>Verify: Profile system that processes 10000 entities with single component type</li>\n<li>Debug signs: High cache miss rates indicate component storage layout problems</li>\n</ul>\n<p>After implementing system dependency analysis (Milestone 3 checkpoint):</p>\n<ul>\n<li>Run: <code>./debug_tests --system-dependencies</code></li>\n<li>Expected: Dependency analysis correctly identifies read-after-write relationships</li>\n<li>Verify: Create systems with intentional dependencies, analysis should detect execution order requirements</li>\n<li>Debug signs: Circular dependencies or missed dependencies indicate incomplete access tracking</li>\n</ul>\n<p><strong>G. Common Debugging Scenarios</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis Steps</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Random crashes during component access</td>\n<td>Stale entity references</td>\n<td>Enable comprehensive entity validation</td>\n<td>Add generation counter checks</td>\n</tr>\n<tr>\n<td>System performance suddenly degrades</td>\n<td>Cache efficiency regression</td>\n<td>Profile cache miss rates before/after</td>\n<td>Restore component layout optimizations</td>\n</tr>\n<tr>\n<td>Components appear to have wrong values</td>\n<td>System execution order issue</td>\n<td>Trace component read/write operations</td>\n<td>Adjust system priorities</td>\n</tr>\n<tr>\n<td>Memory usage grows without bound</td>\n<td>Resource leaks during entity destruction</td>\n<td>Track allocations during entity lifecycle</td>\n<td>Fix component destructor calls</td>\n</tr>\n<tr>\n<td>Systems skip entities during iteration</td>\n<td>Iterator invalidation</td>\n<td>Log storage modifications during iteration</td>\n<td>Use deferred modification pattern</td>\n</tr>\n<tr>\n<td>Event systems create infinite loops</td>\n<td>Circular event dependencies</td>\n<td>Trace event publication and processing</td>\n<td>Add event processing depth limits</td>\n</tr>\n</tbody></table>\n<p>The debugging infrastructure should be designed as a development aid that can be completely disabled in release builds while providing comprehensive error detection during development. The key is to make debugging systematic rather than relying on intuition to find complex interaction bugs in the ECS architecture.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>A. Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Memory debugging</td>\n<td>Manual validation checks with asserts</td>\n<td>Valgrind/AddressSanitizer integration</td>\n</tr>\n<tr>\n<td>Performance profiling</td>\n<td>Simple timing with <code>std::chrono</code></td>\n<td>Hardware performance counter APIs</td>\n</tr>\n<tr>\n<td>Cache analysis</td>\n<td>Manual miss counters</td>\n<td>Intel PCM or platform-specific profilers</td>\n</tr>\n<tr>\n<td>Allocation tracking</td>\n<td>Custom <code>new</code>/<code>delete</code> wrappers</td>\n<td>Heap profiler with call stack traces</td>\n</tr>\n<tr>\n<td>System tracing</td>\n<td>File-based logging with timestamps</td>\n<td>Real-time visualization dashboard</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File Structure</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">project</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">root</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  src</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ecs</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      debugging</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        entity_validator.h           ← Entity reference validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        entity_validator.cpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cache_profiler.h             ← Cache miss analysis  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cache_profiler.cpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        allocation_tracker.h         ← Memory allocation monitoring</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        allocation_tracker.cpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        system_tracer.h              ← System execution analysis</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        system_tracer.cpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        performance_monitor.h        ← Performance regression detection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        performance_monitor.cpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        debug_config.h               ← Compile</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">time debug toggles</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        debug_macros.h               ← Debug assertion macros</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      debugging</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        validation_tests.cpp         ← Entity validation test cases</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        performance_tests.cpp        ← Performance regression tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        integration_debug_tests.cpp  ← End</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">to</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">end debugging scenarios</span></span></code></pre></div>\n\n<p><strong>C. Debug Infrastructure Starter Code</strong></p>\n<p>Complete entity validation system ready for use:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// debug_config.h - Compile-time debug feature configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifdef</span><span style=\"color:#B392F0\"> DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #define</span><span style=\"color:#B392F0\"> ECS_ENABLE_VALIDATION</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #define</span><span style=\"color:#B392F0\"> ECS_ENABLE_PERFORMANCE_MONITORING</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #define</span><span style=\"color:#B392F0\"> ECS_ENABLE_ALLOCATION_TRACKING</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #define</span><span style=\"color:#B392F0\"> ECS_ENABLE_SYSTEM_TRACING</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#else</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #define</span><span style=\"color:#B392F0\"> ECS_ENABLE_VALIDATION</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #define</span><span style=\"color:#B392F0\"> ECS_ENABLE_PERFORMANCE_MONITORING</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #define</span><span style=\"color:#B392F0\"> ECS_ENABLE_ALLOCATION_TRACKING</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #define</span><span style=\"color:#B392F0\"> ECS_ENABLE_SYSTEM_TRACING</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Maximum number of performance samples to keep per system</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ECS_MAX_PERFORMANCE_SAMPLES</span><span style=\"color:#79B8FF\"> 1000</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Maximum number of system trace events to keep</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ECS_MAX_TRACE_EVENTS</span><span style=\"color:#79B8FF\"> 10000</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Performance regression threshold (percentage)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ECS_PERFORMANCE_REGRESSION_THRESHOLD</span><span style=\"color:#79B8FF\"> 25.0</span><span style=\"color:#F97583\">f</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// debug_macros.h - Debug assertion and logging macros</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;iostream></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cassert></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#if</span><span style=\"color:#B392F0\"> ECS_ENABLE_VALIDATION</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #define</span><span style=\"color:#B392F0\"> ECS_VALIDATE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">condition</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        do</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(condition)) { </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                std</span><span style=\"color:#E1E4E8\">::cerr </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"ECS Validation Failed: \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> message </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         &#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \" at \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> __FILE__</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \":\"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> __LINE__</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::endl; </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #define</span><span style=\"color:#B392F0\"> ECS_DEBUG_LOG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"[ECS DEBUG] \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> message </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::endl</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#else</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #define</span><span style=\"color:#B392F0\"> ECS_VALIDATE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">condition</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) ((</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #define</span><span style=\"color:#B392F0\"> ECS_DEBUG_LOG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) ((</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// allocation_tracker.h - Complete memory allocation monitoring</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unordered_map></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;mutex></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;chrono></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> AllocationInfo</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::string file;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> line;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">steady_clock</span><span style=\"color:#E1E4E8\">::time_point timestamp;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AllocationTracker</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;void*</span><span style=\"color:#E1E4E8\">, AllocationInfo</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> active_allocations_;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    mutable</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::mutex mutex_;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> total_allocated_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> peak_allocated_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> allocation_count_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#B392F0\"> AllocationTracker</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> getInstance</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        static</span><span style=\"color:#E1E4E8\"> AllocationTracker instance;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> instance;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> recordAllocation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> file</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::lock_guard</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(mutex_);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        active_allocations_[ptr] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {size, file, line, </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                                   std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">steady_clock</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">()};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        total_allocated_ </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        peak_allocated_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">max</span><span style=\"color:#E1E4E8\">(peak_allocated_, total_allocated_);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        allocation_count_</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> recordDeallocation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::lock_guard</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(mutex_);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> it </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> active_allocations_.</span><span style=\"color:#B392F0\">find</span><span style=\"color:#E1E4E8\">(ptr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (it </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> active_allocations_.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            total_allocated_ </span><span style=\"color:#F97583\">-=</span><span style=\"color:#E1E4E8\"> it->second.size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            active_allocations_.</span><span style=\"color:#B392F0\">erase</span><span style=\"color:#E1E4E8\">(it);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#B392F0\"> getTotalAllocated</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::lock_guard</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(mutex_);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> total_allocated_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#B392F0\"> getPeakAllocated</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::lock_guard</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(mutex_);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> peak_allocated_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">pair</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">AllocationInfo</span><span style=\"color:#E1E4E8\">>> </span><span style=\"color:#B392F0\">getActiveAllocations</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::lock_guard</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(mutex_);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">pair</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">AllocationInfo</span><span style=\"color:#E1E4E8\">>>(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            active_allocations_.</span><span style=\"color:#B392F0\">begin</span><span style=\"color:#E1E4E8\">(), active_allocations_.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> reset</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::lock_guard</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(mutex_);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        active_allocations_.</span><span style=\"color:#B392F0\">clear</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        total_allocated_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        peak_allocated_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        allocation_count_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#if</span><span style=\"color:#B392F0\"> ECS_ENABLE_ALLOCATION_TRACKING</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #define</span><span style=\"color:#B392F0\"> ECS_TRACK_ALLOC</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ptr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">size</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        AllocationTracker</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">getInstance</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">recordAllocation</span><span style=\"color:#E1E4E8\">(ptr, size, </span><span style=\"color:#B392F0\">__FILE__</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">__LINE__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #define</span><span style=\"color:#B392F0\"> ECS_TRACK_FREE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ptr</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        AllocationTracker</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">getInstance</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">recordDeallocation</span><span style=\"color:#E1E4E8\">(ptr)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#else</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #define</span><span style=\"color:#B392F0\"> ECS_TRACK_ALLOC</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ptr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">size</span><span style=\"color:#E1E4E8\">) ((</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #define</span><span style=\"color:#B392F0\"> ECS_TRACK_FREE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ptr</span><span style=\"color:#E1E4E8\">) ((</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span></code></pre></div>\n\n<p><strong>D. Core Debugging Logic Skeleton</strong></p>\n<p>Template code for the main debugging components that learners should implement:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// entity_validator.cpp - Core validation logic for implementation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"entity_validator.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"debug_macros.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ValidationResult</span><span style=\"color:#B392F0\"> EntityValidator</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">validateEntity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> EntityManager</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> manager</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                                               Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                                               ValidationLevel</span><span style=\"color:#FFAB70\"> level</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ValidationResult result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result.entity_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> entity.id;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result.expected_generation </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> entity.generation;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: If level is VALIDATION_NONE, return valid result immediately</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if entity ID is within valid range (not INVALID_ENTITY_ID)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If invalid, set result.valid = false and appropriate error message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For VALIDATION_BASIC and above, verify generation counter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get actual generation from EntityManager and compare with expected</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If mismatch, set result.actual_generation and error message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: For VALIDATION_STANDARD and above, check if entity is alive</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use EntityManager::isAlive() to verify entity status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If not alive, set appropriate error message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: For VALIDATION_COMPREHENSIVE, perform additional checks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Verify entity ID hasn't been recycled inappropriately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Check entity access patterns for suspicious behavior</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Validate entity is not in destruction queue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> EntityValidator</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">isValidQuick</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> EntityManager</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> manager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Fast path validation for hot code paths</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check generation counter only (minimal overhead)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return true if entity appears valid, false otherwise</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This should be optimized for performance over comprehensive checking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// cache_profiler.cpp - Cache performance analysis implementation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"cache_profiler.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> CacheMissCounter</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">startMonitoring</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize performance monitoring state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Reset all counters to zero</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If using hardware performance counters, configure them</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Record start timestamp for rate calculations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Set monitoring_active_ flag to true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">CacheMissCounter</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">CacheStats</span><span style=\"color:#B392F0\"> CacheMissCounter</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">stopMonitoring</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Set monitoring_active_ flag to false</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If using hardware performance counters, read final values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Calculate miss rates (misses / total accesses)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Calculate cache line utilization statistics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return populated CacheStats structure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> CacheMissCounter</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">recordMemoryAccess</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> address</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">monitoring_active_) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Increment total memory access counter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Calculate which cache lines are accessed based on address and size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For each cache line, determine if it's likely a miss</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update cache miss counters accordingly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Track access patterns for locality analysis</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// system_tracer.cpp - System execution dependency analysis</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"system_tracer.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> SystemExecutionTracer</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">recordComponentAccess</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> system_name</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                                                ComponentTypeID</span><span style=\"color:#FFAB70\"> type_id</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                                                EntityID</span><span style=\"color:#FFAB70\"> entity_id</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                                bool</span><span style=\"color:#FFAB70\"> is_write</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">tracing_enabled_) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create ComponentAccess record with all parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set timestamp to current high-resolution time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Add record to access_log_ vector</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If log exceeds maximum size, remove oldest entries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Consider sampling if access rate is very high</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">SystemExecutionTracer</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">analyzeDependencies</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> issues;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Group access records by system name and component type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: For each system, build lists of components read vs written</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Find cases where System A writes Component X and System B reads Component X</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check execution order - if B executes before A, that's a dependency issue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Look for circular dependencies (A->B->C->A)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Format each issue as descriptive string and add to issues vector</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> issues;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// performance_monitor.cpp - Performance regression detection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"performance_monitor.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> PerformanceMonitor</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">recordSystemExecution</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> system_name</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                              float</span><span style=\"color:#FFAB70\"> execution_time</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Find or create SystemPerformanceData entry for system_name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Add execution_time to the execution_times vector</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If vector size exceeds max_samples_, remove oldest entry (front)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Recalculate current_average from all samples in vector</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If baseline exists, check if current_average exceeds threshold</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Set performance_warning flag if regression detected</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> PerformanceMonitor</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">establishBaseline</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> system_name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Find SystemPerformanceData for system_name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Calculate average of current execution_times vector</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Set this average as the baseline_time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Clear performance_warning flag since we're establishing new baseline</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Log baseline establishment for debugging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">PerformanceMonitor</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">getPerformanceWarnings</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> warnings;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Iterate through all entries in system_performance_</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: For each system with performance_warning = true:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3:   Calculate percentage regression vs baseline</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4:   Format warning message with system name and regression amount</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5:   Add formatted message to warnings vector</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> warnings;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Debugging Hints</strong></p>\n<p>For C++ ECS debugging:</p>\n<ul>\n<li>Use <code>gdb</code> with <code>set follow-fork-mode child</code> for multi-process debugging</li>\n<li>Enable core dumps with <code>ulimit -c unlimited</code> for post-mortem analysis  </li>\n<li>Use <code>std::source_location</code> (C++20) or <code>__FILE__/__LINE__</code> macros for error tracking</li>\n<li>Compile with <code>-g -O0</code> for debug builds and <code>-DNDEBUG -O3</code> for release</li>\n<li>Use <code>std::mutex</code> for thread-safe debugging in multi-threaded systems</li>\n<li>Enable sanitizers: <code>-fsanitize=address,undefined,thread</code> during development</li>\n</ul>\n<p><strong>F. Milestone Debugging Checkpoints</strong></p>\n<p><strong>Milestone 1 (Entity Manager) - Entity Validation Testing:</strong></p>\n<ul>\n<li>Run: <code>./ecs_tests --gtest_filter=&quot;*EntityValidation*&quot;</code></li>\n<li>Expected behavior: All entity lifecycle validation tests pass</li>\n<li>Manual verification: Create entities, destroy them, attempt access - should fail validation</li>\n<li>Debug signs: If stale references aren&#39;t caught, check generation counter implementation</li>\n</ul>\n<p><strong>Milestone 2 (Component Storage) - Cache Performance Testing:</strong></p>\n<ul>\n<li>Run: <code>./performance_tests --cache-profiling --entity-count=50000</code></li>\n<li>Expected metrics: Cache miss rate &lt; 15% for sequential iteration</li>\n<li>Manual verification: Profile component iteration vs random access patterns</li>\n<li>Debug signs: High miss rates indicate sparse set implementation issues</li>\n</ul>\n<p><strong>Milestone 3 (System Interface) - Dependency Analysis Testing:</strong></p>\n<ul>\n<li>Run: <code>./ecs_tests --system-dependencies --verbose</code></li>\n<li>Expected output: Correct identification of read-after-write dependencies</li>\n<li>Manual verification: Create systems with known dependencies, verify detection</li>\n<li>Debug signs: Missed dependencies indicate incomplete component access tracking</li>\n</ul>\n<p><strong>Milestone 4 (Archetypes) - Archetype Performance Testing:</strong></p>\n<ul>\n<li>Run: <code>./performance_tests --archetype-efficiency --archetype-count=20</code></li>\n<li>Expected metrics: 90%+ cache hit rate for archetype iteration</li>\n<li>Manual verification: Compare archetype vs non-archetype iteration performance</li>\n<li>Debug signs: Poor archetype performance suggests fragmentation or transition overhead</li>\n</ul>\n<p><strong>G. Debugging Tips Reference</strong></p>\n<table>\n<thead>\n<tr>\n<th>Problem Category</th>\n<th>Symptom</th>\n<th>Diagnostic Command</th>\n<th>Investigation Steps</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Memory corruption</td>\n<td>Segfaults during component access</td>\n<td><code>valgrind --tool=memcheck ./app</code></td>\n<td>Check entity validation, sparse set integrity</td>\n</tr>\n<tr>\n<td>Performance regression</td>\n<td>Frame time increased &gt;20%</td>\n<td><code>./app --enable-profiling</code></td>\n<td>Compare cache miss rates, system execution times</td>\n</tr>\n<tr>\n<td>System logic errors</td>\n<td>Components have unexpected values</td>\n<td><code>./app --trace-systems --verbose</code></td>\n<td>Analyze system dependencies, execution order</td>\n</tr>\n<tr>\n<td>Resource leaks</td>\n<td>Memory usage grows continuously</td>\n<td><code>valgrind --tool=massif ./app</code></td>\n<td>Track entity destruction, component cleanup</td>\n</tr>\n<tr>\n<td>Cache efficiency issues</td>\n<td>Low performance despite good algorithm</td>\n<td><code>perf stat -e cache-misses ./app</code></td>\n<td>Profile memory access patterns, component layout</td>\n</tr>\n</tbody></table>\n<p>The debugging infrastructure should provide clear, actionable information when problems occur, helping developers quickly identify whether issues are in their application logic or in the ECS infrastructure itself. The key is making debugging systematic rather than requiring developers to guess at complex interaction patterns.</p>\n<h2 id=\"future-extensions\">Future Extensions</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All Milestones — potential enhancements to extend the basic ECS implementation with advanced features including multi-threading, component relationships, event systems, and development tooling</p>\n</blockquote>\n<p>After completing the core ECS implementation across all four milestones, numerous opportunities exist to extend the architecture with advanced capabilities. These extensions transform the basic ECS from a functional game engine foundation into a production-ready, high-performance system suitable for complex applications. The extensions fall into three primary categories: performance enhancements through parallelization, advanced ECS features that handle complex entity relationships, and development tooling that improves the development experience.</p>\n<p>Understanding these extensions serves multiple purposes. First, it demonstrates the scalability and flexibility inherent in well-designed ECS architectures. Second, it provides concrete next steps for developers who want to push their implementation beyond the basics. Third, it illustrates real-world considerations that production game engines must address. Each extension builds upon the foundation established in the four core milestones while introducing new challenges and architectural considerations.</p>\n<p>The mental model for these extensions is like <strong>upgrading a factory production line</strong>. The core ECS represents a functional assembly line where workers (systems) process products (entities) at individual stations (component operations). The extensions represent major infrastructure upgrades: installing conveyor belts that can run multiple products simultaneously (multi-threading), adding quality control stations that can react to production events (reactive systems), and implementing management dashboards that monitor the entire operation (development tooling).</p>\n<h3 id=\"multi-threading-extensions\">Multi-Threading Extensions</h3>\n<p>Multi-threading extensions represent the most significant performance enhancement possible for ECS architectures, potentially delivering massive throughput improvements for systems that can execute in parallel. However, multi-threading also introduces substantial complexity in terms of data synchronization, system dependencies, and debugging challenges.</p>\n<h4 id=\"mental-model-parallel-assembly-lines\">Mental Model: Parallel Assembly Lines</h4>\n<p>Think of multi-threading ECS like <strong>converting a single assembly line into multiple parallel production lines</strong>. In the single-threaded version, one worker handles each station sequentially. With multi-threading, multiple workers can operate different stations simultaneously, as long as they don&#39;t interfere with each other&#39;s work. Some stations might require exclusive access to shared resources (like a single quality control checklist), while others can operate completely independently (like parallel packaging stations).</p>\n<p>The key insight is that not all work can be parallelized effectively. Systems that read the same components can often run in parallel, but systems that write to shared components must be carefully coordinated. The challenge becomes scheduling work to maximize parallelism while preventing data races and maintaining correctness.</p>\n<blockquote>\n<p><strong>Decision: Thread-Safe Component Access Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Multiple threads need to access component data simultaneously without corruption, but traditional locks would eliminate performance benefits</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Global ECS lock (simple but eliminates parallelism)</li>\n<li>Per-component-type locks (moderate complexity, decent parallelism)</li>\n<li>Read-write locks with dependency analysis (complex but maximum parallelism)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Read-write locks with compile-time dependency analysis</li>\n<li><strong>Rationale</strong>: Systems declare read/write component dependencies at compile-time, allowing automatic scheduling of compatible systems in parallel while serializing conflicting systems</li>\n<li><strong>Consequences</strong>: Requires dependency declaration overhead but enables near-optimal parallel execution while maintaining safety</li>\n</ul>\n</blockquote>\n<p>The thread-safe component access implementation involves several layers of coordination. At the lowest level, each <code>ComponentStorage</code> instance uses read-write locks to allow multiple readers or single writers. At the system level, each system declares its component dependencies through template parameters or runtime registration. The <code>SystemManager</code> analyzes these dependencies to build a dependency graph, identifying which systems can execute concurrently and which must be serialized.</p>\n<table>\n<thead>\n<tr>\n<th>Component Access Pattern</th>\n<th>Thread Safety Approach</th>\n<th>Performance Impact</th>\n<th>Implementation Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Multiple readers, no writers</td>\n<td>Shared read locks</td>\n<td>Excellent parallelism</td>\n<td>Low - standard read-write locks</td>\n</tr>\n<tr>\n<td>Single writer, no readers</td>\n<td>Exclusive write locks</td>\n<td>Good parallelism</td>\n<td>Low - exclusive access</td>\n</tr>\n<tr>\n<td>Mixed read-write patterns</td>\n<td>Dependency-ordered execution</td>\n<td>Moderate parallelism</td>\n<td>High - requires scheduling</td>\n</tr>\n<tr>\n<td>Cross-system communication</td>\n<td>Message passing queues</td>\n<td>Variable</td>\n<td>High - requires event systems</td>\n</tr>\n</tbody></table>\n<p>The system dependency analysis creates execution phases where compatible systems run in parallel within each phase, but phases execute sequentially. For example, Phase 1 might include input processing and AI decision systems (both read-only), Phase 2 might include movement and collision systems (both write position/velocity), and Phase 3 might include rendering and audio systems (both read-only again).</p>\n<p><strong>Parallel System Execution Implementation</strong></p>\n<p>The parallel execution framework builds upon the existing <code>SystemManager</code> with thread pool management and work stealing capabilities. The enhanced system uses a task-based approach where each system becomes a task that can be distributed across worker threads.</p>\n<table>\n<thead>\n<tr>\n<th>System Execution Component</th>\n<th>Single-Threaded Version</th>\n<th>Multi-Threaded Version</th>\n<th>Additional Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>System Registration</td>\n<td>Direct vector storage</td>\n<td>Thread-safe registry with dependency metadata</td>\n<td>Moderate - atomic operations</td>\n</tr>\n<tr>\n<td>Execution Scheduling</td>\n<td>Simple priority order</td>\n<td>Phase-based parallel batching</td>\n<td>High - dependency resolution</td>\n</tr>\n<tr>\n<td>Component Access</td>\n<td>Direct references</td>\n<td>Lock-guarded access</td>\n<td>High - deadlock prevention</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Immediate propagation</td>\n<td>Cross-thread error collection</td>\n<td>High - thread synchronization</td>\n</tr>\n</tbody></table>\n<p>The execution flow involves several steps: dependency analysis creates execution phases, work stealing distributes systems across threads, barrier synchronization ensures phase completion before proceeding, and error collection aggregates failures across threads. This requires careful management of thread lifecycle, work distribution, and synchronization points.</p>\n<blockquote>\n<p>The critical insight for parallel ECS execution is that cache locality often matters more than thread count. Running 100 systems on 8 cores with poor cache behavior performs worse than running 50 well-designed systems on 4 cores with good data locality.</p>\n</blockquote>\n<p><strong>Thread-Safe Component Storage</strong></p>\n<p>Component storage modifications require careful attention to iterator safety and memory management. The existing sparse set implementation must be enhanced with atomic operations and careful ordering to prevent corruption during concurrent access.</p>\n<table>\n<thead>\n<tr>\n<th>Thread Safety Challenge</th>\n<th>Detection Method</th>\n<th>Prevention Strategy</th>\n<th>Performance Cost</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Iterator invalidation during modification</td>\n<td>Debug mode validation</td>\n<td>Deferred modification queues</td>\n<td>Low - batched updates</td>\n</tr>\n<tr>\n<td>ABA problems in sparse arrays</td>\n<td>Generation counters</td>\n<td>Hazard pointers or epochs</td>\n<td>Moderate - memory overhead</td>\n</tr>\n<tr>\n<td>Memory reallocation races</td>\n<td>Address sanitizer tools</td>\n<td>Pre-allocated growth strategy</td>\n<td>Low - reduced allocations</td>\n</tr>\n<tr>\n<td>Component destruction races</td>\n<td>Valgrind or similar</td>\n<td>Reference counting</td>\n<td>High - atomic operations</td>\n</tr>\n</tbody></table>\n<p>The thread-safe sparse set implementation uses epoch-based memory reclamation to safely handle concurrent modifications. Threads announce their participation in operations through epoch advancement, and memory reclamation is deferred until all threads have progressed past the reclamation epoch. This eliminates the need for expensive per-access atomic operations while maintaining safety.</p>\n<p><strong>Work Stealing and Load Balancing</strong></p>\n<p>Advanced multi-threading implementations incorporate work stealing to handle uneven system execution times. When one thread completes its assigned systems early, it can steal work from threads with remaining tasks, improving overall CPU utilization.</p>\n<p>The work stealing implementation maintains per-thread work queues with systems initially distributed based on estimated execution cost. Threads that complete their work attempt to steal from other threads&#39; queues using lock-free algorithms. This requires careful attention to data locality - stolen work should ideally access components that are already cached on the stealing thread.</p>\n<h4 id=\"common-multi-threading-pitfalls\">Common Multi-Threading Pitfalls</h4>\n<p>⚠️ <strong>Pitfall: Excessive Lock Contention</strong>\nMany developers add locks around every component access, creating bottlenecks that eliminate parallelism benefits. This occurs because individual component accesses are extremely fast (nanoseconds), but lock acquisition overhead can be microseconds. Solution: Use batch operations and lock-free data structures where possible, and design systems to minimize shared data access.</p>\n<p>⚠️ <strong>Pitfall: Cache Line False Sharing</strong>\nWhen multiple threads write to different variables on the same cache line, performance degrades severely due to cache line bouncing between cores. This is especially problematic with component arrays where adjacent entities might be processed by different threads. Solution: Use thread-local processing with periodic synchronization, or ensure thread assignments respect cache line boundaries.</p>\n<p>⚠️ <strong>Pitfall: Dependency Cycle Deadlocks</strong>\nComplex dependency graphs can create circular dependencies that cause deadlocks during parallel execution. This typically manifests as systems waiting indefinitely for each other to release resources. Solution: Implement topological sorting of system dependencies and detect cycles during registration rather than execution.</p>\n<h3 id=\"advanced-ecs-features\">Advanced ECS Features</h3>\n<p>Advanced ECS features extend the basic entity-component-system paradigm with sophisticated capabilities that handle complex game scenarios. These features address limitations of the basic model when dealing with hierarchical relationships, reactive behaviors, and complex entity interactions.</p>\n<h4 id=\"mental-model-smart-factory-with-automation\">Mental Model: Smart Factory with Automation</h4>\n<p>Think of advanced ECS features like <strong>upgrading a basic factory with intelligent automation systems</strong>. The basic factory has workers performing tasks in sequence, but the advanced factory adds conveyor sensors that trigger actions when products pass by (event systems), assembly robots that can reconfigure themselves based on product requirements (reactive systems), and quality control systems that can modify production based on real-time feedback (component relationships).</p>\n<p>These features transform the ECS from a passive data processing system into an active, responsive architecture that can react to changes, maintain relationships, and adapt behavior based on runtime conditions.</p>\n<p><strong>Hierarchical Entity Relationships</strong></p>\n<p>Hierarchical relationships allow entities to form parent-child relationships, enabling complex composite objects like vehicles with wheels, characters with equipment, or UI panels with nested elements. This extends the flat entity model with tree-like structures while maintaining ECS performance characteristics.</p>\n<blockquote>\n<p><strong>Decision: Hierarchy Implementation Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Need parent-child relationships for composite entities while maintaining ECS performance and avoiding deep object hierarchies</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Parent/Child component references (simple but limited queries)</li>\n<li>Dedicated hierarchy manager with tree operations (complex but full-featured)</li>\n<li>Hybrid approach with cached relationship queries (balanced complexity/performance)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Hybrid approach with <code>Hierarchy</code> component and cached tree operations</li>\n<li><strong>Rationale</strong>: Provides full tree operations when needed while maintaining fast iteration for systems that don&#39;t need hierarchy information</li>\n<li><strong>Consequences</strong>: Adds moderate complexity but enables complex composite entities without performance penalties</li>\n</ul>\n</blockquote>\n<p>The hierarchical implementation uses a <code>Hierarchy</code> component that stores parent/child relationships, combined with a <code>HierarchyManager</code> that maintains cached tree structures for efficient traversal operations.</p>\n<table>\n<thead>\n<tr>\n<th>Hierarchy Component</th>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Hierarchy</code></td>\n<td><code>parent</code></td>\n<td><code>Entity</code></td>\n<td>Parent entity reference, <code>INVALID_ENTITY</code> if root</td>\n</tr>\n<tr>\n<td><code>Hierarchy</code></td>\n<td><code>firstChild</code></td>\n<td><code>Entity</code></td>\n<td>First child in linked list, <code>INVALID_ENTITY</code> if leaf</td>\n</tr>\n<tr>\n<td><code>Hierarchy</code></td>\n<td><code>nextSibling</code></td>\n<td><code>Entity</code></td>\n<td>Next sibling in parent&#39;s child list</td>\n</tr>\n<tr>\n<td><code>Hierarchy</code></td>\n<td><code>previousSibling</code></td>\n<td><code>Entity</code></td>\n<td>Previous sibling for efficient removal</td>\n</tr>\n<tr>\n<td><code>Hierarchy</code></td>\n<td><code>childCount</code></td>\n<td><code>uint32_t</code></td>\n<td>Number of direct children for fast iteration</td>\n</tr>\n</tbody></table>\n<p>The <code>HierarchyManager</code> provides tree operations while maintaining performance through careful caching and batch updates.</p>\n<table>\n<thead>\n<tr>\n<th>Hierarchy Operation</th>\n<th>Method Signature</th>\n<th>Time Complexity</th>\n<th>Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Parent Assignment</td>\n<td><code>setParent(Entity, Entity)</code></td>\n<td>O(1)</td>\n<td>Attaching entities to parents</td>\n</tr>\n<tr>\n<td>Child Enumeration</td>\n<td><code>getChildren(Entity) -&gt; vector&lt;Entity&gt;</code></td>\n<td>O(children)</td>\n<td>Iterating child entities</td>\n</tr>\n<tr>\n<td>Ancestor Walking</td>\n<td><code>getAncestors(Entity) -&gt; vector&lt;Entity&gt;</code></td>\n<td>O(depth)</td>\n<td>Bubble-up operations</td>\n</tr>\n<tr>\n<td>Subtree Traversal</td>\n<td><code>traverseSubtree(Entity, callback)</code></td>\n<td>O(subtree)</td>\n<td>Hierarchical updates</td>\n</tr>\n<tr>\n<td>Depth Calculation</td>\n<td><code>getDepth(Entity) -&gt; uint32_t</code></td>\n<td>O(depth)</td>\n<td>Level-based processing</td>\n</tr>\n</tbody></table>\n<p>Hierarchical transformations represent a common use case where child entities inherit or modify their parent&#39;s transformation. The <code>HierarchicalTransformSystem</code> demonstrates how to efficiently process parent-child relationships while maintaining cache-friendly iteration patterns.</p>\n<p>The system processes entities in depth-first order, ensuring parent transformations are computed before child transformations. This requires careful ordering of entity processing and caching of computed world-space transforms to avoid redundant calculations.</p>\n<p><strong>Reactive Systems and Event Handling</strong></p>\n<p>Reactive systems respond to changes in component data rather than executing every frame, enabling event-driven architectures that can improve performance and code organization. These systems activate only when relevant changes occur, reducing unnecessary processing for inactive entities.</p>\n<table>\n<thead>\n<tr>\n<th>Event System Component</th>\n<th>Responsibility</th>\n<th>Performance Impact</th>\n<th>Implementation Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ComponentChangeTracker</code></td>\n<td>Detects component modifications</td>\n<td>Low overhead when inactive</td>\n<td>Moderate - requires instrumentation</td>\n</tr>\n<tr>\n<td><code>EventQueue</code></td>\n<td>Queues and dispatches events</td>\n<td>Batch processing efficiency</td>\n<td>Low - standard queue operations</td>\n</tr>\n<tr>\n<td><code>ReactiveSystem</code></td>\n<td>Responds to specific events</td>\n<td>Eliminates unnecessary updates</td>\n<td>Moderate - event subscription</td>\n</tr>\n<tr>\n<td><code>EventDispatcher</code></td>\n<td>Routes events to interested systems</td>\n<td>Minimizes system activation</td>\n<td>High - subscription management</td>\n</tr>\n</tbody></table>\n<p>The reactive system implementation tracks component changes through instrumentation of component storage operations. When components are added, removed, or modified, the system generates events that are queued for processing by interested reactive systems.</p>\n<p><strong>Component Dependencies and Validation</strong></p>\n<p>Component dependencies allow specification of requirements between component types, ensuring entities maintain valid configurations and enabling automatic component management.</p>\n<table>\n<thead>\n<tr>\n<th>Dependency Type</th>\n<th>Description</th>\n<th>Validation Timing</th>\n<th>Resolution Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Required Dependencies</td>\n<td>ComponentA requires ComponentB to be present</td>\n<td>Component addition/removal</td>\n<td>Automatic addition of missing components</td>\n</tr>\n<tr>\n<td>Exclusive Dependencies</td>\n<td>ComponentA and ComponentB cannot coexist</td>\n<td>Component addition</td>\n<td>Error or automatic removal</td>\n</tr>\n<tr>\n<td>Conditional Dependencies</td>\n<td>ComponentA requires ComponentB only when ComponentC present</td>\n<td>Dynamic evaluation</td>\n<td>Lazy validation and resolution</td>\n</tr>\n<tr>\n<td>Version Dependencies</td>\n<td>ComponentA requires specific version of ComponentB</td>\n<td>Component modification</td>\n<td>Version compatibility checking</td>\n</tr>\n</tbody></table>\n<p>The dependency system integrates with the existing component storage to enforce constraints automatically, reducing runtime errors and improving system reliability.</p>\n<p><strong>Archetype Relationships and Queries</strong></p>\n<p>Advanced archetype systems support complex queries that go beyond simple component presence checks, enabling sophisticated entity selection based on component values, relationships, and computed properties.</p>\n<table>\n<thead>\n<tr>\n<th>Advanced Query Type</th>\n<th>Example</th>\n<th>Implementation Strategy</th>\n<th>Performance Characteristics</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Value-based queries</td>\n<td>Entities with Health &lt; 50</td>\n<td>Indexed component values</td>\n<td>O(matching entities)</td>\n</tr>\n<tr>\n<td>Relationship queries</td>\n<td>Entities within 10 units of player</td>\n<td>Spatial indexing</td>\n<td>O(log n + results)</td>\n</tr>\n<tr>\n<td>Computed property queries</td>\n<td>Entities with velocity magnitude &gt; 5.0</td>\n<td>Cached derived values</td>\n<td>O(entities) with caching</td>\n</tr>\n<tr>\n<td>Cross-archetype queries</td>\n<td>Parent-child pairs with different components</td>\n<td>Join operations</td>\n<td>O(parents * children)</td>\n</tr>\n</tbody></table>\n<p>These advanced queries require sophisticated indexing and caching strategies to maintain performance while providing expressive query capabilities.</p>\n<h4 id=\"common-advanced-feature-pitfalls\">Common Advanced Feature Pitfalls</h4>\n<p>⚠️ <strong>Pitfall: Hierarchy Update Ordering</strong>\nProcessing hierarchical entities in the wrong order can cause visual artifacts or incorrect behavior when child entities depend on updated parent values. This commonly occurs with transform hierarchies where children appear to lag behind parent movement. Solution: Process entities in depth-first order or use double-buffering to separate read and write phases.</p>\n<p>⚠️ <strong>Pitfall: Event System Memory Leaks</strong>\nEvent systems that don&#39;t properly unsubscribe listeners or clean up event queues can cause memory leaks and performance degradation over time. This is particularly problematic with temporary entities or systems that are created and destroyed dynamically. Solution: Implement automatic subscription cleanup and bounded event queues with configurable retention policies.</p>\n<p>⚠️ <strong>Pitfall: Over-Engineering Component Dependencies</strong>\nComplex dependency systems can become harder to understand and debug than the problems they solve, especially when dependencies create unexpected cascading effects. Solution: Start with simple required/forbidden relationships and add complexity only when specifically needed for your use case.</p>\n<h3 id=\"development-tooling\">Development Tooling</h3>\n<p>Development tooling transforms the ECS from a functional but opaque system into a transparent, debuggable, and optimizable architecture. Professional game development requires sophisticated tools for understanding system behavior, diagnosing performance issues, and visualizing entity relationships.</p>\n<h4 id=\"mental-model-factory-control-room\">Mental Model: Factory Control Room</h4>\n<p>Think of development tooling like <strong>building a comprehensive control room for a complex factory</strong>. The factory (ECS) can operate without the control room, but the control room provides essential capabilities: monitoring dashboards show real-time performance metrics, diagnostic tools help identify bottlenecks and failures, and control interfaces allow operators to adjust parameters and investigate issues without stopping production.</p>\n<p>The tooling infrastructure must be designed for minimal runtime impact when not in use, while providing deep introspection capabilities when debugging is required. This requires careful instrumentation that can be enabled or disabled based on build configuration and runtime flags.</p>\n<p><strong>Debug Visualizers and Inspectors</strong></p>\n<p>Debug visualizers provide real-time views of ECS state, allowing developers to understand entity composition, system execution, and data flow patterns. These tools are essential for debugging complex interactions and performance optimization.</p>\n<table>\n<thead>\n<tr>\n<th>Visualization Tool</th>\n<th>Information Displayed</th>\n<th>Use Cases</th>\n<th>Implementation Requirements</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Entity Inspector</td>\n<td>Component values, relationships, lifecycle</td>\n<td>Debugging entity behavior</td>\n<td>Runtime reflection system</td>\n</tr>\n<tr>\n<td>System Performance Monitor</td>\n<td>Execution times, call counts, dependencies</td>\n<td>Performance optimization</td>\n<td>High-resolution timing</td>\n</tr>\n<tr>\n<td>Component Memory Visualizer</td>\n<td>Memory layout, cache patterns, fragmentation</td>\n<td>Memory optimization</td>\n<td>Memory introspection</td>\n</tr>\n<tr>\n<td>Archetype Browser</td>\n<td>Archetype composition, entity counts, transitions</td>\n<td>Understanding data organization</td>\n<td>Archetype metadata access</td>\n</tr>\n</tbody></table>\n<p>The entity inspector provides a hierarchical view of entities with expandable component details, similar to object inspectors in modern IDEs. This requires a runtime reflection system that can enumerate component types and provide human-readable representations of component values.</p>\n<p><strong>Performance Profilers and Analytics</strong></p>\n<p>Performance profiling tools provide detailed insights into ECS behavior, enabling optimization of bottlenecks and validation of performance assumptions. These tools must have minimal impact on release builds while providing comprehensive data in development builds.</p>\n<table>\n<thead>\n<tr>\n<th>Profiling Component</th>\n<th>Metrics Collected</th>\n<th>Analysis Capabilities</th>\n<th>Implementation Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>SystemProfiler</code></td>\n<td>Execution time, call frequency, cache misses</td>\n<td>System bottleneck identification</td>\n<td>Instrumented system wrappers</td>\n</tr>\n<tr>\n<td><code>ComponentAccessProfiler</code></td>\n<td>Access patterns, locality, contention</td>\n<td>Data layout optimization</td>\n<td>Memory access tracking</td>\n</tr>\n<tr>\n<td><code>AllocationProfiler</code></td>\n<td>Allocation frequency, sizes, lifetimes</td>\n<td>Memory usage optimization</td>\n<td>Custom allocator hooks</td>\n</tr>\n<tr>\n<td><code>ArchetypeProfiler</code></td>\n<td>Transition frequency, storage efficiency</td>\n<td>Archetype design validation</td>\n<td>Archetype operation logging</td>\n</tr>\n</tbody></table>\n<p>The profiling infrastructure uses a sampling-based approach to minimize overhead while collecting representative data. Profiling can be enabled per-system or globally, allowing focused analysis of specific performance concerns.</p>\n<p><strong>Memory Analysis and Debugging</strong></p>\n<p>Memory analysis tools help identify leaks, corruption, and inefficient usage patterns in ECS implementations. These tools are crucial for maintaining reliability in long-running applications like games.</p>\n<table>\n<thead>\n<tr>\n<th>Memory Analysis Tool</th>\n<th>Detection Capability</th>\n<th>Implementation Approach</th>\n<th>Performance Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Entity Leak Detector</td>\n<td>Entities never destroyed</td>\n<td>Reference tracking</td>\n<td>Low - debug builds only</td>\n</tr>\n<tr>\n<td>Component Corruption Scanner</td>\n<td>Invalid component values</td>\n<td>Checksum validation</td>\n<td>High - enabled selectively</td>\n</tr>\n<tr>\n<td>Memory Layout Analyzer</td>\n<td>Cache inefficient patterns</td>\n<td>Address space analysis</td>\n<td>Moderate - sampling based</td>\n</tr>\n<tr>\n<td>Allocation Tracker</td>\n<td>Memory usage patterns</td>\n<td>Custom allocator instrumentation</td>\n<td>Low - statistical sampling</td>\n</tr>\n</tbody></table>\n<p>The memory analysis implementation uses compiler-specific debugging features and custom allocators to provide detailed information about memory usage patterns and potential issues.</p>\n<p><strong>Interactive Debugging and Manipulation</strong></p>\n<p>Interactive debugging tools allow runtime modification of ECS state for testing scenarios and investigating bugs. These capabilities are essential for rapid iteration and problem diagnosis.</p>\n<table>\n<thead>\n<tr>\n<th>Interactive Tool</th>\n<th>Capabilities</th>\n<th>Safety Considerations</th>\n<th>Implementation Requirements</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Runtime Entity Editor</td>\n<td>Create, modify, destroy entities</td>\n<td>Must maintain system consistency</td>\n<td>Transaction-based modifications</td>\n</tr>\n<tr>\n<td>Component Value Editor</td>\n<td>Modify component values in real-time</td>\n<td>Type safety and validation</td>\n<td>Runtime type information</td>\n</tr>\n<tr>\n<td>System Control Panel</td>\n<td>Enable, disable, reorder systems</td>\n<td>Dependency validation</td>\n<td>Dynamic system management</td>\n</tr>\n<tr>\n<td>Query Inspector</td>\n<td>Test and optimize component queries</td>\n<td>Performance impact awareness</td>\n<td>Query compilation and analysis</td>\n</tr>\n</tbody></table>\n<p>The interactive debugging system uses a command-based interface where modifications are validated before application, ensuring that debugging operations don&#39;t corrupt the ECS state or introduce inconsistencies.</p>\n<p><strong>Editor Integration and Asset Pipeline</strong></p>\n<p>Editor integration connects ECS development with content creation workflows, allowing designers and artists to work with entities and components through visual interfaces.</p>\n<table>\n<thead>\n<tr>\n<th>Editor Integration Feature</th>\n<th>Benefit</th>\n<th>Technical Requirements</th>\n<th>Development Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Visual Entity Composition</td>\n<td>Designer-friendly entity creation</td>\n<td>Serialization system</td>\n<td>High - requires UI framework</td>\n</tr>\n<tr>\n<td>Component Property Editors</td>\n<td>Type-appropriate value editing</td>\n<td>Runtime type metadata</td>\n<td>Moderate - standard property grids</td>\n</tr>\n<tr>\n<td>System Execution Visualization</td>\n<td>Understanding system interactions</td>\n<td>Real-time data collection</td>\n<td>High - requires visualization framework</td>\n</tr>\n<tr>\n<td>Performance Dashboard</td>\n<td>Non-programmer performance monitoring</td>\n<td>Aggregated metrics display</td>\n<td>Moderate - data visualization</td>\n</tr>\n</tbody></table>\n<p>Editor integration typically requires serialization systems that can convert ECS state to and from persistent formats, enabling asset pipeline integration and save/load functionality.</p>\n<h4 id=\"common-development-tooling-pitfalls\">Common Development Tooling Pitfalls</h4>\n<p>⚠️ <strong>Pitfall: Performance Impact in Release Builds</strong>\nDebug instrumentation that significantly impacts release build performance defeats the purpose of optimization efforts. This commonly occurs when debug code paths are not properly excluded or when profiling overhead is too high. Solution: Use preprocessor macros and template specialization to completely eliminate debug code in release builds, and implement sampling-based profiling with configurable overhead levels.</p>\n<p>⚠️ <strong>Pitfall: Tool-Induced State Corruption</strong>\nInteractive debugging tools that don&#39;t properly validate modifications can corrupt ECS state, making debugging more difficult rather than easier. This is particularly problematic when modifying entities during system execution or violating component dependencies. Solution: Implement all interactive modifications through the same validation and safety mechanisms used by regular game code.</p>\n<p>⚠️ <strong>Pitfall: Information Overload in Debug Displays</strong>\nComprehensive debug information can become overwhelming and counterproductive when too much data is displayed simultaneously. This makes it difficult to focus on relevant information during debugging sessions. Solution: Implement filtering, grouping, and drill-down capabilities that allow developers to focus on specific aspects of system behavior while maintaining access to comprehensive data when needed.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The implementation of ECS extensions requires careful consideration of complexity trade-offs and development priorities. These extensions significantly increase system complexity while providing substantial benefits for advanced use cases.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Extension Category</th>\n<th>Simple Approach</th>\n<th>Production Approach</th>\n<th>Recommended Starting Point</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Multi-threading</td>\n<td><code>std::thread</code> with manual synchronization</td>\n<td>Thread pool with work stealing</td>\n<td>Simple approach with read-write locks</td>\n</tr>\n<tr>\n<td>Event Systems</td>\n<td>Direct function callbacks</td>\n<td>Message queue with batching</td>\n<td>Direct callbacks for initial implementation</td>\n</tr>\n<tr>\n<td>Debug Visualization</td>\n<td>Console output with formatting</td>\n<td>ImGui or similar immediate mode GUI</td>\n<td>Console output for core functionality</td>\n</tr>\n<tr>\n<td>Performance Profiling</td>\n<td><code>std::chrono</code> timing</td>\n<td>Platform-specific high-resolution counters</td>\n<td><code>std::chrono</code> with statistical sampling</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<p>The extended ECS implementation requires careful organization to manage increased complexity while maintaining clarity and modularity.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">project</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">root</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── include</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">ecs</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── core</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                    // Core ECS implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── entity_manager.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── component_storage.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   └── system_interface.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── extensions</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">              // Extension features</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── threading</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   │   ├── thread_safe_storage.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   │   ├── parallel_system_manager.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   │   └── work_stealing_scheduler.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── advanced</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   │   ├── hierarchy_manager.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   │   ├── reactive_systems.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   │   └── component_dependencies.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   └── tooling</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │       ├── debug_visualizer.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │       ├── performance_profiler.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │       └── memory_analyzer.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── utils</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                   // Supporting utilities</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│       ├── thread_pool.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│       ├── lock_free_queue.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│       └── reflection_system.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── src</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">ecs</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── core</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                    // Core implementation files</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── extensions</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">              // Extension implementation files</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── utils</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                   // Utility implementations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── examples</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── basic_ecs</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">              // Core ECS examples</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── multi_threaded</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">         // Threading examples</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── hierarchical</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">           // Hierarchy examples</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── debug_tools</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">            // Tooling examples</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">└── tests</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ├── core</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                    // Core ECS tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ├── extensions</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">              // Extension tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    └── integration</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">             // Full system tests</span></span></code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Thread-Safe Component Storage Foundation</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;shared_mutex></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;atomic></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;memory></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Thread-safe wrapper for component storage with read-write semantics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ThreadSafeComponentStorage</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    mutable</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::shared_mutex mutex_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ComponentStorage</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">T</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> storage_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::atomic</span><span style=\"color:#F97583\">&#x3C;uint64_t></span><span style=\"color:#E1E4E8\"> modification_count_{</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read operations allow multiple concurrent readers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> Func</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    auto</span><span style=\"color:#B392F0\"> withReadLock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Func</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#FFAB70\"> func</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> -></span><span style=\"color:#F97583\"> decltype</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">func</span><span style=\"color:#E1E4E8\">(storage_)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::shared_lock</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::shared_mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(mutex_);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> func</span><span style=\"color:#E1E4E8\">(storage_);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write operations require exclusive access</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> Func</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    auto</span><span style=\"color:#B392F0\"> withWriteLock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Func</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#FFAB70\"> func</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#B392F0\">decltype</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">func</span><span style=\"color:#E1E4E8\">(storage_)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::unique_lock</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::shared_mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(mutex_);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> func</span><span style=\"color:#E1E4E8\">(storage_);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        modification_count_.</span><span style=\"color:#B392F0\">fetch_add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::memory_order_relaxed);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if storage has been modified since last check</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> hasBeenModified</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint64_t&#x26;</span><span style=\"color:#FFAB70\"> lastSeen</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint64_t</span><span style=\"color:#E1E4E8\"> current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> modification_count_.</span><span style=\"color:#B392F0\">load</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::memory_order_relaxed);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (current </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> lastSeen) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            lastSeen </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Simple thread pool for parallel system execution</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ThreadPool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::thread</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> workers_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::queue</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::function</span><span style=\"color:#F97583\">&#x3C;void</span><span style=\"color:#E1E4E8\">()</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> tasks_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::mutex queue_mutex_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::condition_variable condition_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::atomic</span><span style=\"color:#F97583\">&#x3C;bool></span><span style=\"color:#E1E4E8\"> stop_{</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    explicit</span><span style=\"color:#B392F0\"> ThreadPool</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> threads</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> threads; </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">i) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            workers_.</span><span style=\"color:#B392F0\">emplace_back</span><span style=\"color:#E1E4E8\">([</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">] {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">stop_.</span><span style=\"color:#B392F0\">load</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    std</span><span style=\"color:#E1E4E8\">::function</span><span style=\"color:#F97583\">&#x3C;void</span><span style=\"color:#E1E4E8\">()</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> task;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                        std</span><span style=\"color:#E1E4E8\">::unique_lock</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(queue_mutex_);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        condition_.</span><span style=\"color:#B392F0\">wait</span><span style=\"color:#E1E4E8\">(lock, [</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">] { </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                            return</span><span style=\"color:#E1E4E8\"> stop_.</span><span style=\"color:#B392F0\">load</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">||</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">tasks_.</span><span style=\"color:#B392F0\">empty</span><span style=\"color:#E1E4E8\">(); </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        if</span><span style=\"color:#E1E4E8\"> (stop_.</span><span style=\"color:#B392F0\">load</span><span style=\"color:#E1E4E8\">()) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        task </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">move</span><span style=\"color:#E1E4E8\">(tasks_.</span><span style=\"color:#B392F0\">front</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        tasks_.</span><span style=\"color:#B392F0\">pop</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    task</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> Func</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> enqueue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Func</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#FFAB70\"> func</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            std</span><span style=\"color:#E1E4E8\">::unique_lock</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(queue_mutex_);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            tasks_.</span><span style=\"color:#B392F0\">emplace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">forward</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Func</span><span style=\"color:#E1E4E8\">>(func));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        condition_.</span><span style=\"color:#B392F0\">notify_one</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ~ThreadPool</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stop_.</span><span style=\"color:#B392F0\">store</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        condition_.</span><span style=\"color:#B392F0\">notify_all</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">auto&#x26;</span><span style=\"color:#E1E4E8\"> worker : workers_) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            worker.</span><span style=\"color:#B392F0\">join</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Event System Foundation</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;functional></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unordered_map></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;typeindex></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Basic event system for reactive ECS behavior</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EventSystem</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Event base class for type erasure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> Event</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        virtual</span><span style=\"color:#B392F0\"> ~Event</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> default</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Component change event</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> ComponentAdded</span><span style=\"color:#E1E4E8\"> : Event {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Entity entity;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ComponentTypeID componentType;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ComponentAdded</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> e</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">ComponentTypeID</span><span style=\"color:#FFAB70\"> type</span><span style=\"color:#E1E4E8\">) </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            : </span><span style=\"color:#B392F0\">entity</span><span style=\"color:#E1E4E8\">(e), </span><span style=\"color:#B392F0\">componentType</span><span style=\"color:#E1E4E8\">(type) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> ComponentRemoved</span><span style=\"color:#E1E4E8\"> : Event {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Entity entity;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ComponentTypeID componentType;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ComponentRemoved</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> e</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">ComponentTypeID</span><span style=\"color:#FFAB70\"> type</span><span style=\"color:#E1E4E8\">) </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            : </span><span style=\"color:#B392F0\">entity</span><span style=\"color:#E1E4E8\">(e), </span><span style=\"color:#B392F0\">componentType</span><span style=\"color:#E1E4E8\">(type) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Event subscription mechanism</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    using</span><span style=\"color:#B392F0\"> EventHandler</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">function</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Event</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">)>;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> EventType</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> subscribe</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EventHandler</span><span style=\"color:#FFAB70\"> handler</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        subscribers_[</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">type_index</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">typeid</span><span style=\"color:#E1E4E8\">(EventType))].</span><span style=\"color:#B392F0\">push_back</span><span style=\"color:#E1E4E8\">(handler);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> EventType</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> publish</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> EventType</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> event</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> it </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> subscribers_.</span><span style=\"color:#B392F0\">find</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">type_index</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">typeid</span><span style=\"color:#E1E4E8\">(EventType)));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (it </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> subscribers_.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> auto&#x26;</span><span style=\"color:#E1E4E8\"> handler : it->second) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                handler</span><span style=\"color:#E1E4E8\">(event);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> processQueuedEvents</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">auto&#x26;</span><span style=\"color:#E1E4E8\"> event : event_queue_) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Process event through type-erased dispatch</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            event</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        event_queue_.</span><span style=\"color:#B392F0\">clear</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::type_index, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">EventHandler</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> subscribers_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::function</span><span style=\"color:#F97583\">&#x3C;void</span><span style=\"color:#E1E4E8\">()</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> event_queue_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton\">Core Logic Skeleton</h4>\n<p><strong>Parallel System Manager Implementation</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ParallelSystemManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> SystemInfo</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">System</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> system;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::set</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ComponentTypeID</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> readComponents;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::set</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ComponentTypeID</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> writeComponents;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> priority;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#E1E4E8\"> enabled;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">SystemInfo</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> systems_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ThreadPool thread_pool_;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> systems_sorted_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    explicit</span><span style=\"color:#B392F0\"> ParallelSystemManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> thread_count</span><span style=\"color:#E1E4E8\">) </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span><span style=\"color:#B392F0\">thread_pool_</span><span style=\"color:#E1E4E8\">(thread_count) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    T</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> registerSystem</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> priority</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Create system instance with perfect forwarding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Analyze system's component dependencies using reflection or explicit declaration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Store system with dependency metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Mark systems as needing re-sort for dependency analysis</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use template traits or explicit dependency declaration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> updateAllSystems</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Sort systems by priority if needed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Group systems into execution phases based on component dependencies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Execute each phase in parallel using thread pool</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Wait for phase completion before starting next phase</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Collect and handle any errors from parallel execution</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Systems that read the same components can run in parallel</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Systems that write to the same components must be serialized</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">>> </span><span style=\"color:#B392F0\">analyzeSystemDependencies</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Create dependency graph from system component access patterns</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Identify systems with conflicting write dependencies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Group compatible systems into execution phases</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Return vector of phases, each containing system indices</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Two systems conflict if one writes to components the other reads/writes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> executePhase</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> systemIndices</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                     World</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Create tasks for each system in the phase</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Submit tasks to thread pool for parallel execution</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Wait for all tasks to complete using synchronization</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Collect any exceptions or errors from parallel execution</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use std::future or barrier synchronization</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Hierarchy Manager Implementation</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> HierarchyManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    World</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> world_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">, EntityHash</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> cached_children_;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> cache_dirty_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    explicit</span><span style=\"color:#B392F0\"> HierarchyManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">) : </span><span style=\"color:#B392F0\">world_</span><span style=\"color:#E1E4E8\">(world) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> setParent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> child</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> parent</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Validate that child and parent are different entities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Check for circular references (child becoming ancestor of current parent)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Remove child from current parent's child list if it has one</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Add child to new parent's child list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Update child's Hierarchy component with new parent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: Mark hierarchy cache as dirty for rebuilding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use getAncestors to detect circular references</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">getChildren</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> parent</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Check if cached children data is valid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: If cache is dirty, rebuild children cache from Hierarchy components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Return cached children vector for parent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Return empty vector if parent has no children</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Cache all parent-child relationships for performance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">getAncestors</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Start with given entity and empty ancestors list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Follow parent references up the hierarchy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Add each parent to ancestors list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Stop when reaching root entity (parent == INVALID_ENTITY)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Return ancestors list in root-to-parent order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Detect infinite loops by limiting maximum depth</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> traverseSubtree</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> root</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">function</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)> </span><span style=\"color:#FFAB70\">callback</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Call callback for root entity with depth 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Get all children of current entity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Recursively traverse each child with incremented depth</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Use depth-first traversal order for predictable processing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Consider iterative implementation to avoid stack overflow</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> rebuildChildrenCache</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Clear existing cached children data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Iterate through all entities with Hierarchy components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: For each entity, add it to its parent's children list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Mark cache as clean after rebuilding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use component query to find all hierarchical entities</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> wouldCreateCycle</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> child</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> newParent</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Get all ancestors of newParent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Check if child appears in ancestor list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Return true if cycle would be created</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: If child is an ancestor of newParent, making newParent the parent creates a cycle</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>Multi-Threading Extension Checkpoint</strong>\nAfter implementing basic multi-threading support:</p>\n<ul>\n<li>Run <code>cd build &amp;&amp; make test_parallel_systems &amp;&amp; ./test_parallel_systems</code></li>\n<li>Expected output: Systems execute in parallel phases with proper synchronization</li>\n<li>Manually verify: Create systems with conflicting dependencies, ensure they execute serially</li>\n<li>Performance test: Measure speedup with multiple threads vs single-threaded execution</li>\n<li>Signs of problems: Data races, deadlocks, or performance regression indicate synchronization issues</li>\n</ul>\n<p><strong>Advanced Features Checkpoint</strong>\nAfter implementing hierarchy and event systems:</p>\n<ul>\n<li>Run <code>cd build &amp;&amp; make test_hierarchy &amp;&amp; ./test_hierarchy</code></li>\n<li>Expected behavior: Parent-child relationships maintained correctly, events fired on component changes</li>\n<li>Manually verify: Create hierarchical entities, modify components, observe event system responses</li>\n<li>Test edge cases: Circular references prevented, deep hierarchies handled efficiently</li>\n<li>Signs of problems: Stack overflow, infinite loops, or missing event notifications</li>\n</ul>\n<p><strong>Development Tooling Checkpoint</strong>\nAfter implementing debug visualization:</p>\n<ul>\n<li>Run <code>cd build &amp;&amp; make debug_example &amp;&amp; ./debug_example</code></li>\n<li>Expected output: Real-time display of entity states, system performance metrics, memory usage</li>\n<li>Interactive test: Modify entity components through debug interface, verify changes reflect in game</li>\n<li>Performance check: Ensure debug tools have minimal impact when disabled</li>\n<li>Signs of problems: Significant performance impact, crashes when debugging, or inaccurate information display</li>\n</ul>\n<p>The extensions transform the basic ECS into a production-ready architecture capable of handling complex game development scenarios. Each extension adds significant value while introducing complexity that must be carefully managed through good architectural practices and comprehensive testing.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations-table\">Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Extension Category</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Multi-threading</td>\n<td><code>std::thread</code> with manual locks</td>\n<td>Custom work-stealing scheduler with lock-free queues</td>\n</tr>\n<tr>\n<td>Event Systems</td>\n<td>Direct callback registration</td>\n<td>Message queue with priority scheduling and batching</td>\n</tr>\n<tr>\n<td>Hierarchy Management</td>\n<td>Parent/child component references</td>\n<td>Dedicated tree structure with cached operations</td>\n</tr>\n<tr>\n<td>Debug Visualization</td>\n<td>Console logging with structured output</td>\n<td>ImGui integration with real-time entity inspection</td>\n</tr>\n<tr>\n<td>Performance Profiling</td>\n<td><code>std::chrono::high_resolution_clock</code> timing</td>\n<td>Platform-specific performance counters with sampling</td>\n</tr>\n<tr>\n<td>Memory Analysis</td>\n<td>Custom allocator with tracking</td>\n<td>Integration with Valgrind, AddressSanitizer, or similar tools</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">project</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">root</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── include</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">ecs</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── core</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                           // Core ECS (Milestones 1-4)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── entity_manager.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── component_storage.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── system_interface.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   └── archetype_storage.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── threading</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                      // Multi-threading extensions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── thread_safe_storage.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── parallel_system_manager.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── work_stealing_scheduler.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   └── lock_free_primitives.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── advanced</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                       // Advanced ECS features</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── hierarchy_manager.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── reactive_systems.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── event_dispatcher.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── component_dependencies.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   └── advanced_queries.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── tooling</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                        // Development tools</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── debug_visualizer.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── performance_profiler.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── memory_analyzer.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── entity_inspector.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   └── system_tracer.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── utils</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                          // Supporting utilities</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│       ├── thread_pool.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│       ├── reflection_system.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│       ├── command_buffer.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│       └── circular_buffer.hpp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── src</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">ecs</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                           // Implementation files</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── core</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                          // Core implementations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── threading</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                     // Threading implementations  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── advanced</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                      // Advanced feature implementations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── tooling</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                       // Tool implementations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── utils</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                         // Utility implementations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── examples</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">_basic_ecs/</span><span style=\"color:#6A737D\">                  // Core ECS examples</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\">_multithreaded/</span><span style=\"color:#6A737D\">              // Threading examples</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#F97583\">_hierarchical/</span><span style=\"color:#6A737D\">               // Hierarchy examples</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#F97583\">_reactive/</span><span style=\"color:#6A737D\">                   // Event system examples</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#F97583\">_debug_tools/</span><span style=\"color:#6A737D\">                // Debug tooling examples</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── tools</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                             // Standalone development tools</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── ecs_profiler</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                  // Performance analysis tool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── entity_editor</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                 // Visual entity editing tool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── memory_visualizer</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">             // Memory layout analysis tool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">└── tests</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ├── unit</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                          // Individual component tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ├── integration</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                   // Cross-component tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ├── performance</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                   // Benchmark and regression tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    └── stress</span><span style=\"color:#F97583\">/</span><span style=\"color:#6A737D\">                        // Load and stability tests</span></span></code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Thread Pool with Work Stealing</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;thread></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;queue></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;mutex></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;condition_variable></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;atomic></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;functional></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;future></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> WorkStealingThreadPool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#79B8FF\"> alignas(64)</span><span style=\"color:#B392F0\"> WorkerQueue</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#6A737D\">  // Cache line aligned</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::queue</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::function</span><span style=\"color:#F97583\">&#x3C;void</span><span style=\"color:#E1E4E8\">()</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> tasks;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        mutable</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::mutex mutex;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::condition_variable condition;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">WorkerQueue</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> worker_queues_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::thread</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> workers_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::atomic</span><span style=\"color:#F97583\">&#x3C;bool></span><span style=\"color:#E1E4E8\"> stop_requested_{</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::atomic</span><span style=\"color:#F97583\">&#x3C;size_t></span><span style=\"color:#E1E4E8\"> active_workers_{</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> workerLoop</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> worker_id</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto&#x26;</span><span style=\"color:#E1E4E8\"> local_queue </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">worker_queues_[worker_id];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">stop_requested_.</span><span style=\"color:#B392F0\">load</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::memory_order_relaxed)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            std</span><span style=\"color:#E1E4E8\">::function</span><span style=\"color:#F97583\">&#x3C;void</span><span style=\"color:#E1E4E8\">()</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> task;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Try to get task from local queue first</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">tryPopLocal</span><span style=\"color:#E1E4E8\">(local_queue, task)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                active_workers_.</span><span style=\"color:#B392F0\">fetch_add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::memory_order_relaxed);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                task</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                active_workers_.</span><span style=\"color:#B392F0\">fetch_sub</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::memory_order_relaxed);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Try to steal from other workers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">tryStealWork</span><span style=\"color:#E1E4E8\">(worker_id, task)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                active_workers_.</span><span style=\"color:#B392F0\">fetch_add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::memory_order_relaxed);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                task</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                active_workers_.</span><span style=\"color:#B392F0\">fetch_sub</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::memory_order_relaxed);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Wait for new work</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            std</span><span style=\"color:#E1E4E8\">::unique_lock</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(local_queue.mutex);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            local_queue.condition.</span><span style=\"color:#B392F0\">wait_for</span><span style=\"color:#E1E4E8\">(lock, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">milliseconds</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> tryPopLocal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">WorkerQueue</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> queue</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">function</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">()></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> task</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::unique_lock</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(queue.mutex, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::try_to_lock);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (lock.</span><span style=\"color:#B392F0\">owns_lock</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">queue.tasks.</span><span style=\"color:#B392F0\">empty</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            task </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">move</span><span style=\"color:#E1E4E8\">(queue.tasks.</span><span style=\"color:#B392F0\">front</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            queue.tasks.</span><span style=\"color:#B392F0\">pop</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> tryStealWork</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> excluding_worker</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">function</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">()></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> task</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> worker_queues_.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">i) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> excluding_worker) </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            auto&#x26;</span><span style=\"color:#E1E4E8\"> queue </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">worker_queues_[i];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            std</span><span style=\"color:#E1E4E8\">::unique_lock</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(queue.mutex, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::try_to_lock);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (lock.</span><span style=\"color:#B392F0\">owns_lock</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">queue.tasks.</span><span style=\"color:#B392F0\">empty</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                task </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">move</span><span style=\"color:#E1E4E8\">(queue.tasks.</span><span style=\"color:#B392F0\">front</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                queue.tasks.</span><span style=\"color:#B392F0\">pop</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    explicit</span><span style=\"color:#B392F0\"> WorkStealingThreadPool</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> thread_count</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">thread</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">hardware_concurrency</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        worker_queues_.</span><span style=\"color:#B392F0\">reserve</span><span style=\"color:#E1E4E8\">(thread_count);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        workers_.</span><span style=\"color:#B392F0\">reserve</span><span style=\"color:#E1E4E8\">(thread_count);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Create worker queues</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> thread_count; </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">i) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            worker_queues_.</span><span style=\"color:#B392F0\">emplace_back</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">make_unique</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">WorkerQueue</span><span style=\"color:#E1E4E8\">>());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Start worker threads</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> thread_count; </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">i) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            workers_.</span><span style=\"color:#B392F0\">emplace_back</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">WorkStealingThreadPool</span><span style=\"color:#E1E4E8\">::workerLoop, </span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">, i);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> Func</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    auto</span><span style=\"color:#B392F0\"> enqueue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Func</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#FFAB70\"> func</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">future</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">decltype</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">func</span><span style=\"color:#E1E4E8\">(args...))> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        using</span><span style=\"color:#B392F0\"> ReturnType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> decltype</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">func</span><span style=\"color:#E1E4E8\">(args...));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> task </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">make_shared</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">packaged_task</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">ReturnType</span><span style=\"color:#E1E4E8\">()>>(</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">bind</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">forward</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Func</span><span style=\"color:#E1E4E8\">>(func), </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">forward</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">>(args)...)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        );</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> task-></span><span style=\"color:#B392F0\">get_future</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Distribute tasks round-robin across workers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        static</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::atomic</span><span style=\"color:#F97583\">&#x3C;size_t></span><span style=\"color:#E1E4E8\"> counter{</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> target_worker </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> counter.</span><span style=\"color:#B392F0\">fetch_add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> worker_queues_.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto&#x26;</span><span style=\"color:#E1E4E8\"> queue </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">worker_queues_[target_worker];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            std</span><span style=\"color:#E1E4E8\">::unique_lock</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(queue.mutex);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            queue.tasks.</span><span style=\"color:#B392F0\">emplace</span><span style=\"color:#E1E4E8\">([</span><span style=\"color:#FFAB70\">task</span><span style=\"color:#E1E4E8\">]() { (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">task)(); });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        queue.condition.</span><span style=\"color:#B392F0\">notify_one</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> waitForAllTasks</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Wait until all workers are idle</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (active_workers_.</span><span style=\"color:#B392F0\">load</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::memory_order_relaxed) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">this_thread</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">sleep_for</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">microseconds</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Double-check that all queues are empty</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#E1E4E8\"> all_empty </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">all_empty) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            all_empty </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">auto&#x26;</span><span style=\"color:#E1E4E8\"> queue : worker_queues_) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                std</span><span style=\"color:#E1E4E8\">::unique_lock</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::mutex</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> lock</span><span style=\"color:#E1E4E8\">(queue->mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">queue->tasks.</span><span style=\"color:#B392F0\">empty</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    all_empty </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">all_empty) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">this_thread</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">sleep_for</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">microseconds</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#B392F0\"> getThreadCount</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> workers_.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ~WorkStealingThreadPool</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stop_requested_.</span><span style=\"color:#B392F0\">store</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::memory_order_relaxed);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Wake up all workers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">auto&#x26;</span><span style=\"color:#E1E4E8\"> queue : worker_queues_) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            queue->condition.</span><span style=\"color:#B392F0\">notify_all</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Wait for all workers to finish</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">auto&#x26;</span><span style=\"color:#E1E4E8\"> worker : workers_) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            worker.</span><span style=\"color:#B392F0\">join</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Event System with Batching</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unordered_map></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;typeindex></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;functional></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;memory></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;queue></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EventDispatcher</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Base event interface</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> Event</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        virtual</span><span style=\"color:#B392F0\"> ~Event</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> default</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        virtual</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">type_index</span><span style=\"color:#B392F0\"> getType</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Typed event wrapper</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> TypedEvent</span><span style=\"color:#E1E4E8\"> : Event {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        T data;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        explicit</span><span style=\"color:#B392F0\"> TypedEvent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Args</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">) : </span><span style=\"color:#B392F0\">data</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">forward</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">>(args)...) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">type_index</span><span style=\"color:#B392F0\"> getType</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> override</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">type_index</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">typeid</span><span style=\"color:#E1E4E8\">(T));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Event handler function type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    using</span><span style=\"color:#B392F0\"> EventHandler</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">function</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Event</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">)>;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Subscribe to events of specific type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> subscribe</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EventHandler</span><span style=\"color:#FFAB70\"> handler</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> type_index </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">type_index</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">typeid</span><span style=\"color:#E1E4E8\">(T));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        event_handlers_[type_index].</span><span style=\"color:#B392F0\">emplace_back</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">move</span><span style=\"color:#E1E4E8\">(handler));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Convenient typed subscription</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> subscribe</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">function</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">)> </span><span style=\"color:#FFAB70\">handler</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        subscribe</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">>([</span><span style=\"color:#FFAB70\">handler</span><span style=\"color:#E1E4E8\">](</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Event</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> event</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            const</span><span style=\"color:#F97583\"> auto&#x26;</span><span style=\"color:#E1E4E8\"> typed_event </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> static_cast&#x3C;const</span><span style=\"color:#E1E4E8\"> TypedEvent</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">T</span><span style=\"color:#F97583\">>&#x26;></span><span style=\"color:#E1E4E8\">(event);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            handler</span><span style=\"color:#E1E4E8\">(typed_event.data);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Queue event for batch processing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> queueEvent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Args</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        event_queue_.</span><span style=\"color:#B392F0\">emplace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">make_unique</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">TypedEvent</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">>>(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">forward</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">>(args)...));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Immediately dispatch event</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">typename</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> dispatchEvent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Args</span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">... </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        TypedEvent</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">T</span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> event</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">forward</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Args</span><span style=\"color:#E1E4E8\">>(args)...);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        dispatchEvent</span><span style=\"color:#E1E4E8\">(event);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> dispatchEvent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> Event</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> event</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> it </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> event_handlers_.</span><span style=\"color:#B392F0\">find</span><span style=\"color:#E1E4E8\">(event.</span><span style=\"color:#B392F0\">getType</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (it </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> event_handlers_.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> auto&#x26;</span><span style=\"color:#E1E4E8\"> handler : it->second) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                handler</span><span style=\"color:#E1E4E8\">(event);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Process all queued events</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> processQueuedEvents</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">event_queue_.</span><span style=\"color:#B392F0\">empty</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            auto</span><span style=\"color:#E1E4E8\"> event </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">move</span><span style=\"color:#E1E4E8\">(event_queue_.</span><span style=\"color:#B392F0\">front</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            event_queue_.</span><span style=\"color:#B392F0\">pop</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            dispatchEvent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">event);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Clear all queued events without processing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> clearQueue</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::queue</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Event</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> empty;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        event_queue_.</span><span style=\"color:#B392F0\">swap</span><span style=\"color:#E1E4E8\">(empty);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#B392F0\"> getQueueSize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> event_queue_.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> clearAllHandlers</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        event_handlers_.</span><span style=\"color:#B392F0\">clear</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    template</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> clearHandlers</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        event_handlers_.</span><span style=\"color:#B392F0\">erase</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">type_index</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">typeid</span><span style=\"color:#E1E4E8\">(T)));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::type_index, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">EventHandler</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> event_handlers_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::queue</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::unique_ptr</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Event</span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> event_queue_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Common ECS events</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> ComponentAddedEvent</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Entity entity;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ComponentTypeID componentType;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ComponentAddedEvent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> e</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">ComponentTypeID</span><span style=\"color:#FFAB70\"> type</span><span style=\"color:#E1E4E8\">) </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span><span style=\"color:#B392F0\">entity</span><span style=\"color:#E1E4E8\">(e), </span><span style=\"color:#B392F0\">componentType</span><span style=\"color:#E1E4E8\">(type) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> ComponentRemovedEvent</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Entity entity;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ComponentTypeID componentType;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ComponentRemovedEvent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> e</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">ComponentTypeID</span><span style=\"color:#FFAB70\"> type</span><span style=\"color:#E1E4E8\">) </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span><span style=\"color:#B392F0\">entity</span><span style=\"color:#E1E4E8\">(e), </span><span style=\"color:#B392F0\">componentType</span><span style=\"color:#E1E4E8\">(type) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> EntityCreatedEvent</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Entity entity;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    explicit</span><span style=\"color:#B392F0\"> EntityCreatedEvent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> e</span><span style=\"color:#E1E4E8\">) : </span><span style=\"color:#B392F0\">entity</span><span style=\"color:#E1E4E8\">(e) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> EntityDestroyedEvent</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Entity entity;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    explicit</span><span style=\"color:#B392F0\"> EntityDestroyedEvent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> e</span><span style=\"color:#E1E4E8\">) : </span><span style=\"color:#B392F0\">entity</span><span style=\"color:#E1E4E8\">(e) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Simple Performance Profiler</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#pragma</span><span style=\"color:#B392F0\"> once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;chrono></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unordered_map></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;algorithm></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;iostream></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;iomanip></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PerformanceProfiler</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> ProfileData</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::string name;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        double</span><span style=\"color:#E1E4E8\"> totalTime </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        double</span><span style=\"color:#E1E4E8\"> minTime </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">numeric_limits</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">>::</span><span style=\"color:#B392F0\">max</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        double</span><span style=\"color:#E1E4E8\"> maxTime </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> callCount </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        double</span><span style=\"color:#B392F0\"> getAverageTime</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> callCount </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ?</span><span style=\"color:#E1E4E8\"> totalTime </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> callCount </span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    class</span><span style=\"color:#B392F0\"> ScopedTimer</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        PerformanceProfiler</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> profiler_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::string name_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">high_resolution_clock</span><span style=\"color:#E1E4E8\">::time_point start_time_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ScopedTimer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PerformanceProfiler</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> profiler</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            : </span><span style=\"color:#B392F0\">profiler_</span><span style=\"color:#E1E4E8\">(profiler), </span><span style=\"color:#B392F0\">name_</span><span style=\"color:#E1E4E8\">(name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            , </span><span style=\"color:#B392F0\">start_time_</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">high_resolution_clock</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">()) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ~ScopedTimer</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            auto</span><span style=\"color:#E1E4E8\"> end_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">high_resolution_clock</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            auto</span><span style=\"color:#E1E4E8\"> duration </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">duration</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">milli</span><span style=\"color:#E1E4E8\">>(end_time </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start_time_).</span><span style=\"color:#B392F0\">count</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            profiler_-></span><span style=\"color:#B392F0\">recordTiming</span><span style=\"color:#E1E4E8\">(name_, duration);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> recordTiming</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">double</span><span style=\"color:#FFAB70\"> timeMs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto&#x26;</span><span style=\"color:#E1E4E8\"> data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> profile_data_[name];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        data.name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> name;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        data.totalTime </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> timeMs;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        data.minTime </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">min</span><span style=\"color:#E1E4E8\">(data.minTime, timeMs);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        data.maxTime </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">max</span><span style=\"color:#E1E4E8\">(data.maxTime, timeMs);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        data.callCount</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ScopedTimer</span><span style=\"color:#B392F0\"> createTimer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> ScopedTimer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">, name);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> reset</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        profile_data_.</span><span style=\"color:#B392F0\">clear</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> printReport</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (profile_data_.</span><span style=\"color:#B392F0\">empty</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"No profiling data available.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Sort by total time descending</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ProfileData</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> sorted_data;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> auto&#x26;</span><span style=\"color:#E1E4E8\"> pair : profile_data_) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            sorted_data.</span><span style=\"color:#B392F0\">push_back</span><span style=\"color:#E1E4E8\">(pair.second);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">sort</span><span style=\"color:#E1E4E8\">(sorted_data.</span><span style=\"color:#B392F0\">begin</span><span style=\"color:#E1E4E8\">(), sorted_data.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">(), </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 [](</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> ProfileData</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> a</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> ProfileData</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> b</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                     return</span><span style=\"color:#E1E4E8\"> a.totalTime </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> b.totalTime;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">=== Performance Profile Report ===</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::left </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                  &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">setw</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">25</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"Name\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                  &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">setw</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"Total (ms)\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                  &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">setw</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"Avg (ms)\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                  &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">setw</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"Min (ms)\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                  &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">setw</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"Max (ms)\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                  &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">setw</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"Calls\"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">85</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'-'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> auto&#x26;</span><span style=\"color:#E1E4E8\"> data : sorted_data) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::left </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                      &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">setw</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">25</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> data.name</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                      &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">setw</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::fixed </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">setprecision</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> data.totalTime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                      &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">setw</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::fixed </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">setprecision</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> data.</span><span style=\"color:#B392F0\">getAverageTime</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                      &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">setw</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::fixed </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">setprecision</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> data.minTime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                      &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">setw</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::fixed </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">setprecision</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> data.maxTime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                      &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">setw</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> data.callCount </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#B392F0\"> ProfileData</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> getProfileData</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        auto</span><span style=\"color:#E1E4E8\"> it </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> profile_data_.</span><span style=\"color:#B392F0\">find</span><span style=\"color:#E1E4E8\">(name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> it </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> profile_data_.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">?</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">it->second </span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> nullptr</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">ProfileData</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">getAllProfileData</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">ProfileData</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> auto&#x26;</span><span style=\"color:#E1E4E8\"> pair : profile_data_) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result.</span><span style=\"color:#B392F0\">push_back</span><span style=\"color:#E1E4E8\">(pair.second);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::string, ProfileData</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> profile_data_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Global profiler instance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#E1E4E8\"> PerformanceProfiler g_profiler;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Convenience macro for timing scopes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PROFILE_SCOPE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">auto</span><span style=\"color:#E1E4E8\"> timer </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> g_profiler.</span><span style=\"color:#B392F0\">createTimer</span><span style=\"color:#E1E4E8\">(name)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PROFILE_FUNCTION</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">PROFILE_SCOPE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">__FUNCTION__</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>Parallel System Manager</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ParallelSystemManager</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#F97583\">public</span><span style=\"color:#B392F0\"> SystemManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WorkStealingThreadPool thread_pool_;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;size_t>></span><span style=\"color:#E1E4E8\"> execution_phases_;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> dependency_analysis_dirty_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    explicit</span><span style=\"color:#B392F0\"> ParallelSystemManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> thread_count</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">thread</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">hardware_concurrency</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span><span style=\"color:#B392F0\">thread_pool_</span><span style=\"color:#E1E4E8\">(thread_count) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> updateAllSystems</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">override</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        PROFILE_FUNCTION</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Check if dependency analysis needs to be updated</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: If dirty, rebuild execution phases based on system dependencies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: For each execution phase, submit systems to thread pool</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Wait for current phase to complete before starting next phase</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Handle any exceptions that occurred during parallel execution</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use analyzeSystemDependencies() to build phases</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use thread_pool_.waitForAllTasks() between phases</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> analyzeSystemDependencies</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        PROFILE_SCOPE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Dependency Analysis\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Clear existing execution phases</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Create dependency graph from system component access patterns  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Group systems with compatible dependencies into phases</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Ensure systems that write to same components are in different phases</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Store phases in execution_phases_ member</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Two systems are compatible if their write sets don't overlap</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //       and neither writes to components the other reads</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> systemsAreCompatible</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> system1_idx</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> system2_idx</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Get component access patterns for both systems</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Check if system1 writes to components that system2 reads or writes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Check if system2 writes to components that system1 reads or writes  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Return true only if no conflicts exist</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use set intersection to find conflicting component types</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> executeSystemsInPhase</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> system_indices</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                              World</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">float</span><span style=\"color:#FFAB70\"> deltaTime</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::future</span><span style=\"color:#F97583\">&#x3C;void>></span><span style=\"color:#E1E4E8\"> futures;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        futures.</span><span style=\"color:#B392F0\">reserve</span><span style=\"color:#E1E4E8\">(system_indices.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: For each system index in the phase, create an async task</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Submit tasks to thread pool and collect futures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Wait for all futures to complete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Check futures for exceptions and handle appropriately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Capture system reference and parameters by value in lambda</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use std::exception_ptr to handle cross-thread exceptions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Hierarchy Manager with Caching</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> HierarchyManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    World</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> world_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Cached data for performance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    mutable</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">, EntityHash</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> children_cache_;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    mutable</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::unordered_map</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">Entity</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\">, EntityHash</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> ancestors_cache_;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    mutable</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#E1E4E8\"> cache_valid_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    explicit</span><span style=\"color:#B392F0\"> HierarchyManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">) : </span><span style=\"color:#B392F0\">world_</span><span style=\"color:#E1E4E8\">(world) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> setParent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> child</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> parent</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Validate that child and parent are different entities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Check for circular references using wouldCreateCycle()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Remove child from its current parent's hierarchy (if any)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Add child to new parent's hierarchy component</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Update child's hierarchy component with new parent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: Invalidate cached hierarchy data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use hasComponent/getComponent to access Hierarchy components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Update both parent and child Hierarchy components atomically</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> removeFromHierarchy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Get entity's current hierarchy component</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Remove entity from parent's child list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Recursively remove all children from hierarchy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Remove entity's hierarchy component</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Invalidate hierarchy cache</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Process children before removing parent to maintain consistency</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">getChildren</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> parent</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Check if cache is valid, rebuild if necessary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Look up parent in children cache</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Return cached children vector or empty vector if none</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use rebuildCache() to ensure cache validity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#B392F0\">getAncestors</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> entity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Check if cache is valid, rebuild if necessary  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Look up entity in ancestors cache</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: If not cached, walk up parent chain and cache result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Return ancestors in root-to-immediate-parent order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Limit ancestor depth to prevent infinite loops</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> traverseSubtree</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> root</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">function</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)> </span><span style=\"color:#FFAB70\">callback</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Call callback for root entity with depth 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Get direct children of root entity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: For each child, recursively call traverseSubtree with depth+1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Use depth-first traversal order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Consider iterative implementation with explicit stack for deep hierarchies</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> isAncestorOf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> potential_ancestor</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> descendant</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Get all ancestors of descendant</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Check if potential_ancestor appears in ancestors list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Return true if found, false otherwise</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use getAncestors() for implementation simplicity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> rebuildCache</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (cache_valid_) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        PROFILE_SCOPE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Hierarchy Cache Rebuild\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Clear existing cached data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Query all entities with Hierarchy components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: For each entity, add it to its parent's children list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Build ancestors cache by walking parent chains</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Mark cache as valid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use world_->query&#x3C;Hierarchy>() to get hierarchical entities</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#B392F0\"> wouldCreateCycle</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> child</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Entity</span><span style=\"color:#FFAB70\"> newParent</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Get all ancestors of newParent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Check if child appears in the ancestor list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Return true if cycle would be created</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: If child is ancestor of newParent, making newParent parent of child creates cycle</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> invalidateCache</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cache_valid_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        children_cache_.</span><span style=\"color:#B392F0\">clear</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ancestors_cache_.</span><span style=\"color:#B392F0\">clear</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Debug Entity Inspector</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EntityInspector</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    World</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> world_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Entity selected_entity_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> INVALID_ENTITY;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> show_inspector_window_ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    explicit</span><span style=\"color:#B392F0\"> EntityInspector</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">World</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> world</span><span style=\"color:#E1E4E8\">) : </span><span style=\"color:#B392F0\">world_</span><span style=\"color:#E1E4E8\">(world) {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> render</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">show_inspector_window_) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Create ImGui window for entity inspection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Display entity selector with all alive entities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Show selected entity's component list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Allow editing of component values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Provide buttons for adding/removing components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use ImGui::Begin/End for window creation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use world_->getAllEntities() for entity list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> renderEntityList</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Get list of all alive entities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Display entities in selectable list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Update selected_entity_ when selection changes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Show entity ID and generation for debugging</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use ImGui::Selectable for entity selection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> renderComponentList</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (selected_entity_ </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> INVALID_ENTITY) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Get component type registry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: For each registered component type, check if entity has it</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Display component values in expandable tree nodes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Allow editing of component fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Show \"Add Component\" button for missing components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use reflection system to display component fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use ImGui::TreeNode for component grouping</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> renderComponentEditor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ComponentTypeID</span><span style=\"color:#FFAB70\"> typeID</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Get component type information from registry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Get component data for selected entity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Display editable fields based on component type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Apply changes when values are modified</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Handle different field types appropriately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Switch on component type to provide appropriate editors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use ImGui input widgets for different data types</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<p><strong>C++ Multi-Threading Considerations:</strong></p>\n<ul>\n<li>Use <code>std::shared_mutex</code> for read-write locks allowing multiple readers</li>\n<li>Consider <code>std::atomic</code> for simple shared variables to avoid lock overhead</li>\n<li>Use <code>alignas(64)</code> on frequently accessed structures to prevent false sharing</li>\n<li>Prefer <code>std::memory_order_relaxed</code> for performance counters that don&#39;t need strict ordering</li>\n<li>Use thread-local storage for per-thread data to minimize synchronization</li>\n</ul>\n<p><strong>Memory Management:</strong></p>\n<ul>\n<li>Use <code>std::unique_ptr</code> for automatic resource cleanup in complex systems</li>\n<li>Consider custom allocators for high-frequency allocations like events</li>\n<li>Use placement new for objects in pre-allocated memory pools</li>\n<li>Implement RAII patterns for resource acquisition and release</li>\n</ul>\n<p><strong>Performance Optimization:</strong></p>\n<ul>\n<li>Profile before optimizing - use tools like <code>perf</code>, Intel VTune, or built-in profilers</li>\n<li>Batch operations to reduce function call overhead</li>\n<li>Use structure-of-arrays layout for SIMD-friendly data access</li>\n<li>Consider compile-time polymorphism (templates) over runtime polymorphism (virtual functions) in hot paths</li>\n</ul>\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>Multi-Threading Extension Checkpoint:</strong>\nAfter implementing parallel system execution:</p>\n<ul>\n<li>Run: <code>cd build &amp;&amp; cmake --build . --target test_parallel_systems &amp;&amp; ./test_parallel_systems</code></li>\n<li>Expected output: &quot;Systems executed in N phases with M threads&quot; with timing comparisons</li>\n<li>Verify: Create systems with read/write conflicts, ensure proper phase separation</li>\n<li>Performance test: Measure execution time with 1 vs multiple threads, expect speedup for CPU-bound systems</li>\n<li>Stress test: Run with many entities (10,000+) and verify no data races or crashes</li>\n<li>Signs of issues: Random crashes, inconsistent results, performance regression, or deadlocks</li>\n</ul>\n<p><strong>Advanced Features Checkpoint:</strong>\nAfter implementing hierarchy and event systems:</p>\n<ul>\n<li>Run: <code>cd build &amp;&amp; cmake --build . --target test_advanced_features &amp;&amp; ./test_advanced_features</code></li>\n<li>Expected behavior: Hierarchical transforms update correctly, events fire when components change</li>\n<li>Interactive test: Create parent-child entity relationships, move parent, verify children follow</li>\n<li>Event test: Add/remove components, confirm appropriate events are generated and handled</li>\n<li>Edge case test: Attempt circular references, deep hierarchies (100+ levels), rapid parent changes</li>\n<li>Signs of issues: Stack overflow, infinite loops, missing events, or memory leaks</li>\n</ul>\n<p><strong>Development Tooling Checkpoint:</strong>\nAfter implementing debug visualization and profiling:</p>\n<ul>\n<li>Run: <code>cd build &amp;&amp; cmake --build . --target debug_example &amp;&amp; ./debug_example</code></li>\n<li>Expected output: Real-time window showing entity list, component values, and performance metrics</li>\n<li>Interactive test: Select entities, modify component values, verify changes appear in game</li>\n<li>Performance check: Enable/disable profiling, verify minimal impact when disabled</li>\n<li>Memory test: Use debug tools to identify memory leaks or excessive allocations</li>\n<li>Signs of issues: Significant performance impact, incorrect data display, or crashes when debugging</li>\n</ul>\n<p><strong>Integration Checkpoint:</strong>\nAfter completing all extensions:</p>\n<ul>\n<li>Run full test</li>\n</ul>\n<h2 id=\"glossary\">Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All Milestones — comprehensive terminology reference for ECS architecture, data-oriented design concepts, and performance optimization terms used throughout the implementation</p>\n</blockquote>\n<p>Understanding ECS architecture requires mastery of specialized terminology spanning game engine design, performance optimization, and data structure concepts. This glossary provides comprehensive definitions organized by conceptual area to support learning throughout all project milestones.</p>\n<h3 id=\"mental-model-technical-dictionary-with-cross-references\">Mental Model: Technical Dictionary with Cross-References</h3>\n<p>Think of this glossary as a specialized technical dictionary where each term is connected to related concepts through cross-references and usage examples. Unlike a simple word list, each definition explains not just what a term means, but why it matters in the context of ECS architecture and how it relates to performance goals. The organization follows the conceptual flow from basic ECS principles through advanced optimization techniques.</p>\n<h3 id=\"core-ecs-terminology\">Core ECS Terminology</h3>\n<p>The fundamental concepts that define Entity-Component-System architecture form the foundation for understanding all advanced topics.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Usage Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Entity</strong></td>\n<td>A unique identifier representing a game object, containing only an ID and generation counter without data or behavior</td>\n<td>Core abstraction in all ECS operations - represents players, bullets, enemies, etc.</td>\n</tr>\n<tr>\n<td><strong>Component</strong></td>\n<td>Plain data structure containing information about one aspect of an entity, such as position, health, or velocity</td>\n<td>Stored separately from entities in cache-friendly arrays for data-oriented design</td>\n</tr>\n<tr>\n<td><strong>System</strong></td>\n<td>Logic that operates on entities having specific component combinations, implementing game behaviors like movement or rendering</td>\n<td>Executes each frame, queries for entities with required components, processes them in batches</td>\n</tr>\n<tr>\n<td><strong>World</strong></td>\n<td>ECS coordinator class that manages all entities, components, and systems, providing the main interface for ECS operations</td>\n<td>Central hub that ties together Entity Manager, Component Storage, and System Manager</td>\n</tr>\n<tr>\n<td><strong>EntityID</strong></td>\n<td>Unique 32-bit identifier for an entity, used as an index into various data structures throughout the ECS</td>\n<td>Primary key for entity lookup - does not guarantee entity is still alive without generation checking</td>\n</tr>\n<tr>\n<td><strong>Generation</strong></td>\n<td>Version number associated with each EntityID that increments when an entity is destroyed, preventing stale references</td>\n<td>Critical for memory safety - prevents accessing recycled entity IDs that point to different entities</td>\n</tr>\n</tbody></table>\n<h3 id=\"entity-management-concepts\">Entity Management Concepts</h3>\n<p>Entity lifecycle management requires specialized terminology for safe ID recycling and reference validation.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Usage Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Entity Lifecycle</strong></td>\n<td>The complete sequence of entity creation, active usage, and destruction with proper cleanup of all associated data</td>\n<td>Managed by EntityManager through createEntity(), component attachment, and destroyEntity() calls</td>\n</tr>\n<tr>\n<td><strong>Generation Counter</strong></td>\n<td>Version number preventing stale entity references by incrementing whenever an EntityID is recycled for a new entity</td>\n<td>Solves the ABA problem where recycled IDs could access wrong entity data without versioning</td>\n</tr>\n<tr>\n<td><strong>ID Recycling</strong></td>\n<td>Reusing EntityIDs from destroyed entities to prevent unbounded growth of entity indices in long-running applications</td>\n<td>Maintains dense entity arrays and prevents memory waste, essential for games running for hours</td>\n</tr>\n<tr>\n<td><strong>Stale Reference</strong></td>\n<td>Entity reference pointing to a destroyed entity, potentially accessing wrong data if ID was recycled without generation checking</td>\n<td>Common bug source - prevented by always validating Entity.generation matches current generation</td>\n</tr>\n<tr>\n<td><strong>Free List</strong></td>\n<td>Queue of recycled EntityIDs available for assignment to new entities, enabling efficient ID reuse</td>\n<td>Implemented as vector storing destroyed EntityIDs, processed during entity creation</td>\n</tr>\n<tr>\n<td><strong>ABA Problem</strong></td>\n<td>Accessing wrong data when IDs are reused without versioning - thread A sees ID 5 pointing to entity X, ID gets recycled to entity Y, thread A accesses expecting X but gets Y</td>\n<td>Solved by generation counters that change when IDs are recycled</td>\n</tr>\n<tr>\n<td><strong>Entity Validation</strong></td>\n<td>Process of checking that an Entity reference is still valid by verifying the generation counter matches current value</td>\n<td>Configurable safety checking from no validation (release) to comprehensive bounds checking (debug)</td>\n</tr>\n</tbody></table>\n<h3 id=\"component-storage-architecture\">Component Storage Architecture</h3>\n<p>Cache-friendly component storage requires understanding of specialized data structures and memory layout principles.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Usage Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Sparse Set</strong></td>\n<td>Bidirectional mapping data structure using sparse and dense arrays to provide O(1) insert, remove, and lookup operations</td>\n<td>Core of component storage - maps entity IDs to component array indices efficiently</td>\n</tr>\n<tr>\n<td><strong>Dense Array</strong></td>\n<td>Contiguous storage containing actual component data for cache-friendly iteration over all components of a type</td>\n<td>Where components live - enables SIMD processing and minimizes cache misses during system updates</td>\n</tr>\n<tr>\n<td><strong>Sparse Array</strong></td>\n<td>Array indexed by EntityID that stores indices into the dense array, enabling constant-time entity-to-component lookup</td>\n<td>Maps entity IDs to dense positions - uses SIZE_MAX as sentinel for &quot;no component&quot;</td>\n</tr>\n<tr>\n<td><strong>Bidirectional Mapping</strong></td>\n<td>Data structure relationship allowing efficient translation in both directions - entity ID to component index and component index to entity ID</td>\n<td>Enables both &quot;get component for entity&quot; and &quot;get entity for component&quot; operations in O(1) time</td>\n</tr>\n<tr>\n<td><strong>Swap-Remove</strong></td>\n<td>Array removal technique that fills gaps by moving the last element to the removed position, maintaining dense packing</td>\n<td>Prevents array fragmentation but changes element order - requires updating sparse array indices</td>\n</tr>\n<tr>\n<td><strong>Structure-of-Arrays</strong></td>\n<td>Memory layout storing all instances of each component type in separate contiguous arrays rather than interleaving different types</td>\n<td>Opposite of Array-of-Structures - enables cache-friendly iteration and SIMD vectorization</td>\n</tr>\n<tr>\n<td><strong>Cache Locality</strong></td>\n<td>Organizing data so related information is stored close together in memory, minimizing CPU cache misses during access</td>\n<td>Key performance principle - systems iterate over dense component arrays for maximum cache efficiency</td>\n</tr>\n</tbody></table>\n<h3 id=\"system-execution-framework\">System Execution Framework</h3>\n<p>System coordination and execution requires terminology for queries, scheduling, and data access patterns.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Usage Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Component Query</strong></td>\n<td>Mechanism for finding entities that have specific combinations of component types, used by systems to locate relevant entities</td>\n<td>Template-based specification like query&lt;Position, Velocity&gt;() returns iterator over matching entities</td>\n</tr>\n<tr>\n<td><strong>Query Iterator</strong></td>\n<td>Template-based iterator that efficiently traverses entities matching a component query, providing tuple access to components</td>\n<td>Dereferences to tuple&lt;Position&amp;, Velocity&amp;&gt; for type-safe component access during iteration</td>\n</tr>\n<tr>\n<td><strong>System Execution Framework</strong></td>\n<td>Infrastructure coordinating system updates each frame, handling registration, ordering, and safe execution with error recovery</td>\n<td>Manages system lifecycle, dependency ordering, and provides World and delta time to each system</td>\n</tr>\n<tr>\n<td><strong>Priority-Based Scheduling</strong></td>\n<td>Execution ordering using integer priority values to ensure systems run in correct sequence each frame</td>\n<td>Lower numbers execute first: input (100), logic (200), physics (300), rendering (500)</td>\n</tr>\n<tr>\n<td><strong>Assembly Line Stations</strong></td>\n<td>Mental model for understanding systems as specialized processing stations that entities flow through each frame</td>\n<td>Each system is a station that processes entities with required components, like factory assembly line</td>\n</tr>\n<tr>\n<td><strong>System Update Cycle</strong></td>\n<td>Frame-by-frame execution flow where each system queries for entities, iterates over matches, and updates component data</td>\n<td>Single frame: input → logic → physics → rendering, with delta time provided for time-based calculations</td>\n</tr>\n<tr>\n<td><strong>Deferred Modification Pattern</strong></td>\n<td>Collecting component changes during iteration and applying them after iteration completes to prevent iterator invalidation</td>\n<td>Prevents crashes from modifying containers while iterating - queue changes and apply in separate phase</td>\n</tr>\n</tbody></table>\n<h3 id=\"performance-and-optimization-terms\">Performance and Optimization Terms</h3>\n<p>High-performance ECS implementations require understanding of CPU cache behavior and memory access patterns.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Usage Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Cache Miss</strong></td>\n<td>CPU cache lookup failure requiring slower main memory access, causing performance degradation</td>\n<td>Primary performance enemy - random memory access patterns cause cache misses and performance drops</td>\n</tr>\n<tr>\n<td><strong>Cache Miss Ratio</strong></td>\n<td>Percentage of memory accesses that fail to find data in CPU cache, requiring main memory access</td>\n<td>Performance metric - lower ratios indicate better cache utilization and higher performance</td>\n</tr>\n<tr>\n<td><strong>SIMD Processing</strong></td>\n<td>Single Instruction Multiple Data - CPU instructions that operate on multiple data elements simultaneously</td>\n<td>Enabled by contiguous component arrays - process 4-8 positions simultaneously with vectorized instructions</td>\n</tr>\n<tr>\n<td><strong>Data-Oriented Design</strong></td>\n<td>Programming methodology that organizes code around data access patterns rather than object relationships</td>\n<td>ECS core principle - optimize for CPU cache behavior and memory bandwidth rather than code organization</td>\n</tr>\n<tr>\n<td><strong>Hot Path</strong></td>\n<td>Frequently executed code sections where performance is critical, requiring minimal overhead and maximum optimization</td>\n<td>Entity validation in system queries - use fastest validation level since it runs every frame</td>\n</tr>\n<tr>\n<td><strong>Memory Bandwidth</strong></td>\n<td>Rate at which CPU can read data from main memory, often the bottleneck in data-intensive applications</td>\n<td>Maximized by sequential memory access patterns enabled by dense component arrays</td>\n</tr>\n<tr>\n<td><strong>Prefetching</strong></td>\n<td>CPU technique for loading data into cache before it&#39;s needed, based on predicted access patterns</td>\n<td>Improved by predictable iteration patterns over contiguous component arrays</td>\n</tr>\n<tr>\n<td><strong>Performance Regression</strong></td>\n<td>Code changes that reduce system performance compared to previous baseline measurements</td>\n<td>Detected by benchmark infrastructure comparing current frame times to historical averages</td>\n</tr>\n</tbody></table>\n<h3 id=\"advanced-archetype-concepts\">Advanced Archetype Concepts</h3>\n<p>Archetype-based storage introduces additional terminology for entity grouping and cache optimization.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Usage Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Archetype</strong></td>\n<td>Grouping entities by identical component combinations into shared storage structures for maximum cache efficiency</td>\n<td>Entities with Position+Velocity components share one archetype, Position+Health share another</td>\n</tr>\n<tr>\n<td><strong>Component Mask</strong></td>\n<td>Bitset indicating which component types are present in an archetype, used for fast archetype matching</td>\n<td>64-bit bitset where each bit represents one component type - enables fast subset/intersection operations</td>\n</tr>\n<tr>\n<td><strong>Archetype Transition</strong></td>\n<td>Moving an entity between archetypes when components are added or removed, updating all storage structures</td>\n<td>Adding Health component moves entity from Position+Velocity archetype to Position+Velocity+Health archetype</td>\n</tr>\n<tr>\n<td><strong>Chunk-Based Storage</strong></td>\n<td>Fixed-size memory blocks storing multiple entities of the same archetype for cache-friendly linear iteration</td>\n<td>16KB chunks store multiple entities with their components co-located for optimal memory access patterns</td>\n</tr>\n<tr>\n<td><strong>Entity Stride</strong></td>\n<td>Total memory size per entity including all component data within an archetype chunk</td>\n<td>Calculated from component sizes and alignment - determines how many entities fit in each chunk</td>\n</tr>\n<tr>\n<td><strong>Archetype Explosion</strong></td>\n<td>Performance problem from creating too many unique component combinations, fragmenting memory and complicating queries</td>\n<td>Mitigated by component design that favors composition and shared component patterns</td>\n</tr>\n<tr>\n<td><strong>Chunk Utilization</strong></td>\n<td>Percentage of chunk capacity filled with entities - higher utilization means better memory efficiency</td>\n<td>Monitored to detect archetype fragmentation and optimize entity distribution across chunks</td>\n</tr>\n</tbody></table>\n<h3 id=\"type-safety-and-validation\">Type Safety and Validation</h3>\n<p>Robust ECS implementations require comprehensive type checking and validation terminology.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Usage Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Type Safety</strong></td>\n<td>Compile-time and runtime guarantees that component access uses correct types, preventing data corruption</td>\n<td>Template system ensures getComponent<Position>() returns Position&amp; and catches type mismatches</td>\n</tr>\n<tr>\n<td><strong>Type Erasure</strong></td>\n<td>Runtime polymorphism technique allowing storage and manipulation of different component types through common interface</td>\n<td>IComponentStorage base class enables World to manage all component types without knowing specific types</td>\n</tr>\n<tr>\n<td><strong>Component Type Registry</strong></td>\n<td>Singleton managing metadata for all component types including size, alignment, and constructor information</td>\n<td>Maps ComponentTypeID to type information, enabling dynamic component operations and serialization</td>\n</tr>\n<tr>\n<td><strong>Type ID Verification</strong></td>\n<td>Runtime checking that component access matches expected type information to prevent memory corruption</td>\n<td>Validates that getComponent<Position>() is called on storage actually containing Position components</td>\n</tr>\n<tr>\n<td><strong>Validation Level</strong></td>\n<td>Configurable amount of safety checking performed, from no validation (release) to comprehensive bounds checking (debug)</td>\n<td>VALIDATION_NONE for performance, VALIDATION_COMPREHENSIVE for development debugging</td>\n</tr>\n<tr>\n<td><strong>Type Mismatch</strong></td>\n<td>Runtime error where component access uses wrong type information, potentially causing memory corruption or crashes</td>\n<td>Caught by type verification system and reported with detailed error information including entity ID</td>\n</tr>\n</tbody></table>\n<h3 id=\"error-handling-and-recovery\">Error Handling and Recovery</h3>\n<p>Robust ECS systems require specialized error handling terminology for system failures and recovery.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Usage Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Circuit Breaker Pattern</strong></td>\n<td>Error handling technique that isolates failing systems to prevent cascading failures throughout the ECS</td>\n<td>Disables systems after error threshold exceeded, attempts recovery after timeout period</td>\n</tr>\n<tr>\n<td><strong>Error Threshold</strong></td>\n<td>Maximum number of errors before a system is automatically disabled to prevent further damage</td>\n<td>Configurable per system - critical systems might have higher thresholds than optional systems</td>\n</tr>\n<tr>\n<td><strong>Recovery Timeout</strong></td>\n<td>Time period after system failure before attempting to re-enable the system and resume normal operation</td>\n<td>Prevents rapid failure loops while allowing systems to recover from transient errors</td>\n</tr>\n<tr>\n<td><strong>System Health Monitoring</strong></td>\n<td>Tracking system execution success/failure rates and performance metrics to detect problems early</td>\n<td>Records error counts, execution times, and success rates for each system over time windows</td>\n</tr>\n<tr>\n<td><strong>Dependency Cascading</strong></td>\n<td>Disabling dependent systems when their requirements fail, preventing execution with incomplete data</td>\n<td>If physics system fails, disable collision detection system that depends on physics results</td>\n</tr>\n<tr>\n<td><strong>Resource Leak</strong></td>\n<td>Failure to release memory, file handles, or other resources when systems encounter errors during cleanup</td>\n<td>Prevented by RAII patterns and proper exception handling in component destructors</td>\n</tr>\n</tbody></table>\n<h3 id=\"testing-and-debugging-terminology\">Testing and Debugging Terminology</h3>\n<p>Comprehensive testing strategies require specialized terminology for validation and performance measurement.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Usage Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Integration Testing</strong></td>\n<td>Testing component interactions together rather than in isolation to verify system-level behavior</td>\n<td>Tests complete entity creation, component attachment, and system processing workflows</td>\n</tr>\n<tr>\n<td><strong>Checkpoint Testing</strong></td>\n<td>Validation performed after each milestone completion to verify expected functionality before proceeding</td>\n<td>Milestone 1: entity creation/destruction, Milestone 2: component attachment, etc.</td>\n</tr>\n<tr>\n<td><strong>Benchmark Infrastructure</strong></td>\n<td>Tools and frameworks for measuring system performance and detecting regressions over time</td>\n<td>Measures frame times, cache miss rates, and memory allocation patterns across development</td>\n</tr>\n<tr>\n<td><strong>Cache Performance Profiling</strong></td>\n<td>Measuring CPU cache hit/miss ratios and memory access patterns to optimize data structures</td>\n<td>Identifies performance bottlenecks from poor cache locality in component storage</td>\n</tr>\n<tr>\n<td><strong>System Execution Tracing</strong></td>\n<td>Recording detailed information about system execution order, dependencies, and component access patterns</td>\n<td>Helps debug system ordering issues and identify unnecessary dependencies between systems</td>\n</tr>\n<tr>\n<td><strong>Memory Corruption Detection</strong></td>\n<td>Techniques for identifying invalid memory access, use-after-free errors, and buffer overruns in component data</td>\n<td>Essential for debugging sparse set implementation and entity lifecycle management</td>\n</tr>\n<tr>\n<td><strong>Performance Baseline</strong></td>\n<td>Reference measurements for system performance used to detect regressions in future development</td>\n<td>Established after optimization work to ensure future changes don&#39;t degrade performance</td>\n</tr>\n</tbody></table>\n<h3 id=\"data-structure-implementation-details\">Data Structure Implementation Details</h3>\n<p>Low-level implementation requires understanding of memory management and algorithmic complexity concepts.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Usage Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Sentinel Value</strong></td>\n<td>Special value used to indicate invalid or missing data, such as SIZE_MAX for empty sparse set entries</td>\n<td>INVALID_ENTITY_ID for invalid entities, SIZE_MAX for &quot;no component&quot; in sparse arrays</td>\n</tr>\n<tr>\n<td><strong>Memory Pool</strong></td>\n<td>Pre-allocated memory blocks for efficient allocation of fixed-size objects like archetype chunks</td>\n<td>ChunkAllocator manages pools of 16KB chunks to avoid frequent malloc/free operations</td>\n</tr>\n<tr>\n<td><strong>Iterator Invalidation</strong></td>\n<td>Corruption of iterators when underlying containers are modified during iteration</td>\n<td>Prevented by deferred modification pattern - collect changes during iteration, apply after</td>\n</tr>\n<tr>\n<td><strong>Template Parameter Pack</strong></td>\n<td>Variadic template feature allowing functions to accept variable numbers of component types</td>\n<td>Enables query&lt;Position, Velocity, Health&gt;() with compile-time type safety for any component combination</td>\n</tr>\n<tr>\n<td><strong>Const-Correctness</strong></td>\n<td>C++ principle ensuring read-only access through const references and methods where data shouldn&#39;t be modified</td>\n<td>getComponent<const Position>() for read-only access, getComponent<Position>() for read-write</td>\n</tr>\n<tr>\n<td><strong>RAII</strong></td>\n<td>Resource Acquisition Is Initialization - C++ idiom ensuring resources are properly cleaned up when objects are destroyed</td>\n<td>Component destructors automatically called during entity destruction, prevents resource leaks</td>\n</tr>\n<tr>\n<td><strong>Move Semantics</strong></td>\n<td>C++ feature for efficient transfer of resources without copying, important for component storage operations</td>\n<td>addComponent<Position>(entity, std::move(position)) transfers ownership efficiently</td>\n</tr>\n</tbody></table>\n<h3 id=\"game-development-context\">Game Development Context</h3>\n<p>ECS terminology specific to game engine architecture and real-time systems.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Usage Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Frame</strong></td>\n<td>Single update cycle of the game loop, typically targeting 60 FPS (16.67ms per frame)</td>\n<td>Each frame executes all systems in priority order with current delta time</td>\n</tr>\n<tr>\n<td><strong>Delta Time</strong></td>\n<td>Time elapsed since the last frame, passed to systems for time-based calculations like movement and animation</td>\n<td>Enables frame-rate independent game logic - move velocity * deltaTime pixels per frame</td>\n</tr>\n<tr>\n<td><strong>Game Object</strong></td>\n<td>Traditional OOP representation of game entities, replaced by Entity+Components in ECS architecture</td>\n<td>Player, Enemy, Bullet objects become entities with Position, Health, Sprite components</td>\n</tr>\n<tr>\n<td><strong>Update Loop</strong></td>\n<td>Main game loop that repeatedly executes system updates, input processing, and rendering each frame</td>\n<td>while(running) { input.update(); logic.update(); render.update(); } pattern</td>\n</tr>\n<tr>\n<td><strong>Real-Time Constraints</strong></td>\n<td>Performance requirements ensuring game maintains target frame rate without stuttering or lag</td>\n<td>Systems must complete processing within frame time budget (16.67ms for 60 FPS)</td>\n</tr>\n<tr>\n<td><strong>Asset Management</strong></td>\n<td>Loading and managing game resources like textures, sounds, and models referenced by components</td>\n<td>Components store resource IDs rather than raw data - actual assets managed separately</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-anti-patterns-and-pitfalls\">Common Anti-Patterns and Pitfalls</h3>\n<p>Understanding what NOT to do is crucial for successful ECS implementation.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Usage Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Thick Entities</strong></td>\n<td>Anti-pattern where entities contain logic or data instead of being pure IDs, defeating ECS performance benefits</td>\n<td>Avoid Entity classes with update() methods - keep entities as lightweight ID+generation pairs</td>\n</tr>\n<tr>\n<td><strong>Component Dependencies</strong></td>\n<td>Anti-pattern where components reference or depend on other components, creating tight coupling</td>\n<td>Avoid Position component storing Velocity* - use systems to coordinate between component types</td>\n</tr>\n<tr>\n<td><strong>System Communication</strong></td>\n<td>Anti-pattern where systems directly call each other instead of communicating through component data</td>\n<td>Systems should be independent - communicate through component state changes, not method calls</td>\n</tr>\n<tr>\n<td><strong>Premature Optimization</strong></td>\n<td>Implementing complex optimizations like archetypes before measuring performance and identifying bottlenecks</td>\n<td>Start with simple sparse sets, profile performance, then optimize only proven bottlenecks</td>\n</tr>\n<tr>\n<td><strong>String-Based Queries</strong></td>\n<td>Anti-pattern using string names for component types instead of compile-time type checking</td>\n<td>Avoid query(&quot;Position&quot;, &quot;Velocity&quot;) - use query&lt;Position, Velocity&gt;() for type safety</td>\n</tr>\n<tr>\n<td><strong>Singleton Components</strong></td>\n<td>Anti-pattern using components to store global state that should live outside the ECS</td>\n<td>Game configuration belongs in separate managers, not as components on special entities</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The terminology defined above enables precise communication about ECS concepts throughout implementation. This comprehensive vocabulary supports learning progression from basic entity management through advanced archetype optimization.</p>\n<h4 id=\"essential-terms-by-milestone\">Essential Terms by Milestone</h4>\n<p><strong>Milestone 1 (Entity Manager):</strong> Entity, EntityID, Generation, Entity Lifecycle, Generation Counter, ID Recycling, Stale Reference, Free List, ABA Problem, Entity Validation</p>\n<p><strong>Milestone 2 (Component Storage):</strong> Component, Sparse Set, Dense Array, Sparse Array, Bidirectional Mapping, Swap-Remove, Structure-of-Arrays, Cache Locality, Type Safety, Component Type Registry</p>\n<p><strong>Milestone 3 (System Interface):</strong> System, Component Query, Query Iterator, System Execution Framework, Priority-Based Scheduling, System Update Cycle, Deferred Modification Pattern</p>\n<p><strong>Milestone 4 (Archetypes):</strong> Archetype, Component Mask, Archetype Transition, Chunk-Based Storage, Entity Stride, Archetype Explosion, Chunk Utilization</p>\n<h4 id=\"performance-related-term-clusters\">Performance-Related Term Clusters</h4>\n<p>Understanding performance requires mastery of related terminology groups:</p>\n<p><strong>Cache Performance:</strong> Cache Miss, Cache Miss Ratio, Cache Locality, Memory Bandwidth, Prefetching, Hot Path, Performance Regression</p>\n<p><strong>Memory Management:</strong> Memory Pool, Sentinel Value, RAII, Move Semantics, Resource Leak, Iterator Invalidation</p>\n<p><strong>Data Access Patterns:</strong> Structure-of-Arrays, Dense Array, SIMD Processing, Data-Oriented Design, Contiguous Storage</p>\n<h4 id=\"error-handling-term-relationships\">Error Handling Term Relationships</h4>\n<p>Robust implementation requires understanding error handling terminology connections:</p>\n<p><strong>Validation:</strong> Entity Validation, Type Safety, Type ID Verification, Validation Level, Type Mismatch</p>\n<p><strong>Recovery:</strong> Circuit Breaker Pattern, Error Threshold, Recovery Timeout, System Health Monitoring, Dependency Cascading</p>\n<p><strong>Testing:</strong> Integration Testing, Checkpoint Testing, Benchmark Infrastructure, Memory Corruption Detection</p>\n<p>This glossary serves as both a learning resource during implementation and a reference for maintaining consistent terminology across the codebase. Each term definition includes not just the meaning, but the context and rationale for its importance in ECS architecture.</p>\n","toc":[{"level":1,"text":"ECS Architecture: Design Document","id":"ecs-architecture-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Context and Problem Statement","id":"context-and-problem-statement"},{"level":3,"text":"Object-Oriented Game Architecture Problems","id":"object-oriented-game-architecture-problems"},{"level":4,"text":"Cache Miss Cascade Problems","id":"cache-miss-cascade-problems"},{"level":4,"text":"Inheritance Hierarchy Complexity","id":"inheritance-hierarchy-complexity"},{"level":4,"text":"Scattered Data Access Patterns","id":"scattered-data-access-patterns"},{"level":3,"text":"Data-Oriented Design Benefits","id":"data-oriented-design-benefits"},{"level":4,"text":"Cache Locality Optimization","id":"cache-locality-optimization"},{"level":4,"text":"SIMD-Friendly Operations","id":"simd-friendly-operations"},{"level":4,"text":"Composition Over Inheritance","id":"composition-over-inheritance"},{"level":3,"text":"Existing ECS Approaches Comparison","id":"existing-ecs-approaches-comparison"},{"level":4,"text":"Simple Component Arrays Approach","id":"simple-component-arrays-approach"},{"level":4,"text":"Sparse Set Storage Approach","id":"sparse-set-storage-approach"},{"level":4,"text":"Archetype-Based Storage Approach","id":"archetype-based-storage-approach"},{"level":4,"text":"Implementation Strategy Recommendation","id":"implementation-strategy-recommendation"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended Project Structure","id":"recommended-project-structure"},{"level":4,"text":"Core Data Type Foundations","id":"core-data-type-foundations"},{"level":4,"text":"Entity Manager Implementation Skeleton","id":"entity-manager-implementation-skeleton"},{"level":4,"text":"Component Storage Implementation Skeleton","id":"component-storage-implementation-skeleton"},{"level":4,"text":"System Interface Foundation","id":"system-interface-foundation"},{"level":4,"text":"World Coordinator Implementation","id":"world-coordinator-implementation"},{"level":4,"text":"Example Usage Pattern","id":"example-usage-pattern"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Language-Specific Implementation Notes","id":"language-specific-implementation-notes"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"Functional Goals: Entity lifecycle, component attachment, system execution","id":"functional-goals-entity-lifecycle-component-attachment-system-execution"},{"level":3,"text":"Performance Goals: Cache-friendly iteration, constant-time lookups, minimal allocations","id":"performance-goals-cache-friendly-iteration-constant-time-lookups-minimal-allocations"},{"level":3,"text":"Non-Goals: Multi-threading, serialization, networking, visual editors","id":"non-goals-multi-threading-serialization-networking-visual-editors"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Core Type Definitions","id":"core-type-definitions"},{"level":4,"text":"Sample Component Definitions","id":"sample-component-definitions"},{"level":4,"text":"Entity Manager Skeleton","id":"entity-manager-skeleton"},{"level":4,"text":"Component Storage Interface","id":"component-storage-interface"},{"level":4,"text":"System Base Class","id":"system-base-class"},{"level":4,"text":"World Coordinator Skeleton","id":"world-coordinator-skeleton"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Performance Validation","id":"performance-validation"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"Component Responsibilities","id":"component-responsibilities"},{"level":4,"text":"Entity Manager Responsibilities","id":"entity-manager-responsibilities"},{"level":4,"text":"Component Storage Responsibilities","id":"component-storage-responsibilities"},{"level":4,"text":"System Interface Responsibilities","id":"system-interface-responsibilities"},{"level":4,"text":"World Coordinator Responsibilities","id":"world-coordinator-responsibilities"},{"level":3,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":3,"text":"Data Flow Patterns","id":"data-flow-patterns"},{"level":4,"text":"Entity Creation Flow","id":"entity-creation-flow"},{"level":4,"text":"Component Attachment Flow","id":"component-attachment-flow"},{"level":4,"text":"System Update Cycle","id":"system-update-cycle"},{"level":4,"text":"Query Execution Patterns","id":"query-execution-patterns"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Core Architecture Skeleton","id":"core-architecture-skeleton"},{"level":4,"text":"Language-Specific Implementation Notes","id":"language-specific-implementation-notes"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Data Model","id":"data-model"},{"level":3,"text":"Entity ID Structure","id":"entity-id-structure"},{"level":3,"text":"Component Type Information","id":"component-type-information"},{"level":3,"text":"Archetype Data Layout","id":"archetype-data-layout"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Entity Manager Design","id":"entity-manager-design"},{"level":3,"text":"Mental Model: Library Card System","id":"mental-model-library-card-system"},{"level":3,"text":"Generation Counter Mechanism","id":"generation-counter-mechanism"},{"level":3,"text":"ID Recycling Strategy","id":"id-recycling-strategy"},{"level":3,"text":"Common Entity Management Pitfalls","id":"common-entity-management-pitfalls"},{"level":3,"text":"Common Entity Management Pitfalls","id":"common-entity-management-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Component Storage Design","id":"component-storage-design"},{"level":3,"text":"Mental Model: Warehouse with Index Cards","id":"mental-model-warehouse-with-index-cards"},{"level":3,"text":"Sparse Set Data Structure","id":"sparse-set-data-structure"},{"level":3,"text":"Type-Safe Component Access","id":"type-safe-component-access"},{"level":3,"text":"Common Component Storage Pitfalls","id":"common-component-storage-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"System Interface Design","id":"system-interface-design"},{"level":3,"text":"Mental Model: Assembly Line Stations","id":"mental-model-assembly-line-stations"},{"level":3,"text":"Component Query Mechanism","id":"component-query-mechanism"},{"level":4,"text":"Query Execution Process","id":"query-execution-process"},{"level":4,"text":"Query Optimization Strategies","id":"query-optimization-strategies"},{"level":3,"text":"System Execution and Ordering","id":"system-execution-and-ordering"},{"level":4,"text":"System Base Interface","id":"system-base-interface"},{"level":4,"text":"System Registration and Lifecycle","id":"system-registration-and-lifecycle"},{"level":4,"text":"Dependency Management","id":"dependency-management"},{"level":3,"text":"Common System Design Pitfalls","id":"common-system-design-pitfalls"},{"level":4,"text":"Component Modification During Iteration","id":"component-modification-during-iteration"},{"level":4,"text":"System Ordering Dependencies","id":"system-ordering-dependencies"},{"level":4,"text":"Thread Safety Concerns","id":"thread-safety-concerns"},{"level":4,"text":"Performance Anti-Patterns","id":"performance-anti-patterns"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"System Base Interface (Complete)","id":"system-base-interface-complete"},{"level":4,"text":"Query Interface Implementation (Core Logic Skeleton)","id":"query-interface-implementation-core-logic-skeleton"},{"level":4,"text":"System Manager Implementation (Complete)","id":"system-manager-implementation-complete"},{"level":4,"text":"Example System Implementations (Complete)","id":"example-system-implementations-complete"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Archetype-Based Storage (Advanced)","id":"archetype-based-storage-advanced"},{"level":3,"text":"Mental Model: Filing Cabinet Organization","id":"mental-model-filing-cabinet-organization"},{"level":3,"text":"Archetype Identification and Transitions","id":"archetype-identification-and-transitions"},{"level":3,"text":"Chunk-Based Memory Layout","id":"chunk-based-memory-layout"},{"level":3,"text":"Archetype Implementation Pitfalls","id":"archetype-implementation-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Interactions and Data Flow","id":"interactions-and-data-flow"},{"level":3,"text":"Entity Lifecycle Flow","id":"entity-lifecycle-flow"},{"level":4,"text":"Entity Creation Sequence","id":"entity-creation-sequence"},{"level":4,"text":"Component Attachment Process","id":"component-attachment-process"},{"level":4,"text":"Component Removal and Cleanup","id":"component-removal-and-cleanup"},{"level":4,"text":"Entity Destruction Workflow","id":"entity-destruction-workflow"},{"level":3,"text":"System Update Cycle","id":"system-update-cycle"},{"level":4,"text":"Frame Execution Flow","id":"frame-execution-flow"},{"level":4,"text":"System Execution and Ordering","id":"system-execution-and-ordering"},{"level":4,"text":"Component Access Patterns","id":"component-access-patterns"},{"level":3,"text":"Query Execution Patterns","id":"query-execution-patterns"},{"level":4,"text":"Query Specification and Construction","id":"query-specification-and-construction"},{"level":4,"text":"Entity Filtering and Iteration","id":"entity-filtering-and-iteration"},{"level":4,"text":"Component Access and Modification Safety","id":"component-access-and-modification-safety"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Implementation Hints","id":"language-specific-implementation-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"Entity Validation Strategies","id":"entity-validation-strategies"},{"level":4,"text":"Mental Model: Hotel Key Cards with Expiration","id":"mental-model-hotel-key-cards-with-expiration"},{"level":4,"text":"Entity Validation State Machine","id":"entity-validation-state-machine"},{"level":4,"text":"Validation Error Recovery Strategies","id":"validation-error-recovery-strategies"},{"level":4,"text":"Common Entity Validation Pitfalls","id":"common-entity-validation-pitfalls"},{"level":3,"text":"Component Type Safety","id":"component-type-safety"},{"level":4,"text":"Mental Model: Library Card Catalog with ISBN Numbers","id":"mental-model-library-card-catalog-with-isbn-numbers"},{"level":4,"text":"Component Type Registration System","id":"component-type-registration-system"},{"level":4,"text":"Type-Safe Component Access Patterns","id":"type-safe-component-access-patterns"},{"level":4,"text":"Type Mismatch Error Recovery","id":"type-mismatch-error-recovery"},{"level":4,"text":"Common Component Type Safety Pitfalls","id":"common-component-type-safety-pitfalls"},{"level":3,"text":"System Execution Error Recovery","id":"system-execution-error-recovery"},{"level":4,"text":"Mental Model: Circuit Breakers in Electrical Systems","id":"mental-model-circuit-breakers-in-electrical-systems"},{"level":4,"text":"System Error Classification","id":"system-error-classification"},{"level":4,"text":"Circuit Breaker State Machine","id":"circuit-breaker-state-machine"},{"level":4,"text":"Error Context Collection","id":"error-context-collection"},{"level":4,"text":"System Dependency Management","id":"system-dependency-management"},{"level":4,"text":"Common System Execution Pitfalls","id":"common-system-execution-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Entity Validation Infrastructure","id":"entity-validation-infrastructure"},{"level":4,"text":"Component Type Safety Infrastructure","id":"component-type-safety-infrastructure"},{"level":4,"text":"System Circuit Breaker Infrastructure","id":"system-circuit-breaker-infrastructure"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Testing Strategy","id":"testing-strategy"},{"level":3,"text":"Mental Model: Quality Control in a Manufacturing Pipeline","id":"mental-model-quality-control-in-a-manufacturing-pipeline"},{"level":3,"text":"Milestone Checkpoint Testing","id":"milestone-checkpoint-testing"},{"level":4,"text":"Milestone 1: Entity Manager Checkpoint","id":"milestone-1-entity-manager-checkpoint"},{"level":4,"text":"Milestone 2: Component Storage Checkpoint","id":"milestone-2-component-storage-checkpoint"},{"level":4,"text":"Milestone 3: System Interface Checkpoint","id":"milestone-3-system-interface-checkpoint"},{"level":4,"text":"Milestone 4: Archetype Storage Checkpoint","id":"milestone-4-archetype-storage-checkpoint"},{"level":3,"text":"Performance Benchmarking","id":"performance-benchmarking"},{"level":4,"text":"Cache Miss Measurement Strategy","id":"cache-miss-measurement-strategy"},{"level":4,"text":"Iteration Speed Comparisons","id":"iteration-speed-comparisons"},{"level":4,"text":"Memory Usage Analysis","id":"memory-usage-analysis"},{"level":4,"text":"Performance Regression Detection","id":"performance-regression-detection"},{"level":3,"text":"Correctness Verification","id":"correctness-verification"},{"level":4,"text":"Entity Lifecycle Consistency","id":"entity-lifecycle-consistency"},{"level":4,"text":"Component Data Integrity","id":"component-data-integrity"},{"level":4,"text":"System Execution Correctness","id":"system-execution-correctness"},{"level":4,"text":"Edge Case Handling Verification","id":"edge-case-handling-verification"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Test Infrastructure Starter Code","id":"test-infrastructure-starter-code"},{"level":4,"text":"Core Test Skeleton Code","id":"core-test-skeleton-code"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Performance Benchmark Infrastructure","id":"performance-benchmark-infrastructure"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"Memory and Corruption Issues","id":"memory-and-corruption-issues"},{"level":3,"text":"Performance Problem Diagnosis","id":"performance-problem-diagnosis"},{"level":3,"text":"System Logic Debugging","id":"system-logic-debugging"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Future Extensions","id":"future-extensions"},{"level":3,"text":"Multi-Threading Extensions","id":"multi-threading-extensions"},{"level":4,"text":"Mental Model: Parallel Assembly Lines","id":"mental-model-parallel-assembly-lines"},{"level":4,"text":"Common Multi-Threading Pitfalls","id":"common-multi-threading-pitfalls"},{"level":3,"text":"Advanced ECS Features","id":"advanced-ecs-features"},{"level":4,"text":"Mental Model: Smart Factory with Automation","id":"mental-model-smart-factory-with-automation"},{"level":4,"text":"Common Advanced Feature Pitfalls","id":"common-advanced-feature-pitfalls"},{"level":3,"text":"Development Tooling","id":"development-tooling"},{"level":4,"text":"Mental Model: Factory Control Room","id":"mental-model-factory-control-room"},{"level":4,"text":"Common Development Tooling Pitfalls","id":"common-development-tooling-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton","id":"core-logic-skeleton"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations Table","id":"technology-recommendations-table"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Glossary","id":"glossary"},{"level":3,"text":"Mental Model: Technical Dictionary with Cross-References","id":"mental-model-technical-dictionary-with-cross-references"},{"level":3,"text":"Core ECS Terminology","id":"core-ecs-terminology"},{"level":3,"text":"Entity Management Concepts","id":"entity-management-concepts"},{"level":3,"text":"Component Storage Architecture","id":"component-storage-architecture"},{"level":3,"text":"System Execution Framework","id":"system-execution-framework"},{"level":3,"text":"Performance and Optimization Terms","id":"performance-and-optimization-terms"},{"level":3,"text":"Advanced Archetype Concepts","id":"advanced-archetype-concepts"},{"level":3,"text":"Type Safety and Validation","id":"type-safety-and-validation"},{"level":3,"text":"Error Handling and Recovery","id":"error-handling-and-recovery"},{"level":3,"text":"Testing and Debugging Terminology","id":"testing-and-debugging-terminology"},{"level":3,"text":"Data Structure Implementation Details","id":"data-structure-implementation-details"},{"level":3,"text":"Game Development Context","id":"game-development-context"},{"level":3,"text":"Common Anti-Patterns and Pitfalls","id":"common-anti-patterns-and-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Essential Terms by Milestone","id":"essential-terms-by-milestone"},{"level":4,"text":"Performance-Related Term Clusters","id":"performance-related-term-clusters"},{"level":4,"text":"Error Handling Term Relationships","id":"error-handling-term-relationships"}],"title":"ECS Architecture: Design Document","markdown":"# ECS Architecture: Design Document\n\n\n## Overview\n\nAn Entity-Component-System (ECS) architecture that separates game objects into entities (IDs), components (data), and systems (logic) to achieve data-oriented design principles. The key architectural challenge is maintaining cache-friendly memory layouts while providing flexible entity composition and efficient query mechanisms for high-performance game engines.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n## Context and Problem Statement\n\n> **Milestone(s):** Foundation for all milestones — understanding why ECS architecture is necessary\n\nModern game development faces a fundamental performance crisis rooted in how we organize game object data and behavior. While object-oriented programming provides excellent abstraction and code organization for many software domains, it creates severe performance bottlenecks in games where thousands of entities must be processed every frame within strict timing constraints. This section explores the specific problems that traditional object-oriented game architectures create and how Entity-Component-System (ECS) architecture addresses these issues through data-oriented design principles.\n\n### Object-Oriented Game Architecture Problems\n\nTraditional game engines organize game objects using object-oriented hierarchies where each game entity is represented as an object containing both data (properties) and behavior (methods). While this approach feels intuitive to programmers — after all, a \"Tank\" object naturally contains health, position, and firing logic — it creates three critical performance problems that become insurmountable as games scale to thousands of entities.\n\n**Mental Model: The Library Maze**\nThink of traditional object-oriented game architecture like a library where related books are scattered across different floors and wings. When you need to research a topic, you must walk from the history section on the third floor to the science wing in the basement, then to the philosophy section in the east building. Each book (object) contains everything about one topic (entity), but gathering information about many similar topics requires constantly traveling between distant locations. Your research session becomes dominated by walking time rather than actual reading.\n\n#### Cache Miss Cascade Problems\n\nModern processors are fast, but only when data lives in CPU cache. Main memory access takes 100-300 CPU cycles, while cache access takes 1-4 cycles — a 100x performance difference. Object-oriented game architectures systematically defeat CPU caches through scattered memory layouts and unpredictable access patterns.\n\nConsider a typical object-oriented game entity hierarchy:\n\n| Class Level | Memory Layout | Cache Behavior |\n|-------------|---------------|----------------|\n| `GameObject` base class | Virtual function table pointer, entity ID, transform | May be cache-friendly for transform updates |\n| `Actor` derived class | Health, team affiliation, AI state | Scattered across memory as objects are created |\n| `Tank` concrete class | Armor value, ammunition count, turret rotation | Each tank object non-contiguous with other tanks |\n| Component pointers | Rendering, physics, audio components | Each pointer dereference likely cache miss |\n\nWhen a movement system needs to update positions for 1000 tanks, the processor must load 1000 separate memory locations from main RAM. Each tank object contains the needed position data, but it's surrounded by unrelated data like ammunition counts and AI state that the movement system doesn't need. The CPU cache fills with irrelevant data, forcing constant memory fetches.\n\nThe problem compounds when multiple systems run in sequence. A physics system updates positions, evicting cache lines. Then a rendering system needs those same positions, but they've been evicted, causing another round of memory fetches. Each system thrashes the cache with its own access patterns.\n\n| System | Data Needed | Data Actually Loaded | Cache Efficiency |\n|--------|-------------|---------------------|------------------|\n| Movement System | Position, velocity (8 bytes) | Entire Tank object (200+ bytes) | ~4% efficient |\n| Physics System | Position, mass, collision shape (24 bytes) | Entire Tank object (200+ bytes) | ~12% efficient |\n| Rendering System | Position, mesh, textures (16 bytes) | Entire Tank object (200+ bytes) | ~8% efficient |\n\n> The fundamental insight is that object-oriented designs optimize for human conceptual organization (all tank data together) while processors optimize for computational access patterns (all position data together).\n\n#### Inheritance Hierarchy Complexity\n\nObject-oriented game engines typically organize entities using deep inheritance hierarchies that seemed logical during design but create maintenance nightmares and performance problems as games evolve.\n\nA typical game entity hierarchy might look like:\n\n| Class | Inherits From | Adds Fields | Common Problems |\n|-------|---------------|-------------|-----------------|\n| `GameObject` | None | ID, transform, active flag | Base becomes bloated with \"universal\" features |\n| `Actor` | `GameObject` | Health, team, AI state | Forces all actors to have AI even if unnecessary |\n| `Vehicle` | `Actor` | Speed, fuel, driver | What about remote-controlled vehicles without drivers? |\n| `Tank` | `Vehicle` | Armor, ammunition | Works fine initially |\n| `Hovercraft` | `Vehicle` | Hover height, ground clearance | Inherits fuel system but uses energy instead |\n| `FlyingTank` | ??? | Both tank and aircraft properties | Multiple inheritance or awkward compromises |\n\nThe hierarchy looks clean on paper, but real game requirements break these neat categories. What happens when you need:\n- A tank that can also fly (hover tank)?\n- A vehicle driven by AI that sometimes becomes player-controlled?\n- A destructible building that gains vehicle properties when it becomes a mobile fortress?\n- Temporary power-ups that add vehicle-like movement to infantry units?\n\nEach new requirement forces awkward compromises:\n1. **Bloated base classes**: Adding fields to `GameObject` to handle edge cases, wasting memory for entities that don't need them\n2. **Deep inheritance chains**: Seven-level hierarchies where changes to base classes break multiple derived classes\n3. **Interface proliferation**: Adding `IDamageable`, `IMoveable`, `ITargetable` interfaces that create complex multiple inheritance scenarios\n4. **Code duplication**: Similar behavior implemented differently across inheritance branches\n\n> **Decision: Why Traditional Inheritance Fails for Game Entities**\n> - **Context**: Game entities need flexible, runtime-configurable behavior combinations that don't fit neat taxonomies\n> - **Options Considered**: Deep inheritance hierarchies, multiple inheritance, interface-based composition\n> - **Decision**: Move away from inheritance-based entity organization entirely\n> - **Rationale**: Games require \"composition over inheritance\" because entity behavior combinations are data-driven, not statically determinable\n> - **Consequences**: Need new architecture that supports runtime behavior composition — this motivates ECS design\n\n#### Scattered Data Access Patterns\n\nObject-oriented architectures scatter related computational data across memory, forcing systems to follow pointer chains and load irrelevant data. This creates predictable performance problems that compound as entity counts increase.\n\nConsider how different game systems access entity data in an object-oriented design:\n\n**Scenario: 1000 tanks in a battle**\n\n| Frame Operation | Memory Access Pattern | Performance Impact |\n|----------------|----------------------|-------------------|\n| Physics update | Visit each tank object → follow physics component pointer → update position | 2000 memory locations, scattered across heap |\n| Rendering update | Visit each tank object → follow render component pointer → extract transform + model | Another 2000 locations, different scatter pattern |\n| AI update | Visit each tank object → follow AI component pointer → read nearby enemies | 3000+ locations (includes enemy lookups) |\n| Audio update | Visit each tank object → follow audio component pointer → calculate 3D position | 2000 more scattered accesses |\n\nEach system follows different pointer chains to different memory locations. There's no spatial locality because:\n1. Tank objects were allocated at different times, scattered across the heap\n2. Component objects are allocated separately, pointed to from tank objects\n3. Each system needs different subsets of data, but must load entire objects\n\nThe processor spends more time waiting for memory than executing game logic. Profilers show 70-80% of frame time spent on memory stalls rather than computation.\n\n**Pointer Chasing Anti-Pattern**\n\nObject-oriented designs often create \"pointer chasing\" scenarios where accessing related data requires following multiple indirections:\n\n```\nTank object → AI Component → Target pointer → Enemy Tank → Health Component → Current health value\n```\n\nEach arrow represents a potential cache miss. To answer \"how much health does my target have?\", the processor might perform 5 separate memory fetches from scattered locations.\n\n| Access Step | Data Loaded | Bytes Useful | Bytes Wasted |\n|-------------|-------------|--------------|--------------|\n| Load tank object | Tank properties (200 bytes) | AI component pointer (8 bytes) | 192 bytes |\n| Load AI component | AI state (150 bytes) | Target pointer (8 bytes) | 142 bytes |\n| Load enemy tank | Enemy tank properties (200 bytes) | Health component pointer (8 bytes) | 192 bytes |\n| Load health component | Health data (50 bytes) | Current health (4 bytes) | 46 bytes |\n\nTo extract 4 bytes of health data, the system loaded 600 bytes total — a 99.3% waste ratio. Multiply this by thousands of entities and dozens of systems per frame, and the performance cost becomes prohibitive.\n\n### Data-Oriented Design Benefits\n\nData-oriented design flips the traditional object-oriented approach by organizing data around computational access patterns rather than conceptual object boundaries. Instead of asking \"what data does a Tank object contain?\", data-oriented design asks \"what data does the movement system need, and how can we lay it out for maximum cache efficiency?\"\n\n**Mental Model: The Organized Warehouse**\nThink of data-oriented design like a well-organized warehouse where inventory is grouped by how it's used rather than what company manufactured it. All the heavy items are in one section with forklifts, all the fragile items are in another section with special handling equipment, and all the small frequently-accessed items are near the shipping dock. When workers need to fulfill orders, they can efficiently gather similar items without constantly traveling between distant warehouse sections.\n\n#### Cache Locality Optimization\n\nData-oriented design achieves dramatic performance improvements by organizing data to match how systems actually access it. Instead of scattering tank data across individual objects, we group all position data together, all velocity data together, and all health data together.\n\n**Contiguous Array Benefits**\n\nConsider how a movement system processes entity positions in a data-oriented layout:\n\n| Data Organization | Memory Layout | Cache Performance |\n|------------------|---------------|------------------|\n| Array of positions | `[pos1][pos2][pos3][pos4]...` | Sequential access, perfect cache line utilization |\n| Array of velocities | `[vel1][vel2][vel3][vel4]...` | Adjacent to positions, minimal cache misses |\n| Array of rotations | `[rot1][rot2][rot3][rot4]...` | Predictable access pattern, good prefetching |\n\nWhen the movement system updates 1000 entities:\n1. Load position array starting address into cache\n2. Process positions sequentially — each cache line contains 8-16 positions\n3. Load velocity array — processor prefetches next cache lines automatically\n4. Update positions using vectorized operations across multiple entities simultaneously\n\n| Access Pattern | Cache Lines Used | Entities Processed | Cache Efficiency |\n|----------------|------------------|-------------------|------------------|\n| Sequential array access | 64 cache lines | 1000 entities | ~95% efficient |\n| Object-oriented scatter | 1000+ cache lines | 1000 entities | ~5% efficient |\n\nThe same computation that took 1000 memory fetches now takes 64, and most are automatically prefetched by the processor's prediction mechanisms.\n\n**Memory Access Predictability**\n\nData-oriented layouts create predictable access patterns that processors can optimize automatically:\n\n1. **Sequential prefetching**: CPU automatically loads next cache lines when it detects linear access patterns\n2. **Stride prediction**: CPU learns to prefetch every Nth element for regular patterns  \n3. **Branch prediction**: Simple loops over arrays have highly predictable branching\n4. **TLB efficiency**: Fewer distinct memory pages accessed means fewer translation lookups\n\n| Performance Metric | Object-Oriented | Data-Oriented | Improvement |\n|--------------------|-----------------|---------------|-------------|\n| Cache miss rate | 60-80% | 5-10% | 8-15x better |\n| Memory bandwidth utilization | 10-20% | 80-95% | 4-8x better |\n| Branch prediction accuracy | 70-85% | 95-99% | 20-40% better |\n| TLB miss rate | 5-15% | 0.1-1% | 10-50x better |\n\n#### SIMD-Friendly Operations\n\nSingle Instruction, Multiple Data (SIMD) processing allows processors to perform the same operation on multiple data elements simultaneously. Modern processors can add 4-8 floating-point values in a single instruction, but only if the data is properly arranged.\n\n**Vectorized Computation Opportunities**\n\nData-oriented layouts enable automatic vectorization by compilers and explicit SIMD optimization by developers:\n\n| Operation | Scalar Processing (Object-Oriented) | Vectorized Processing (Data-Oriented) |\n|-----------|-----------------------------------|-------------------------------------|\n| Position updates | Update one tank position per instruction | Update 4-8 positions per instruction |\n| Distance calculations | One distance calculation per loop | 4-8 distance calculations per loop |\n| Health regeneration | One health update per instruction | 4-8 health updates per instruction |\n| Collision detection | Compare one entity pair per iteration | Compare multiple pairs with vector operations |\n\n**Example: Movement System Performance**\n\nConsider updating positions for 1000 entities:\n\n| Approach | Instructions per Entity | Total Instructions | SIMD Utilization |\n|----------|------------------------|-------------------|------------------|\n| Object-oriented | 12 instructions (load, add, store with cache misses) | 12,000 instructions | 0% - scalar only |\n| Data-oriented scalar | 3 instructions (vectorized load, add, store) | 3,000 instructions | 0% - but cache friendly |\n| Data-oriented SIMD | 3 instructions processing 4 entities each | 750 instructions | 100% - full vectorization |\n\nThe data-oriented SIMD approach is 16x faster than object-oriented, combining cache efficiency with vectorized computation.\n\n**Structure of Arrays vs Array of Structures**\n\nThe key insight is organizing data as \"Structure of Arrays\" (SoA) rather than \"Array of Structures\" (AoS):\n\n| Organization | Memory Layout | SIMD Compatibility | Cache Efficiency |\n|--------------|---------------|-------------------|------------------|\n| Array of Structures (OOP) | `[x1,y1,z1,health1][x2,y2,z2,health2]...` | Poor - mixed data types | Poor - loads unused data |\n| Structure of Arrays (DOD) | `[x1,x2,x3,x4...][y1,y2,y3,y4...][z1,z2,z3,z4...]` | Excellent - homogeneous data | Excellent - only needed data |\n\nWhen a movement system needs only X coordinates, the Structure of Arrays layout provides a contiguous array of X values perfect for SIMD processing, while Array of Structures forces loading irrelevant Y, Z, and health data.\n\n#### Composition Over Inheritance\n\nData-oriented design naturally leads to composition-based entity architectures where entities are collections of data components rather than instances of class hierarchies. This provides the flexibility that inheritance hierarchies promise but rarely deliver.\n\n**Component-Based Composition Model**\n\nInstead of entities inheriting behavior from class hierarchies, entities are composed from independent data components:\n\n| Entity Type | Component Composition | Runtime Flexibility |\n|-------------|----------------------|-------------------|\n| Tank | Position + Velocity + Health + Armor + Weapon | Can add/remove components dynamically |\n| Infantry | Position + Velocity + Health + Equipment | Same components, different values |\n| Building | Position + Health + Armor | No velocity - stationary |\n| Projectile | Position + Velocity + Lifetime | No health - expires by time |\n| Powerup | Position + Velocity + Effect + Lifetime | Grants temporary abilities |\n\nEach component is a simple data structure with no behavior. Systems provide behavior by operating on entities that have specific component combinations.\n\n**Runtime Composition Benefits**\n\nComponent composition enables runtime behavior changes that inheritance hierarchies cannot support:\n\n| Scenario | Object-Oriented Solution | Component-Based Solution |\n|----------|-------------------------|-------------------------|\n| Tank loses engine | Create new \"DisabledTank\" subclass? | Remove Velocity component |\n| Infantry enters vehicle | Switch object type to \"VehicleDriver\"? | Add Vehicle component |\n| Building becomes mobile | Multiple inheritance from Building + Vehicle? | Add Velocity component |\n| Temporary invisibility | Add boolean flag to base GameObject? | Add TemporaryInvisibility component |\n\nComponents can be added and removed at runtime without changing entity types or copying data between different object instances.\n\n**System Specialization**\n\nSystems operate only on entities with required components, creating natural specialization without inheritance complexity:\n\n| System | Required Components | Entities Processed | Behavior |\n|--------|-------------------|-------------------|----------|\n| Movement System | Position + Velocity | Tanks, infantry, projectiles | Updates positions |\n| Combat System | Health + Position | Tanks, infantry, buildings | Handles damage |\n| Rendering System | Position + Visual | All visible entities | Draws to screen |\n| AI System | AI + Position + Health | NPCs only | Makes decisions |\n\nEach system is simple and focused. There's no need for complex inheritance hierarchies or interface implementations — systems naturally process exactly the entities that need their behavior.\n\n> **Decision: Component Composition Architecture**\n> - **Context**: Need flexible entity behavior combinations without inheritance complexity\n> - **Options Considered**: Deep inheritance, multiple inheritance, interface-based design, component composition\n> - **Decision**: Use component composition where entities are collections of data components\n> - **Rationale**: Enables runtime behavior changes, eliminates inheritance complexity, supports data-oriented layout\n> - **Consequences**: Need system architecture to provide behavior, requires component storage and query mechanisms\n\n### Existing ECS Approaches Comparison\n\nThe Entity-Component-System pattern has evolved through several implementation approaches, each with different trade-offs between simplicity, performance, and memory usage. Understanding these approaches helps choose the right implementation strategy for different game requirements.\n\n**Mental Model: Database Storage Strategies**\nThink of ECS component storage like different database storage strategies. You can store customer data in separate files per customer (like object-oriented approaches), in separate tables per data type (like simple component arrays), or in pre-organized views grouping customers by their attribute combinations (like archetype-based storage). Each approach optimizes for different query patterns and data access needs.\n\n#### Simple Component Arrays Approach\n\nThe simplest ECS implementation stores each component type in separate arrays, using sparse arrays or hash maps to associate entity IDs with component indices. This approach is straightforward to implement and reason about.\n\n**Storage Organization**\n\n| Component Type | Storage Structure | Entity-to-Index Mapping | Memory Layout |\n|----------------|------------------|------------------------|---------------|\n| Position | `Array<Position>` | `Map<EntityID, Index>` | Contiguous position data |\n| Velocity | `Array<Velocity>` | `Map<EntityID, Index>` | Contiguous velocity data |\n| Health | `Array<Health>` | `Map<EntityID, Index>` | Contiguous health data |\n\nEach component array contains only entities that have that component. An entity with Position and Health components would have entries in two arrays, potentially at different indices.\n\n**Query Processing**\n\nTo find entities with both Position and Velocity components:\n1. Iterate through Position component indices\n2. For each entity ID, check if it also exists in Velocity component indices\n3. If both exist, include entity in query results\n\n| Query Type | Process Steps | Time Complexity | Cache Performance |\n|------------|--------------|-----------------|------------------|\n| Single component | Iterate one array | O(n) where n = entities with component | Excellent - sequential access |\n| Two components | Iterate first, lookup second | O(n + m log m) with hash maps | Good - some indirection |\n| Three+ components | Multiple intersections | O(n * log m * log k...) | Fair - more lookups |\n\n**Simple Arrays Trade-offs**\n\n| Aspect | Advantages | Disadvantages |\n|--------|------------|--------------|\n| Implementation | Simple to understand and implement | Becomes complex with many component types |\n| Memory Usage | Only stores components that exist | Hash maps have memory overhead |\n| Query Performance | Fast for single-component queries | Slow for multi-component queries |\n| Cache Efficiency | Excellent for individual component iteration | Poor for multi-component access |\n| Entity Modification | Easy to add/remove components | May require multiple hash map updates |\n\nThis approach works well for simple games with few component types and queries, but performance degrades as query complexity increases.\n\n#### Sparse Set Storage Approach\n\nSparse sets provide an elegant solution to the entity-to-component mapping problem, offering O(1) addition, removal, and lookup operations while maintaining cache-friendly iteration over dense component arrays.\n\n**Sparse Set Data Structure**\n\nA sparse set consists of two arrays that work together to provide bidirectional mapping:\n\n| Array Type | Purpose | Contents | Access Pattern |\n|------------|---------|----------|----------------|\n| Dense Array | Stores actual component data | `[component_0, component_1, component_2, ...]` | Sequential iteration |\n| Sparse Array | Maps entity IDs to dense indices | `[dense_index_for_entity_0, invalid, dense_index_for_entity_2, ...]` | Random access by entity ID |\n| Dense-to-Entity | Maps dense indices to entity IDs | `[entity_0, entity_1, entity_2, ...]` | Reverse lookup for iteration |\n\n**Sparse Set Operations**\n\n| Operation | Algorithm | Time Complexity | Cache Impact |\n|-----------|-----------|----------------|--------------|\n| Add Component | 1. Append to dense array<br/>2. Store dense index in sparse[entity_id]<br/>3. Store entity_id in dense-to-entity array | O(1) | One cache line per array |\n| Remove Component | 1. Swap-remove from dense array<br/>2. Update sparse array for swapped entity<br/>3. Invalidate sparse[entity_id] | O(1) | Minimal cache impact |\n| Lookup Component | 1. Check sparse[entity_id] < dense.size()<br/>2. Verify dense_to_entity[sparse[entity_id]] == entity_id | O(1) | Two cache line accesses |\n| Iterate All | Iterate dense array sequentially | O(n) | Perfect cache line utilization |\n\n**Multi-Component Query Processing**\n\nSparse sets enable efficient multi-component queries through set intersection algorithms:\n\n1. **Find smallest component set**: Query components with fewest entities first\n2. **Iterate smallest set**: Check each entity in smallest component's dense array  \n3. **Validate other components**: Use O(1) sparse set lookups to verify entity has other required components\n4. **Build result set**: Collect entities that have all required components\n\n| Query Size | Processing Strategy | Expected Performance | Cache Behavior |\n|------------|-------------------|---------------------|----------------|\n| 1 component | Direct dense iteration | O(n) where n = entities with component | Excellent sequential access |\n| 2 components | Iterate smaller, lookup larger | O(min(n,m)) | Good - mostly sequential |\n| 3+ components | Iterate smallest, lookup others | O(smallest_set_size) | Good - predictable pattern |\n\n**Sparse Set Trade-offs**\n\n| Aspect | Advantages | Disadvantages |\n|--------|------------|--------------|\n| Lookup Performance | O(1) entity-to-component access | Requires entity ID validation check |\n| Memory Efficiency | Dense packing of existing components | Sparse array sized by max entity ID |\n| Query Performance | Fast multi-component queries | Requires intersection algorithms |\n| Implementation | Moderate complexity, well-understood | Swap-remove semantics can surprise users |\n| Cache Efficiency | Excellent iteration, good lookup | Sparse array may have poor locality |\n\nSparse sets provide the best balance of performance and simplicity for most ECS implementations, offering fast queries without the complexity of archetype-based storage.\n\n#### Archetype-Based Storage Approach\n\nArchetype-based storage represents the most advanced ECS approach, grouping entities by their exact component combinations into separate storage \"tables\" for maximum cache efficiency and query performance.\n\n**Archetype Organization Concept**\n\nAn archetype represents a unique combination of component types. All entities with identical component sets are stored together in contiguous memory:\n\n| Archetype | Component Combination | Entity Storage | Memory Layout |\n|-----------|---------------------|----------------|---------------|\n| Archetype A | Position + Velocity | Entities 1,5,7,12... | All Position data contiguous, all Velocity data contiguous |\n| Archetype B | Position + Health | Entities 2,8,9,15... | All Position data contiguous, all Health data contiguous |\n| Archetype C | Position + Velocity + Health | Entities 3,6,11... | All three component types contiguous |\n\nEach archetype maintains its own set of component arrays, and entities with identical component combinations share the same archetype storage.\n\n**Archetype Query Performance**\n\nQueries become extremely fast because the system can identify matching archetypes once and then iterate their entities with perfect cache locality:\n\n| Query | Matching Archetypes | Processing | Performance |\n|-------|-------------------|------------|-------------|\n| Position only | A, B, C | Iterate position arrays in each archetype | O(matching_entities) |\n| Position + Velocity | A, C | Iterate both archetypes' arrays sequentially | Perfect cache locality |\n| Position + Health | B, C | Skip archetype A entirely | No wasted iteration |\n\nThere's no intersection logic needed — the archetype organization pre-computes which entities match each possible query.\n\n**Archetype Transitions**\n\nThe complexity in archetype systems comes from handling component additions and removals, which require moving entities between archetypes:\n\n| Operation | Process | Performance Impact | Implementation Complexity |\n|-----------|---------|-------------------|--------------------------|\n| Add Component | 1. Find or create destination archetype<br/>2. Copy entity's components to new archetype<br/>3. Remove entity from old archetype<br/>4. Update entity ID mapping | O(components_per_entity) | Complex archetype graph management |\n| Remove Component | Similar to add — move to archetype without the component | O(components_per_entity) | Must handle archetype cleanup |\n| Entity Destruction | Remove from current archetype, no transition needed | O(1) swap-remove | Simpler than transitions |\n\n**Archetype Implementation Challenges**\n\n| Challenge | Problem | Solution Approaches | Trade-offs |\n|-----------|---------|-------------------|------------|\n| Archetype Explosion | Too many unique component combinations create many small archetypes | Group similar archetypes, component filtering | Complexity vs. cache efficiency |\n| Transition Overhead | Moving entities between archetypes is expensive | Batch transitions, lazy updates | Latency vs. throughput |\n| Memory Management | Each archetype needs its own storage allocation | Chunk-based allocation, archetype pooling | Memory usage vs. allocation overhead |\n| Iteration Complexity | Must iterate multiple archetypes for single query | Archetype iteration abstractions | Performance vs. API simplicity |\n\n**Archetype Performance Characteristics**\n\n| Workload Type | Performance | Best Use Case |\n|---------------|-------------|---------------|\n| Large homogeneous entity groups | Excellent | RTS games with thousands of similar units |\n| Many different component combinations | Good | Complex RPGs with diverse entity types |\n| Frequent component changes | Poor | Highly dynamic gameplay with temporary effects |\n| Simple queries over large datasets | Excellent | Physics simulation, rendering |\n\n> **Decision: Storage Strategy Selection**\n> - **Context**: Need to choose component storage approach balancing performance, complexity, and flexibility\n> - **Options Considered**: Simple arrays, sparse sets, archetype-based storage\n> - **Decision**: Implement sparse set approach with optional archetype extension\n> - **Rationale**: Sparse sets provide good performance for most games without archetype complexity; archetypes can be added later for optimization\n> - **Consequences**: Moderate implementation complexity, good query performance, straightforward debugging\n\n#### Implementation Strategy Recommendation\n\nBased on the trade-offs analysis, this design document recommends a **sparse set foundation with optional archetype extension**:\n\n| Implementation Phase | Storage Approach | Target Audience | Performance Characteristics |\n|---------------------|-----------------|----------------|---------------------------|\n| Phase 1 (Core) | Sparse sets for component storage | Learning ECS concepts | Good performance, moderate complexity |\n| Phase 2 (Extension) | Archetype-based storage optimization | Advanced performance tuning | Excellent performance, high complexity |\n\nThis progression allows developers to:\n1. **Learn ECS concepts** with a comprehensible sparse set implementation\n2. **Achieve good performance** for most game scenarios  \n3. **Extend to archetypes** when profiling reveals performance bottlenecks\n4. **Understand trade-offs** by implementing both approaches\n\nThe sparse set foundation provides solid performance while remaining debuggable and understandable. The archetype extension demonstrates advanced ECS optimization techniques without overwhelming beginners with unnecessary complexity.\n\n### Implementation Guidance\n\nThis section provides practical guidance for implementing the ECS concepts discussed above, targeting developers who understand the design rationale and need concrete technical direction.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option | Rationale |\n|-----------|---------------|-----------------|-----------|\n| Entity ID Generation | Incremental counter with free list | Generational indices with packed storage | Simple approach sufficient for learning |\n| Component Storage | `std::vector` with `std::unordered_map` | Custom sparse set implementation | STL containers provide good starting point |\n| Type Safety | Template specialization | Compile-time type IDs with `typeid` | Templates catch errors at compile time |\n| Memory Management | Standard allocators | Custom pool allocators | Standard allocators simplify initial implementation |\n\n#### Recommended Project Structure\n\nUnderstanding how ECS components fit together helps avoid the common mistake of putting all code in a single file:\n\n```\necs-project/\n├── src/\n│   ├── core/\n│   │   ├── entity.h              ← Entity ID and generation definitions\n│   │   ├── entity.cpp\n│   │   └── entity_manager.h      ← Entity lifecycle management\n│   │   └── entity_manager.cpp\n│   ├── components/\n│   │   ├── component_storage.h   ← Sparse set storage implementation\n│   │   ├── component_storage.cpp\n│   │   └── component_registry.h  ← Type registration and lookup\n│   │   └── component_registry.cpp\n│   ├── systems/\n│   │   ├── system.h              ← Base system interface\n│   │   ├── system_manager.h      ← System execution and ordering\n│   │   └── system_manager.cpp\n│   ├── world/\n│   │   ├── world.h               ← Main ECS coordinator\n│   │   └── world.cpp\n│   └── examples/\n│       ├── game_components.h     ← Sample Position, Velocity, Health components\n│       ├── movement_system.cpp   ← Example system implementation\n│       └── main.cpp              ← Demo application\n├── tests/\n│   ├── entity_tests.cpp\n│   ├── component_tests.cpp\n│   └── system_tests.cpp\n└── include/\n    └── ecs/                      ← Public API headers\n        ├── ecs.h\n        └── component_types.h\n```\n\nThis structure separates concerns clearly: entities manage IDs, components handle storage, systems provide behavior, and world coordinates everything.\n\n#### Core Data Type Foundations\n\nStart with these fundamental types that all other ECS components depend on:\n\n```cpp\n// entity.h - Core entity identification\n#include <cstdint>\n#include <limits>\n\nusing EntityID = std::uint32_t;\nusing Generation = std::uint32_t;\n\nstruct Entity {\n    EntityID id;\n    Generation generation;\n    \n    // TODO: Implement equality and comparison operators\n    // TODO: Add invalid entity constant\n    // TODO: Consider hash function for use in containers\n};\n\n// component_id.h - Type-safe component identification\nusing ComponentTypeID = std::uint32_t;\n\ntemplate<typename T>\nComponentTypeID getComponentTypeID() {\n    // TODO: Generate unique ID for component type T\n    // Hint: Use static local variable to ensure same ID per type\n    // Hint: Consider using typeid(T).hash_code() or manual registration\n}\n```\n\n#### Entity Manager Implementation Skeleton\n\nThe Entity Manager handles the \"library card system\" for entity IDs:\n\n```cpp\n// entity_manager.h\n#include <vector>\n#include <queue>\n#include \"entity.h\"\n\nclass EntityManager {\nprivate:\n    std::vector<Generation> generations_;  // Generation per entity slot\n    std::queue<EntityID> free_entities_;   // Recycled entity IDs\n    EntityID next_entity_id_;              // Next new entity ID\n    \npublic:\n    EntityManager();\n    \n    // Creates new entity with unique ID and current generation\n    Entity createEntity();\n    \n    // Marks entity as destroyed, increments generation, adds to free list\n    void destroyEntity(Entity entity);\n    \n    // Validates that entity ID and generation are current\n    bool isAlive(Entity entity) const;\n    \n    // Returns all currently alive entities for iteration\n    // TODO: Implement efficient iteration without checking every slot\n    std::vector<Entity> getAliveEntities() const;\n    \nprivate:\n    // TODO: Handle entity ID overflow when next_entity_id_ wraps around\n    // TODO: Decide on initial capacity and growth strategy for generations_\n    // TODO: Consider maximum entity limit to prevent unbounded growth\n};\n```\n\nKey implementation notes:\n- `generations_[entity.id]` stores the current generation for that entity slot\n- When destroying an entity, increment `generations_[entity.id]` and add the ID to `free_entities_`\n- `isAlive()` returns `true` only if `generations_[entity.id] == entity.generation`\n- Reuse entity IDs from `free_entities_` before generating new ones\n\n#### Component Storage Implementation Skeleton\n\nImplement the \"warehouse with index cards\" sparse set storage:\n\n```cpp\n// component_storage.h\n#include <vector>\n#include <unordered_map>\n#include <memory>\n#include \"entity.h\"\n\n// Base class for type-erased component storage\nclass IComponentStorage {\npublic:\n    virtual ~IComponentStorage() = default;\n    virtual void removeEntity(Entity entity) = 0;\n    virtual bool hasComponent(Entity entity) const = 0;\n    virtual size_t size() const = 0;\n};\n\n// Template specialization for specific component types\ntemplate<typename T>\nclass ComponentStorage : public IComponentStorage {\nprivate:\n    std::vector<T> dense_;                     // Contiguous component data\n    std::vector<Entity> dense_to_entity_;     // Maps dense index to entity\n    std::unordered_map<EntityID, size_t> sparse_; // Maps entity ID to dense index\n    \npublic:\n    // Add component to entity, return reference for initialization\n    T& addComponent(Entity entity, T&& component = T{});\n    \n    // Remove component from entity (swap-remove from dense array)\n    void removeComponent(Entity entity);\n    \n    // Get component for entity (throws if not found)\n    T& getComponent(Entity entity);\n    const T& getComponent(Entity entity) const;\n    \n    // Check if entity has this component type\n    bool hasComponent(Entity entity) const override;\n    \n    // Iterator access for systems\n    auto begin() { return dense_.begin(); }\n    auto end() { return dense_.end(); }\n    \n    // Get entity corresponding to component at dense index\n    Entity getEntity(size_t dense_index) const;\n    \n    // IComponentStorage interface implementation\n    void removeEntity(Entity entity) override;\n    size_t size() const override { return dense_.size(); }\n    \nprivate:\n    // TODO: Implement swap-remove logic for removeComponent\n    // TODO: Validate entity references in debug builds\n    // TODO: Consider sparse array growth strategy\n    // TODO: Handle iterator invalidation during component removal\n};\n```\n\nCritical implementation details:\n- `dense_` stores actual component data for cache-friendly iteration\n- `sparse_` maps entity IDs to indices in `dense_` for O(1) lookup\n- `dense_to_entity_` enables reverse lookup from component to entity\n- Swap-remove maintains contiguous storage but changes entity positions\n\n#### System Interface Foundation\n\nCreate the \"assembly line stations\" framework:\n\n```cpp\n// system.h\n#include <vector>\n#include <memory>\n#include \"entity.h\"\n\nclass World; // Forward declaration\n\nclass System {\npublic:\n    virtual ~System() = default;\n    \n    // Called once per frame with time elapsed since last frame\n    virtual void update(World& world, float deltaTime) = 0;\n    \n    // Optional: called when system is registered with world\n    virtual void onRegister(World& world) {}\n    \n    // Optional: called when system is removed from world\n    virtual void onUnregister(World& world) {}\n};\n\n// system_manager.h\nclass SystemManager {\nprivate:\n    std::vector<std::unique_ptr<System>> systems_;\n    \npublic:\n    // Register system with execution priority (lower = earlier)\n    template<typename T, typename... Args>\n    void registerSystem(int priority, Args&&... args);\n    \n    // Update all systems in priority order\n    void updateSystems(World& world, float deltaTime);\n    \n    // Remove system by type\n    template<typename T>\n    void unregisterSystem();\n    \nprivate:\n    // TODO: Implement priority-based system ordering\n    // TODO: Handle system dependencies and cycles\n    // TODO: Consider system groups for batched execution\n};\n```\n\n#### World Coordinator Implementation\n\nThe World class coordinates all ECS components:\n\n```cpp\n// world.h\n#include \"entity_manager.h\"\n#include \"component_registry.h\"\n#include \"system_manager.h\"\n\nclass World {\nprivate:\n    EntityManager entity_manager_;\n    ComponentRegistry component_registry_;\n    SystemManager system_manager_;\n    \npublic:\n    // Entity operations\n    Entity createEntity() { return entity_manager_.createEntity(); }\n    void destroyEntity(Entity entity);\n    bool isAlive(Entity entity) const { return entity_manager_.isAlive(entity); }\n    \n    // Component operations\n    template<typename T>\n    T& addComponent(Entity entity, T&& component = T{});\n    \n    template<typename T>\n    void removeComponent(Entity entity);\n    \n    template<typename T>\n    T& getComponent(Entity entity);\n    \n    template<typename T>\n    bool hasComponent(Entity entity) const;\n    \n    // System operations\n    template<typename T, typename... Args>\n    void registerSystem(int priority, Args&&... args);\n    \n    // Query operations for systems\n    template<typename... Components>\n    auto query() -> QueryIterator<Components...>;\n    \n    // Main update loop\n    void update(float deltaTime);\n    \nprivate:\n    // TODO: Implement component cleanup when entity is destroyed\n    // TODO: Handle system registration before vs. after world setup\n    // TODO: Consider thread safety for multi-threaded systems\n};\n```\n\n#### Example Usage Pattern\n\nDemonstrate how all pieces work together:\n\n```cpp\n// examples/simple_game.cpp\n#include \"ecs/world.h\"\n\n// Sample component types\nstruct Position { float x, y; };\nstruct Velocity { float dx, dy; };\nstruct Health { int current, maximum; };\n\n// Sample system\nclass MovementSystem : public System {\npublic:\n    void update(World& world, float deltaTime) override {\n        // TODO: Query entities with Position + Velocity components\n        // TODO: Update each position by velocity * deltaTime\n        // Hint: for (auto [entity, pos, vel] : world.query<Position, Velocity>())\n    }\n};\n\nint main() {\n    World world;\n    \n    // Register systems\n    world.registerSystem<MovementSystem>(100); // Priority 100\n    \n    // Create entities\n    Entity tank = world.createEntity();\n    world.addComponent<Position>(tank, {10.0f, 5.0f});\n    world.addComponent<Velocity>(tank, {1.0f, 0.0f});\n    world.addComponent<Health>(tank, {100, 100});\n    \n    // Game loop\n    float deltaTime = 0.016f; // 60 FPS\n    for (int frame = 0; frame < 1000; ++frame) {\n        world.update(deltaTime);\n        \n        // TODO: Add rendering, input handling, etc.\n    }\n    \n    return 0;\n}\n```\n\n#### Milestone Checkpoints\n\nAfter implementing each major component, verify expected behavior:\n\n**Checkpoint 1: Entity Manager**\n- Run: `./build/entity_tests`\n- Expected: Entity creation returns unique IDs, destroyed entities fail `isAlive()` checks\n- Manual test: Create 1000 entities, destroy every other one, verify only alive entities remain\n\n**Checkpoint 2: Component Storage**  \n- Run: `./build/component_tests`\n- Expected: Components can be added/removed, iteration visits all components sequentially\n- Manual test: Add Position components to 100 entities, iterate and verify all positions are accessible\n\n**Checkpoint 3: System Integration**\n- Run: `./build/system_tests` \n- Expected: Systems execute in priority order, can query and modify components\n- Manual test: Create entities with Position+Velocity, run MovementSystem, verify positions update\n\n#### Language-Specific Implementation Notes\n\n**C++ Specific Guidance:**\n- Use `std::vector` for dense arrays — it provides cache-friendly contiguous storage\n- Use `std::unordered_map` for sparse mapping — prefer over `std::map` for O(1) average lookup\n- Leverage templates for type safety — `ComponentStorage<Position>` catches type errors at compile time\n- Consider `std::enable_if` for concept checking — ensure only valid component types are stored\n- Use move semantics for component addition — avoid unnecessary copies of large components\n\n**Memory Management Strategy:**\n- Start with standard allocators — optimize later only if profiling shows allocation hotspots\n- Use RAII for automatic cleanup — destructors handle component storage cleanup\n- Consider `std::unique_ptr` for system storage — clear ownership and automatic destruction\n- Reserve vector capacity when possible — reduces reallocations during entity creation bursts\n\n**Performance Monitoring:**\n- Add timing around `world.update()` to measure frame time\n- Count cache misses using `perf stat -e cache-misses ./your_program`\n- Profile with tools like `perf record` or Visual Studio diagnostics\n- Measure memory usage growth over long running sessions\n\n\n## Goals and Non-Goals\n\n> **Milestone(s):** Foundation for all milestones — defining scope and success criteria\n\nBefore diving into the technical details of our ECS implementation, we must clearly establish what we're building and, equally important, what we're not building. Think of this as **drawing the blueprint boundaries** — a construction project needs clear specifications about what features the building will have (number of floors, electrical capacity, plumbing) and what it won't include (swimming pool, helipad, underground garage). Without these boundaries, scope creep leads to an overly complex system that never gets completed.\n\nOur ECS architecture targets **learning-focused simplicity** rather than production-grade completeness. This means we prioritize understanding core ECS concepts and achieving solid performance fundamentals over advanced features that would obscure the underlying principles. The goal is to build a system where a junior developer can trace through every line of code and understand exactly why each design decision was made.\n\n### Functional Goals: Entity lifecycle, component attachment, system execution\n\nThe core functionality of our ECS revolves around three fundamental operations that mirror how game objects behave in practice. **Think of it like a theater production** — we need actors (entities), costumes and props (components), and directors for different aspects like lighting and sound (systems). The theater must support hiring and firing actors, changing their costumes between scenes, and having each director work with their relevant actors each night.\n\nOur functional requirements center on **entity lifecycle management** as the foundational capability. Every game object needs to come into existence with a unique identity, exist for some period while gameplay logic operates on it, and eventually be destroyed when no longer needed. This lifecycle must be robust enough to handle edge cases like accessing destroyed entities or creating thousands of entities in a single frame.\n\n| Functional Requirement | Description | Success Criteria |\n|------------------------|-------------|------------------|\n| **Entity Creation** | Generate unique entity identifiers | `createEntity()` returns unique `Entity` with valid `EntityID` and `Generation` |\n| **Entity Validation** | Check if entity reference is still valid | `isAlive(Entity)` correctly identifies destroyed entities using generation counter |\n| **Entity Destruction** | Clean up entity and mark ID for recycling | `destroyEntity(Entity)` removes all components and enables ID reuse |\n| **Entity Iteration** | Traverse all living entities efficiently | Support for range-based iteration over valid entities |\n\n**Component attachment and detachment** represents the second pillar of ECS functionality. Unlike traditional object-oriented inheritance where capabilities are fixed at compile time, ECS enables **dynamic composition** where entities gain and lose capabilities during runtime. A player entity might start with just `Position` and `Health` components, then gain a `Weapon` component when picking up a sword, and later acquire a `Poisoned` component when hit by a toxic attack.\n\nThe component system must maintain **type safety** while supporting this dynamic behavior. When a system requests a `Velocity` component from an entity, the system should either receive a valid reference to that component's data or get a clear indication that the entity doesn't possess that component type. Runtime type errors from casting or accessing wrong component types should be impossible.\n\n| Component Operation | Description | Success Criteria |\n|-------------------|-------------|------------------|\n| **Component Addition** | Attach typed data to entity | `addComponent<T>(Entity, T&&)` stores component and returns reference |\n| **Component Removal** | Detach component type from entity | `removeComponent<T>(Entity)` cleans up storage and updates indices |\n| **Component Access** | Retrieve component data safely | `getComponent<T>(Entity)` returns typed reference or throws exception |\n| **Component Queries** | Check component presence | `hasComponent<T>(Entity)` returns boolean without side effects |\n\n**System execution framework** provides the final functional pillar by orchestrating how game logic operates on entities and their components. Think of systems as **specialized assembly line stations** — the rendering system processes all entities with `Position` and `Sprite` components to draw them on screen, while the physics system handles entities with `Position`, `Velocity`, and `Collider` components to simulate movement and collisions.\n\nSystems must be able to **query for entities** matching their required component combinations and **iterate efficiently** over the results. The framework should handle system registration, execution ordering, and provide each system with the frame time delta for time-based updates.\n\n| System Capability | Description | Success Criteria |\n|-------------------|-------------|------------------|\n| **System Registration** | Add systems to execution pipeline | `registerSystem<T>(priority, args...)` adds system with specified order |\n| **Component Queries** | Find entities with required components | `query<Position, Velocity>()` returns iterator over matching entities |\n| **Frame Updates** | Execute all systems each frame | `update(World&, deltaTime)` calls each system in priority order |\n| **System Ordering** | Control execution sequence | Higher priority systems run before lower priority ones |\n\n### Performance Goals: Cache-friendly iteration, constant-time lookups, minimal allocations\n\nPerformance represents the primary motivation for choosing ECS over traditional object-oriented architectures. Our performance goals target **data-oriented design principles** that align with modern CPU architectures and memory hierarchies. **Think of CPU cache as a small, fast warehouse** right next to the assembly line — when components are stored contiguously in memory, the CPU can load entire chunks of related data in a single cache line, dramatically reducing the time spent waiting for memory access.\n\n**Cache-friendly iteration** stands as our most critical performance objective. When a physics system processes 10,000 entities with `Position` and `Velocity` components, those components should be stored in contiguous arrays that enable efficient sequential access patterns. This organization allows the CPU to prefetch subsequent data elements, utilize SIMD instructions for parallel processing, and minimize cache misses that can stall the processor for hundreds of cycles.\n\nTraditional object-oriented approaches store each game object as a separate allocation with components scattered throughout memory. When iterating over 10,000 game objects, each memory access potentially triggers a cache miss, resulting in poor performance that scales linearly with the number of objects. Our ECS implementation must demonstrate measurably better cache performance through contiguous component storage.\n\n| Performance Target | Measurement | Target Value | Verification Method |\n|-------------------|-------------|--------------|-------------------|\n| **Cache Miss Rate** | L1 data cache misses per component access | < 5% for sequential iteration | CPU performance counters during component iteration |\n| **Memory Bandwidth** | Bytes processed per second during system updates | > 1 GB/s for simple component updates | Benchmark 100k+ entities with timer measurements |\n| **Iteration Speed** | Entities processed per millisecond | > 100k entities/ms for simple operations | Microbenchmark with position update system |\n\n**Constant-time lookups** ensure that accessing components by entity ID doesn't become a bottleneck as the number of entities grows. When a collision system detects that two entities intersected, it needs to immediately access their `Health` and `Damage` components to apply effects. This lookup operation should take the same time whether the world contains 100 entities or 100,000 entities.\n\nWe achieve O(1) lookup performance through **sparse set data structures** that map entity IDs to component indices. The sparse set maintains two arrays — a sparse array indexed by entity ID that points into a dense array containing the actual component data. This approach combines constant-time random access with cache-friendly sequential iteration.\n\n| Lookup Operation | Time Complexity | Space Overhead | Implementation Strategy |\n|-----------------|-----------------|----------------|----------------------|\n| **Component Access by Entity** | O(1) average case | 2x index storage | Sparse set with entity ID as key |\n| **Component Existence Check** | O(1) worst case | Minimal | Sparse array bounds check + validity test |\n| **Entity Validation** | O(1) worst case | 4 bytes per entity | Generation counter comparison |\n\n**Minimal allocations** during gameplay prevents garbage collection pauses and memory fragmentation that can cause frame rate stutters. While entity creation and destruction inevitably require some memory management, component access and system updates should operate on pre-allocated storage without triggering additional heap allocations.\n\nOur allocation strategy emphasizes **upfront capacity planning** where component storage arrays are sized based on expected peak entity counts. When arrays need to grow, they expand in large chunks to amortize reallocation costs. System updates should perform zero allocations in the common case of processing existing entities.\n\n> **Design Principle: Zero-Allocation Hot Path**\n> \n> Once the world is populated with entities and components, the primary game loop should perform zero heap allocations during normal system updates. All temporary data structures, iterators, and component references should use stack allocation or reference existing heap storage.\n\n| Allocation Category | Frequency | Strategy | Measurement |\n|--------------------|-----------|----------|-------------|\n| **Entity Creation** | Infrequent | Batch allocation with ID recycling | < 1 allocation per entity on average |\n| **Component Storage Growth** | Rare | Exponential growth with large chunks | Amortized O(1) over entity lifetime |\n| **System Updates** | Every frame | Zero allocations for existing data | Memory profiler shows no allocations during updates |\n\n### Non-Goals: Multi-threading, serialization, networking, visual editors\n\nEstablishing clear non-goals prevents scope creep and allows us to focus on mastering core ECS concepts before tackling advanced features. **Think of these as features for ECS Architecture 2.0** — important capabilities that build upon the foundation we're creating, but would significantly complicate the initial implementation and obscure the fundamental principles we're trying to learn.\n\n**Multi-threading support** represents a major complexity multiplier that would require thread-safe component access, system scheduling across worker threads, and synchronization primitives that can easily introduce deadlocks or race conditions. While production ECS implementations like Unity's DOTS achieve impressive performance through parallel system execution, the additional complexity would overwhelm developers learning basic ECS concepts.\n\nMulti-threading in ECS requires sophisticated analysis of system dependencies to determine which systems can run in parallel. A physics system that modifies `Position` components cannot run simultaneously with a rendering system that reads `Position` components without careful synchronization. Building this dependency analysis and scheduling system would triple the implementation complexity.\n\n> **Decision: Single-Threaded Execution Model**\n> - **Context**: Multi-threading could improve performance but adds significant complexity to component access, system scheduling, and debugging\n> - **Options Considered**: \n>   - Single-threaded with simple execution loop\n>   - Multi-threaded with job system and dependency analysis\n>   - Hybrid with optional threading for specific systems\n> - **Decision**: Single-threaded execution for initial implementation\n> - **Rationale**: Enables focus on core ECS concepts without synchronization complexity; easier debugging and testing; sufficient performance for learning scenarios\n> - **Consequences**: Performance limited to single core utilization; simpler codebase that's easier to understand and extend\n\n**Serialization and persistence** functionality would require defining binary formats for entity data, handling component type information at runtime, versioning schemas as components change, and managing references between entities across save/load boundaries. Each component type would need serialization logic, and the system would need to handle partial saves, corruption recovery, and migration between different data versions.\n\nThe complexity comes not just from the serialization mechanics, but from the architectural changes required to support it. Components might need to store additional metadata, entity references would require translation during deserialization, and system initialization order becomes critical when loading saved worlds.\n\n**Networking and replication** introduces distributed systems challenges including state synchronization, lag compensation, authority resolution when multiple clients modify the same entity, and bandwidth optimization for component updates. ECS networking typically requires classifying components as authoritative vs. replicated, implementing delta compression for component changes, and handling connection drops that leave entities in inconsistent states.\n\nThese features require expertise in distributed systems that goes well beyond ECS architecture. The networking layer would likely become larger and more complex than the ECS implementation itself.\n\n**Visual editors and tooling** would require building GUI systems for entity inspection, component editing, system profiling, and world visualization. While these tools significantly improve developer experience, they represent entire application domains (UI frameworks, graphics rendering, input handling) that would distract from learning ECS principles.\n\n| Non-Goal | Complexity Impact | Recommended Timeline |\n|----------|------------------|---------------------|\n| **Multi-Threading** | 3x implementation complexity | After mastering single-threaded ECS |\n| **Serialization** | 2x codebase size | After component system is stable |\n| **Networking** | Requires distributed systems expertise | Advanced project after ECS fundamentals |\n| **Visual Tools** | Separate application domain | Quality-of-life improvement for later versions |\n\nOur non-goals don't represent unimportant features — they're sophisticated capabilities that deserve dedicated focus after mastering the foundational ECS concepts. By explicitly excluding them from our initial scope, we can build a clean, understandable implementation that serves as a solid foundation for these advanced features.\n\n> **Learning Path Recommendation**\n> \n> Master the core ECS implementation first: entity lifecycle, component storage, and system execution. Once you can implement these from scratch and understand all the performance trade-offs, tackle one advanced feature at a time. Multi-threading typically provides the biggest performance improvement, while serialization enables the most gameplay features.\n\nThe scope boundaries we've established ensure our ECS implementation remains focused on teaching data-oriented design principles while delivering measurable performance improvements over object-oriented alternatives. The functional goals provide concrete targets for each milestone, the performance goals ensure we achieve the architectural benefits that justify ECS complexity, and the non-goals prevent scope creep that could derail the project.\n\n### Implementation Guidance\n\nThis implementation guidance provides concrete technology recommendations and starter code to help you begin building the ECS architecture. The focus is on C++ implementations that demonstrate the performance and type safety principles discussed in the design section.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **Memory Management** | `std::vector` with manual sizing | Custom pool allocators with block management |\n| **Type Information** | `std::type_index` with `std::unordered_map` | Compile-time type IDs with template metaprogramming |\n| **Container Libraries** | STL containers (`std::vector`, `std::unordered_map`) | Custom containers optimized for ECS access patterns |\n| **Testing Framework** | Google Test with basic assertions | Google Test + Google Benchmark for performance testing |\n| **Build System** | CMake with simple configuration | CMake with advanced dependency management and testing targets |\n\n#### Recommended File Structure\n\nOrganize your ECS implementation with clear separation between core components and example usage:\n\n```cpp\necs-architecture/\n├── include/\n│   └── ecs/\n│       ├── entity_manager.h      ← Entity lifecycle and ID management\n│       ├── component_storage.h   ← Component storage and sparse sets\n│       ├── system.h              ← System base class and execution\n│       ├── world.h               ← Main ECS coordinator\n│       └── types.h               ← Core type definitions (EntityID, Generation)\n├── src/\n│   ├── entity_manager.cpp        ← Entity manager implementation\n│   ├── component_storage.cpp     ← Component storage implementation\n│   ├── system.cpp                ← System execution framework\n│   └── world.cpp                 ← World coordinator implementation\n├── examples/\n│   ├── basic_movement.cpp        ← Simple position/velocity example\n│   └── game_simulation.cpp       ← More complex multi-system example\n├── tests/\n│   ├── entity_manager_test.cpp   ← Entity lifecycle tests\n│   ├── component_storage_test.cpp ← Component operations tests\n│   ├── system_test.cpp           ← System execution tests\n│   └── performance_benchmark.cpp ← Cache performance and timing tests\n└── CMakeLists.txt                ← Build configuration\n```\n\n#### Core Type Definitions\n\nStart with these fundamental type definitions that establish the foundation for all ECS operations:\n\n```cpp\n// include/ecs/types.h\n#pragma once\n#include <cstdint>\n\nnamespace ECS {\n    // Entity identifier combining index and generation for safe references\n    using EntityID = uint32_t;\n    using Generation = uint32_t;\n    \n    // Component type identification for runtime type safety\n    using ComponentTypeID = uint32_t;\n    \n    // Complete entity reference with generation counter\n    struct Entity {\n        EntityID id;\n        Generation generation;\n        \n        bool operator==(const Entity& other) const {\n            return id == other.id && generation == other.generation;\n        }\n        \n        bool operator!=(const Entity& other) const {\n            return !(*this == other);\n        }\n    };\n    \n    // Sentinel values for invalid references\n    constexpr EntityID INVALID_ENTITY_ID = 0;\n    constexpr Generation DEFAULT_GENERATION = 1;\n    constexpr Entity INVALID_ENTITY = {INVALID_ENTITY_ID, 0};\n}\n```\n\n#### Sample Component Definitions\n\nDefine example components that demonstrate different data patterns common in game development:\n\n```cpp\n// examples/components.h\n#pragma once\n\nnamespace ECS {\n    // Position component for spatial representation\n    struct Position {\n        float x, y;\n        \n        Position(float x = 0.0f, float y = 0.0f) : x(x), y(y) {}\n    };\n    \n    // Velocity component for movement\n    struct Velocity {\n        float dx, dy;\n        \n        Velocity(float dx = 0.0f, float dy = 0.0f) : dx(dx), dy(dy) {}\n    };\n    \n    // Health component with current and maximum values\n    struct Health {\n        int current;\n        int maximum;\n        \n        Health(int max_health = 100) : current(max_health), maximum(max_health) {}\n        \n        bool isAlive() const { return current > 0; }\n        void takeDamage(int damage) { current = std::max(0, current - damage); }\n        void heal(int amount) { current = std::min(maximum, current + amount); }\n    };\n}\n```\n\n#### Entity Manager Skeleton\n\nThe entity manager handles ID generation, lifecycle tracking, and ID recycling:\n\n```cpp\n// include/ecs/entity_manager.h\n#pragma once\n#include \"types.h\"\n#include <vector>\n#include <queue>\n\nnamespace ECS {\n    class EntityManager {\n    private:\n        std::vector<Generation> generations_;  // Generation counter per entity index\n        std::queue<EntityID> free_ids_;       // Recycled entity IDs\n        EntityID next_id_;                    // Next ID to allocate if no recycled IDs\n        \n    public:\n        EntityManager();\n        \n        // Create new entity with unique ID and generation\n        Entity createEntity();\n        \n        // Mark entity as destroyed and recycle its ID\n        void destroyEntity(const Entity& entity);\n        \n        // Check if entity reference is still valid\n        bool isAlive(const Entity& entity) const;\n        \n        // Get current number of alive entities\n        size_t getAliveCount() const;\n        \n        // Iterator support for traversing all alive entities\n        class EntityIterator; // TODO: Implement iterator class\n        EntityIterator begin() const;\n        EntityIterator end() const;\n    };\n}\n```\n\n#### Component Storage Interface\n\nDefine the interface for type-erased component storage operations:\n\n```cpp\n// include/ecs/component_storage.h\n#pragma once\n#include \"types.h\"\n#include <memory>\n#include <unordered_map>\n\nnamespace ECS {\n    // Base interface for type-erased component operations\n    class IComponentStorage {\n    public:\n        virtual ~IComponentStorage() = default;\n        virtual void removeComponent(const Entity& entity) = 0;\n        virtual bool hasComponent(const Entity& entity) const = 0;\n        virtual size_t getComponentCount() const = 0;\n    };\n    \n    // Template implementation for type-specific component storage\n    template<typename T>\n    class ComponentStorage : public IComponentStorage {\n    private:\n        std::vector<T> components_;           // Dense array of component data\n        std::vector<EntityID> entity_ids_;   // Entity ID for each component\n        std::unordered_map<EntityID, size_t> entity_to_index_; // Sparse mapping\n        \n    public:\n        // Add component to entity with perfect forwarding\n        template<typename... Args>\n        T& addComponent(const Entity& entity, Args&&... args);\n        \n        // Remove component from entity using swap-remove\n        void removeComponent(const Entity& entity) override;\n        \n        // Get component reference for entity\n        T& getComponent(const Entity& entity);\n        const T& getComponent(const Entity& entity) const;\n        \n        // Check if entity has this component type\n        bool hasComponent(const Entity& entity) const override;\n        \n        // Get total number of components stored\n        size_t getComponentCount() const override;\n        \n        // Iterator support for efficient component traversal\n        typename std::vector<T>::iterator begin() { return components_.begin(); }\n        typename std::vector<T>::iterator end() { return components_.end(); }\n        typename std::vector<T>::const_iterator begin() const { return components_.begin(); }\n        typename std::vector<T>::const_iterator end() const { return components_.end(); }\n    };\n}\n```\n\n#### System Base Class\n\nSystems define the interface for game logic that operates on entities with specific component combinations:\n\n```cpp\n// include/ecs/system.h\n#pragma once\n\nnamespace ECS {\n    class World; // Forward declaration\n    \n    // Base class for all systems\n    class System {\n    public:\n        virtual ~System() = default;\n        \n        // Called each frame with delta time in seconds\n        virtual void update(World& world, float deltaTime) = 0;\n        \n        // Optional initialization when system is registered\n        virtual void initialize(World& world) {}\n        \n        // Optional cleanup when system is removed\n        virtual void shutdown(World& world) {}\n    };\n}\n```\n\n#### World Coordinator Skeleton\n\nThe World class coordinates all ECS components and provides the main API:\n\n```cpp\n// include/ecs/world.h\n#pragma once\n#include \"entity_manager.h\"\n#include \"component_storage.h\"\n#include \"system.h\"\n#include <memory>\n#include <vector>\n#include <unordered_map>\n#include <typeindex>\n\nnamespace ECS {\n    class World {\n    private:\n        EntityManager entity_manager_;\n        std::unordered_map<std::type_index, std::unique_ptr<IComponentStorage>> component_storages_;\n        std::vector<std::pair<int, std::unique_ptr<System>>> systems_; // priority, system\n        \n        // Helper to get or create component storage for type T\n        template<typename T>\n        ComponentStorage<T>* getComponentStorage();\n        \n    public:\n        World() = default;\n        ~World() = default;\n        \n        // Entity operations\n        Entity createEntity() { return entity_manager_.createEntity(); }\n        void destroyEntity(const Entity& entity);\n        bool isAlive(const Entity& entity) const { return entity_manager_.isAlive(entity); }\n        \n        // Component operations\n        template<typename T, typename... Args>\n        T& addComponent(const Entity& entity, Args&&... args);\n        \n        template<typename T>\n        void removeComponent(const Entity& entity);\n        \n        template<typename T>\n        T& getComponent(const Entity& entity);\n        \n        template<typename T>\n        const T& getComponent(const Entity& entity) const;\n        \n        template<typename T>\n        bool hasComponent(const Entity& entity) const;\n        \n        // System operations\n        template<typename T, typename... Args>\n        void registerSystem(int priority, Args&&... args);\n        \n        void update(float deltaTime);\n        \n        // Query interface for finding entities with specific components\n        template<typename... Components>\n        auto query(); // TODO: Implement query iterator\n    };\n}\n```\n\n#### Milestone Checkpoints\n\nAfter implementing each milestone, verify functionality with these concrete tests:\n\n**Milestone 1: Entity Manager**\n```bash\n# Compile and run entity manager tests\ng++ -std=c++17 -I include tests/entity_manager_test.cpp src/entity_manager.cpp -o test_entities\n./test_entities\n\n# Expected output should show:\n# - Unique entity IDs generated for each createEntity() call\n# - isAlive() returns false for destroyed entities\n# - ID recycling reuses destroyed entity IDs with incremented generations\n```\n\n**Milestone 2: Component Storage**\n```bash\n# Compile and run component storage tests\ng++ -std=c++17 -I include tests/component_storage_test.cpp -o test_components\n./test_components\n\n# Expected behavior:\n# - Adding components increases storage size and enables hasComponent() lookup\n# - Removing components decreases size and swap-removes maintain dense packing\n# - getComponent() returns correct references that can be modified\n```\n\n**Milestone 3: System Interface**\n```bash\n# Compile and run basic movement example\ng++ -std=c++17 -I include examples/basic_movement.cpp src/*.cpp -o basic_movement\n./basic_movement\n\n# Expected output:\n# - Systems execute in priority order each frame\n# - Movement system updates Position components based on Velocity\n# - Frame delta time properly scales movement calculations\n```\n\n#### Performance Validation\n\nUse these benchmarks to verify cache-friendly performance characteristics:\n\n```cpp\n// tests/performance_benchmark.cpp (skeleton)\n#include <chrono>\n#include <iostream>\n#include \"ecs/world.h\"\n\nvoid benchmarkComponentIteration() {\n    // TODO: Create 100,000 entities with Position and Velocity components\n    // TODO: Measure time to iterate through all Position components\n    // TODO: Compare with pointer-chasing approach (vector of pointers)\n    // TODO: Verify >10x performance improvement for sequential access\n}\n\nvoid benchmarkComponentLookup() {\n    // TODO: Create entities and measure getComponent() lookup time\n    // TODO: Verify O(1) performance regardless of entity count\n    // TODO: Test with 1k, 10k, 100k entities to confirm constant time\n}\n```\n\nThis implementation guidance provides the foundation for building a performant ECS architecture while maintaining focus on learning core concepts. The modular structure enables incremental development where each milestone builds upon previous work without requiring major refactoring.\n\n\n## High-Level Architecture\n\n> **Milestone(s):** Foundation for Milestones 1-4 — understanding the overall ECS structure and component interactions\n\nOur ECS architecture consists of four main components working together to achieve data-oriented design principles. Think of the ECS as a **digital library management system** where entities are library cards, components are the books and resources attached to each card, systems are the librarians who process specific types of materials, and the optional archetype optimization is like organizing books by genre for faster processing.\n\n![ECS Architecture Overview](./diagrams/ecs-overview.svg)\n\nThe architecture separates concerns cleanly: the `EntityManager` handles the identity and lifecycle of game objects, `ComponentStorage` manages the actual data in cache-friendly layouts, the `System` interface provides the framework for game logic execution, and optional `Archetype` storage optimizes for maximum performance by grouping similar entities together. This separation enables the composition over inheritance principle that makes ECS so powerful for game development.\n\nEach component has a specific responsibility and communicates with others through well-defined interfaces. The `World` class serves as the central coordinator, orchestrating interactions between all components while maintaining the data flow patterns that enable efficient frame-by-frame game updates.\n\n### Component Responsibilities\n\nThe ECS architecture divides responsibilities among four core components, each with distinct ownership and clear boundaries. Understanding these responsibilities is crucial because violations lead to the performance problems and coupling issues that ECS is designed to solve.\n\n#### Entity Manager Responsibilities\n\nThe `EntityManager` serves as the **identity authority** for the entire ECS system. Think of it as the **DMV office** that issues unique identification numbers and tracks which IDs are currently valid. Its primary responsibility is ensuring that every entity in the system has a unique, stable identity that can be safely referenced by other components.\n\n| Responsibility | Description | Why Important |\n|---|---|---|\n| Unique ID Generation | Creates `EntityID` values that are never duplicated during runtime | Prevents entity confusion and reference conflicts |\n| Generation Management | Maintains `Generation` counters to invalidate stale entity references | Eliminates dangling pointer equivalent bugs in ECS |\n| Lifecycle Tracking | Tracks which entities are alive, dead, or available for recycling | Enables safe iteration and memory management |\n| ID Recycling | Reuses destroyed entity IDs to prevent memory growth in long-running games | Critical for games that create/destroy many entities |\n\nThe `EntityManager` owns the master entity registry and is the single source of truth for entity existence. It does not store component data or execute game logic—those are the responsibilities of other components. When a system needs to know if an entity reference is valid, it asks the `EntityManager`. When component storage needs to clean up data for a destroyed entity, it coordinates with the `EntityManager`.\n\n> **Decision: Single Entity Manager vs Distributed ID Generation**\n> - **Context**: We need to generate unique entity IDs and track entity lifecycle across the entire ECS system\n> - **Options Considered**: Centralized `EntityManager`, distributed ID generation per system, globally unique timestamps\n> - **Decision**: Single centralized `EntityManager` with generation counters\n> - **Rationale**: Centralized management ensures ID uniqueness without coordination overhead, generation counters provide safety against stale references, and a single authority simplifies debugging and validation\n> - **Consequences**: Single point of truth for entity existence, potential bottleneck for massive entity creation (but this is rare), simplified system design\n\n#### Component Storage Responsibilities\n\nThe `ComponentStorage` system is responsible for the **data organization and access patterns** that make ECS performant. Think of it as a **specialized warehouse** with different storage areas optimized for different types of inventory, where the warehouse manager (sparse set) keeps track of which items belong to which customers.\n\n| Responsibility | Description | Why Important |\n|---|---|---|\n| Cache-Friendly Layout | Stores components in contiguous arrays for efficient iteration | Enables SIMD operations and minimizes cache misses |\n| Constant-Time Lookup | Maps entity IDs to component indices using sparse sets | Systems can access specific entity components without searching |\n| Type Safety | Ensures component access matches expected types at compile time | Prevents runtime errors from component type confusion |\n| Dynamic Composition | Adds and removes components without affecting other entity data | Enables flexible entity composition during gameplay |\n\nThe component storage owns all component data and the mapping between entities and their components. It does not know about entity lifecycle (that's the `EntityManager`'s job) or game logic (that's the `System`'s responsibility). Each component type gets its own storage instance, and the system provides a unified interface for type-safe access.\n\n> **Decision: Sparse Set vs Hash Map for Entity-Component Mapping**\n> - **Context**: Need constant-time lookup from entity ID to component data while maintaining cache-friendly iteration\n> - **Options Considered**: Hash maps, binary search trees, sparse sets, linear arrays\n> - **Decision**: Sparse set data structure with dense array for components\n> - **Rationale**: Sparse sets provide O(1) insertion, deletion, and lookup while maintaining dense storage for cache-friendly iteration; hash maps have poor iteration performance; arrays require linear search\n> - **Consequences**: Excellent iteration performance for systems, O(1) component access, memory overhead for sparse array, complexity in implementation\n\n#### System Interface Responsibilities\n\nThe `System` interface provides the **execution framework** for game logic while maintaining the data-oriented design principles. Think of systems as **specialized factory workers** on an assembly line, where each worker processes specific types of components and passes the entities along to the next worker.\n\n| Responsibility | Description | Why Important |\n|---|---|---|\n| Game Logic Execution | Implements specific behaviors that operate on component data | Separates behavior from data storage for modularity |\n| Component Queries | Specifies which component combinations the system requires | Enables automatic entity filtering and iteration |\n| Frame Ordering | Defines execution priority and dependencies between systems | Ensures game logic runs in the correct sequence |\n| Delta Time Processing | Receives frame time for time-based updates and animations | Enables frame-rate independent game behavior |\n\nSystems own the game logic but do not own entity or component data. They operate through queries that ask the component storage \"give me all entities that have components X, Y, and Z\" and then process those entities. Systems declare their dependencies and execution order, allowing the `SystemManager` to schedule them correctly.\n\n> **Decision: Push vs Pull System Execution Model**\n> - **Context**: Systems need to process entities with specific component combinations each frame\n> - **Options Considered**: Push model (components notify systems), pull model (systems query components), hybrid event/query model\n> - **Decision**: Pull model with explicit component queries\n> - **Rationale**: Pull model gives systems control over iteration order and timing, easier to reason about data dependencies, simpler threading model, explicit queries make system requirements visible\n> - **Consequences**: Systems must explicitly query for data each frame, no automatic reactivity, but predictable execution and clear data flow\n\n#### World Coordinator Responsibilities\n\nThe `World` class serves as the **central coordinator** that orchestrates interactions between all ECS components. Think of it as the **conductor of an orchestra**, ensuring that each section (entities, components, systems) plays their part at the right time and in harmony with the others.\n\n| Responsibility | Description | Why Important |\n|---|---|---|\n| Component Integration | Provides unified interface to `EntityManager`, `ComponentStorage`, and `SystemManager` | Single entry point simplifies ECS usage and reduces coupling |\n| Frame Orchestration | Coordinates the update cycle across all systems each frame | Ensures consistent timing and execution order |\n| Resource Management | Manages memory and cleanup across all ECS components | Prevents resource leaks and maintains performance |\n| API Simplification | Hides internal complexity behind clean, type-safe methods | Makes ECS accessible to gameplay programmers |\n\nThe `World` owns instances of all other ECS components and coordinates their interactions. It does not implement storage or logic directly—instead, it delegates to the appropriate specialized component. Game code interacts primarily with the `World`, which handles the complexity of routing requests to the correct underlying systems.\n\n### Recommended File Structure\n\nOrganizing ECS code properly from the start prevents the monolithic files and circular dependencies that plague many ECS implementations. Our file structure mirrors the component responsibilities and creates clear module boundaries that support both compilation speed and maintainability.\n\n```\necs-architecture/\n├── include/\n│   └── ecs/\n│       ├── world.h                    ← Main ECS interface\n│       ├── entity/\n│       │   ├── entity_manager.h       ← Entity lifecycle and ID management\n│       │   └── entity_types.h         ← Entity, EntityID, Generation types\n│       ├── component/\n│       │   ├── component_storage.h    ← Generic component storage interface\n│       │   ├── sparse_set.h           ← Sparse set implementation\n│       │   └── component_types.h      ← ComponentTypeID and registration\n│       ├── system/\n│       │   ├── system.h               ← System base class and interfaces\n│       │   ├── system_manager.h       ← System registration and execution\n│       │   └── query.h                ← Component query implementation\n│       └── archetype/                 ← Advanced archetype optimization\n│           ├── archetype.h            ← Archetype identification and storage\n│           └── archetype_manager.h    ← Archetype-based component storage\n├── src/\n│   ├── world.cpp                      ← World implementation\n│   ├── entity/\n│   │   ├── entity_manager.cpp         ← Entity ID generation and recycling\n│   │   └── entity_types.cpp           ← Entity utility functions\n│   ├── component/\n│   │   ├── component_storage.cpp      ← Storage implementation\n│   │   └── sparse_set.cpp             ← Sparse set operations\n│   ├── system/\n│   │   ├── system_manager.cpp         ← System execution scheduling\n│   │   └── query.cpp                  ← Query filtering and iteration\n│   └── archetype/\n│       ├── archetype.cpp              ← Archetype operations\n│       └── archetype_manager.cpp      ← Archetype-based storage\n├── examples/\n│   ├── basic_ecs/\n│   │   ├── components.h               ← Position, Velocity, Health components\n│   │   ├── systems.h                  ← Movement, Collision systems\n│   │   └── main.cpp                   ← Simple ECS usage example\n│   └── performance_test/\n│       ├── benchmark.cpp              ← Performance comparison tests\n│       └── stress_test.cpp            ← Large entity count testing\n└── tests/\n    ├── entity/\n    │   ├── test_entity_manager.cpp    ← Entity lifecycle tests\n    │   └── test_entity_recycling.cpp  ← ID recycling verification\n    ├── component/\n    │   ├── test_component_storage.cpp  ← Component CRUD operations\n    │   └── test_sparse_set.cpp         ← Sparse set correctness\n    ├── system/\n    │   ├── test_system_execution.cpp   ← System ordering and updates\n    │   └── test_component_queries.cpp  ← Query filtering tests\n    └── integration/\n        ├── test_full_ecs.cpp           ← End-to-end ECS scenarios\n        └── test_performance.cpp        ← Cache performance verification\n```\n\n> **Design Insight: Module Boundaries Prevent Coupling**\n> \n> The file structure enforces the separation of concerns by making dependencies explicit. The `entity/` module cannot include headers from `system/` without clearly violating the architecture. This prevents the gradual coupling that destroys ECS performance benefits.\n\nEach directory represents a distinct module with specific responsibilities:\n\n| Module | Purpose | Dependencies | What It Cannot Access |\n|---|---|---|---|\n| `entity/` | Entity identity and lifecycle | None (foundation module) | Component data, system logic |\n| `component/` | Data storage and access | `entity/` for EntityID types | System logic, entity lifecycle |\n| `system/` | Game logic execution framework | `entity/` and `component/` for queries | Direct component storage access |\n| `archetype/` | Performance optimization | All other modules | N/A (advanced feature) |\n\nThe `examples/` directory provides complete, working demonstrations of ECS usage patterns. The `basic_ecs` example shows how to create entities, add components, and implement simple systems. The `performance_test` example demonstrates the cache efficiency gains and provides benchmarking code for validation.\n\n> **Decision: Header-Only vs Compiled Library Structure**\n> - **Context**: Need to balance compilation speed, template instantiation, and ease of integration\n> - **Options Considered**: Fully header-only library, fully compiled library, hybrid approach with template headers\n> - **Decision**: Hybrid approach with implementation files for non-template code\n> - **Rationale**: Template components like `ComponentStorage<T>` must be header-only for type safety; non-template code like `EntityManager` can be compiled separately for faster builds; hybrid approach balances performance and compilation speed\n> - **Consequences**: Faster compilation than header-only, more complex build than fully compiled, but optimal for C++ template-heavy code\n\n### Data Flow Patterns\n\nUnderstanding how data flows through the ECS system is crucial for both implementation and debugging. The data flow follows a **request-response pattern** where systems make explicit queries for the data they need, rather than data being pushed to systems automatically.\n\n#### Entity Creation Flow\n\nThe entity creation process demonstrates how the different ECS components collaborate to maintain consistency and performance. This flow happens when game code calls `world.createEntity()` and begins adding components.\n\n1. **World Delegation**: The `World` receives the creation request and delegates to the `EntityManager`\n2. **ID Generation**: The `EntityManager` either reuses a recycled ID or generates a new unique `EntityID`\n3. **Generation Assignment**: A new `Generation` counter is assigned to prevent stale reference issues\n4. **Entity Registration**: The new `Entity` (combining ID and generation) is marked as alive in the entity registry\n5. **Return to Caller**: The `Entity` handle is returned to game code for component attachment\n\n| Step | Component Responsible | Data Modified | Validation Required |\n|---|---|---|---|\n| Request Routing | `World` | None | None |\n| ID Allocation | `EntityManager` | Free list, entity registry | Check free list availability |\n| Generation Increment | `EntityManager` | Generation counter | Handle overflow (wrap to 1) |\n| Status Update | `EntityManager` | Alive entity set | Ensure ID not already alive |\n| Response | `World` | None | Validate entity creation success |\n\n#### Component Attachment Flow\n\nComponent attachment shows how the ECS maintains the sparse set mappings that enable efficient queries while preserving cache-friendly iteration. This flow occurs when game code calls `world.addComponent<Position>(entity, position)`.\n\n1. **Type Registration**: The `ComponentStorage` system ensures the component type is registered and has allocated storage\n2. **Entity Validation**: The request validates that the target entity is alive through the `EntityManager`\n3. **Sparse Set Update**: The entity ID is mapped to the next available dense array index\n4. **Component Storage**: The component data is placed in the dense array at the mapped index\n5. **Index Mapping**: The bidirectional sparse set mapping is completed for O(1) future access\n\n> **Critical Data Flow Insight**\n> \n> Component attachment never triggers system execution automatically. Systems only see new components when they perform their next query during the update cycle. This prevents the cascading update problems that plague reactive architectures.\n\n#### System Update Cycle\n\nThe system update cycle represents the core game loop where all entity processing happens. This cycle runs every frame and demonstrates how systems query for entities and process components without interfering with each other.\n\n1. **Frame Initialization**: The `World` begins a new frame update with delta time calculation\n2. **System Iteration**: Systems execute in priority order defined during registration\n3. **Component Query**: Each system queries for entities matching its required component combination\n4. **Entity Iteration**: The system processes each matching entity using the component data\n5. **Component Modification**: Systems modify component data directly in the dense storage arrays\n6. **Frame Completion**: All systems finish, and the frame cycle prepares for the next update\n\n| Phase | System Action | Component Storage Response | Performance Consideration |\n|---|---|---|---|\n| Query Specification | Declares required components | Identifies matching entities | Query compilation can be cached |\n| Entity Filtering | Requests entity list | Returns iterator over dense arrays | Cache-friendly linear iteration |\n| Component Access | Requests specific component | Returns direct reference | No indirection or validation overhead |\n| Data Modification | Updates component values | Stores in dense array | SIMD-friendly memory access pattern |\n\nThe query mechanism is designed for maximum cache efficiency. When a system requests entities with `Position` and `Velocity` components, the component storage returns iterators that traverse the dense arrays in lockstep, ensuring that related data is accessed together.\n\n> **Decision: Immediate vs Deferred Component Modifications**\n> - **Context**: Systems need to modify components during iteration without breaking other systems in the same frame\n> - **Options Considered**: Immediate modification in place, deferred modification with command buffers, copy-on-write snapshots\n> - **Decision**: Immediate in-place modification with iteration safety guarantees\n> - **Rationale**: In-place modification has zero allocation overhead and maximum cache performance; ECS iteration patterns naturally avoid modification conflicts; command buffers add complexity and memory overhead\n> - **Consequences**: Systems must be careful about structural changes (adding/removing components) during iteration, but component value changes are safe and optimal\n\n#### Query Execution Patterns\n\nComponent queries form the bridge between system logic and component data. The query execution pattern ensures that systems receive exactly the entities they need while maintaining optimal iteration performance.\n\nSystems specify their component requirements through template parameters: `query<Position, Velocity>()` requests all entities that have both components. The query system then coordinates with the component storage to find the intersection of entities across multiple component types.\n\nThe query execution follows these patterns:\n\n**Single Component Query**: Direct iteration over the dense array for that component type. This is the fastest query pattern since it requires no entity filtering—every element in the dense array is a valid result.\n\n**Multi-Component Query**: Intersection of entity sets across component types. The query system iterates over the smallest component set and checks for the presence of other required components. This maintains cache efficiency while ensuring correctness.\n\n**Component Exclusion**: Systems can specify components that entities must NOT have. This enables patterns like \"all entities with Position but without Velocity\" for static object processing.\n\nThe query results provide direct access to component data without additional indirection. When a system iterates over query results, it receives references to the actual component instances stored in the dense arrays, enabling maximum performance for data processing.\n\n### Implementation Guidance\n\nThe ECS architecture requires careful attention to template design, memory management, and performance characteristics. The following guidance provides concrete implementation patterns and technology recommendations for building a production-quality ECS system.\n\n#### Technology Recommendations\n\n| Component | Simple Approach | Advanced Approach | Performance Trade-off |\n|---|---|---|---|\n| Entity ID Storage | `std::vector<bool>` for alive tracking | Custom packed bitset with population count | Memory vs. iteration speed |\n| Component Arrays | `std::vector<T>` with manual management | Memory pool with chunk allocation | Simplicity vs. allocation performance |\n| Sparse Set Implementation | Separate sparse and dense `std::vector` | Single allocation with offset pointers | Memory fragmentation vs. cache locality |\n| Type Registration | `std::unordered_map` with type hashing | Compile-time type ID generation | Runtime flexibility vs. compile-time optimization |\n| System Scheduling | `std::vector` with manual ordering | Dependency graph with topological sort | Implementation complexity vs. automatic ordering |\n\n#### Core Architecture Skeleton\n\nThis complete file structure provides the foundation for the ECS implementation. Each file includes the essential type definitions and method signatures that learners will implement throughout the milestones.\n\n**File: `include/ecs/entity/entity_types.h`**\n```cpp\n#ifndef ECS_ENTITY_TYPES_H\n#define ECS_ENTITY_TYPES_H\n\n#include <cstdint>\n\nnamespace ecs {\n    // Core entity identification types\n    using EntityID = uint32_t;\n    using Generation = uint32_t;\n    \n    // Combined entity handle with generation counter\n    struct Entity {\n        EntityID id;\n        Generation generation;\n        \n        // Equality comparison for entity handles\n        bool operator==(const Entity& other) const {\n            return id == other.id && generation == other.generation;\n        }\n        \n        bool operator!=(const Entity& other) const {\n            return !(*this == other);\n        }\n    };\n    \n    // Sentinel values for invalid references\n    constexpr EntityID INVALID_ENTITY_ID = static_cast<EntityID>(-1);\n    constexpr Generation DEFAULT_GENERATION = 1;\n    constexpr Entity INVALID_ENTITY = {INVALID_ENTITY_ID, 0};\n    \n} // namespace ecs\n\n#endif // ECS_ENTITY_TYPES_H\n```\n\n**File: `include/ecs/entity/entity_manager.h`**\n```cpp\n#ifndef ECS_ENTITY_MANAGER_H\n#define ECS_ENTITY_MANAGER_H\n\n#include \"entity_types.h\"\n#include <vector>\n#include <queue>\n\nnamespace ecs {\n    class EntityManager {\n    public:\n        EntityManager();\n        ~EntityManager() = default;\n        \n        // Core entity lifecycle operations\n        Entity createEntity();\n        void destroyEntity(const Entity& entity);\n        bool isAlive(const Entity& entity) const;\n        \n        // Entity iteration and statistics\n        std::vector<Entity> getAllAlive() const;\n        size_t getAliveCount() const;\n        size_t getDeadCount() const;\n        \n    private:\n        // TODO: Implement generation tracking per entity ID\n        // TODO: Implement free list for recycled entity IDs\n        // TODO: Implement alive status tracking\n        // TODO: Implement generation overflow handling\n        \n        std::vector<Generation> generations_;  // Generation per entity ID\n        std::queue<EntityID> free_ids_;       // Recycled entity IDs\n        std::vector<bool> alive_entities_;    // Alive status per entity ID\n        EntityID next_entity_id_;             // Next new entity ID\n    };\n    \n} // namespace ecs\n\n#endif // ECS_ENTITY_MANAGER_H\n```\n\n**File: `include/ecs/component/component_types.h`**\n```cpp\n#ifndef ECS_COMPONENT_TYPES_H\n#define ECS_COMPONENT_TYPES_H\n\n#include <cstdint>\n#include <typeinfo>\n\nnamespace ecs {\n    // Component type identification\n    using ComponentTypeID = uint32_t;\n    constexpr ComponentTypeID INVALID_COMPONENT_TYPE = static_cast<ComponentTypeID>(-1);\n    \n    // Global component type registration\n    template<typename T>\n    ComponentTypeID getComponentTypeID() {\n        static ComponentTypeID id = generateComponentTypeID();\n        return id;\n    }\n    \n    // Component type counter for unique ID generation\n    ComponentTypeID generateComponentTypeID();\n    \n} // namespace ecs\n\n#endif // ECS_COMPONENT_TYPES_H\n```\n\n**File: `include/ecs/world.h`**\n```cpp\n#ifndef ECS_WORLD_H\n#define ECS_WORLD_H\n\n#include \"entity/entity_manager.h\"\n#include \"component/component_storage.h\"\n#include \"system/system_manager.h\"\n#include <memory>\n\nnamespace ecs {\n    // Main ECS coordinator class\n    class World {\n    public:\n        World();\n        ~World() = default;\n        \n        // Entity operations\n        Entity createEntity() {\n            // TODO: Delegate to entity manager\n        }\n        \n        void destroyEntity(const Entity& entity) {\n            // TODO: Remove all components first\n            // TODO: Then destroy entity in manager\n        }\n        \n        bool isAlive(const Entity& entity) const {\n            // TODO: Delegate to entity manager\n        }\n        \n        // Component operations\n        template<typename T>\n        T& addComponent(const Entity& entity, T&& component) {\n            // TODO: Validate entity is alive\n            // TODO: Get or create component storage for type T\n            // TODO: Add component to storage\n        }\n        \n        template<typename T>\n        void removeComponent(const Entity& entity) {\n            // TODO: Get component storage for type T\n            // TODO: Remove component from storage\n        }\n        \n        template<typename T>\n        T& getComponent(const Entity& entity) {\n            // TODO: Get component storage for type T\n            // TODO: Return component reference\n        }\n        \n        template<typename T>\n        bool hasComponent(const Entity& entity) const {\n            // TODO: Get component storage for type T\n            // TODO: Check if entity has component\n        }\n        \n        // System operations\n        template<typename SystemT, typename... Args>\n        void registerSystem(int priority, Args&&... args) {\n            // TODO: Create system instance\n            // TODO: Register with system manager\n        }\n        \n        void update(float deltaTime) {\n            // TODO: Execute all systems in priority order\n        }\n        \n        // Query interface for systems\n        template<typename... Components>\n        auto query() {\n            // TODO: Return query iterator for component combination\n        }\n        \n    private:\n        EntityManager entity_manager_;\n        // TODO: Component storage manager\n        // TODO: System manager\n    };\n    \n} // namespace ecs\n\n#endif // ECS_WORLD_H\n```\n\n#### Language-Specific Implementation Notes\n\n**Memory Management**: Use RAII principles consistently. The `EntityManager` should manage its own memory for generation counters and free lists. Component storage should use `std::vector` for automatic memory management with manual control over capacity growth.\n\n**Template Instantiation**: Component storage uses templates extensively. Consider explicit template instantiation in source files for commonly used component types to reduce compilation time. The `getComponentTypeID<T>()` function will instantiate a static variable for each component type.\n\n**Exception Safety**: ECS operations should provide strong exception safety guarantees. If `addComponent` fails to allocate storage, the entity should remain in its previous state. Use RAII wrappers and scope guards for complex operations.\n\n**Performance Considerations**: Profile early and often. The sparse set implementation is the performance critical path—measure cache miss rates and iteration speed. Consider using `std::vector<T>::reserve()` to pre-allocate storage for known entity counts.\n\n#### Milestone Checkpoints\n\n**After Milestone 1 (Entity Manager)**:\n- Run `make test_entity_manager` - should pass all entity lifecycle tests\n- Create 1000 entities, destroy every other one, create 1000 more - should reuse recycled IDs\n- Verify generation counters increment on entity ID reuse\n- Check that `isAlive()` correctly rejects stale entity references\n\n**After Milestone 2 (Component Storage)**:\n- Run `make test_component_storage` - should pass all component CRUD tests\n- Add `Position` components to 1000 entities, iterate over all - should complete in microseconds\n- Remove components from random entities, verify sparse set remains consistent\n- Check that component access with wrong type fails to compile\n\n**After Milestone 3 (System Interface)**:\n- Run `make test_system_execution` - should pass system ordering and update tests\n- Register movement system, create entities with `Position` and `Velocity`, run one frame\n- Verify systems execute in priority order with dependency resolution\n- Check that delta time propagates correctly to all systems\n\n**After Milestone 4 (Archetypes)**:\n- Run `make test_archetype_performance` - should show improved cache performance\n- Compare iteration speed vs. sparse set implementation - should be 2-3x faster\n- Add/remove components and verify archetype transitions work correctly\n- Measure memory usage - should be more compact than sparse set storage\n\n\n## Data Model\n\n> **Milestone(s):** Milestones 1-4 — core data structures that enable entity management, component storage, system queries, and archetype optimization\n\nThe data model forms the foundation of our ECS architecture, defining how we represent entities, components, and their relationships in memory. Think of the data model as the blueprint for a highly organized warehouse: we need efficient ways to identify items (entities), categorize them (component types), store them for fast access (sparse sets), and group similar items together for bulk operations (archetypes). The design of these core data structures directly impacts both the performance characteristics and the ease of use of our entire ECS system.\n\nOur data model must solve several critical challenges simultaneously. First, entity references must remain stable even when entities are created and destroyed frequently, preventing the classic \"dangling pointer\" problem that plagues game engines. Second, component data must be stored in cache-friendly layouts that enable high-performance iteration while still supporting dynamic composition. Third, type information must be preserved at runtime to enable safe component access without sacrificing performance. Finally, for advanced implementations, we need metadata structures that enable grouping entities by component combinations for maximum cache efficiency.\n\n![Core Data Types and Relationships](./diagrams/data-model-relationships.svg)\n\nThe relationships between these data structures form a carefully orchestrated system. Entity IDs serve as stable references that survive entity lifecycle operations through generation counters. Component type information bridges the gap between compile-time type safety and runtime flexibility. Sparse sets provide the bidirectional mapping that makes both entity-to-component and component-to-entity lookups efficient. Archetypes build upon all of these to create the highest-performance storage layout possible for bulk operations.\n\n### Entity ID Structure\n\n**Mental Model: Library Card System**\n\nThink of entity management like a library card system at a large university. Each library card has a unique number printed on it, but when a student graduates, their card gets recycled for new students. To prevent a new student from accidentally accessing the previous student's account, each card also has an issue year or semester stamp. Even if card #12345 gets reused, the new card is stamped \"Fall 2024\" while the old records show \"Spring 2023,\" making it clear they're different people. Similarly, entity IDs use generation counters to distinguish between different \"incarnations\" of the same ID number.\n\nThe `Entity` structure represents our core entity identification mechanism. Unlike simple integer IDs that can become dangling references when entities are destroyed, our entity system uses a two-part identifier that remains safe even in complex scenarios involving frequent entity creation and destruction.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `id` | `EntityID` | The index portion of the entity identifier, corresponds to position in entity storage arrays |\n| `generation` | `Generation` | The generation counter that distinguishes different incarnations of the same ID |\n\nThe `EntityID` serves as the index component, representing the position where this entity's metadata is stored in the Entity Manager's internal arrays. This index-based approach enables constant-time lookups and efficient iteration over all entities. However, unlike raw indices, `EntityID` values are never reused immediately after an entity is destroyed.\n\nThe `Generation` counter solves the fundamental problem of stale entity references. Every time an entity ID is recycled for a new entity, the generation counter increments. This means that even if two entities share the same `EntityID`, they can be distinguished by their generation values. When code attempts to access a component using a stale entity reference, the generation mismatch will be detected and the access can be safely rejected.\n\n> **Decision: Packed Entity Structure vs Separate ID/Generation**\n> - **Context**: Entity references need both index and generation information, which could be stored as separate values or packed into a single integer\n> - **Options Considered**: \n>   1. Separate `EntityID` and `Generation` fields in a struct\n>   2. Packed format using bit manipulation (e.g., 20 bits ID + 12 bits generation in uint32_t)\n>   3. Simple integer IDs with external generation tracking\n> - **Decision**: Separate fields in a struct approach\n> - **Rationale**: Separate fields provide clearer code, avoid bit manipulation complexity, enable larger ID spaces, and simplify debugging since values are human-readable\n> - **Consequences**: Uses more memory per entity reference (8 bytes vs 4 bytes for packed), but provides maximum flexibility and maintainability\n\nThe ID recycling mechanism operates through a free list that tracks destroyed entity IDs. When an entity is destroyed, its ID is added to the free list rather than being immediately reused. When a new entity is created, the system first checks the free list for available IDs. If an ID is recycled, its generation counter is incremented to distinguish it from previous incarnations.\n\n**Generation Counter Overflow Handling**\n\nOne subtle but critical aspect of the generation counter system is handling overflow conditions. Since generation counters are finite-width integers (typically 32-bit), they will eventually overflow in long-running applications that create and destroy many entities. Our system handles this through several mechanisms:\n\n1. **Large Counter Space**: Using 32-bit generation counters provides over 4 billion generations per entity ID, making overflow extremely unlikely in practice\n2. **Overflow Detection**: When incrementing a generation would cause overflow, the system can either skip that ID permanently or implement wraparound with additional safety checks\n3. **Conservative Validation**: Entity validation always checks both ID bounds and generation equality, catching most overflow-related issues\n\n**Entity Validation Process**\n\nThe entity validation process ensures that entity references remain valid throughout the application lifecycle. This involves several checks performed whenever an entity reference is used:\n\n1. **Bounds Check**: Verify the `EntityID` falls within the valid range of allocated entity slots\n2. **Alive Check**: Confirm the entity slot is currently occupied by a live entity\n3. **Generation Match**: Verify the reference generation matches the current generation in the entity slot\n4. **Component Consistency**: For component operations, verify the entity actually has the requested component type\n\n### Component Type Information\n\n**Mental Model: Warehouse Inventory System**\n\nThink of component type information like the inventory management system in a large warehouse. Each product category (component type) has its own storage area with specialized equipment: frozen goods need freezers, fragile items need padded shelves, and bulk items need large bins. The warehouse maintains a master catalog that maps product codes (type IDs) to storage locations and handling procedures. When workers need to find or store items, they look up the product code to determine which storage system to use and how to handle that item type safely.\n\nComponent type information bridges the gap between compile-time type safety and runtime flexibility in our ECS system. Since systems need to query for entities with arbitrary component combinations determined at runtime, we need a way to identify, store, and access component types without losing type safety or performance.\n\nThe `ComponentTypeID` serves as our runtime type identifier, providing a unique integer for each component type registered in the system. These IDs are assigned sequentially as component types are first used, creating a dense mapping that enables efficient storage in arrays and bitsets.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `typeID` | `ComponentTypeID` | Unique identifier for this component type, assigned at registration |\n| `name` | `const char*` | Human-readable name for debugging and serialization |\n| `size` | `size_t` | Size in bytes of a single component instance |\n| `alignment` | `size_t` | Required memory alignment for component instances |\n| `destructor` | `void(*)(void*)` | Function pointer to call component destructor |\n| `moveConstructor` | `void(*)(void*, void*)` | Function pointer for moving component data |\n\nThe component type registry maintains this metadata for all registered component types. This information enables type-erased operations while preserving the ability to call appropriate constructors, destructors, and move operations. The registry uses template specialization to generate and cache this metadata automatically when component types are first accessed.\n\n**Type ID Generation Strategy**\n\nComponent type IDs must be consistent within a single program execution but do not need to be stable across program restarts. Our type ID generation uses a simple counter-based approach with template-based caching for performance:\n\n1. **First Access Registration**: When a component type is first accessed, the system generates the next available type ID\n2. **Template Caching**: Each component type gets a template specialization that caches its type ID for subsequent access\n3. **Sequential Assignment**: Type IDs are assigned sequentially starting from 0, creating a dense ID space optimal for array indexing\n4. **Consistency Guarantee**: Within a single program execution, each component type receives the same ID regardless of access order\n\n> **Decision: Sequential Type IDs vs Hash-Based IDs**\n> - **Context**: Component types need unique identifiers that enable efficient storage and lookup operations\n> - **Options Considered**:\n>   1. Sequential integer IDs assigned on first use\n>   2. Hash-based IDs derived from type names\n>   3. Compile-time assigned IDs using template metaprogramming\n> - **Decision**: Sequential integer IDs with template caching\n> - **Rationale**: Sequential IDs create dense arrays for storage, avoid hash collisions, work with any component type regardless of naming, and provide predictable performance characteristics\n> - **Consequences**: Type IDs are not stable across program runs, but this enables optimal memory layouts and eliminates hash collision complexity\n\n**Sparse Set Integration**\n\nThe component type information directly integrates with our sparse set storage system. Each component type gets its own `ComponentStorage` instance that maintains the sparse set mapping from entity IDs to component array indices. This design provides several advantages:\n\n- **Type Safety**: Each component type has its own storage with compile-time type checking\n- **Independent Lifecycle**: Components of different types can be added and removed independently\n- **Optimal Memory Layout**: Each component type is stored in its own contiguous array for cache efficiency\n- **Efficient Queries**: Systems can quickly determine which entities have specific component combinations\n\nThe `IComponentStorage` base interface enables type-erased operations on component storage, allowing the ECS system to manage storage instances without knowing their specific component types at compile time.\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `removeEntity` | `Entity entity` | `void` | Remove component from entity if present |\n| `hasEntity` | `Entity entity` | `bool` | Check if entity has this component type |\n| `getTypeID` | - | `ComponentTypeID` | Return the component type ID for this storage |\n| `size` | - | `size_t` | Return number of components currently stored |\n| `clear` | - | `void` | Remove all components and reset storage |\n\n### Archetype Data Layout\n\n**Mental Model: Filing Cabinet Organization**\n\nThink of archetype-based storage like a highly organized filing system in a law firm. Instead of storing each client's documents randomly throughout the office, related documents are grouped together in specific filing cabinets. All divorce cases go in one cabinet, all contract disputes in another, and all tax issues in a third. Within each cabinet, documents are organized in a consistent order so lawyers can quickly find everything they need for a specific case type. Similarly, archetypes group entities with identical component combinations together, storing all their components in adjacent memory locations for maximum cache efficiency.\n\n![Archetype Storage Layout](./diagrams/archetype-organization.svg)\n\nArchetype-based storage represents the most advanced optimization in our ECS architecture. While the basic sparse set approach stores each component type separately, archetypes group entities by their complete component combination and store all components for those entities together. This creates optimal memory layouts for systems that process multiple component types simultaneously.\n\nThe `ArchetypeID` uniquely identifies each distinct component combination found in the ECS world. These IDs are generated dynamically as new component combinations are discovered, creating a registry of all unique entity \"shapes\" in the system.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `id` | `uint32_t` | Unique identifier for this archetype |\n| `componentMask` | `ComponentMask` | Bitset indicating which component types are present |\n| `componentTypes` | `std::vector<ComponentTypeID>` | Ordered list of component types in this archetype |\n| `componentOffsets` | `std::vector<size_t>` | Byte offsets for each component type within entity data |\n| `entityStride` | `size_t` | Total bytes per entity (sum of all component sizes plus padding) |\n\nThe `componentMask` provides a compact representation of which component types are present in this archetype. This bitset enables fast archetype matching during system queries — a system requiring components A, B, and C can quickly check if an archetype contains all three by performing bitwise operations on the mask.\n\n**Chunk-Based Memory Layout**\n\nWithin each archetype, entities are stored in fixed-size chunks that optimize for cache line utilization and memory allocation patterns. Each chunk contains a predetermined number of entities with all their components stored in structure-of-arrays format.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `entities` | `Entity[]` | Array of entity IDs in this chunk |\n| `componentData` | `std::byte*` | Raw memory containing all component data |\n| `entityCount` | `uint32_t` | Number of entities currently stored in this chunk |\n| `capacity` | `uint32_t` | Maximum entities this chunk can hold |\n\nThe component data within each chunk is laid out in structure-of-arrays format, meaning all instances of component type A are stored contiguously, followed by all instances of component type B, and so on. This layout maximizes cache efficiency when systems iterate over specific component types.\n\n**Archetype Transition Management**\n\nOne of the most complex aspects of archetype-based storage is managing transitions when entities gain or lose components. Since adding or removing a component changes an entity's archetype, the entity must be moved between archetype storage areas.\n\nThe archetype transition process follows these steps:\n\n1. **Source Archetype Identification**: Determine the entity's current archetype based on its existing components\n2. **Target Archetype Resolution**: Calculate the new archetype after the component operation (add/remove)\n3. **Target Archetype Creation**: Create the target archetype if it doesn't exist yet\n4. **Entity Data Migration**: Copy the entity's component data from source to target archetype\n5. **Index Updates**: Update all sparse set indices to reflect the entity's new storage location\n6. **Source Cleanup**: Remove the entity from its original archetype storage\n\n> **Decision: Structure-of-Arrays vs Array-of-Structures Layout**\n> - **Context**: Archetype storage needs to organize multiple component types for optimal iteration performance\n> - **Options Considered**:\n>   1. Structure-of-Arrays (SoA): All instances of component A, then all instances of component B\n>   2. Array-of-Structures (AoS): Entity 1's components A+B+C, then Entity 2's components A+B+C\n>   3. Hybrid approach with both layouts available\n> - **Decision**: Structure-of-Arrays layout within archetype chunks\n> - **Rationale**: SoA layout maximizes cache efficiency when systems iterate over specific component types, enables SIMD optimizations, and matches typical system access patterns where not all components are accessed simultaneously\n> - **Consequences**: Requires more complex entity transition logic and may perform worse for systems that access all components of individual entities, but provides significant performance benefits for typical ECS usage patterns\n\n**Archetype Graph and Query Optimization**\n\nThe collection of all archetypes forms a graph structure where edges represent single-component additions or removals. This graph enables several optimizations:\n\n- **Transition Caching**: Common archetype transitions can be precomputed and cached\n- **Query Filtering**: System queries can eliminate entire archetype families based on component requirements\n- **Memory Pooling**: Related archetypes can share memory pools for better allocation performance\n\nThe archetype graph also helps identify potential \"archetype explosion\" issues where too many unique component combinations create excessive memory overhead. Monitoring tools can analyze the graph to suggest component design improvements.\n\n⚠️ **Pitfall: Archetype Explosion**\nCreating too many unique component combinations can lead to archetype explosion, where the overhead of managing numerous small archetypes exceeds the benefits. This often occurs when using components for temporary state (like \"IsJumping\" flags) or unique identifiers. Instead, consider using component data fields for temporary state and reserve separate component types for fundamentally different behaviors. Monitor archetype count and average entities per archetype to detect explosion issues early.\n\n⚠️ **Pitfall: Frequent Archetype Transitions**\nEntities that frequently gain and lose components can create performance bottlenecks due to the cost of moving data between archetypes. This commonly happens with temporary status effects or state-based components. Consider redesigning frequently-changing state as component data fields rather than separate component types, or use a hybrid approach where core components remain stable while auxiliary data is stored separately.\n\n### Implementation Guidance\n\n**Technology Recommendations**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Entity ID Storage | `std::vector<Entity>` with linear search | Hash table or custom allocator with free list |\n| Component Type Registry | `std::unordered_map<std::type_index, TypeInfo>` | Template-based compile-time registry |\n| Sparse Set Implementation | `std::vector` for dense array, `std::vector` for sparse array | Custom memory pools with chunk allocation |\n| Archetype Storage | `std::vector<std::vector<std::byte>>` per archetype | Memory-mapped files or custom chunk allocators |\n\n**Recommended File Structure**\n\n```cpp\nsrc/ecs/\n  core/\n    entity.hpp              // Entity ID and generation definitions\n    entity.cpp              // Entity validation and utility functions\n    component_type.hpp      // ComponentTypeID and type information\n    component_type.cpp      // Type registry implementation\n  storage/\n    sparse_set.hpp          // Generic sparse set implementation\n    sparse_set.cpp          // Sparse set operations\n    component_storage.hpp   // Template component storage classes\n    component_storage.cpp   // Type-erased storage base class\n    archetype.hpp           // Archetype data structures\n    archetype.cpp           // Archetype transition logic\n  test/\n    entity_test.cpp         // Entity ID and generation tests\n    sparse_set_test.cpp     // Sparse set correctness tests\n    archetype_test.cpp      // Archetype storage and transition tests\n```\n\n**Core Data Structure Implementations**\n\nHere are the essential data structure definitions that form the foundation of your ECS implementation:\n\n```cpp\n// entity.hpp\n#include <cstdint>\n#include <limits>\n\nusing EntityID = uint32_t;\nusing Generation = uint32_t;\n\nconstexpr EntityID INVALID_ENTITY_ID = std::numeric_limits<EntityID>::max();\nconstexpr Generation DEFAULT_GENERATION = 0;\n\nstruct Entity {\n    EntityID id;\n    Generation generation;\n    \n    // TODO: Implement equality operators for entity comparison\n    // TODO: Implement hash function for use in containers\n    // TODO: Add validation method to check for INVALID_ENTITY\n};\n\nconstexpr Entity INVALID_ENTITY = {INVALID_ENTITY_ID, DEFAULT_GENERATION};\n\n// component_type.hpp  \n#include <string>\n#include <typeindex>\n#include <functional>\n\nusing ComponentTypeID = uint32_t;\n\nstruct ComponentTypeInfo {\n    ComponentTypeID typeID;\n    std::string name;\n    size_t size;\n    size_t alignment;\n    std::function<void(void*)> destructor;\n    std::function<void(void*, void*)> moveConstructor;\n    \n    // TODO: Add copy constructor function pointer\n    // TODO: Add serialization function pointers for advanced features\n    // TODO: Add debug string conversion for component inspection\n};\n\nclass ComponentTypeRegistry {\nprivate:\n    static ComponentTypeID nextTypeID;\n    static std::unordered_map<std::type_index, ComponentTypeInfo> typeMap;\n    \npublic:\n    // TODO: Implement getTypeID<T>() that returns cached or generates new type ID\n    // TODO: Implement getTypeInfo(ComponentTypeID) for runtime type information\n    // TODO: Implement registerType<T>() for explicit type registration\n    // TODO: Add iteration support for all registered types\n};\n```\n\n**Sparse Set Foundation**\n\nThe sparse set implementation provides the core mapping mechanism between entities and components:\n\n```cpp\n// sparse_set.hpp\n#include \"entity.hpp\"\n#include <vector>\n\ntemplate<typename T>\nclass SparseSet {\nprivate:\n    std::vector<T> dense;           // Contiguous storage of components\n    std::vector<uint32_t> sparse;   // Maps entity ID to dense array index\n    std::vector<Entity> entities;   // Maps dense index to entity\n    \npublic:\n    // TODO: Implement insert(Entity, T&&) - add component to entity\n    // TODO: Implement remove(Entity) - remove component and compact array\n    // TODO: Implement get(Entity) -> T& - retrieve component reference\n    // TODO: Implement has(Entity) -> bool - check if entity has component\n    // TODO: Implement size() and capacity() for memory management\n    // TODO: Implement begin()/end() iterators for component iteration\n    // TODO: Implement clear() to remove all components\n    \nprivate:\n    // TODO: Implement ensureSparseCapacity(EntityID) for dynamic growth\n    // TODO: Implement swapRemove(size_t index) for efficient removal\n    // TODO: Implement validateEntity(Entity) for generation checking\n};\n```\n\n**Archetype Data Structures**\n\nFor advanced implementations, the archetype system requires careful data layout planning:\n\n```cpp\n// archetype.hpp\n#include \"component_type.hpp\"\n#include <bitset>\n#include <memory>\n\nconstexpr size_t MAX_COMPONENTS = 64;\nusing ComponentMask = std::bitset<MAX_COMPONENTS>;\n\nstruct ArchetypeInfo {\n    uint32_t archetypeID;\n    ComponentMask componentMask;\n    std::vector<ComponentTypeID> componentTypes;\n    std::vector<size_t> componentOffsets;\n    size_t entityStride;\n    \n    // TODO: Add calculateStride() method to compute entity data size\n    // TODO: Add hasComponent(ComponentTypeID) helper method\n    // TODO: Add isSubsetOf(ComponentMask) for query matching\n};\n\nclass ArchetypeChunk {\nprivate:\n    std::unique_ptr<std::byte[]> data;\n    std::vector<Entity> entities;\n    uint32_t entityCount;\n    uint32_t capacity;\n    const ArchetypeInfo* archetype;\n    \npublic:\n    // TODO: Implement addEntity(Entity, component data...) \n    // TODO: Implement removeEntity(Entity) with swap-remove\n    // TODO: Implement getComponent<T>(Entity) with offset calculation\n    // TODO: Implement iteration support for bulk component access\n    // TODO: Add memory management for chunk resizing\n};\n```\n\n**Milestone Checkpoints**\n\nAfter implementing each milestone, verify functionality with these checkpoints:\n\n**Milestone 1 - Entity Manager:**\n- Create 1000 entities, destroy every other one, create 1000 more\n- Verify that generation counters increment correctly for recycled IDs  \n- Verify that `isAlive()` returns false for destroyed entities\n- Expected behavior: No entity ID exceeds 1000, but generations vary\n\n**Milestone 2 - Component Storage:**\n- Add Position and Velocity components to 100 entities\n- Remove Position from entities 50-99, verify Velocity components remain\n- Iterate over all Position components and verify count equals 50\n- Expected behavior: Contiguous iteration with no gaps or invalid data\n\n**Milestone 3 - System Interface:**\n- Create entities with various component combinations\n- Implement a movement system requiring Position + Velocity\n- Query should return only entities having both components\n- Expected behavior: System processes exactly the entities matching query\n\n**Milestone 4 - Archetypes (Advanced):**\n- Monitor archetype creation as component combinations are added\n- Add/remove components and verify entities transition between archetypes\n- Benchmark iteration speed comparing sparse set vs archetype approaches\n- Expected behavior: Fewer cache misses and faster iteration with archetypes\n\n**Language-Specific Hints**\n\n**C++ Implementation Tips:**\n- Use `std::type_index` with `typeid(T)` for component type identification\n- Employ placement new for constructing components in pre-allocated memory\n- Consider `std::unique_ptr<std::byte[]>` for raw memory management in archetypes\n- Use template specialization to cache component type IDs at compile time\n- Implement custom allocators for frequent archetype chunk allocation/deallocation\n\n**Memory Management Considerations:**\n- Component destructors must be called when components are removed\n- Use RAII principles for automatic cleanup of component storage\n- Consider memory pool allocators for fixed-size archetype chunks\n- Implement proper move semantics for component transfers between archetypes\n- Monitor memory fragmentation in long-running applications with frequent entity churn\n\n\n## Entity Manager Design\n\n> **Milestone(s):** Milestone 1 (Entity Manager) — implementing entity ID generation, lifecycle tracking, and ID recycling with generation counters\n\nThe Entity Manager serves as the foundation of our ECS architecture, providing the fundamental service of entity lifecycle management. Think of it as the identity card office for your game world — it issues unique identification cards to game objects, tracks which cards are currently valid, and recycles old cards when objects are destroyed to prevent running out of identification numbers in long-running games.\n\nThis component must solve several challenging problems simultaneously. First, it must generate unique entity identifiers that never collide during runtime, even when millions of entities are created and destroyed. Second, it must efficiently track which entities are currently alive versus destroyed, supporting both fast validation of entity references and efficient iteration over all living entities. Third, it must implement a memory-efficient recycling system that reuses the identifiers of destroyed entities without allowing stale references to accidentally access newly created entities that happen to reuse the same ID.\n\nThe Entity Manager's design directly impacts the performance characteristics of the entire ECS system. Every component lookup, system query, and entity validation flows through this component, making its efficiency critical for overall system performance. A poorly designed entity manager can introduce cache misses, memory fragmentation, and O(n) lookup operations that cripple game performance.\n\n### Mental Model: Library Card System\n\nTo understand entity management, imagine a large public library with a sophisticated card catalog system. When someone wants to check out books, they receive a library card with two critical pieces of information: a card number and an issue date (or generation). The card number identifies which slot in the filing system belongs to this patron, while the issue date prevents problems when cards are reused.\n\nHere's how the analogy maps to our Entity Manager:\n\nThe **library card number** corresponds to our `EntityID` — a simple integer that identifies a specific slot in our entity storage arrays. Just as library cards are numbered 1, 2, 3, and so forth, entity IDs are simple incrementing integers that serve as indices into our data structures.\n\nThe **issue date** corresponds to our `Generation` counter — a version number that gets incremented each time a card number is reused. When patron #42 returns their library card, the librarian doesn't immediately give card #42 to the next person. Instead, they update the issue date and keep track of which generation of card #42 is currently valid.\n\nThe **card catalog filing system** corresponds to our entity storage arrays — indexed by the card number, these slots hold information about whether the card is currently issued, what generation it's on, and what books (components) are associated with this patron.\n\nThe **returned card recycling bin** corresponds to our free list — when a patron returns their library card, it goes into a recycling bin to be reissued later rather than being thrown away. This prevents the library from running out of card numbers even after serving millions of patrons over decades.\n\nThe critical insight from this analogy is the **stale reference problem**. Imagine if the library didn't use issue dates — when patron Alice returns card #42, and it's immediately reissued to patron Bob, any old references to \"card #42\" would now incorrectly point to Bob's account instead of Alice's. By including the issue date, the library can detect that a reference to \"card #42 issued in March\" is invalid once that card has been reissued with an April date.\n\nThis same principle prevents our ECS from accidentally accessing the wrong entity when IDs are recycled. An entity reference that holds both the ID (42) and generation (March) becomes safely invalid once that entity is destroyed and the ID is recycled with a new generation (April).\n\n### Generation Counter Mechanism\n\nThe generation counter mechanism forms the core safety system that prevents stale entity references from causing data corruption or logic errors. Every entity consists of two components: an `EntityID` that serves as an index into storage arrays, and a `Generation` that serves as a version number for that index slot.\n\nWhen the Entity Manager creates a new entity, it performs several operations atomically. First, it selects an `EntityID` — either by reusing a recycled ID from the free list or by allocating a new ID by incrementing the global entity counter. Second, it increments the generation counter for that specific entity slot, ensuring that any previous references to this entity ID become invalid. Third, it marks the entity slot as alive in the entity status tracking structure. Finally, it returns an `Entity` structure containing both the ID and the current generation.\n\nThe generation counter prevents the **ABA problem** that would otherwise plague entity references. Consider this scenario without generations: Entity A is created with ID 100, a system stores a reference to entity 100, entity A is destroyed, entity B is created and reuses ID 100, and the system's stale reference to entity 100 now incorrectly accesses entity B's data. This silent corruption can cause subtle bugs that are extremely difficult to debug.\n\nWith generation counters, the scenario becomes safe: Entity A is created with ID 100 and generation 1, a system stores a reference to entity (100, 1), entity A is destroyed, entity B is created with ID 100 and generation 2, and when the system attempts to access entity (100, 1), the Entity Manager detects the generation mismatch and safely returns an \"entity not found\" error instead of returning entity B's data.\n\n**Decision: 32-bit Generation Counters**\n- **Context**: We need to choose the size of generation counters, balancing memory usage against overflow risk\n- **Options Considered**: 16-bit (65K generations), 32-bit (4B generations), 64-bit (effectively unlimited)\n- **Decision**: 32-bit generation counters\n- **Rationale**: 32-bit provides 4 billion generations per entity slot, which even at 60 FPS with one entity created/destroyed per frame would take over 2 years to overflow a single slot. 64-bit would double memory usage for entity references with no practical benefit, while 16-bit creates realistic overflow scenarios in long-running games.\n- **Consequences**: Each entity reference uses 8 bytes total (4 bytes ID + 4 bytes generation), and generation overflow is a theoretical concern that can be handled by reserving the maximum generation value as a \"permanent\" marker for entities that should never be recycled.\n\nThe Entity Manager maintains a **generation table** that maps each entity ID to its current generation counter. This table grows as new entity IDs are allocated and never shrinks, since even recycled entity IDs need their generation counters to be maintained. The table structure supports constant-time access for generation validation and updates.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `generations` | `vector<Generation>` | Maps entity ID to current generation counter for that slot |\n| `aliveFlags` | `vector<bool>` | Bit vector indicating which entity IDs are currently alive |\n| `freeList` | `queue<EntityID>` | Queue of recycled entity IDs available for reuse |\n| `nextEntityID` | `EntityID` | Next unused entity ID for allocation when free list is empty |\n\nWhen validating an entity reference, the Entity Manager performs these steps:\n\n1. Extract the entity ID and generation from the entity reference\n2. Check if the entity ID is within the bounds of the generations table\n3. Look up the current generation for this entity ID in the generations table\n4. Compare the reference generation with the current generation\n5. Check if the entity is marked as alive in the alive flags bit vector\n6. Return true only if the generations match and the entity is alive\n\nThis validation process runs in constant time O(1) since all operations are simple array indexers and integer comparisons. The bit vector for alive flags provides cache-efficient storage, packing 8 entity status flags into each byte of memory.\n\n### ID Recycling Strategy\n\nThe ID recycling strategy addresses a critical concern for long-running applications: preventing entity ID exhaustion while maintaining constant-time allocation and deallocation performance. Games, especially persistent online games or game engines, may create and destroy millions of entities over their lifetime. A naive approach that simply increments a global counter would eventually overflow, while a complex approach that tries to find gaps in the ID space would introduce expensive search operations.\n\nOur recycling strategy uses a **free list** data structure — a simple queue that holds entity IDs that have been freed and are available for reuse. When an entity is destroyed, its ID is pushed onto the free list after incrementing the generation counter for that slot. When a new entity is created, the Entity Manager first checks if the free list contains any recycled IDs before allocating a new ID from the global counter.\n\nThe free list provides several important guarantees. First, it ensures that entity creation runs in amortized constant time — most creations will pop from the free list in O(1), and only when the free list is empty will the system need to allocate a new ID. Second, it provides excellent memory locality for recently used entity IDs, since recently freed IDs are likely to have their associated memory pages still in CPU cache. Third, it prevents unbounded growth of the entity ID space in applications with steady-state entity counts.\n\n**Decision: FIFO Free List Implementation**\n- **Context**: We need to choose the ordering strategy for recycled entity IDs to optimize cache locality and prevent pathological cases\n- **Options Considered**: LIFO stack (reuse most recent), FIFO queue (age-based reuse), random selection\n- **Decision**: FIFO queue implementation\n- **Rationale**: FIFO provides better temporal locality by ensuring recently freed entities have time for their associated component data to be evicted from cache before the ID is reused. LIFO could cause thrashing by immediately reusing entity IDs whose component data is still hot in cache, potentially confusing debugging. Random selection provides no cache benefits and complicates implementation.\n- **Consequences**: Entity IDs experience a \"cooling off\" period before reuse, improving cache behavior and making debugging easier since recently destroyed entities won't immediately have their IDs reused.\n\nThe implementation maintains several data structures to support efficient recycling:\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `createEntity` | none | `Entity` | Pops from free list or allocates new ID, increments generation, marks alive |\n| `destroyEntity` | `Entity entity` | `void` | Validates entity, marks not alive, pushes ID to free list, increments generation |\n| `isAlive` | `Entity entity` | `bool` | Validates entity ID and generation against current state |\n| `getAllEntities` | none | `vector<Entity>` | Returns all currently alive entities for iteration |\n\nThe recycling process follows these steps when creating an entity:\n\n1. Check if the free list contains any recycled entity IDs\n2. If free list is not empty, pop the oldest recycled ID from the front of the queue\n3. If free list is empty, use the next available ID from the global counter and increment the counter\n4. Increment the generation counter for the selected entity ID slot\n5. Mark the entity ID as alive in the status bit vector\n6. Return an `Entity` structure with the ID and new generation\n\nThe recycling process follows these steps when destroying an entity:\n\n1. Validate that the entity reference is currently alive using the generation counter\n2. Mark the entity ID as not alive in the status bit vector\n3. Increment the generation counter for this entity ID slot (invalidating existing references)\n4. Push the entity ID onto the back of the free list queue for future reuse\n5. Notify any registered observers that the entity has been destroyed (for component cleanup)\n\nThis approach handles the **generation overflow** edge case by reserving the maximum generation value (`UINT32_MAX`) as a special \"permanent\" marker. If an entity ID's generation counter would overflow, the Entity Manager instead marks it as permanent and never recycles it. In practice, this requires creating and destroying the same entity ID 4 billion times, which is extremely unlikely even in long-running applications.\n\n**Memory Efficiency Considerations**\n\nThe recycling strategy also addresses memory efficiency concerns in the component storage systems. When an entity is destroyed, its components must be removed from their respective storage arrays. The Entity Manager provides hooks for component systems to register cleanup callbacks that are invoked during entity destruction, ensuring that component memory is freed promptly rather than accumulating as garbage.\n\nThe free list size is capped to prevent memory usage from growing unbounded in applications that experience temporary spikes in entity creation. When the free list exceeds a configured threshold (default 1024 entries), older entries are discarded and those entity IDs become permanently unavailable for allocation. This trades a small amount of entity ID space for bounded memory usage.\n\n### Common Entity Management Pitfalls\n\nEntity management introduces several subtle pitfalls that can cause crashes, data corruption, or performance problems. Understanding these pitfalls helps developers build robust ECS implementations and debug issues that arise in complex game scenarios.\n\n⚠️ **Pitfall: Stale Entity References**\n\nThe most common and dangerous pitfall is improper handling of stale entity references. This occurs when game code stores entity references in local variables, member variables, or data structures, and continues using them after the referenced entity has been destroyed. Without proper validation, stale references can access memory belonging to newly created entities, causing silent data corruption.\n\nConsider this problematic sequence: a combat system stores a reference to a \"target enemy\" entity in a member variable, the enemy dies and its entity is destroyed during the same frame, a new pickup item is created and happens to reuse the same entity ID, and the combat system continues using its stale reference, accidentally treating the pickup item as an enemy and potentially corrupting its component data.\n\nThe correct approach requires validating entity references before every use by calling `isAlive()`. Systems should be designed to gracefully handle entity validation failures by cleaning up their internal state and continuing execution. Critical references (such as parent-child relationships) should use observer patterns or event systems to be notified when referenced entities are destroyed.\n\n⚠️ **Pitfall: Entity Reference Storage in Components**\n\nA subtle variant of the stale reference problem occurs when components store references to other entities. For example, a `Parent` component might store an entity reference to indicate hierarchical relationships, or a `Target` component might reference an entity being pursued by an AI. These stored references can become stale when the referenced entities are destroyed.\n\nThe solution requires implementing a **reference tracking system** where the Entity Manager maintains a registry of which entities reference which other entities. When an entity is destroyed, the Entity Manager iterates through all entities that reference it and either nullifies their references or triggers cleanup callbacks. This adds complexity but prevents silent corruption in entity relationship systems.\n\n⚠️ **Pitfall: Generation Counter Overflow**\n\nAlthough generation overflow is unlikely with 32-bit counters, it represents a potential crash or corruption source in extremely long-running applications. The overflow occurs when an entity ID is recycled so frequently that its generation counter wraps around to zero, potentially causing very old stale references to become valid again.\n\nThe defense against overflow involves reserving the maximum generation value as a \"permanent\" sentinel that prevents further recycling. When a generation counter reaches `UINT32_MAX - 1`, the next destruction marks it as permanent rather than incrementing to zero. The entity ID becomes permanently unavailable for allocation, trading a small amount of ID space for safety.\n\n⚠️ **Pitfall: Iteration Invalidation During Entity Creation/Destruction**\n\nEntity creation and destruction during iteration over the alive entities list can cause iterator invalidation, crashes, or skipped entities. This commonly occurs when systems create or destroy entities based on conditions they discover during iteration, such as spawning projectiles when iterating over weapons or destroying entities when their health reaches zero.\n\nThe safe approach requires deferring entity lifecycle operations until after iteration completes. Systems should collect entities to be created or destroyed in temporary lists during iteration, then process those lists after iteration finishes. Alternatively, the Entity Manager can provide \"deferred\" creation and destruction methods that queue operations for execution at safe points.\n\n⚠️ **Pitfall: Component Access Without Entity Validation**\n\nSystems often assume that if they successfully queried for entities with specific components, those entities will remain valid throughout the frame. However, other systems executing earlier in the frame might have destroyed some of those entities, leaving the query results containing stale references.\n\nThe solution requires either validating entities before accessing their components, or designing the system execution order to guarantee that entity destruction happens at specific, well-defined points in the frame (such as at the end of frame processing). The latter approach is more performant but requires careful architectural planning.\n\n⚠️ **Pitfall: Free List Memory Growth**\n\nIn applications with highly variable entity counts, the free list can grow very large during high entity count periods and then retain that memory even when entity counts drop. This creates memory usage that never shrinks, potentially causing memory pressure in memory-constrained environments.\n\nThe mitigation involves implementing a **free list size cap** and periodically compacting the free list during low-activity periods. When the free list exceeds the cap, the oldest entries are discarded (permanently retiring those entity IDs). During compaction, the system can rebuild the free list to use only recent entries, allowing garbage collection of the old free list memory.\n\n### Common Entity Management Pitfalls\n\n| Failure Mode | Detection Method | Prevention Strategy | Recovery Approach |\n|--------------|------------------|-------------------|------------------|\n| Stale reference access | Debug assertions on `isAlive()` | Validate before every access | Clean up invalid references, continue |\n| Generation overflow | Monitor generation values | Use permanent marker at max value | Block recycling, log warning |\n| Iterator invalidation | Crash or skipped entities | Defer creation/destruction | Exception handling, state repair |\n| Free list growth | Memory monitoring | Size caps and compaction | Discard excess entries |\n| Component reference cycles | Reference count tracking | Weak references for cycles | Break cycles during destruction |\n\n![Entity Lifecycle State Machine](./diagrams/entity-lifecycle.svg)\n\nThe entity lifecycle state machine shows the complete flow from entity creation through active usage to destruction and ID recycling. Notice how the generation counter increments at two key points: when an entity is created (to invalidate any previous references to this ID) and when an entity is destroyed (to invalidate current references before recycling). This dual-increment approach ensures that stale references become invalid immediately rather than remaining dangerous until the next entity reuses the ID.\n\n![Core Data Types and Relationships](./diagrams/data-model-relationships.svg)\n\nThe data model relationships diagram illustrates how the Entity Manager's data structures interconnect with the broader ECS system. The `Entity` structure combining `EntityID` and `Generation` serves as the fundamental reference type that flows through all component operations and system queries. The generation counter mechanism ensures that these references remain safe even as entity IDs are recycled through the free list management system.\n\n### Implementation Guidance\n\nThe Entity Manager provides the foundation for all ECS operations, so its implementation must balance simplicity with performance. The following guidance helps you build a robust entity management system that will scale from simple prototypes to production games.\n\n**A. Technology Recommendations Table:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Entity Storage | `std::vector<Generation>` + `std::vector<bool>` | Custom packed bitfields with SIMD operations |\n| Free List | `std::queue<EntityID>` | Lock-free circular buffer for multithreading |\n| Entity Validation | Simple array lookup | Bloom filter for fast negative results |\n| Memory Management | Standard allocators | Custom memory pools for entity metadata |\n\n**B. Recommended File Structure:**\n\n```\nproject-root/\n  src/\n    ecs/\n      entity_manager.hpp           ← EntityManager class declaration\n      entity_manager.cpp           ← EntityManager implementation\n      entity_types.hpp             ← Entity, EntityID, Generation type definitions\n      entity_manager_test.cpp      ← Unit tests for entity lifecycle\n    core/\n      types.hpp                    ← Basic type definitions (uint32_t aliases)\n```\n\n**C. Infrastructure Starter Code:**\n\n```cpp\n// entity_types.hpp - Complete type definitions ready to use\n#pragma once\n#include <cstdint>\n#include <limits>\n\nusing EntityID = uint32_t;\nusing Generation = uint32_t;\n\nconstexpr EntityID INVALID_ENTITY_ID = std::numeric_limits<EntityID>::max();\nconstexpr Generation DEFAULT_GENERATION = 1;\n\nstruct Entity {\n    EntityID id;\n    Generation generation;\n    \n    Entity() : id(INVALID_ENTITY_ID), generation(0) {}\n    Entity(EntityID id_, Generation gen_) : id(id_), generation(gen_) {}\n    \n    bool operator==(const Entity& other) const {\n        return id == other.id && generation == other.generation;\n    }\n    \n    bool operator!=(const Entity& other) const {\n        return !(*this == other);\n    }\n    \n    bool isValid() const {\n        return id != INVALID_ENTITY_ID && generation > 0;\n    }\n};\n\nconst Entity INVALID_ENTITY = Entity();\n\n// Hash function for using Entity as std::unordered_map key\nnamespace std {\n    template<>\n    struct hash<Entity> {\n        size_t operator()(const Entity& entity) const {\n            return hash<uint64_t>()((uint64_t(entity.generation) << 32) | entity.id);\n        }\n    };\n}\n```\n\n**D. Core Logic Skeleton Code:**\n\n```cpp\n// entity_manager.hpp - Class declaration with complete interface\n#pragma once\n#include \"entity_types.hpp\"\n#include <vector>\n#include <queue>\n#include <functional>\n\nclass EntityManager {\npublic:\n    using EntityDestroyedCallback = std::function<void(Entity)>;\n    \n    EntityManager();\n    ~EntityManager() = default;\n    \n    // Core entity lifecycle operations\n    Entity createEntity();\n    void destroyEntity(Entity entity);\n    bool isAlive(Entity entity) const;\n    \n    // Bulk operations for system queries\n    std::vector<Entity> getAllEntities() const;\n    size_t getAliveEntityCount() const;\n    \n    // Callback registration for component cleanup\n    void registerDestroyCallback(EntityDestroyedCallback callback);\n    \n    // Debug and statistics\n    size_t getFreeListSize() const;\n    EntityID getNextEntityID() const;\n    \nprivate:\n    std::vector<Generation> generations_;\n    std::vector<bool> aliveFlags_;\n    std::queue<EntityID> freeList_;\n    EntityID nextEntityID_;\n    std::vector<EntityDestroyedCallback> destroyCallbacks_;\n    \n    static constexpr size_t MAX_FREE_LIST_SIZE = 1024;\n    static constexpr Generation PERMANENT_GENERATION = std::numeric_limits<Generation>::max();\n};\n\n// entity_manager.cpp - Implementation skeleton with TODOs\n#include \"entity_manager.hpp\"\n#include <algorithm>\n#include <cassert>\n\nEntityManager::EntityManager() \n    : nextEntityID_(0) {\n    // Reserve some initial capacity to avoid early reallocations\n    generations_.reserve(1000);\n    aliveFlags_.reserve(1000);\n}\n\nEntity EntityManager::createEntity() {\n    EntityID entityID;\n    \n    // TODO 1: Check if free list has any recycled IDs available\n    // TODO 2: If free list not empty, pop the front ID for reuse\n    // TODO 3: If free list empty, allocate new ID from nextEntityID_ and increment it\n    // TODO 4: Ensure the generations_ and aliveFlags_ vectors are large enough for this ID\n    // TODO 5: Increment the generation counter for this entity ID slot\n    // TODO 6: Mark the entity as alive in aliveFlags_\n    // TODO 7: Return Entity structure with the ID and new generation\n    // Hint: Use generations_.resize() if entityID >= generations_.size()\n}\n\nvoid EntityManager::destroyEntity(Entity entity) {\n    // TODO 1: Validate that the entity is currently alive using isAlive()\n    // TODO 2: If not alive, log warning and return early (don't crash)\n    // TODO 3: Mark entity as not alive in aliveFlags_\n    // TODO 4: Increment generation counter for this entity ID (invalidates references)\n    // TODO 5: Check if generation would overflow to 0 - if so, mark as permanent\n    // TODO 6: If not permanent, add entity ID to free list for recycling\n    // TODO 7: Notify all registered destroy callbacks with the entity\n    // TODO 8: If free list exceeds MAX_FREE_LIST_SIZE, remove oldest entries\n    // Hint: Check generation < PERMANENT_GENERATION before incrementing\n}\n\nbool EntityManager::isAlive(Entity entity) const {\n    // TODO 1: Check if entity.id is within bounds of generations_ vector\n    // TODO 2: If out of bounds, return false (never allocated)\n    // TODO 3: Look up current generation for this entity ID\n    // TODO 4: Compare entity.generation with current generation - must match exactly\n    // TODO 5: Check aliveFlags_[entity.id] to verify entity is marked alive\n    // TODO 6: Return true only if generation matches AND entity is alive\n    // Hint: Use entity.id < generations_.size() for bounds check\n}\n\nstd::vector<Entity> EntityManager::getAllEntities() const {\n    std::vector<Entity> result;\n    result.reserve(getAliveEntityCount());\n    \n    // TODO 1: Iterate through all possible entity IDs up to generations_.size()\n    // TODO 2: For each ID, check if aliveFlags_[id] is true\n    // TODO 3: If alive, create Entity(id, generations_[id]) and add to result\n    // TODO 4: Return the completed vector of alive entities\n    // Hint: This enables systems to iterate over all entities efficiently\n    \n    return result;\n}\n\nsize_t EntityManager::getAliveEntityCount() const {\n    // TODO 1: Count the number of 'true' values in aliveFlags_\n    // TODO 2: Only count up to nextEntityID_ to avoid counting unallocated slots\n    // Hint: Use std::count() algorithm or simple loop\n}\n\nvoid EntityManager::registerDestroyCallback(EntityDestroyedCallback callback) {\n    destroyCallbacks_.push_back(callback);\n}\n\nsize_t EntityManager::getFreeListSize() const {\n    return freeList_.size();\n}\n\nEntityID EntityManager::getNextEntityID() const {\n    return nextEntityID_;\n}\n```\n\n**E. Language-Specific Hints:**\n\n- **Memory Efficiency**: Use `std::vector<bool>` for alive flags — it's specially optimized to pack 8 booleans per byte\n- **Performance**: Reserve initial capacity for vectors to avoid reallocations during early entity creation\n- **Thread Safety**: This implementation is not thread-safe. For multithreaded use, add `std::mutex` around all public methods\n- **Debugging**: Add debug assertions with `assert()` to catch invalid entity access during development\n- **Overflow Safety**: Always check generation overflow before incrementing to prevent wraparound to 0\n\n**F. Milestone Checkpoint:**\n\nAfter implementing the Entity Manager, verify it works correctly:\n\n```cpp\n// Test basic entity lifecycle\nEntityManager manager;\n\n// Create entities and verify they're alive\nEntity e1 = manager.createEntity();\nEntity e2 = manager.createEntity();\nassert(manager.isAlive(e1));\nassert(manager.isAlive(e2));\nassert(manager.getAliveEntityCount() == 2);\n\n// Destroy an entity and verify it's dead\nmanager.destroyEntity(e1);\nassert(!manager.isAlive(e1));\nassert(manager.isAlive(e2));\nassert(manager.getAliveEntityCount() == 1);\n\n// Create new entity and verify ID recycling\nEntity e3 = manager.createEntity();\nassert(e3.id == e1.id);  // Should reuse the ID\nassert(e3.generation > e1.generation);  // But with higher generation\nassert(!manager.isAlive(e1));  // Old reference still invalid\nassert(manager.isAlive(e3));   // New reference valid\n```\n\nExpected behavior:\n- Entity creation returns valid entities with unique generation numbers\n- Destroyed entities fail `isAlive()` checks immediately\n- Entity IDs get recycled but with incremented generation counters\n- `getAllEntities()` returns only currently alive entities\n- Free list size grows when entities are destroyed and shrinks when IDs are recycled\n\nSigns something is wrong:\n- Assertion failures indicating stale references aren't being invalidated\n- Memory usage growing unbounded (free list not being managed properly)\n- Entity IDs not being recycled (new entities always get fresh IDs)\n- Crashes when accessing destroyed entities (generation validation not working)\n\n\n## Component Storage Design\n\n> **Milestone(s):** Milestone 2 (Component Storage) — implementing cache-friendly component storage with sparse sets for constant-time entity-to-component mapping\n\nThe Component Storage system forms the data access backbone of our ECS architecture. While the Entity Manager handles entity lifecycles, the Component Storage system manages the actual component data that gives meaning to those entities. The fundamental challenge is maintaining both cache-friendly iteration patterns for systems processing many entities and constant-time random access for individual entity operations. Our solution employs sparse sets as the core data structure, providing the optimal balance between memory efficiency, access speed, and cache locality.\n\n### Mental Model: Warehouse with Index Cards\n\nThink of the Component Storage system as a modern warehouse with a sophisticated indexing system. The warehouse has two distinct areas: the **storage floor** and the **index card catalog**.\n\nThe **storage floor** contains rows of identical shelves, where each shelf holds one specific type of product (component type). All products of the same type are stored together in consecutive shelf positions for efficient bulk operations — imagine a forklift driver who can quickly process an entire row of the same product type. This represents our **dense component arrays** where all `Position` components are stored contiguously, all `Velocity` components are stored together, and so forth.\n\nThe **index card catalog** sits at the warehouse entrance. Each customer (entity) has a unique customer ID number, but these ID numbers are not consecutive — customer #5 might be followed by customer #847. The index cards provide instant lookup: given any customer ID, you can immediately find which shelf position holds their specific products, if any. This represents our **sparse arrays** that map entity IDs to positions in the dense component arrays.\n\nWhen a customer places an order (system queries entities), they specify which product types they need. The warehouse staff can quickly scan the index catalog to identify which customers have all the required products, then efficiently walk through the storage floor collecting items shelf by shelf. When a customer cancels their account (entity destruction), their index card is removed and their shelf positions are marked available for the next customer.\n\nThis mental model captures three critical aspects: sparse entity IDs require indirect indexing, components of the same type benefit from contiguous storage, and the mapping between sparse IDs and dense storage must be bidirectional for efficient insertion and removal operations.\n\n### Sparse Set Data Structure\n\n![Sparse Set Data Structure](./diagrams/sparse-set-structure.svg)\n\nThe sparse set data structure forms the mathematical foundation of our component storage system. Unlike traditional hash tables or binary trees, sparse sets provide true O(1) operations for all basic operations: insertion, deletion, lookup, and membership testing. Understanding their internal mechanics is crucial for implementing an efficient ECS system.\n\nA sparse set consists of three parallel arrays that work together to create a bidirectional mapping:\n\n| Array Name | Purpose | Size | Access Pattern |\n|------------|---------|------|----------------|\n| `dense` | Stores actual component data contiguously | Number of entities with this component | Sequential iteration for systems |\n| `sparse` | Maps entity IDs to dense array indices | Maximum possible entity ID + 1 | Random access by entity ID |\n| `entities` | Maps dense array indices back to entity IDs | Same size as dense array | Reverse lookup during removal |\n\nThe **dense array** stores the actual component data in contiguous memory. When a system iterates over all entities with `Position` components, it walks through this array linearly, achieving optimal cache locality. Each position in the dense array corresponds to exactly one entity that possesses this component type.\n\nThe **sparse array** provides the mapping from entity IDs to dense array positions. Given an entity ID of 847, we check `sparse[847]` to find which position in the dense array holds that entity's component. If `sparse[847]` contains 23, then `dense[23]` holds entity 847's component data.\n\nThe **entities array** enables reverse lookup during removal operations. When we need to remove entity 847's component from position 23 in the dense array, we must update the sparse array entry for whichever entity gets moved to fill the gap. The entities array tells us which entity ID corresponds to each dense array position.\n\n> **Design Insight**: The bidirectional mapping is essential for efficient removal. Without the entities array, removing a component would require a linear search through the sparse array to update the mapping for the entity that gets moved during the swap-remove operation.\n\nThe insertion algorithm demonstrates the sparse set's elegance:\n\n1. **Validate entity existence**: Confirm the entity ID is valid and the entity is currently alive\n2. **Check for existing component**: If `sparse[entityID]` points to a valid dense array position and `entities[sparse[entityID]] == entityID`, the entity already has this component type\n3. **Append to dense array**: Add the new component data to the end of the dense array at position `denseSize`\n4. **Update sparse mapping**: Set `sparse[entityID] = denseSize` to point the entity ID to its component's position\n5. **Update reverse mapping**: Set `entities[denseSize] = entityID` to enable reverse lookup\n6. **Increment size counter**: Increase `denseSize` to reflect the additional component\n\nThe removal algorithm employs the swap-remove technique to maintain contiguous storage:\n\n1. **Validate component exists**: Confirm `sparse[entityID]` points to a valid position and the reverse mapping is consistent\n2. **Identify positions**: The component to remove is at position `removeIndex = sparse[entityID]`, and the last component is at position `lastIndex = denseSize - 1`\n3. **Swap elements**: Move the last component to fill the gap: `dense[removeIndex] = dense[lastIndex]`\n4. **Update sparse mapping**: The moved entity needs its sparse array updated: `sparse[entities[lastIndex]] = removeIndex`\n5. **Update reverse mapping**: The new position needs the correct entity ID: `entities[removeIndex] = entities[lastIndex]`\n6. **Decrement size counter**: Reduce `denseSize` to reflect the removed component\n7. **Optional cleanup**: Mark `sparse[entityID]` as invalid to prevent stale access\n\n> **Critical Implementation Detail**: The membership test `sparse[entityID] < denseSize && entities[sparse[entityID]] == entityID` prevents false positives when sparse array positions contain stale indices from previously removed components.\n\n![Core Data Types and Relationships](./diagrams/data-model-relationships.svg)\n\n**Decision: Sparse Set vs Hash Table for Component Storage**\n\n- **Context**: We need constant-time access to components by entity ID while maintaining cache-friendly iteration for systems. Hash tables, dynamic arrays, and sparse sets are the primary contenders.\n- **Options Considered**:\n  - Hash table with entity IDs as keys and component pointers as values\n  - Dynamic array indexed directly by entity ID\n  - Sparse set with dense component array and sparse index mapping\n- **Decision**: Sparse set implementation with separate dense and sparse arrays\n- **Rationale**: Hash tables suffer from cache misses during iteration due to scattered memory layout and require expensive rehashing. Direct indexing by entity ID wastes enormous memory when entity IDs are sparse (entity 1,000,000 would require a million-element array). Sparse sets provide O(1) access like hash tables but guarantee contiguous storage for cache-friendly iteration while using memory proportional to the number of actual components, not the maximum entity ID.\n- **Consequences**: Enables SIMD vectorization of component processing loops, eliminates memory waste from sparse entity ID spaces, and maintains constant-time operations for all component access patterns. The trade-off is slightly more complex implementation logic and the need to maintain three parallel arrays instead of a single hash table.\n\n| Storage Option | Access Time | Iteration Speed | Memory Usage | Cache Locality |\n|----------------|-------------|-----------------|--------------|----------------|\n| Hash Table | O(1) average | Poor (scattered) | High (overhead) | Poor |\n| Direct Array | O(1) | Excellent | Terrible (sparse) | Excellent |\n| Sparse Set | O(1) | Excellent | Optimal | Excellent |\n\n### Type-Safe Component Access\n\nComponent type safety prevents runtime errors that can corrupt game state or crash the application. In a dynamically composed ECS system where entities can have arbitrary component combinations, the type system must enforce that systems only access components that actually exist and match the expected types.\n\nThe component type registry serves as the central authority for component metadata. Every component type receives a unique `ComponentTypeID` during registration, along with essential metadata for memory management and type verification:\n\n| Field | Type | Purpose |\n|-------|------|---------|\n| `typeID` | `ComponentTypeID` | Unique identifier for this component type |\n| `name` | `string` | Human-readable type name for debugging |\n| `size` | `size_t` | Memory footprint in bytes for allocation |\n| `alignment` | `size_t` | Memory alignment requirements for performance |\n| `destructor` | Function pointer | Cleanup function for complex component types |\n| `moveConstructor` | Function pointer | Efficient relocation during storage operations |\n\nThe type-safe access system operates through template specialization and compile-time type resolution. When code requests `getComponent<Position>(entity)`, the compiler instantiates a specialized version of the component storage access functions that can only operate on `Position` components.\n\nTemplate-based component registration happens automatically through C++ template magic:\n\n1. **First access triggers registration**: When `getComponent<Position>()` is called for the first time, template instantiation triggers automatic type registration\n2. **Compile-time type ID generation**: Each component type receives a unique type ID based on template instantiation order or type hashing\n3. **Storage creation**: A specialized `ComponentStorage<Position>` instance is created to hold all `Position` components\n4. **Interface registration**: The storage instance is registered with the type-erased interface system for runtime polymorphic access\n\nThe type-erased interface enables runtime polymorphism while preserving compile-time type safety. The `IComponentStorage` base class provides virtual methods that component-specific storage classes implement:\n\n| Method | Parameters | Returns | Description |\n|--------|-----------|---------|-------------|\n| `removeComponent` | `Entity` | `bool` | Remove component from entity without knowing specific type |\n| `hasComponent` | `Entity` | `bool` | Check component existence without type information |\n| `moveComponent` | `Entity, Entity` | `void` | Transfer component between entities during archetype transitions |\n| `getTypeInfo` | None | `ComponentTypeInfo` | Retrieve metadata for this component type |\n| `getComponentCount` | None | `size_t` | Count total components of this type |\n| `clear` | None | `void` | Remove all components (used during world destruction) |\n\n> **Design Insight**: The combination of compile-time templates and runtime type erasure provides both performance and flexibility. Templates eliminate virtual function overhead in hot paths, while type erasure enables generic algorithms that work with any component type.\n\n**Decision: Template-Based vs Runtime Type System**\n\n- **Context**: Components must be accessed efficiently with type safety, but the ECS system also needs runtime flexibility for tools, serialization, and generic algorithms.\n- **Options Considered**:\n  - Pure template system with all type information at compile time\n  - Runtime type system with string-based or ID-based type lookup\n  - Hybrid system with templates for performance and type-erased interfaces for flexibility\n- **Decision**: Hybrid template and type-erased interface system\n- **Rationale**: Pure templates provide optimal performance but prevent runtime component access needed for debugging tools and data serialization. Pure runtime systems sacrifice performance and type safety. The hybrid approach uses templates for hot paths where systems access known component types, and type-erased interfaces for cold paths like entity destruction and tool integration.\n- **Consequences**: Systems achieve optimal performance through direct template instantiation while maintaining flexibility for runtime operations. The cost is increased implementation complexity and larger binary size due to template instantiation.\n\nThe component access API enforces type safety through careful interface design:\n\n| Method | Template Parameter | Return Type | Safety Guarantee |\n|--------|--------------------|-------------|-------------------|\n| `addComponent<T>` | Component type T | `T&` | Creates typed storage if needed, returns reference to new component |\n| `getComponent<T>` | Component type T | `T&` | Throws exception if component doesn't exist, otherwise returns typed reference |\n| `tryGetComponent<T>` | Component type T | `T*` | Returns null pointer if component doesn't exist, otherwise returns typed pointer |\n| `hasComponent<T>` | Component type T | `bool` | Safe existence check without accessing component data |\n| `removeComponent<T>` | Component type T | `bool` | Returns true if component was removed, false if it didn't exist |\n\nRuntime type validation occurs at key points to catch programming errors early:\n\n1. **Component access validation**: Before returning component references, verify the entity is alive and possesses the requested component type\n2. **Storage type matching**: Ensure the template parameter matches the storage container's actual type to prevent type confusion\n3. **Memory layout verification**: Validate component size and alignment match registered type information to catch ABI mismatches\n4. **Entity lifecycle checking**: Prevent access to components on destroyed entities through generation counter validation\n\n### Common Component Storage Pitfalls\n\nComponent storage systems introduce subtle bugs that can cause memory corruption, performance degradation, or incorrect game behavior. Understanding these pitfalls helps avoid hours of debugging and ensures robust ECS implementations.\n\n⚠️ **Pitfall: Iterator Invalidation During Component Modification**\n\nThe most dangerous pitfall occurs when systems modify component storage while iterating over components. Consider this scenario: a combat system iterates through all entities with `Health` components, and during processing, one entity's health drops to zero, triggering entity destruction that removes its `Health` component. The swap-remove operation moves the last `Health` component to fill the gap, but the iterator continues from the next position, skipping the moved component entirely.\n\n```\nInitial state: [Health_A, Health_B, Health_C, Health_D]\nIterator at position 1 (Health_B)\nHealth_B drops to 0, entity destroyed\nAfter removal: [Health_A, Health_D, Health_C] (D moved to position 1)\nIterator advances to position 2, skipping Health_D entirely\n```\n\nThis manifests as entities mysteriously not receiving damage, healing effects, or other component-based processing. The fix requires careful iteration patterns: either collect entities to modify in a separate pass, use reverse iteration when removing components, or implement removal-safe iterators that account for swap-remove semantics.\n\n⚠️ **Pitfall: Stale Sparse Array Indices**\n\nSparse arrays can contain stale indices that point to dense array positions occupied by different entities. When entity 847 is destroyed, its sparse array entry `sparse[847]` retains the old dense array index. If that position is later filled by entity 1205's component, checking `sparse[847]` returns a valid index that points to entity 1205's data instead of indicating entity 847 has no component.\n\nThe membership test `sparse[entityID] < denseSize && entities[sparse[entityID]] == entityID` prevents this bug by verifying the reverse mapping. However, systems that skip this validation and directly access `dense[sparse[entityID]]` will read incorrect component data, leading to entities affecting each other's behavior in bizarre ways.\n\n⚠️ **Pitfall: ABA Problem in Component References**\n\nComponent references can become invalid when entities are destroyed and their IDs recycled. A system holds a `Position&` reference to entity 500's position component. Entity 500 is destroyed, its ID is recycled, and a new entity receives ID 500 with a different position component. The original reference now points to the new entity's data, causing the system to modify the wrong entity's position.\n\nThis is particularly dangerous in systems that cache component references across multiple frames. The solution requires either using entity-based access instead of caching references, implementing reference invalidation tracking, or using generation counters to detect when entity IDs have been recycled.\n\n⚠️ **Pitfall: Component Storage Memory Leaks**\n\nComponents containing dynamically allocated resources (strings, vectors, smart pointers) can leak memory when removed from storage without proper destruction. The sparse set swap-remove operation moves component data using `memcpy` or similar techniques, but doesn't invoke destructors on the original location.\n\nFor example, a `Name` component containing a `std::string` must have its destructor called when removed, or the string's internal buffer leaks. The component type registry's destructor function pointer addresses this by calling the appropriate cleanup code during component removal.\n\n⚠️ **Pitfall: Sparse Array Memory Explosion**\n\nWhen entity IDs become very large, sparse arrays consume excessive memory. An entity with ID 1,000,000 requires a sparse array with at least one million elements, even if only ten entities exist. This wastes gigabytes of memory and degrades cache performance due to the large memory footprint.\n\nThe solution involves either using hash tables for extremely sparse entity ID spaces, implementing segmented sparse arrays that allocate memory in chunks, or constraining entity ID generation to reasonable ranges with ID recycling policies.\n\n⚠️ **Pitfall: Inconsistent Component Type Registration**\n\nDifferent compilation units can register the same component type with different type IDs if template instantiation occurs in different orders. This causes `Position` components added in one source file to be invisible to systems in another source file because they're stored in different type ID storage containers.\n\nExplicit component type registration during world initialization prevents this by ensuring consistent type ID assignment across all compilation units. The registration order must be deterministic and occur before any component operations.\n\n⚠️ **Pitfall: Dense Array Capacity Management**\n\nFrequent component addition and removal can cause memory fragmentation and performance degradation if dense arrays repeatedly reallocate. Adding components to arrays that frequently exceed capacity triggers expensive copy operations that move all existing components to larger memory blocks.\n\nPre-allocating dense array capacity based on expected entity counts amortizes reallocation costs. However, over-allocation wastes memory, while under-allocation causes performance spikes. Monitoring component count statistics helps find the optimal balance.\n\n⚠️ **Pitfall: Thread Safety Assumptions**\n\nComponent storage operations are not thread-safe by default. Multiple systems accessing components concurrently can cause race conditions where component data is corrupted, sparse array mappings become inconsistent, or dense array size counters become inaccurate.\n\nEven read-only access can be unsafe if other threads are modifying component storage simultaneously. The swap-remove operation temporarily creates inconsistent state where sparse mappings point to incorrect dense array positions until the update completes.\n\nThread safety requires either system scheduling that prevents concurrent access to the same component types, reader-writer locks around component storage operations, or lockless data structures designed for concurrent access.\n\n### Implementation Guidance\n\nThe Component Storage implementation bridges the gap between sparse set theory and practical ECS performance. This section provides complete working code for component infrastructure and detailed skeletons for core storage algorithms.\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Type Registration | Manual registration with macros | Automatic template-based registration |\n| Memory Management | Raw arrays with manual resize | Custom allocators with memory pools |\n| Type Safety | Runtime type ID checking | Compile-time template constraints |\n| Container Library | Standard library containers | Custom containers optimized for ECS |\n\n**Recommended File Structure:**\n\n```\necs-project/\n  include/ecs/\n    component_storage.hpp       ← Public component storage interface\n    component_registry.hpp     ← Component type registration system\n    sparse_set.hpp             ← Core sparse set implementation\n    component_types.hpp        ← Sample component definitions\n  src/ecs/\n    component_storage.cpp      ← Implementation of storage classes\n    component_registry.cpp    ← Type registration implementation\n  tests/\n    test_component_storage.cpp ← Unit tests for component operations\n    test_sparse_set.cpp       ← Tests for sparse set data structure\n  examples/\n    component_demo.cpp        ← Usage examples and benchmarks\n```\n\n**Infrastructure Starter Code (Complete Implementation):**\n\n```cpp\n// include/ecs/component_types.hpp\n#pragma once\n#include <cstdint>\n#include <string>\n#include <functional>\n\nusing EntityID = uint32_t;\nusing Generation = uint32_t;\nusing ComponentTypeID = uint32_t;\n\nstruct Entity {\n    EntityID id;\n    Generation generation;\n    \n    bool operator==(const Entity& other) const {\n        return id == other.id && generation == other.generation;\n    }\n};\n\nconstexpr EntityID INVALID_ENTITY_ID = UINT32_MAX;\nconstexpr Generation DEFAULT_GENERATION = 1;\nconstexpr ComponentTypeID MAX_COMPONENTS = 256;\n\n// Sample component types for testing and examples\nstruct Position {\n    float x, y;\n    Position(float x = 0.0f, float y = 0.0f) : x(x), y(y) {}\n};\n\nstruct Velocity {\n    float dx, dy;\n    Velocity(float dx = 0.0f, float dy = 0.0f) : dx(dx), dy(dy) {}\n};\n\nstruct Health {\n    int current, maximum;\n    Health(int max = 100) : current(max), maximum(max) {}\n};\n\nstruct ComponentTypeInfo {\n    ComponentTypeID typeID;\n    std::string name;\n    size_t size;\n    size_t alignment;\n    std::function<void(void*)> destructor;\n    std::function<void(void*, void*)> moveConstructor;\n};\n```\n\n```cpp\n// include/ecs/component_registry.hpp\n#pragma once\n#include \"component_types.hpp\"\n#include <unordered_map>\n#include <typeinfo>\n#include <typeindex>\n\nclass ComponentTypeRegistry {\nprivate:\n    static ComponentTypeRegistry* instance_;\n    std::unordered_map<std::type_index, ComponentTypeID> typeToID_;\n    std::unordered_map<ComponentTypeID, ComponentTypeInfo> idToInfo_;\n    ComponentTypeID nextTypeID_ = 0;\n\n    ComponentTypeRegistry() = default;\n\npublic:\n    static ComponentTypeRegistry& getInstance() {\n        if (!instance_) {\n            instance_ = new ComponentTypeRegistry();\n        }\n        return *instance_;\n    }\n\n    template<typename T>\n    ComponentTypeID registerComponentType() {\n        std::type_index typeIndex(typeid(T));\n        \n        auto it = typeToID_.find(typeIndex);\n        if (it != typeToID_.end()) {\n            return it->second;  // Already registered\n        }\n\n        ComponentTypeID typeID = nextTypeID_++;\n        typeToID_[typeIndex] = typeID;\n\n        ComponentTypeInfo info;\n        info.typeID = typeID;\n        info.name = typeid(T).name();\n        info.size = sizeof(T);\n        info.alignment = alignof(T);\n        \n        if constexpr (!std::is_trivially_destructible_v<T>) {\n            info.destructor = [](void* ptr) {\n                static_cast<T*>(ptr)->~T();\n            };\n        }\n        \n        if constexpr (!std::is_trivially_move_constructible_v<T>) {\n            info.moveConstructor = [](void* dest, void* src) {\n                new (dest) T(std::move(*static_cast<T*>(src)));\n            };\n        }\n\n        idToInfo_[typeID] = info;\n        return typeID;\n    }\n\n    template<typename T>\n    ComponentTypeID getComponentTypeID() {\n        std::type_index typeIndex(typeid(T));\n        auto it = typeToID_.find(typeIndex);\n        return (it != typeToID_.end()) ? it->second : UINT32_MAX;\n    }\n\n    const ComponentTypeInfo* getTypeInfo(ComponentTypeID typeID) {\n        auto it = idToInfo_.find(typeID);\n        return (it != idToInfo_.end()) ? &it->second : nullptr;\n    }\n};\n\nComponentTypeRegistry* ComponentTypeRegistry::instance_ = nullptr;\n```\n\n**Core Logic Skeleton Code:**\n\n```cpp\n// include/ecs/sparse_set.hpp\n#pragma once\n#include \"component_types.hpp\"\n#include <vector>\n#include <stdexcept>\n\ntemplate<typename T>\nclass SparseSet {\nprivate:\n    std::vector<T> dense_;           // Contiguous component storage\n    std::vector<size_t> sparse_;     // Maps entity ID to dense index\n    std::vector<EntityID> entities_; // Maps dense index to entity ID\n    size_t maxEntityID_;\n\npublic:\n    explicit SparseSet(size_t maxEntities = 10000) : maxEntityID_(maxEntities) {\n        sparse_.resize(maxEntities, SIZE_MAX);  // SIZE_MAX as sentinel\n    }\n\n    // Insert component for entity - returns reference to inserted component\n    T& insert(EntityID entityID, T&& component) {\n        // TODO 1: Validate entityID is within bounds (< maxEntityID_)\n        // TODO 2: Check if entity already has component - if so, replace it\n        // TODO 3: Expand sparse array if entityID >= sparse_.size()\n        // TODO 4: Add component to end of dense array\n        // TODO 5: Update sparse[entityID] to point to new dense index\n        // TODO 6: Update entities array to map dense index back to entityID\n        // TODO 7: Return reference to newly inserted component\n        // Hint: dense_.size() before insertion is the new component's index\n    }\n\n    // Remove component for entity - returns true if component existed\n    bool remove(EntityID entityID) {\n        // TODO 1: Check if entity has component using contains() logic\n        // TODO 2: Get dense index where component is stored\n        // TODO 3: If removing last element, just pop_back and update size\n        // TODO 4: Otherwise, move last element to fill gap (swap-remove)\n        // TODO 5: Update sparse mapping for the moved element\n        // TODO 6: Update entities mapping for the moved element's position\n        // TODO 7: Mark removed entity's sparse entry as invalid (SIZE_MAX)\n        // TODO 8: Remove last element from dense and entities arrays\n        // Hint: The entity being moved is entities_.back()\n    }\n\n    // Check if entity has component\n    bool contains(EntityID entityID) const {\n        // TODO 1: Check if entityID is within sparse array bounds\n        // TODO 2: Get dense index from sparse[entityID]\n        // TODO 3: Verify index is valid (< dense_.size())\n        // TODO 4: Verify reverse mapping is consistent (entities_[index] == entityID)\n        // Hint: This prevents stale indices from returning true\n    }\n\n    // Get component reference - throws if not found\n    T& get(EntityID entityID) {\n        // TODO 1: Use contains() to verify component exists\n        // TODO 2: If not found, throw std::runtime_error with descriptive message\n        // TODO 3: Return reference to component at dense_[sparse_[entityID]]\n        // Hint: Message should include entity ID for debugging\n    }\n\n    // Get component pointer - returns nullptr if not found\n    T* tryGet(EntityID entityID) {\n        // TODO 1: Use contains() to check if component exists\n        // TODO 2: If exists, return pointer to dense_[sparse_[entityID]]\n        // TODO 3: If not exists, return nullptr\n        // Hint: This is the safe alternative to get() for optional access\n    }\n\n    // Iterator support for system queries\n    typename std::vector<T>::iterator begin() { return dense_.begin(); }\n    typename std::vector<T>::iterator end() { return dense_.end(); }\n    typename std::vector<T>::const_iterator begin() const { return dense_.begin(); }\n    typename std::vector<T>::const_iterator end() const { return dense_.end(); }\n\n    // Access entity ID by dense array index during iteration\n    EntityID getEntity(size_t denseIndex) const {\n        return (denseIndex < entities_.size()) ? entities_[denseIndex] : INVALID_ENTITY_ID;\n    }\n\n    size_t size() const { return dense_.size(); }\n    bool empty() const { return dense_.empty(); }\n    void clear() {\n        dense_.clear();\n        entities_.clear();\n        std::fill(sparse_.begin(), sparse_.end(), SIZE_MAX);\n    }\n};\n```\n\n```cpp\n// include/ecs/component_storage.hpp\n#pragma once\n#include \"sparse_set.hpp\"\n#include \"component_registry.hpp\"\n#include <unordered_map>\n#include <memory>\n\n// Type-erased interface for runtime component operations\nclass IComponentStorage {\npublic:\n    virtual ~IComponentStorage() = default;\n    virtual bool removeComponent(EntityID entityID) = 0;\n    virtual bool hasComponent(EntityID entityID) const = 0;\n    virtual ComponentTypeID getTypeID() const = 0;\n    virtual size_t getComponentCount() const = 0;\n    virtual void clear() = 0;\n};\n\n// Typed component storage implementation\ntemplate<typename T>\nclass ComponentStorage : public IComponentStorage {\nprivate:\n    SparseSet<T> storage_;\n    ComponentTypeID typeID_;\n\npublic:\n    ComponentStorage() {\n        auto& registry = ComponentTypeRegistry::getInstance();\n        typeID_ = registry.registerComponentType<T>();\n    }\n\n    // Add component to entity with perfect forwarding\n    template<typename... Args>\n    T& addComponent(EntityID entityID, Args&&... args) {\n        // TODO 1: Construct component with forwarded arguments\n        // TODO 2: Use storage_.insert() to add component\n        // TODO 3: Return reference to added component\n        // Hint: T{std::forward<Args>(args)...} constructs component\n    }\n\n    // Remove component from entity\n    bool removeComponent(EntityID entityID) override {\n        // TODO 1: Use storage_.remove() to remove component\n        // TODO 2: Return the result (true if removed, false if didn't exist)\n    }\n\n    // Check if entity has this component type\n    bool hasComponent(EntityID entityID) const override {\n        // TODO 1: Use storage_.contains() to check existence\n        // TODO 2: Return the result\n    }\n\n    // Get component reference - throws if not found\n    T& getComponent(EntityID entityID) {\n        // TODO 1: Use storage_.get() to retrieve component\n        // TODO 2: Return reference (exception handling is in SparseSet)\n    }\n\n    // Try to get component - returns nullptr if not found\n    T* tryGetComponent(EntityID entityID) {\n        // TODO 1: Use storage_.tryGet() to safely retrieve component\n        // TODO 2: Return pointer (nullptr if not found)\n    }\n\n    // Implementation of IComponentStorage interface\n    ComponentTypeID getTypeID() const override { return typeID_; }\n    size_t getComponentCount() const override { return storage_.size(); }\n    void clear() override { storage_.clear(); }\n\n    // Iterator access for systems\n    auto begin() { return storage_.begin(); }\n    auto end() { return storage_.end(); }\n    auto begin() const { return storage_.begin(); }\n    auto end() const { return storage_.end(); }\n\n    // Access entity ID during iteration\n    EntityID getEntity(size_t index) const { return storage_.getEntity(index); }\n};\n\n// World class that manages all component storage\nclass World {\nprivate:\n    std::unordered_map<ComponentTypeID, std::unique_ptr<IComponentStorage>> componentStorages_;\n\n    template<typename T>\n    ComponentStorage<T>* getOrCreateStorage() {\n        auto& registry = ComponentTypeRegistry::getInstance();\n        ComponentTypeID typeID = registry.registerComponentType<T>();\n        \n        auto it = componentStorages_.find(typeID);\n        if (it == componentStorages_.end()) {\n            auto storage = std::make_unique<ComponentStorage<T>>();\n            auto* ptr = storage.get();\n            componentStorages_[typeID] = std::move(storage);\n            return ptr;\n        }\n        \n        return static_cast<ComponentStorage<T>*>(it->second.get());\n    }\n\npublic:\n    // Add component to entity\n    template<typename T, typename... Args>\n    T& addComponent(EntityID entityID, Args&&... args) {\n        // TODO 1: Get or create storage for component type T\n        // TODO 2: Use storage->addComponent() with forwarded arguments\n        // TODO 3: Return reference to added component\n    }\n\n    // Remove component from entity\n    template<typename T>\n    bool removeComponent(EntityID entityID) {\n        // TODO 1: Get storage for component type T\n        // TODO 2: If storage doesn't exist, return false\n        // TODO 3: Use storage->removeComponent() and return result\n    }\n\n    // Get component reference\n    template<typename T>\n    T& getComponent(EntityID entityID) {\n        // TODO 1: Get storage for component type T\n        // TODO 2: If storage doesn't exist, throw std::runtime_error\n        // TODO 3: Use storage->getComponent() and return reference\n    }\n\n    // Check if entity has component\n    template<typename T>\n    bool hasComponent(EntityID entityID) const {\n        // TODO 1: Get storage for component type T\n        // TODO 2: If storage doesn't exist, return false\n        // TODO 3: Use storage->hasComponent() and return result\n    }\n};\n```\n\n**Milestone Checkpoint:**\n\nAfter implementing the component storage system, verify your implementation with these tests:\n\n```bash\n# Compile and run unit tests\ng++ -std=c++17 -I include tests/test_component_storage.cpp src/ecs/*.cpp -o test_storage\n./test_storage\n```\n\nExpected behavior verification:\n1. **Component Addition**: Create entities and add `Position`, `Velocity`, and `Health` components. Verify `hasComponent<T>()` returns true.\n2. **Component Access**: Retrieve component references and verify data integrity. Modify components and confirm changes persist.\n3. **Component Removal**: Remove components and verify `hasComponent<T>()` returns false. Ensure other components remain unaffected.\n4. **Iterator Performance**: Add 10,000 entities with `Position` components. Time iteration - should process 1M+ components per millisecond.\n5. **Memory Usage**: Monitor memory usage as components are added/removed. Verify memory is reclaimed when components are removed.\n\nSigns of problems and fixes:\n- **Segmentation fault on component access**: Check entity ID bounds validation and sparse array sizing\n- **Stale component data**: Verify the bidirectional mapping check in `contains()` method\n- **Memory leaks**: Ensure destructors are called through the component registry's destructor function pointers\n- **Poor iteration performance**: Profile cache misses - dense arrays should have >95% cache hit rate during iteration\n\n\n## System Interface Design\n\n> **Milestone(s):** Milestone 3 (System Interface) — implementing system execution framework with component queries and execution ordering\n\nThe System Interface provides the execution framework that brings our ECS architecture to life. While entities provide identity and components store data, systems contain the actual game logic that operates on that data each frame. The key architectural challenge is providing systems with an efficient way to find and iterate over entities that match their component requirements, while maintaining cache locality and preventing common iteration pitfalls.\n\n### Mental Model: Assembly Line Stations\n\nThink of systems as **specialized processing stations in a factory assembly line**. Each station (system) has specific requirements for what types of products (entities) it can work on, and it performs a specific operation before passing the product to the next station.\n\nIn a car manufacturing plant, the \"Paint System\" only works on entities that have both a `Body` component and a `Color` component. It doesn't need to know about engines or electronics — it focuses solely on its specialized task. Similarly, the \"Engine Installation System\" requires entities with a `Chassis` component and an `Engine` component, but it ignores paint-related data entirely.\n\nThe assembly line supervisor (our `SystemManager`) ensures that stations operate in the correct order — you can't install the engine before the chassis is ready, and you can't apply clear coat before the base paint. Each station processes many products during its time slice, working efficiently through batches of similar items rather than switching back and forth between different product types.\n\nThis mental model captures three crucial aspects of our system design: **specialization** (each system has specific component requirements), **batched processing** (systems iterate through many matching entities per frame), and **execution ordering** (some systems must run before others to maintain logical consistency).\n\n### Component Query Mechanism\n\nThe heart of the system interface is the **component query mechanism** that allows systems to efficiently find and iterate over entities containing specific component combinations. This mechanism must bridge the gap between a system's logical requirements (\"I need all entities with Position and Velocity\") and the physical storage layout of our component arrays.\n\n![Component Query Execution Flow](./diagrams/component-query-flow.svg)\n\n> **Decision: Template-Based Query Interface**\n> - **Context**: Systems need to specify required components at compile time for type safety and performance\n> - **Options Considered**: Runtime string-based queries, template parameter packs, component bitmask matching\n> - **Decision**: Template parameter pack queries with compile-time type resolution\n> - **Rationale**: Provides zero-cost abstraction with full type safety, enables SIMD optimization opportunities, and prevents runtime type errors\n> - **Consequences**: Slightly more complex syntax but eliminates entire classes of runtime errors and enables better compiler optimizations\n\nOur query interface uses C++ template parameter packs to specify required components at compile time. The `query<Position, Velocity>()` syntax generates a specialized query iterator that knows exactly which component types it needs to access, enabling the compiler to optimize the access patterns and eliminate virtual function calls during the tight inner loops of system execution.\n\n#### Query Execution Process\n\nThe query execution follows a multi-stage process that balances flexibility with performance:\n\n1. **Query Registration**: The system specifies its required component types through template parameters, creating a compile-time component type list\n2. **Entity Filtering**: The query mechanism identifies all entities that possess ALL required component types by intersecting the sparse sets of each component type\n3. **Iterator Construction**: A specialized iterator is constructed that can efficiently traverse the filtered entity set while providing direct access to each required component\n4. **Cache-Friendly Iteration**: The iterator accesses components in memory-layout-friendly patterns to maximize cache locality during system execution\n5. **Component Access**: Systems retrieve strongly-typed component references without runtime type checking or virtual function overhead\n\n| Query Interface Method | Parameters | Returns | Description |\n|------------------------|------------|---------|-------------|\n| `query<Components...>()` | Template parameter pack of component types | `QueryIterator<Components...>` | Creates iterator over entities with all specified components |\n| `QueryIterator::operator*()` | None | `std::tuple<Components&...>` | Dereferences iterator to component references tuple |\n| `QueryIterator::operator++()` | None | `QueryIterator&` | Advances to next matching entity |\n| `QueryIterator::entity()` | None | `Entity` | Returns current entity ID for additional operations |\n| `QueryIterator::valid()` | None | `bool` | Checks if iterator points to valid entity |\n\nThe query mechanism handles several subtle complexities behind its simple interface. When multiple component types are required, the system must find the intersection of entities that exist in ALL relevant sparse sets. Rather than performing expensive set intersection operations, our implementation uses the smallest component set as the iteration base and validates presence in other sets during traversal, trading some CPU cycles for dramatically better memory access patterns.\n\n#### Query Optimization Strategies\n\nOur query implementation employs several optimization strategies to maximize performance during system execution:\n\n**Smallest Set First**: When querying for multiple component types, the query engine automatically identifies the component type with the fewest entities and uses that as the primary iteration source. This minimizes the number of entities that need validation against other component sets.\n\n**Early Termination**: During entity validation, the query checks for component presence in order of likelihood, terminating as soon as any required component is missing. This reduces unnecessary cache misses when entities don't match the complete query.\n\n**Prefetch Hinting**: On supported platforms, the query iterator issues memory prefetch hints for upcoming entities in the iteration sequence, allowing the CPU to speculatively load component data while processing the current entity.\n\n**SIMD-Friendly Layout**: Component access patterns are structured to enable vectorized operations when systems process multiple entities with identical operations, particularly beneficial for mathematical computations on `Position` and `Velocity` components.\n\n> ⚠️ **Pitfall: Dynamic Query Construction**\n> Avoid building queries dynamically at runtime using string-based component names or runtime type information. This prevents compile-time optimization and forces expensive runtime type checking. Instead, use template specialization to create different system variants for different component combinations.\n\n### System Execution and Ordering\n\nThe system execution framework coordinates the orderly execution of all registered systems each frame, ensuring that dependencies are respected and that systems execute with consistent timing information. This framework must balance flexibility in system registration with predictable, high-performance execution.\n\n![System Update Sequence](./diagrams/system-execution-sequence.svg)\n\n> **Decision: Priority-Based System Ordering**\n> - **Context**: Some systems must execute before others (physics before rendering), but strict dependency graphs are complex to maintain\n> - **Options Considered**: Explicit dependency declarations, topological sorting, manual ordering, priority-based scheduling\n> - **Decision**: Integer priority values with lower numbers executing first\n> - **Rationale**: Simple to understand and debug, allows fine-grained control, avoids circular dependency complexity\n> - **Consequences**: Requires careful priority assignment but provides predictable execution order without graph analysis overhead\n\n#### System Base Interface\n\nAll game logic systems inherit from a common `System` base class that defines the execution interface and provides access to the ECS world state. This interface is designed to be minimal yet sufficient for all system types, from simple component updates to complex multi-entity interactions.\n\n| System Interface Method | Parameters | Returns | Description |\n|--------------------------|------------|---------|-------------|\n| `update(World&, float)` | World reference, delta time in seconds | `void` | Main system logic executed each frame |\n| `getName()` | None | `const std::string&` | Returns human-readable system name for debugging |\n| `getPriority()` | None | `int` | Returns execution priority (lower executes first) |\n| `isEnabled()` | None | `bool` | Checks if system should execute this frame |\n| `setEnabled(bool)` | Enable/disable flag | `void` | Allows runtime system activation control |\n\nThe `update` method receives a reference to the complete ECS `World`, allowing systems to perform queries, create/destroy entities, and modify components as needed. The delta time parameter enables frame-rate-independent updates for time-based calculations like physics integration and animation interpolation.\n\n#### System Registration and Lifecycle\n\nSystems are registered with the `SystemManager` during application initialization, specifying their execution priority and any configuration parameters. The registration process validates that priority values don't conflict and builds the execution order list that will be used during frame updates.\n\n1. **Registration Phase**: Systems are registered with unique priorities during application startup, before the main game loop begins\n2. **Validation Phase**: The system manager validates that all required dependencies can be satisfied and that no circular dependencies exist\n3. **Execution List Construction**: Systems are sorted by priority value into a linear execution order that remains constant during runtime\n4. **Frame Execution**: Each frame, systems execute in priority order with consistent delta time and world state access\n5. **Error Handling**: If any system throws an exception, execution continues with subsequent systems to maintain frame consistency\n\n| SystemManager Method | Parameters | Returns | Description |\n|----------------------|------------|---------|-------------|\n| `registerSystem<T>(int, Args...)` | Priority value, constructor arguments | `T*` | Registers system instance with specified priority |\n| `removeSystem<T>()` | Template type parameter | `bool` | Removes system of specified type from execution |\n| `getSystem<T>()` | Template type parameter | `T*` | Retrieves registered system instance or nullptr |\n| `updateAllSystems(World&, float)` | World reference, delta time | `void` | Executes all enabled systems in priority order |\n| `getSystemCount()` | None | `size_t` | Returns number of registered systems |\n\nThe system manager maintains ownership of all registered system instances, handling their lifecycle from registration through destruction. This centralized ownership simplifies memory management and ensures that systems remain valid throughout the application lifecycle.\n\n#### Dependency Management\n\nWhile our priority-based system uses simple integer values rather than explicit dependency graphs, careful priority assignment can encode complex dependency relationships. The key insight is that **data flow dependencies** (system A produces data that system B consumes) are more important than **temporal dependencies** (system A must complete before system B starts).\n\n**Common Priority Ranges**:\n- **Input Processing (0-99)**: Keyboard, mouse, and controller input systems that populate input component state\n- **Game Logic (100-299)**: AI decision making, player control processing, game rule enforcement\n- **Physics Simulation (300-399)**: Collision detection, physics integration, movement resolution  \n- **Animation and Interpolation (400-499)**: Sprite animation, skeletal animation, interpolation between physics steps\n- **Rendering Preparation (500-599)**: Culling, sorting, render command generation\n- **Audio Processing (600-699)**: 3D audio positioning, effect processing, music management\n- **Debug and UI (700-799)**: Debug visualization, UI layout, developer tools\n\nThis priority structure ensures that input is processed before game logic can react to it, physics runs before rendering attempts to display entity positions, and debug information is generated after all gameplay systems have completed their updates.\n\n> ⚠️ **Pitfall: Priority Gaps**\n> Don't assign consecutive priority values like 1, 2, 3, 4. Instead use gaps like 100, 200, 300, 400 to allow inserting new systems later without renumbering existing systems. This is particularly important when multiple programmers are adding systems independently.\n\n### Common System Design Pitfalls\n\nSystem implementation involves several subtle correctness and performance pitfalls that can cause crashes, logic errors, or significant performance degradation. Understanding these pitfalls helps developers write robust systems and debug issues when they arise.\n\n#### Component Modification During Iteration\n\nThe most dangerous pitfall in system design is **modifying the component storage structure while iterating over entities**. This can occur when systems add or remove components from entities during query iteration, potentially invalidating iterators or causing memory corruption.\n\n⚠️ **Pitfall: Iterator Invalidation During Component Addition**\n\nWhen a system adds a component to an entity during iteration, the underlying sparse set may need to resize its dense array to accommodate the new component. This resize operation can invalidate all existing iterators pointing into that array, causing subsequent iterator operations to access invalid memory locations.\n\n```cpp\n// DANGEROUS: Adding components during iteration\nfor (auto [entity, pos] : world.query<Position>()) {\n    if (shouldAddVelocity(pos)) {\n        world.addComponent<Velocity>(entity, {0, 0}); // May invalidate iterator!\n    }\n}\n```\n\n**Detection**: Programs may crash with segmentation faults, produce incorrect results, or exhibit non-deterministic behavior that changes between debug and release builds.\n\n**Prevention**: Collect entities requiring component changes in a separate vector during iteration, then apply changes after iteration completes:\n\n```cpp\n// SAFE: Deferred component modifications  \nstd::vector<Entity> entitiesToModify;\nfor (auto [entity, pos] : world.query<Position>()) {\n    if (shouldAddVelocity(pos)) {\n        entitiesToModify.push_back(entity);\n    }\n}\nfor (Entity entity : entitiesToModify) {\n    world.addComponent<Velocity>(entity, {0, 0});\n}\n```\n\n⚠️ **Pitfall: Entity Destruction During Query Iteration**\n\nDestroying entities during iteration can cause similar iterator invalidation issues, but with the additional complexity that destroyed entities may be recycled immediately, leading to the **ABA problem** where an entity ID points to a completely different entity than expected.\n\n**Detection**: Systems may process entities multiple times, skip entities entirely, or operate on entities with unexpected component combinations.\n\n**Prevention**: Use the same deferred modification pattern, collecting entities for destruction in a separate container and processing them after iteration completes.\n\n#### System Ordering Dependencies\n\nIncorrect system execution order can cause subtle logic bugs that are difficult to reproduce and debug. These issues often manifest as frame-to-frame inconsistencies or state that appears \"one frame behind\" the expected behavior.\n\n⚠️ **Pitfall: Physics After Rendering**\n\nIf the rendering system executes before the physics system, entities will be drawn at their positions from the previous frame, creating a visible lag between input and visual response. This is particularly noticeable during rapid movement or rotation.\n\n**Detection**: Visual stuttering, input lag, or \"ghosting\" effects where entities appear to trail behind their actual logical positions.\n\n**Prevention**: Always ensure physics and movement systems execute before rendering systems by assigning appropriate priority values.\n\n⚠️ **Pitfall: Input Processing After Game Logic**\n\nWhen input systems run after game logic systems, player actions won't take effect until the following frame, creating perceptible input delay and making the game feel unresponsive.\n\n**Detection**: Button presses that seem to be ignored or delayed, particularly noticeable in fast-paced games requiring precise timing.\n\n**Prevention**: Assign input processing systems the highest priority (lowest numeric values) to ensure they execute first each frame.\n\n#### Thread Safety Concerns\n\nWhile our basic ECS implementation is single-threaded, many developers eventually want to parallelize system execution for performance. However, naive parallelization can introduce race conditions and data corruption.\n\n⚠️ **Pitfall: Concurrent Component Access**\n\nMultiple systems accessing the same component types concurrently can create race conditions where one system reads partially-updated data from another system, leading to inconsistent entity state.\n\n**Detection**: Non-deterministic behavior that changes between runs, crashes that only occur under high CPU load, or component values that occasionally contain impossible combinations.\n\n**Prevention**: In single-threaded systems, this isn't a concern. For multi-threaded systems, either use read/write locks around component access or carefully design systems to operate on disjoint component sets.\n\n⚠️ **Pitfall: Entity Creation/Destruction Race Conditions**\n\nCreating or destroying entities from multiple threads simultaneously can corrupt the entity manager's internal data structures, particularly the free list and generation counters.\n\n**Detection**: Entity IDs that resolve to incorrect entities, crashes during entity operations, or memory corruption in entity storage arrays.\n\n**Prevention**: Serialize all entity lifecycle operations through a single thread or use atomic operations with careful memory ordering for the entity manager's critical sections.\n\n#### Performance Anti-Patterns\n\nSeveral system design patterns can severely impact performance by destroying cache locality or introducing unnecessary computational overhead.\n\n⚠️ **Pitfall: Mixed Component Access Patterns**\n\nSystems that access components in unpredictable orders or frequently switch between different component types can cause excessive cache misses, dramatically reducing performance.\n\n**Detection**: Poor performance despite low algorithmic complexity, high cache miss rates in profiling tools, or performance that scales poorly with entity count.\n\n**Prevention**: Structure system logic to access components in consistent patterns, preferably processing all instances of one component type before moving to the next.\n\n⚠️ **Pitfall: Expensive Operations in Inner Loops**\n\nPerforming complex calculations, memory allocations, or system calls during entity iteration can make systems orders of magnitude slower than necessary.\n\n**Detection**: Frame rate drops when entity counts increase, profiling showing hot spots in system update methods, or stuttering during gameplay.\n\n**Prevention**: Move expensive operations outside the iteration loop when possible, pre-calculate values that don't change during iteration, and avoid memory allocation in performance-critical systems.\n\n### Implementation Guidance\n\nThis section provides concrete implementation patterns and starter code for building the system interface, focusing on the template-based query mechanism and priority-driven execution framework.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Query Interface | Template parameter packs with std::tuple | Custom iterator with SFINAE type checking |\n| System Storage | std::vector with manual sorting | Priority queue with stable ordering guarantees |\n| Dependency Management | Integer priorities with manual assignment | Dependency graph with topological sort |\n| Error Handling | Exception propagation with logging | Error codes with graceful degradation |\n| Performance Profiling | Manual timing with std::chrono | Integrated profiler with per-system metrics |\n\n#### Recommended File Structure\n\n```cpp\nproject-root/\n  include/\n    ecs/\n      System.h              ← Base system interface and query templates\n      SystemManager.h       ← System registration and execution coordination\n      Query.h               ← Query iterator implementation and type traits\n  src/\n    ecs/\n      SystemManager.cpp     ← System execution loop and priority management\n  examples/\n    systems/\n      MovementSystem.h      ← Example system showing position/velocity integration\n      RenderSystem.h        ← Example system showing component querying patterns\n      InputSystem.h         ← Example system showing entity creation/destruction\n```\n\n#### System Base Interface (Complete)\n\n```cpp\n// System.h - Base interface for all game logic systems\n#pragma once\n#include <string>\n\n// Forward declarations\nclass World;\n\nclass System {\npublic:\n    explicit System(const std::string& name, int priority)\n        : name_(name), priority_(priority), enabled_(true) {}\n    \n    virtual ~System() = default;\n    \n    // Main system execution method - implement game logic here\n    virtual void update(World& world, float deltaTime) = 0;\n    \n    // System identification and configuration\n    const std::string& getName() const { return name_; }\n    int getPriority() const { return priority_; }\n    \n    bool isEnabled() const { return enabled_; }\n    void setEnabled(bool enabled) { enabled_ = enabled; }\n    \nprotected:\n    std::string name_;\n    int priority_;\n    bool enabled_;\n};\n\n// Helper macro for system priority ranges\n#define PRIORITY_INPUT      100\n#define PRIORITY_LOGIC      200\n#define PRIORITY_PHYSICS    300\n#define PRIORITY_ANIMATION  400\n#define PRIORITY_RENDERING  500\n#define PRIORITY_AUDIO      600\n#define PRIORITY_DEBUG      700\n```\n\n#### Query Interface Implementation (Core Logic Skeleton)\n\n```cpp\n// Query.h - Template-based component query system\n#pragma once\n#include <tuple>\n#include <vector>\n#include \"Entity.h\"\n\n// Forward declaration\nclass World;\n\ntemplate<typename... Components>\nclass QueryIterator {\nprivate:\n    World* world_;\n    std::vector<Entity> entities_;\n    size_t current_index_;\n    \npublic:\n    QueryIterator(World* world, std::vector<Entity>&& entities)\n        : world_(world), entities_(std::move(entities)), current_index_(0) {}\n    \n    // Iterator interface implementation\n    std::tuple<Components&...> operator*() {\n        // TODO 1: Get current entity from entities_[current_index_]\n        // TODO 2: Retrieve each component reference using world_->getComponent<T>()\n        // TODO 3: Return tuple of component references\n        // Hint: Use std::forward_as_tuple for reference tuple construction\n    }\n    \n    QueryIterator& operator++() {\n        // TODO 1: Increment current_index_\n        // TODO 2: Skip any entities that became invalid since query construction\n        // TODO 3: Return reference to self for chaining\n        return *this;\n    }\n    \n    bool operator!=(const QueryIterator& other) const {\n        // TODO 1: Compare current_index_ with other.current_index_\n        // TODO 2: Handle end-of-iteration case when current_index_ >= entities_.size()\n        return current_index_ != other.current_index_;\n    }\n    \n    Entity entity() const {\n        // TODO 1: Validate current_index_ is within bounds\n        // TODO 2: Return entities_[current_index_]\n        return entities_[current_index_];\n    }\n    \n    // Range-based for loop support\n    QueryIterator begin() { return *this; }\n    QueryIterator end() { \n        QueryIterator end_iter = *this;\n        end_iter.current_index_ = entities_.size();\n        return end_iter;\n    }\n};\n\n// Query construction helper - implement in World class\ntemplate<typename... Components>\nQueryIterator<Components...> query(World& world) {\n    // TODO 1: Get all entities that have the first component type\n    // TODO 2: Filter entities to only those having ALL required component types\n    // TODO 3: Collect filtered entities into vector\n    // TODO 4: Return QueryIterator constructed with filtered entities\n    // Hint: Use world.hasComponent<T>() for each required component type\n}\n```\n\n#### System Manager Implementation (Complete)\n\n```cpp\n// SystemManager.cpp - System registration and execution coordination\n#include \"SystemManager.h\"\n#include \"System.h\"\n#include <algorithm>\n#include <iostream>\n#include <stdexcept>\n\nclass SystemManager {\nprivate:\n    std::vector<std::unique_ptr<System>> systems_;\n    bool systems_sorted_;\n    \npublic:\n    SystemManager() : systems_sorted_(false) {}\n    \n    template<typename T, typename... Args>\n    T* registerSystem(int priority, Args&&... args) {\n        // Create system instance with perfect forwarding\n        auto system = std::make_unique<T>(std::forward<Args>(args)...);\n        T* system_ptr = system.get();\n        \n        // Check for priority conflicts (optional but recommended)\n        for (const auto& existing : systems_) {\n            if (existing->getPriority() == priority) {\n                std::cout << \"Warning: Priority conflict between \" \n                         << existing->getName() << \" and \" << system->getName() << std::endl;\n            }\n        }\n        \n        systems_.push_back(std::move(system));\n        systems_sorted_ = false; // Mark for re-sorting\n        return system_ptr;\n    }\n    \n    void updateAllSystems(World& world, float deltaTime) {\n        // Sort systems by priority if needed\n        if (!systems_sorted_) {\n            std::sort(systems_.begin(), systems_.end(),\n                [](const std::unique_ptr<System>& a, const std::unique_ptr<System>& b) {\n                    return a->getPriority() < b->getPriority();\n                });\n            systems_sorted_ = true;\n        }\n        \n        // Execute all enabled systems in priority order\n        for (auto& system : systems_) {\n            if (system->isEnabled()) {\n                try {\n                    system->update(world, deltaTime);\n                } catch (const std::exception& e) {\n                    std::cerr << \"System \" << system->getName() \n                             << \" threw exception: \" << e.what() << std::endl;\n                    // Continue with other systems to maintain frame consistency\n                }\n            }\n        }\n    }\n    \n    template<typename T>\n    T* getSystem() {\n        for (auto& system : systems_) {\n            if (T* typed_system = dynamic_cast<T*>(system.get())) {\n                return typed_system;\n            }\n        }\n        return nullptr;\n    }\n    \n    size_t getSystemCount() const { return systems_.size(); }\n};\n```\n\n#### Example System Implementations (Complete)\n\n```cpp\n// MovementSystem.h - Example system showing component queries and modification\n#pragma once\n#include \"System.h\"\n#include \"Components.h\" // Position, Velocity components\n\nclass MovementSystem : public System {\npublic:\n    MovementSystem() : System(\"Movement\", PRIORITY_PHYSICS) {}\n    \n    void update(World& world, float deltaTime) override {\n        // Query all entities with both Position and Velocity components\n        for (auto [entity, pos, vel] : world.query<Position, Velocity>()) {\n            // Integrate velocity into position using frame delta time\n            pos.x += vel.dx * deltaTime;\n            pos.y += vel.dy * deltaTime;\n            \n            // Apply simple friction to velocity\n            vel.dx *= 0.99f;\n            vel.dy *= 0.99f;\n        }\n    }\n};\n\n// InputSystem.h - Example system showing entity creation and component addition\n#pragma once\n#include \"System.h\"\n#include \"Components.h\"\n\nclass InputSystem : public System {\nprivate:\n    std::vector<Entity> entities_to_modify_;\n    \npublic:\n    InputSystem() : System(\"Input\", PRIORITY_INPUT) {}\n    \n    void update(World& world, float deltaTime) override {\n        entities_to_modify_.clear();\n        \n        // Check for input that should create new entities\n        if (isKeyPressed(KEY_SPACE)) {\n            Entity bullet = world.createEntity();\n            world.addComponent<Position>(bullet, {100.0f, 100.0f});\n            world.addComponent<Velocity>(bullet, {200.0f, 0.0f});\n        }\n        \n        // Collect entities needing velocity changes (deferred modification pattern)\n        for (auto [entity, pos] : world.query<Position>()) {\n            if (isKeyPressed(KEY_UP)) {\n                entities_to_modify_.push_back(entity);\n            }\n        }\n        \n        // Apply velocity changes after iteration completes\n        for (Entity entity : entities_to_modify_) {\n            if (world.hasComponent<Velocity>(entity)) {\n                auto& vel = world.getComponent<Velocity>(entity);\n                vel.dy -= 100.0f; // Move upward\n            } else {\n                world.addComponent<Velocity>(entity, {0.0f, -100.0f});\n            }\n        }\n    }\n};\n```\n\n#### Milestone Checkpoint\n\nAfter implementing the system interface, verify the following behavior:\n\n**Expected Functionality:**\n1. **System Registration**: Register multiple systems with different priorities and verify they execute in priority order\n2. **Component Queries**: Systems can query for entities with specific component combinations and iterate over results\n3. **Type Safety**: Component access through queries provides compile-time type checking without runtime overhead\n4. **Execution Order**: Lower priority numbers execute before higher priority numbers consistently\n5. **Error Handling**: Exceptions in one system don't prevent other systems from executing\n\n**Testing Commands:**\n```bash\n# Compile and run basic system test\ng++ -std=c++17 -I include src/test_systems.cpp -o test_systems\n./test_systems\n\n# Expected output:\n# Frame 1:\n#   InputSystem (priority 100) executed\n#   MovementSystem (priority 300) executed\n#   RenderSystem (priority 500) executed\n# Frame 2:\n#   InputSystem (priority 100) executed\n#   MovementSystem (priority 300) executed\n#   RenderSystem (priority 500) executed\n```\n\n**Manual Verification:**\n1. Create entities with Position and Velocity components\n2. Register MovementSystem and observe positions updating each frame\n3. Add systems with incorrect priority ordering and verify execution sequence\n4. Intentionally cause an exception in one system and verify others continue executing\n\n**Common Issues and Diagnosis:**\n- **Systems execute in wrong order**: Check priority values - lower numbers should execute first\n- **Query returns no entities**: Verify entities actually have ALL required component types using `hasComponent<T>()`\n- **Crashes during iteration**: Check for component addition/removal during iteration - use deferred modification pattern\n- **Components not updating**: Ensure query returns references (`auto [entity, pos, vel]`) not copies (`auto [entity, pos, vel]` without reference types)\n\n\n## Archetype-Based Storage (Advanced)\n\n> **Milestone(s):** Milestone 4 (Archetypes) — implementing archetype-based storage for maximum cache efficiency through entity grouping by component combination\n\nThe archetype-based storage system represents the pinnacle of ECS performance optimization. While the sparse set approach from Milestone 2 provides excellent constant-time entity-to-component mapping, it still scatters components of the same type across different memory locations when entities have different component combinations. Archetype-based storage solves this by grouping entities with identical component combinations together, enabling unprecedented cache locality and SIMD processing opportunities.\n\n### Mental Model: Filing Cabinet Organization\n\nThink of archetypes as a sophisticated filing cabinet system in a large corporate office. Instead of having one drawer per document type (like our sparse set approach), we organize documents by **client profiles**. Each client profile represents a specific combination of document types that commonly appear together.\n\nIn our filing cabinet analogy:\n- **Archetypes** are filing cabinet drawers labeled with specific document combinations: \"Tax Returns + Financial Statements + Legal Contracts\" or \"Employment Records + Performance Reviews\"\n- **Entities** are individual client folders within each drawer\n- **Components** are the actual documents stored in each client folder\n- **Chunks** are the individual filing cabinet sections within each drawer, each holding a fixed number of client folders\n\nWhen we need to process all tax returns, we don't search through every drawer in the office. Instead, we go directly to drawers labeled with \"Tax Returns\" and process entire sections at once. This is exactly how archetype-based storage achieves superior cache performance — all entities with similar data layouts are stored together, and we can process them in large batches.\n\nThe key insight is that most game entities fall into common patterns: \"Renderable Objects\" (Position + Sprite + Transform), \"Moving Entities\" (Position + Velocity + Physics), or \"Interactive Items\" (Position + Collider + Inventory). By grouping these patterns together, we can process hundreds of similar entities without a single cache miss.\n\n### Archetype Identification and Transitions\n\nArchetype identification relies on **component masks** — bitsets that uniquely identify which component types an entity possesses. Each bit position corresponds to a specific `ComponentTypeID`, creating a compact representation of an entity's component combination.\n\n> **Decision: Component Mask-Based Archetype Identification**\n> - **Context**: Need efficient method to group entities with identical component combinations while supporting fast lookups and transitions\n> - **Options Considered**: String-based component signatures, sorted component type arrays, bitset-based component masks\n> - **Decision**: Use `ComponentMask` bitset of `MAX_COMPONENTS` size for archetype identification\n> - **Rationale**: Bitset operations are extremely fast (single CPU instruction for comparisons), compact memory usage (typically 64-256 bits), and enable efficient set operations for archetype transitions\n> - **Consequences**: Limits maximum component types but enables sub-nanosecond archetype lookups and transitions\n\nThe archetype identification process follows a systematic approach:\n\n1. **Component Mask Generation**: When components are added or removed from an entity, we update its component mask by setting or clearing the corresponding bit for each `ComponentTypeID`\n2. **Archetype Lookup**: The ECS maintains a hash map from `ComponentMask` to `ArchetypeInfo`, enabling constant-time archetype discovery for any component combination\n3. **Archetype Creation**: If no archetype exists for a given component mask, we dynamically create a new archetype with appropriate storage layout and chunk structure\n4. **Entity Assignment**: Entities are assigned to their matching archetype based on their current component mask, ensuring all entities in an archetype have identical component combinations\n\n| Archetype Operation | Input | Output | Time Complexity | Description |\n|-------------------|-------|--------|-----------------|-------------|\n| `identifyArchetype` | `ComponentMask` | `ArchetypeInfo*` | O(1) | Finds existing archetype or creates new one |\n| `calculateMask<Components...>` | Template parameter pack | `ComponentMask` | O(k) | Generates mask for given component types |\n| `transitionEntity` | `Entity`, `ArchetypeInfo*` | `void` | O(k) | Moves entity between archetypes |\n| `findMatchingArchetypes` | `ComponentMask` | `vector<ArchetypeInfo*>` | O(n) | Finds all archetypes containing required components |\n\n**Archetype transitions** occur whenever an entity's component combination changes through `addComponent` or `removeComponent` operations. This process is more complex than simple sparse set modifications because the entity must physically move between different archetype storage areas.\n\nThe archetype transition algorithm proceeds as follows:\n\n1. **Current Archetype Identification**: Determine the entity's current archetype from its existing component mask\n2. **New Component Mask Calculation**: Update the component mask based on the added or removed component type\n3. **Target Archetype Resolution**: Find or create the archetype corresponding to the new component mask\n4. **Component Data Migration**: Copy all existing component data from the current archetype chunk to the target archetype chunk\n5. **New Component Initialization**: For `addComponent` operations, initialize the new component data in the target archetype\n6. **Index Updates**: Update all internal mapping structures to reflect the entity's new archetype location\n7. **Source Cleanup**: Remove the entity from its previous archetype chunk using swap-remove semantics\n\n> The critical challenge in archetype transitions is maintaining data consistency during the migration process. Since component data moves between different memory locations, any existing pointers or references become invalid. Systems must be designed to avoid holding component references across frame boundaries.\n\n**Component masks enable sophisticated archetype matching** for system queries. When a system requests entities with components `Position`, `Velocity`, and `Health`, we generate a query mask and use bitwise AND operations to find all archetypes that contain at least those components:\n\n```\nQuery Mask:    00000111 (Position | Velocity | Health)\nArchetype A:   00001111 (Position | Velocity | Health | Sprite)    → Match!\nArchetype B:   00000110 (Velocity | Health)                        → No match\nArchetype C:   00010111 (Position | Velocity | Health | Physics)   → Match!\n```\n\nThis bitwise matching approach enables systems to process multiple archetype chunks in sequence, maintaining excellent cache locality within each chunk while covering all entities that satisfy the query requirements.\n\n### Chunk-Based Memory Layout\n\nWithin each archetype, entities and their components are organized into **chunks** — fixed-size memory blocks that store multiple entities with structure-of-arrays layout. This chunked approach provides several critical advantages over monolithic archetype storage.\n\n> **Decision: Chunk-Based Storage Within Archetypes**\n> - **Context**: Need to balance cache efficiency with memory allocation flexibility and iteration performance\n> - **Options Considered**: Monolithic archetype arrays, fixed-size chunks, dynamic chunk sizing\n> - **Decision**: Use fixed-size `ArchetypeChunk` blocks with configurable capacity (typically 16KB per chunk)\n> - **Rationale**: Fixed chunks enable predictable memory usage, reduce allocation overhead, improve cache utilization, and support efficient parallel processing\n> - **Consequences**: Slightly more complex memory management but dramatically better performance characteristics and scalability\n\nEach `ArchetypeChunk` contains multiple parallel arrays — one for each component type in the archetype. The chunk layout follows strict structure-of-arrays principles to maximize cache efficiency during iteration:\n\n| Chunk Section | Content | Memory Layout | Purpose |\n|---------------|---------|---------------|---------|\n| Entity Array | `Entity` structs | Contiguous entity IDs with generations | Fast entity iteration and validation |\n| Component Arrays | Type-specific component data | Separate contiguous array per component type | Cache-friendly component processing |\n| Metadata | Chunk header information | Entity count, capacity, archetype pointer | Chunk management and validation |\n| Padding | Memory alignment space | Unused bytes for cache line alignment | Optimal CPU cache utilization |\n\nThe chunk memory layout calculation requires careful attention to data alignment and cache line boundaries:\n\n1. **Entity Array Placement**: Entities are stored first, aligned to the beginning of the chunk for fastest access during iteration\n2. **Component Array Alignment**: Each component array begins at a memory address aligned to the component's natural alignment requirements (typically 4 or 8 bytes)\n3. **Cache Line Considerations**: Component arrays are positioned to minimize cache line splits — avoiding situations where a single component spans multiple cache lines\n4. **Chunk Size Optimization**: Total chunk size is chosen to fit within L1 or L2 cache for optimal processing performance\n\nThe **entity stride calculation** determines how many entities can fit within a single chunk based on the archetype's component combination:\n\n```\nEntity Stride = sizeof(Entity) + sum(sizeof(ComponentType)) for all components in archetype\nEntities Per Chunk = (CHUNK_SIZE - CHUNK_HEADER_SIZE) / Entity Stride\n```\n\nFor example, an archetype containing `Position` (8 bytes), `Velocity` (8 bytes), and `Health` (8 bytes) components would have:\n- Entity Stride: 8 (Entity) + 8 (Position) + 8 (Velocity) + 8 (Health) = 32 bytes\n- Entities Per Chunk: (16384 - 64) / 32 = 509 entities per chunk\n\n> **Cache Efficiency Insight**: Processing 509 entities with identical memory layout in sequence typically results in near-zero cache misses after the initial cache line loads. This represents a 50-100x performance improvement over scattered component access patterns.\n\n**Chunk iteration patterns** are designed to maximize CPU cache utilization and enable SIMD processing:\n\n| Iteration Pattern | Use Case | Cache Behavior | SIMD Compatibility |\n|------------------|----------|----------------|-------------------|\n| Single Component | Position updates | Excellent — single array traversal | Perfect — contiguous same-type data |\n| Multiple Components | Physics calculations | Good — parallel array traversal | Good — requires gather/scatter operations |\n| Entity-Centric | Complex logic requiring multiple components | Fair — multiple cache line loads per entity | Poor — requires component interleaving |\n\nThe most efficient iteration pattern processes one component type at a time across all entities in the chunk, then moves to the next component type. This approach keeps the CPU cache full of relevant data and enables vectorized operations on modern processors.\n\n**Chunk allocation and deallocation** follows a pooled memory management strategy to avoid frequent system memory allocations:\n\n1. **Chunk Pool Maintenance**: Pre-allocate chunks from the system and maintain them in a free list for rapid allocation\n2. **Chunk Recycling**: When archetypes shrink, return empty chunks to the pool rather than deallocating them immediately\n3. **Memory Pressure Handling**: Monitor chunk pool size and deallocate excess chunks during low-usage periods\n4. **Fragmentation Prevention**: Periodically compact partially-filled chunks to maintain optimal memory density\n\n### Archetype Implementation Pitfalls\n\nImplementing archetype-based storage introduces several subtle but critical pitfalls that can severely impact performance or correctness. Understanding these common mistakes helps avoid costly debugging sessions and performance regressions.\n\n⚠️ **Pitfall: Archetype Explosion**\n\nArchetype explosion occurs when the system creates too many unique archetype combinations, fragmenting entities across numerous small archetypes instead of grouping them efficiently. This happens when games use many optional or temporary components, creating a combinatorial explosion of possible component masks.\n\n**Why it's problematic**: Each archetype has memory overhead for chunk management and bookkeeping. With thousands of archetypes containing only a few entities each, memory usage explodes and cache efficiency disappears. Query iteration becomes expensive as systems must visit many small archetypes instead of processing large chunks efficiently.\n\n**Warning signs**: More than 1000 unique archetypes in a typical game, average entities per archetype below 10, memory usage growing faster than entity count, query performance degrading despite constant entity counts.\n\n**Solutions**: Design component hierarchies to minimize optional components, use tag components sparingly, implement archetype consolidation strategies, consider component pooling for temporary effects, monitor archetype statistics during development.\n\n⚠️ **Pitfall: Excessive Transition Overhead**\n\nFrequent archetype transitions can overwhelm the performance benefits of cache-friendly storage. This occurs when systems repeatedly add and remove components, causing entities to bounce between archetypes every frame.\n\n**Why it's problematic**: Each archetype transition requires copying all component data from one chunk to another, updating internal mappings, and potentially allocating new chunks. The cost of these operations can exceed the cache efficiency gains, especially for entities with many components.\n\n**Measurement approach**: Profile the ratio of archetype transitions to system updates — ratios above 0.1 (one transition per ten system updates) often indicate problems. Monitor component addition/removal patterns to identify problematic systems.\n\n**Solutions**: Batch component modifications to occur less frequently, use state machines instead of adding/removing components for temporary states, implement component flags for boolean state instead of optional components, defer non-critical component changes to reduce transition frequency.\n\n⚠️ **Pitfall: Chunk Underutilization**\n\nPoor chunk utilization occurs when chunks remain mostly empty due to suboptimal entity distribution or frequent entity destruction without compaction. This wastes memory and reduces cache efficiency.\n\n**Symptoms**: Low average entity count per chunk (below 50% capacity), memory usage growing without corresponding entity count increases, iteration performance lower than expected despite archetype organization.\n\n**Root causes**: Entity destruction patterns that fragment chunks, archetype design that results in very large entity strides, chunk size configuration mismatched to typical entity counts.\n\n**Prevention strategies**: Implement chunk compaction during low-usage periods, monitor chunk utilization metrics, configure chunk sizes based on profiling typical entity distributions, design archetypes to balance component combinations with utilization rates.\n\n⚠️ **Pitfall: Iterator Invalidation During Transitions**\n\nComponent references and iterators become invalid when entities transition between archetypes, but this invalidation is not immediately obvious since the entity ID remains valid.\n\n**Why it's dangerous**: Systems holding component pointers or references across archetype transitions will access stale memory, potentially reading garbage data or causing segmentation faults. This is particularly problematic in multi-threaded systems where transitions occur concurrently with component access.\n\n**Detection techniques**: Use debug builds with component reference tracking, implement component access validation, add assertions to detect stale pointer usage, profile for unexpected memory access patterns.\n\n**Safe patterns**: Never hold component references across system boundaries, refresh component access on each frame, use entity IDs and component lookups instead of cached pointers, implement deferred modification patterns for component changes during iteration.\n\n| Pitfall Category | Performance Impact | Debugging Difficulty | Prevention Effort |\n|------------------|-------------------|---------------------|-------------------|\n| Archetype Explosion | Severe — memory and query performance | Medium — visible in profiling | High — requires careful component design |\n| Transition Overhead | High — can negate cache benefits | Easy — shows up in frame profilers | Medium — requires batching strategies |\n| Chunk Underutilization | Medium — memory waste and cache misses | Easy — memory profiling reveals waste | Low — mostly configuration tuning |\n| Iterator Invalidation | Critical — memory safety issues | Hard — intermittent crashes | Medium — requires disciplined coding patterns |\n\n> The key principle for avoiding archetype pitfalls is to measure and monitor archetype statistics continuously during development. Problems with archetype-based storage typically manifest as gradual performance degradation rather than immediate failures, making early detection crucial for maintaining system performance.\n\n**Common debugging techniques** for archetype-related issues include:\n\n1. **Archetype Statistics Logging**: Track archetype count, average entities per archetype, transition frequency, and chunk utilization rates\n2. **Component Access Validation**: Implement debug-mode checks that verify component pointers remain valid between access attempts\n3. **Memory Layout Visualization**: Tools that display archetype memory layouts and entity distribution patterns\n4. **Performance Regression Testing**: Automated tests that detect performance degradation as archetype usage patterns change\n5. **Cache Miss Profiling**: Hardware performance counters to measure actual cache efficiency gains from archetype organization\n\n### Implementation Guidance\n\nArchetype-based storage represents the most complex milestone in our ECS implementation, requiring sophisticated memory management and careful performance optimization. The following guidance provides a practical roadmap for implementing this advanced optimization.\n\n**Technology Recommendations:**\n\n| Component | Simple Approach | Advanced Approach |\n|-----------|----------------|-------------------|\n| Memory Management | `std::vector` per component array | Custom chunk allocator with memory pools |\n| Component Masks | `std::bitset<64>` for component identification | Hand-optimized bit manipulation with SIMD |\n| Archetype Storage | Hash map from mask to archetype | Hierarchical archetype graph with fast queries |\n| Chunk Iteration | Range-based for loops | Template-based iterator with SIMD hints |\n\n**Recommended File Structure:**\n\n```\nsrc/\n  ecs/\n    archetype/\n      archetype_info.h         ← ArchetypeInfo and ComponentMask definitions\n      archetype_chunk.h        ← Chunk storage and iteration\n      archetype_storage.h      ← Main archetype storage manager\n      archetype_storage.cpp    ← Implementation\n      chunk_allocator.h        ← Memory pool for chunk allocation\n      chunk_allocator.cpp      ← Pool implementation\n    world.h                    ← Updated World class with archetype support\n    world.cpp                  ← Integration with existing ECS components\n  tests/\n    archetype_tests.cpp        ← Comprehensive archetype testing\n    performance_tests.cpp      ← Cache efficiency benchmarks\n```\n\n**Core Data Structure Definitions:**\n\n```cpp\n// archetype_info.h - Complete archetype metadata structure\n#include <vector>\n#include <bitset>\n#include <memory>\n\nconstexpr size_t MAX_COMPONENTS = 64;\nconstexpr size_t CHUNK_SIZE = 16384;  // 16KB chunks for L1 cache efficiency\n\nusing ComponentMask = std::bitset<MAX_COMPONENTS>;\n\nstruct ArchetypeInfo {\n    uint32_t archetypeID;\n    ComponentMask componentMask;\n    std::vector<ComponentTypeID> componentTypes;\n    std::vector<size_t> componentOffsets;  // Offset of each component within chunk\n    size_t entityStride;                   // Total size per entity including all components\n    size_t entitiesPerChunk;               // Maximum entities that fit in one chunk\n    std::vector<std::unique_ptr<ArchetypeChunk>> chunks;\n    \n    // Fast component lookup\n    size_t getComponentOffset(ComponentTypeID typeID) const;\n    bool hasComponent(ComponentTypeID typeID) const;\n};\n\nstruct ArchetypeChunk {\n    std::unique_ptr<uint8_t[]> data;  // Raw memory for all component arrays\n    std::vector<Entity> entities;     // Entity IDs in this chunk\n    uint32_t entityCount;             // Current number of entities\n    uint32_t capacity;                // Maximum entities this chunk can hold\n    ArchetypeInfo* archetype;         // Pointer to parent archetype\n    \n    // Component array access\n    template<typename T>\n    T* getComponentArray();\n    \n    // Entity management within chunk\n    void addEntity(Entity entity);\n    void removeEntity(size_t index);  // Uses swap-remove\n    void compactChunk();              // Remove gaps from entity removal\n};\n```\n\n**Archetype Storage Manager Implementation Skeleton:**\n\n```cpp\n// archetype_storage.cpp - Core archetype management logic\nclass ArchetypeStorage {\nprivate:\n    std::unordered_map<ComponentMask, std::unique_ptr<ArchetypeInfo>> archetypes_;\n    ChunkAllocator chunkAllocator_;\n    uint32_t nextArchetypeID_ = 1;\n\npublic:\n    // Main archetype operations that learners need to implement\n    \n    template<typename... Components>\n    ArchetypeInfo* getOrCreateArchetype() {\n        // TODO 1: Generate ComponentMask for the given component types\n        // TODO 2: Check if archetype already exists in archetypes_ map\n        // TODO 3: If not found, create new ArchetypeInfo with calculateLayout()\n        // TODO 4: Initialize chunk allocator for this archetype\n        // TODO 5: Add archetype to map and return pointer\n        // Hint: Use ComponentTypeRegistry to get ComponentTypeID for each type\n    }\n    \n    void transitionEntity(Entity entity, ArchetypeInfo* targetArchetype) {\n        // TODO 1: Find entity's current archetype and chunk location\n        // TODO 2: Allocate space in target archetype (may require new chunk)\n        // TODO 3: Copy all existing component data to target location\n        // TODO 4: Update internal entity-to-location mappings\n        // TODO 5: Remove entity from source chunk using swap-remove\n        // TODO 6: Clean up empty chunks if necessary\n        // Hint: Component data copying requires knowledge of component sizes\n    }\n    \n    template<typename... Components>\n    std::vector<ArchetypeInfo*> findMatchingArchetypes() {\n        // TODO 1: Generate query mask from template parameter pack\n        // TODO 2: Iterate through all existing archetypes\n        // TODO 3: Use bitwise AND to test if archetype contains all required components\n        // TODO 4: Collect matching archetypes into result vector\n        // TODO 5: Sort by entity count for optimal iteration order\n        // Performance hint: Cache query results for frequently used component combinations\n    }\n\nprivate:\n    void calculateArchetypeLayout(ArchetypeInfo* archetype) {\n        // TODO 1: Sort component types by alignment requirements (largest first)\n        // TODO 2: Calculate offset for each component array within chunk\n        // TODO 3: Account for padding between arrays for proper alignment\n        // TODO 4: Calculate total entity stride and entities per chunk\n        // TODO 5: Validate that chunk can hold at least one entity\n        // Memory layout hint: Align each component array to its natural alignment\n    }\n    \n    ArchetypeChunk* allocateNewChunk(ArchetypeInfo* archetype) {\n        // TODO 1: Get raw memory from chunk allocator\n        // TODO 2: Create ArchetypeChunk with proper capacity\n        // TODO 3: Initialize component arrays within the chunk memory\n        // TODO 4: Add chunk to archetype's chunk list\n        // TODO 5: Return pointer to new chunk for immediate use\n        // Memory safety: Ensure proper cleanup if allocation fails\n    }\n};\n```\n\n**Chunk Memory Management Infrastructure:**\n\n```cpp\n// chunk_allocator.h - Memory pool for efficient chunk allocation\nclass ChunkAllocator {\nprivate:\n    std::vector<std::unique_ptr<uint8_t[]>> freeChunks_;\n    size_t chunkSize_;\n    size_t totalAllocated_ = 0;\n    size_t maxPoolSize_ = 1024;  // Prevent unbounded memory growth\n\npublic:\n    explicit ChunkAllocator(size_t chunkSize = CHUNK_SIZE) : chunkSize_(chunkSize) {}\n    \n    std::unique_ptr<uint8_t[]> allocateChunk() {\n        if (!freeChunks_.empty()) {\n            auto chunk = std::move(freeChunks_.back());\n            freeChunks_.pop_back();\n            return chunk;\n        }\n        \n        ++totalAllocated_;\n        return std::make_unique<uint8_t[]>(chunkSize_);\n    }\n    \n    void deallocateChunk(std::unique_ptr<uint8_t[]> chunk) {\n        if (freeChunks_.size() < maxPoolSize_) {\n            freeChunks_.push_back(std::move(chunk));\n        }\n        // Otherwise let unique_ptr automatically deallocate\n    }\n    \n    // Statistics for debugging and monitoring\n    size_t getTotalAllocated() const { return totalAllocated_; }\n    size_t getPooledChunks() const { return freeChunks_.size(); }\n};\n```\n\n**Integration with Existing ECS World:**\n\n```cpp\n// Updated World class to support archetype-based storage\nclass World {\nprivate:\n    EntityManager entityManager_;\n    ArchetypeStorage archetypeStorage_;\n    SystemManager systemManager_;\n    \n    // Entity-to-archetype mapping for fast lookups\n    std::unordered_map<EntityID, std::pair<ArchetypeInfo*, size_t>> entityLocations_;\n\npublic:\n    template<typename T>\n    T& addComponent(Entity entity, T&& component) {\n        // TODO 1: Check if entity currently has any components (determines source archetype)\n        // TODO 2: Calculate new component mask including the added component\n        // TODO 3: Get or create target archetype for new component combination\n        // TODO 4: Transition entity to target archetype (may involve data copying)\n        // TODO 5: Initialize new component data in target archetype chunk\n        // TODO 6: Update entityLocations_ mapping with new location\n        // TODO 7: Return reference to newly added component\n        // Integration note: This replaces the old ComponentStorage approach\n    }\n    \n    template<typename T>\n    void removeComponent(Entity entity) {\n        // TODO 1: Validate entity exists and has the specified component\n        // TODO 2: Calculate new component mask excluding the removed component\n        // TODO 3: Get or create target archetype for remaining components\n        // TODO 4: Copy all remaining component data to target archetype\n        // TODO 5: Transition entity to target archetype\n        // TODO 6: Update entityLocations_ mapping\n        // TODO 7: Clean up empty archetype chunks if necessary\n        // Cleanup note: Call component destructor before removing data\n    }\n    \n    template<typename... Components>\n    auto query() {\n        // TODO 1: Find all archetypes matching the component requirements\n        // TODO 2: Create iterator that spans across multiple archetypes\n        // TODO 3: Provide tuple-based access to component data\n        // TODO 4: Handle empty archetypes gracefully\n        // TODO 5: Optimize iteration order for cache efficiency\n        // Performance note: Process largest archetypes first for better branch prediction\n        return ArchetypeQueryIterator<Components...>(*this, archetypeStorage_.findMatchingArchetypes<Components...>());\n    }\n};\n```\n\n**Advanced Query Iterator Implementation:**\n\n```cpp\n// High-performance iterator spanning multiple archetypes\ntemplate<typename... Components>\nclass ArchetypeQueryIterator {\nprivate:\n    std::vector<ArchetypeInfo*> matchingArchetypes_;\n    size_t currentArchetypeIndex_ = 0;\n    size_t currentChunkIndex_ = 0;\n    size_t currentEntityIndex_ = 0;\n    World* world_;\n\npublic:\n    ArchetypeQueryIterator(World& world, std::vector<ArchetypeInfo*> archetypes)\n        : world_(&world), matchingArchetypes_(std::move(archetypes)) {\n        // Start at first valid entity\n        skipToValidEntity();\n    }\n    \n    std::tuple<Components&...> operator*() {\n        // TODO 1: Get current archetype chunk and entity index\n        // TODO 2: Calculate component array pointers within chunk\n        // TODO 3: Return tuple of references to component data\n        // TODO 4: Ensure type safety with template parameter validation\n        // Performance hint: Use pointer arithmetic for fast component access\n    }\n    \n    ArchetypeQueryIterator& operator++() {\n        // TODO 1: Advance to next entity within current chunk\n        // TODO 2: If chunk exhausted, move to next chunk in archetype\n        // TODO 3: If archetype exhausted, move to next archetype\n        // TODO 4: Skip empty chunks and archetypes automatically\n        // TODO 5: Update internal position tracking\n        // Iteration hint: Batch validation checks to avoid per-entity overhead\n    }\n    \n    Entity entity() const {\n        // TODO: Return current entity ID from current archetype chunk\n        // Validation: Ensure iterator is in valid state before returning\n    }\n    \n    bool operator!=(const ArchetypeQueryIterator& other) const {\n        // TODO: Compare iterator positions for range-based for loop support\n        // Note: Typically only compared against end() iterator\n    }\n\nprivate:\n    void skipToValidEntity() {\n        // TODO 1: Skip empty chunks and archetypes\n        // TODO 2: Find next archetype with entities if current is exhausted\n        // TODO 3: Update position indices to point to valid entity\n        // TODO 4: Handle case where no entities match the query\n    }\n};\n```\n\n**Language-Specific Performance Hints:**\n\n- **Memory Alignment**: Use `alignas()` specifiers to ensure component arrays align to cache line boundaries (64 bytes on most processors)\n- **SIMD Processing**: Design component layouts to enable `std::execution::vectorized_policy` with standard algorithms\n- **Branch Prediction**: Process largest archetypes first to improve CPU branch predictor performance\n- **Template Optimization**: Use `if constexpr` to eliminate runtime branches in template code\n- **Memory Prefetching**: Add `__builtin_prefetch()` hints for predictable access patterns (GCC/Clang)\n\n**Milestone Checkpoint:**\n\nAfter implementing archetype-based storage, verify the following behavior:\n\n1. **Archetype Creation**: Run `world.addComponent<Position>(entity1); world.addComponent<Velocity>(entity1);` — should create archetype with ComponentMask containing Position and Velocity bits\n2. **Cache Efficiency Test**: Create 1000 entities with Position+Velocity, iterate through `query<Position, Velocity>()` — should complete in under 1ms with proper archetype organization\n3. **Transition Verification**: Add Health component to existing Position+Velocity entity — should move entity to Position+Velocity+Health archetype and maintain all component data\n4. **Memory Usage**: Monitor memory consumption — should remain stable even with frequent entity creation/destruction due to chunk pooling\n5. **Query Performance**: Benchmark queries across multiple archetypes — iteration speed should scale linearly with entity count, not archetype count\n\n**Debugging Tips:**\n\n| Symptom | Likely Cause | Diagnosis | Fix |\n|---------|-------------|-----------|-----|\n| Memory usage exploding | Archetype explosion | Count unique archetypes, check for optional components | Redesign components to reduce combinations |\n| Slow query performance | Too many small archetypes | Profile entities per archetype | Consolidate similar component patterns |\n| Crashes during component access | Stale pointers after transitions | Add component reference validation | Use entity IDs instead of component pointers |\n| Memory leaks | Chunks not being freed | Track chunk allocation/deallocation | Implement proper chunk pooling |\n| Cache misses despite archetypes | Poor chunk utilization | Profile chunk fill rates | Tune chunk size and compaction frequency |\n\n![Archetype Storage Layout](./diagrams/archetype-organization.svg)\n\n![Archetype Transition Process](./diagrams/archetype-transitions.svg)\n\n\n## Interactions and Data Flow\n\n> **Milestone(s):** Milestones 1-4 — understanding how entities, components, and systems interact during typical game operations including entity creation, component attachment, and system updates\n\nThe true power of an ECS architecture emerges not from its individual components, but from how they work together during actual game execution. Understanding these interactions is crucial for implementing a cohesive system that maintains both performance and correctness throughout the entity lifecycle.\n\nThink of the ECS interactions like a bustling city ecosystem. Entities are citizens with unique ID cards, components are the various services and attributes each citizen possesses (home address, job, health status), and systems are the city departments that process citizens with specific combinations of services. Just as a citizen might visit the DMV (which only processes people with driver's licenses), then go to the hospital (which processes people with health records), our systems process entities based on their component combinations. The city's efficiency depends on smooth coordination between departments, proper citizen identification, and organized service delivery.\n\nThis section explores three critical aspects of ECS interactions: how entities move through their lifecycle from creation to destruction, how systems execute each frame to process relevant entities, and how component queries efficiently locate entities matching specific criteria.\n\n### Entity Lifecycle Flow\n\nThe entity lifecycle represents the complete journey of a game object from conception to cleanup, involving coordinated actions across the Entity Manager, Component Storage, and System Interface. Understanding this flow is essential because improper lifecycle management leads to memory leaks, stale references, and system inconsistencies.\n\n#### Entity Creation Sequence\n\nEntity creation involves generating a unique identifier, initializing tracking structures, and preparing the entity for component attachment. The process must guarantee ID uniqueness while enabling efficient lookup and iteration.\n\nThe creation sequence follows these steps:\n\n1. **ID Generation**: The Entity Manager checks its free list for recycled IDs. If available, it pops an ID and increments its generation counter. Otherwise, it allocates a new ID from the next available index.\n\n2. **Alive Status Registration**: The new entity is marked as alive in the Entity Manager's tracking structures, typically a bitset or sparse array that enables constant-time status queries.\n\n3. **Generation Validation Setup**: The entity's generation counter is recorded in the Entity Manager's generation array at the entity's index position, enabling future validation of entity references.\n\n4. **Iterator Registration**: If the ECS supports entity iteration, the new entity is added to the alive entities collection, maintaining the ability to iterate over all living entities.\n\n5. **Callback Notification**: Any registered creation callbacks are invoked, allowing systems to respond to new entity creation for initialization or logging purposes.\n\n| Step | Component Responsible | Data Structure Modified | Purpose |\n|------|----------------------|------------------------|---------|\n| ID Generation | EntityManager | free_list_, next_id_ | Obtain unique identifier |\n| Alive Status | EntityManager | alive_entities_ bitset | Enable status queries |\n| Generation Recording | EntityManager | generations_ array | Prevent stale references |\n| Iterator Support | EntityManager | entity_list_ vector | Support entity iteration |\n| Callback Execution | EntityManager | creation_callbacks_ | Notify interested systems |\n\n> **Design Insight**: Entity creation is intentionally lightweight, involving no component allocation. This separation of concerns allows entities to exist as pure identifiers before acquiring behavior through components.\n\n#### Component Attachment Process\n\nComponent attachment transforms an empty entity into a functional game object by associating data with the entity ID. This process must maintain type safety while updating any archetype-based storage systems.\n\nThe attachment process involves:\n\n1. **Type Registration Verification**: The component type must be registered with the ComponentTypeRegistry, ensuring metadata like size and destructor information is available.\n\n2. **Storage Location**: The appropriate ComponentStorage instance is located based on the component's type ID, creating the storage if this is the first component of this type.\n\n3. **Component Construction**: The component is constructed in-place within the storage system, typically using move semantics for efficiency.\n\n4. **Entity Mapping Update**: The sparse set mapping from entity ID to component index is updated, enabling constant-time component access.\n\n5. **Archetype Transition**: If using archetype-based storage, the entity transitions to a new archetype that includes this component type, potentially moving existing components.\n\n6. **Query Invalidation**: Any active query iterators are marked as potentially invalid, since the entity's component combination has changed.\n\n| Operation | Before State | After State | Data Structure Impact |\n|-----------|-------------|-------------|----------------------|\n| Type Check | Component unregistered | Type metadata available | ComponentTypeRegistry |\n| Storage Access | No T storage exists | ComponentStorage<T> ready | storage_map_ |\n| Construction | Component data in parameters | Component in dense array | SparseSet<T> |\n| Mapping | Entity has no T component | Entity → component index | sparse_ and dense_ arrays |\n| Archetype | Entity in archetype A | Entity in archetype B | ArchetypeStorage transitions |\n\n> **Critical Consideration**: Component attachment can be expensive in archetype-based systems due to the need to move all existing components to a new archetype. This cost is amortized over the performance benefits of cache-friendly iteration.\n\n#### Component Removal and Cleanup\n\nComponent removal requires careful coordination to maintain data structure integrity while avoiding iterator invalidation and memory leaks. The process must handle both explicit removal and destruction-time cleanup.\n\nThe removal sequence proceeds as follows:\n\n1. **Existence Verification**: The system verifies the entity actually has the component to avoid spurious removal attempts that could corrupt data structures.\n\n2. **Component Destruction**: The component's destructor is called to clean up any resources it holds, such as dynamically allocated memory or external handles.\n\n3. **Swap-Remove Operation**: The component is removed from the dense array using swap-remove semantics, moving the last component to fill the gap and updating indices accordingly.\n\n4. **Mapping Cleanup**: The sparse set mappings are updated to reflect the new dense array layout, ensuring the moved component maintains correct entity-to-index mapping.\n\n5. **Archetype Transition**: The entity moves to an archetype that lacks this component type, again potentially requiring movement of remaining components.\n\n6. **Iterator Invalidation**: Active iterators are invalidated since the dense array structure has changed through the swap-remove operation.\n\n⚠️ **Pitfall: Iterator Invalidation During Removal**\nA common mistake is removing components while iterating over them. The swap-remove operation changes array indices, causing iterators to skip entities or access invalid memory. Always collect entities for modification first, then process them after iteration completes, or iterate backwards when removing components.\n\n#### Entity Destruction Workflow\n\nEntity destruction represents the complete cleanup of an entity and all its components, requiring coordination across all ECS subsystems to prevent resource leaks and stale references.\n\nThe destruction workflow encompasses:\n\n1. **Component Enumeration**: The system identifies all components attached to the entity, typically by checking component storage systems or consulting archetype metadata.\n\n2. **Component-wise Cleanup**: Each component is individually removed using the component removal process, ensuring proper destructor execution and storage cleanup.\n\n3. **System Notification**: Destruction callbacks are invoked to allow systems to perform cleanup specific to their domain, such as removing entities from spatial indices.\n\n4. **Alive Status Revocation**: The entity is marked as dead in the Entity Manager's tracking structures, preventing future component access attempts.\n\n5. **Generation Increment**: The entity's generation counter is incremented to invalidate any existing Entity references that might still exist in game code.\n\n6. **ID Recycling**: The entity ID is added to the free list for future reuse, but only after the generation increment to prevent the ABA problem.\n\n| Phase | Actions Taken | Failure Recovery | Performance Impact |\n|-------|---------------|------------------|-------------------|\n| Component Scan | Identify attached components | Skip invalid components | O(number of component types) |\n| Component Cleanup | Call destructors, update storage | Log errors, continue cleanup | O(number of attached components) |\n| Callback Execution | Notify interested systems | Isolate callback failures | O(number of registered callbacks) |\n| Status Update | Mark entity dead | Critical - must succeed | O(1) |\n| ID Recycling | Add to free list | Memory leak if failed | O(1) |\n\n> **Decision: Immediate vs. Deferred Destruction**\n> - **Context**: Entity destruction can happen during system iteration, potentially causing iterator invalidation\n> - **Options Considered**: \n>   1. Immediate destruction during system execution\n>   2. Deferred destruction using a \"to-destroy\" queue\n>   3. Generational marking with periodic cleanup\n> - **Decision**: Deferred destruction with end-of-frame cleanup\n> - **Rationale**: Prevents iterator invalidation, allows systems to complete their work, and batches destruction operations for better cache performance\n> - **Consequences**: Requires destruction queue management and ensures destroyed entities remain accessible until cleanup, but eliminates a major source of ECS bugs\n\n### System Update Cycle\n\nThe system update cycle represents the heartbeat of the ECS architecture, where all game logic executes in a coordinated fashion each frame. Understanding this cycle is crucial because it determines how systems interact with entities and components while maintaining performance and correctness.\n\nThink of the system update cycle like a hospital's daily rounds. Each department (system) has specialized responsibilities and visits patients (entities) that need their particular type of care. The neurology department only visits patients with brain-related conditions (entities with specific components), while the cardiology department focuses on heart patients. The hospital runs on a strict schedule - morning labs, afternoon consultations, evening treatments - ensuring departments don't interfere with each other and patients receive care in the proper order.\n\n#### Frame Execution Flow\n\nEach frame follows a predictable execution pattern that ensures systems process entities in the correct order while maintaining data consistency. The frame execution flow coordinates system ordering, component access, and modification patterns.\n\nThe frame execution sequence:\n\n1. **Pre-Frame Setup**: The World processes any deferred entity destruction from the previous frame, cleans up invalidated query iterators, and prepares systems for execution.\n\n2. **System Priority Sorting**: If new systems were registered or priorities changed, the SystemManager sorts systems by their priority values, ensuring deterministic execution order.\n\n3. **Delta Time Calculation**: The frame's delta time is computed from the previous frame's timestamp, providing systems with timing information for frame-rate independent updates.\n\n4. **System Iteration**: Each enabled system executes in priority order, receiving the World reference and delta time as parameters to its update method.\n\n5. **Deferred Modification Processing**: Any component additions or removals that were deferred during system execution are applied, potentially triggering archetype transitions.\n\n6. **Post-Frame Cleanup**: Destroyed entities are fully cleaned up, temporary query iterators are released, and performance statistics are updated.\n\n| Phase | Duration (typical) | Primary Activity | Failure Handling |\n|-------|-------------------|------------------|------------------|\n| Pre-Frame Setup | <1% frame time | Cleanup and preparation | Log errors, continue execution |\n| Priority Sorting | <1% frame time | System ordering | Use previous sort if failed |\n| Delta Time | <1% frame time | Time calculation | Use fixed timestep as fallback |\n| System Execution | 90-95% frame time | Core game logic | Isolate system failures |\n| Deferred Processing | 3-5% frame time | Component modifications | Roll back partial changes |\n| Post-Frame Cleanup | 1-2% frame time | Resource cleanup | Force cleanup on next frame |\n\n#### System Execution and Ordering\n\nSystem execution order critically affects game behavior, as systems often depend on the results of other systems' work. The ordering mechanism must be predictable, configurable, and efficient to maintain frame rate targets.\n\nSystems execute according to several principles:\n\n**Priority-Based Ordering**: Each system has an integer priority value, with lower numbers executing first. This provides explicit control over execution sequence while allowing insertion of new systems at appropriate points.\n\n**Dependency Declaration**: Advanced ECS implementations allow systems to declare dependencies on other systems, automatically computing execution order based on the dependency graph.\n\n**Phase-Based Organization**: Systems are grouped into logical phases like Input, Logic, Physics, Animation, and Rendering, with each phase having a priority range.\n\n**Conditional Execution**: Systems can be disabled dynamically, allowing features to be toggled without removing systems from the execution list.\n\n| Priority Range | Phase | Example Systems | Typical Duration |\n|----------------|-------|-----------------|------------------|\n| 0-99 | Pre-Update | Cleanup, Statistics | 1-2% frame |\n| 100-199 | Input | Input Processing, Event Handling | 3-5% frame |\n| 200-299 | Logic | AI, Game Rules, State Machines | 20-30% frame |\n| 300-399 | Physics | Collision, Movement, Physics | 30-40% frame |\n| 400-499 | Animation | Skeletal Animation, Tweening | 10-20% frame |\n| 500-599 | Rendering | Culling, Rendering, UI | 20-30% frame |\n| 600-699 | Post-Update | Debug, Profiling | 1-2% frame |\n\n> **Design Insight**: Priority-based ordering is simpler than dependency graphs but requires careful priority assignment. Reserve ranges for each phase and leave gaps (e.g., use priorities 100, 200, 300) to allow insertion of new systems without renumbering existing ones.\n\n#### Component Access Patterns\n\nSystems access components through well-defined patterns that balance performance with safety. Understanding these patterns is essential for writing efficient systems that don't cause data races or iterator invalidation.\n\n**Read-Only Access Pattern**: Systems that only read component data can safely iterate over entities without concern for modification conflicts. This pattern enables parallel execution in multi-threaded ECS implementations.\n\n**Exclusive Write Pattern**: Systems that modify components must ensure exclusive access to prevent data races. The deferred modification pattern collects changes during iteration and applies them afterward.\n\n**Mixed Access Pattern**: Systems that read some components and write others require careful ordering to avoid reading stale data or creating inconsistent states.\n\n**Cross-System Communication**: Systems communicate through shared components that act as message queues or through the World's event system rather than direct function calls.\n\n| Access Pattern | Thread Safety | Iterator Safety | Performance Impact | Use Cases |\n|----------------|---------------|-----------------|-------------------|-----------|\n| Read-Only | High | High | Minimal overhead | Rendering, AI queries |\n| Exclusive Write | Medium | Low | Deferred processing cost | Physics, animation |\n| Mixed Access | Low | Low | Significant overhead | Complex game logic |\n| Event-Based | High | High | Moderate overhead | Cross-system communication |\n\n⚠️ **Pitfall: Component Modification During Iteration**\nNever add or remove components while iterating over entities with those components. This invalidates iterators and can cause crashes or memory corruption. Use the deferred modification pattern: collect entities that need changes during iteration, then apply changes after iteration completes.\n\n### Query Execution Patterns\n\nComponent queries form the bridge between systems and the entities they need to process. Efficient query execution is crucial for ECS performance, as poorly implemented queries can turn O(1) component access into expensive linear searches.\n\nThink of component queries like a library's catalog system. When you want books about \"medieval history written in English,\" you don't walk through every shelf checking each book. Instead, you use the catalog's cross-referenced index system - it quickly finds the intersection of \"medieval history\" topics with \"English language\" books. Similarly, component queries use efficient indexing structures (sparse sets, archetype masks) to quickly locate entities that have specific component combinations without examining every entity in the world.\n\n#### Query Specification and Construction\n\nQuery construction defines which entities a system wants to process by specifying required components, optional components, and exclusion criteria. The query system must compile these specifications into efficient execution plans.\n\nThe query construction process involves:\n\n1. **Template Parameter Analysis**: The query system analyzes the template parameters to determine required component types at compile time, enabling type-safe access and optimization.\n\n2. **Component Type Registration**: Each component type in the query is verified to be registered with the ECS, preventing runtime errors from unregistered types.\n\n3. **Query Plan Generation**: The system generates an execution plan that determines the optimal iteration strategy based on component storage types and entity counts.\n\n4. **Iterator Preparation**: Query iterators are prepared with references to the necessary component storage systems and entity lists.\n\n5. **Validation Setup**: Safety checks are configured to detect iterator invalidation during component modification.\n\n| Query Type | Template Signature | Iteration Strategy | Performance Characteristics |\n|------------|-------------------|-------------------|----------------------------|\n| Single Component | `query<Position>()` | Dense array iteration | O(n) where n = component count |\n| Multiple Components | `query<Position, Velocity>()` | Intersection of sparse sets | O(min(n1, n2)) where n1, n2 are component counts |\n| With Exclusions | `query<Position>.exclude<Dead>()` | Filtered iteration | O(n) with per-entity exclusion check |\n| Archetype-Based | Automatic optimization | Chunk iteration | O(matching entities) with perfect cache locality |\n\n#### Entity Filtering and Iteration\n\nEntity filtering determines which entities match the query criteria and provides efficient iteration over the results. The filtering process must balance generality with performance, supporting complex queries while maintaining cache-friendly access patterns.\n\n**Sparse Set Intersection**: For queries involving multiple components, the system computes the intersection of sparse sets to find entities that have all required components. This process is optimized by iterating over the smallest sparse set and checking membership in the others.\n\n**Archetype-Based Filtering**: In archetype systems, filtering becomes a matter of finding archetypes whose component masks include all required components and exclude forbidden ones. This reduces per-entity checks to per-archetype checks.\n\n**Exclusion Handling**: Exclusion criteria (entities that must NOT have certain components) are handled through additional membership tests during iteration or archetype mask operations.\n\n**Cache-Friendly Ordering**: The iteration order is optimized for cache locality, typically following the dense array order of the most restrictive component type.\n\nThe filtering algorithm proceeds as follows:\n\n1. **Component Count Analysis**: Determine the entity count for each required component type to identify the smallest set for intersection-based iteration.\n\n2. **Iteration Strategy Selection**: Choose between sparse set intersection, archetype iteration, or hybrid approaches based on query complexity and entity distribution.\n\n3. **Primary Iterator Setup**: Initialize the primary iterator over the component type with the fewest entities to minimize intersection operations.\n\n4. **Secondary Component Validation**: For each entity in the primary iteration, verify the presence of all other required components and absence of excluded components.\n\n5. **Component Reference Assembly**: Collect references to all requested components for the current entity, preparing them for system access.\n\n6. **Iterator Advancement**: Move to the next matching entity, handling sparse set gaps and archetype boundaries as necessary.\n\n> **Decision: Intersection vs. Archetype Query Strategy**\n> - **Context**: Different query strategies have vastly different performance characteristics depending on entity distribution\n> - **Options Considered**:\n>   1. Always use sparse set intersection\n>   2. Always use archetype iteration when available\n>   3. Hybrid approach selecting strategy based on query characteristics\n> - **Decision**: Hybrid approach with runtime strategy selection\n> - **Rationale**: Sparse set intersection excels for rare component combinations, while archetype iteration excels for common combinations. Automatic selection provides optimal performance across diverse scenarios.\n> - **Consequences**: Requires more complex query compiler but delivers consistent performance regardless of component distribution patterns.\n\n#### Component Access and Modification Safety\n\nSafe component access during query iteration requires careful attention to iterator validity and modification ordering. The access patterns must prevent data races while maintaining the performance benefits of direct component references.\n\n**Direct Reference Access**: Query iterators provide direct references to component data, eliminating the need for additional lookups during system execution. These references remain valid only while the iterator is unchanged.\n\n**Modification Detection**: The query system tracks modifications to component storage that could invalidate iterators, such as component addition/removal or swap-remove operations during component destruction.\n\n**Deferred Modification Pattern**: Systems that need to modify component attachments collect the required changes during iteration and apply them afterward, preserving iterator validity throughout the query loop.\n\n**Type Safety Guarantees**: Template-based query construction provides compile-time guarantees that requested component types match the actual component storage, preventing runtime type errors.\n\n| Safety Mechanism | Protection Provided | Performance Cost | When to Use |\n|------------------|-------------------|------------------|-------------|\n| Iterator Validation | Detects invalidated iterators | Low | Debug builds |\n| Const References | Prevents accidental modification | None | Read-only systems |\n| Deferred Modification | Prevents iterator invalidation | Moderate | Systems that add/remove components |\n| Component Locking | Prevents concurrent access | High | Multi-threaded systems |\n| Copy-Based Access | Eliminates reference invalidation | High | Systems with complex modification patterns |\n\n⚠️ **Pitfall: Stale Component References**\nComponent references obtained from query iterators become invalid if the underlying storage is modified. Never store component references across frame boundaries or after component addition/removal operations. Always re-query components if storage might have changed.\n\nThe query execution patterns form the foundation for efficient system implementation, enabling high-performance entity processing while maintaining type safety and correctness guarantees. Understanding these patterns is essential for writing systems that scale with entity count and component complexity.\n\n![ECS Architecture Overview](./diagrams/ecs-overview.svg)\n\n![Entity Lifecycle State Machine](./diagrams/entity-lifecycle.svg)\n\n![System Update Sequence](./diagrams/system-execution-sequence.svg)\n\n![Component Query Execution Flow](./diagrams/component-query-flow.svg)\n\n![Archetype Transition Process](./diagrams/archetype-transitions.svg)\n\n### Implementation Guidance\n\nThe interactions between ECS components require careful coordination in code to maintain both performance and correctness. This section provides complete implementations of the interaction patterns and concrete examples of proper entity lifecycle management.\n\n#### Technology Recommendations\n\n| Component | Simple Approach | Advanced Approach |\n|-----------|----------------|-------------------|\n| Entity Creation | Direct ID allocation with vector growth | Free list with generation counters |\n| Component Queries | Linear search through entities | Sparse set intersection optimization |\n| System Execution | Simple priority-ordered vector | Dependency graph with topological sort |\n| Modification Safety | Immediate modifications | Deferred modification queues |\n| Iterator Management | Raw pointer iteration | RAII iterator with invalidation detection |\n| Memory Management | Standard allocators | Custom pool allocators for components |\n\n#### Recommended File Structure\n\n```cpp\nproject-root/\n  src/\n    ecs/\n      core/\n        Entity.h                    ← Entity ID and basic types\n        EntityManager.h/.cpp        ← Entity lifecycle management\n        ComponentStorage.h/.cpp     ← Component storage implementation\n        World.h/.cpp               ← Main ECS coordinator\n      \n      systems/\n        System.h                   ← System base class\n        SystemManager.h/.cpp       ← System execution coordination\n        Query.h                    ← Query iterator implementation\n      \n      components/\n        CommonComponents.h         ← Position, Velocity, Health components\n        ComponentRegistry.h/.cpp   ← Component type management\n      \n      utils/\n        SparseSet.h               ← Sparse set implementation\n        TypeUtils.h               ← Template utilities for type handling\n    \n    examples/\n      BasicGameLoop.cpp           ← Complete example showing interactions\n      \n  tests/\n    EntityLifecycleTest.cpp       ← Entity creation/destruction tests\n    SystemExecutionTest.cpp       ← System update cycle tests\n    QueryPerformanceTest.cpp      ← Query execution benchmarks\n```\n\n#### Infrastructure Starter Code\n\n**Complete Entity Lifecycle Manager**:\n```cpp\n#ifndef ENTITY_LIFECYCLE_MANAGER_H\n#define ENTITY_LIFECYCLE_MANAGER_H\n\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <functional>\n\nusing EntityID = uint32_t;\nusing Generation = uint32_t;\n\nconstexpr EntityID INVALID_ENTITY_ID = UINT32_MAX;\nconstexpr Generation DEFAULT_GENERATION = 1;\nconstexpr Generation PERMANENT_GENERATION = UINT32_MAX;\n\nstruct Entity {\n    EntityID id;\n    Generation generation;\n    \n    bool operator==(const Entity& other) const {\n        return id == other.id && generation == other.generation;\n    }\n    \n    bool operator!=(const Entity& other) const {\n        return !(*this == other);\n    }\n};\n\nconstexpr Entity INVALID_ENTITY{INVALID_ENTITY_ID, 0};\n\nclass EntityLifecycleManager {\npublic:\n    using DestroyCallback = std::function<void(Entity)>;\n    \n    EntityLifecycleManager() : next_id_(0) {}\n    \n    // Complete entity creation with generation tracking\n    Entity createEntity() {\n        EntityID id;\n        Generation gen;\n        \n        if (!free_list_.empty()) {\n            id = free_list_.front();\n            free_list_.pop();\n            gen = ++generations_[id];  // Increment generation for recycled ID\n        } else {\n            id = next_id_++;\n            generations_.resize(next_id_, DEFAULT_GENERATION);\n            alive_entities_.resize(next_id_);\n            gen = DEFAULT_GENERATION;\n        }\n        \n        alive_entities_[id] = true;\n        ++alive_count_;\n        \n        Entity entity{id, gen};\n        \n        // Notify creation callbacks\n        for (const auto& callback : creation_callbacks_) {\n            callback(entity);\n        }\n        \n        return entity;\n    }\n    \n    // Safe entity destruction with callback notifications\n    void destroyEntity(Entity entity) {\n        if (!isAlive(entity)) return;\n        \n        destruction_queue_.push(entity);\n    }\n    \n    // Process all queued destructions (call at end of frame)\n    void processDestroyQueue() {\n        while (!destruction_queue_.empty()) {\n            Entity entity = destruction_queue_.front();\n            destruction_queue_.pop();\n            \n            if (!isAlive(entity)) continue;  // Already destroyed\n            \n            // Notify destruction callbacks first\n            for (const auto& callback : destruction_callbacks_) {\n                callback(entity);\n            }\n            \n            // Mark as dead and recycle ID\n            alive_entities_[entity.id] = false;\n            --alive_count_;\n            \n            // Add to free list for recycling (generation already incremented)\n            if (generations_[entity.id] < PERMANENT_GENERATION) {\n                free_list_.push(entity.id);\n            }\n        }\n    }\n    \n    // Fast entity validation\n    bool isAlive(Entity entity) const {\n        return entity.id < generations_.size() && \n               generations_[entity.id] == entity.generation &&\n               alive_entities_[entity.id];\n    }\n    \n    // Get all alive entities (for iteration)\n    std::vector<Entity> getAllEntities() const {\n        std::vector<Entity> entities;\n        entities.reserve(alive_count_);\n        \n        for (EntityID id = 0; id < generations_.size(); ++id) {\n            if (alive_entities_[id]) {\n                entities.push_back({id, generations_[id]});\n            }\n        }\n        \n        return entities;\n    }\n    \n    // Callback registration\n    void registerCreationCallback(const DestroyCallback& callback) {\n        creation_callbacks_.push_back(callback);\n    }\n    \n    void registerDestroyCallback(const DestroyCallback& callback) {\n        destruction_callbacks_.push_back(callback);\n    }\n    \n    size_t getAliveEntityCount() const { return alive_count_; }\n\nprivate:\n    EntityID next_id_;\n    std::vector<Generation> generations_;\n    std::vector<bool> alive_entities_;\n    std::queue<EntityID> free_list_;\n    std::queue<Entity> destruction_queue_;\n    size_t alive_count_ = 0;\n    \n    std::vector<DestroyCallback> creation_callbacks_;\n    std::vector<DestroyCallback> destruction_callbacks_;\n};\n\n#endif // ENTITY_LIFECYCLE_MANAGER_H\n```\n\n**Complete System Execution Framework**:\n```cpp\n#ifndef SYSTEM_EXECUTION_FRAMEWORK_H\n#define SYSTEM_EXECUTION_FRAMEWORK_H\n\n#include <vector>\n#include <memory>\n#include <algorithm>\n#include <chrono>\n#include <stdexcept>\n\n// Forward declarations\nclass World;\n\n// System execution priorities\nconstexpr int PRIORITY_INPUT = 100;\nconstexpr int PRIORITY_LOGIC = 200;\nconstexpr int PRIORITY_PHYSICS = 300;\nconstexpr int PRIORITY_ANIMATION = 400;\nconstexpr int PRIORITY_RENDERING = 500;\nconstexpr int PRIORITY_AUDIO = 600;\nconstexpr int PRIORITY_DEBUG = 700;\n\nclass System {\npublic:\n    System(const std::string& name, int priority) \n        : name_(name), priority_(priority), enabled_(true) {}\n    \n    virtual ~System() = default;\n    \n    // Main system update method - implement in derived classes\n    virtual void update(World& world, float deltaTime) = 0;\n    \n    // System metadata access\n    const std::string& getName() const { return name_; }\n    int getPriority() const { return priority_; }\n    bool isEnabled() const { return enabled_; }\n    void setEnabled(bool enabled) { enabled_ = enabled; }\n    \nprotected:\n    std::string name_;\n    int priority_;\n    bool enabled_;\n};\n\nclass SystemManager {\npublic:\n    // Register a system with automatic priority-based ordering\n    template<typename T, typename... Args>\n    T* registerSystem(int priority, Args&&... args) {\n        auto system = std::make_unique<T>(std::forward<Args>(args)...);\n        T* system_ptr = system.get();\n        \n        systems_.emplace_back(std::move(system));\n        systems_sorted_ = false;  // Mark for re-sorting\n        \n        return system_ptr;\n    }\n    \n    // Execute all enabled systems in priority order\n    void updateAllSystems(World& world, float deltaTime) {\n        ensureSystemsAreSorted();\n        \n        for (const auto& system : systems_) {\n            if (system->isEnabled()) {\n                try {\n                    system->update(world, deltaTime);\n                } catch (const std::exception& e) {\n                    // Log error but continue with other systems\n                    // In production, you might want more sophisticated error handling\n                    fprintf(stderr, \"System %s failed: %s\\n\", \n                            system->getName().c_str(), e.what());\n                }\n            }\n        }\n    }\n    \n    // Find a specific system by type\n    template<typename T>\n    T* getSystem() {\n        for (const auto& system : systems_) {\n            if (T* typed_system = dynamic_cast<T*>(system.get())) {\n                return typed_system;\n            }\n        }\n        return nullptr;\n    }\n    \n    size_t getSystemCount() const { return systems_.size(); }\n    \n    // Remove a system by type\n    template<typename T>\n    bool removeSystem() {\n        auto it = std::find_if(systems_.begin(), systems_.end(),\n            [](const std::unique_ptr<System>& system) {\n                return dynamic_cast<T*>(system.get()) != nullptr;\n            });\n        \n        if (it != systems_.end()) {\n            systems_.erase(it);\n            return true;\n        }\n        return false;\n    }\n\nprivate:\n    void ensureSystemsAreSorted() {\n        if (!systems_sorted_) {\n            std::sort(systems_.begin(), systems_.end(),\n                [](const std::unique_ptr<System>& a, const std::unique_ptr<System>& b) {\n                    return a->getPriority() < b->getPriority();\n                });\n            systems_sorted_ = true;\n        }\n    }\n    \n    std::vector<std::unique_ptr<System>> systems_;\n    bool systems_sorted_ = true;\n};\n\n// High-precision timing utilities\nclass FrameTimer {\npublic:\n    FrameTimer() : last_frame_(std::chrono::high_resolution_clock::now()) {}\n    \n    float tick() {\n        auto current_time = std::chrono::high_resolution_clock::now();\n        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(\n            current_time - last_frame_);\n        last_frame_ = current_time;\n        \n        float delta_seconds = duration.count() / 1000000.0f;\n        \n        // Cap delta time to prevent spiral of death\n        return std::min(delta_seconds, 0.1f);\n    }\n\nprivate:\n    std::chrono::high_resolution_clock::time_point last_frame_;\n};\n\n#endif // SYSTEM_EXECUTION_FRAMEWORK_H\n```\n\n#### Core Logic Skeleton Code\n\n**Entity Lifecycle Integration**:\n```cpp\n// World.h - Main ECS coordinator with lifecycle management\nclass World {\npublic:\n    World() {\n        // TODO 1: Initialize EntityLifecycleManager\n        // TODO 2: Register component cleanup callback with entity manager\n        // TODO 3: Initialize SystemManager\n        // TODO 4: Setup frame timer for delta time calculation\n    }\n    \n    // Entity lifecycle operations\n    Entity createEntity() {\n        // TODO 1: Call entity_manager_.createEntity()\n        // TODO 2: Log entity creation for debugging (optional)\n        // TODO 3: Return the new entity\n    }\n    \n    void destroyEntity(Entity entity) {\n        // TODO 1: Remove all components from entity before destruction\n        // TODO 2: Call entity_manager_.destroyEntity(entity) to queue destruction\n        // TODO 3: Mark any cached query iterators as potentially invalid\n    }\n    \n    // Component operations with lifecycle integration\n    template<typename T>\n    T& addComponent(Entity entity, T&& component) {\n        // TODO 1: Validate entity is alive using entity_manager_.isAlive()\n        // TODO 2: Get or create ComponentStorage<T> instance\n        // TODO 3: Insert component into storage and get reference\n        // TODO 4: Invalidate query iterators that might be affected\n        // TODO 5: Return reference to the stored component\n        // Hint: Use storage_.insert(entity.id, std::forward<T>(component))\n    }\n    \n    template<typename T>\n    bool removeComponent(Entity entity) {\n        // TODO 1: Validate entity is alive\n        // TODO 2: Find ComponentStorage<T> instance\n        // TODO 3: Remove component using storage_.remove(entity.id)\n        // TODO 4: Invalidate affected query iterators\n        // TODO 5: Return true if component was removed, false if not found\n    }\n    \n    // Query creation with proper iterator management\n    template<typename... Components>\n    QueryIterator<Components...> query() {\n        // TODO 1: Validate all component types are registered\n        // TODO 2: Find component storages for each type\n        // TODO 3: Create iterator with intersection of entities\n        // TODO 4: Register iterator for invalidation tracking\n        // TODO 5: Return properly initialized iterator\n        // Hint: Use sparse set intersection for multiple components\n    }\n    \n    // Frame execution with proper lifecycle management\n    void update() {\n        // TODO 1: Calculate delta time using frame_timer_.tick()\n        // TODO 2: Process any queued entity destructions\n        // TODO 3: Execute all systems via system_manager_.updateAllSystems()\n        // TODO 4: Apply any deferred component modifications\n        // TODO 5: Clean up invalidated query iterators\n        // Hint: Always process destructions before system updates\n    }\n\nprivate:\n    EntityLifecycleManager entity_manager_;\n    SystemManager system_manager_;\n    FrameTimer frame_timer_;\n    \n    // TODO: Add component storage management\n    // TODO: Add query iterator tracking for invalidation\n    // TODO: Add deferred modification queue\n};\n```\n\n**Query Iterator with Safety**:\n```cpp\n// Query.h - Safe query iteration with lifecycle awareness\ntemplate<typename... Components>\nclass QueryIterator {\npublic:\n    QueryIterator(World* world, std::vector<Entity> entities) \n        : world_(world), entities_(std::move(entities)), current_index_(0) {\n        // TODO 1: Store weak reference to world for validation\n        // TODO 2: Register this iterator for invalidation tracking\n        // TODO 3: Validate all entities are alive at construction time\n        // TODO 4: Initialize current_index_ to first valid entity\n    }\n    \n    // Iterator interface\n    std::tuple<Components&...> operator*() {\n        // TODO 1: Validate iterator is still valid (not invalidated)\n        // TODO 2: Validate current entity is alive\n        // TODO 3: Get component references for current entity\n        // TODO 4: Return tuple of component references\n        // TODO 5: Throw exception if entity died or components were removed\n        // Hint: Use world_->getComponent<T>(current_entity()) for each type\n    }\n    \n    QueryIterator& operator++() {\n        // TODO 1: Increment current_index_\n        // TODO 2: Skip any dead entities (they might have died during iteration)\n        // TODO 3: Validate we don't go past the end of entities vector\n        // TODO 4: Update internal state for next dereference\n        // TODO 5: Return *this for chaining\n    }\n    \n    bool operator!=(const QueryIterator& other) const {\n        // TODO 1: Compare world pointers for same query source\n        // TODO 2: Compare current_index_ positions\n        // TODO 3: Handle end() iterator comparison correctly\n        // TODO 4: Return true if iterators point to different positions\n    }\n    \n    Entity entity() const {\n        // TODO 1: Validate current_index_ is within bounds\n        // TODO 2: Return entities_[current_index_]\n        // TODO 3: Handle end-of-iteration case appropriately\n    }\n    \n    // Range-based for loop support\n    QueryIterator begin() { return *this; }\n    QueryIterator end() { \n        // TODO 1: Create end iterator with current_index_ = entities_.size()\n        // TODO 2: Ensure end iterator compares correctly with operator!=\n    }\n\nprivate:\n    World* world_;\n    std::vector<Entity> entities_;\n    size_t current_index_;\n    \n    // TODO: Add invalidation detection mechanism\n    // TODO: Add entity liveness checking during iteration\n};\n```\n\n#### Language-Specific Implementation Hints\n\n**C++ Template and Memory Management**:\n- Use `std::unordered_map<std::type_index, std::unique_ptr<IComponentStorage>>` for type-erased component storage management\n- Implement `ComponentStorage<T>` as template specialization of `IComponentStorage` interface\n- Use `std::forward<T>(component)` for perfect forwarding in `addComponent`\n- Consider `std::vector<std::unique_ptr<System>>` for system storage with automatic cleanup\n- Use RAII pattern for query iterator lifecycle management\n\n**Performance Optimization Tips**:\n- Reserve space in entity vectors using `entities_.reserve(expected_count)`\n- Use `std::move` semantics when transferring component ownership\n- Consider memory pools for frequent entity creation/destruction patterns\n- Profile sparse set intersection performance vs. linear iteration for different entity counts\n- Use `likely`/`unlikely` attributes for common/rare execution paths in C++20\n\n#### Milestone Checkpoint\n\nAfter implementing the interaction patterns, verify correct behavior:\n\n**Entity Lifecycle Verification**:\n```bash\n# Compile and run entity lifecycle test\ng++ -std=c++17 -O2 -o lifecycle_test EntityLifecycleTest.cpp\n./lifecycle_test\n\n# Expected output:\n# Entity creation: 1000 entities created in <10ms\n# Entity destruction: 1000 entities destroyed, 0 alive remaining\n# ID recycling: 1000 new entities reused old IDs with incremented generations\n# Memory usage: No memory leaks detected\n```\n\n**System Execution Verification**:\n```bash\n# Run system execution test with multiple systems\n./system_test --entities=10000 --systems=5\n\n# Expected output:\n# Frame 1: Input(100) -> Logic(200) -> Physics(300) -> Rendering(500) [16.67ms]\n# Frame 2: Input(100) -> Logic(200) -> Physics(300) -> Rendering(500) [16.33ms]\n# Average system execution order: Correct priority-based ordering maintained\n# System isolation: No system failures affected other systems\n```\n\n**Query Performance Verification**:\n```bash\n# Benchmark query execution with different entity counts\n./query_benchmark --max-entities=100000\n\n# Expected output:\n# Single component query: 100k entities processed in <5ms\n# Two component intersection: 50k matching entities in <8ms  \n# Three component intersection: 10k matching entities in <12ms\n# Query iteration overhead: <10% of total processing time\n```\n\n**Signs of Problems**:\n- **Entity ID collisions**: Check generation counter implementation\n- **Iterator crashes**: Verify query invalidation handling during component modification\n- **System execution order violations**: Check SystemManager priority sorting\n- **Memory leaks**: Ensure EntityLifecycleManager processes destruction queue\n- **Performance degradation**: Profile query intersection algorithms for optimization opportunities\n\n\n## Error Handling and Edge Cases\n\n> **Milestone(s):** Milestones 1-4 — robust error handling and edge case management for entity validation, component type safety, and system execution reliability\n\nIn any complex system, robust error handling separates production-ready code from fragile prototypes. ECS architectures face unique challenges because they operate on large numbers of entities and components each frame, making error recovery critical for maintaining game stability. A single uncaught error in a physics system shouldn't crash the entire game — players expect smooth experiences even when individual components fail.\n\nThink of error handling in an ECS like quality control in a massive factory assembly line. Each station (system) processes thousands of items (entities) per minute. When defects occur — broken parts, missing components, or station malfunctions — the factory needs protocols to detect problems, isolate failures, and continue production without shutting down the entire operation.\n\nOur error handling strategy addresses three critical failure domains: **entity validation** (preventing access to destroyed entities), **component type safety** (preventing type mismatches during component operations), and **system execution recovery** (handling system failures gracefully). Each domain requires different detection mechanisms and recovery strategies.\n\n### Entity Validation Strategies\n\nEntity validation prevents the most common and dangerous class of ECS bugs: accessing destroyed entities through stale references. Without proper validation, stale entity access can corrupt memory, crash systems, or produce subtle gameplay bugs that are extremely difficult to debug.\n\n#### Mental Model: Hotel Key Cards with Expiration\n\nThink of entity validation like a hotel key card system. Each guest (entity reference) receives a key card with both a room number (entity ID) and an expiration timestamp (generation counter). When checking in, the front desk verifies both the room number exists and the key card hasn't expired. If a previous guest's key card is used after checkout, the system rejects access even if the room number is valid — the generation counter prevents the \"wrong guest accessing the room\" problem.\n\nThe generation counter mechanism provides our primary defense against stale entity access. Every time an entity ID is recycled, the generation increments, making old references invalid even if they contain the correct entity ID.\n\n> **Decision: Multi-Layered Entity Validation**\n> - **Context**: ECS systems make thousands of entity accesses per frame, requiring fast validation without sacrificing safety\n> - **Options Considered**: \n>   1. No validation (fastest but unsafe)\n>   2. Generation-only validation (fast but incomplete)\n>   3. Multi-layered validation with graceful degradation\n> - **Decision**: Multi-layered validation combining generation checks, alive status verification, and optional debug assertions\n> - **Rationale**: Provides configurable safety levels — release builds use fast generation checks while debug builds add comprehensive validation\n> - **Consequences**: Slight performance overhead in exchange for robust error detection and easier debugging\n\n| Validation Layer | Performance Cost | Detection Capability | When Active |\n|------------------|------------------|---------------------|-------------|\n| Generation Check | ~1 CPU cycle | Stale entity references | Always |\n| Alive Status Verification | ~2-3 CPU cycles | Recently destroyed entities | Always |\n| Component Existence Check | ~5-10 CPU cycles | Missing component access | Debug builds |\n| Memory Bounds Check | ~10-20 CPU cycles | Buffer overruns | Debug builds |\n\n#### Entity Validation State Machine\n\nThe entity validation process follows a clear state machine that determines whether an entity reference is valid for component access:\n\n| Current State | Validation Check | Next State | Action Taken |\n|--------------|------------------|------------|--------------|\n| Reference Received | Check generation counter | Valid Generation / Invalid Generation | Continue / Return error |\n| Valid Generation | Check alive status in EntityManager | Alive / Dead | Continue / Return error |\n| Alive | Verify component exists (debug only) | Component Found / Missing | Continue / Return error |\n| Component Found | Verify memory bounds (debug only) | Valid Access / Out of Bounds | Return reference / Assertion failure |\n\nThe validation algorithm follows these steps:\n\n1. Extract the entity ID and generation from the entity reference\n2. Bounds-check the entity ID against the EntityManager's capacity\n3. Compare the reference generation against the current generation for that ID slot\n4. If generations match, verify the entity is marked alive in the status array\n5. In debug builds, additionally verify the requested component type exists for this entity\n6. In debug builds, perform bounds checking on the component array access\n7. Return success with component reference or failure with specific error code\n\n#### Validation Error Recovery Strategies\n\nWhen entity validation fails, our recovery strategy depends on the validation layer and execution context. The goal is to provide meaningful diagnostics while maintaining system stability.\n\n| Failure Mode | Detection Method | Recovery Action | Error Information |\n|-------------|------------------|-----------------|-------------------|\n| Invalid Generation | Generation counter mismatch | Return null/error code | Entity ID, expected vs actual generation |\n| Dead Entity Access | Alive status check failure | Return null/error code | Entity ID, destruction frame number |\n| Missing Component | Component existence check | Return null/error code | Entity ID, requested component type |\n| Memory Corruption | Bounds checking failure | Assertion/exception | Entity ID, memory address, expected bounds |\n\n> The critical insight here is that validation failures often indicate logic bugs rather than runtime conditions. A well-designed game should rarely attempt to access destroyed entities, so validation failures should be logged aggressively for debugging.\n\nFor graceful error recovery, we provide both throwing and non-throwing variants of component access methods:\n\n| Method Variant | Failure Behavior | Use Case |\n|---------------|------------------|----------|\n| `getComponent<T>(entity)` | Throws exception | When component must exist |\n| `tryGetComponent<T>(entity)` | Returns nullptr | When component might not exist |\n| `hasComponent<T>(entity)` | Returns false | For conditional access |\n\n#### Common Entity Validation Pitfalls\n\n⚠️ **Pitfall: Caching Entity References Across Frames**\n\nMany developers cache entity references in systems or components, assuming they remain valid indefinitely. This breaks when entities are destroyed and their IDs recycled.\n\nExample problematic pattern:\n```cpp\nclass FollowSystem {\n    Entity target_; // Cached across frames - DANGEROUS\n    void update(World& world, float dt) {\n        auto& position = world.getComponent<Position>(target_); // May access wrong entity\n    }\n};\n```\n\n**Why it's wrong**: The cached `target_` entity might be destroyed and its ID recycled for a completely different entity type.\n\n**How to fix**: Always re-validate cached entity references or use entity lifecycle callbacks to clear invalid references.\n\n⚠️ **Pitfall: Ignoring Validation Failures**\n\nSystems sometimes ignore validation failures and continue processing, leading to subtle bugs or crashes later.\n\n**Why it's wrong**: Validation failures indicate serious logic errors that compound over time.\n\n**How to fix**: Always check validation results and handle failures explicitly, either by skipping the entity or logging the error for investigation.\n\n⚠️ **Pitfall: Expensive Validation in Hot Loops**\n\nDebug builds sometimes add expensive validation that makes the game unplayable during development.\n\n**Why it's wrong**: Developers disable debug builds to maintain playable framerates, losing valuable error detection.\n\n**How to fix**: Use tiered validation with lightweight checks always enabled and expensive validation controllable via compile-time flags.\n\n### Component Type Safety\n\nComponent type safety prevents runtime errors from type mismatches during component operations. Without proper type safety, systems might attempt to access a `Position` component as a `Velocity` component, leading to memory corruption or incorrect behavior.\n\n#### Mental Model: Library Card Catalog with ISBN Numbers\n\nThink of component type safety like a library card catalog system where each book (component) has both a shelf location (entity ID) and an ISBN number (component type ID). When a patron requests \"the physics book from shelf 42,\" the librarian doesn't just grab whatever book is at that location — they verify the ISBN matches the expected book type. This prevents accidentally checking out a cookbook when you requested a physics textbook.\n\nComponent type IDs serve as our \"ISBN system\" for runtime type verification. Each component type receives a unique identifier during registration, and all component operations verify the type ID before performing memory access.\n\n> **Decision: Compile-Time + Runtime Type Safety**\n> - **Context**: C++ templates provide compile-time type safety, but ECS systems need runtime type verification for dynamic operations\n> - **Options Considered**:\n>   1. Compile-time only (fast but limited flexibility)\n>   2. Runtime only (flexible but slower and less safe)\n>   3. Hybrid compile-time + runtime validation\n> - **Decision**: Hybrid approach using templates for compile-time safety and type IDs for runtime verification\n> - **Rationale**: Templates catch most errors at compile-time with zero runtime cost, while type IDs enable dynamic operations like serialization and debugging\n> - **Consequences**: Best of both worlds — fast execution with runtime flexibility, but increased implementation complexity\n\n#### Component Type Registration System\n\nThe `ComponentTypeRegistry` maintains metadata for all registered component types, enabling runtime type verification and introspection:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `typeID` | `ComponentTypeID` | Unique identifier for this component type |\n| `name` | `string` | Human-readable type name for debugging |\n| `size` | `size_t` | Memory size in bytes for allocation |\n| `alignment` | `size_t` | Memory alignment requirements |\n| `destructor` | `function pointer` | Cleanup function for component destruction |\n| `moveConstructor` | `function pointer` | Move semantics for component relocation |\n\nThe type registration process follows these steps:\n\n1. Template specialization generates unique type information at compile-time\n2. First access to a component type triggers registration via `registerComponentType<T>()`\n3. Registry assigns monotonically increasing type IDs starting from 1\n4. Type metadata is stored in a global registry accessible by component type ID\n5. Template functions use compile-time type information while runtime systems use type IDs\n\n#### Type-Safe Component Access Patterns\n\nComponent access methods use template specialization to ensure compile-time type safety while adding runtime verification for additional protection:\n\n| Access Pattern | Compile-Time Safety | Runtime Verification | Performance |\n|---------------|-------------------|---------------------|-------------|\n| `getComponent<Position>(entity)` | Full template checking | Type ID verification | Fastest |\n| `tryGetComponent<Position>(entity)` | Full template checking | Type ID + null checking | Fast |\n| `getComponentByTypeID(entity, typeID)` | Type-erased access | Full runtime verification | Slower |\n| `hasComponent<Position>(entity)` | Template specialization | Type ID verification | Fast |\n\nThe component storage system maintains type safety through several mechanisms:\n\n1. **Template Specialization**: Each `ComponentStorage<T>` instance is specialized for a specific component type\n2. **Type ID Verification**: Runtime checks ensure component type IDs match expected types\n3. **Memory Layout Validation**: Debug builds verify component sizes and alignments match registered metadata\n4. **Bounds Checking**: Array access is bounds-checked against component storage capacity\n\n#### Type Mismatch Error Recovery\n\nWhen type mismatches occur, our recovery strategy focuses on providing clear diagnostic information while maintaining system stability:\n\n| Error Type | Detection Point | Recovery Action | Diagnostic Information |\n|-----------|----------------|-----------------|----------------------|\n| Wrong Component Type | Template access with wrong type | Compile error | Expected vs actual type names |\n| Unregistered Type | First component operation | Runtime exception | Component type name and registration hint |\n| Type ID Mismatch | Runtime type verification | Return error code | Expected vs actual type IDs and names |\n| Size Mismatch | Component storage allocation | Runtime exception | Expected vs actual sizes and alignment |\n\n> The key insight for type safety is that most type errors should be caught at compile-time through template specialization. Runtime type checking serves as a safety net for dynamic operations and provides better error messages during debugging.\n\n#### Common Component Type Safety Pitfalls\n\n⚠️ **Pitfall: Accessing Components Without Type Registration**\n\nSystems sometimes attempt to access component types before they're registered with the `ComponentTypeRegistry`.\n\n**Why it's wrong**: Unregistered types have invalid type IDs, leading to failed lookups or memory corruption.\n\n**How to fix**: Ensure all component types are registered during system initialization, preferably in a centralized location.\n\n⚠️ **Pitfall: Type ID Collisions from Manual Assignment**\n\nDevelopers sometimes manually assign component type IDs instead of using automatic registration.\n\n**Why it's wrong**: Manual assignment can create ID collisions, causing different component types to share the same identifier.\n\n**How to fix**: Always use `registerComponentType<T>()` for automatic ID assignment and maintain a single source of truth for type registration.\n\n⚠️ **Pitfall: Mixing Template and Type-Erased Access**\n\nCode sometimes mixes template-based component access with type-erased access without proper verification.\n\n**Why it's wrong**: Type-erased access bypasses compile-time safety checks, making type mismatches possible.\n\n**How to fix**: Use consistent access patterns within each system and add explicit type verification when mixing access methods.\n\n### System Execution Error Recovery\n\nSystem execution errors occur when individual systems encounter runtime failures during their update cycles. Unlike entity validation or type safety errors, system execution errors often represent recoverable conditions that shouldn't crash the entire frame update.\n\n#### Mental Model: Circuit Breakers in Electrical Systems\n\nThink of system execution error recovery like circuit breakers in a house's electrical system. When one appliance (system) has a problem and starts drawing too much current (encounters an error), the circuit breaker trips to protect the rest of the house (game engine) from damage. The faulty appliance stops working, but the lights in other rooms stay on. Once the problem is fixed, you can reset the breaker and restore normal operation.\n\nSystem error recovery uses a similar circuit breaker pattern — when a system encounters repeated failures, it gets temporarily disabled to prevent cascading errors, while other systems continue normal execution.\n\n> **Decision: Isolated System Execution with Circuit Breaker Pattern**\n> - **Context**: Game systems must run every frame, but individual system failures shouldn't crash the entire game\n> - **Options Considered**:\n>   1. Fail-fast approach (terminate on first system error)\n>   2. Silent failure recovery (ignore errors and continue)\n>   3. Circuit breaker pattern with error isolation\n> - **Decision**: Circuit breaker pattern with configurable error thresholds and recovery mechanisms\n> - **Rationale**: Provides excellent stability by isolating failing systems while maintaining visibility into errors for debugging\n> - **Consequences**: Games remain playable even with buggy systems, but adds complexity to system management and error reporting\n\n#### System Error Classification\n\nDifferent types of system errors require different recovery strategies. Our classification system helps determine the appropriate response:\n\n| Error Class | Severity | Recovery Strategy | Example |\n|------------|----------|-------------------|---------|\n| Transient | Low | Retry next frame | Network timeout in multiplayer sync |\n| Logic Error | Medium | Skip current frame, continue next frame | Division by zero in physics calculation |\n| Resource Exhaustion | High | Disable system temporarily | Out of memory for particle effects |\n| Critical Error | Critical | Disable system permanently | Corrupted system internal state |\n\n#### Circuit Breaker State Machine\n\nThe circuit breaker mechanism follows a state machine that tracks system health and automatically manages system execution:\n\n| Current State | Error Event | Next State | Action Taken |\n|--------------|-------------|------------|--------------|\n| Healthy | No errors | Healthy | Normal execution |\n| Healthy | Single error | Monitoring | Log error, continue execution |\n| Monitoring | Error threshold exceeded | Open | Disable system, start recovery timer |\n| Open | Recovery timeout | Half-Open | Re-enable system with limited execution |\n| Half-Open | Successful execution | Healthy | Restore normal execution |\n| Half-Open | Error occurs | Open | Disable system, extend recovery period |\n\nThe system execution framework manages error recovery through these steps:\n\n1. Wrap each system's update call in exception handling\n2. Track error count and frequency for each system\n3. When error threshold is exceeded, transition system to disabled state\n4. Continue executing other systems normally\n5. After recovery timeout, attempt to re-enable the failed system\n6. Monitor re-enabled systems for continued failures\n7. Log all errors with context for debugging and telemetry\n\n#### Error Context Collection\n\nWhen system errors occur, comprehensive context collection enables effective debugging and recovery decisions:\n\n| Context Category | Information Collected | Purpose |\n|-----------------|----------------------|---------|\n| System State | System name, priority, enabled status | Identify which system failed |\n| Execution Context | Frame number, delta time, entity count | Understand execution environment |\n| Error Details | Exception type, message, stack trace | Diagnose root cause |\n| Entity Context | Current entity being processed, component state | Isolate problematic entities |\n| Resource Usage | Memory usage, CPU time, allocation count | Detect resource-related failures |\n\n#### System Dependency Management\n\nSystem errors become more complex when systems have dependencies on each other. Our dependency management ensures that dependent systems handle upstream failures gracefully:\n\n| Dependency Type | Failure Response | Recovery Strategy |\n|----------------|------------------|-------------------|\n| Required Dependency | Disable dependent system | Re-enable when dependency recovers |\n| Optional Dependency | Continue with degraded functionality | Log warning, use fallback behavior |\n| Circular Dependency | Break dependency cycle | Disable one system to prevent cascade |\n\nThe dependency resolution algorithm works as follows:\n\n1. Build dependency graph during system registration\n2. When a system fails, identify all dependent systems\n3. For required dependencies, cascade disable to dependent systems\n4. For optional dependencies, notify dependent systems of upstream failure\n5. During recovery, re-enable systems in dependency order\n6. Detect and break circular dependencies to prevent deadlocks\n\n#### Common System Execution Pitfalls\n\n⚠️ **Pitfall: Modifying Components During Iteration**\n\nSystems sometimes modify component collections (adding/removing components) while iterating over entities, causing iterator invalidation.\n\n**Why it's wrong**: Iterator invalidation can cause crashes, infinite loops, or skipped entities.\n\n**How to fix**: Use deferred modification patterns — collect changes during iteration and apply them after iteration completes.\n\n⚠️ **Pitfall: Ignoring System Execution Order**\n\nDevelopers sometimes ignore system execution dependencies, leading to systems processing stale data from the previous frame.\n\n**Why it's wrong**: Processing order affects game logic correctness — physics must run before rendering, input before movement.\n\n**How to fix**: Explicitly declare system dependencies and use priority-based scheduling to ensure correct execution order.\n\n⚠️ **Pitfall: Resource Leaks in Failed Systems**\n\nFailed systems sometimes leak resources (memory, file handles, GPU resources) when they're disabled due to errors.\n\n**Why it's wrong**: Resource leaks accumulate over time and can cause system-wide failures.\n\n**How to fix**: Implement proper cleanup in system destructors and error handling paths, ensure resources are released when systems are disabled.\n\n### Implementation Guidance\n\nThe error handling implementation requires careful balance between safety, performance, and usability. Our approach provides configurable safety levels that can be adjusted based on build configuration and performance requirements.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Exception Handling | `std::exception` with error codes | Custom exception hierarchy with structured data |\n| Error Logging | `std::cerr` with simple messages | Structured logging library (spdlog) with levels |\n| Assertion System | Standard `assert()` macro | Custom assertions with stack traces |\n| Memory Debugging | Built-in bounds checking | AddressSanitizer or Valgrind integration |\n\n#### Recommended File Structure\n\n```cpp\nproject-root/\n  src/ecs/\n    error_handling/\n      entity_validator.h          ← Entity validation strategies\n      entity_validator.cpp\n      component_type_safety.h     ← Component type verification\n      component_type_safety.cpp   \n      system_circuit_breaker.h    ← System error recovery\n      system_circuit_breaker.cpp\n      error_context.h             ← Error context collection\n      error_context.cpp\n      ecs_exceptions.h            ← Custom exception types\n    core/\n      entity_manager.h            ← Modified with validation\n      component_storage.h         ← Modified with type safety\n      system_manager.h            ← Modified with error recovery\n```\n\n#### Entity Validation Infrastructure\n\n```cpp\n// Complete entity validation with configurable safety levels\nclass EntityValidator {\npublic:\n    enum class ValidationLevel {\n        NONE,           // No validation (release builds)\n        BASIC,          // Generation counter only\n        STANDARD,       // Generation + alive status\n        COMPREHENSIVE   // All checks including bounds\n    };\n    \n    struct ValidationResult {\n        bool valid;\n        EntityID entity_id;\n        Generation expected_generation;\n        Generation actual_generation;\n        std::string error_message;\n    };\n    \n    // Validates entity reference with configurable checking level\n    static ValidationResult validateEntity(\n        const EntityManager& manager, \n        Entity entity, \n        ValidationLevel level = ValidationLevel::STANDARD\n    ) {\n        // TODO 1: Check if entity ID is within valid range\n        // TODO 2: Compare entity generation with manager's current generation\n        // TODO 3: If STANDARD or higher, verify entity is marked alive\n        // TODO 4: If COMPREHENSIVE, perform additional bounds checking\n        // TODO 5: Construct detailed ValidationResult with error context\n        return {};\n    }\n    \n    // Fast validation for hot paths (generation check only)\n    static inline bool isValidQuick(const EntityManager& manager, Entity entity) {\n        // TODO 1: Bounds check entity ID against manager capacity\n        // TODO 2: Generation comparison with early exit\n        return false;\n    }\n};\n\n// Exception types for different validation failures\nclass EntityValidationException : public std::exception {\npublic:\n    EntityValidationException(const EntityValidator::ValidationResult& result)\n        : result_(result) {\n        // TODO: Format detailed error message from ValidationResult\n    }\n    \n    const char* what() const noexcept override {\n        // TODO: Return formatted error message\n        return \"\";\n    }\n    \n    const EntityValidator::ValidationResult& getResult() const { return result_; }\n    \nprivate:\n    EntityValidator::ValidationResult result_;\n};\n```\n\n#### Component Type Safety Infrastructure\n\n```cpp\n// Type-safe component access with runtime verification\ntemplate<typename T>\nclass TypeSafeComponentAccess {\npublic:\n    // Throws exception on type mismatch or invalid access\n    static T& getComponent(ComponentStorage<T>& storage, EntityID entity) {\n        // TODO 1: Verify T is registered with ComponentTypeRegistry\n        // TODO 2: Check entity exists in component storage\n        // TODO 3: Verify component type ID matches T's registered type\n        // TODO 4: Perform bounds checking in debug builds\n        // TODO 5: Return reference to component\n        static T dummy;\n        return dummy;\n    }\n    \n    // Returns nullptr on any access failure\n    static T* tryGetComponent(ComponentStorage<T>& storage, EntityID entity) {\n        // TODO 1: All validation steps from getComponent\n        // TODO 2: Return nullptr instead of throwing on failure\n        // TODO 3: Log warnings for debugging in debug builds\n        return nullptr;\n    }\n    \n    // Verifies component exists without accessing data\n    static bool hasComponent(const ComponentStorage<T>& storage, EntityID entity) {\n        // TODO 1: Basic type registration check\n        // TODO 2: Entity existence check in storage\n        // TODO 3: Return boolean result without exceptions\n        return false;\n    }\n};\n\n// Runtime type verification for dynamic operations\nclass ComponentTypeVerifier {\npublic:\n    struct TypeMismatchInfo {\n        ComponentTypeID expected_type;\n        ComponentTypeID actual_type;\n        std::string expected_name;\n        std::string actual_name;\n        EntityID entity_id;\n    };\n    \n    // Verifies component type matches expected type ID\n    static bool verifyComponentType(\n        EntityID entity,\n        ComponentTypeID expected_type,\n        IComponentStorage* storage,\n        TypeMismatchInfo* mismatch_info = nullptr\n    ) {\n        // TODO 1: Get actual component type from storage\n        // TODO 2: Compare with expected type ID\n        // TODO 3: If mismatch_info provided, fill in diagnostic details\n        // TODO 4: Look up human-readable type names from registry\n        return false;\n    }\n    \n    // Validates all registered types have consistent metadata\n    static std::vector<std::string> validateTypeRegistry() {\n        // TODO 1: Iterate through all registered component types\n        // TODO 2: Verify type IDs are unique and sequential\n        // TODO 3: Check size and alignment constraints are valid\n        // TODO 4: Return list of any inconsistencies found\n        return {};\n    }\n};\n```\n\n#### System Circuit Breaker Infrastructure\n\n```cpp\n// Circuit breaker for individual system error recovery\nclass SystemCircuitBreaker {\npublic:\n    enum class State {\n        HEALTHY,     // System executing normally\n        MONITORING,  // Tracking errors, still executing\n        OPEN,        // System disabled due to errors\n        HALF_OPEN    // Testing system recovery\n    };\n    \n    struct ErrorThreshold {\n        size_t max_errors = 5;           // Errors before opening circuit\n        float time_window = 10.0f;       // Time window for error counting (seconds)\n        float recovery_timeout = 30.0f;  // Time before attempting recovery\n    };\n    \n    struct SystemHealthInfo {\n        State state = State::HEALTHY;\n        size_t error_count = 0;\n        float last_error_time = 0.0f;\n        float state_change_time = 0.0f;\n        std::vector<std::string> recent_errors;\n    };\n    \nprivate:\n    std::unordered_map<std::string, SystemHealthInfo> system_health_;\n    ErrorThreshold thresholds_;\n    float current_time_ = 0.0f;\n    \npublic:\n    SystemCircuitBreaker(const ErrorThreshold& thresholds = {})\n        : thresholds_(thresholds) {}\n    \n    // Records error for system and updates circuit breaker state\n    void recordError(const std::string& system_name, const std::string& error_message) {\n        // TODO 1: Get or create SystemHealthInfo for this system\n        // TODO 2: Add error to recent errors list (with time truncation)\n        // TODO 3: Increment error count and update last error time\n        // TODO 4: Check if error threshold exceeded in time window\n        // TODO 5: Transition to MONITORING or OPEN state as appropriate\n        // TODO 6: Log state transitions for debugging\n    }\n    \n    // Checks if system should be executed this frame\n    bool shouldExecuteSystem(const std::string& system_name) {\n        // TODO 1: Get SystemHealthInfo for system\n        // TODO 2: Handle HEALTHY and MONITORING states (execute normally)\n        // TODO 3: Handle OPEN state (check recovery timeout)\n        // TODO 4: Handle HALF_OPEN state (limited execution)\n        // TODO 5: Update current_time_ and perform time-based state transitions\n        return true;\n    }\n    \n    // Records successful execution for recovery monitoring\n    void recordSuccess(const std::string& system_name) {\n        // TODO 1: Get SystemHealthInfo for system\n        // TODO 2: If in HALF_OPEN, transition back to HEALTHY\n        // TODO 3: If in MONITORING, clear error count if no recent errors\n        // TODO 4: Update state change timestamps\n    }\n    \n    // Gets current health status for debugging/telemetry\n    SystemHealthInfo getSystemHealth(const std::string& system_name) const {\n        // TODO: Return copy of SystemHealthInfo or default if not found\n        return {};\n    }\n    \n    void updateTime(float delta_time) {\n        current_time_ += delta_time;\n    }\n};\n\n// Enhanced SystemManager with error recovery\nclass ErrorRecoverySystemManager : public SystemManager {\nprivate:\n    SystemCircuitBreaker circuit_breaker_;\n    std::unordered_map<std::string, std::vector<std::string>> system_dependencies_;\n    \npublic:\n    // Override base updateAllSystems to add error handling\n    void updateAllSystems(World& world, float delta_time) override {\n        circuit_breaker_.updateTime(delta_time);\n        \n        // TODO 1: Iterate through systems in priority order\n        // TODO 2: Check circuit breaker before executing each system\n        // TODO 3: Wrap system execution in try-catch block\n        // TODO 4: Record errors/successes with circuit breaker\n        // TODO 5: Handle dependency cascading for failed systems\n        // TODO 6: Continue with remaining systems even if some fail\n    }\n    \n    // Declares dependency relationship between systems\n    void addSystemDependency(const std::string& dependent, const std::string& dependency) {\n        // TODO 1: Add dependency to dependency map\n        // TODO 2: Validate no circular dependencies created\n        // TODO 3: Update system execution order if needed\n    }\n    \n    // Gets error statistics for monitoring/debugging\n    std::vector<std::pair<std::string, SystemCircuitBreaker::SystemHealthInfo>> \n    getSystemHealthReport() const {\n        // TODO 1: Iterate through all registered systems\n        // TODO 2: Get health info from circuit breaker for each\n        // TODO 3: Return sorted list for display/logging\n        return {};\n    }\n};\n```\n\n#### Milestone Checkpoint\n\nAfter implementing error handling:\n\n**Entity Validation Test:**\n```bash\n# Run entity validation tests\ng++ -DDEBUG -g -o entity_validator_test test/entity_validator_test.cpp\n./entity_validator_test\n\n# Expected output:\n# [PASS] Valid entity access succeeds\n# [PASS] Stale entity reference detected and rejected  \n# [PASS] Generation counter prevents ABA problem\n# [PASS] Out of bounds entity ID rejected\n```\n\n**Component Type Safety Test:**\n```bash\n# Run component type safety tests\ng++ -DDEBUG -g -o component_safety_test test/component_safety_test.cpp  \n./component_safety_test\n\n# Expected output:\n# [PASS] Template type checking works at compile time\n# [PASS] Runtime type verification catches mismatches\n# [PASS] Unregistered component type throws exception\n# [PASS] Type-erased access validates correctly\n```\n\n**System Error Recovery Test:**\n```bash\n# Run system circuit breaker tests\ng++ -DDEBUG -g -o system_recovery_test test/system_recovery_test.cpp\n./system_recovery_test\n\n# Expected output:\n# [PASS] Healthy system executes normally  \n# [PASS] Failed system disabled after threshold\n# [PASS] System recovery after timeout\n# [PASS] Dependent systems disabled with failed dependency\n```\n\n**Manual Verification Steps:**\n1. Create entities and immediately destroy them, then try to access components — should get validation errors\n2. Attempt to access `Position` component as `Velocity` type — should get type mismatch error  \n3. Create a system that throws exceptions — verify other systems continue running\n4. Check log files contain detailed error context for debugging\n\n**Signs of Problems:**\n- Crashes instead of graceful error handling indicate missing exception handling\n- Silent failures without error logs suggest validation isn't being called\n- Systems not recovering after errors indicates circuit breaker logic bugs\n- Performance too slow in debug builds means validation is too expensive\n\n\n## Testing Strategy\n\n> **Milestone(s):** Milestones 1-4 — comprehensive testing approaches for each milestone including unit tests for components, integration tests for system interactions, and performance benchmarks\n\nTesting an ECS architecture presents unique challenges compared to traditional object-oriented systems. The separation of data (components) from logic (systems) means we must verify not only individual component behavior but also the complex interactions between entities, components, and systems across multiple execution frames. Our testing strategy must validate both correctness and performance characteristics, ensuring that our cache-friendly data structures actually deliver the promised performance benefits while maintaining data integrity throughout entity lifecycles.\n\n### Mental Model: Quality Control in a Manufacturing Pipeline\n\nThink of ECS testing like quality control in a modern manufacturing facility. Just as a factory has quality checkpoints at each station (individual component testing), integration tests between stations (system interaction testing), and performance benchmarks for the entire production line (end-to-end performance testing), our ECS testing strategy operates at multiple levels. Each milestone represents a manufacturing station that must pass quality checks before the next station can rely on its output. The assembly line (system execution) must maintain throughput targets while producing correct results, and any performance degradation or correctness failure at one station affects the entire production line.\n\nThe key insight is that ECS testing must verify both the **structural integrity** of our data-oriented design (are components stored correctly, are entity relationships maintained) and the **behavioral correctness** of our logic systems (do systems process entities correctly, do component modifications propagate properly). Unlike testing traditional object hierarchies where each object encapsulates both data and behavior, ECS testing must verify the coordination between separate data storage and logic execution components.\n\n### Milestone Checkpoint Testing\n\nEach milestone builds upon the previous one, creating a dependency chain where later milestones rely heavily on earlier components functioning correctly. Our checkpoint testing strategy validates both the immediate functionality delivered by each milestone and its integration with previously completed milestones. This approach catches integration issues early and provides confidence that complex interactions will work correctly when all milestones are combined.\n\n#### Milestone 1: Entity Manager Checkpoint\n\nThe Entity Manager checkpoint testing focuses on validating entity lifecycle management, generation counter behavior, and ID recycling mechanisms. Since all other milestones depend on reliable entity management, these tests must be comprehensive and cover edge cases thoroughly.\n\n| Test Category | Test Name | Expected Behavior | Validation Method |\n|---------------|-----------|-------------------|-------------------|\n| ID Generation | `testEntityCreation` | Each call to `createEntity()` returns unique `EntityID` | Assert no duplicate IDs in 10,000 entity batch |\n| Generation Counter | `testGenerationIncrement` | Destroying and recreating entity increments generation | Create entity, destroy, recreate - verify generation+1 |\n| ID Recycling | `testIDRecycling` | Destroyed entity IDs are reused for new entities | Destroy entity with ID 100, create new - should get ID 100 |\n| Stale Reference Prevention | `testStaleEntityDetection` | `isAlive()` returns false for destroyed entities | Create entity, store reference, destroy, verify `isAlive()` false |\n| Free List Management | `testFreeListBounds` | Free list respects `MAX_FREE_LIST_SIZE` limit | Destroy entities exceeding limit, verify oldest IDs permanently retired |\n| Alive Entity Tracking | `testAliveEntityCount` | `getAliveEntityCount()` matches actual living entities | Create/destroy entities, verify count accuracy throughout |\n| Entity Iteration | `testEntityIteration` | `getAllEntities()` returns only alive entities | Create mixed alive/dead entities, verify iteration skips dead |\n| Overflow Handling | `testGenerationOverflow` | Generation counter handles overflow gracefully | Force generation to maximum value, verify safe behavior |\n\nThe critical checkpoint verification involves running a stress test that creates 100,000 entities, destroys 50,000 in random order, creates another 25,000, and verifies that all entity operations maintain consistency. This test should complete in under 100 milliseconds and produce no duplicate entity IDs or false positive `isAlive()` results.\n\n**Checkpoint Command**: Run `./test_entity_manager --stress` and verify output shows \"All 175,000 entity operations completed successfully, 75,000 entities alive, 0 duplicate IDs detected, 0 stale references accessible.\"\n\n#### Milestone 2: Component Storage Checkpoint\n\nComponent storage testing must validate cache-friendly storage patterns, sparse set operations, and type-safe component access. The tests verify both correctness and performance characteristics of our data-oriented storage approach.\n\n| Test Category | Test Name | Expected Behavior | Validation Method |\n|---------------|-----------|-------------------|-------------------|\n| Sparse Set Operations | `testSparseSetInsertRemove` | `insert()` and `remove()` maintain bidirectional mapping | Insert components, verify both dense and sparse arrays consistent |\n| Cache Locality | `testContiguousStorage` | Component data stored in contiguous memory blocks | Verify address arithmetic between consecutive components |\n| Type Safety | `testComponentTypeVerification` | Wrong type access throws `ComponentTypeException` | Attempt to access `Position` as `Velocity`, verify exception |\n| Swap-Remove Semantics | `testSwapRemoveBehavior` | Component removal swaps last element to fill gap | Remove middle component, verify last component moved to gap |\n| Entity-Component Mapping | `testEntityComponentLookup` | `hasComponent()` and `getComponent()` consistent | Add components to entities, verify lookup operations match |\n| Iterator Stability | `testIteratorInvalidation` | Component modification invalidates active iterators | Modify components during iteration, verify safe failure |\n| Memory Efficiency | `testMemoryFootprint` | Storage overhead stays within acceptable bounds | Measure memory usage with 10,000 components, verify <5% overhead |\n| Type Registry | `testComponentTypeRegistry` | Multiple component types coexist correctly | Register `Position`, `Velocity`, `Health`, verify independent storage |\n\nThe performance aspect of component storage testing involves measuring memory access patterns using cache miss counters. Our benchmark creates 10,000 entities with `Position` components, then iterates through all positions calculating distances. This operation should complete in under 1 millisecond with fewer than 100 cache misses, demonstrating effective cache locality.\n\n**Checkpoint Command**: Run `./test_component_storage --benchmark` and verify output shows \"10,000 component iteration completed in <1ms, cache miss ratio <1%, memory overhead 3.2%.\"\n\n#### Milestone 3: System Interface Checkpoint\n\nSystem interface testing focuses on component queries, system execution ordering, and the interaction between systems and component storage. These tests must verify that systems can reliably find and process entities with specific component combinations.\n\n| Test Category | Test Name | Expected Behavior | Validation Method |\n|---------------|-----------|-------------------|-------------------|\n| Component Queries | `testQueryEntitySelection` | Query finds all entities matching component requirements | Create entities with different components, verify query results |\n| Query Iterator | `testQueryIteratorBehavior` | Iterator provides type-safe access to entity components | Use `query<Position, Velocity>()`, verify tuple access works |\n| System Registration | `testSystemRegistration` | Systems register with priority and execute in order | Register systems with priorities 100, 300, 200 - verify execution order 100, 200, 300 |\n| System Execution | `testSystemUpdateCycle` | `updateAllSystems()` calls `update()` on all enabled systems | Register systems, call update cycle, verify all systems received update |\n| Delta Time Passing | `testDeltaTimeDistribution` | Systems receive correct delta time parameter | Pass 0.016f delta time, verify all systems received same value |\n| System Enabling/Disabling | `testSystemToggling` | Disabled systems don't execute during update cycle | Disable system, run update cycle, verify system didn't execute |\n| Dependency Ordering | `testSystemDependencies` | Systems with dependencies execute in correct order | Physics system depends on input - verify input executes first |\n| Query Result Consistency | `testQueryConsistency` | Multiple queries for same components return same entities | Run identical queries consecutively, verify entity sets match |\n\nSystem interface checkpoint testing includes a complex scenario where multiple systems modify entity components during the same frame. We create entities with `Position`, `Velocity`, and `Health` components, then run physics, damage, and rendering systems that each modify different component types. The test verifies that all component modifications are visible to subsequent systems in the same frame.\n\n**Checkpoint Command**: Run `./test_system_interface --integration` and verify output shows \"3 systems executed successfully, 1000 entities processed, component modifications correctly propagated between systems.\"\n\n#### Milestone 4: Archetype Storage Checkpoint\n\nArchetype storage testing validates entity grouping by component combination, archetype transitions when components are added or removed, and cache-efficient iteration within archetypes. This advanced milestone requires sophisticated testing to verify the complex data movement operations.\n\n| Test Category | Test Name | Expected Behavior | Validation Method |\n|---------------|-----------|-------------------|-------------------|\n| Archetype Identification | `testArchetypeCreation` | Entities with same components grouped into same archetype | Create entities with identical components, verify same `ArchetypeInfo` |\n| Archetype Transitions | `testComponentAddRemoveTransition` | Adding/removing components moves entities between archetypes | Add component to entity, verify moved to new archetype |\n| Chunk-Based Storage | `testChunkAllocation` | Entities within archetypes stored in fixed-size chunks | Verify chunk boundaries at `CHUNK_SIZE` intervals |\n| Cache-Friendly Iteration | `testArchetypeIteration` | Iterating archetype accesses contiguous memory | Measure cache misses during archetype iteration |\n| Archetype Query Matching | `testArchetypeQueryOptimization` | Queries efficiently find matching archetypes | Query should examine only archetypes containing required components |\n| Entity Movement | `testEntityArchetypeMovement` | Entity component data preserved during archetype transitions | Verify component values unchanged after archetype transition |\n| Chunk Compaction | `testChunkGarbageCollection` | Removing entities compacts chunks efficiently | Remove entities, verify no gaps in chunk storage |\n| Archetype Graph | `testArchetypeGraph` | Archetype transitions form valid directed graph | Verify archetype relationships form acyclic graph |\n\nArchetype storage checkpoint testing involves a stress scenario where entities rapidly add and remove components, causing frequent archetype transitions. The test creates 1,000 entities, performs 10,000 component additions and removals, and verifies that all entity data remains consistent throughout the transitions while maintaining cache-friendly storage patterns.\n\n**Checkpoint Command**: Run `./test_archetype_storage --transitions` and verify output shows \"10,000 archetype transitions completed successfully, 0 data corruption detected, average transition time <0.001ms.\"\n\n### Performance Benchmarking\n\nPerformance benchmarking validates that our ECS implementation delivers the promised benefits of data-oriented design. The benchmarks measure cache efficiency, iteration performance, and memory usage patterns under realistic game development scenarios. Our benchmarking strategy compares ECS performance against traditional object-oriented approaches and establishes baseline performance expectations for each milestone.\n\n#### Cache Miss Measurement Strategy\n\nCache efficiency forms the core benefit of ECS architecture, so measuring cache behavior accurately is critical. We use hardware performance counters to measure L1, L2, and L3 cache misses during component iteration operations. The benchmarks create scenarios that should demonstrate clear cache efficiency advantages over scattered object-oriented data layouts.\n\n| Benchmark Name | Scenario | Expected Cache Performance | Measurement Method |\n|----------------|----------|----------------------------|-------------------|\n| `benchComponentIteration` | Iterate 10,000 Position components | <1% L1 cache miss ratio | Hardware performance counters via `perf` |\n| `benchMultiComponentQuery` | Query Position+Velocity on 10,000 entities | <2% L2 cache miss ratio | Memory access pattern analysis |\n| `benchArchetypeIteration` | Iterate entities within single archetype | <0.5% L3 cache miss ratio | Cache miss profiling tools |\n| `benchRandomAccess` | Random entity component access pattern | Cache misses scale with entity count | Statistical cache behavior analysis |\n| `benchSystemExecution` | Full system update cycle with 5 systems | Cache miss ratio stable across frames | Frame-to-frame cache consistency |\n\nThe cache miss benchmarks run on systems with known cache hierarchy characteristics. We establish baseline measurements by running equivalent operations on traditional object-oriented entity implementations, then compare ECS performance. The ECS implementation should show 5-10x fewer cache misses for iteration-heavy operations.\n\n#### Iteration Speed Comparisons\n\nComponent iteration speed directly impacts frame rate performance in real games. Our iteration benchmarks measure throughput for various component access patterns and entity counts, establishing performance scaling characteristics as entity populations grow.\n\n| Benchmark Name | Operation | Entity Count | Expected Throughput | Performance Target |\n|----------------|-----------|--------------|--------------------|--------------------|\n| `benchSingleComponentIteration` | Process all Position components | 100,000 | >50M components/second | Linear scaling with entity count |\n| `benchDualComponentIteration` | Process Position+Velocity pairs | 100,000 | >25M pairs/second | Sparse set intersection overhead |\n| `benchTripleComponentIteration` | Process Position+Velocity+Health | 100,000 | >15M triplets/second | Multiple sparse set intersection |\n| `benchArchetypeOptimizedIteration` | Same operation using archetypes | 100,000 | >40M triplets/second | Archetype optimization advantage |\n| `benchSystemUpdateBenchmark` | Complete physics system update | 100,000 | >10M updates/second | Realistic system performance |\n\nIteration speed benchmarks measure both raw component access speed and realistic system processing rates. The benchmarks include representative mathematical operations (vector math, collision detection, state updates) to simulate real game system workloads. Performance scaling should remain linear or near-linear as entity counts increase, demonstrating that our data-oriented approach avoids performance cliffs.\n\n#### Memory Usage Analysis\n\nMemory efficiency affects both performance and scalability. Our memory benchmarks measure storage overhead, fragmentation characteristics, and memory access patterns under various entity and component configurations.\n\n| Benchmark Name | Memory Aspect | Measurement | Efficiency Target |\n|----------------|---------------|-------------|-------------------|\n| `benchComponentStorageOverhead` | Storage overhead vs raw data size | Bytes used / bytes of component data | <10% overhead |\n| `benchSparseSetMemoryEfficiency` | Sparse set memory usage vs entity count | Memory growth rate as entities increase | Linear growth with small constant |\n| `benchArchetypeMemoryLayout` | Archetype chunk utilization | Percentage of allocated chunks actively used | >80% utilization |\n| `benchMemoryFragmentation` | Heap fragmentation after entity churn | Free memory block distribution | Minimal fragmentation |\n| `benchMemoryLocality` | Component data locality within caches | Memory addresses of consecutive components | Contiguous address ranges |\n\nMemory analysis includes measuring the impact of entity creation and destruction patterns on heap fragmentation. We simulate realistic game scenarios where entities are created and destroyed frequently, measuring whether our ID recycling and component storage strategies maintain efficient memory usage over extended runtime periods.\n\n#### Performance Regression Detection\n\nPerformance benchmarks establish baseline performance characteristics that must be maintained as the codebase evolves. Our regression detection compares current performance against established baselines, alerting developers when changes negatively impact performance.\n\n> **Critical Performance Baselines**\n> - Single component iteration: >50M components/second on reference hardware\n> - Cache miss ratio for contiguous iteration: <1% L1 misses\n> - Memory overhead for component storage: <10% of raw component data\n> - System execution performance: >10M entity updates/second for simple systems\n> - Archetype transition time: <0.001ms average per entity movement\n\nPerformance regression testing runs automatically as part of the build process, comparing current benchmark results against stored baseline values. Regressions exceeding 10% performance degradation require explicit acknowledgment and rationale before code changes are accepted.\n\n### Correctness Verification\n\nCorrectness verification ensures that our ECS implementation maintains data integrity and behavioral consistency throughout entity lifecycles, component modifications, and system executions. Unlike performance benchmarks that measure speed, correctness tests verify that operations produce expected results and handle edge cases safely.\n\n#### Entity Lifecycle Consistency\n\nEntity lifecycle testing verifies that entity creation, modification, and destruction maintain consistent state throughout the ECS system. These tests check that entity references remain valid when they should be and become invalid when entities are destroyed.\n\n| Test Category | Correctness Property | Verification Method | Expected Outcome |\n|---------------|---------------------|---------------------|------------------|\n| Entity Creation Uniqueness | No duplicate entity IDs generated during runtime | Create 1M entities, verify all IDs unique | Zero duplicate IDs detected |\n| Generation Counter Monotonicity | Generation counters increase monotonically per ID | Track generation progression for recycled IDs | Generations always increase |\n| Stale Reference Detection | Destroyed entities not accessible via old references | Store entity references, destroy entities, attempt access | All access attempts fail safely |\n| Component Consistency | Entity components remain consistent during lifecycle | Add components, verify persistence across operations | Components maintain values |\n| Iteration Stability | Entity iteration doesn't include destroyed entities | Destroy entities during iteration, verify results | Destroyed entities excluded |\n\nEntity lifecycle correctness testing includes stress scenarios where entities are created and destroyed rapidly while other operations (component access, system updates) are running concurrently. The tests verify that the system maintains consistency even under high-frequency entity churn.\n\n#### Component Data Integrity\n\nComponent data integrity testing ensures that component values are preserved correctly and that component operations (add, remove, modify) don't corrupt related data or create inconsistent state.\n\n| Test Category | Integrity Property | Verification Method | Expected Outcome |\n|---------------|-------------------|---------------------|------------------|\n| Component Value Preservation | Component values unchanged by unrelated operations | Store component values, perform unrelated operations, verify values | All values preserved exactly |\n| Sparse Set Bidirectional Consistency | Dense and sparse arrays remain synchronized | Verify sparse[dense[i]] == i for all valid indices | Perfect bidirectional mapping |\n| Type Safety Enforcement | Wrong type access detected and prevented | Attempt cross-type component access, verify rejection | All incorrect access attempts blocked |\n| Memory Corruption Prevention | Component operations don't corrupt adjacent memory | Add/remove components, verify adjacent data unchanged | No corruption detected |\n| Component Attachment Consistency | hasComponent() matches actual component presence | Check component existence vs actual storage state | Perfect consistency |\n\nComponent integrity testing focuses on the swap-remove operations used by sparse sets, verifying that moving components to fill gaps doesn't corrupt data or create inconsistent index mappings. The tests include scenarios where components are added and removed in various orders, ensuring that storage remains consistent regardless of operation sequence.\n\n#### System Execution Correctness\n\nSystem execution correctness verifies that systems process entities correctly, that component modifications are applied properly, and that system interactions produce expected results across multiple execution frames.\n\n| Test Category | Execution Property | Verification Method | Expected Outcome |\n|---------------|-------------------|---------------------|------------------|\n| System Execution Order | Systems execute in priority order each frame | Register systems with known priorities, verify execution sequence | Strict priority ordering maintained |\n| Component Query Accuracy | Queries return exactly entities matching requirements | Create entities with known components, verify query results | Perfect query accuracy |\n| Component Modification Visibility | System modifications visible to subsequent systems | Modify components in one system, verify visibility in next | All modifications visible |\n| Delta Time Distribution | All systems receive identical delta time values | Pass delta time to system manager, verify all systems get same value | Identical delta time across systems |\n| System State Isolation | System failures don't affect other system execution | Force system to throw exception, verify other systems continue | System isolation maintained |\n\nSystem execution correctness includes testing complex multi-frame scenarios where entities and components are modified across multiple update cycles. The tests verify that system execution produces deterministic results and that the same input consistently produces the same output.\n\n#### Edge Case Handling Verification\n\nEdge case testing validates system behavior under unusual or extreme conditions, ensuring that the ECS implementation handles corner cases gracefully without crashing or corrupting data.\n\n| Edge Case Category | Scenario | Expected Behavior | Verification Method |\n|-------------------|----------|-------------------|---------------------|\n| Empty Entity Operations | Operations on entities with no components | Operations succeed or fail safely | No crashes or corruption |\n| Maximum Entity Count | Creating entities until ID space exhausted | Graceful failure when IDs exhausted | Safe failure mode activated |\n| Component Type Overflow | Registering more component types than supported | Registration fails safely after limit | `MAX_COMPONENTS` limit enforced |\n| System Exception Handling | System throws exception during update | Exception contained, other systems continue | System isolation verified |\n| Concurrent Access Safety | Multiple operations on same entity simultaneously | Operations complete safely or fail cleanly | No data races or corruption |\n\nEdge case verification includes fuzz testing where random sequences of valid operations are applied to the ECS system, verifying that no combination of legal operations can cause crashes or data corruption. The tests run for extended periods to catch rare race conditions or state inconsistencies.\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option | Rationale |\n|-----------|---------------|-----------------|-----------|\n| Test Framework | Google Test (C++) | Catch2 with BDD extensions | Google Test provides comprehensive assertion macros and death tests for ECS |\n| Performance Profiling | `std::chrono` + manual instrumentation | Intel VTune or perf with hardware counters | Hardware counters essential for accurate cache miss measurement |\n| Memory Analysis | Valgrind memcheck | AddressSanitizer + heap profiling | AddressSanitizer catches more subtle memory errors in ECS sparse sets |\n| Build Integration | Manual test execution | CMake CTest + CI/CD pipeline | Automated execution prevents performance regression |\n\n#### Recommended File Structure\n\n```\necs-project/\n├── tests/\n│   ├── unit/\n│   │   ├── entity_manager_test.cpp     ← Milestone 1 unit tests\n│   │   ├── component_storage_test.cpp  ← Milestone 2 unit tests  \n│   │   ├── system_interface_test.cpp   ← Milestone 3 unit tests\n│   │   └── archetype_storage_test.cpp  ← Milestone 4 unit tests\n│   ├── integration/\n│   │   ├── ecs_integration_test.cpp    ← Cross-component integration tests\n│   │   └── game_scenario_test.cpp      ← Realistic game scenarios\n│   ├── benchmarks/\n│   │   ├── performance_benchmarks.cpp ← Cache and speed benchmarks\n│   │   ├── memory_benchmarks.cpp      ← Memory usage analysis\n│   │   └── regression_tests.cpp       ← Performance regression detection\n│   └── test_utils/\n│       ├── test_components.h          ← Position, Velocity, Health components\n│       ├── mock_systems.h             ← Test system implementations\n│       └── performance_counters.h     ← Hardware counter utilities\n├── src/\n│   └── ecs/                           ← ECS implementation files\n└── tools/\n    ├── benchmark_runner.cpp           ← Performance measurement tool\n    └── cache_analyzer.cpp             ← Cache miss analysis tool\n```\n\n#### Test Infrastructure Starter Code\n\nComplete test infrastructure for ECS components that handles the complexities of entity lifecycle and component management:\n\n```cpp\n// tests/test_utils/test_components.h - Standard test components\n#pragma once\n#include <cmath>\n\nstruct Position {\n    float x = 0.0f;\n    float y = 0.0f;\n    \n    bool operator==(const Position& other) const {\n        return std::abs(x - other.x) < 0.001f && std::abs(y - other.y) < 0.001f;\n    }\n};\n\nstruct Velocity {\n    float dx = 0.0f;\n    float dy = 0.0f;\n    \n    bool operator==(const Velocity& other) const {\n        return std::abs(dx - other.dx) < 0.001f && std::abs(dy - other.dy) < 0.001f;\n    }\n};\n\nstruct Health {\n    int current = 100;\n    int maximum = 100;\n    \n    bool operator==(const Health& other) const {\n        return current == other.current && maximum == other.maximum;\n    }\n};\n\n// tests/test_utils/mock_systems.h - Test system implementations\n#pragma once\n#include \"ecs/system_interface.h\"\n\nclass MovementSystem : public System {\npublic:\n    MovementSystem() : System(\"MovementSystem\", PRIORITY_PHYSICS) {}\n    \n    void update(World& world, float deltaTime) override {\n        auto query = world.query<Position, Velocity>();\n        for (auto [position, velocity] : query) {\n            position.x += velocity.dx * deltaTime;\n            position.y += velocity.dy * deltaTime;\n        }\n    }\n};\n\nclass HealthSystem : public System {\npublic:\n    int entitiesProcessed = 0;\n    \n    HealthSystem() : System(\"HealthSystem\", PRIORITY_LOGIC) {}\n    \n    void update(World& world, float deltaTime) override {\n        auto query = world.query<Health>();\n        for (auto [health] : query) {\n            if (health.current > 0) {\n                entitiesProcessed++;\n            }\n        }\n    }\n};\n\n// tests/test_utils/performance_counters.h - Hardware performance monitoring\n#pragma once\n#include <chrono>\n#include <fstream>\n#include <string>\n\nclass CacheMissCounter {\nprivate:\n    uint64_t l1_misses_start = 0;\n    uint64_t l2_misses_start = 0;\n    bool monitoring_active = false;\n    \npublic:\n    void startMonitoring() {\n        // Platform-specific performance counter initialization\n        monitoring_active = true;\n        l1_misses_start = readL1CacheMisses();\n        l2_misses_start = readL2CacheMisses();\n    }\n    \n    struct CacheStats {\n        uint64_t l1_misses;\n        uint64_t l2_misses;\n        double miss_ratio;\n    };\n    \n    CacheStats stopMonitoring() {\n        if (!monitoring_active) return {0, 0, 0.0};\n        \n        uint64_t l1_misses = readL1CacheMisses() - l1_misses_start;\n        uint64_t l2_misses = readL2CacheMisses() - l2_misses_start;\n        monitoring_active = false;\n        \n        return {l1_misses, l2_misses, calculateMissRatio(l1_misses, l2_misses)};\n    }\n    \nprivate:\n    uint64_t readL1CacheMisses() {\n        // Linux perf_event_open() or Windows performance counters\n        // Implementation depends on platform\n        return 0; // Placeholder - implement with actual hardware counters\n    }\n    \n    uint64_t readL2CacheMisses() {\n        // Platform-specific L2 cache miss counter reading\n        return 0; // Placeholder - implement with actual hardware counters  \n    }\n    \n    double calculateMissRatio(uint64_t l1_misses, uint64_t l2_misses) {\n        // Calculate cache miss percentage based on access patterns\n        return 0.0; // Placeholder - implement actual miss ratio calculation\n    }\n};\n```\n\n#### Core Test Skeleton Code\n\nTest skeletons for each milestone with detailed TODO comments mapping to verification requirements:\n\n```cpp\n// tests/unit/entity_manager_test.cpp - Milestone 1 testing\n#include <gtest/gtest.h>\n#include \"ecs/entity_manager.h\"\n#include <unordered_set>\n#include <vector>\n\nclass EntityManagerTest : public ::testing::Test {\nprotected:\n    EntityManager entity_manager;\n    \n    void SetUp() override {\n        // Reset entity manager state before each test\n    }\n};\n\nTEST_F(EntityManagerTest, UniqueEntityGeneration) {\n    // TODO 1: Create 10,000 entities and store their IDs\n    // TODO 2: Use std::unordered_set to detect duplicate IDs\n    // TODO 3: Assert that set size equals entity count (no duplicates)\n    // TODO 4: Verify all entities report isAlive() == true\n    // Expected: Zero duplicate IDs, all entities alive\n}\n\nTEST_F(EntityManagerTest, GenerationCounterProgression) {\n    // TODO 1: Create entity and store its ID and generation\n    // TODO 2: Destroy the entity using destroyEntity()\n    // TODO 3: Create another entity - should reuse ID with incremented generation\n    // TODO 4: Verify new entity has same ID but generation+1\n    // TODO 5: Verify old entity reference now returns isAlive() == false\n    // Expected: ID reused, generation incremented, stale reference detected\n}\n\nTEST_F(EntityManagerTest, FreeListManagement) {\n    // TODO 1: Create entities until free list reaches capacity\n    // TODO 2: Destroy more entities than MAX_FREE_LIST_SIZE\n    // TODO 3: Verify oldest destroyed IDs have PERMANENT_GENERATION\n    // TODO 4: Create new entities - verify recent destroys get recycled\n    // TODO 5: Verify permanently retired IDs never get reused\n    // Expected: Free list bounded, old IDs permanently retired\n}\n\n// tests/unit/component_storage_test.cpp - Milestone 2 testing\nTEST_F(ComponentStorageTest, SparseSetConsistency) {\n    ComponentStorage<Position> storage;\n    \n    // TODO 1: Insert Position components for entities 100, 200, 300\n    // TODO 2: Verify dense array contains exactly 3 elements\n    // TODO 3: For each entity, verify sparse[entityID] gives correct dense index\n    // TODO 4: For each dense index, verify entity_array[index] gives correct entity ID\n    // TODO 5: Remove entity 200, verify sparse set maintains bidirectional mapping\n    // Expected: Perfect bidirectional mapping maintained through all operations\n}\n\nTEST_F(ComponentStorageTest, CacheLocalityMeasurement) {\n    ComponentStorage<Position> storage;\n    CacheMissCounter counter;\n    \n    // TODO 1: Create 10,000 Position components with sequential entity IDs\n    // TODO 2: Start cache miss monitoring\n    // TODO 3: Iterate through all positions, performing simple calculation\n    // TODO 4: Stop monitoring and capture cache statistics\n    // TODO 5: Assert L1 cache miss ratio < 1%\n    // Expected: Cache-friendly iteration with minimal cache misses\n}\n\n// tests/integration/ecs_integration_test.cpp - Cross-milestone testing\nTEST_F(ECSIntegrationTest, CompleteGameFrameSimulation) {\n    World world;\n    \n    // TODO 1: Register MovementSystem and HealthSystem with priorities\n    // TODO 2: Create 1000 entities with Position, Velocity, Health components\n    // TODO 3: Run 60 frame updates with 16ms delta time each\n    // TODO 4: Verify all entities moved correctly (position += velocity * deltaTime * 60)\n    // TODO 5: Verify all systems executed in priority order each frame\n    // TODO 6: Verify component modifications visible between systems\n    // Expected: Realistic game simulation with correct physics and component updates\n}\n```\n\n#### Milestone Checkpoints\n\nEach milestone includes specific verification steps that prove the implementation meets acceptance criteria:\n\n**Milestone 1 Checkpoint**: \n```bash\n# Compile and run entity manager tests\ncd build && make test_entity_manager && ./test_entity_manager --gtest_filter=\"EntityManager*\"\n\n# Expected output:\n# [==========] Running 8 tests from 1 test suite.\n# [       OK ] EntityManagerTest.UniqueEntityGeneration (15 ms)\n# [       OK ] EntityManagerTest.GenerationCounterProgression (2 ms)  \n# [       OK ] EntityManagerTest.FreeListManagement (8 ms)\n# [==========] 8 tests from 1 test suite ran. (45 ms total)\n# [  PASSED  ] 8 tests.\n```\n\n**Milestone 2 Checkpoint**:\n```bash\n# Run component storage with cache analysis\n./test_component_storage --benchmark --cache_analysis\n\n# Expected output:\n# Component Storage Tests: PASSED\n# Cache Performance: L1 miss ratio 0.8%, L2 miss ratio 1.2%\n# Memory overhead: 4.1% of raw component data\n# Iteration speed: 52M components/second\n```\n\n**Milestone 3 Checkpoint**:\n```bash  \n# Run system integration tests\n./test_system_interface --integration --timing\n\n# Expected output:\n# System registration: 3 systems registered successfully\n# System execution order: InputSystem(100), PhysicsSystem(300), RenderSystem(500)\n# Frame update: 1000 entities processed in 0.8ms\n# Component queries: 100% accuracy across all query types\n```\n\n**Milestone 4 Checkpoint**:\n```bash\n# Run archetype optimization tests  \n./test_archetype_storage --performance --transitions\n\n# Expected output:\n# Archetype creation: 15 unique archetypes identified\n# Entity transitions: 10,000 transitions completed in 8ms\n# Cache performance: 40% improvement over sparse set iteration  \n# Memory utilization: 89% chunk utilization achieved\n```\n\n#### Performance Benchmark Infrastructure\n\nComplete benchmarking infrastructure for measuring and comparing ECS performance characteristics:\n\n```cpp\n// tests/benchmarks/performance_benchmarks.cpp\n#include <benchmark/benchmark.h>\n#include \"ecs/world.h\"\n#include \"test_utils/test_components.h\"\n#include \"test_utils/performance_counters.h\"\n\nstatic void BM_ComponentIteration(benchmark::State& state) {\n    World world;\n    \n    // Setup: Create entities with Position components\n    for (int i = 0; i < state.range(0); ++i) {\n        Entity entity = world.createEntity();\n        world.addComponent<Position>(entity, {static_cast<float>(i), static_cast<float>(i)});\n    }\n    \n    // Benchmark: Iterate through all positions\n    for (auto _ : state) {\n        float sum = 0.0f;\n        auto query = world.query<Position>();\n        for (auto [position] : query) {\n            sum += position.x + position.y;\n        }\n        benchmark::DoNotOptimize(sum);\n    }\n    \n    state.SetItemsProcessed(state.iterations() * state.range(0));\n    state.SetBytesProcessed(state.iterations() * state.range(0) * sizeof(Position));\n}\n\nBENCHMARK(BM_ComponentIteration)\n    ->Range(1000, 100000)\n    ->ReportAggregatesOnly(true)\n    ->MeasureProcessorTime();\n\nstatic void BM_SystemExecution(benchmark::State& state) {\n    World world;\n    world.registerSystem<MovementSystem>(PRIORITY_PHYSICS);\n    \n    // TODO 1: Create entities with Position and Velocity components\n    // TODO 2: Measure complete system update cycle time\n    // TODO 3: Report entities processed per second\n    // Expected: >10M entity updates/second for simple movement system\n}\n\nBENCHMARK(BM_SystemExecution)\n    ->Range(1000, 100000)\n    ->Unit(benchmark::kMicrosecond);\n\n```\n\n\n## Debugging Guide\n\n> **Milestone(s):** Milestones 1-4 — comprehensive debugging techniques for memory corruption, performance issues, and system logic problems encountered during ECS implementation\n\nDebugging an Entity-Component-System architecture presents unique challenges compared to traditional object-oriented game engines. The separation of data (components) from logic (systems) and the use of indirection through entity IDs creates new categories of bugs that developers must learn to recognize and diagnose. This guide provides systematic approaches for identifying and resolving the most common issues encountered during ECS development.\n\nThe debugging challenges in ECS fall into three primary categories. **Memory and corruption issues** arise from the complex pointer relationships between entities, components, and storage systems. **Performance problems** stem from cache inefficiencies that defeat the primary advantage of data-oriented design. **System logic errors** occur when the separation of concerns creates unexpected interactions between systems or invalid assumptions about component state.\n\nUnderstanding these debugging scenarios is crucial because ECS bugs often manifest differently than traditional object-oriented bugs. A null pointer dereference in object-oriented code typically points directly to the problematic object. In ECS, the same symptom might indicate a stale entity reference, component storage corruption, or system execution order dependencies that are several layers removed from the crash location.\n\n### Memory and Corruption Issues\n\nThink of debugging ECS memory issues like investigating a mail delivery system where letters (components) can be delivered to the wrong addresses (entities), postal workers (systems) might use outdated address books (stale references), or the sorting facility (component storage) might have internal organizational problems. Each type of delivery failure requires different diagnostic techniques to trace the root cause.\n\nMemory corruption in ECS systems typically manifests through four primary mechanisms: stale entity references, component storage corruption, iterator invalidation during system updates, and resource leaks during entity destruction. Each category requires specific diagnostic approaches because the symptoms often appear far from the actual bug location.\n\n**Stale Entity Reference Detection**\n\nStale entity references represent the most common and dangerous category of ECS memory bugs. These occur when code attempts to access an entity that has been destroyed, but the `Entity` reference still contains the old ID and generation values. The generation counter mechanism prevents most accesses to recycled entity IDs, but various edge cases can still cause problems.\n\nThe primary diagnostic approach involves implementing comprehensive entity validation at multiple levels. The `EntityValidator` provides configurable validation strategies that can be enabled during development and disabled for release builds:\n\n| Validation Level | Checks Performed | Performance Impact | Use Case |\n|-----------------|------------------|-------------------|----------|\n| `VALIDATION_NONE` | No validation | Zero overhead | Release builds |\n| `VALIDATION_BASIC` | Generation counter only | Minimal | Hot paths in debug builds |\n| `VALIDATION_STANDARD` | Generation + alive status | Low | Standard debug builds |\n| `VALIDATION_COMPREHENSIVE` | All validation + bounds checking | High | Deep debugging sessions |\n\nCommon stale reference scenarios include entities destroyed during system iteration, entities destroyed by one system and accessed by another in the same frame, and entities destroyed in callback functions triggered by component removal. The validation system catches these by maintaining detailed tracking of entity lifecycle events and cross-referencing access attempts against the current entity state.\n\n**Component Storage Corruption Diagnosis**\n\nComponent storage corruption occurs when the sparse set data structures become inconsistent, typically due to incorrect swap-remove operations, invalid index updates, or memory overwrites. These bugs are particularly insidious because they often cause crashes in unrelated code that happens to iterate over the corrupted storage.\n\nThe diagnostic approach involves implementing storage integrity checking that validates the bidirectional mapping between sparse and dense arrays. The integrity checker verifies that every entity ID in the sparse array correctly maps to a valid dense index, every dense index correctly maps back to the sparse array, and the entity count matches the actual number of stored components.\n\nStorage corruption often manifests through specific symptoms that point to different root causes:\n\n| Symptom | Likely Cause | Diagnostic Steps | Fix Strategy |\n|---------|--------------|------------------|--------------|\n| Random crashes during component iteration | Dense array corruption | Check dense array bounds and entity count consistency | Validate swap-remove operations |\n| `hasComponent` returns true but `getComponent` crashes | Sparse array pointing to invalid dense index | Verify sparse-to-dense mapping integrity | Fix index updates during component removal |\n| Components appear to belong to wrong entities | Entity ID corruption in dense storage | Compare expected vs actual entity IDs in dense array | Validate entity ID copying during storage operations |\n| Memory access violations during component destruction | Double-free or use-after-free | Track component destructor calls and memory ownership | Implement component lifecycle logging |\n\n**Iterator Invalidation Detection**\n\nIterator invalidation occurs when component storage is modified while systems are iterating over it. This is particularly problematic in ECS because systems often need to create or destroy entities based on the components they're processing. The deferred modification pattern addresses this by collecting changes during iteration and applying them afterward, but incorrect implementation can still cause problems.\n\nThe key diagnostic technique involves tracking iterator lifetimes and detecting storage modifications that occur while iterators are active. This requires maintaining a registry of active iterators and validating that no structural modifications occur to the underlying storage while iteration is in progress.\n\nIterator invalidation manifests through several patterns:\n\n1. **Immediate crashes** when the iterator accesses memory that has been reallocated or moved\n2. **Subtle data corruption** when the iterator continues to work but processes incorrect data\n3. **Infinite loops** when iterator advancement logic becomes confused by structural changes\n4. **Skipped entities** when removal operations shift array contents during iteration\n\n**Resource Leak Detection During Entity Destruction**\n\nEntity destruction in ECS involves coordinating cleanup across multiple component storage systems and ensuring that all references to the entity are properly invalidated. Resource leaks occur when this coordination fails, leaving dangling pointers, unclosed file handles, or unreleased memory allocations.\n\nThe diagnostic approach involves implementing comprehensive destruction logging that tracks every step of the entity cleanup process. This includes logging component destructor calls, entity ID recycling, callback invocations, and reference invalidation. The destruction audit trail allows debugging of incomplete cleanup sequences.\n\nCommon resource leak scenarios include:\n\n- **Component destructors not called** when component storage systems fail to properly destruct components during entity removal\n- **Callback systems holding stale references** when observer pattern implementations don't receive entity destruction notifications\n- **System-local caches containing stale data** when systems maintain their own entity collections that aren't updated during destruction\n- **Cross-component references** when components contain entity IDs that aren't properly invalidated during destruction\n\n### Performance Problem Diagnosis\n\nThink of ECS performance debugging like optimizing a factory assembly line where the goal is to keep all workers (CPU cores) busy processing parts (entities) that flow smoothly through stations (systems) without bottlenecks. Performance problems occur when parts pile up at certain stations, workers stand idle waiting for materials, or the conveyor belt moves parts in inefficient patterns that waste time.\n\nPerformance issues in ECS typically fall into three categories: cache inefficiency problems that reduce the benefits of data-oriented design, allocation hotspots that cause garbage collection pauses or memory fragmentation, and system execution bottlenecks that prevent parallel processing or create frame rate inconsistencies.\n\n**Cache Miss Analysis and Optimization**\n\nCache misses represent the most critical performance issue in ECS because the entire architecture is designed around achieving cache locality. When cache efficiency is poor, ECS can actually perform worse than traditional object-oriented approaches due to the additional indirection overhead.\n\nThe `CacheMissCounter` provides detailed metrics about memory access patterns during system execution:\n\n| Metric | Description | Target Value | Optimization Strategy |\n|--------|-------------|--------------|----------------------|\n| L1 Cache Miss Rate | Percentage of memory accesses that miss L1 cache | < 5% | Improve component layout and iteration patterns |\n| L2 Cache Miss Rate | Percentage of L1 misses that also miss L2 cache | < 15% | Reduce working set size and improve temporal locality |\n| Memory Bandwidth Utilization | Percentage of theoretical bandwidth used | > 60% | Optimize for sequential access patterns |\n| Cache Line Utilization | Average bytes used per cache line loaded | > 50% | Pack related data together, avoid padding |\n\nCache miss diagnosis involves profiling component access patterns during system execution and identifying where the data layout diverges from the access patterns. Common cache efficiency problems include:\n\n**Random access patterns** occur when systems process entities in orders that don't match the component storage layout. This is particularly problematic with sparse set storage where entity IDs might be processed in arbitrary order, causing the dense component arrays to be accessed randomly rather than sequentially.\n\n**Component size mismatches** happen when components are larger than optimal for their usage patterns, causing unnecessary data to be loaded into cache lines. For example, a `Position` component that includes rarely-used fields wastes cache bandwidth when systems only need the x and y coordinates.\n\n**Cross-system interference** occurs when multiple systems access different component types for the same entities, but the component storage layouts don't align. This causes each system to evict the cache lines loaded by previous systems, reducing overall cache efficiency.\n\n**Archetype fragmentation** in advanced ECS implementations can cause entities with identical component combinations to be stored in different archetypes, preventing efficient batch processing and reducing cache locality.\n\n**Allocation Hotspot Detection**\n\nMemory allocation during frame execution causes performance spikes due to heap management overhead and potential garbage collection pauses. ECS systems should ideally perform zero allocations during steady-state execution, but several common patterns can introduce allocation hotspots.\n\nThe allocation profiler tracks memory allocations during system execution and categorizes them by source:\n\n| Allocation Source | Common Causes | Detection Method | Mitigation Strategy |\n|------------------|---------------|------------------|-------------------|\n| Component storage growth | Adding components to full storage arrays | Track storage resize operations | Pre-allocate based on expected entity counts |\n| Entity creation/destruction | Dynamic entity management | Monitor entity lifecycle allocations | Use entity pools and deferred cleanup |\n| System temporary data | Algorithms requiring intermediate storage | Profile system-specific allocations | Pre-allocate scratch buffers |\n| Query result caching | Systems caching entity lists | Track query result memory usage | Use persistent query results with dirty tracking |\n\n**System Execution Bottleneck Analysis**\n\nSystem execution bottlenecks occur when individual systems take disproportionately long to execute, when system dependencies prevent parallel execution, or when systems interfere with each other's performance characteristics.\n\nThe system profiler provides detailed timing information for each system execution:\n\n```\nSystem Performance Report:\nMovementSystem: 2.3ms (45% of frame time)\n  - Entity iteration: 1.8ms\n  - Component updates: 0.4ms\n  - Collision detection: 0.1ms\nCollisionSystem: 1.1ms (22% of frame time)\n  - Spatial partitioning: 0.7ms\n  - Collision resolution: 0.4ms\nRenderSystem: 0.9ms (18% of frame time)\n  - Culling: 0.3ms\n  - Draw call submission: 0.6ms\n```\n\nSystem bottleneck diagnosis involves identifying whether performance problems are due to algorithmic complexity, data access patterns, or system interaction effects. The key metrics include:\n\n**System execution time distribution** shows which systems consume the most frame time and whether the distribution matches expected workload patterns. Systems that consume disproportionate time relative to their entity counts often have algorithmic or cache efficiency problems.\n\n**Component access patterns** reveal whether systems are accessing components in cache-friendly orders and whether multiple systems are interfering with each other's cache usage. Systems that show high cache miss rates despite processing many entities likely have data layout problems.\n\n**System dependency bottlenecks** occur when systems cannot execute in parallel due to component access conflicts or explicit dependency relationships. The dependency analyzer identifies the critical path through system execution and highlights opportunities for parallel execution.\n\n**Performance Regression Detection**\n\nPerformance regressions occur when code changes inadvertently reduce system performance, often in subtle ways that aren't immediately obvious during development. The regression detection system maintains performance baselines and alerts developers when system performance falls below expected thresholds.\n\nThe regression detector tracks key performance metrics across code changes:\n\n| Metric Category | Baseline Measurement | Regression Threshold | Alert Trigger |\n|-----------------|---------------------|---------------------|---------------|\n| Frame time | 95th percentile frame duration | 10% increase | Automatic test failure |\n| System timing | Individual system execution time | 15% increase | Performance warning |\n| Cache efficiency | Cache miss rate per system | 20% increase | Architecture review required |\n| Memory usage | Peak memory consumption | 25% increase | Memory audit required |\n\n### System Logic Debugging\n\nThink of system logic debugging like troubleshooting a complex factory where multiple specialized machines (systems) process parts (entities) that move through the facility. Problems arise when machines make incorrect assumptions about part specifications (component state), when the processing order creates dependencies that weren't anticipated, or when machines interfere with each other's work in unexpected ways.\n\nSystem logic errors in ECS are particularly challenging to debug because the separation of data and logic means that problems often manifest far from their root causes. A system might make a valid assumption about component state that becomes invalid due to the actions of a different system executed earlier in the frame.\n\n**Component State Inconsistency Tracking**\n\nComponent state inconsistencies occur when systems make assumptions about component values that don't hold due to the actions of other systems. These problems are subtle because each individual system operates correctly according to its local logic, but the global system behavior is incorrect.\n\nThe component state tracker monitors component modifications and validates that component values remain within expected ranges and relationships:\n\n| Validation Type | Description | Example Check | Debugging Information |\n|----------------|-------------|---------------|----------------------|\n| Range validation | Component values stay within valid ranges | Health values between 0 and maximum | Which system set invalid value and when |\n| Relationship consistency | Related components maintain valid relationships | Position and velocity vectors have reasonable magnitudes | Systems that modified related components |\n| State machine compliance | Component state transitions follow valid patterns | Animation states transition according to state machine | Invalid transition source and triggering system |\n| Cross-component invariants | Multi-component constraints are maintained | Transform hierarchy maintains parent-child relationships | Systems that broke invariant and affected entities |\n\nCommon state inconsistency patterns include:\n\n**Race conditions between systems** occur when multiple systems modify related components in the same frame without coordination. For example, a physics system might update position based on velocity while a control system simultaneously modifies velocity based on input, leading to inconsistent motion calculations.\n\n**Assumption violations** happen when systems make implicit assumptions about component state that become invalid due to other system actions. A rendering system might assume that entities with `Renderable` components always have valid `Transform` components, but an entity management system might remove transforms during destruction, causing render system crashes.\n\n**State machine violations** occur when systems modify component state in ways that violate implicit state machines. An animation system might assume that animation state transitions follow a specific pattern, but a game logic system might directly set animation states, causing invalid transitions.\n\n**System Execution Order Dependencies**\n\nSystem execution order dependencies are among the most difficult ECS bugs to debug because they involve subtle interactions between systems that might work correctly in isolation but fail when combined. These dependencies often emerge gradually as the codebase grows and new systems are added.\n\nThe dependency tracker analyzes component access patterns to identify potential execution order issues:\n\n| Dependency Type | Description | Detection Method | Resolution Strategy |\n|----------------|-------------|------------------|-------------------|\n| Read-after-write | System reads component modified by earlier system | Track component read/write operations | Ensure writing system executes first |\n| Write-after-read | System writes component read by earlier system | Analyze data flow between systems | Defer writes or reorder systems |\n| Write-after-write | Multiple systems modify same component | Detect conflicting component writes | Coordinate writes or establish ownership |\n| Circular dependencies | Systems have mutual dependencies | Build dependency graph and detect cycles | Break cycles through data flow redesign |\n\n**System execution order debugging** involves tracing the flow of component modifications through systems and identifying where assumptions about execution order become critical. The execution tracer logs component access operations and builds a dependency graph showing which systems depend on the results of other systems.\n\nExample dependency analysis output:\n```\nSystem Dependency Analysis:\nInputSystem (Priority 100):\n  - Writes: Velocity, PlayerInput\n  - Reads: (none)\n  - Dependencies: (none)\n\nMovementSystem (Priority 200):\n  - Writes: Position, Velocity\n  - Reads: Velocity, PlayerInput\n  - Dependencies: InputSystem (reads Velocity written by InputSystem)\n\nCollisionSystem (Priority 300):\n  - Writes: Position, Velocity, Health\n  - Reads: Position, Velocity, Collider\n  - Dependencies: MovementSystem (reads Position written by MovementSystem)\n\nRenderSystem (Priority 500):\n  - Writes: (none)\n  - Reads: Position, Renderable, Transform\n  - Dependencies: MovementSystem (reads Position), CollisionSystem (reads final Position)\n```\n\n**Component Modification During Iteration**\n\nComponent modification during iteration represents a classic ECS debugging challenge where systems need to modify component storage while iterating over entities. This can cause iterator invalidation, skipped entities, or infinite loops depending on the specific modification patterns.\n\nThe iteration safety checker monitors component storage modifications during system execution and detects potentially unsafe operations:\n\n| Unsafe Operation | Risk Level | Detection Method | Safe Alternative |\n|------------------|------------|------------------|------------------|\n| Add component during iteration | High | Track storage modifications during iteration | Use deferred component addition |\n| Remove component during iteration | High | Detect component removal during iteration | Use deferred component removal |\n| Destroy entity during iteration | Critical | Monitor entity destruction during iteration | Use deferred entity destruction |\n| Modify iterated component | Low | Check for component value changes | Direct modification is usually safe |\n\n**Deferred modification pattern debugging** involves ensuring that systems correctly collect modifications during iteration and apply them afterward. Common problems include forgetting to apply deferred modifications, applying them in the wrong order, or incorrectly handling entity references that become invalid during the deferred application phase.\n\n**System Communication and Event Handling**\n\nSystems often need to communicate with each other beyond simple component modifications. Event systems, message queues, and callback mechanisms introduce additional complexity that can create subtle bugs when systems make assumptions about when events will be processed or in what order messages will be received.\n\nThe event system debugger tracks message flow between systems and identifies potential communication issues:\n\n| Communication Issue | Symptoms | Diagnostic Approach | Prevention Strategy |\n|-------------------|----------|-------------------|-------------------|\n| Event ordering dependencies | Systems process events in wrong order | Log event processing timestamps | Use priority-based event queues |\n| Lost events | Systems don't receive expected events | Track event publication and subscription | Implement event delivery confirmation |\n| Event storms | Systems create excessive events | Monitor event generation rates | Implement event rate limiting |\n| Circular event chains | Events trigger other events indefinitely | Detect event processing cycles | Break cycles through event filtering |\n\n**System State Validation and Health Monitoring**\n\nComplex ECS applications benefit from comprehensive system health monitoring that can detect when systems enter invalid states or begin exhibiting abnormal behavior patterns. The system health monitor provides early warning of logic errors before they cause visible bugs or crashes.\n\nThe health monitoring system tracks various system health indicators:\n\n| Health Indicator | Normal Range | Warning Threshold | Critical Threshold |\n|-----------------|--------------|-------------------|-------------------|\n| Entities processed per frame | Stable or gradually changing | 50% sudden change | 80% sudden change |\n| Component modifications per frame | Proportional to entity count | 2x normal rate | 5x normal rate |\n| System execution time | Consistent within 20% | 50% increase | 100% increase |\n| Memory allocation rate | Near zero during steady state | >1MB per frame | >10MB per frame |\n\n### Implementation Guidance\n\nThe debugging infrastructure for an ECS requires careful balance between comprehensive error detection and runtime performance. Development builds should include extensive validation and logging systems that can be disabled in release builds to maintain performance.\n\n**A. Technology Recommendations**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Memory debugging | Manual validation checks with asserts | Valgrind/AddressSanitizer integration |\n| Performance profiling | Simple timing with high_resolution_clock | Intel VTune or custom sampling profiler |\n| Cache analysis | Manual cache miss counters | Hardware performance counter integration |\n| Allocation tracking | Custom allocation wrapper | Memory profiler with call stack traces |\n| System tracing | Printf-style logging | Structured logging with trace correlation |\n\n**B. Recommended File Structure**\n\n```\nproject-root/\n  src/\n    ecs/\n      core/\n        entity_manager.cpp\n        component_storage.cpp\n        system_manager.cpp\n      debugging/\n        entity_validator.cpp          ← entity reference validation\n        cache_profiler.cpp           ← cache miss analysis\n        allocation_tracker.cpp       ← memory allocation monitoring\n        system_debugger.cpp          ← system execution analysis\n        performance_monitor.cpp      ← comprehensive performance tracking\n      debugging/\n        debug_config.h               ← compile-time debug feature toggles\n        debug_macros.h               ← debug assertion and logging macros\n    tests/\n      integration/\n        debugging_integration_test.cpp  ← end-to-end debugging scenarios\n      performance/\n        cache_benchmark.cpp          ← cache efficiency benchmarks\n        allocation_benchmark.cpp     ← allocation performance tests\n```\n\n**C. Entity Validation Infrastructure**\n\nThe entity validation system provides the foundation for detecting stale entity references and ensuring entity lifecycle correctness:\n\n```cpp\n#include <unordered_map>\n#include <vector>\n#include <string>\n#include <chrono>\n\n// Complete entity validation infrastructure\nclass EntityValidator {\nprivate:\n    struct EntityInfo {\n        bool is_alive;\n        Generation generation;\n        std::chrono::steady_clock::time_point creation_time;\n        std::chrono::steady_clock::time_point destruction_time;\n        size_t access_count;\n    };\n    \n    std::unordered_map<EntityID, EntityInfo> entity_history_;\n    ValidationLevel current_level_;\n    \npublic:\n    EntityValidator(ValidationLevel level = VALIDATION_STANDARD) \n        : current_level_(level) {}\n    \n    void recordEntityCreation(Entity entity) {\n        if (current_level_ == VALIDATION_NONE) return;\n        \n        entity_history_[entity.id] = EntityInfo{\n            .is_alive = true,\n            .generation = entity.generation,\n            .creation_time = std::chrono::steady_clock::now(),\n            .destruction_time = {},\n            .access_count = 0\n        };\n    }\n    \n    void recordEntityDestruction(Entity entity) {\n        if (current_level_ == VALIDATION_NONE) return;\n        \n        auto it = entity_history_.find(entity.id);\n        if (it != entity_history_.end()) {\n            it->second.is_alive = false;\n            it->second.destruction_time = std::chrono::steady_clock::now();\n        }\n    }\n    \n    // Validation implementation left for learner\n    ValidationResult validateEntity(const EntityManager& manager, \n                                  Entity entity, ValidationLevel level);\n    \n    bool isValidQuick(const EntityManager& manager, Entity entity);\n    \n    std::vector<Entity> getStaleReferences() const;\n    void clearHistory();\n};\n\n// Cache miss monitoring infrastructure\nclass CacheMissCounter {\nprivate:\n    struct CacheStats {\n        size_t l1_misses = 0;\n        size_t l2_misses = 0;\n        size_t memory_accesses = 0;\n        size_t cache_lines_loaded = 0;\n        double miss_rate_l1 = 0.0;\n        double miss_rate_l2 = 0.0;\n    };\n    \n    CacheStats current_stats_;\n    bool monitoring_active_ = false;\n    \npublic:\n    void startMonitoring() {\n        // TODO: Initialize hardware performance counters or sampling\n        monitoring_active_ = true;\n        current_stats_ = {};\n    }\n    \n    CacheStats stopMonitoring() {\n        // TODO: Read hardware performance counters and calculate rates\n        monitoring_active_ = false;\n        return current_stats_;\n    }\n    \n    void recordMemoryAccess(void* address, size_t size);\n    void recordCacheLineMiss(void* cache_line_address);\n};\n```\n\n**D. System Debugging Core Logic**\n\nThe system debugging infrastructure tracks system execution and detects logic errors:\n\n```cpp\n// System execution tracer for dependency analysis\nclass SystemExecutionTracer {\nprivate:\n    struct ComponentAccess {\n        std::string system_name;\n        ComponentTypeID component_type;\n        EntityID entity_id;\n        bool is_write;\n        std::chrono::steady_clock::time_point timestamp;\n    };\n    \n    std::vector<ComponentAccess> access_log_;\n    bool tracing_enabled_ = false;\n    \npublic:\n    void startTracing() { \n        tracing_enabled_ = true; \n        access_log_.clear(); \n    }\n    \n    void stopTracing() { tracing_enabled_ = false; }\n    \n    void recordComponentAccess(const std::string& system_name,\n                             ComponentTypeID type_id,\n                             EntityID entity_id,\n                             bool is_write) {\n        // TODO 1: Check if tracing is enabled\n        // TODO 2: Create ComponentAccess record with current timestamp\n        // TODO 3: Add record to access_log_\n        // TODO 4: If log gets too large, remove oldest entries\n    }\n    \n    std::vector<std::string> analyzeDependencies() {\n        // TODO 1: Group access records by system name\n        // TODO 2: For each system, identify components it reads vs writes\n        // TODO 3: Find systems that read components written by other systems\n        // TODO 4: Build dependency graph and detect cycles\n        // TODO 5: Return list of dependency issues as human-readable strings\n    }\n    \n    void generateDependencyReport(std::ostream& output) {\n        // TODO 1: Analyze dependencies using analyzeDependencies()\n        // TODO 2: Format results as readable dependency graph\n        // TODO 3: Highlight potential execution order issues\n        // TODO 4: Suggest system priority adjustments\n    }\n};\n\n// Performance regression detector\nclass PerformanceMonitor {\nprivate:\n    struct SystemPerformanceData {\n        std::string system_name;\n        std::vector<float> execution_times;\n        float baseline_time = 0.0f;\n        float current_average = 0.0f;\n        size_t sample_count = 0;\n        bool performance_warning = false;\n    };\n    \n    std::unordered_map<std::string, SystemPerformanceData> system_performance_;\n    size_t max_samples_ = 100;\n    \npublic:\n    void recordSystemExecution(const std::string& system_name, float execution_time) {\n        // TODO 1: Find or create SystemPerformanceData for system\n        // TODO 2: Add execution_time to execution_times vector\n        // TODO 3: If vector exceeds max_samples_, remove oldest entry\n        // TODO 4: Recalculate current_average\n        // TODO 5: Check if current average exceeds baseline by threshold\n        // TODO 6: Set performance_warning flag if regression detected\n    }\n    \n    void establishBaseline(const std::string& system_name) {\n        // TODO 1: Calculate average of recent execution times\n        // TODO 2: Set as baseline_time for the system\n        // TODO 3: Clear performance_warning flag\n    }\n    \n    std::vector<std::string> getPerformanceWarnings() const {\n        // TODO 1: Iterate through all system performance data\n        // TODO 2: For systems with performance_warning = true\n        // TODO 3: Calculate regression percentage vs baseline\n        // TODO 4: Format warning message with specific numbers\n        // TODO 5: Return vector of warning strings\n    }\n};\n```\n\n**E. Language-Specific Debugging Tips**\n\nFor C++ ECS debugging:\n- Use `std::unique_ptr` with custom deleters to track component destruction\n- Enable AddressSanitizer with `-fsanitize=address` to catch memory errors\n- Use `std::chrono::high_resolution_clock` for precise system timing\n- Implement debug-only validation with `#ifdef DEBUG` preprocessor guards\n- Use `static_assert` to catch component size issues at compile time\n- Enable all compiler warnings with `-Wall -Wextra -Werror`\n\n**F. Milestone Checkpoints**\n\nAfter implementing entity validation (Milestone 1 checkpoint):\n- Run: `./debug_tests --entity-validation`\n- Expected: All entity lifecycle tests pass with validation enabled\n- Verify: Create 1000 entities, destroy half randomly, attempt access to destroyed entities should fail validation\n- Debug signs: If validation doesn't catch stale references, check generation counter updates during destruction\n\nAfter implementing cache profiling (Milestone 2 checkpoint):\n- Run: `./performance_tests --cache-analysis`\n- Expected: Cache miss rate < 10% for sequential component iteration\n- Verify: Profile system that processes 10000 entities with single component type\n- Debug signs: High cache miss rates indicate component storage layout problems\n\nAfter implementing system dependency analysis (Milestone 3 checkpoint):\n- Run: `./debug_tests --system-dependencies`\n- Expected: Dependency analysis correctly identifies read-after-write relationships\n- Verify: Create systems with intentional dependencies, analysis should detect execution order requirements\n- Debug signs: Circular dependencies or missed dependencies indicate incomplete access tracking\n\n**G. Common Debugging Scenarios**\n\n| Symptom | Likely Cause | Diagnosis Steps | Fix |\n|---------|--------------|-----------------|-----|\n| Random crashes during component access | Stale entity references | Enable comprehensive entity validation | Add generation counter checks |\n| System performance suddenly degrades | Cache efficiency regression | Profile cache miss rates before/after | Restore component layout optimizations |\n| Components appear to have wrong values | System execution order issue | Trace component read/write operations | Adjust system priorities |\n| Memory usage grows without bound | Resource leaks during entity destruction | Track allocations during entity lifecycle | Fix component destructor calls |\n| Systems skip entities during iteration | Iterator invalidation | Log storage modifications during iteration | Use deferred modification pattern |\n| Event systems create infinite loops | Circular event dependencies | Trace event publication and processing | Add event processing depth limits |\n\nThe debugging infrastructure should be designed as a development aid that can be completely disabled in release builds while providing comprehensive error detection during development. The key is to make debugging systematic rather than relying on intuition to find complex interaction bugs in the ECS architecture.\n\n### Implementation Guidance\n\n**A. Technology Recommendations**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Memory debugging | Manual validation checks with asserts | Valgrind/AddressSanitizer integration |\n| Performance profiling | Simple timing with `std::chrono` | Hardware performance counter APIs |\n| Cache analysis | Manual miss counters | Intel PCM or platform-specific profilers |\n| Allocation tracking | Custom `new`/`delete` wrappers | Heap profiler with call stack traces |\n| System tracing | File-based logging with timestamps | Real-time visualization dashboard |\n\n**B. Recommended File Structure**\n\n```cpp\nproject-root/\n  src/\n    ecs/\n      debugging/\n        entity_validator.h           ← Entity reference validation\n        entity_validator.cpp\n        cache_profiler.h             ← Cache miss analysis  \n        cache_profiler.cpp\n        allocation_tracker.h         ← Memory allocation monitoring\n        allocation_tracker.cpp\n        system_tracer.h              ← System execution analysis\n        system_tracer.cpp\n        performance_monitor.h        ← Performance regression detection\n        performance_monitor.cpp\n        debug_config.h               ← Compile-time debug toggles\n        debug_macros.h               ← Debug assertion macros\n    tests/\n      debugging/\n        validation_tests.cpp         ← Entity validation test cases\n        performance_tests.cpp        ← Performance regression tests\n        integration_debug_tests.cpp  ← End-to-end debugging scenarios\n```\n\n**C. Debug Infrastructure Starter Code**\n\nComplete entity validation system ready for use:\n\n```cpp\n// debug_config.h - Compile-time debug feature configuration\n#pragma once\n\n#ifdef DEBUG\n    #define ECS_ENABLE_VALIDATION 1\n    #define ECS_ENABLE_PERFORMANCE_MONITORING 1\n    #define ECS_ENABLE_ALLOCATION_TRACKING 1\n    #define ECS_ENABLE_SYSTEM_TRACING 1\n#else\n    #define ECS_ENABLE_VALIDATION 0\n    #define ECS_ENABLE_PERFORMANCE_MONITORING 0\n    #define ECS_ENABLE_ALLOCATION_TRACKING 0\n    #define ECS_ENABLE_SYSTEM_TRACING 0\n#endif\n\n// Maximum number of performance samples to keep per system\n#define ECS_MAX_PERFORMANCE_SAMPLES 1000\n\n// Maximum number of system trace events to keep\n#define ECS_MAX_TRACE_EVENTS 10000\n\n// Performance regression threshold (percentage)\n#define ECS_PERFORMANCE_REGRESSION_THRESHOLD 25.0f\n\n// debug_macros.h - Debug assertion and logging macros\n#pragma once\n#include <iostream>\n#include <cassert>\n\n#if ECS_ENABLE_VALIDATION\n    #define ECS_VALIDATE(condition, message) \\\n        do { \\\n            if (!(condition)) { \\\n                std::cerr << \"ECS Validation Failed: \" << message \\\n                         << \" at \" << __FILE__ << \":\" << __LINE__ << std::endl; \\\n                assert(false); \\\n            } \\\n        } while(0)\n        \n    #define ECS_DEBUG_LOG(message) \\\n        std::cout << \"[ECS DEBUG] \" << message << std::endl\n#else\n    #define ECS_VALIDATE(condition, message) ((void)0)\n    #define ECS_DEBUG_LOG(message) ((void)0)\n#endif\n\n// allocation_tracker.h - Complete memory allocation monitoring\n#pragma once\n#include <unordered_map>\n#include <vector>\n#include <string>\n#include <mutex>\n#include <chrono>\n\nstruct AllocationInfo {\n    size_t size;\n    std::string file;\n    int line;\n    std::chrono::steady_clock::time_point timestamp;\n};\n\nclass AllocationTracker {\nprivate:\n    std::unordered_map<void*, AllocationInfo> active_allocations_;\n    mutable std::mutex mutex_;\n    size_t total_allocated_ = 0;\n    size_t peak_allocated_ = 0;\n    size_t allocation_count_ = 0;\n    \npublic:\n    static AllocationTracker& getInstance() {\n        static AllocationTracker instance;\n        return instance;\n    }\n    \n    void recordAllocation(void* ptr, size_t size, \n                         const std::string& file, int line) {\n        std::lock_guard<std::mutex> lock(mutex_);\n        active_allocations_[ptr] = {size, file, line, \n                                   std::chrono::steady_clock::now()};\n        total_allocated_ += size;\n        peak_allocated_ = std::max(peak_allocated_, total_allocated_);\n        allocation_count_++;\n    }\n    \n    void recordDeallocation(void* ptr) {\n        std::lock_guard<std::mutex> lock(mutex_);\n        auto it = active_allocations_.find(ptr);\n        if (it != active_allocations_.end()) {\n            total_allocated_ -= it->second.size;\n            active_allocations_.erase(it);\n        }\n    }\n    \n    size_t getTotalAllocated() const {\n        std::lock_guard<std::mutex> lock(mutex_);\n        return total_allocated_;\n    }\n    \n    size_t getPeakAllocated() const {\n        std::lock_guard<std::mutex> lock(mutex_);\n        return peak_allocated_;\n    }\n    \n    std::vector<std::pair<void*, AllocationInfo>> getActiveAllocations() const {\n        std::lock_guard<std::mutex> lock(mutex_);\n        return std::vector<std::pair<void*, AllocationInfo>>(\n            active_allocations_.begin(), active_allocations_.end());\n    }\n    \n    void reset() {\n        std::lock_guard<std::mutex> lock(mutex_);\n        active_allocations_.clear();\n        total_allocated_ = 0;\n        peak_allocated_ = 0;\n        allocation_count_ = 0;\n    }\n};\n\n#if ECS_ENABLE_ALLOCATION_TRACKING\n    #define ECS_TRACK_ALLOC(ptr, size) \\\n        AllocationTracker::getInstance().recordAllocation(ptr, size, __FILE__, __LINE__)\n    #define ECS_TRACK_FREE(ptr) \\\n        AllocationTracker::getInstance().recordDeallocation(ptr)\n#else\n    #define ECS_TRACK_ALLOC(ptr, size) ((void)0)\n    #define ECS_TRACK_FREE(ptr) ((void)0)\n#endif\n```\n\n**D. Core Debugging Logic Skeleton**\n\nTemplate code for the main debugging components that learners should implement:\n\n```cpp\n// entity_validator.cpp - Core validation logic for implementation\n#include \"entity_validator.h\"\n#include \"debug_macros.h\"\n\nValidationResult EntityValidator::validateEntity(const EntityManager& manager,\n                                               Entity entity,\n                                               ValidationLevel level) {\n    ValidationResult result;\n    result.entity_id = entity.id;\n    result.expected_generation = entity.generation;\n    \n    // TODO 1: If level is VALIDATION_NONE, return valid result immediately\n    \n    // TODO 2: Check if entity ID is within valid range (not INVALID_ENTITY_ID)\n    // If invalid, set result.valid = false and appropriate error message\n    \n    // TODO 3: For VALIDATION_BASIC and above, verify generation counter\n    // Get actual generation from EntityManager and compare with expected\n    // If mismatch, set result.actual_generation and error message\n    \n    // TODO 4: For VALIDATION_STANDARD and above, check if entity is alive\n    // Use EntityManager::isAlive() to verify entity status\n    // If not alive, set appropriate error message\n    \n    // TODO 5: For VALIDATION_COMPREHENSIVE, perform additional checks\n    // - Verify entity ID hasn't been recycled inappropriately\n    // - Check entity access patterns for suspicious behavior\n    // - Validate entity is not in destruction queue\n    \n    return result;\n}\n\nbool EntityValidator::isValidQuick(const EntityManager& manager, Entity entity) {\n    // TODO 1: Fast path validation for hot code paths\n    // TODO 2: Check generation counter only (minimal overhead)\n    // TODO 3: Return true if entity appears valid, false otherwise\n    // This should be optimized for performance over comprehensive checking\n}\n\n// cache_profiler.cpp - Cache performance analysis implementation\n#include \"cache_profiler.h\"\n\nvoid CacheMissCounter::startMonitoring() {\n    // TODO 1: Initialize performance monitoring state\n    // TODO 2: Reset all counters to zero\n    // TODO 3: If using hardware performance counters, configure them\n    // TODO 4: Record start timestamp for rate calculations\n    // TODO 5: Set monitoring_active_ flag to true\n}\n\nCacheMissCounter::CacheStats CacheMissCounter::stopMonitoring() {\n    // TODO 1: Set monitoring_active_ flag to false\n    // TODO 2: If using hardware performance counters, read final values\n    // TODO 3: Calculate miss rates (misses / total accesses)\n    // TODO 4: Calculate cache line utilization statistics\n    // TODO 5: Return populated CacheStats structure\n}\n\nvoid CacheMissCounter::recordMemoryAccess(void* address, size_t size) {\n    if (!monitoring_active_) return;\n    \n    // TODO 1: Increment total memory access counter\n    // TODO 2: Calculate which cache lines are accessed based on address and size\n    // TODO 3: For each cache line, determine if it's likely a miss\n    // TODO 4: Update cache miss counters accordingly\n    // TODO 5: Track access patterns for locality analysis\n}\n\n// system_tracer.cpp - System execution dependency analysis\n#include \"system_tracer.h\"\n\nvoid SystemExecutionTracer::recordComponentAccess(const std::string& system_name,\n                                                ComponentTypeID type_id,\n                                                EntityID entity_id,\n                                                bool is_write) {\n    if (!tracing_enabled_) return;\n    \n    // TODO 1: Create ComponentAccess record with all parameters\n    // TODO 2: Set timestamp to current high-resolution time\n    // TODO 3: Add record to access_log_ vector\n    // TODO 4: If log exceeds maximum size, remove oldest entries\n    // TODO 5: Consider sampling if access rate is very high\n}\n\nstd::vector<std::string> SystemExecutionTracer::analyzeDependencies() {\n    std::vector<std::string> issues;\n    \n    // TODO 1: Group access records by system name and component type\n    // TODO 2: For each system, build lists of components read vs written\n    // TODO 3: Find cases where System A writes Component X and System B reads Component X\n    // TODO 4: Check execution order - if B executes before A, that's a dependency issue\n    // TODO 5: Look for circular dependencies (A->B->C->A)\n    // TODO 6: Format each issue as descriptive string and add to issues vector\n    \n    return issues;\n}\n\n// performance_monitor.cpp - Performance regression detection\n#include \"performance_monitor.h\"\n\nvoid PerformanceMonitor::recordSystemExecution(const std::string& system_name, \n                                              float execution_time) {\n    // TODO 1: Find or create SystemPerformanceData entry for system_name\n    // TODO 2: Add execution_time to the execution_times vector\n    // TODO 3: If vector size exceeds max_samples_, remove oldest entry (front)\n    // TODO 4: Recalculate current_average from all samples in vector\n    // TODO 5: If baseline exists, check if current_average exceeds threshold\n    // TODO 6: Set performance_warning flag if regression detected\n}\n\nvoid PerformanceMonitor::establishBaseline(const std::string& system_name) {\n    // TODO 1: Find SystemPerformanceData for system_name\n    // TODO 2: Calculate average of current execution_times vector\n    // TODO 3: Set this average as the baseline_time\n    // TODO 4: Clear performance_warning flag since we're establishing new baseline\n    // TODO 5: Log baseline establishment for debugging\n}\n\nstd::vector<std::string> PerformanceMonitor::getPerformanceWarnings() const {\n    std::vector<std::string> warnings;\n    \n    // TODO 1: Iterate through all entries in system_performance_\n    // TODO 2: For each system with performance_warning = true:\n    // TODO 3:   Calculate percentage regression vs baseline\n    // TODO 4:   Format warning message with system name and regression amount\n    // TODO 5:   Add formatted message to warnings vector\n    \n    return warnings;\n}\n```\n\n**E. Language-Specific Debugging Hints**\n\nFor C++ ECS debugging:\n- Use `gdb` with `set follow-fork-mode child` for multi-process debugging\n- Enable core dumps with `ulimit -c unlimited` for post-mortem analysis  \n- Use `std::source_location` (C++20) or `__FILE__/__LINE__` macros for error tracking\n- Compile with `-g -O0` for debug builds and `-DNDEBUG -O3` for release\n- Use `std::mutex` for thread-safe debugging in multi-threaded systems\n- Enable sanitizers: `-fsanitize=address,undefined,thread` during development\n\n**F. Milestone Debugging Checkpoints**\n\n**Milestone 1 (Entity Manager) - Entity Validation Testing:**\n- Run: `./ecs_tests --gtest_filter=\"*EntityValidation*\"`\n- Expected behavior: All entity lifecycle validation tests pass\n- Manual verification: Create entities, destroy them, attempt access - should fail validation\n- Debug signs: If stale references aren't caught, check generation counter implementation\n\n**Milestone 2 (Component Storage) - Cache Performance Testing:**\n- Run: `./performance_tests --cache-profiling --entity-count=50000`\n- Expected metrics: Cache miss rate < 15% for sequential iteration\n- Manual verification: Profile component iteration vs random access patterns\n- Debug signs: High miss rates indicate sparse set implementation issues\n\n**Milestone 3 (System Interface) - Dependency Analysis Testing:**\n- Run: `./ecs_tests --system-dependencies --verbose`\n- Expected output: Correct identification of read-after-write dependencies\n- Manual verification: Create systems with known dependencies, verify detection\n- Debug signs: Missed dependencies indicate incomplete component access tracking\n\n**Milestone 4 (Archetypes) - Archetype Performance Testing:**\n- Run: `./performance_tests --archetype-efficiency --archetype-count=20`\n- Expected metrics: 90%+ cache hit rate for archetype iteration\n- Manual verification: Compare archetype vs non-archetype iteration performance\n- Debug signs: Poor archetype performance suggests fragmentation or transition overhead\n\n**G. Debugging Tips Reference**\n\n| Problem Category | Symptom | Diagnostic Command | Investigation Steps |\n|-----------------|---------|-------------------|-------------------|\n| Memory corruption | Segfaults during component access | `valgrind --tool=memcheck ./app` | Check entity validation, sparse set integrity |\n| Performance regression | Frame time increased >20% | `./app --enable-profiling` | Compare cache miss rates, system execution times |\n| System logic errors | Components have unexpected values | `./app --trace-systems --verbose` | Analyze system dependencies, execution order |\n| Resource leaks | Memory usage grows continuously | `valgrind --tool=massif ./app` | Track entity destruction, component cleanup |\n| Cache efficiency issues | Low performance despite good algorithm | `perf stat -e cache-misses ./app` | Profile memory access patterns, component layout |\n\nThe debugging infrastructure should provide clear, actionable information when problems occur, helping developers quickly identify whether issues are in their application logic or in the ECS infrastructure itself. The key is making debugging systematic rather than requiring developers to guess at complex interaction patterns.\n\n\n## Future Extensions\n\n> **Milestone(s):** All Milestones — potential enhancements to extend the basic ECS implementation with advanced features including multi-threading, component relationships, event systems, and development tooling\n\nAfter completing the core ECS implementation across all four milestones, numerous opportunities exist to extend the architecture with advanced capabilities. These extensions transform the basic ECS from a functional game engine foundation into a production-ready, high-performance system suitable for complex applications. The extensions fall into three primary categories: performance enhancements through parallelization, advanced ECS features that handle complex entity relationships, and development tooling that improves the development experience.\n\nUnderstanding these extensions serves multiple purposes. First, it demonstrates the scalability and flexibility inherent in well-designed ECS architectures. Second, it provides concrete next steps for developers who want to push their implementation beyond the basics. Third, it illustrates real-world considerations that production game engines must address. Each extension builds upon the foundation established in the four core milestones while introducing new challenges and architectural considerations.\n\nThe mental model for these extensions is like **upgrading a factory production line**. The core ECS represents a functional assembly line where workers (systems) process products (entities) at individual stations (component operations). The extensions represent major infrastructure upgrades: installing conveyor belts that can run multiple products simultaneously (multi-threading), adding quality control stations that can react to production events (reactive systems), and implementing management dashboards that monitor the entire operation (development tooling).\n\n### Multi-Threading Extensions\n\nMulti-threading extensions represent the most significant performance enhancement possible for ECS architectures, potentially delivering massive throughput improvements for systems that can execute in parallel. However, multi-threading also introduces substantial complexity in terms of data synchronization, system dependencies, and debugging challenges.\n\n#### Mental Model: Parallel Assembly Lines\n\nThink of multi-threading ECS like **converting a single assembly line into multiple parallel production lines**. In the single-threaded version, one worker handles each station sequentially. With multi-threading, multiple workers can operate different stations simultaneously, as long as they don't interfere with each other's work. Some stations might require exclusive access to shared resources (like a single quality control checklist), while others can operate completely independently (like parallel packaging stations).\n\nThe key insight is that not all work can be parallelized effectively. Systems that read the same components can often run in parallel, but systems that write to shared components must be carefully coordinated. The challenge becomes scheduling work to maximize parallelism while preventing data races and maintaining correctness.\n\n> **Decision: Thread-Safe Component Access Strategy**\n> - **Context**: Multiple threads need to access component data simultaneously without corruption, but traditional locks would eliminate performance benefits\n> - **Options Considered**: \n>   1. Global ECS lock (simple but eliminates parallelism)\n>   2. Per-component-type locks (moderate complexity, decent parallelism)\n>   3. Read-write locks with dependency analysis (complex but maximum parallelism)\n> - **Decision**: Read-write locks with compile-time dependency analysis\n> - **Rationale**: Systems declare read/write component dependencies at compile-time, allowing automatic scheduling of compatible systems in parallel while serializing conflicting systems\n> - **Consequences**: Requires dependency declaration overhead but enables near-optimal parallel execution while maintaining safety\n\nThe thread-safe component access implementation involves several layers of coordination. At the lowest level, each `ComponentStorage` instance uses read-write locks to allow multiple readers or single writers. At the system level, each system declares its component dependencies through template parameters or runtime registration. The `SystemManager` analyzes these dependencies to build a dependency graph, identifying which systems can execute concurrently and which must be serialized.\n\n| Component Access Pattern | Thread Safety Approach | Performance Impact | Implementation Complexity |\n|---------------------------|------------------------|-------------------|-------------------------|\n| Multiple readers, no writers | Shared read locks | Excellent parallelism | Low - standard read-write locks |\n| Single writer, no readers | Exclusive write locks | Good parallelism | Low - exclusive access |\n| Mixed read-write patterns | Dependency-ordered execution | Moderate parallelism | High - requires scheduling |\n| Cross-system communication | Message passing queues | Variable | High - requires event systems |\n\nThe system dependency analysis creates execution phases where compatible systems run in parallel within each phase, but phases execute sequentially. For example, Phase 1 might include input processing and AI decision systems (both read-only), Phase 2 might include movement and collision systems (both write position/velocity), and Phase 3 might include rendering and audio systems (both read-only again).\n\n**Parallel System Execution Implementation**\n\nThe parallel execution framework builds upon the existing `SystemManager` with thread pool management and work stealing capabilities. The enhanced system uses a task-based approach where each system becomes a task that can be distributed across worker threads.\n\n| System Execution Component | Single-Threaded Version | Multi-Threaded Version | Additional Complexity |\n|----------------------------|-------------------------|------------------------|----------------------|\n| System Registration | Direct vector storage | Thread-safe registry with dependency metadata | Moderate - atomic operations |\n| Execution Scheduling | Simple priority order | Phase-based parallel batching | High - dependency resolution |\n| Component Access | Direct references | Lock-guarded access | High - deadlock prevention |\n| Error Handling | Immediate propagation | Cross-thread error collection | High - thread synchronization |\n\nThe execution flow involves several steps: dependency analysis creates execution phases, work stealing distributes systems across threads, barrier synchronization ensures phase completion before proceeding, and error collection aggregates failures across threads. This requires careful management of thread lifecycle, work distribution, and synchronization points.\n\n> The critical insight for parallel ECS execution is that cache locality often matters more than thread count. Running 100 systems on 8 cores with poor cache behavior performs worse than running 50 well-designed systems on 4 cores with good data locality.\n\n**Thread-Safe Component Storage**\n\nComponent storage modifications require careful attention to iterator safety and memory management. The existing sparse set implementation must be enhanced with atomic operations and careful ordering to prevent corruption during concurrent access.\n\n| Thread Safety Challenge | Detection Method | Prevention Strategy | Performance Cost |\n|-------------------------|------------------|-------------------|-----------------|\n| Iterator invalidation during modification | Debug mode validation | Deferred modification queues | Low - batched updates |\n| ABA problems in sparse arrays | Generation counters | Hazard pointers or epochs | Moderate - memory overhead |\n| Memory reallocation races | Address sanitizer tools | Pre-allocated growth strategy | Low - reduced allocations |\n| Component destruction races | Valgrind or similar | Reference counting | High - atomic operations |\n\nThe thread-safe sparse set implementation uses epoch-based memory reclamation to safely handle concurrent modifications. Threads announce their participation in operations through epoch advancement, and memory reclamation is deferred until all threads have progressed past the reclamation epoch. This eliminates the need for expensive per-access atomic operations while maintaining safety.\n\n**Work Stealing and Load Balancing**\n\nAdvanced multi-threading implementations incorporate work stealing to handle uneven system execution times. When one thread completes its assigned systems early, it can steal work from threads with remaining tasks, improving overall CPU utilization.\n\nThe work stealing implementation maintains per-thread work queues with systems initially distributed based on estimated execution cost. Threads that complete their work attempt to steal from other threads' queues using lock-free algorithms. This requires careful attention to data locality - stolen work should ideally access components that are already cached on the stealing thread.\n\n#### Common Multi-Threading Pitfalls\n\n⚠️ **Pitfall: Excessive Lock Contention**\nMany developers add locks around every component access, creating bottlenecks that eliminate parallelism benefits. This occurs because individual component accesses are extremely fast (nanoseconds), but lock acquisition overhead can be microseconds. Solution: Use batch operations and lock-free data structures where possible, and design systems to minimize shared data access.\n\n⚠️ **Pitfall: Cache Line False Sharing**\nWhen multiple threads write to different variables on the same cache line, performance degrades severely due to cache line bouncing between cores. This is especially problematic with component arrays where adjacent entities might be processed by different threads. Solution: Use thread-local processing with periodic synchronization, or ensure thread assignments respect cache line boundaries.\n\n⚠️ **Pitfall: Dependency Cycle Deadlocks**\nComplex dependency graphs can create circular dependencies that cause deadlocks during parallel execution. This typically manifests as systems waiting indefinitely for each other to release resources. Solution: Implement topological sorting of system dependencies and detect cycles during registration rather than execution.\n\n### Advanced ECS Features\n\nAdvanced ECS features extend the basic entity-component-system paradigm with sophisticated capabilities that handle complex game scenarios. These features address limitations of the basic model when dealing with hierarchical relationships, reactive behaviors, and complex entity interactions.\n\n#### Mental Model: Smart Factory with Automation\n\nThink of advanced ECS features like **upgrading a basic factory with intelligent automation systems**. The basic factory has workers performing tasks in sequence, but the advanced factory adds conveyor sensors that trigger actions when products pass by (event systems), assembly robots that can reconfigure themselves based on product requirements (reactive systems), and quality control systems that can modify production based on real-time feedback (component relationships).\n\nThese features transform the ECS from a passive data processing system into an active, responsive architecture that can react to changes, maintain relationships, and adapt behavior based on runtime conditions.\n\n**Hierarchical Entity Relationships**\n\nHierarchical relationships allow entities to form parent-child relationships, enabling complex composite objects like vehicles with wheels, characters with equipment, or UI panels with nested elements. This extends the flat entity model with tree-like structures while maintaining ECS performance characteristics.\n\n> **Decision: Hierarchy Implementation Strategy**\n> - **Context**: Need parent-child relationships for composite entities while maintaining ECS performance and avoiding deep object hierarchies\n> - **Options Considered**:\n>   1. Parent/Child component references (simple but limited queries)\n>   2. Dedicated hierarchy manager with tree operations (complex but full-featured)\n>   3. Hybrid approach with cached relationship queries (balanced complexity/performance)\n> - **Decision**: Hybrid approach with `Hierarchy` component and cached tree operations\n> - **Rationale**: Provides full tree operations when needed while maintaining fast iteration for systems that don't need hierarchy information\n> - **Consequences**: Adds moderate complexity but enables complex composite entities without performance penalties\n\nThe hierarchical implementation uses a `Hierarchy` component that stores parent/child relationships, combined with a `HierarchyManager` that maintains cached tree structures for efficient traversal operations.\n\n| Hierarchy Component | Field Name | Type | Description |\n|--------------------|------------|------|-------------|\n| `Hierarchy` | `parent` | `Entity` | Parent entity reference, `INVALID_ENTITY` if root |\n| `Hierarchy` | `firstChild` | `Entity` | First child in linked list, `INVALID_ENTITY` if leaf |\n| `Hierarchy` | `nextSibling` | `Entity` | Next sibling in parent's child list |\n| `Hierarchy` | `previousSibling` | `Entity` | Previous sibling for efficient removal |\n| `Hierarchy` | `childCount` | `uint32_t` | Number of direct children for fast iteration |\n\nThe `HierarchyManager` provides tree operations while maintaining performance through careful caching and batch updates.\n\n| Hierarchy Operation | Method Signature | Time Complexity | Use Case |\n|--------------------|-----------------|--------------|---------| \n| Parent Assignment | `setParent(Entity, Entity)` | O(1) | Attaching entities to parents |\n| Child Enumeration | `getChildren(Entity) -> vector<Entity>` | O(children) | Iterating child entities |\n| Ancestor Walking | `getAncestors(Entity) -> vector<Entity>` | O(depth) | Bubble-up operations |\n| Subtree Traversal | `traverseSubtree(Entity, callback)` | O(subtree) | Hierarchical updates |\n| Depth Calculation | `getDepth(Entity) -> uint32_t` | O(depth) | Level-based processing |\n\nHierarchical transformations represent a common use case where child entities inherit or modify their parent's transformation. The `HierarchicalTransformSystem` demonstrates how to efficiently process parent-child relationships while maintaining cache-friendly iteration patterns.\n\nThe system processes entities in depth-first order, ensuring parent transformations are computed before child transformations. This requires careful ordering of entity processing and caching of computed world-space transforms to avoid redundant calculations.\n\n**Reactive Systems and Event Handling**\n\nReactive systems respond to changes in component data rather than executing every frame, enabling event-driven architectures that can improve performance and code organization. These systems activate only when relevant changes occur, reducing unnecessary processing for inactive entities.\n\n| Event System Component | Responsibility | Performance Impact | Implementation Complexity |\n|------------------------|----------------|-------------------|-------------------------|\n| `ComponentChangeTracker` | Detects component modifications | Low overhead when inactive | Moderate - requires instrumentation |\n| `EventQueue` | Queues and dispatches events | Batch processing efficiency | Low - standard queue operations |\n| `ReactiveSystem` | Responds to specific events | Eliminates unnecessary updates | Moderate - event subscription |\n| `EventDispatcher` | Routes events to interested systems | Minimizes system activation | High - subscription management |\n\nThe reactive system implementation tracks component changes through instrumentation of component storage operations. When components are added, removed, or modified, the system generates events that are queued for processing by interested reactive systems.\n\n**Component Dependencies and Validation**\n\nComponent dependencies allow specification of requirements between component types, ensuring entities maintain valid configurations and enabling automatic component management.\n\n| Dependency Type | Description | Validation Timing | Resolution Strategy |\n|----------------|-------------|-------------------|-------------------|\n| Required Dependencies | ComponentA requires ComponentB to be present | Component addition/removal | Automatic addition of missing components |\n| Exclusive Dependencies | ComponentA and ComponentB cannot coexist | Component addition | Error or automatic removal |\n| Conditional Dependencies | ComponentA requires ComponentB only when ComponentC present | Dynamic evaluation | Lazy validation and resolution |\n| Version Dependencies | ComponentA requires specific version of ComponentB | Component modification | Version compatibility checking |\n\nThe dependency system integrates with the existing component storage to enforce constraints automatically, reducing runtime errors and improving system reliability.\n\n**Archetype Relationships and Queries**\n\nAdvanced archetype systems support complex queries that go beyond simple component presence checks, enabling sophisticated entity selection based on component values, relationships, and computed properties.\n\n| Advanced Query Type | Example | Implementation Strategy | Performance Characteristics |\n|--------------------|---------|------------------------|---------------------------|\n| Value-based queries | Entities with Health < 50 | Indexed component values | O(matching entities) |\n| Relationship queries | Entities within 10 units of player | Spatial indexing | O(log n + results) |\n| Computed property queries | Entities with velocity magnitude > 5.0 | Cached derived values | O(entities) with caching |\n| Cross-archetype queries | Parent-child pairs with different components | Join operations | O(parents * children) |\n\nThese advanced queries require sophisticated indexing and caching strategies to maintain performance while providing expressive query capabilities.\n\n#### Common Advanced Feature Pitfalls\n\n⚠️ **Pitfall: Hierarchy Update Ordering**\nProcessing hierarchical entities in the wrong order can cause visual artifacts or incorrect behavior when child entities depend on updated parent values. This commonly occurs with transform hierarchies where children appear to lag behind parent movement. Solution: Process entities in depth-first order or use double-buffering to separate read and write phases.\n\n⚠️ **Pitfall: Event System Memory Leaks**\nEvent systems that don't properly unsubscribe listeners or clean up event queues can cause memory leaks and performance degradation over time. This is particularly problematic with temporary entities or systems that are created and destroyed dynamically. Solution: Implement automatic subscription cleanup and bounded event queues with configurable retention policies.\n\n⚠️ **Pitfall: Over-Engineering Component Dependencies**\nComplex dependency systems can become harder to understand and debug than the problems they solve, especially when dependencies create unexpected cascading effects. Solution: Start with simple required/forbidden relationships and add complexity only when specifically needed for your use case.\n\n### Development Tooling\n\nDevelopment tooling transforms the ECS from a functional but opaque system into a transparent, debuggable, and optimizable architecture. Professional game development requires sophisticated tools for understanding system behavior, diagnosing performance issues, and visualizing entity relationships.\n\n#### Mental Model: Factory Control Room\n\nThink of development tooling like **building a comprehensive control room for a complex factory**. The factory (ECS) can operate without the control room, but the control room provides essential capabilities: monitoring dashboards show real-time performance metrics, diagnostic tools help identify bottlenecks and failures, and control interfaces allow operators to adjust parameters and investigate issues without stopping production.\n\nThe tooling infrastructure must be designed for minimal runtime impact when not in use, while providing deep introspection capabilities when debugging is required. This requires careful instrumentation that can be enabled or disabled based on build configuration and runtime flags.\n\n**Debug Visualizers and Inspectors**\n\nDebug visualizers provide real-time views of ECS state, allowing developers to understand entity composition, system execution, and data flow patterns. These tools are essential for debugging complex interactions and performance optimization.\n\n| Visualization Tool | Information Displayed | Use Cases | Implementation Requirements |\n|--------------------|----------------------|-----------|---------------------------|\n| Entity Inspector | Component values, relationships, lifecycle | Debugging entity behavior | Runtime reflection system |\n| System Performance Monitor | Execution times, call counts, dependencies | Performance optimization | High-resolution timing |\n| Component Memory Visualizer | Memory layout, cache patterns, fragmentation | Memory optimization | Memory introspection |\n| Archetype Browser | Archetype composition, entity counts, transitions | Understanding data organization | Archetype metadata access |\n\nThe entity inspector provides a hierarchical view of entities with expandable component details, similar to object inspectors in modern IDEs. This requires a runtime reflection system that can enumerate component types and provide human-readable representations of component values.\n\n**Performance Profilers and Analytics**\n\nPerformance profiling tools provide detailed insights into ECS behavior, enabling optimization of bottlenecks and validation of performance assumptions. These tools must have minimal impact on release builds while providing comprehensive data in development builds.\n\n| Profiling Component | Metrics Collected | Analysis Capabilities | Implementation Strategy |\n|---------------------|-------------------|----------------------|------------------------|\n| `SystemProfiler` | Execution time, call frequency, cache misses | System bottleneck identification | Instrumented system wrappers |\n| `ComponentAccessProfiler` | Access patterns, locality, contention | Data layout optimization | Memory access tracking |\n| `AllocationProfiler` | Allocation frequency, sizes, lifetimes | Memory usage optimization | Custom allocator hooks |\n| `ArchetypeProfiler` | Transition frequency, storage efficiency | Archetype design validation | Archetype operation logging |\n\nThe profiling infrastructure uses a sampling-based approach to minimize overhead while collecting representative data. Profiling can be enabled per-system or globally, allowing focused analysis of specific performance concerns.\n\n**Memory Analysis and Debugging**\n\nMemory analysis tools help identify leaks, corruption, and inefficient usage patterns in ECS implementations. These tools are crucial for maintaining reliability in long-running applications like games.\n\n| Memory Analysis Tool | Detection Capability | Implementation Approach | Performance Impact |\n|---------------------|---------------------|------------------------|-------------------|\n| Entity Leak Detector | Entities never destroyed | Reference tracking | Low - debug builds only |\n| Component Corruption Scanner | Invalid component values | Checksum validation | High - enabled selectively |\n| Memory Layout Analyzer | Cache inefficient patterns | Address space analysis | Moderate - sampling based |\n| Allocation Tracker | Memory usage patterns | Custom allocator instrumentation | Low - statistical sampling |\n\nThe memory analysis implementation uses compiler-specific debugging features and custom allocators to provide detailed information about memory usage patterns and potential issues.\n\n**Interactive Debugging and Manipulation**\n\nInteractive debugging tools allow runtime modification of ECS state for testing scenarios and investigating bugs. These capabilities are essential for rapid iteration and problem diagnosis.\n\n| Interactive Tool | Capabilities | Safety Considerations | Implementation Requirements |\n|------------------|-------------|----------------------|---------------------------|\n| Runtime Entity Editor | Create, modify, destroy entities | Must maintain system consistency | Transaction-based modifications |\n| Component Value Editor | Modify component values in real-time | Type safety and validation | Runtime type information |\n| System Control Panel | Enable, disable, reorder systems | Dependency validation | Dynamic system management |\n| Query Inspector | Test and optimize component queries | Performance impact awareness | Query compilation and analysis |\n\nThe interactive debugging system uses a command-based interface where modifications are validated before application, ensuring that debugging operations don't corrupt the ECS state or introduce inconsistencies.\n\n**Editor Integration and Asset Pipeline**\n\nEditor integration connects ECS development with content creation workflows, allowing designers and artists to work with entities and components through visual interfaces.\n\n| Editor Integration Feature | Benefit | Technical Requirements | Development Complexity |\n|---------------------------|---------|------------------------|----------------------|\n| Visual Entity Composition | Designer-friendly entity creation | Serialization system | High - requires UI framework |\n| Component Property Editors | Type-appropriate value editing | Runtime type metadata | Moderate - standard property grids |\n| System Execution Visualization | Understanding system interactions | Real-time data collection | High - requires visualization framework |\n| Performance Dashboard | Non-programmer performance monitoring | Aggregated metrics display | Moderate - data visualization |\n\nEditor integration typically requires serialization systems that can convert ECS state to and from persistent formats, enabling asset pipeline integration and save/load functionality.\n\n#### Common Development Tooling Pitfalls\n\n⚠️ **Pitfall: Performance Impact in Release Builds**\nDebug instrumentation that significantly impacts release build performance defeats the purpose of optimization efforts. This commonly occurs when debug code paths are not properly excluded or when profiling overhead is too high. Solution: Use preprocessor macros and template specialization to completely eliminate debug code in release builds, and implement sampling-based profiling with configurable overhead levels.\n\n⚠️ **Pitfall: Tool-Induced State Corruption**\nInteractive debugging tools that don't properly validate modifications can corrupt ECS state, making debugging more difficult rather than easier. This is particularly problematic when modifying entities during system execution or violating component dependencies. Solution: Implement all interactive modifications through the same validation and safety mechanisms used by regular game code.\n\n⚠️ **Pitfall: Information Overload in Debug Displays**\nComprehensive debug information can become overwhelming and counterproductive when too much data is displayed simultaneously. This makes it difficult to focus on relevant information during debugging sessions. Solution: Implement filtering, grouping, and drill-down capabilities that allow developers to focus on specific aspects of system behavior while maintaining access to comprehensive data when needed.\n\n### Implementation Guidance\n\nThe implementation of ECS extensions requires careful consideration of complexity trade-offs and development priorities. These extensions significantly increase system complexity while providing substantial benefits for advanced use cases.\n\n#### Technology Recommendations\n\n| Extension Category | Simple Approach | Production Approach | Recommended Starting Point |\n|-------------------|----------------|--------------------|-----------------------|\n| Multi-threading | `std::thread` with manual synchronization | Thread pool with work stealing | Simple approach with read-write locks |\n| Event Systems | Direct function callbacks | Message queue with batching | Direct callbacks for initial implementation |\n| Debug Visualization | Console output with formatting | ImGui or similar immediate mode GUI | Console output for core functionality |\n| Performance Profiling | `std::chrono` timing | Platform-specific high-resolution counters | `std::chrono` with statistical sampling |\n\n#### Recommended File Structure\n\nThe extended ECS implementation requires careful organization to manage increased complexity while maintaining clarity and modularity.\n\n```cpp\nproject-root/\n├── include/ecs/\n│   ├── core/                    // Core ECS implementation\n│   │   ├── entity_manager.hpp\n│   │   ├── component_storage.hpp\n│   │   └── system_interface.hpp\n│   ├── extensions/              // Extension features\n│   │   ├── threading/\n│   │   │   ├── thread_safe_storage.hpp\n│   │   │   ├── parallel_system_manager.hpp\n│   │   │   └── work_stealing_scheduler.hpp\n│   │   ├── advanced/\n│   │   │   ├── hierarchy_manager.hpp\n│   │   │   ├── reactive_systems.hpp\n│   │   │   └── component_dependencies.hpp\n│   │   └── tooling/\n│   │       ├── debug_visualizer.hpp\n│   │       ├── performance_profiler.hpp\n│   │       └── memory_analyzer.hpp\n│   └── utils/                   // Supporting utilities\n│       ├── thread_pool.hpp\n│       ├── lock_free_queue.hpp\n│       └── reflection_system.hpp\n├── src/ecs/\n│   ├── core/                    // Core implementation files\n│   ├── extensions/              // Extension implementation files\n│   └── utils/                   // Utility implementations\n├── examples/\n│   ├── basic_ecs/              // Core ECS examples\n│   ├── multi_threaded/         // Threading examples\n│   ├── hierarchical/           // Hierarchy examples\n│   └── debug_tools/            // Tooling examples\n└── tests/\n    ├── core/                    // Core ECS tests\n    ├── extensions/              // Extension tests\n    └── integration/             // Full system tests\n```\n\n#### Infrastructure Starter Code\n\n**Thread-Safe Component Storage Foundation**\n\n```cpp\n#include <shared_mutex>\n#include <atomic>\n#include <memory>\n\n// Thread-safe wrapper for component storage with read-write semantics\ntemplate<typename T>\nclass ThreadSafeComponentStorage {\nprivate:\n    mutable std::shared_mutex mutex_;\n    ComponentStorage<T> storage_;\n    std::atomic<uint64_t> modification_count_{0};\n    \npublic:\n    // Read operations allow multiple concurrent readers\n    template<typename Func>\n    auto withReadLock(Func&& func) const -> decltype(func(storage_)) {\n        std::shared_lock<std::shared_mutex> lock(mutex_);\n        return func(storage_);\n    }\n    \n    // Write operations require exclusive access\n    template<typename Func>\n    auto withWriteLock(Func&& func) -> decltype(func(storage_)) {\n        std::unique_lock<std::shared_mutex> lock(mutex_);\n        auto result = func(storage_);\n        modification_count_.fetch_add(1, std::memory_order_relaxed);\n        return result;\n    }\n    \n    // Check if storage has been modified since last check\n    bool hasBeenModified(uint64_t& lastSeen) const {\n        uint64_t current = modification_count_.load(std::memory_order_relaxed);\n        if (current != lastSeen) {\n            lastSeen = current;\n            return true;\n        }\n        return false;\n    }\n};\n\n// Simple thread pool for parallel system execution\nclass ThreadPool {\nprivate:\n    std::vector<std::thread> workers_;\n    std::queue<std::function<void()>> tasks_;\n    std::mutex queue_mutex_;\n    std::condition_variable condition_;\n    std::atomic<bool> stop_{false};\n    \npublic:\n    explicit ThreadPool(size_t threads) {\n        for (size_t i = 0; i < threads; ++i) {\n            workers_.emplace_back([this] {\n                while (!stop_.load()) {\n                    std::function<void()> task;\n                    {\n                        std::unique_lock<std::mutex> lock(queue_mutex_);\n                        condition_.wait(lock, [this] { \n                            return stop_.load() || !tasks_.empty(); \n                        });\n                        \n                        if (stop_.load()) break;\n                        \n                        task = std::move(tasks_.front());\n                        tasks_.pop();\n                    }\n                    task();\n                }\n            });\n        }\n    }\n    \n    template<typename Func>\n    void enqueue(Func&& func) {\n        {\n            std::unique_lock<std::mutex> lock(queue_mutex_);\n            tasks_.emplace(std::forward<Func>(func));\n        }\n        condition_.notify_one();\n    }\n    \n    ~ThreadPool() {\n        stop_.store(true);\n        condition_.notify_all();\n        for (auto& worker : workers_) {\n            worker.join();\n        }\n    }\n};\n```\n\n**Event System Foundation**\n\n```cpp\n#include <vector>\n#include <functional>\n#include <unordered_map>\n#include <typeindex>\n\n// Basic event system for reactive ECS behavior\nclass EventSystem {\npublic:\n    // Event base class for type erasure\n    struct Event {\n        virtual ~Event() = default;\n    };\n    \n    // Component change event\n    struct ComponentAdded : Event {\n        Entity entity;\n        ComponentTypeID componentType;\n        ComponentAdded(Entity e, ComponentTypeID type) \n            : entity(e), componentType(type) {}\n    };\n    \n    struct ComponentRemoved : Event {\n        Entity entity;\n        ComponentTypeID componentType;\n        ComponentRemoved(Entity e, ComponentTypeID type) \n            : entity(e), componentType(type) {}\n    };\n    \n    // Event subscription mechanism\n    using EventHandler = std::function<void(const Event&)>;\n    \n    template<typename EventType>\n    void subscribe(EventHandler handler) {\n        subscribers_[std::type_index(typeid(EventType))].push_back(handler);\n    }\n    \n    template<typename EventType>\n    void publish(const EventType& event) {\n        auto it = subscribers_.find(std::type_index(typeid(EventType)));\n        if (it != subscribers_.end()) {\n            for (const auto& handler : it->second) {\n                handler(event);\n            }\n        }\n    }\n    \n    void processQueuedEvents() {\n        for (auto& event : event_queue_) {\n            // Process event through type-erased dispatch\n            event();\n        }\n        event_queue_.clear();\n    }\n    \nprivate:\n    std::unordered_map<std::type_index, std::vector<EventHandler>> subscribers_;\n    std::vector<std::function<void()>> event_queue_;\n};\n```\n\n#### Core Logic Skeleton\n\n**Parallel System Manager Implementation**\n\n```cpp\nclass ParallelSystemManager {\nprivate:\n    struct SystemInfo {\n        std::unique_ptr<System> system;\n        std::set<ComponentTypeID> readComponents;\n        std::set<ComponentTypeID> writeComponents;\n        int priority;\n        bool enabled;\n    };\n    \n    std::vector<SystemInfo> systems_;\n    ThreadPool thread_pool_;\n    bool systems_sorted_ = false;\n    \npublic:\n    explicit ParallelSystemManager(size_t thread_count) \n        : thread_pool_(thread_count) {}\n    \n    template<typename T, typename... Args>\n    T* registerSystem(int priority, Args&&... args) {\n        // TODO 1: Create system instance with perfect forwarding\n        // TODO 2: Analyze system's component dependencies using reflection or explicit declaration\n        // TODO 3: Store system with dependency metadata\n        // TODO 4: Mark systems as needing re-sort for dependency analysis\n        // Hint: Use template traits or explicit dependency declaration\n    }\n    \n    void updateAllSystems(World& world, float deltaTime) {\n        // TODO 1: Sort systems by priority if needed\n        // TODO 2: Group systems into execution phases based on component dependencies\n        // TODO 3: Execute each phase in parallel using thread pool\n        // TODO 4: Wait for phase completion before starting next phase\n        // TODO 5: Collect and handle any errors from parallel execution\n        // Hint: Systems that read the same components can run in parallel\n        // Hint: Systems that write to the same components must be serialized\n    }\n    \nprivate:\n    std::vector<std::vector<size_t>> analyzeSystemDependencies() {\n        // TODO 1: Create dependency graph from system component access patterns\n        // TODO 2: Identify systems with conflicting write dependencies\n        // TODO 3: Group compatible systems into execution phases\n        // TODO 4: Return vector of phases, each containing system indices\n        // Hint: Two systems conflict if one writes to components the other reads/writes\n    }\n    \n    void executePhase(const std::vector<size_t>& systemIndices, \n                     World& world, float deltaTime) {\n        // TODO 1: Create tasks for each system in the phase\n        // TODO 2: Submit tasks to thread pool for parallel execution\n        // TODO 3: Wait for all tasks to complete using synchronization\n        // TODO 4: Collect any exceptions or errors from parallel execution\n        // Hint: Use std::future or barrier synchronization\n    }\n};\n```\n\n**Hierarchy Manager Implementation**\n\n```cpp\nclass HierarchyManager {\nprivate:\n    World* world_;\n    std::unordered_map<Entity, std::vector<Entity>, EntityHash> cached_children_;\n    bool cache_dirty_ = true;\n    \npublic:\n    explicit HierarchyManager(World* world) : world_(world) {}\n    \n    void setParent(Entity child, Entity parent) {\n        // TODO 1: Validate that child and parent are different entities\n        // TODO 2: Check for circular references (child becoming ancestor of current parent)\n        // TODO 3: Remove child from current parent's child list if it has one\n        // TODO 4: Add child to new parent's child list\n        // TODO 5: Update child's Hierarchy component with new parent\n        // TODO 6: Mark hierarchy cache as dirty for rebuilding\n        // Hint: Use getAncestors to detect circular references\n    }\n    \n    std::vector<Entity> getChildren(Entity parent) {\n        // TODO 1: Check if cached children data is valid\n        // TODO 2: If cache is dirty, rebuild children cache from Hierarchy components\n        // TODO 3: Return cached children vector for parent\n        // TODO 4: Return empty vector if parent has no children\n        // Hint: Cache all parent-child relationships for performance\n    }\n    \n    std::vector<Entity> getAncestors(Entity entity) {\n        // TODO 1: Start with given entity and empty ancestors list\n        // TODO 2: Follow parent references up the hierarchy\n        // TODO 3: Add each parent to ancestors list\n        // TODO 4: Stop when reaching root entity (parent == INVALID_ENTITY)\n        // TODO 5: Return ancestors list in root-to-parent order\n        // Hint: Detect infinite loops by limiting maximum depth\n    }\n    \n    void traverseSubtree(Entity root, std::function<void(Entity, int)> callback) {\n        // TODO 1: Call callback for root entity with depth 0\n        // TODO 2: Get all children of current entity\n        // TODO 3: Recursively traverse each child with incremented depth\n        // TODO 4: Use depth-first traversal order for predictable processing\n        // Hint: Consider iterative implementation to avoid stack overflow\n    }\n    \nprivate:\n    void rebuildChildrenCache() {\n        // TODO 1: Clear existing cached children data\n        // TODO 2: Iterate through all entities with Hierarchy components\n        // TODO 3: For each entity, add it to its parent's children list\n        // TODO 4: Mark cache as clean after rebuilding\n        // Hint: Use component query to find all hierarchical entities\n    }\n    \n    bool wouldCreateCycle(Entity child, Entity newParent) {\n        // TODO 1: Get all ancestors of newParent\n        // TODO 2: Check if child appears in ancestor list\n        // TODO 3: Return true if cycle would be created\n        // Hint: If child is an ancestor of newParent, making newParent the parent creates a cycle\n    }\n};\n```\n\n#### Milestone Checkpoints\n\n**Multi-Threading Extension Checkpoint**\nAfter implementing basic multi-threading support:\n- Run `cd build && make test_parallel_systems && ./test_parallel_systems`\n- Expected output: Systems execute in parallel phases with proper synchronization\n- Manually verify: Create systems with conflicting dependencies, ensure they execute serially\n- Performance test: Measure speedup with multiple threads vs single-threaded execution\n- Signs of problems: Data races, deadlocks, or performance regression indicate synchronization issues\n\n**Advanced Features Checkpoint**\nAfter implementing hierarchy and event systems:\n- Run `cd build && make test_hierarchy && ./test_hierarchy`\n- Expected behavior: Parent-child relationships maintained correctly, events fired on component changes\n- Manually verify: Create hierarchical entities, modify components, observe event system responses\n- Test edge cases: Circular references prevented, deep hierarchies handled efficiently\n- Signs of problems: Stack overflow, infinite loops, or missing event notifications\n\n**Development Tooling Checkpoint**\nAfter implementing debug visualization:\n- Run `cd build && make debug_example && ./debug_example`\n- Expected output: Real-time display of entity states, system performance metrics, memory usage\n- Interactive test: Modify entity components through debug interface, verify changes reflect in game\n- Performance check: Ensure debug tools have minimal impact when disabled\n- Signs of problems: Significant performance impact, crashes when debugging, or inaccurate information display\n\nThe extensions transform the basic ECS into a production-ready architecture capable of handling complex game development scenarios. Each extension adds significant value while introducing complexity that must be carefully managed through good architectural practices and comprehensive testing.\n\n### Implementation Guidance\n\n#### Technology Recommendations Table\n\n| Extension Category | Simple Option | Advanced Option |\n|-------------------|---------------|----------------|\n| Multi-threading | `std::thread` with manual locks | Custom work-stealing scheduler with lock-free queues |\n| Event Systems | Direct callback registration | Message queue with priority scheduling and batching |\n| Hierarchy Management | Parent/child component references | Dedicated tree structure with cached operations |\n| Debug Visualization | Console logging with structured output | ImGui integration with real-time entity inspection |\n| Performance Profiling | `std::chrono::high_resolution_clock` timing | Platform-specific performance counters with sampling |\n| Memory Analysis | Custom allocator with tracking | Integration with Valgrind, AddressSanitizer, or similar tools |\n\n#### Recommended File Structure\n\n```cpp\nproject-root/\n├── include/ecs/\n│   ├── core/                           // Core ECS (Milestones 1-4)\n│   │   ├── entity_manager.hpp\n│   │   ├── component_storage.hpp\n│   │   ├── system_interface.hpp\n│   │   └── archetype_storage.hpp\n│   ├── threading/                      // Multi-threading extensions\n│   │   ├── thread_safe_storage.hpp\n│   │   ├── parallel_system_manager.hpp\n│   │   ├── work_stealing_scheduler.hpp\n│   │   └── lock_free_primitives.hpp\n│   ├── advanced/                       // Advanced ECS features\n│   │   ├── hierarchy_manager.hpp\n│   │   ├── reactive_systems.hpp\n│   │   ├── event_dispatcher.hpp\n│   │   ├── component_dependencies.hpp\n│   │   └── advanced_queries.hpp\n│   ├── tooling/                        // Development tools\n│   │   ├── debug_visualizer.hpp\n│   │   ├── performance_profiler.hpp\n│   │   ├── memory_analyzer.hpp\n│   │   ├── entity_inspector.hpp\n│   │   └── system_tracer.hpp\n│   └── utils/                          // Supporting utilities\n│       ├── thread_pool.hpp\n│       ├── reflection_system.hpp\n│       ├── command_buffer.hpp\n│       └── circular_buffer.hpp\n├── src/ecs/                           // Implementation files\n│   ├── core/                          // Core implementations\n│   ├── threading/                     // Threading implementations  \n│   ├── advanced/                      // Advanced feature implementations\n│   ├── tooling/                       // Tool implementations\n│   └── utils/                         // Utility implementations\n├── examples/\n│   ├── 01_basic_ecs/                  // Core ECS examples\n│   ├── 02_multithreaded/              // Threading examples\n│   ├── 03_hierarchical/               // Hierarchy examples\n│   ├── 04_reactive/                   // Event system examples\n│   └── 05_debug_tools/                // Debug tooling examples\n├── tools/                             // Standalone development tools\n│   ├── ecs_profiler/                  // Performance analysis tool\n│   ├── entity_editor/                 // Visual entity editing tool\n│   └── memory_visualizer/             // Memory layout analysis tool\n└── tests/\n    ├── unit/                          // Individual component tests\n    ├── integration/                   // Cross-component tests\n    ├── performance/                   // Benchmark and regression tests\n    └── stress/                        // Load and stability tests\n```\n\n#### Infrastructure Starter Code\n\n**Thread Pool with Work Stealing**\n\n```cpp\n#pragma once\n#include <vector>\n#include <thread>\n#include <queue>\n#include <mutex>\n#include <condition_variable>\n#include <atomic>\n#include <functional>\n#include <future>\n\nclass WorkStealingThreadPool {\nprivate:\n    struct alignas(64) WorkerQueue {  // Cache line aligned\n        std::queue<std::function<void()>> tasks;\n        mutable std::mutex mutex;\n        std::condition_variable condition;\n    };\n    \n    std::vector<std::unique_ptr<WorkerQueue>> worker_queues_;\n    std::vector<std::thread> workers_;\n    std::atomic<bool> stop_requested_{false};\n    std::atomic<size_t> active_workers_{0};\n    \n    void workerLoop(size_t worker_id) {\n        auto& local_queue = *worker_queues_[worker_id];\n        \n        while (!stop_requested_.load(std::memory_order_relaxed)) {\n            std::function<void()> task;\n            \n            // Try to get task from local queue first\n            if (tryPopLocal(local_queue, task)) {\n                active_workers_.fetch_add(1, std::memory_order_relaxed);\n                task();\n                active_workers_.fetch_sub(1, std::memory_order_relaxed);\n                continue;\n            }\n            \n            // Try to steal from other workers\n            if (tryStealWork(worker_id, task)) {\n                active_workers_.fetch_add(1, std::memory_order_relaxed);\n                task();\n                active_workers_.fetch_sub(1, std::memory_order_relaxed);\n                continue;\n            }\n            \n            // Wait for new work\n            std::unique_lock<std::mutex> lock(local_queue.mutex);\n            local_queue.condition.wait_for(lock, std::chrono::milliseconds(1));\n        }\n    }\n    \n    bool tryPopLocal(WorkerQueue& queue, std::function<void()>& task) {\n        std::unique_lock<std::mutex> lock(queue.mutex, std::try_to_lock);\n        if (lock.owns_lock() && !queue.tasks.empty()) {\n            task = std::move(queue.tasks.front());\n            queue.tasks.pop();\n            return true;\n        }\n        return false;\n    }\n    \n    bool tryStealWork(size_t excluding_worker, std::function<void()>& task) {\n        for (size_t i = 0; i < worker_queues_.size(); ++i) {\n            if (i == excluding_worker) continue;\n            \n            auto& queue = *worker_queues_[i];\n            std::unique_lock<std::mutex> lock(queue.mutex, std::try_to_lock);\n            if (lock.owns_lock() && !queue.tasks.empty()) {\n                task = std::move(queue.tasks.front());\n                queue.tasks.pop();\n                return true;\n            }\n        }\n        return false;\n    }\n    \npublic:\n    explicit WorkStealingThreadPool(size_t thread_count = std::thread::hardware_concurrency()) {\n        worker_queues_.reserve(thread_count);\n        workers_.reserve(thread_count);\n        \n        // Create worker queues\n        for (size_t i = 0; i < thread_count; ++i) {\n            worker_queues_.emplace_back(std::make_unique<WorkerQueue>());\n        }\n        \n        // Start worker threads\n        for (size_t i = 0; i < thread_count; ++i) {\n            workers_.emplace_back(&WorkStealingThreadPool::workerLoop, this, i);\n        }\n    }\n    \n    template<typename Func, typename... Args>\n    auto enqueue(Func&& func, Args&&... args) -> std::future<decltype(func(args...))> {\n        using ReturnType = decltype(func(args...));\n        \n        auto task = std::make_shared<std::packaged_task<ReturnType()>>(\n            std::bind(std::forward<Func>(func), std::forward<Args>(args)...)\n        );\n        \n        auto result = task->get_future();\n        \n        // Distribute tasks round-robin across workers\n        static std::atomic<size_t> counter{0};\n        size_t target_worker = counter.fetch_add(1) % worker_queues_.size();\n        \n        auto& queue = *worker_queues_[target_worker];\n        {\n            std::unique_lock<std::mutex> lock(queue.mutex);\n            queue.tasks.emplace([task]() { (*task)(); });\n        }\n        queue.condition.notify_one();\n        \n        return result;\n    }\n    \n    void waitForAllTasks() {\n        // Wait until all workers are idle\n        while (active_workers_.load(std::memory_order_relaxed) > 0) {\n            std::this_thread::sleep_for(std::chrono::microseconds(100));\n        }\n        \n        // Double-check that all queues are empty\n        bool all_empty = false;\n        while (!all_empty) {\n            all_empty = true;\n            for (auto& queue : worker_queues_) {\n                std::unique_lock<std::mutex> lock(queue->mutex);\n                if (!queue->tasks.empty()) {\n                    all_empty = false;\n                    break;\n                }\n            }\n            if (!all_empty) {\n                std::this_thread::sleep_for(std::chrono::microseconds(100));\n            }\n        }\n    }\n    \n    size_t getThreadCount() const { return workers_.size(); }\n    \n    ~WorkStealingThreadPool() {\n        stop_requested_.store(true, std::memory_order_relaxed);\n        \n        // Wake up all workers\n        for (auto& queue : worker_queues_) {\n            queue->condition.notify_all();\n        }\n        \n        // Wait for all workers to finish\n        for (auto& worker : workers_) {\n            worker.join();\n        }\n    }\n};\n```\n\n**Event System with Batching**\n\n```cpp\n#pragma once\n#include <vector>\n#include <unordered_map>\n#include <typeindex>\n#include <functional>\n#include <memory>\n#include <queue>\n\nclass EventDispatcher {\npublic:\n    // Base event interface\n    struct Event {\n        virtual ~Event() = default;\n        virtual std::type_index getType() const = 0;\n    };\n    \n    // Typed event wrapper\n    template<typename T>\n    struct TypedEvent : Event {\n        T data;\n        \n        template<typename... Args>\n        explicit TypedEvent(Args&&... args) : data(std::forward<Args>(args)...) {}\n        \n        std::type_index getType() const override {\n            return std::type_index(typeid(T));\n        }\n    };\n    \n    // Event handler function type\n    using EventHandler = std::function<void(const Event&)>;\n    \n    // Subscribe to events of specific type\n    template<typename T>\n    void subscribe(EventHandler handler) {\n        auto type_index = std::type_index(typeid(T));\n        event_handlers_[type_index].emplace_back(std::move(handler));\n    }\n    \n    // Convenient typed subscription\n    template<typename T>\n    void subscribe(std::function<void(const T&)> handler) {\n        subscribe<T>([handler](const Event& event) {\n            const auto& typed_event = static_cast<const TypedEvent<T>&>(event);\n            handler(typed_event.data);\n        });\n    }\n    \n    // Queue event for batch processing\n    template<typename T, typename... Args>\n    void queueEvent(Args&&... args) {\n        event_queue_.emplace(std::make_unique<TypedEvent<T>>(std::forward<Args>(args)...));\n    }\n    \n    // Immediately dispatch event\n    template<typename T, typename... Args>\n    void dispatchEvent(Args&&... args) {\n        TypedEvent<T> event(std::forward<Args>(args)...);\n        dispatchEvent(event);\n    }\n    \n    void dispatchEvent(const Event& event) {\n        auto it = event_handlers_.find(event.getType());\n        if (it != event_handlers_.end()) {\n            for (const auto& handler : it->second) {\n                handler(event);\n            }\n        }\n    }\n    \n    // Process all queued events\n    void processQueuedEvents() {\n        while (!event_queue_.empty()) {\n            auto event = std::move(event_queue_.front());\n            event_queue_.pop();\n            dispatchEvent(*event);\n        }\n    }\n    \n    // Clear all queued events without processing\n    void clearQueue() {\n        std::queue<std::unique_ptr<Event>> empty;\n        event_queue_.swap(empty);\n    }\n    \n    size_t getQueueSize() const {\n        return event_queue_.size();\n    }\n    \n    void clearAllHandlers() {\n        event_handlers_.clear();\n    }\n    \n    template<typename T>\n    void clearHandlers() {\n        event_handlers_.erase(std::type_index(typeid(T)));\n    }\n    \nprivate:\n    std::unordered_map<std::type_index, std::vector<EventHandler>> event_handlers_;\n    std::queue<std::unique_ptr<Event>> event_queue_;\n};\n\n// Common ECS events\nstruct ComponentAddedEvent {\n    Entity entity;\n    ComponentTypeID componentType;\n    \n    ComponentAddedEvent(Entity e, ComponentTypeID type) \n        : entity(e), componentType(type) {}\n};\n\nstruct ComponentRemovedEvent {\n    Entity entity;\n    ComponentTypeID componentType;\n    \n    ComponentRemovedEvent(Entity e, ComponentTypeID type) \n        : entity(e), componentType(type) {}\n};\n\nstruct EntityCreatedEvent {\n    Entity entity;\n    explicit EntityCreatedEvent(Entity e) : entity(e) {}\n};\n\nstruct EntityDestroyedEvent {\n    Entity entity;\n    explicit EntityDestroyedEvent(Entity e) : entity(e) {}\n};\n```\n\n**Simple Performance Profiler**\n\n```cpp\n#pragma once\n#include <chrono>\n#include <unordered_map>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n\nclass PerformanceProfiler {\npublic:\n    struct ProfileData {\n        std::string name;\n        double totalTime = 0.0;\n        double minTime = std::numeric_limits<double>::max();\n        double maxTime = 0.0;\n        size_t callCount = 0;\n        \n        double getAverageTime() const {\n            return callCount > 0 ? totalTime / callCount : 0.0;\n        }\n    };\n    \n    class ScopedTimer {\n    private:\n        PerformanceProfiler* profiler_;\n        std::string name_;\n        std::chrono::high_resolution_clock::time_point start_time_;\n        \n    public:\n        ScopedTimer(PerformanceProfiler* profiler, const std::string& name)\n            : profiler_(profiler), name_(name)\n            , start_time_(std::chrono::high_resolution_clock::now()) {}\n        \n        ~ScopedTimer() {\n            auto end_time = std::chrono::high_resolution_clock::now();\n            auto duration = std::chrono::duration<double, std::milli>(end_time - start_time_).count();\n            profiler_->recordTiming(name_, duration);\n        }\n    };\n    \n    void recordTiming(const std::string& name, double timeMs) {\n        auto& data = profile_data_[name];\n        data.name = name;\n        data.totalTime += timeMs;\n        data.minTime = std::min(data.minTime, timeMs);\n        data.maxTime = std::max(data.maxTime, timeMs);\n        data.callCount++;\n    }\n    \n    ScopedTimer createTimer(const std::string& name) {\n        return ScopedTimer(this, name);\n    }\n    \n    void reset() {\n        profile_data_.clear();\n    }\n    \n    void printReport() const {\n        if (profile_data_.empty()) {\n            std::cout << \"No profiling data available.\\n\";\n            return;\n        }\n        \n        // Sort by total time descending\n        std::vector<ProfileData> sorted_data;\n        for (const auto& pair : profile_data_) {\n            sorted_data.push_back(pair.second);\n        }\n        \n        std::sort(sorted_data.begin(), sorted_data.end(), \n                 [](const ProfileData& a, const ProfileData& b) {\n                     return a.totalTime > b.totalTime;\n                 });\n        \n        std::cout << \"\\n=== Performance Profile Report ===\\n\";\n        std::cout << std::left \n                  << std::setw(25) << \"Name\"\n                  << std::setw(12) << \"Total (ms)\"\n                  << std::setw(12) << \"Avg (ms)\"\n                  << std::setw(12) << \"Min (ms)\"\n                  << std::setw(12) << \"Max (ms)\"\n                  << std::setw(10) << \"Calls\" << \"\\n\";\n        std::cout << std::string(85, '-') << \"\\n\";\n        \n        for (const auto& data : sorted_data) {\n            std::cout << std::left \n                      << std::setw(25) << data.name\n                      << std::setw(12) << std::fixed << std::setprecision(3) << data.totalTime\n                      << std::setw(12) << std::fixed << std::setprecision(3) << data.getAverageTime()\n                      << std::setw(12) << std::fixed << std::setprecision(3) << data.minTime\n                      << std::setw(12) << std::fixed << std::setprecision(3) << data.maxTime\n                      << std::setw(10) << data.callCount << \"\\n\";\n        }\n        std::cout << \"\\n\";\n    }\n    \n    const ProfileData* getProfileData(const std::string& name) const {\n        auto it = profile_data_.find(name);\n        return it != profile_data_.end() ? &it->second : nullptr;\n    }\n    \n    std::vector<ProfileData> getAllProfileData() const {\n        std::vector<ProfileData> result;\n        for (const auto& pair : profile_data_) {\n            result.push_back(pair.second);\n        }\n        return result;\n    }\n    \nprivate:\n    std::unordered_map<std::string, ProfileData> profile_data_;\n};\n\n// Global profiler instance\nextern PerformanceProfiler g_profiler;\n\n// Convenience macro for timing scopes\n#define PROFILE_SCOPE(name) auto timer = g_profiler.createTimer(name)\n#define PROFILE_FUNCTION() PROFILE_SCOPE(__FUNCTION__)\n```\n\n#### Core Logic Skeleton Code\n\n**Parallel System Manager**\n\n```cpp\nclass ParallelSystemManager : public SystemManager {\nprivate:\n    WorkStealingThreadPool thread_pool_;\n    std::vector<std::vector<size_t>> execution_phases_;\n    bool dependency_analysis_dirty_ = true;\n    \npublic:\n    explicit ParallelSystemManager(size_t thread_count = std::thread::hardware_concurrency())\n        : thread_pool_(thread_count) {}\n    \n    void updateAllSystems(World& world, float deltaTime) override {\n        PROFILE_FUNCTION();\n        \n        // TODO 1: Check if dependency analysis needs to be updated\n        // TODO 2: If dirty, rebuild execution phases based on system dependencies\n        // TODO 3: For each execution phase, submit systems to thread pool\n        // TODO 4: Wait for current phase to complete before starting next phase\n        // TODO 5: Handle any exceptions that occurred during parallel execution\n        // Hint: Use analyzeSystemDependencies() to build phases\n        // Hint: Use thread_pool_.waitForAllTasks() between phases\n    }\n    \nprivate:\n    void analyzeSystemDependencies() {\n        PROFILE_SCOPE(\"Dependency Analysis\");\n        \n        // TODO 1: Clear existing execution phases\n        // TODO 2: Create dependency graph from system component access patterns  \n        // TODO 3: Group systems with compatible dependencies into phases\n        // TODO 4: Ensure systems that write to same components are in different phases\n        // TODO 5: Store phases in execution_phases_ member\n        // Hint: Two systems are compatible if their write sets don't overlap\n        //       and neither writes to components the other reads\n    }\n    \n    bool systemsAreCompatible(size_t system1_idx, size_t system2_idx) const {\n        // TODO 1: Get component access patterns for both systems\n        // TODO 2: Check if system1 writes to components that system2 reads or writes\n        // TODO 3: Check if system2 writes to components that system1 reads or writes  \n        // TODO 4: Return true only if no conflicts exist\n        // Hint: Use set intersection to find conflicting component types\n    }\n    \n    void executeSystemsInPhase(const std::vector<size_t>& system_indices, \n                              World& world, float deltaTime) {\n        std::vector<std::future<void>> futures;\n        futures.reserve(system_indices.size());\n        \n        // TODO 1: For each system index in the phase, create an async task\n        // TODO 2: Submit tasks to thread pool and collect futures\n        // TODO 3: Wait for all futures to complete\n        // TODO 4: Check futures for exceptions and handle appropriately\n        // Hint: Capture system reference and parameters by value in lambda\n        // Hint: Use std::exception_ptr to handle cross-thread exceptions\n    }\n};\n```\n\n**Hierarchy Manager with Caching**\n\n```cpp\nclass HierarchyManager {\nprivate:\n    World* world_;\n    \n    // Cached data for performance\n    mutable std::unordered_map<Entity, std::vector<Entity>, EntityHash> children_cache_;\n    mutable std::unordered_map<Entity, std::vector<Entity>, EntityHash> ancestors_cache_;\n    mutable bool cache_valid_ = false;\n    \npublic:\n    explicit HierarchyManager(World* world) : world_(world) {}\n    \n    void setParent(Entity child, Entity parent) {\n        // TODO 1: Validate that child and parent are different entities\n        // TODO 2: Check for circular references using wouldCreateCycle()\n        // TODO 3: Remove child from its current parent's hierarchy (if any)\n        // TODO 4: Add child to new parent's hierarchy component\n        // TODO 5: Update child's hierarchy component with new parent\n        // TODO 6: Invalidate cached hierarchy data\n        // Hint: Use hasComponent/getComponent to access Hierarchy components\n        // Hint: Update both parent and child Hierarchy components atomically\n    }\n    \n    void removeFromHierarchy(Entity entity) {\n        // TODO 1: Get entity's current hierarchy component\n        // TODO 2: Remove entity from parent's child list\n        // TODO 3: Recursively remove all children from hierarchy\n        // TODO 4: Remove entity's hierarchy component\n        // TODO 5: Invalidate hierarchy cache\n        // Hint: Process children before removing parent to maintain consistency\n    }\n    \n    std::vector<Entity> getChildren(Entity parent) const {\n        // TODO 1: Check if cache is valid, rebuild if necessary\n        // TODO 2: Look up parent in children cache\n        // TODO 3: Return cached children vector or empty vector if none\n        // Hint: Use rebuildCache() to ensure cache validity\n    }\n    \n    std::vector<Entity> getAncestors(Entity entity) const {\n        // TODO 1: Check if cache is valid, rebuild if necessary  \n        // TODO 2: Look up entity in ancestors cache\n        // TODO 3: If not cached, walk up parent chain and cache result\n        // TODO 4: Return ancestors in root-to-immediate-parent order\n        // Hint: Limit ancestor depth to prevent infinite loops\n    }\n    \n    void traverseSubtree(Entity root, std::function<void(Entity, int)> callback) const {\n        // TODO 1: Call callback for root entity with depth 0\n        // TODO 2: Get direct children of root entity\n        // TODO 3: For each child, recursively call traverseSubtree with depth+1\n        // TODO 4: Use depth-first traversal order\n        // Hint: Consider iterative implementation with explicit stack for deep hierarchies\n    }\n    \n    bool isAncestorOf(Entity potential_ancestor, Entity descendant) const {\n        // TODO 1: Get all ancestors of descendant\n        // TODO 2: Check if potential_ancestor appears in ancestors list\n        // TODO 3: Return true if found, false otherwise\n        // Hint: Use getAncestors() for implementation simplicity\n    }\n    \nprivate:\n    void rebuildCache() const {\n        if (cache_valid_) return;\n        \n        PROFILE_SCOPE(\"Hierarchy Cache Rebuild\");\n        \n        // TODO 1: Clear existing cached data\n        // TODO 2: Query all entities with Hierarchy components\n        // TODO 3: For each entity, add it to its parent's children list\n        // TODO 4: Build ancestors cache by walking parent chains\n        // TODO 5: Mark cache as valid\n        // Hint: Use world_->query<Hierarchy>() to get hierarchical entities\n    }\n    \n    bool wouldCreateCycle(Entity child, Entity newParent) const {\n        // TODO 1: Get all ancestors of newParent\n        // TODO 2: Check if child appears in the ancestor list\n        // TODO 3: Return true if cycle would be created\n        // Hint: If child is ancestor of newParent, making newParent parent of child creates cycle\n    }\n    \n    void invalidateCache() {\n        cache_valid_ = false;\n        children_cache_.clear();\n        ancestors_cache_.clear();\n    }\n};\n```\n\n**Debug Entity Inspector**\n\n```cpp\nclass EntityInspector {\nprivate:\n    World* world_;\n    Entity selected_entity_ = INVALID_ENTITY;\n    bool show_inspector_window_ = true;\n    \npublic:\n    explicit EntityInspector(World* world) : world_(world) {}\n    \n    void render() {\n        if (!show_inspector_window_) return;\n        \n        // TODO 1: Create ImGui window for entity inspection\n        // TODO 2: Display entity selector with all alive entities\n        // TODO 3: Show selected entity's component list\n        // TODO 4: Allow editing of component values\n        // TODO 5: Provide buttons for adding/removing components\n        // Hint: Use ImGui::Begin/End for window creation\n        // Hint: Use world_->getAllEntities() for entity list\n    }\n    \nprivate:\n    void renderEntityList() {\n        // TODO 1: Get list of all alive entities\n        // TODO 2: Display entities in selectable list\n        // TODO 3: Update selected_entity_ when selection changes\n        // TODO 4: Show entity ID and generation for debugging\n        // Hint: Use ImGui::Selectable for entity selection\n    }\n    \n    void renderComponentList() {\n        if (selected_entity_ == INVALID_ENTITY) return;\n        \n        // TODO 1: Get component type registry\n        // TODO 2: For each registered component type, check if entity has it\n        // TODO 3: Display component values in expandable tree nodes\n        // TODO 4: Allow editing of component fields\n        // TODO 5: Show \"Add Component\" button for missing components\n        // Hint: Use reflection system to display component fields\n        // Hint: Use ImGui::TreeNode for component grouping\n    }\n    \n    void renderComponentEditor(ComponentTypeID typeID) {\n        // TODO 1: Get component type information from registry\n        // TODO 2: Get component data for selected entity\n        // TODO 3: Display editable fields based on component type\n        // TODO 4: Apply changes when values are modified\n        // TODO 5: Handle different field types appropriately\n        // Hint: Switch on component type to provide appropriate editors\n        // Hint: Use ImGui input widgets for different data types\n    }\n};\n```\n\n#### Language-Specific Hints\n\n**C++ Multi-Threading Considerations:**\n- Use `std::shared_mutex` for read-write locks allowing multiple readers\n- Consider `std::atomic` for simple shared variables to avoid lock overhead\n- Use `alignas(64)` on frequently accessed structures to prevent false sharing\n- Prefer `std::memory_order_relaxed` for performance counters that don't need strict ordering\n- Use thread-local storage for per-thread data to minimize synchronization\n\n**Memory Management:**\n- Use `std::unique_ptr` for automatic resource cleanup in complex systems\n- Consider custom allocators for high-frequency allocations like events\n- Use placement new for objects in pre-allocated memory pools\n- Implement RAII patterns for resource acquisition and release\n\n**Performance Optimization:**\n- Profile before optimizing - use tools like `perf`, Intel VTune, or built-in profilers\n- Batch operations to reduce function call overhead\n- Use structure-of-arrays layout for SIMD-friendly data access\n- Consider compile-time polymorphism (templates) over runtime polymorphism (virtual functions) in hot paths\n\n#### Milestone Checkpoints\n\n**Multi-Threading Extension Checkpoint:**\nAfter implementing parallel system execution:\n- Run: `cd build && cmake --build . --target test_parallel_systems && ./test_parallel_systems`\n- Expected output: \"Systems executed in N phases with M threads\" with timing comparisons\n- Verify: Create systems with read/write conflicts, ensure proper phase separation\n- Performance test: Measure execution time with 1 vs multiple threads, expect speedup for CPU-bound systems\n- Stress test: Run with many entities (10,000+) and verify no data races or crashes\n- Signs of issues: Random crashes, inconsistent results, performance regression, or deadlocks\n\n**Advanced Features Checkpoint:**\nAfter implementing hierarchy and event systems:\n- Run: `cd build && cmake --build . --target test_advanced_features && ./test_advanced_features`\n- Expected behavior: Hierarchical transforms update correctly, events fire when components change\n- Interactive test: Create parent-child entity relationships, move parent, verify children follow\n- Event test: Add/remove components, confirm appropriate events are generated and handled\n- Edge case test: Attempt circular references, deep hierarchies (100+ levels), rapid parent changes\n- Signs of issues: Stack overflow, infinite loops, missing events, or memory leaks\n\n**Development Tooling Checkpoint:**\nAfter implementing debug visualization and profiling:\n- Run: `cd build && cmake --build . --target debug_example && ./debug_example`\n- Expected output: Real-time window showing entity list, component values, and performance metrics\n- Interactive test: Select entities, modify component values, verify changes appear in game\n- Performance check: Enable/disable profiling, verify minimal impact when disabled\n- Memory test: Use debug tools to identify memory leaks or excessive allocations\n- Signs of issues: Significant performance impact, incorrect data display, or crashes when debugging\n\n**Integration Checkpoint:**\nAfter completing all extensions:\n- Run full test\n\n\n## Glossary\n\n> **Milestone(s):** All Milestones — comprehensive terminology reference for ECS architecture, data-oriented design concepts, and performance optimization terms used throughout the implementation\n\nUnderstanding ECS architecture requires mastery of specialized terminology spanning game engine design, performance optimization, and data structure concepts. This glossary provides comprehensive definitions organized by conceptual area to support learning throughout all project milestones.\n\n### Mental Model: Technical Dictionary with Cross-References\n\nThink of this glossary as a specialized technical dictionary where each term is connected to related concepts through cross-references and usage examples. Unlike a simple word list, each definition explains not just what a term means, but why it matters in the context of ECS architecture and how it relates to performance goals. The organization follows the conceptual flow from basic ECS principles through advanced optimization techniques.\n\n### Core ECS Terminology\n\nThe fundamental concepts that define Entity-Component-System architecture form the foundation for understanding all advanced topics.\n\n| Term | Definition | Usage Context |\n|------|------------|---------------|\n| **Entity** | A unique identifier representing a game object, containing only an ID and generation counter without data or behavior | Core abstraction in all ECS operations - represents players, bullets, enemies, etc. |\n| **Component** | Plain data structure containing information about one aspect of an entity, such as position, health, or velocity | Stored separately from entities in cache-friendly arrays for data-oriented design |\n| **System** | Logic that operates on entities having specific component combinations, implementing game behaviors like movement or rendering | Executes each frame, queries for entities with required components, processes them in batches |\n| **World** | ECS coordinator class that manages all entities, components, and systems, providing the main interface for ECS operations | Central hub that ties together Entity Manager, Component Storage, and System Manager |\n| **EntityID** | Unique 32-bit identifier for an entity, used as an index into various data structures throughout the ECS | Primary key for entity lookup - does not guarantee entity is still alive without generation checking |\n| **Generation** | Version number associated with each EntityID that increments when an entity is destroyed, preventing stale references | Critical for memory safety - prevents accessing recycled entity IDs that point to different entities |\n\n### Entity Management Concepts\n\nEntity lifecycle management requires specialized terminology for safe ID recycling and reference validation.\n\n| Term | Definition | Usage Context |\n|------|------------|---------------|\n| **Entity Lifecycle** | The complete sequence of entity creation, active usage, and destruction with proper cleanup of all associated data | Managed by EntityManager through createEntity(), component attachment, and destroyEntity() calls |\n| **Generation Counter** | Version number preventing stale entity references by incrementing whenever an EntityID is recycled for a new entity | Solves the ABA problem where recycled IDs could access wrong entity data without versioning |\n| **ID Recycling** | Reusing EntityIDs from destroyed entities to prevent unbounded growth of entity indices in long-running applications | Maintains dense entity arrays and prevents memory waste, essential for games running for hours |\n| **Stale Reference** | Entity reference pointing to a destroyed entity, potentially accessing wrong data if ID was recycled without generation checking | Common bug source - prevented by always validating Entity.generation matches current generation |\n| **Free List** | Queue of recycled EntityIDs available for assignment to new entities, enabling efficient ID reuse | Implemented as vector storing destroyed EntityIDs, processed during entity creation |\n| **ABA Problem** | Accessing wrong data when IDs are reused without versioning - thread A sees ID 5 pointing to entity X, ID gets recycled to entity Y, thread A accesses expecting X but gets Y | Solved by generation counters that change when IDs are recycled |\n| **Entity Validation** | Process of checking that an Entity reference is still valid by verifying the generation counter matches current value | Configurable safety checking from no validation (release) to comprehensive bounds checking (debug) |\n\n### Component Storage Architecture\n\nCache-friendly component storage requires understanding of specialized data structures and memory layout principles.\n\n| Term | Definition | Usage Context |\n|------|------------|---------------|\n| **Sparse Set** | Bidirectional mapping data structure using sparse and dense arrays to provide O(1) insert, remove, and lookup operations | Core of component storage - maps entity IDs to component array indices efficiently |\n| **Dense Array** | Contiguous storage containing actual component data for cache-friendly iteration over all components of a type | Where components live - enables SIMD processing and minimizes cache misses during system updates |\n| **Sparse Array** | Array indexed by EntityID that stores indices into the dense array, enabling constant-time entity-to-component lookup | Maps entity IDs to dense positions - uses SIZE_MAX as sentinel for \"no component\" |\n| **Bidirectional Mapping** | Data structure relationship allowing efficient translation in both directions - entity ID to component index and component index to entity ID | Enables both \"get component for entity\" and \"get entity for component\" operations in O(1) time |\n| **Swap-Remove** | Array removal technique that fills gaps by moving the last element to the removed position, maintaining dense packing | Prevents array fragmentation but changes element order - requires updating sparse array indices |\n| **Structure-of-Arrays** | Memory layout storing all instances of each component type in separate contiguous arrays rather than interleaving different types | Opposite of Array-of-Structures - enables cache-friendly iteration and SIMD vectorization |\n| **Cache Locality** | Organizing data so related information is stored close together in memory, minimizing CPU cache misses during access | Key performance principle - systems iterate over dense component arrays for maximum cache efficiency |\n\n### System Execution Framework\n\nSystem coordination and execution requires terminology for queries, scheduling, and data access patterns.\n\n| Term | Definition | Usage Context |\n|------|------------|---------------|\n| **Component Query** | Mechanism for finding entities that have specific combinations of component types, used by systems to locate relevant entities | Template-based specification like query<Position, Velocity>() returns iterator over matching entities |\n| **Query Iterator** | Template-based iterator that efficiently traverses entities matching a component query, providing tuple access to components | Dereferences to tuple<Position&, Velocity&> for type-safe component access during iteration |\n| **System Execution Framework** | Infrastructure coordinating system updates each frame, handling registration, ordering, and safe execution with error recovery | Manages system lifecycle, dependency ordering, and provides World and delta time to each system |\n| **Priority-Based Scheduling** | Execution ordering using integer priority values to ensure systems run in correct sequence each frame | Lower numbers execute first: input (100), logic (200), physics (300), rendering (500) |\n| **Assembly Line Stations** | Mental model for understanding systems as specialized processing stations that entities flow through each frame | Each system is a station that processes entities with required components, like factory assembly line |\n| **System Update Cycle** | Frame-by-frame execution flow where each system queries for entities, iterates over matches, and updates component data | Single frame: input → logic → physics → rendering, with delta time provided for time-based calculations |\n| **Deferred Modification Pattern** | Collecting component changes during iteration and applying them after iteration completes to prevent iterator invalidation | Prevents crashes from modifying containers while iterating - queue changes and apply in separate phase |\n\n### Performance and Optimization Terms\n\nHigh-performance ECS implementations require understanding of CPU cache behavior and memory access patterns.\n\n| Term | Definition | Usage Context |\n|------|------------|---------------|\n| **Cache Miss** | CPU cache lookup failure requiring slower main memory access, causing performance degradation | Primary performance enemy - random memory access patterns cause cache misses and performance drops |\n| **Cache Miss Ratio** | Percentage of memory accesses that fail to find data in CPU cache, requiring main memory access | Performance metric - lower ratios indicate better cache utilization and higher performance |\n| **SIMD Processing** | Single Instruction Multiple Data - CPU instructions that operate on multiple data elements simultaneously | Enabled by contiguous component arrays - process 4-8 positions simultaneously with vectorized instructions |\n| **Data-Oriented Design** | Programming methodology that organizes code around data access patterns rather than object relationships | ECS core principle - optimize for CPU cache behavior and memory bandwidth rather than code organization |\n| **Hot Path** | Frequently executed code sections where performance is critical, requiring minimal overhead and maximum optimization | Entity validation in system queries - use fastest validation level since it runs every frame |\n| **Memory Bandwidth** | Rate at which CPU can read data from main memory, often the bottleneck in data-intensive applications | Maximized by sequential memory access patterns enabled by dense component arrays |\n| **Prefetching** | CPU technique for loading data into cache before it's needed, based on predicted access patterns | Improved by predictable iteration patterns over contiguous component arrays |\n| **Performance Regression** | Code changes that reduce system performance compared to previous baseline measurements | Detected by benchmark infrastructure comparing current frame times to historical averages |\n\n### Advanced Archetype Concepts\n\nArchetype-based storage introduces additional terminology for entity grouping and cache optimization.\n\n| Term | Definition | Usage Context |\n|------|------------|---------------|\n| **Archetype** | Grouping entities by identical component combinations into shared storage structures for maximum cache efficiency | Entities with Position+Velocity components share one archetype, Position+Health share another |\n| **Component Mask** | Bitset indicating which component types are present in an archetype, used for fast archetype matching | 64-bit bitset where each bit represents one component type - enables fast subset/intersection operations |\n| **Archetype Transition** | Moving an entity between archetypes when components are added or removed, updating all storage structures | Adding Health component moves entity from Position+Velocity archetype to Position+Velocity+Health archetype |\n| **Chunk-Based Storage** | Fixed-size memory blocks storing multiple entities of the same archetype for cache-friendly linear iteration | 16KB chunks store multiple entities with their components co-located for optimal memory access patterns |\n| **Entity Stride** | Total memory size per entity including all component data within an archetype chunk | Calculated from component sizes and alignment - determines how many entities fit in each chunk |\n| **Archetype Explosion** | Performance problem from creating too many unique component combinations, fragmenting memory and complicating queries | Mitigated by component design that favors composition and shared component patterns |\n| **Chunk Utilization** | Percentage of chunk capacity filled with entities - higher utilization means better memory efficiency | Monitored to detect archetype fragmentation and optimize entity distribution across chunks |\n\n### Type Safety and Validation\n\nRobust ECS implementations require comprehensive type checking and validation terminology.\n\n| Term | Definition | Usage Context |\n|------|------------|---------------|\n| **Type Safety** | Compile-time and runtime guarantees that component access uses correct types, preventing data corruption | Template system ensures getComponent<Position>() returns Position& and catches type mismatches |\n| **Type Erasure** | Runtime polymorphism technique allowing storage and manipulation of different component types through common interface | IComponentStorage base class enables World to manage all component types without knowing specific types |\n| **Component Type Registry** | Singleton managing metadata for all component types including size, alignment, and constructor information | Maps ComponentTypeID to type information, enabling dynamic component operations and serialization |\n| **Type ID Verification** | Runtime checking that component access matches expected type information to prevent memory corruption | Validates that getComponent<Position>() is called on storage actually containing Position components |\n| **Validation Level** | Configurable amount of safety checking performed, from no validation (release) to comprehensive bounds checking (debug) | VALIDATION_NONE for performance, VALIDATION_COMPREHENSIVE for development debugging |\n| **Type Mismatch** | Runtime error where component access uses wrong type information, potentially causing memory corruption or crashes | Caught by type verification system and reported with detailed error information including entity ID |\n\n### Error Handling and Recovery\n\nRobust ECS systems require specialized error handling terminology for system failures and recovery.\n\n| Term | Definition | Usage Context |\n|------|------------|---------------|\n| **Circuit Breaker Pattern** | Error handling technique that isolates failing systems to prevent cascading failures throughout the ECS | Disables systems after error threshold exceeded, attempts recovery after timeout period |\n| **Error Threshold** | Maximum number of errors before a system is automatically disabled to prevent further damage | Configurable per system - critical systems might have higher thresholds than optional systems |\n| **Recovery Timeout** | Time period after system failure before attempting to re-enable the system and resume normal operation | Prevents rapid failure loops while allowing systems to recover from transient errors |\n| **System Health Monitoring** | Tracking system execution success/failure rates and performance metrics to detect problems early | Records error counts, execution times, and success rates for each system over time windows |\n| **Dependency Cascading** | Disabling dependent systems when their requirements fail, preventing execution with incomplete data | If physics system fails, disable collision detection system that depends on physics results |\n| **Resource Leak** | Failure to release memory, file handles, or other resources when systems encounter errors during cleanup | Prevented by RAII patterns and proper exception handling in component destructors |\n\n### Testing and Debugging Terminology\n\nComprehensive testing strategies require specialized terminology for validation and performance measurement.\n\n| Term | Definition | Usage Context |\n|------|------------|---------------|\n| **Integration Testing** | Testing component interactions together rather than in isolation to verify system-level behavior | Tests complete entity creation, component attachment, and system processing workflows |\n| **Checkpoint Testing** | Validation performed after each milestone completion to verify expected functionality before proceeding | Milestone 1: entity creation/destruction, Milestone 2: component attachment, etc. |\n| **Benchmark Infrastructure** | Tools and frameworks for measuring system performance and detecting regressions over time | Measures frame times, cache miss rates, and memory allocation patterns across development |\n| **Cache Performance Profiling** | Measuring CPU cache hit/miss ratios and memory access patterns to optimize data structures | Identifies performance bottlenecks from poor cache locality in component storage |\n| **System Execution Tracing** | Recording detailed information about system execution order, dependencies, and component access patterns | Helps debug system ordering issues and identify unnecessary dependencies between systems |\n| **Memory Corruption Detection** | Techniques for identifying invalid memory access, use-after-free errors, and buffer overruns in component data | Essential for debugging sparse set implementation and entity lifecycle management |\n| **Performance Baseline** | Reference measurements for system performance used to detect regressions in future development | Established after optimization work to ensure future changes don't degrade performance |\n\n### Data Structure Implementation Details\n\nLow-level implementation requires understanding of memory management and algorithmic complexity concepts.\n\n| Term | Definition | Usage Context |\n|------|------------|---------------|\n| **Sentinel Value** | Special value used to indicate invalid or missing data, such as SIZE_MAX for empty sparse set entries | INVALID_ENTITY_ID for invalid entities, SIZE_MAX for \"no component\" in sparse arrays |\n| **Memory Pool** | Pre-allocated memory blocks for efficient allocation of fixed-size objects like archetype chunks | ChunkAllocator manages pools of 16KB chunks to avoid frequent malloc/free operations |\n| **Iterator Invalidation** | Corruption of iterators when underlying containers are modified during iteration | Prevented by deferred modification pattern - collect changes during iteration, apply after |\n| **Template Parameter Pack** | Variadic template feature allowing functions to accept variable numbers of component types | Enables query<Position, Velocity, Health>() with compile-time type safety for any component combination |\n| **Const-Correctness** | C++ principle ensuring read-only access through const references and methods where data shouldn't be modified | getComponent<const Position>() for read-only access, getComponent<Position>() for read-write |\n| **RAII** | Resource Acquisition Is Initialization - C++ idiom ensuring resources are properly cleaned up when objects are destroyed | Component destructors automatically called during entity destruction, prevents resource leaks |\n| **Move Semantics** | C++ feature for efficient transfer of resources without copying, important for component storage operations | addComponent<Position>(entity, std::move(position)) transfers ownership efficiently |\n\n### Game Development Context\n\nECS terminology specific to game engine architecture and real-time systems.\n\n| Term | Definition | Usage Context |\n|------|------------|---------------|\n| **Frame** | Single update cycle of the game loop, typically targeting 60 FPS (16.67ms per frame) | Each frame executes all systems in priority order with current delta time |\n| **Delta Time** | Time elapsed since the last frame, passed to systems for time-based calculations like movement and animation | Enables frame-rate independent game logic - move velocity * deltaTime pixels per frame |\n| **Game Object** | Traditional OOP representation of game entities, replaced by Entity+Components in ECS architecture | Player, Enemy, Bullet objects become entities with Position, Health, Sprite components |\n| **Update Loop** | Main game loop that repeatedly executes system updates, input processing, and rendering each frame | while(running) { input.update(); logic.update(); render.update(); } pattern |\n| **Real-Time Constraints** | Performance requirements ensuring game maintains target frame rate without stuttering or lag | Systems must complete processing within frame time budget (16.67ms for 60 FPS) |\n| **Asset Management** | Loading and managing game resources like textures, sounds, and models referenced by components | Components store resource IDs rather than raw data - actual assets managed separately |\n\n### Common Anti-Patterns and Pitfalls\n\nUnderstanding what NOT to do is crucial for successful ECS implementation.\n\n| Term | Definition | Usage Context |\n|------|------------|---------------|\n| **Thick Entities** | Anti-pattern where entities contain logic or data instead of being pure IDs, defeating ECS performance benefits | Avoid Entity classes with update() methods - keep entities as lightweight ID+generation pairs |\n| **Component Dependencies** | Anti-pattern where components reference or depend on other components, creating tight coupling | Avoid Position component storing Velocity* - use systems to coordinate between component types |\n| **System Communication** | Anti-pattern where systems directly call each other instead of communicating through component data | Systems should be independent - communicate through component state changes, not method calls |\n| **Premature Optimization** | Implementing complex optimizations like archetypes before measuring performance and identifying bottlenecks | Start with simple sparse sets, profile performance, then optimize only proven bottlenecks |\n| **String-Based Queries** | Anti-pattern using string names for component types instead of compile-time type checking | Avoid query(\"Position\", \"Velocity\") - use query<Position, Velocity>() for type safety |\n| **Singleton Components** | Anti-pattern using components to store global state that should live outside the ECS | Game configuration belongs in separate managers, not as components on special entities |\n\n### Implementation Guidance\n\nThe terminology defined above enables precise communication about ECS concepts throughout implementation. This comprehensive vocabulary supports learning progression from basic entity management through advanced archetype optimization.\n\n#### Essential Terms by Milestone\n\n**Milestone 1 (Entity Manager):** Entity, EntityID, Generation, Entity Lifecycle, Generation Counter, ID Recycling, Stale Reference, Free List, ABA Problem, Entity Validation\n\n**Milestone 2 (Component Storage):** Component, Sparse Set, Dense Array, Sparse Array, Bidirectional Mapping, Swap-Remove, Structure-of-Arrays, Cache Locality, Type Safety, Component Type Registry\n\n**Milestone 3 (System Interface):** System, Component Query, Query Iterator, System Execution Framework, Priority-Based Scheduling, System Update Cycle, Deferred Modification Pattern\n\n**Milestone 4 (Archetypes):** Archetype, Component Mask, Archetype Transition, Chunk-Based Storage, Entity Stride, Archetype Explosion, Chunk Utilization\n\n#### Performance-Related Term Clusters\n\nUnderstanding performance requires mastery of related terminology groups:\n\n**Cache Performance:** Cache Miss, Cache Miss Ratio, Cache Locality, Memory Bandwidth, Prefetching, Hot Path, Performance Regression\n\n**Memory Management:** Memory Pool, Sentinel Value, RAII, Move Semantics, Resource Leak, Iterator Invalidation\n\n**Data Access Patterns:** Structure-of-Arrays, Dense Array, SIMD Processing, Data-Oriented Design, Contiguous Storage\n\n#### Error Handling Term Relationships\n\nRobust implementation requires understanding error handling terminology connections:\n\n**Validation:** Entity Validation, Type Safety, Type ID Verification, Validation Level, Type Mismatch\n\n**Recovery:** Circuit Breaker Pattern, Error Threshold, Recovery Timeout, System Health Monitoring, Dependency Cascading\n\n**Testing:** Integration Testing, Checkpoint Testing, Benchmark Infrastructure, Memory Corruption Detection\n\nThis glossary serves as both a learning resource during implementation and a reference for maintaining consistent terminology across the codebase. Each term definition includes not just the meaning, but the context and rationale for its importance in ECS architecture.\n"}