{"html":"<h1 id=\"-project-charter-filesystem-implementation\">ðŸŽ¯ Project Charter: Filesystem Implementation</h1>\n<h2 id=\"what-you-are-building\">What You Are Building</h2>\n<p>You are building a fully functional, on-disk, inode-based filesystem that integrates directly with the Linux kernel via FUSE. Unlike a simple memory-based simulation, your filesystem will store data in a persistent 4KB-block-aligned disk image, support multi-level indirect block pointers for large files, provide a hierarchical directory tree, and implement a circular write-ahead journal (WAL) to ensure metadata remains consistent even if the power is cut mid-write.</p>\n<h2 id=\"why-this-project-exists\">Why This Project Exists</h2>\n<p>Most developers treat the filesystem as a reliable, infinite, byte-addressable array, but storage hardware is actually a rigid, finite collection of blocks. Building a filesystem from scratch forces you to bridge this gap manually. You will learn to negotiate the &quot;read-modify-write&quot; cycles inherent in SSDs, implement the same indirection logic used in CPU page tables, and master the atomic commit protocols that prevent data corruption in production databases like PostgreSQL and SQLite.</p>\n<h2 id=\"what-you-will-be-able-to-do-when-done\">What You Will Be Able to Do When Done</h2>\n<ul>\n<li><strong>Design on-disk layouts:</strong> Calculate exactly where superblocks, bitmaps, and inode tables live on a raw device.</li>\n<li><strong>Manage multi-level indirection:</strong> Implement direct, single-indirect, and double-indirect pointers to address files up to 4GB.</li>\n<li><strong>Implement Path Resolution:</strong> Build the recursion logic that translates strings like <code>/home/user/file.txt</code> into specific inode identifiers.</li>\n<li><strong>Expose Userspace Filesystems:</strong> Use the FUSE API to mount your code as a real Linux mount point accessible by <code>ls</code>, <code>cp</code>, and <code>vim</code>.</li>\n<li><strong>Guarantee Crash Consistency:</strong> Build a write-ahead journal that can replay committed transactions after a simulated system crash.</li>\n</ul>\n<h2 id=\"final-deliverable\">Final Deliverable</h2>\n<p>A complete C or Rust system consisting of ~4,000 lines of code across two primary binaries:</p>\n<ol>\n<li><strong><code>mkfs</code></strong>: A formatting tool that initializes raw files into valid filesystem images.</li>\n<li><strong><code>myfs</code></strong>: A FUSE daemon that mounts the image. \nThe system is complete when you can mount your filesystem, copy a git repository into it, <code>SIGKILL</code> the process during a write, and see the filesystem recover perfectly upon remounting.</li>\n</ol>\n<h2 id=\"is-this-project-for-you\">Is This Project For You?</h2>\n<p><strong>You should start this if you:</strong></p>\n<ul>\n<li>Are comfortable with C or Rust, specifically manual memory management and pointers.</li>\n<li>Understand bitwise operations (masks, shifts) for bitmap manipulation.</li>\n<li>Have a basic grasp of POSIX File I/O (<code>open</code>, <code>lseek</code>, <code>read</code>, <code>write</code>).</li>\n</ul>\n<p><strong>Come back after you&#39;ve learned:</strong></p>\n<ul>\n<li><strong>Struct Packing:</strong> Understanding how compilers align data in memory (e.g., <code>__attribute__((packed))</code>).</li>\n<li><strong>Basic Data Structures:</strong> You must be comfortable with linked lists and tree-like traversal.</li>\n</ul>\n<h2 id=\"estimated-effort\">Estimated Effort</h2>\n<table>\n<thead>\n<tr>\n<th>Phase</th>\n<th>Time</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Phase 1:</strong> Block Layer and mkfs</td>\n<td>~12 hours</td>\n</tr>\n<tr>\n<td><strong>Phase 2:</strong> Inode Management</td>\n<td>~12 hours</td>\n</tr>\n<tr>\n<td><strong>Phase 3:</strong> Directory Operations</td>\n<td>~12 hours</td>\n</tr>\n<tr>\n<td><strong>Phase 4:</strong> File Read/Write Operations</td>\n<td>~12 hours</td>\n</tr>\n<tr>\n<td><strong>Phase 5:</strong> FUSE Integration</td>\n<td>~12 hours</td>\n</tr>\n<tr>\n<td><strong>Phase 6:</strong> Write-Ahead Journaling</td>\n<td>~15 hours</td>\n</tr>\n<tr>\n<td><strong>Total</strong></td>\n<td><strong>~75 hours</strong></td>\n</tr>\n</tbody></table>\n<h2 id=\"definition-of-done\">Definition of Done</h2>\n<p>The project is complete when:</p>\n<ul>\n<li>The <code>mkfs</code> tool generates an image that passes a validation script checking superblock magic numbers and root directory invariants.</li>\n<li>The filesystem can be mounted via FUSE and supports standard Unix commands (<code>ls -la</code>, <code>mkdir</code>, <code>rm</code>, <code>cp</code>, <code>mv</code>).</li>\n<li>The system correctly handles &quot;sparse files,&quot; where seeking past EOF and writing does not consume physical disk blocks for the gap.</li>\n<li>A &quot;Crash Test&quot; script successfully triggers a <code>SIGKILL</code> during a metadata-heavy operation, and <code>journal_recover</code> restores the filesystem to a consistent state on the next mount.</li>\n<li>All internal consistency checks (assertions on block numbers and link counts) pass under a concurrent workload of at least 4 threads.</li>\n</ul>\n<hr>\n<h1 id=\"filesystem-implementation-an-interactive-atlas\">Filesystem Implementation: An Interactive Atlas</h1>\n<p>This project builds a complete inode-based filesystem from raw blocks up through FUSE mounting and write-ahead journaling. You will start with nothing but a flat file acting as a disk image, and layer increasingly sophisticated abstractions: block I/O, bitmap allocation, inode metadata with multi-level indirection, directory trees with path resolution, full POSIX-like file operations, real OS integration via FUSE, and finally crash-consistent journaling. Each layer reveals how the operating system transforms a dumb array of 4KB blocks into the rich tree of files and directories that every program takes for granted.</p>\n<p>The atlas is structured so that each milestone shatters a common misconception about how filesystems work, then cascades that insight into 3-5 connected domains. By the end, you won&#39;t just have a working filesystem â€” you&#39;ll understand why databases use WAL, why SSDs have FTLs, why <code>fsync</code> matters, and why every storage system on earth is really just a block allocator with opinions.</p>\n<!-- MS_ID: filesystem-m1 -->\n<h1 id=\"milestone-1-block-layer-and-mkfs\">Milestone 1: Block Layer and mkfs</h1>\n<h2 id=\"the-disk-does-not-know-you-exist\">The Disk Does Not Know You Exist</h2>\n<p>You have written thousands of files. You have called <code>fopen</code>, <code>fwrite</code>, <code>fclose</code> without thinking twice. You have an intuition â€” a reasonable one â€” that when you write &quot;Hello&quot; to a file, those five bytes land somewhere on the disk in sequence, and the OS just keeps track of where they are.\nThat intuition is completely wrong.\nThe disk has no concept of your file. It has no concept of bytes. It has no concept of names, paths, or even the idea that one chunk of data &quot;belongs together.&quot; The disk is a machine that answers exactly two questions: &quot;Give me block number N&quot; and &quot;Store these bytes at block number N.&quot; Block N is always the same size â€” 4,096 bytes â€” and the disk treats all of them identically. Block 7 is not more important than block 7,000,000. They are interchangeable containers.\nEverything you have ever experienced as a &quot;file&quot; â€” its name, its size, its permissions, the fact that its contents are logically contiguous even when physically scattered â€” is a fiction maintained entirely by software. The filesystem is the author of that fiction. And this milestone is where you learn to write it from scratch.</p>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m1-before-after-mkfs.svg\" alt=\"Before/After mkfs â€” Raw vs. Formatted\"></p>\n<hr>\n<h2 id=\"the-fundamental-tension-fixed-blocks-vs-variable-reality\">The Fundamental Tension: Fixed Blocks vs. Variable Reality</h2>\n<p>[[EXPLAIN:block-device-abstraction-â€”-why-disks-speak-in-fixed-size-blocks,-not-bytes|Block device abstraction â€” why disks speak in fixed-size blocks, not bytes]]\nHere is the core hardware constraint you are negotiating with for this entire project:\n<strong>Storage hardware speaks in fixed, aligned blocks. Software demands arbitrary byte ranges.</strong>\nA spinning magnetic disk reads and writes in sectors (typically 512 bytes, modern &quot;Advanced Format&quot; drives: 4,096 bytes). The read/write head sweeps across a platter â€” you cannot tell it to read 5 bytes starting at byte offset 7,234. You must read the entire sector containing those bytes, modify what you need in memory, and write the entire sector back. This is called a <strong>read-modify-write cycle</strong>, and you will encounter it in every layer of this project.\nSSDs are even more constrained. NAND flash cells can only be written in &quot;pages&quot; (4â€“16 KB) and only erased in larger &quot;blocks&quot; (128â€“512 KB). The SSD&#39;s internal controller â€” called the Flash Translation Layer (FTL) â€” hides these constraints behind a block interface identical to what a spinning disk presents.</p>\n<blockquote>\n<p>The numbers that matter:</p>\n<ul>\n<li>A read of any size within one 4KB block = 1 disk I/O operation</li>\n<li>Two reads that span a 4KB boundary = 2 disk I/O operations</li>\n<li>Misaligned access that crosses block boundaries = double the cost\nYour filesystem inherits this constraint from below. You will define a block size of 4,096 bytes (4KB). Everything you store â€” superblock metadata, bitmaps, inode tables, directory entries, file data â€” must be packed into an integer number of 4KB blocks. Nothing lives between blocks. Nothing spans blocks unless you explicitly manage it.\nThis is the deal. Let&#39;s build around it.</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"the-disk-image-a-file-that-pretends-to-be-a-disk\">The Disk Image: A File That Pretends to Be a Disk</h2>\n<p>You do not have a spare disk lying around for development. You don&#39;t need one. A regular file on your host OS can serve as a perfectly faithful disk simulation. You will open a file (<code>disk.img</code>), and every 4KB region within that file corresponds to one block.</p>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m1-block-device-abstraction.svg\" alt=\"Block Device â€” read_block/write_block Translation\"></p>\n<p>This is your block device abstraction. Two functions. Nothing else:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> read_block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> block_num</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> write_block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> block_num</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<p><code>fd</code> is the open file descriptor of your disk image. <code>block_num</code> is the logical address. <code>buf</code> is exactly <code>BLOCK_SIZE</code> (4,096) bytes. The implementation is a seek followed by a read or write:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BLOCK_SIZE</span><span style=\"color:#79B8FF\">   4096</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> SECTOR_SIZE</span><span style=\"color:#79B8FF\">  512</span><span style=\"color:#6A737D\">   /* kept for reference; we use BLOCK_SIZE units */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> read_block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> block_num</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    off_t</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">off_t</span><span style=\"color:#E1E4E8\">)block_num </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">lseek</span><span style=\"color:#E1E4E8\">(fd, offset, SEEK_SET) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">off_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">errno;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> read</span><span style=\"color:#E1E4E8\">(fd, buf, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (n </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (n </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">errno </span><span style=\"color:#F97583\">:</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> write_block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> block_num</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    off_t</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">off_t</span><span style=\"color:#E1E4E8\">)block_num </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">lseek</span><span style=\"color:#E1E4E8\">(fd, offset, SEEK_SET) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">off_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">errno;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> write</span><span style=\"color:#E1E4E8\">(fd, buf, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (n </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (n </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">errno </span><span style=\"color:#F97583\">:</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Every single operation in this project â€” reading a superblock, scanning a bitmap, fetching an inode, reading file data â€” will eventually call one of these two functions. They are the bedrock. Everything above them is metadata management.</p>\n<blockquote>\n<p><strong>Hardware Soul</strong>: What happens when <code>read_block</code> executes? Your host OS&#39;s VFS layer intercepts the <code>read</code> syscall. The kernel checks the page cache â€” if the 4KB chunk is already cached in RAM, no disk I/O occurs; the data is copied from kernel memory to your buffer in nanoseconds. If it&#39;s not cached (cold miss), the kernel submits a block I/O request, the disk controller fetches the sector(s), the data lands in a kernel buffer, and then gets copied to your process. That cold miss costs 50â€“150 Î¼s on an SSD, or 5â€“10 ms on a spinning disk. Your block abstraction hides this, but the latency is always there underneath.\n<strong>Pitfall to avoid</strong>: Always validate <code>block_num &lt; total_blocks</code> before calling into these functions. A bug that passes <code>block_num = 3,000,000</code> into a disk image with only 1,000 blocks will happily seek to byte offset 12 billion and either hit EOF or extend the file. Add a bounds check:</p>\n</blockquote>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Always called before read_block / write_block */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> validate_block_num</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> block_num</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> total_blocks</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (block_num </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> total_blocks) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"on-disk-layout-the-filesystem-as-a-database\">On-Disk Layout: The Filesystem as a Database</h2>\n<p>You have a flat array of 4KB blocks. Your filesystem needs to store several kinds of data:</p>\n<ol>\n<li><strong>The filesystem&#39;s own description</strong> â€” how big is it? how many inodes? where do things live? â†’ <strong>Superblock</strong></li>\n<li><strong>Which blocks are free and which are in use?</strong> â†’ <strong>Block Bitmap</strong></li>\n<li><strong>Which inode numbers are free and which are in use?</strong> â†’ <strong>Inode Bitmap</strong></li>\n<li><strong>The actual inode structures</strong> (file metadata: size, permissions, block pointers) â†’ <strong>Inode Table</strong></li>\n<li><strong>The journal</strong> (for crash recovery in Milestone 6) â†’ <strong>Journal Region</strong></li>\n<li><strong>The actual file and directory data</strong> â†’ <strong>Data Blocks</strong>\nThese must be arranged in a specific order in the block array, and every component must know where to find every other component. The superblock is the bootstrap record that makes this possible â€” it stores the positions and sizes of everything else.</li>\n</ol>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m1-disk-layout.svg\" alt=\"On-Disk Layout â€” Complete Block Map\"></p>\n<p>Here is the layout we will use:</p>\n<table>\n<thead>\n<tr>\n<th>Block Range</th>\n<th>Contents</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Block 0</td>\n<td>Superblock</td>\n</tr>\n<tr>\n<td>Block 1</td>\n<td>Block Bitmap (tracks data blocks)</td>\n</tr>\n<tr>\n<td>Block 2</td>\n<td>Inode Bitmap</td>\n</tr>\n<tr>\n<td>Blocks 3â€“N</td>\n<td>Inode Table (N depends on inode count)</td>\n</tr>\n<tr>\n<td>Blocks N+1â€“M</td>\n<td>Journal Region</td>\n</tr>\n<tr>\n<td>Blocks M+1â€“end</td>\n<td>Data Blocks</td>\n</tr>\n<tr>\n<td>The exact values of N and M are computed from the superblock fields â€” which means you need to understand the superblock first.</td>\n<td></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"the-superblock-your-filesystem39s-birth-certificate\">The Superblock: Your Filesystem&#39;s Birth Certificate</h2>\n<p>[[EXPLAIN:on-disk-serialization-â€”-packing-structs-to-exact-byte-layouts-with-fixed-width-types|On-disk serialization â€” packing structs to exact byte layouts with fixed-width types]]\nThe superblock lives in block 0. It is the first thing read when you mount the filesystem, and the source of truth for every other layout calculation. If the superblock is corrupted, the filesystem is unreadable â€” there is no way to find anything else.\nHere is every field and why it exists:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> FS_MAGIC</span><span style=\"color:#F97583\">        0x</span><span style=\"color:#79B8FF\">DEADC0DE</span><span style=\"color:#6A737D\">   /* arbitrary identifier; proves this is OUR filesystem */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> FS_VERSION</span><span style=\"color:#79B8FF\">      1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BLOCK_SIZE</span><span style=\"color:#79B8FF\">      4096</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> INODE_SIZE</span><span style=\"color:#79B8FF\">      128</span><span style=\"color:#6A737D\">          /* bytes per inode; must divide evenly into BLOCK_SIZE */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> INODES_PER_BLOCK</span><span style=\"color:#E1E4E8\"> (BLOCK_SIZE </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> INODE_SIZE)</span><span style=\"color:#6A737D\">   /* 32 inodes per block */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Superblock â€” always resides in block 0.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * BYTE LAYOUT (all little-endian, packed):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset  0: magic           (4 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset  4: version         (4 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset  8: block_size      (4 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 12: total_blocks    (4 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 16: total_inodes    (4 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 20: free_blocks     (4 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 24: free_inodes     (4 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 28: inode_table_start (4 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 32: inode_table_blocks (4 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 36: journal_start   (4 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 40: journal_blocks  (4 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 44: data_block_start (4 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 48: root_inode      (4 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   ...reserved...             (4044 bytes to fill block)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Total: 4096 bytes (1 block)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#B392F0\"> __attribute__</span><span style=\"color:#E1E4E8\">((packed)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> magic;</span><span style=\"color:#6A737D\">              /* must equal FS_MAGIC to be a valid filesystem */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> version;</span><span style=\"color:#6A737D\">            /* filesystem format version */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> block_size;</span><span style=\"color:#6A737D\">         /* always BLOCK_SIZE (4096) â€” stored for validation */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> total_blocks;</span><span style=\"color:#6A737D\">       /* total number of blocks in the image */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> total_inodes;</span><span style=\"color:#6A737D\">       /* maximum number of inodes */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> free_blocks;</span><span style=\"color:#6A737D\">        /* count of currently unallocated data blocks */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> free_inodes;</span><span style=\"color:#6A737D\">        /* count of currently unallocated inodes */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> inode_table_start;</span><span style=\"color:#6A737D\">  /* block number where inode table begins */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> inode_table_blocks;</span><span style=\"color:#6A737D\"> /* how many blocks the inode table occupies */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> journal_start;</span><span style=\"color:#6A737D\">      /* block number where journal region begins */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> journal_blocks;</span><span style=\"color:#6A737D\">     /* how many blocks the journal occupies */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> data_block_start;</span><span style=\"color:#6A737D\">   /* block number where data blocks begin */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> root_inode;</span><span style=\"color:#6A737D\">         /* inode number of the root directory (/) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\">  reserved</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 52</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\"> /* pad to exactly one block */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n<blockquote>\n<p><strong>Why <code>__attribute__((packed))</code>?</strong> The C compiler inserts invisible padding bytes between struct fields to align them to their natural size (a <code>uint32_t</code> is normally aligned to a 4-byte boundary). When you write this struct to disk and read it back on a different system â€” or even the same system after recompilation â€” padding bytes may shift. <code>__attribute__((packed))</code> tells GCC/Clang to remove all padding: every field occupies exactly the bytes you declared. This is mandatory for any struct that lives on disk. The tradeoff: packed struct access may generate slower unaligned memory reads on some architectures. For disk I/O, this is irrelevant.</p>\n</blockquote>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m1-superblock-struct.svg\" alt=\"Superblock Structure â€” Byte-Level Memory Layout\"></p>\n<p><strong>The magic number</strong> deserves special attention. <code>0xDEADC0DE</code> is not just vanity â€” it is a safety gate. When you implement mounting, the very first check is:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (sb.magic </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> FS_MAGIC) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Not a valid filesystem image (bad magic: 0x</span><span style=\"color:#79B8FF\">%08X</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, sb.magic);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Without this check, your filesystem code will happily interpret a random file, a truncated image, or a different filesystem format as valid â€” and then corrupt it. Every filesystem has a magic number: ext4 uses <code>0xEF53</code>, FAT32 uses <code>0x28</code> at offset 66, XFS uses <code>&quot;XFSB&quot;</code> as ASCII bytes.\n<strong>Layout calculations</strong> â€” all positions are derived from the superblock, computed once during <code>mkfs</code> and stored:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Given: total_blocks, total_inodes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Compute: all region positions */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> compute_layout</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> total_blocks</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> total_inodes</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                            superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sb->block_size      </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sb->total_blocks    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> total_blocks;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sb->total_inodes    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> total_inodes;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Fixed positions */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Block 0: superblock (already implicit) */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Block 1: block bitmap */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Block 2: inode bitmap */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> inode_table_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> inode_table_blocks </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (total_inodes </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> INODES_PER_BLOCK </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                   /</span><span style=\"color:#E1E4E8\"> INODES_PER_BLOCK;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* e.g., 1024 inodes / 32 per block = 32 blocks for inode table */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> journal_start  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inode_table_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> inode_table_blocks;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> journal_blocks </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* 4MB journal; tune as needed */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> data_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> journal_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> journal_blocks;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sb->inode_table_start  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inode_table_start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sb->inode_table_blocks </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inode_table_blocks;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sb->journal_start      </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> journal_start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sb->journal_blocks     </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> journal_blocks;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sb->data_block_start   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> data_start;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Free counts: subtract everything used by metadata */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sb->free_blocks </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> total_blocks </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> data_start;</span><span style=\"color:#6A737D\">  /* data blocks only */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sb->free_inodes </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> total_inodes </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">            /* inode 1 reserved for root */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sb->root_inode  </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sb->magic       </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> FS_MAGIC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sb->version     </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> FS_VERSION;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<blockquote>\n<p><strong>Off-by-one protection</strong>: Notice <code>free_blocks = total_blocks - data_start</code>. This is exact â€” it means blocks 0 through <code>data_start - 1</code> are all metadata and are never treated as allocatable data blocks. The block bitmap only tracks data blocks, so bitmap bit 0 corresponds to disk block <code>data_block_start</code>, not disk block 0. This offset must be applied consistently everywhere â€” allocating from the bitmap gives you a <em>data block index</em>, which you add to <code>data_block_start</code> to get the actual disk block number.</p>\n</blockquote>\n<hr>\n<h2 id=\"bitmaps-one-bit-per-block-two-states-of-truth\">Bitmaps: One Bit per Block, Two States of Truth</h2>\n<p>[[EXPLAIN:bitmap-data-structure-â€”-bit-level-allocation-tracking|Bitmap data structure â€” bit-level allocation tracking]]\nTo track which blocks and inodes are free, you need a data structure that is:</p>\n<ol>\n<li><strong>Compact</strong> â€” tracking 1,000,000 blocks should not cost 1,000,000 bytes</li>\n<li><strong>Fast to scan</strong> â€” finding the first free block must be quick</li>\n<li><strong>Easy to update</strong> â€” marking a block used or free must be a simple write\nA bitmap satisfies all three. One bit per tracked item: <code>0</code> means free, <code>1</code> means used. 4KB of bitmap = 4096 Ã— 8 = 32,768 bits = 32,768 blocks tracked. A filesystem with 1 million data blocks needs only 32 bitmap blocks (~128KB) to track them all.</li>\n</ol>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m1-bitmap-ops.svg\" alt=\"Bitmap Allocation â€” Bit-Level Operations\"></p>\n<p>Your block bitmap lives in block 1. It is allocated exactly one block (4KB = 32,768 bits), which limits your filesystem to 32,768 data blocks (128MB). For a learning project, this is fine. Real filesystems use multiple bitmap blocks per block group (ext4) or more sophisticated free space trees (XFS, Btrfs).</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Bitmap operations.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * The bitmap is stored in memory as uint8_t[BLOCK_SIZE].</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Each bit corresponds to one block or inode.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Bit layout within a byte (standard, big-endian bit order):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   byte[0] bit 7 â†’ index 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   byte[0] bit 6 â†’ index 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   ...</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   byte[0] bit 0 â†’ index 7</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   byte[1] bit 7 â†’ index 8</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   ...</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * We use the simpler little-endian bit order here:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   byte[i / 8] bit (i % 8)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Test whether bit at index is set (1 = used) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> bitmap_test</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> uint8_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">bitmap</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> index</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bitmap</span><span style=\"color:#E1E4E8\">[index </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> (index </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">)) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Set bit at index (mark as used) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> bitmap_set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">bitmap</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> index</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    bitmap</span><span style=\"color:#E1E4E8\">[index </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> (index </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Clear bit at index (mark as free) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> bitmap_clear</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">bitmap</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> index</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    bitmap</span><span style=\"color:#E1E4E8\">[index </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> (index </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Find the first free bit in the bitmap.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns the index of the first 0 bit, or -1 if all bits are set (full).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Optimization: scan byte-by-byte first; skip fully-used bytes (0xFF) fast.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> bitmap_find_free</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> uint8_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">bitmap</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> total_items</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> num_bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (total_items </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 7</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> byte_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; byte_idx </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> num_bytes; byte_idx</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bitmap</span><span style=\"color:#E1E4E8\">[byte_idx] </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FF</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* all 8 bits used â€” skip entire byte */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* At least one free bit in this byte; find which one */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> bit </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; bit </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">; bit</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint32_t</span><span style=\"color:#E1E4E8\"> index </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> byte_idx </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> bit;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (index </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> total_items) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* ran past the valid range */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#FFAB70\">bitmap</span><span style=\"color:#E1E4E8\">[byte_idx] </span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> bit) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)index;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* bitmap full */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><strong>Block allocation in full context</strong> â€” combining disk I/O with bitmap logic:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Allocate a data block. Returns disk block number, or -1 on failure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * The block bitmap is in disk block 1 (BLOCK_BITMAP_BLOCK).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BLOCK_BITMAP_BLOCK</span><span style=\"color:#79B8FF\">  1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> INODE_BITMAP_BLOCK</span><span style=\"color:#79B8FF\">  2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> alloc_block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> bitmap</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 1: Load the block bitmap from disk */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, BLOCK_BITMAP_BLOCK, bitmap) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 2: Find a free bit */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> data_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> bitmap_find_free</span><span style=\"color:#E1E4E8\">(bitmap, sb->free_blocks </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                    (sb->total_blocks </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> sb->data_block_start </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                     -</span><span style=\"color:#E1E4E8\"> sb->free_blocks));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Simpler: track total data blocks separately */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> data_blocks_total </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sb->total_blocks </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> sb->data_block_start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> bitmap_find_free</span><span style=\"color:#E1E4E8\">(bitmap, data_blocks_total);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (data_idx </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* disk full */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 3: Mark it used */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    bitmap_set</span><span style=\"color:#E1E4E8\">(bitmap, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)data_idx);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 4: Write bitmap back to disk â€” MUST happen before returning */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, BLOCK_BITMAP_BLOCK, bitmap) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 5: Update superblock free count */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sb->free_blocks</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Note: caller must persist the superblock update too */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 6: Return the DISK block number (offset by data_block_start) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)(sb->data_block_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)data_idx);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Free a data block. disk_block_num is the actual disk block number.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> free_block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> disk_block_num</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (disk_block_num </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> sb->data_block_start </span><span style=\"color:#F97583\">||</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        disk_block_num </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> sb->total_blocks) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span><span style=\"color:#6A737D\">  /* cannot free a metadata block */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> bitmap</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, BLOCK_BITMAP_BLOCK, bitmap) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> data_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> disk_block_num </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> sb->data_block_start;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    bitmap_clear</span><span style=\"color:#E1E4E8\">(bitmap, data_idx);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, BLOCK_BITMAP_BLOCK, bitmap) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sb->free_blocks</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>The inode bitmap is identical in structure, just stored in block 2 and tracking inode numbers rather than data blocks. Implement <code>alloc_inode</code> and <code>free_inode</code> the same way, substituting <code>INODE_BITMAP_BLOCK</code> and <code>sb-&gt;total_inodes</code>.</p>\n<blockquote>\n<p><strong>Hardware Soul â€” Bitmap Scan Performance</strong>: The <code>bitmap_find_free</code> function scans sequentially. This is intentional: sequential memory access is extremely cache-friendly. Your entire block bitmap fits in a single 4KB block â€” which fits in a single L1 cache line fetch (actually 64 L1 cache lines at 64 bytes each, but the sequential scan will prefetch them automatically). Scanning 32,768 bits sequentially is ~4,000 byte comparisons â€” at 32 bytes per cycle, under 200 CPU cycles, under 100ns. The disk read to load the bitmap is 1000Ã— slower. The bitmap scan itself is never the bottleneck.\n<strong>Why not a free list instead?</strong> A linked list of free blocks (used by early Unix filesystems) has O(1) allocation but requires updating two disk blocks per allocation (the list head block and the freed/allocated block). Scanning a full bitmap has O(n) worst case but O(1) in practice for nearly-empty filesystems. The bigger win: bitmaps are trivially crash-recoverable â€” you can reconstruct the correct bitmap by scanning all inodes.</p>\n</blockquote>\n<hr>\n<h2 id=\"designing-for-crash-safety-the-two-write-problem\">Designing for Crash Safety: The Two-Write Problem</h2>\n<p>Before writing <code>mkfs</code>, you need to internalize one consequence of working with blocks that will affect every write operation you ever implement:\n<strong>A crash between two writes leaves the filesystem in an inconsistent state.</strong>\nExample: to allocate block 500, you must:</p>\n<ol>\n<li>Set bit 500 in the block bitmap (marks it used)</li>\n<li>Update the inode&#39;s block pointer to point to 500\nIf the power dies between step 1 and step 2, you now have a block that is marked as used but that no inode points to â€” a <strong>leaked block</strong>. If the power dies between step 2 and step 1 (if you do it in the other order), you have a block that an inode thinks it owns but that is also marked free â€” which means it could be allocated to a different file, causing <strong>data corruption</strong>.\nThis is the crash consistency problem. Milestone 6 solves it properly with journaling. For now, establish the discipline: <strong>always write to the bitmap before writing to the structure that references it</strong>. When in doubt, bitmap first.</li>\n</ol>\n<hr>\n<h2 id=\"mkfs-formatting-the-raw-image\">mkfs: Formatting the Raw Image</h2>\n<p><code>mkfs</code> stands for &quot;make filesystem.&quot; It is the tool that transforms a raw, unformatted file (a flat blob of zeros) into a valid filesystem that your code can mount and operate on. Every filesystem has one: <code>mkfs.ext4</code>, <code>mkfs.xfs</code>, <code>mkfs.fat</code>.\nYour <code>mkfs</code> must perform these operations in order:</p>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m1-mkfs-sequence.svg\" alt=\"mkfs Initialization Sequence\"></p>\n<ol>\n<li>Create (or truncate) the disk image file to the desired size</li>\n<li>Compute the on-disk layout (call <code>compute_layout</code>)</li>\n<li>Write the superblock to block 0</li>\n<li>Zero the block bitmap (block 1) â€” all blocks free</li>\n<li>Zero the inode bitmap (block 2) â€” all inodes free</li>\n<li>Zero the inode table blocks</li>\n<li>Allocate inode 1 for the root directory</li>\n<li>Initialize the root directory (a special file whose data contains directory entries for <code>.</code> and <code>..</code>)</li>\n<li>Flush everything to disk</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;fcntl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Minimal inode structure â€” full version in Milestone 2 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> N_DIRECT_PTRS</span><span style=\"color:#79B8FF\">  12</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#B392F0\"> __attribute__</span><span style=\"color:#E1E4E8\">((packed)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> mode;</span><span style=\"color:#6A737D\">          /* file type + permissions */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> uid;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> size;</span><span style=\"color:#6A737D\">          /* file size in bytes */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> atime;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> mtime;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ctime;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> nlinks;</span><span style=\"color:#6A737D\">        /* hard link count */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> _pad;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#FFAB70\"> blocks</span><span style=\"color:#E1E4E8\">[N_DIRECT_PTRS];</span><span style=\"color:#6A737D\">  /* direct block pointers */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> single_indirect;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> double_indirect;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\">  reserved</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">  /* pad to 128 bytes */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">inode_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">_Static_assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">inode_t</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 128</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"inode_t must be exactly 128 bytes\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Minimal directory entry â€” full version in Milestone 3 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#B392F0\"> __attribute__</span><span style=\"color:#E1E4E8\">((packed)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> inode_num;</span><span style=\"color:#6A737D\">     /* 0 = free/unused entry */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> rec_len;</span><span style=\"color:#6A737D\">       /* total length of this entry */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\">  name_len;</span><span style=\"color:#6A737D\">      /* length of name field */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\">  file_type;</span><span style=\"color:#6A737D\">     /* 0=unknown, 1=regular, 2=directory */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\">     name</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">     /* null-padded, NOT null-terminated necessarily */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">dirent_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* File type constants (stored in mode high bits) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> S_IFDIR</span><span style=\"color:#F97583\">  0</span><span style=\"color:#79B8FF\">040000</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> S_IFREG</span><span style=\"color:#F97583\">  0</span><span style=\"color:#79B8FF\">100000</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEFAULT_DIR_MODE</span><span style=\"color:#E1E4E8\">  (S_IFDIR </span><span style=\"color:#F97583\">|</span><span style=\"color:#F97583\"> 0</span><span style=\"color:#79B8FF\">755</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Write an inode to the inode table on disk.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * inode_num: 1-based inode number (0 is reserved/invalid)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> write_inode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> inode_num</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                const</span><span style=\"color:#79B8FF\"> inode_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (inode_num </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> inode_num </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> sb->total_inodes) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Convert inode number to disk position */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> idx          </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inode_num </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* 0-based index into inode table */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> block_offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> idx </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> INODES_PER_BLOCK;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> block_num    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sb->inode_table_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> block_offset;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> slot_in_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> idx </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> INODES_PER_BLOCK;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, block_num, buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Copy inode into the correct slot within this block */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(buf </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> slot_in_block </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> INODE_SIZE, inode, INODE_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> write_block</span><span style=\"color:#E1E4E8\">(fd, block_num, buf);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * mkfs: initialize a fresh filesystem image.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * image_path: path to create the disk image</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * total_blocks: desired size in 4KB blocks (e.g., 4096 = 16MB image)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * total_inodes: maximum number of inodes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> mkfs</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">image_path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> total_blocks</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> total_inodes</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- Step 1: Create and size the image file --- */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(image_path, O_RDWR </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> O_CREAT </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> O_TRUNC, </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">644</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"open\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Extend the file to total_blocks * BLOCK_SIZE bytes */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">ftruncate</span><span style=\"color:#E1E4E8\">(fd, (</span><span style=\"color:#F97583\">off_t</span><span style=\"color:#E1E4E8\">)total_blocks </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ftruncate\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- Step 2: Compute layout and initialize superblock --- */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    superblock_t</span><span style=\"color:#E1E4E8\"> sb;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sb, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(sb));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    compute_layout</span><span style=\"color:#E1E4E8\">(total_blocks, total_inodes, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sb);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- Step 3: Write superblock to block 0 --- */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> block_buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(block_buf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(block_buf, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sb, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(sb));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, block_buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Failed to write superblock</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- Step 4: Zero the block bitmap (block 1) --- */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(block_buf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, BLOCK_BITMAP_BLOCK, block_buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- Step 5: Zero the inode bitmap (block 2) --- */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, INODE_BITMAP_BLOCK, block_buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- Step 6: Zero the inode table --- */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> sb.inode_table_blocks; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memset</span><span style=\"color:#E1E4E8\">(block_buf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, sb.inode_table_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> i, block_buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- Step 7: Mark inode 1 as used in inode bitmap --- */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> inode_bmap</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(inode_bmap, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    bitmap_set</span><span style=\"color:#E1E4E8\">(inode_bmap, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  /* bit 0 â†’ inode number 1 (1-based) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, INODE_BITMAP_BLOCK, inode_bmap) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- Step 8: Allocate a data block for root directory's entries --- */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Manually allocate block 0 of data blocks for root dir content */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> block_bmap</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(block_bmap, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    bitmap_set</span><span style=\"color:#E1E4E8\">(block_bmap, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  /* first data block used by root dir */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, BLOCK_BITMAP_BLOCK, block_bmap) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> root_data_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sb.data_block_start;</span><span style=\"color:#6A737D\">  /* data block index 0 */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- Step 9: Create root directory inode --- */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> root_inode;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">root_inode, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(root_inode));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    root_inode.mode    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> DEFAULT_DIR_MODE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    root_inode.nlinks  </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">      /* '.' and the reference from parent (itself) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    root_inode.size    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    root_inode.blocks[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> root_data_block;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> now </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    root_inode.atime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> root_inode.mtime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> root_inode.ctime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> now;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_inode</span><span style=\"color:#E1E4E8\">(fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sb, sb.root_inode, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">root_inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- Step 10: Write '.' and '..' entries into root's data block --- */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> dir_block</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(dir_block, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Entry for '.' â€” points to root inode itself */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    dirent_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">dot </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">dirent_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)dir_block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dot->inode_num  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sb.root_inode;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dot->name_len   </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dot->file_type  </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* directory */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dot->rec_len    </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">dirent_t</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(dot->name, </span><span style=\"color:#9ECBFF\">\".\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Entry for '..' â€” root's parent is also root */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    dirent_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">dotdot </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">dirent_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)(dir_block </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">dirent_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dotdot->inode_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sb.root_inode;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dotdot->name_len  </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dotdot->file_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dotdot->rec_len   </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">dirent_t</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(dotdot->name, </span><span style=\"color:#9ECBFF\">\"..\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, root_data_block, dir_block) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- Step 11: Persist the updated superblock (free counts changed) --- */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sb.free_blocks</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* one data block used by root dir */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sb.free_inodes</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* inode 1 used by root dir */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(block_buf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(block_buf, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sb, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(sb));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, block_buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"mkfs: created </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> (</span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> blocks, </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> inodes)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           image_path, total_blocks, total_inodes);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Superblock at block 0</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Block bitmap at block </span><span style=\"color:#79B8FF\">%u\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, BLOCK_BITMAP_BLOCK);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Inode bitmap at block </span><span style=\"color:#79B8FF\">%u\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, INODE_BITMAP_BLOCK);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Inode table: blocks </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\">â€“</span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> (</span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> blocks)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           sb.inode_table_start,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           sb.inode_table_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> sb.inode_table_blocks </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           sb.inode_table_blocks);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Journal: blocks </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\">â€“</span><span style=\"color:#79B8FF\">%u\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           sb.journal_start,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           sb.journal_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> sb.journal_blocks </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Data blocks: </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\">â€“</span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> (</span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> available)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           sb.data_block_start, total_blocks </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           sb.free_blocks);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#F97583\">[]</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (argc </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Usage: mkfs &#x3C;image> &#x3C;total_blocks> &#x3C;total_inodes></span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"  Example: mkfs disk.img 4096 1024</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> total_blocks </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">atoi</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> total_inodes </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">atoi</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> mkfs</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], total_blocks, total_inodes) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ?</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> :</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"verification-reading-back-what-you-wrote\">Verification: Reading Back What You Wrote</h2>\n<p>After <code>mkfs</code> runs, write a simple verification function that reads the image back and validates every invariant:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> verify_filesystem</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">image_path</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(image_path, O_RDONLY);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"open\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Read and validate superblock */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    read_block</span><span style=\"color:#E1E4E8\">(fd, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, buf);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">sb </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)buf;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (sb->magic </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> FS_MAGIC) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"FAIL: bad magic number 0x</span><span style=\"color:#79B8FF\">%08X\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, sb->magic);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(fd); </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: magic number 0x</span><span style=\"color:#79B8FF\">%08X\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, sb->magic);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> total blocks, </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> total inodes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           sb->total_blocks, sb->total_inodes);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: data blocks start at block </span><span style=\"color:#79B8FF\">%u\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, sb->data_block_start);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Verify root inode exists and is a directory */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> root_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sb->root_inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> idx          </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> root_ino </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> block_num    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sb->inode_table_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> idx </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> INODES_PER_BLOCK;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> slot         </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> idx </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> INODES_PER_BLOCK;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    read_block</span><span style=\"color:#E1E4E8\">(fd, block_num, buf);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">root </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">inode_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)(buf </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> slot </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> INODE_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> ((root->mode </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> S_IFDIR) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"FAIL: root inode is not a directory</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(fd); </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (root->nlinks </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"FAIL: root nlinks = </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\">, expected 2</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, root->nlinks);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(fd); </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: root inode </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> is a directory with nlinks=</span><span style=\"color:#79B8FF\">%u\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           root_ino, root->nlinks);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Verify inode bitmap marks root inode as used */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    read_block</span><span style=\"color:#E1E4E8\">(fd, INODE_BITMAP_BLOCK, buf);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">bitmap_test</span><span style=\"color:#E1E4E8\">(buf, root_ino </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"FAIL: root inode not marked used in bitmap</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(fd); </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: root inode bit set in inode bitmap</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Read root directory's data block, find '.' entry */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    read_block</span><span style=\"color:#E1E4E8\">(fd, root->blocks[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], buf);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    dirent_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">dot </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">dirent_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)buf;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (dot->inode_num </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> root_ino </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> dot->name[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> '.'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"FAIL: first entry in root is not '.'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(fd); </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: root directory has '.' â†’ inode </span><span style=\"color:#79B8FF\">%u\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, dot->inode_num);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Filesystem image: VERIFIED</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"run-this-immediately-after-mkfs-if-it-passes-every-piece-of-data-you-wrote-survives-a-round-trip-to-disk-and-back-the-most-basic-contract-of-a-storage-system\">Run this immediately after <code>mkfs</code>. If it passes, every piece of data you wrote survives a round-trip to disk and back â€” the most basic contract of a storage system.</h2>\n<h2 id=\"three-level-view-what-happens-when-write_block-executes\">Three-Level View: What Happens When <code>write_block</code> Executes</h2>\n<p>Let&#39;s trace what actually happens when your code calls <code>write_block(fd, 1, bitmap)</code> â€” writing the block bitmap to disk.</p>\n<table>\n<thead>\n<tr>\n<th>Level</th>\n<th>What Happens</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Application (your code)</strong></td>\n<td>Calls <code>write(fd, buf, 4096)</code> via your <code>write_block</code> wrapper. Control transfers to the kernel via a syscall interrupt.</td>\n</tr>\n<tr>\n<td><strong>OS / Kernel</strong></td>\n<td>The VFS layer receives the write. The kernel allocates a 4KB page in the <strong>page cache</strong> (kernel memory) and copies your <code>buf</code> there. The page is now &quot;dirty.&quot; The kernel may not write to disk immediately â€” it batches writes for efficiency. The <code>write</code> syscall returns as soon as the data is in the page cache.</td>\n</tr>\n<tr>\n<td><strong>Hardware</strong></td>\n<td>Eventually (on <code>fsync</code>, or when the kernel decides to flush), the block I/O scheduler submits a write request to the disk driver. The disk DMA controller transfers the 4KB from kernel memory to the disk&#39;s write buffer. The disk confirms completion. The page cache page is marked clean.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>The subtle danger</strong>: When <code>write_block</code> returns <code>0</code>, your data is in the kernel page cache â€” not necessarily on disk. A power loss between the <code>write</code> call and the disk flush loses your data. Later in this project (and in Milestone 6), you will use <code>fsync(fd)</code> to force the kernel to flush all dirty pages to disk before returning. For <code>mkfs</code>, call <code>fsync(fd)</code> before <code>close(fd)</code> to guarantee the freshly formatted image is actually on disk.</p>\n</blockquote>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Add this before close() in mkfs */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">fsync</span><span style=\"color:#E1E4E8\">(fd) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"fsync\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* non-fatal for mkfs in development, but fatal in production */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"key-design-decisions\">Key Design Decisions</h2>\n<p>There are real choices to make at this layer. Here are the most impactful:\n<strong>Fixed inode count vs. dynamic inode allocation</strong></p>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Used By</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Fixed count at mkfs time (chosen âœ“)</strong></td>\n<td>Simple bitmap; O(1) allocation; layout fully known at format time</td>\n<td>Running out of inodes with space remaining (classic ext2/ext3 problem on mail servers)</td>\n<td>ext2, ext3, your implementation</td>\n</tr>\n<tr>\n<td>Dynamic inode allocation</td>\n<td>Inodes grow as needed; no <code>df -i</code> exhaustion</td>\n<td>Complex; requires indirect structures for inode lookup</td>\n<td>XFS, ext4 (flexible block groups)</td>\n</tr>\n<tr>\n<td><strong>Bitmap per region vs. free list</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Option</td>\n<td>Pros</td>\n<td>Cons</td>\n<td>Used By</td>\n</tr>\n<tr>\n<td>---</td>\n<td>---</td>\n<td>---</td>\n<td>---</td>\n</tr>\n<tr>\n<td><strong>Bitmap (chosen âœ“)</strong></td>\n<td>Compact; crash-recoverable (rebuild from inodes); sequential scan</td>\n<td>O(n) scan for allocation; fragmentation over time</td>\n<td>ext2/3/4, most simple filesystems</td>\n</tr>\n<tr>\n<td>Free list / extent list</td>\n<td>O(1) allocation; naturally tracks contiguous free regions</td>\n<td>Requires careful crash recovery; complexity</td>\n<td>XFS (B-tree free space), NTFS</td>\n</tr>\n<tr>\n<td><strong>Block size: 4KB vs. alternatives</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>4KB is the dominant choice because it matches the virtual memory page size on x86-64 (and ARM). This means: block-aligned I/O never triggers partial-page reads; memory-mapped files (<code>mmap</code>) map naturally; the OS page cache handles blocks without padding. Larger blocks (8KB, 16KB) reduce metadata overhead for large files but waste space for small files (a 1-byte file consumes an entire 8KB block). Smaller blocks (1KB, 2KB) reduce internal fragmentation but require more metadata to track the same data.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"knowledge-cascade-one-concept-ten-connections\">Knowledge Cascade: One Concept, Ten Connections</h2>\n<h2 id=\"you-just-built-a-block-allocator-backed-by-a-bitmap-that-sits-on-top-of-a-flat-address-space-of-fixed-size-chunks-this-is-not-a-filesystem-specific-idea-it-is-one-of-the-fundamental-patterns-of-systems-programming-database-page-management-postgresql-sqlite-and-mysql-all-store-data-in-quotpagesquot-fixed-size-blocks-8kb-in-postgres-4kb-in-sqlite-by-default-their-internal-page-managers-maintain-a-freelist-or-bitmap-of-free-pages-the-quotheap-filequot-in-postgres-is-literally-a-sequence-of-8kb-pages-with-a-quotfree-space-mapquot-fsm-tracking-available-space-per-page-your-superblock-is-postgres39s-pg_control-file-your-bitmap-is-the-fsm-building-a-filesystem-gives-you-the-mental-model-to-read-database-internals-with-clarity-the-ssd-flash-translation-layer-ftl-when-you-call-write_blockfd-500-buf-you-are-writing-to-logical-block-500-but-inside-your-ssd-logical-block-500-does-not-map-to-a-fixed-physical-nand-page-the-ftl-maintains-its-own-mapping-table-logical-to-physical-lpt-performs-wear-leveling-distributing-writes-evenly-across-cells-and-manages-its-own-garbage-collection-when-pages-need-to-be-erased-your-filesystem-sits-on-top-of-a-block-abstraction-that-is-itself-implemented-by-another-system-with-its-own-block-abstraction-indirection-all-the-way-down-memory-allocators-jemalloc-tcmalloc-mimalloc-malloc-faces-the-same-problem-from-a-different-angle-carve-variable-size-allocations-from-fixed-size-os-pages-4kb-jemalloc39s-slab-allocator-tracks-free-slots-within-a-page-using-a-bitmap-each-jemalloc-quotrunquot-is-a-region-of-pages-dedicated-to-a-specific-allocation-size-class-with-a-bitmap-marking-which-slots-are-occupied-your-bitmap_find_free-and-bitmap_set-are-functionally-identical-to-what-jemalloc-executes-on-every-malloc-the-problem-is-universal-the-solution-is-the-same-virtual-memory-and-physical-frame-allocation-the-linux-kernel-maintains-a-quotbuddy-allocatorquot-for-physical-memory-pages-with-bitmaps-at-each-order-level-tracking-which-frames-are-free-when-your-process-calls-mmapnull-4096-prot_readprot_write-map_anonymous-1-0-the-kernel-runs-a-bitmap-scan-nearly-identical-to-your-bitmap_find_free-then-marks-the-physical-frame-allocated-and-records-the-mapping-in-your-process39s-page-table-your-filesystem39s-block-allocator-is-the-on-disk-analogue-of-the-kernel39s-physical-frame-allocator-disk-image-forensics-you-now-understand-on-disk-layout-precisely-enough-to-examine-a-raw-disk-image-with-hexdump-c-diskimg-head-100-and-identify-the-magic-number-at-offset-0-the-total-block-count-at-offset-12-and-the-free-block-count-at-offset-20-forensic-tools-like-autopsy-the-sleuth-kit-and-foremost-work-by-reading-raw-disk-images-and-interpreting-known-filesystem-structures-at-known-byte-offsets-exactly-what-your-verify_filesystem-function-does-with-the-knowledge-from-this-milestone-you-can-recover-files-from-a-quotdeletedquot-but-not-overwritten-partition-by-finding-inodes-in-the-inode-table-and-following-their-block-pointers-raid-and-storage-systems-raid-controllers-manage-arrays-of-physical-blocks-with-their-own-parity-metadata-a-raid-5-controller-maintains-a-quotstripe-mapquot-tracking-which-data-blocks-correspond-to-which-parity-blocks-another-form-of-block-level-metadata-management-the-same-freeused-tracking-problem-appears-at-every-storage-abstraction-layer\">You just built a block allocator backed by a bitmap that sits on top of a flat address space of fixed-size chunks. This is not a filesystem-specific idea. It is one of the fundamental patterns of systems programming:\n<strong>â†’ Database Page Management</strong>\nPostgreSQL, SQLite, and MySQL all store data in &quot;pages&quot; â€” fixed-size blocks (8KB in Postgres, 4KB in SQLite by default). Their internal page managers maintain a freelist or bitmap of free pages. The &quot;heap file&quot; in Postgres is literally a sequence of 8KB pages, with a &quot;free space map&quot; (FSM) tracking available space per page. Your superblock is Postgres&#39;s <code>pg_control</code> file. Your bitmap is the FSM. Building a filesystem gives you the mental model to read database internals with clarity.\n<strong>â†’ The SSD Flash Translation Layer (FTL)</strong>\nWhen you call <code>write_block(fd, 500, buf)</code>, you are writing to logical block 500. But inside your SSD, logical block 500 does not map to a fixed physical NAND page. The FTL maintains its own mapping table (logical-to-physical, LPT), performs wear leveling (distributing writes evenly across cells), and manages its own garbage collection when pages need to be erased. Your filesystem sits on top of a block abstraction that is itself implemented by another system with its own block abstraction. Indirection all the way down.\n<strong>â†’ Memory Allocators (jemalloc, tcmalloc, mimalloc)</strong>\n<code>malloc()</code> faces the same problem from a different angle: carve variable-size allocations from fixed-size OS pages (4KB). jemalloc&#39;s slab allocator tracks free slots within a page using... a bitmap. Each <code>jemalloc</code> &quot;run&quot; is a region of pages dedicated to a specific allocation size class, with a bitmap marking which slots are occupied. Your <code>bitmap_find_free</code> and <code>bitmap_set</code> are functionally identical to what jemalloc executes on every <code>malloc</code>. The problem is universal; the solution is the same.\n<strong>â†’ Virtual Memory and Physical Frame Allocation</strong>\nThe Linux kernel maintains a &quot;buddy allocator&quot; for physical memory pages, with bitmaps at each order level tracking which frames are free. When your process calls <code>mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_ANONYMOUS, -1, 0)</code>, the kernel runs a bitmap scan nearly identical to your <code>bitmap_find_free</code>, then marks the physical frame allocated, and records the mapping in your process&#39;s page table. Your filesystem&#39;s block allocator is the on-disk analogue of the kernel&#39;s physical frame allocator.\n<strong>â†’ Disk Image Forensics</strong>\nYou now understand on-disk layout precisely enough to examine a raw disk image with <code>hexdump -C disk.img | head -100</code> and identify the magic number at offset 0, the total block count at offset 12, and the free block count at offset 20. Forensic tools like <code>Autopsy</code>, <code>The Sleuth Kit</code>, and <code>foremost</code> work by reading raw disk images and interpreting known filesystem structures at known byte offsets â€” exactly what your <code>verify_filesystem</code> function does. With the knowledge from this milestone, you can recover files from a &quot;deleted&quot; (but not overwritten) partition by finding inodes in the inode table and following their block pointers.\n<strong>â†’ RAID and Storage Systems</strong>\nRAID controllers manage arrays of physical blocks with their own parity metadata. A RAID-5 controller maintains a &quot;stripe map&quot; tracking which data blocks correspond to which parity blocks â€” another form of block-level metadata management. The same free/used tracking problem appears at every storage abstraction layer.</h2>\n<h2 id=\"before-you-move-on-pitfall-checklist\">Before You Move On: Pitfall Checklist</h2>\n<p>Run through this checklist before calling Milestone 1 complete:</p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Magic number validation</strong>: does your mount code refuse images with a bad magic number?</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Block 0 protection</strong>: can you accidentally allocate block 0 (the superblock) as a data block? Add a guard: <code>assert(alloc_block(...) &gt;= sb-&gt;data_block_start)</code>.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Bitmap index vs. disk block number</strong>: are you consistently converting between &quot;data block index&quot; (0-based offset into data region) and &quot;disk block number&quot; (absolute block address)?</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong><code>fsync</code> on mkfs exit</strong>: is your freshly formatted image actually on disk or still in the page cache?</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong><code>__attribute__((packed))</code> on all disk structs</strong>: did you verify <code>sizeof(superblock_t) == BLOCK_SIZE</code> with <code>_Static_assert</code>?</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Root inode link count = 2</strong>: <code>.</code> and <code>..</code> each count as one hard link. This is a filesystem invariant that tools like <code>fsck</code> check.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Superblock free count accuracy</strong>: after <code>mkfs</code>, <code>sb.free_blocks</code> must equal <code>total_blocks - data_block_start - 1</code> (one block used by root directory data). Off-by-one here causes cascading errors in Milestone 2.</li>\n</ul>\n<hr>\n<h2 id=\"what-you39ve-built-and-what-comes-next\">What You&#39;ve Built and What Comes Next</h2>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-L0-satellite-map.svg\" alt=\"Filesystem Atlas â€” Satellite Map (Home Base)\"></p>\n<h2 id=\"you-started-with-nothing-a-flat-file-you-gave-it-a-grammar-block-0-is-the-superblock-blocks-1-and-2-are-bitmaps-then-the-inode-table-then-the-journal-then-data-you-built-tools-to-allocate-and-free-blocks-and-inodes-with-one-bit-precision-you-formatted-a-raw-image-into-a-valid-filesystem-with-a-root-directory-but-look-at-what-the-root-directory-actually-contains-right-now-two-entries-and-sitting-in-one-data-block-the-quotinodequot-for-the-root-directory-contains-a-block-pointer-to-that-data-block-the-quotinodequot-has-a-size-a-mode-and-a-link-count-but-those-fields-are-barely-populated-in-milestone-2-you-build-the-full-inode-structure-the-direct-and-indirect-block-pointer-tree-that-lets-a-single-inode-track-a-file-from-1-byte-to-several-gigabytes-that39s-where-the-on-disk-layout-stops-being-about-where-things-live-and-starts-being-about-how-much-they-can-grow-the-disk-doesn39t-know-you-exist-but-now-you-know-how-to-make-it-remember-anything-you-want\">You started with nothing. A flat file. You gave it a grammar: block 0 is the superblock, blocks 1 and 2 are bitmaps, then the inode table, then the journal, then data. You built tools to allocate and free blocks and inodes with one-bit precision. You formatted a raw image into a valid filesystem with a root directory.\nBut look at what the root directory actually contains right now: two entries (<code>.</code> and <code>..</code>) sitting in one data block. The &quot;inode&quot; for the root directory contains a block pointer to that data block. The &quot;inode&quot; has a size, a mode, and a link count â€” but those fields are barely populated. In Milestone 2, you build the full inode structure: the direct and indirect block pointer tree that lets a single inode track a file from 1 byte to several gigabytes. That&#39;s where the on-disk layout stops being about <em>where</em> things live, and starts being about <em>how much</em> they can grow.\nThe disk doesn&#39;t know you exist. But now you know how to make it remember anything you want.</h2>\n<!-- END_MS -->\n\n\n<!-- MS_ID: filesystem-m2 -->\n<!-- MS_ID: filesystem-m2 -->\n<h1 id=\"milestone-2-inode-management\">Milestone 2: Inode Management</h1>\n<h2 id=\"a-file-is-not-its-name-not-its-data-not-its-location\">A File Is Not Its Name, Not Its Data, Not Its Location</h2>\n<p>You have used files your entire programming career. You have opened them, read them, written to them, deleted them. You have a mental model â€” reasonable, intuitive, and almost entirely wrong about what is actually happening on disk.\nHere is the model most developers carry: a file is a named container. The name tells you where it is. The contents are stored somewhere nearby. The file &quot;has&quot; its data the way a folder holds documents.\nNow consider this: you can have two names for the same file (hard links), and deleting one name does not delete the file. You can have a file that is 10 gigabytes according to <code>ls -l</code> but occupies only 4 kilobytes on disk. You can rename a file without moving a single byte of its data. You can have a file with no name at all, still open, still readable, living in limbo between deletion and the last <code>close()</code>.\nNone of this makes sense under the &quot;file is a named container&quot; model. It makes perfect sense once you understand the inode.\nThe fundamental design of Unix-derived filesystems separates three things that seem inseparable:</p>\n<ol>\n<li><strong>The name</strong> â€” lives in a directory entry. Just a string pointing to an inode number.</li>\n<li><strong>The metadata</strong> â€” lives in the inode. Size, permissions, timestamps, owner, block pointers.</li>\n<li><strong>The data</strong> â€” lives in data blocks. The inode points to them; they do not know they belong to any file.\nThe inode is the <strong>identity</strong> of a file. Names come and go. Data blocks are allocated and freed. The inode is the fixed center around which everything else orbits. This milestone, you build the inode â€” 128 bytes of metadata that can describe a file from 0 bytes to several gigabytes.</li>\n</ol>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m2-inode-struct.svg\" alt=\"Inode Structure â€” Complete Byte Layout\"></p>\n<hr>\n<h2 id=\"the-fundamental-tension-fixed-metadata-variable-data\">The Fundamental Tension: Fixed Metadata, Variable Data</h2>\n<h2 id=\"here-is-the-physical-constraint-that-makes-this-design-challenging-the-inode-must-be-fixed-size-the-files-it-describes-have-variable-size-an-inode-occupies-exactly-128-bytes-in-the-inode-table-or-256-bytes-in-ext4-but-always-fixed-this-size-cannot-change-after-the-filesystem-is-formatted-yet-a-text-file-might-be-47-bytes-while-a-disk-image-might-be-40-gigabytes-the-same-inode-structure-must-represent-both-if-you-tried-to-embed-the-block-pointer-list-directly-in-the-inode-scaled-to-the-file-size-you-would-need-variable-size-inodes-which-makes-the-inode-table-impossible-to-index-directly-you-cannot-do-inode_table_block-inode_num-sizeofinode_t-if-inodes-have-different-sizes-you-would-need-a-separate-map-of-inode-locations-which-is-just-pushing-the-indirection-one-level-up-the-solution-is-indirection-for-small-files-the-inode-contains-direct-pointers-to-data-blocks-fast-simple-no-extra-io-for-medium-files-the-inode-contains-a-pointer-to-a-block-full-of-pointers-one-extra-disk-read-many-more-blocks-reachable-for-large-files-the-inode-contains-a-pointer-to-a-block-full-of-pointers-to-blocks-full-of-pointers-two-extra-disk-reads-files-up-to-several-gigabytes-this-is-the-key-insight-to-internalize-before-you-write-a-single-line-of-code-the-inode-does-not-contain-data-the-inode-contains-a-tree-of-pointers-to-data-the-tree-has-a-fixed-root-the-inode-fields-but-it-can-grow-additional-levels-as-the-file-grows-let39s-build-it\">Here is the physical constraint that makes this design challenging:\n<strong>The inode must be fixed-size. The files it describes have variable size.</strong>\nAn inode occupies exactly 128 bytes in the inode table (or 256 bytes in ext4, but always fixed). This size cannot change after the filesystem is formatted. Yet a text file might be 47 bytes, while a disk image might be 40 gigabytes. The same inode structure must represent both.\nIf you tried to embed the block pointer list directly in the inode scaled to the file size, you would need variable-size inodes â€” which makes the inode table impossible to index directly (you cannot do <code>inode_table_block + inode_num * sizeof(inode_t)</code> if inodes have different sizes). You would need a separate map of inode locations, which is just pushing the indirection one level up.\nThe solution is <strong>indirection</strong>. For small files, the inode contains direct pointers to data blocks â€” fast, simple, no extra I/O. For medium files, the inode contains a pointer to a <em>block full of pointers</em> â€” one extra disk read, many more blocks reachable. For large files, the inode contains a pointer to a <em>block full of pointers to blocks full of pointers</em> â€” two extra disk reads, files up to several gigabytes.\nThis is the key insight to internalize before you write a single line of code: <strong>the inode does not contain data. The inode contains a tree of pointers to data.</strong> The tree has a fixed root (the inode fields), but it can grow additional levels as the file grows.\nLet&#39;s build it.</h2>\n<h2 id=\"the-inode-structure-128-bytes-that-describe-a-universe\">The Inode Structure: 128 Bytes That Describe a Universe</h2>\n<p>Every field in the inode exists for a specific operational reason. There is no dead weight here â€” this is 128 bytes under tight space pressure.\n[[EXPLAIN:on-disk-serialization-â€”-packing-structs-to-exact-byte-layouts-with-fixed-width-types|On-disk serialization â€” packing structs to exact byte layouts with fixed-width types]]</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;time.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BLOCK_SIZE</span><span style=\"color:#79B8FF\">          4096</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> INODE_SIZE</span><span style=\"color:#79B8FF\">          128</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> INODES_PER_BLOCK</span><span style=\"color:#E1E4E8\">    (BLOCK_SIZE </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> INODE_SIZE)</span><span style=\"color:#6A737D\">   /* 32 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> N_DIRECT</span><span style=\"color:#79B8FF\">            12</span><span style=\"color:#6A737D\">     /* number of direct block pointers */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Inode structure â€” always exactly 128 bytes on disk.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * BYTE LAYOUT (all fields little-endian, packed):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset  0: mode           (2 bytes) â€” file type + permissions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset  2: uid            (2 bytes) â€” owner user ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset  4: gid            (2 bytes) â€” owner group ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset  6: nlinks         (2 bytes) â€” hard link count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset  8: size           (4 bytes) â€” file size in bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 12: atime          (4 bytes) â€” last access time (Unix timestamp)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 16: mtime          (4 bytes) â€” last modification time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 20: ctime          (4 bytes) â€” last metadata change time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 24: blocks[0..11]  (48 bytes) â€” 12 direct block pointers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 72: single_indirect (4 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 76: double_indirect (4 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 80: reserved       (48 bytes) â€” pad to 128 bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Total: 128 bytes exactly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#B392F0\"> __attribute__</span><span style=\"color:#E1E4E8\">((packed)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> mode;</span><span style=\"color:#6A737D\">                  /* file type bits + permission bits */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> uid;</span><span style=\"color:#6A737D\">                   /* owner UID */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> gid;</span><span style=\"color:#6A737D\">                   /* owner GID */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> nlinks;</span><span style=\"color:#6A737D\">                /* hard link count; free inode when this hits 0 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> size;</span><span style=\"color:#6A737D\">                  /* file size in bytes (logical, not disk usage) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> atime;</span><span style=\"color:#6A737D\">                 /* last access time */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> mtime;</span><span style=\"color:#6A737D\">                 /* last data modification time */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ctime;</span><span style=\"color:#6A737D\">                 /* last inode change time (chmod, chown, link) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#FFAB70\"> blocks</span><span style=\"color:#E1E4E8\">[N_DIRECT];</span><span style=\"color:#6A737D\">     /* direct block pointers: blocks[0] is file offset 0 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> single_indirect;</span><span style=\"color:#6A737D\">       /* points to a block containing 1024 block pointers */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> double_indirect;</span><span style=\"color:#6A737D\">       /* points to a block of single-indirect pointers */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\">  reserved</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">48</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">          /* future use; must be zeroed */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">inode_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">_Static_assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">inode_t</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> INODE_SIZE,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">               \"inode_t must be exactly 128 bytes\"</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<p>Let&#39;s examine each field&#39;s purpose carefully:\n<strong><code>mode</code> (2 bytes)</strong>: This single 16-bit field encodes two things at once. The high bits identify the <em>file type</em> (regular file, directory, symbolic link, device, etc.). The low 12 bits encode <em>permissions</em> (read/write/execute for owner, group, and others â€” the familiar <code>rwxr-xr-x</code> pattern). The POSIX standard defines these bit positions:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* File type bits (high 4 bits of mode, shifted into bits 12-15) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> S_IFMT</span><span style=\"color:#F97583\">   0</span><span style=\"color:#79B8FF\">170000</span><span style=\"color:#6A737D\">  /* mask for file type bits */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> S_IFREG</span><span style=\"color:#F97583\">  0</span><span style=\"color:#79B8FF\">100000</span><span style=\"color:#6A737D\">  /* regular file */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> S_IFDIR</span><span style=\"color:#F97583\">  0</span><span style=\"color:#79B8FF\">040000</span><span style=\"color:#6A737D\">  /* directory */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> S_IFLNK</span><span style=\"color:#F97583\">  0</span><span style=\"color:#79B8FF\">120000</span><span style=\"color:#6A737D\">  /* symbolic link */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> S_IFBLK</span><span style=\"color:#F97583\">  0</span><span style=\"color:#79B8FF\">060000</span><span style=\"color:#6A737D\">  /* block device */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> S_IFCHR</span><span style=\"color:#F97583\">  0</span><span style=\"color:#79B8FF\">020000</span><span style=\"color:#6A737D\">  /* character device */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> S_IFIFO</span><span style=\"color:#F97583\">  0</span><span style=\"color:#79B8FF\">010000</span><span style=\"color:#6A737D\">  /* named pipe (FIFO) */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Permission bits (low 9 bits) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> S_IRUSR</span><span style=\"color:#F97583\">  0</span><span style=\"color:#79B8FF\">400</span><span style=\"color:#6A737D\">     /* owner read */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> S_IWUSR</span><span style=\"color:#F97583\">  0</span><span style=\"color:#79B8FF\">200</span><span style=\"color:#6A737D\">     /* owner write */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> S_IXUSR</span><span style=\"color:#F97583\">  0</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#6A737D\">     /* owner execute */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> S_IRGRP</span><span style=\"color:#F97583\">  0</span><span style=\"color:#79B8FF\">040</span><span style=\"color:#6A737D\">     /* group read */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> S_IROTH</span><span style=\"color:#F97583\">  0</span><span style=\"color:#79B8FF\">004</span><span style=\"color:#6A737D\">     /* others read */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* ... etc. */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Helper macros to test file type */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> S_ISDIR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">m</span><span style=\"color:#E1E4E8\">)  (((m) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> S_IFMT) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> S_IFDIR)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> S_ISREG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">m</span><span style=\"color:#E1E4E8\">)  (((m) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> S_IFMT) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> S_IFREG)</span></span></code></pre></div>\n<p>A regular file with <code>rwxr-xr-x</code> permissions: <code>mode = 0100755</code> (octal). A directory with <code>rwxr-xr-x</code>: <code>mode = 0040755</code>.\n<strong><code>nlinks</code> (2 bytes)</strong>: The hard link count. Every directory entry pointing to this inode increments this counter. When you <code>rm</code> a file, the directory entry is removed and <code>nlinks</code> decrements. Only when <code>nlinks</code> hits 0 <em>and</em> no process has the file open should the inode be freed. This is reference counting â€” the same principle used by C++&#39;s <code>shared_ptr</code> and Rust&#39;s <code>Arc</code>. The inode is the shared resource; directory entries are the shared references.\n<strong><code>size</code> (4 bytes)</strong>: The <em>logical</em> file size in bytes. This is what <code>ls -l</code> shows you. It is <strong>not</strong> the amount of disk space the file consumes. A sparse file with 1 byte written at offset 999,999,999 has <code>size = 1,000,000,000</code> but allocates only 2 data blocks (8KB). The relationship between <code>size</code> and actual disk usage is the heart of sparse files, discussed below.\n<strong><code>atime</code>, <code>mtime</code>, <code>ctime</code> (4 bytes each)</strong>: Unix timestamps (seconds since January 1, 1970). </p>\n<ul>\n<li><code>atime</code> updates on every read (often disabled in modern Linux with <code>noatime</code> mount option for performance â€” every read causing a write is expensive)</li>\n<li><code>mtime</code> updates when file <em>data</em> changes</li>\n<li><code>ctime</code> updates when the inode <em>metadata</em> changes (permissions, link count, owner) â€” note: <code>ctime</code> is NOT &quot;creation time&quot;; Unix has no native creation time field in the traditional inode\n<strong><code>blocks[N_DIRECT]</code> (48 bytes)</strong>: Twelve <code>uint32_t</code> values. Each is a disk block number, or zero if that block is not allocated. <code>blocks[0]</code> contains the data starting at file offset 0. <code>blocks[1]</code> contains the data at file offset 4096. <code>blocks[11]</code> contains data at offset 45,056. Together they address the first 48KB of any file.\n<strong><code>single_indirect</code> (4 bytes)</strong>: A pointer to an <em>indirect block</em> â€” a 4KB block whose entire contents are an array of <code>uint32_t</code> block pointers. Each pointer in that indirect block points to a data block. A 4KB indirect block holds <code>4096 / 4 = 1024</code> pointers. So the single-indirect pointer can reach an additional <code>1024 Ã— 4KB = 4MB</code> of file data.\n<strong><code>double_indirect</code> (4 bytes)</strong>: A pointer to a block containing 1024 <em>single-indirect block pointers</em>. Each of those points to a block with 1024 data block pointers. Total capacity: <code>1024 Ã— 1024 Ã— 4KB = 4GB</code>.</li>\n</ul>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m2-pointer-tree.svg\" alt=\"Inode Block Pointer Tree â€” Direct, Single-Indirect, Double-Indirect\"></p>\n<blockquote>\n<p><strong>Why stop at double-indirect?</strong> Most filesystems add a triple-indirect pointer for files up to 4TB. For this project, double-indirect gives you 4GB+ files which is sufficient. ext2/ext3 use triple-indirect. ext4 abandoned this entire scheme in favor of &quot;extents&quot; â€” contiguous run-length encoded block ranges â€” which are far more efficient for large sequential files. We&#39;ll note where extents fit in the knowledge cascade.</p>\n</blockquote>\n<hr>\n<h2 id=\"reading-and-writing-inodes-the-inode-table\">Reading and Writing Inodes: The Inode Table</h2>\n<p>Milestone 1 established that inodes live in the inode table â€” a contiguous region of blocks starting at <code>sb-&gt;inode_table_start</code>. With 32 inodes per block (<code>INODES_PER_BLOCK</code>), inode number <code>N</code> lives in:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>block  = inode_table_start + (N - 1) / INODES_PER_BLOCK\noffset = ((N - 1) % INODES_PER_BLOCK) * INODE_SIZE</code></pre></div>\n<p>The <code>N - 1</code> converts from 1-based inode numbers (inode 0 is reserved/invalid) to 0-based array indices.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Read inode from disk.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * inode_num: 1-based inode number (must be >= 1 and &#x3C;= total_inodes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * out: caller-allocated inode_t to populate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns 0 on success, negative errno on failure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> read_inode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">               uint32_t</span><span style=\"color:#FFAB70\"> inode_num</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">inode_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">out</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (inode_num </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> inode_num </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> sb->total_inodes) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> idx           </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inode_num </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> block_num     </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sb->inode_table_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> idx </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> INODES_PER_BLOCK;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> slot_in_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> idx </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> INODES_PER_BLOCK;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> read_block</span><span style=\"color:#E1E4E8\">(fd, block_num, buf);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(out, buf </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> slot_in_block </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> INODE_SIZE, INODE_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Write inode to disk.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This is a read-modify-write: we read the block, update one inode slot,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * then write the whole block back. We cannot write just the 128-byte inode</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * because the block device only supports full-block writes.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> write_inode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                uint32_t</span><span style=\"color:#FFAB70\"> inode_num</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> inode_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (inode_num </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> inode_num </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> sb->total_inodes) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> idx           </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inode_num </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> block_num     </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sb->inode_table_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> idx </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> INODES_PER_BLOCK;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> slot_in_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> idx </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> INODES_PER_BLOCK;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> read_block</span><span style=\"color:#E1E4E8\">(fd, block_num, buf);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(buf </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> slot_in_block </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> INODE_SIZE, inode, INODE_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> write_block</span><span style=\"color:#E1E4E8\">(fd, block_num, buf);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<blockquote>\n<p><strong>Hardware Soul â€” Read-Modify-Write on Inode Updates</strong>: Every <code>write_inode</code> call is actually a read-modify-write cycle. You read 4096 bytes (one block containing 32 inodes), modify 128 bytes in memory, then write 4096 bytes back. This means every inode update costs 2 disk I/Os instead of 1. Real filesystems address this through a page cache: the block is likely already in RAM from a recent read, so the &quot;read&quot; is a cache hit at ~100ns. Only the write hits disk. But the write-amplification factor of 32Ã— (writing 4096 bytes to modify 128) is real and unavoidable at the block device level. This is one reason ext4 packs multiple inode modifications into a single transaction.</p>\n</blockquote>\n<hr>\n<h2 id=\"inode-allocation-and-deallocation\">Inode Allocation and Deallocation</h2>\n<p>Allocating an inode follows the same bitmap pattern as block allocation from Milestone 1:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> INODE_BITMAP_BLOCK</span><span style=\"color:#79B8FF\">  2</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Allocate a new inode.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns the inode number (1-based) on success, -1 if none free.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * The caller is responsible for initializing and writing the inode.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> alloc_inode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (sb->free_inodes </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> bitmap</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, INODE_BITMAP_BLOCK, bitmap) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Find first free bit (0 = free) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> total_inodes </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sb->total_inodes;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> byte_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; byte_idx </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> (total_inodes </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 7</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">; byte_idx</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bitmap</span><span style=\"color:#E1E4E8\">[byte_idx] </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FF</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> bit </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; bit </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">; bit</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint32_t</span><span style=\"color:#E1E4E8\"> idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> byte_idx </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> bit;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (idx </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> total_inodes) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#FFAB70\">bitmap</span><span style=\"color:#E1E4E8\">[byte_idx] </span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> bit) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /* Found free inode */</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                bitmap</span><span style=\"color:#E1E4E8\">[byte_idx] </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> bit);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, INODE_BITMAP_BLOCK, bitmap) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                sb->free_inodes</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)(idx </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   /* convert 0-based index â†’ 1-based number */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Deallocation is where the real complexity lives. To free an inode, you must:</p>\n<ol>\n<li>Free all <strong>direct</strong> data blocks (up to 12)</li>\n<li>If <code>single_indirect != 0</code>: read that block, free all non-zero block pointers within it, then free the indirect block itself</li>\n<li>If <code>double_indirect != 0</code>: read that block, for each non-zero entry (which is itself a single-indirect block), read that block, free all its data block pointers, free the single-indirect block, then free the double-indirect block</li>\n<li>Clear the inode in the inode table (zero it out)</li>\n<li>Clear the inode&#39;s bit in the inode bitmap\nSteps 2 and 3 describe <strong>recursive block freeing</strong> â€” following the pointer tree to its leaves and freeing bottom-up. Missing this is the most common bug in inode implementations: you free the data blocks and the inode, but orphan the indirect pointer blocks, permanently leaking them until a <code>fsck</code> scan.</li>\n</ol>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m2-inode-deallocation.svg\" alt=\"Inode Deallocation â€” Recursive Block Freeing\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Free a single data block by its disk block number.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Clears the bit in the block bitmap and updates sb->free_blocks.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> free_data_block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> disk_block_num</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (disk_block_num </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">    /* null pointer â€” nothing to free */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (disk_block_num </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> sb->data_block_start </span><span style=\"color:#F97583\">||</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        disk_block_num </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> sb->total_blocks) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span><span style=\"color:#6A737D\">   /* never free metadata blocks */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> bitmap</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, BLOCK_BITMAP_BLOCK, bitmap) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> data_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> disk_block_num </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> sb->data_block_start;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    bitmap</span><span style=\"color:#E1E4E8\">[data_idx </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> (data_idx </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, BLOCK_BITMAP_BLOCK, bitmap) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sb->free_blocks</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Free all blocks pointed to by a single-indirect block,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * then free the indirect block itself.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * indirect_block_num: disk block number of the single-indirect block.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *                     If 0, this is a null pointer (sparse region) â€” do nothing.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> free_single_indirect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                uint32_t</span><span style=\"color:#FFAB70\"> indirect_block_num</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (indirect_block_num </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, indirect_block_num, buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* The indirect block contains 1024 uint32_t block pointers */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">ptrs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)buf;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ptrs_per_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  /* 1024 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> ptrs_per_block; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ptrs</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            free_data_block</span><span style=\"color:#E1E4E8\">(fd, sb, </span><span style=\"color:#FFAB70\">ptrs</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Now free the indirect block itself */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> free_data_block</span><span style=\"color:#E1E4E8\">(fd, sb, indirect_block_num);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Free all blocks reachable through a double-indirect block,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * then free the double-indirect block itself.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> free_double_indirect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                uint32_t</span><span style=\"color:#FFAB70\"> dindirect_block_num</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (dindirect_block_num </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, dindirect_block_num, buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">ptrs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)buf;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ptrs_per_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> ptrs_per_block; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ptrs</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Each entry here is itself a single-indirect block */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            free_single_indirect</span><span style=\"color:#E1E4E8\">(fd, sb, </span><span style=\"color:#FFAB70\">ptrs</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> free_data_block</span><span style=\"color:#E1E4E8\">(fd, sb, dindirect_block_num);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Free an inode and all its associated data blocks.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * After this call, inode_num may be reallocated to a new file.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> free_inode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> inode_num</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, inode_num, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 1: Free all direct data blocks */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> N_DIRECT; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (inode.blocks[i] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            free_data_block</span><span style=\"color:#E1E4E8\">(fd, sb, inode.blocks[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 2: Free single-indirect chain */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free_single_indirect</span><span style=\"color:#E1E4E8\">(fd, sb, inode.single_indirect);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 3: Free double-indirect chain */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free_double_indirect</span><span style=\"color:#E1E4E8\">(fd, sb, inode.double_indirect);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 4: Zero the inode in the table */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> zeroed;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">zeroed, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(zeroed));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_inode</span><span style=\"color:#E1E4E8\">(fd, sb, inode_num, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">zeroed) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 5: Clear inode bitmap bit */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> bitmap</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, INODE_BITMAP_BLOCK, bitmap) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inode_num </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    bitmap</span><span style=\"color:#E1E4E8\">[idx </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> (idx </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, INODE_BITMAP_BLOCK, bitmap) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sb->free_inodes</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<blockquote>\n<p><strong>Pitfall â€” Bitmap Load on Every Block Free</strong>: The <code>free_data_block</code> function above reads and writes the bitmap for every single block freed. Freeing an inode with 12 direct blocks + 1024 indirect blocks = 1036 blocks freed = 2072 bitmap I/Os. This is acceptable for correctness but catastrophically slow for production. Real implementations load the bitmap once, clear all bits in memory, then write it back once. For now, correctness first. When you integrate with Milestone 6 journaling, you will batch these operations anyway.</p>\n</blockquote>\n<hr>\n<h2 id=\"the-block-pointer-tree-file-offset-to-disk-block\">The Block Pointer Tree: File Offset to Disk Block</h2>\n<p>The most important operation on an inode â€” used by every read and write â€” is <strong>translating a file offset to a disk block number</strong>. Given &quot;byte offset 150,000 in this file, which disk block is it in?&quot;, the function must navigate the pointer tree.</p>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m2-offset-to-block.svg\" alt=\"File Offset â†’ Block Number Translation\"></p>\n<p>Let&#39;s work through the math first, then implement it:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>File offset 0 to 49,151:\n  Block index 0â€“11 â†’ inode.blocks[0] through inode.blocks[11]\n  (12 direct blocks Ã— 4096 bytes = 49,152 bytes)\nFile offset 49,152 to 4,243,455:\n  Block index 12 to 1035 â†’ single-indirect region\n  (1024 blocks Ã— 4096 = 4,194,304 bytes = 4MB)\n  To find block at file offset X in single-indirect range:\n    single_idx = (X / BLOCK_SIZE) - N_DIRECT\n    read inode.single_indirect block\n    return ptrs[single_idx]\nFile offset 4,243,456 and beyond:\n  Block index 1036 and beyond â†’ double-indirect region\n  block_index = X / BLOCK_SIZE\n  dbl_idx = block_index - N_DIRECT - PTRS_PER_BLOCK   /* offset into double-indirect */\n  outer = dbl_idx / PTRS_PER_BLOCK   /* which single-indirect block within the double */\n  inner = dbl_idx % PTRS_PER_BLOCK   /* which data block within that single-indirect */\n  read inode.double_indirect block â†’ get ptrs[outer] (a single-indirect block)\n  read ptrs[outer] block â†’ get ptrs[inner] (the data block)</code></pre></div>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTRS_PER_BLOCK</span><span style=\"color:#E1E4E8\">      (BLOCK_SIZE </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">))</span><span style=\"color:#6A737D\">    /* 1024 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DIRECT_LIMIT</span><span style=\"color:#E1E4E8\">        ((</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)N_DIRECT </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> SINGLE_LIMIT</span><span style=\"color:#E1E4E8\">        (DIRECT_LIMIT </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)PTRS_PER_BLOCK </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DOUBLE_LIMIT</span><span style=\"color:#E1E4E8\">        (SINGLE_LIMIT </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)PTRS_PER_BLOCK </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> PTRS_PER_BLOCK </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Translate a file byte offset to a disk block number.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * offset: byte offset within the file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * inode:  the file's inode</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * out_block_num: set to the disk block number (0 if the block is a hole)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns 0 on success, negative errno on I/O error.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns 0 with *out_block_num = 0 for sparse regions (valid, not an error).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> inode_get_block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> inode_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    uint64_t</span><span style=\"color:#FFAB70\"> offset</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">out_block_num</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> block_index </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">out_block_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">    /* default: hole / unallocated */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (offset </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> DOUBLE_LIMIT) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFBIG;</span><span style=\"color:#6A737D\">    /* beyond our addressing capacity */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- Direct region --- */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (block_index </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> N_DIRECT) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        *</span><span style=\"color:#E1E4E8\">out_block_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inode->blocks[block_index];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- Single-indirect region --- */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (block_index </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> N_DIRECT </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> PTRS_PER_BLOCK) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (inode->single_indirect </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            *</span><span style=\"color:#E1E4E8\">out_block_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">    /* entire region is a hole */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, inode->single_indirect, buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">ptrs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)buf;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> single_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)(block_index </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> N_DIRECT);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        *</span><span style=\"color:#E1E4E8\">out_block_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> ptrs</span><span style=\"color:#E1E4E8\">[single_idx];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- Double-indirect region --- */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (inode->double_indirect </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        *</span><span style=\"color:#E1E4E8\">out_block_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">    /* entire double-indirect region is a hole */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> dbl_offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block_index </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> N_DIRECT </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> PTRS_PER_BLOCK;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> outer_idx  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)(dbl_offset </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> PTRS_PER_BLOCK);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> inner_idx  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)(dbl_offset </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> PTRS_PER_BLOCK);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Read double-indirect block â†’ get outer single-indirect block pointer */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, inode->double_indirect, buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">outer_ptrs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)buf;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> single_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> outer_ptrs</span><span style=\"color:#E1E4E8\">[outer_idx];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (single_block </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        *</span><span style=\"color:#E1E4E8\">out_block_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">    /* this single-indirect slot is a hole */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Read single-indirect block â†’ get data block pointer */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, single_block, buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">inner_ptrs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)buf;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">out_block_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> inner_ptrs</span><span style=\"color:#E1E4E8\">[inner_idx];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>The corresponding &quot;set block&quot; operation â€” assigning a disk block number to a given file offset â€” is used by the write path in Milestone 4. It must create indirect and double-indirect blocks if they don&#39;t yet exist:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Set the disk block number for a given file offset.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * If indirect blocks need to be created to hold the pointer, allocates them.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns 0 on success, negative errno on failure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> inode_set_block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">inode_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    uint64_t</span><span style=\"color:#FFAB70\"> offset</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> disk_block_num</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> block_index </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (offset </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> DOUBLE_LIMIT) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFBIG;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- Direct region --- */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (block_index </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> N_DIRECT) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        inode->blocks[block_index] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> disk_block_num;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- Single-indirect region --- */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (block_index </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> N_DIRECT </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> PTRS_PER_BLOCK) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Allocate the indirect block if it doesn't exist yet */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (inode->single_indirect </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            int</span><span style=\"color:#E1E4E8\"> blk </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_block</span><span style=\"color:#E1E4E8\">(fd, sb);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (blk </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOSPC;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Zero the new indirect block */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint8_t</span><span style=\"color:#FFAB70\"> zeros</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            memset</span><span style=\"color:#E1E4E8\">(zeros, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)blk, zeros) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            inode->single_indirect </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)blk;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, inode->single_indirect, buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">ptrs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)buf;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> single_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)(block_index </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> N_DIRECT);</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        ptrs</span><span style=\"color:#E1E4E8\">[single_idx] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> disk_block_num;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> write_block</span><span style=\"color:#E1E4E8\">(fd, inode->single_indirect, buf);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- Double-indirect region --- */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> dbl_offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block_index </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> N_DIRECT </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> PTRS_PER_BLOCK;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> outer_idx  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)(dbl_offset </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> PTRS_PER_BLOCK);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> inner_idx  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)(dbl_offset </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> PTRS_PER_BLOCK);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Allocate the double-indirect block if needed */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (inode->double_indirect </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> blk </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_block</span><span style=\"color:#E1E4E8\">(fd, sb);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (blk </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOSPC;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint8_t</span><span style=\"color:#FFAB70\"> zeros</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memset</span><span style=\"color:#E1E4E8\">(zeros, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)blk, zeros) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        inode->double_indirect </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)blk;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, inode->double_indirect, buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">outer_ptrs  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)buf;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> single_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> outer_ptrs</span><span style=\"color:#E1E4E8\">[outer_idx];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Allocate the single-indirect block within the double-indirect if needed */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (single_block </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> blk </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_block</span><span style=\"color:#E1E4E8\">(fd, sb);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (blk </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOSPC;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint8_t</span><span style=\"color:#FFAB70\"> zeros</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memset</span><span style=\"color:#E1E4E8\">(zeros, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)blk, zeros) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        outer_ptrs</span><span style=\"color:#E1E4E8\">[outer_idx] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)blk;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        single_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)blk;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, inode->double_indirect, buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Now read the single-indirect block and set the data pointer */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, single_block, buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">inner_ptrs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)buf;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    inner_ptrs</span><span style=\"color:#E1E4E8\">[inner_idx] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> disk_block_num;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> write_block</span><span style=\"color:#E1E4E8\">(fd, single_block, buf);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"explainmulti-level-indirection-pointer-to-pointer-to-data-patternmulti-level-indirection-pointer-to-pointer-to-data-pattern\">[[EXPLAIN:multi-level-indirection-â€”-pointer-to-pointer-to-data-pattern|Multi-level indirection â€” pointer-to-pointer-to-data pattern]]</h2>\n<h2 id=\"sparse-files-when-nothing-is-something\">Sparse Files: When Nothing Is Something</h2>\n<p>Look at <code>inode_get_block</code> again. Notice what happens when <code>block_index &lt; N_DIRECT</code> and <code>inode-&gt;blocks[block_index] == 0</code>: you return <code>*out_block_num = 0</code> with no error. A zero block pointer means the block is <strong>unallocated</strong> â€” it is a <em>hole</em> in the file. When a read operation encounters a zero block pointer, it must return zero bytes without doing any disk I/O.</p>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m2-sparse-file.svg\" alt=\"Sparse File â€” Null Pointers as Holes\"></p>\n<p>This is how sparse files work. Consider:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> create_sparse_file_example</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> inode_num</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> inode;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(inode));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode.mode </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> S_IFREG </span><span style=\"color:#F97583\">|</span><span style=\"color:#F97583\"> 0</span><span style=\"color:#79B8FF\">644</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode.nlinks </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Write one byte at offset 0 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> block0 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">alloc_block</span><span style=\"color:#E1E4E8\">(fd, sb);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'A'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    write_block</span><span style=\"color:#E1E4E8\">(fd, block0, buf);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode.blocks[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block0;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Write one byte at offset 999,999,999 â€” deep in double-indirect range */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* inode_set_block will allocate the indirect blocks as needed */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> blockN </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">alloc_block</span><span style=\"color:#E1E4E8\">(fd, sb);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">999999999</span><span style=\"color:#F97583\"> %</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'Z'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    write_block</span><span style=\"color:#E1E4E8\">(fd, blockN, buf);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    inode_set_block</span><span style=\"color:#E1E4E8\">(fd, sb, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode, </span><span style=\"color:#79B8FF\">999999999</span><span style=\"color:#E1E4E8\">, blockN);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* File size: 1,000,000,000 bytes */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode.size </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1000000000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* But disk usage: 2 data blocks + ~2 indirect blocks = ~16KB */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    write_inode</span><span style=\"color:#E1E4E8\">(fd, sb, inode_num, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Reading byte 500,000,000 (which is between the two written offsets) will encounter a null pointer and return a zero byte â€” no disk I/O for the hole. The file appears to be 1GB, but occupies almost no disk space.\nThis is why <code>ls -l</code> and <code>du</code> report different sizes:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>$ ls -l vm_disk.img\n-rw-r--r-- 1 user user 10737418240 Mar 1 12:00 vm_disk.img   # 10GB\n$ du -sh vm_disk.img\n4.0K  vm_disk.img   # Only 4KB actually allocated</code></pre></div>\n<blockquote>\n<p><strong>Three-Level View â€” Where Zero Bytes Come From</strong></p>\n<table>\n<thead>\n<tr>\n<th>Level</th>\n<th>What Happens When You Read a Sparse Hole</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Application</strong></td>\n<td>Calls <code>read(fd, buf, len)</code>, expects data</td>\n</tr>\n<tr>\n<td><strong>Filesystem</strong></td>\n<td><code>inode_get_block</code> returns 0 for the block pointer. Instead of calling <code>read_block</code>, the read handler calls <code>memset(buf, 0, BLOCK_SIZE)</code> â€” zero-fill in RAM</td>\n</tr>\n<tr>\n<td><strong>Hardware</strong></td>\n<td>No disk I/O at all. The zeros are generated entirely in CPU registers and copied to the output buffer. Reads from holes are <strong>faster</strong> than reads from allocated blocks</td>\n</tr>\n</tbody></table>\n</blockquote>\n<hr>\n<h2 id=\"timestamps-the-three-clocks\">Timestamps: The Three Clocks</h2>\n<p>Every inode carries three timestamps, and getting them right matters â€” tools like <code>rsync</code>, <code>make</code>, and backup software depend on correct timestamp semantics.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;time.h></span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Update inode timestamps based on the operation performed.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Note: In production, use clock_gettime(CLOCK_REALTIME) for</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * nanosecond precision. We use time() for simplicity.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> now_ts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Called when file data is read */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> inode_touch_atime</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">inode_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode->atime </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> now_ts</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Note: atime update requires a write_inode() call by the caller.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * This is why noatime is popular: every read causes a metadata write. */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Called when file data is written */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> inode_touch_mtime</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">inode_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ts </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> now_ts</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode->mtime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ts;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode->ctime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ts;</span><span style=\"color:#6A737D\">   /* data change also changes inode */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Called when inode metadata changes (chmod, chown, link, rename) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> inode_touch_ctime</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">inode_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode->ctime </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> now_ts</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"the-ctime-field-trips-up-developers-who-assume-it-means-quotcreation-timequot-unix-filesystems-traditionally-have-no-creation-time-some-modern-filesystems-add-crtime-or-btime-as-an-extension-ctime-is-the-quotinode-change-timequot-it-updates-whenever-anything-in-the-inode-changes-including-the-link-count-permissions-or-owner-this-means-that-chmod-and-chown-update-ctime-but-not-mtime-the-atime-update-on-every-read-is-one-of-the-most-notorious-filesystem-performance-problems-a-disk-that-serves-mostly-reads-will-perform-writes-for-atime-on-every-read-doubling-io-load-on-the-inode-block-linux-introduced-the-relatime-mount-option-update-atime-only-if-it39s-older-than-mtimectime-and-noatime-never-update-atime-your-fuse-integration-in-milestone-5-will-expose-this-as-a-mount-option\">The <code>ctime</code> field trips up developers who assume it means &quot;creation time.&quot; Unix filesystems traditionally have no creation time (some modern filesystems add <code>crtime</code> or <code>btime</code> as an extension). <code>ctime</code> is the &quot;inode change time&quot; â€” it updates whenever anything in the inode changes, including the link count, permissions, or owner. This means that <code>chmod</code> and <code>chown</code> update <code>ctime</code> but not <code>mtime</code>.\nThe <code>atime</code> update-on-every-read is one of the most notorious filesystem performance problems. A disk that serves mostly reads will perform writes for atime on every read â€” doubling I/O load on the inode block. Linux introduced the <code>relatime</code> mount option (update atime only if it&#39;s older than mtime/ctime) and <code>noatime</code> (never update atime). Your FUSE integration in Milestone 5 will expose this as a mount option.</h2>\n<h2 id=\"block-capacity-math-exactly-how-big-can-files-get\">Block Capacity Math: Exactly How Big Can Files Get?</h2>\n<p>Let&#39;s work through the arithmetic precisely, because it comes up in every production filesystem conversation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Maximum file size addressable by this inode scheme.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Direct:          12 blocks Ã— 4096 bytes         =        49,152 bytes  (~48 KB)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Single-indirect: 1024 blocks Ã— 4096 bytes        =     4,194,304 bytes  (~4 MB)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Double-indirect: 1024 Ã— 1024 Ã— 4096 bytes        = 4,294,967,296 bytes  (~4 GB)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Total:                                           = 4,299,210,752 bytes  (~4.004 GB)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * If we added triple-indirect (ext2/ext3 style):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Triple-indirect: 1024 Ã— 1024 Ã— 1024 Ã— 4096      = 4,398,046,511,104 bytes (~4 TB)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_FILE_BLOCKS</span><span style=\"color:#E1E4E8\">  (N_DIRECT </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> PTRS_PER_BLOCK </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                          (</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)PTRS_PER_BLOCK </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> PTRS_PER_BLOCK)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_FILE_SIZE</span><span style=\"color:#E1E4E8\">    ((</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)MAX_FILE_BLOCKS </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE)</span></span></code></pre></div>\n<h2 id=\"note-that-size-is-stored-as-uint32_t-in-our-inode-4-bytes-max-429-gb-for-files-larger-than-4gb-you-would-need-uint64_t-for-the-size-field-which-is-how-ext4-xfs-and-every-modern-filesystem-implement-it-the-32-bit-size-field-is-a-design-limitation-of-our-simplified-implementation-it-matches-the-original-ext2-design\">Note that <code>size</code> is stored as <code>uint32_t</code> in our inode (4 bytes, max ~4.29 GB). For files larger than 4GB, you would need <code>uint64_t</code> for the size field â€” which is how ext4, XFS, and every modern filesystem implement it. The 32-bit size field is a design limitation of our simplified implementation; it matches the original ext2 design.</h2>\n<h2 id=\"the-structural-parallel-inode-pointers-and-page-tables\">The Structural Parallel: Inode Pointers and Page Tables</h2>\n<p>Here is one of the most illuminating cross-domain connections in systems programming:\n<strong>Your double-indirect block pointer tree is the same structure as a 3-level CPU page table.</strong></p>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m2-inode-vs-pagetable.svg\" alt=\"Inode Pointers vs. x86-64 Page Table â€” Structural Parallel\"></p>\n<p>When the CPU translates a virtual address to a physical address, it walks a multi-level page table:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Virtual address (48 bits on x86-64):\n  Bits 47-39: PML4 index    â†’ which entry in the top-level table\n  Bits 38-30: PDPT index    â†’ which entry in the 2nd-level table\n  Bits 29-21: PD index      â†’ which entry in the 3rd-level table\n  Bits 20-12: PT index      â†’ which entry in the 4th-level table (page table)\n  Bits 11-0:  Page offset   â†’ byte within the physical page (4KB)</code></pre></div>\n<p>Compare this to your file offset translation:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>File offset (38 bits for our 4GB max):\n  Bits 37-22: Double-indirect index â†’ which entry in the outer pointer block\n  Bits 21-12: Single-indirect index â†’ which entry in the inner pointer block\n  Bits 11-0:  Block offset          â†’ byte within the 4KB data block</code></pre></div>\n<p>The structural identity is exact: both systems use a tree of fixed-size pointer arrays to translate an index into a physical resource. The MMU does this in hardware with a register (CR3 on x86) pointing to the top-level table. Your filesystem does it in software with a disk block number stored in the inode.\nThe key property both share: <strong>each level of indirection multiplies capacity by the fanout</strong> (1024 for filesystem blocks, 512 for page table entries). This is a <strong>radix tree</strong> â€” fixed-width indexing that provides O(1) lookup with bounded maximum depth.</p>\n<blockquote>\n<p>ðŸ”­ <strong>Deep Dive</strong>: x86-64 page table structure. If you want to see the hardware version of exactly what you just built, read the Intel Software Developer&#39;s Manual Volume 3, Chapter 4 (&quot;Paging&quot;). Section 4.5 covers 4-level paging with full page-walk diagrams. Every concept maps 1:1 to your double-indirect pointer tree.</p>\n</blockquote>\n<hr>\n<h2 id=\"reference-counting-the-link-count-contract\">Reference Counting: The Link Count Contract</h2>\n<p>The <code>nlinks</code> field implements <strong>reference counting</strong> for inodes. This is the same pattern used by <code>shared_ptr</code> in C++, <code>Arc&lt;T&gt;</code> in Rust, Python&#39;s garbage collector, and every operating system&#39;s file descriptor table.\nThe contract:</p>\n<ul>\n<li><code>nlinks</code> starts at 1 when an inode is created (one directory entry points to it)</li>\n<li>Every <code>link()</code> call (creating a hard link) increments <code>nlinks</code></li>\n<li>Every <code>unlink()</code> call (removing a directory entry) decrements <code>nlinks</code></li>\n<li>When <code>nlinks == 0</code> AND no process has the file open: free the inode</li>\n<li>When <code>nlinks == 0</code> but processes still have it open: defer freeing until last <code>close()</code>\nThe &quot;open but unlinked&quot; case is important: you can <code>unlink(&quot;myfile&quot;)</code> on an open file, and the file continues to exist (and be readable/writable) until the last file descriptor pointing to it is closed. Only then does <code>nlinks</code> hitting 0 trigger actual deallocation. Your filesystem&#39;s &quot;open file table&quot; (implemented in Milestone 5) tracks open file descriptors separately from <code>nlinks</code>.\nFor directories specifically:</li>\n<li>A new directory starts with <code>nlinks = 2</code> (one for its own <code>.</code> entry, one for the parent&#39;s entry pointing to it)</li>\n<li>Each subdirectory increments the parent&#39;s <code>nlinks</code> by 1 (because the subdirectory&#39;s <code>..</code> entry points to the parent)</li>\n<li>This is why deeply nested directories have high link counts, and why <code>find -maxdepth N</code> can use <code>nlinks</code> to prune the search</li>\n</ul>\n<hr>\n<h2 id=\"putting-it-together-inode-initialization\">Putting It Together: Inode Initialization</h2>\n<p>When a new file or directory is created, you need to initialize the inode with correct defaults:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Initialize a newly allocated inode for a regular file.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Caller must call write_inode() afterward to persist it.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> inode_init_file</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">inode_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> mode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> uid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> gid</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(inode, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">inode));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode->mode   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (S_IFREG </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> (mode </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0</span><span style=\"color:#79B8FF\">777</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode->uid    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> uid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode->gid    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode->nlinks </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode->size   </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ts   </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> now_ts</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode->atime  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inode->mtime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inode->ctime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ts;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* All block pointers zeroed by memset â€” file starts with no allocated blocks */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* single_indirect and double_indirect are also 0 â€” both are null */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Initialize a newly allocated inode for a directory.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * nlinks starts at 2: one for the parent entry pointing to it,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * one for the '.' entry within the directory itself.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> inode_init_dir</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">inode_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> mode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> uid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> gid</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(inode, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">inode));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode->mode   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (S_IFDIR </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> (mode </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0</span><span style=\"color:#79B8FF\">777</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode->uid    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> uid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode->gid    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode->nlinks </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode->size   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE;</span><span style=\"color:#6A737D\">   /* directories are sized in block units */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ts   </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> now_ts</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode->atime  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inode->mtime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inode->ctime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ts;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"validation-testing-the-inode-implementation\">Validation: Testing the Inode Implementation</h2>\n<p>Before moving to Milestone 3, verify your inode layer thoroughly:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Test suite for inode layer.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Run after mkfs to verify the inode implementation works correctly.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_inode_layer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">=== Inode Layer Tests ===</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 1: Allocate an inode */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_inode</span><span style=\"color:#E1E4E8\">(fd, sb);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(ino </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: allocated inode </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ino);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 2: Initialize and write it */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> inode;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    inode_init_file</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode, </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">644</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">write_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 3: Read it back and verify fields */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> read_back;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">read_back) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">S_ISREG</span><span style=\"color:#E1E4E8\">(read_back.mode));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(read_back.nlinks </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(read_back.size </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: inode round-trip verified</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 4: Set and get a direct block pointer */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> blk </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_block</span><span style=\"color:#E1E4E8\">(fd, sb);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(blk </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">inode_set_block</span><span style=\"color:#E1E4E8\">(fd, sb, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)blk) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> got_block;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">inode_get_block</span><span style=\"color:#E1E4E8\">(fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">got_block) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(got_block </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)blk);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: direct block pointer set/get</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 5: Sparse file â€” get block for unallocated offset */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">inode_get_block</span><span style=\"color:#E1E4E8\">(fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">got_block) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(got_block </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">    /* must be 0 â€” hole */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: sparse hole returns block 0</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 6: Single-indirect region */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> si_blk </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_block</span><span style=\"color:#E1E4E8\">(fd, sb);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> si_offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)N_DIRECT </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE;</span><span style=\"color:#6A737D\">   /* first single-indirect slot */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">inode_set_block</span><span style=\"color:#E1E4E8\">(fd, sb, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode, si_offset, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)si_blk) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(inode.single_indirect </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   /* indirect block must have been allocated */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">inode_get_block</span><span style=\"color:#E1E4E8\">(fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode, si_offset, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">got_block) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(got_block </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)si_blk);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: single-indirect block pointer set/get</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 7: Double-indirect region */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> di_offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)(N_DIRECT </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> PTRS_PER_BLOCK) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> di_blk </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_block</span><span style=\"color:#E1E4E8\">(fd, sb);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">inode_set_block</span><span style=\"color:#E1E4E8\">(fd, sb, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode, di_offset, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)di_blk) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(inode.double_indirect </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">inode_get_block</span><span style=\"color:#E1E4E8\">(fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode, di_offset, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">got_block) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(got_block </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)di_blk);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: double-indirect block pointer set/get</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 8: Free inode â€” all blocks should be reclaimed */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> free_before </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sb->free_blocks;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    write_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">free_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)ino) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* After freeing: all direct blocks + indirect blocks reclaimed */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: inode freed, </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> blocks reclaimed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           sb->free_blocks </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> free_before);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"=== All Inode Tests Passed ===</span><span style=\"color:#79B8FF\">\\n\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"design-decisions-why-this-pointer-scheme\">Design Decisions: Why This Pointer Scheme?</h2>\n<p>The direct/indirect/double-indirect scheme is not the only way to map files to blocks. Here is how the alternatives compare:</p>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Used By</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Direct + Indirect (chosen âœ“)</strong></td>\n<td>Simple traversal logic; sparse files for free; proven design</td>\n<td>Extra I/Os for large files; fragmentation grows with file age</td>\n<td>ext2, ext3, original Unix FFS</td>\n</tr>\n<tr>\n<td><strong>Extents</strong></td>\n<td>Contiguous runs eliminate per-block metadata; large sequential files have 1 metadata read regardless of size; much lower fragmentation</td>\n<td>Extent trees are complex; sparse files harder to represent</td>\n<td>ext4, XFS (B-tree extents), NTFS, HFS+</td>\n</tr>\n<tr>\n<td><strong>Block map array</strong></td>\n<td>Trivially simple</td>\n<td>Cannot represent large files without enormous inode</td>\n<td>FAT (cluster chains), very small filesystems</td>\n</tr>\n<tr>\n<td><strong>B-tree block map</strong></td>\n<td>Self-balancing; handles arbitrary fragmentation gracefully</td>\n<td>Complex implementation; high constant overhead</td>\n<td>Btrfs (copy-on-write B-tree), ZFS</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>ext4 replaced the indirect pointer scheme with extents â€” an extent is a tuple <code>(start_block, length)</code> that describes a contiguous run of blocks. A 1GB sequential file needs only one extent record instead of 262,144 separate block pointers. This collapses the tree to nearly constant depth for sequential files. The extent tree is a B-tree embedded in the inode&#39;s block pointer fields. Building the indirect pointer scheme first (as you&#39;re doing) is the right starting point â€” extents are an optimization of the same conceptual model.</p>\n</blockquote>\n<hr>\n<h2 id=\"knowledge-cascade-one-inode-ten-worlds\">Knowledge Cascade: One Inode, Ten Worlds</h2>\n<h2 id=\"you-have-built-a-fixed-size-metadata-structure-with-a-tree-of-pointers-to-variable-size-content-this-pattern-is-not-unique-to-filesystems-it-is-the-fundamental-pattern-for-indexing-variable-size-data-with-fixed-size-metadata-b-trees-and-database-indexes-your-indirect-block-pointer-tree-is-a-radix-tree-with-fixed-fanout-1024-a-b-tree-is-the-same-concept-generalized-internal-nodes-are-quotindirect-blocksquot-holding-pointers-to-children-leaf-nodes-are-quotdata-blocksquot-holding-actual-values-the-branching-factor-varies-by-page-size-and-key-size-postgresql39s-b-tree-index-pages-innodb39s-clustered-index-and-sqlite39s-b-tree-pages-all-implement-this-same-quotfixed-size-nodes-variable-depth-treequot-principle-ext439s-extent-tree-is-literally-a-b-tree-embedded-in-the-inode-understanding-your-double-indirect-pointers-gives-you-the-mental-model-to-read-any-b-tree-implementation-and-immediately-see-the-parallel-x86-64-virtual-memory-page-tables-as-shown-above-the-cpu39s-page-table-walker-performs-the-same-operation-as-your-inode_get_block-traversing-a-multi-level-array-of-pointers-to-translate-an-index-into-a-physical-resource-cr3-register-is-the-quotinodequot-page-directory-entries-are-the-quotdouble-indirect-blockquot-page-table-entries-are-the-quotsingle-indirect-blockquot-physical-page-frames-are-the-quotdata-blocksquot-if-you-understand-your-inode_get_block-function-you-understand-how-the-mmu-hardware-walks-page-tables-this-insight-unlocks-reading-procpidmaps-understanding-tlb-shootdowns-and-reasoning-about-memory-mapped-file-performance-sparse-files-in-production-systems-virtual-machine-disk-images-qcow2-vmdk-vdi-rely-on-sparse-file-support-from-the-host-filesystem-a-100gb-vm-disk-image-containing-mostly-zeroes-occupies-only-the-space-for-actual-writes-on-an-ext4-or-xfs-host-cp-sparsealways-and-rsync-sparse-are-tools-that-preserve-this-sparseness-backing-databases-qcow2-copy-on-write-work-by-allocating-blocks-on-first-write-exactly-what-your-inode_set_block-does-when-a-block-is-first-written-understanding-null-pointers-holes-means-understanding-how-vm-provisioning-achieves-quotthin-provisioningquot-reference-counting-in-language-runtimes-nlinks-in-the-inode-solves-the-same-problem-as-stdshared_ptrlttgtuse_count-in-c-arcstrong_count-in-rust-cpython39s-ob_refcnt-and-swift39s-arc-the-pattern-is-universal-a-shared-resource-tracks-the-number-of-references-to-it-when-that-count-reaches-zero-the-resource-is-freed-the-filesystem-version-has-one-complication-that-smart-pointers-don39t-the-quotopen-but-unlinkedquot-case-where-a-process-can-hold-a-file-descriptor-to-a-file-whose-nlinks-has-dropped-to-zero-this-is-the-filesystem-equivalent-of-a-quotweak-referencequot-keeping-a-resource-alive-the-nlinks-0-condition-is-the-destructor-trigger-but-only-fires-when-no-quotstrong-holdsquot-open-file-descriptors-remain-git-object-storage-and-content-addressable-systems-git39s-object-store-faces-an-identical-design-challenge-fixed-size-metadata-a-commit-object-author-timestamp-message-parent-pointers-tree-pointer-pointing-to-variable-size-content-file-trees-and-blobs-git39s-quottree-objectsquot-map-filenames-to-blob-hashes-exactly-like-your-inode39s-block-pointer-array-maps-block-indices-to-disk-block-numbers-git39s-blob-objects-are-like-your-data-blocks-the-metadatacontent-separation-in-your-inode-design-is-the-same-abstraction-that-makes-content-addressable-storage-docker-image-layers-and-merkle-trees-work-when-you-understand-inodes-you-understand-why-git39s-quotpack-filesquot-docker39s-quotlayersquot-and-your-filesystem39s-quotdata-blocksquot-are-all-solving-the-same-structural-problem-object-storage-metadata-s3-gcs-cloud-object-storage-systems-maintain-metadata-records-for-each-object-size-creation-time-content-type-etag-hash-owner-access-permissions-this-metadata-is-small-hundreds-of-bytes-and-lives-in-a-separate-system-from-the-object-data-potentially-terabytes-the-metadata-to-data-separation-is-architecturally-identical-to-your-inode-when-you-upload-a-5tb-file-to-s3-a-few-hundred-bytes-of-metadata-are-written-to-a-distributed-key-value-store-while-the-data-itself-flows-through-a-separate-data-plane-to-redundant-storage-servers-your-inode-is-the-on-disk-instantiation-of-this-split-that-cloud-engineers-implement-at-global-scale\">You have built a fixed-size metadata structure with a tree of pointers to variable-size content. This pattern is not unique to filesystems. It is <strong>the</strong> fundamental pattern for indexing variable-size data with fixed-size metadata.\n<strong>â†’ B-Trees and Database Indexes</strong>\nYour indirect block pointer tree is a radix tree with fixed fanout (1024). A B-tree is the same concept generalized: internal nodes are &quot;indirect blocks&quot; holding pointers to children; leaf nodes are &quot;data blocks&quot; holding actual values. The branching factor varies by page size and key size. PostgreSQL&#39;s B-tree index pages, InnoDB&#39;s clustered index, and SQLite&#39;s B-tree pages all implement this same &quot;fixed-size nodes, variable-depth tree&quot; principle. ext4&#39;s extent tree is literally a B-tree embedded in the inode. Understanding your double-indirect pointers gives you the mental model to read any B-tree implementation and immediately see the parallel.\n<strong>â†’ x86-64 Virtual Memory Page Tables</strong>\nAs shown above, the CPU&#39;s page table walker performs the same operation as your <code>inode_get_block</code> â€” traversing a multi-level array of pointers to translate an index into a physical resource. CR3 register is the &quot;inode&quot;; page directory entries are the &quot;double-indirect block&quot;; page table entries are the &quot;single-indirect block&quot;; physical page frames are the &quot;data blocks.&quot; If you understand your <code>inode_get_block</code> function, you understand how the MMU hardware walks page tables. This insight unlocks reading <code>/proc/PID/maps</code>, understanding TLB shootdowns, and reasoning about memory-mapped file performance.\n<strong>â†’ Sparse Files in Production Systems</strong>\nVirtual machine disk images (QCOW2, VMDK, VDI) rely on sparse file support from the host filesystem. A 100GB VM disk image containing mostly zeroes occupies only the space for actual writes on an ext4 or XFS host. <code>cp --sparse=always</code> and <code>rsync --sparse</code> are tools that preserve this sparseness. Backing databases (QCOW2 copy-on-write) work by allocating blocks on first write â€” exactly what your <code>inode_set_block</code> does when a block is first written. Understanding null pointers = holes means understanding how VM provisioning achieves &quot;thin provisioning.&quot;\n<strong>â†’ Reference Counting in Language Runtimes</strong>\n<code>nlinks</code> in the inode solves the same problem as <code>std::shared_ptr&lt;T&gt;::use_count()</code> in C++, <code>Arc::strong_count()</code> in Rust, CPython&#39;s <code>ob_refcnt</code>, and Swift&#39;s ARC. The pattern is universal: a shared resource tracks the number of references to it; when that count reaches zero, the resource is freed. The filesystem version has one complication that smart pointers don&#39;t: the &quot;open but unlinked&quot; case, where a process can hold a file descriptor to a file whose <code>nlinks</code> has dropped to zero. This is the filesystem equivalent of a &quot;weak reference&quot; keeping a resource alive â€” the <code>nlinks = 0</code> condition is the destructor trigger, but only fires when no &quot;strong holds&quot; (open file descriptors) remain.\n<strong>â†’ Git Object Storage and Content-Addressable Systems</strong>\nGit&#39;s object store faces an identical design challenge: fixed-size metadata (a commit object: author, timestamp, message, parent pointers, tree pointer) pointing to variable-size content (file trees and blobs). Git&#39;s &quot;tree objects&quot; map filenames to blob hashes â€” exactly like your inode&#39;s block pointer array maps block indices to disk block numbers. Git&#39;s blob objects are like your data blocks. The metadata/content separation in your inode design is the same abstraction that makes content-addressable storage, Docker image layers, and Merkle trees work. When you understand inodes, you understand why Git&#39;s &quot;pack files,&quot; Docker&#39;s &quot;layers,&quot; and your filesystem&#39;s &quot;data blocks&quot; are all solving the same structural problem.\n<strong>â†’ Object Storage Metadata (S3, GCS)</strong>\nCloud object storage systems maintain metadata records for each object: size, creation time, content-type, ETag (hash), owner, access permissions. This metadata is small (hundreds of bytes) and lives in a separate system from the object data (potentially terabytes). The metadata-to-data separation is architecturally identical to your inode. When you upload a 5TB file to S3, a few hundred bytes of metadata are written to a distributed key-value store, while the data itself flows through a separate data plane to redundant storage servers. Your inode is the on-disk instantiation of this split that cloud engineers implement at global scale.</h2>\n<h2 id=\"before-you-move-on-pitfall-checklist\">Before You Move On: Pitfall Checklist</h2>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Never use block 0 as a data block</strong>: <code>alloc_block</code> returns absolute disk block numbers starting at <code>data_block_start</code>. If you ever see <code>inode-&gt;blocks[i] == 0</code> on an allocated block, something is wrong â€” 0 is the superblock, not a data block. The null/hole sentinel works because legitimate data blocks always have numbers â‰¥ <code>data_block_start</code>.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Indirect block deallocation</strong>: Call <code>free_single_indirect</code> and <code>free_double_indirect</code> in your <code>free_inode</code>. Audit this path by counting <code>sb-&gt;free_blocks</code> before and after freeing a large file â€” the delta should match the number of data blocks plus indirect pointer blocks.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Off-by-one in boundary calculations</strong>: The single-indirect region starts at block index <code>N_DIRECT</code> (12), not <code>N_DIRECT + 1</code>. The double-indirect region starts at block index <code>N_DIRECT + PTRS_PER_BLOCK</code> (1036). An off-by-one here silently corrupts a different block than you intend.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong><code>_Static_assert</code> on inode size</strong>: Add <code>_Static_assert(sizeof(inode_t) == 128, &quot;inode_t size mismatch&quot;)</code>. If you add a field and forget to shrink <code>reserved[]</code>, the compiler will catch it rather than silently misaligning every inode in the table.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Zero the entire inode on allocation</strong>: <code>memset(&amp;inode, 0, sizeof(inode))</code> before <code>inode_init_*</code>. Uninitialized garbage in <code>reserved[]</code> or unused pointer slots causes spurious non-zero pointer values that <code>inode_get_block</code> will try to read as block numbers.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Update <code>ctime</code> on inode writes</strong>: Any operation that modifies the inode (permissions change, link count change, block pointer addition) must update <code>ctime</code>. Forgetting this makes <code>stat()</code> return stale metadata that confuses rsync and backup tools.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Bitmap flush before inode write</strong>: When allocating blocks to satisfy <code>inode_set_block</code>, write the updated bitmap to disk before writing the updated inode. If you crash between the two writes, a bitmap that says the block is used but no inode pointing to it is a leaked block (safe). A bitmap that says the block is free but an inode points to it is double-allocation (catastrophic).</li>\n</ul>\n<hr>\n<h2 id=\"what-you39ve-built-and-what-comes-next\">What You&#39;ve Built and What Comes Next</h2>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-L0-satellite-map.svg\" alt=\"Filesystem Atlas â€” Satellite Map (Home Base)\"></p>\n<h2 id=\"you-now-have-a-complete-inode-layer-a-fixed-size-structure-that-can-represent-any-file-from-0-bytes-to-4gb-a-pointer-tree-with-three-levels-of-indirection-that-costs-zero-extra-disk-reads-for-small-files-one-extra-read-for-medium-files-and-two-extra-reads-for-large-files-sparse-files-where-null-pointers-cost-nothing-reference-counting-that-properly-tracks-all-names-pointing-to-a-file-and-the-ability-to-serialize-all-of-this-to-and-from-exact-byte-positions-on-disk-but-an-inode-has-no-name-inodes-don39t-know-what-they39re-called-that-knowledge-lives-in-the-directory-a-directory-is-a-special-kind-of-file-whose-data-blocks-contain-structured-records-mapping-names-to-inode-numbers-in-milestone-3-you39ll-build-those-directory-entries-implement-the-path-resolution-algorithm-that-translates-homeuserprojectsfiletxt-into-a-sequence-of-inode-lookups-and-implement-mkdir-rmdir-link-and-unlink-with-their-correct-link-count-semantics-the-inode39s-mode-field-already-knows-whether-it39s-a-directory-s_ifdir-now-it39s-time-to-give-the-directory-its-voice\">You now have a complete inode layer. A fixed-size structure that can represent any file from 0 bytes to 4GB. A pointer tree with three levels of indirection that costs zero extra disk reads for small files, one extra read for medium files, and two extra reads for large files. Sparse files where null pointers cost nothing. Reference counting that properly tracks all names pointing to a file. And the ability to serialize all of this to and from exact byte positions on disk.\nBut an inode has no name. Inodes don&#39;t know what they&#39;re called â€” that knowledge lives in the directory. A directory is a special kind of file whose data blocks contain structured records mapping names to inode numbers. In Milestone 3, you&#39;ll build those directory entries, implement the path resolution algorithm that translates <code>/home/user/projects/file.txt</code> into a sequence of inode lookups, and implement <code>mkdir</code>, <code>rmdir</code>, <code>link</code>, and <code>unlink</code> with their correct link count semantics.\nThe inode&#39;s <code>mode</code> field already knows whether it&#39;s a directory (<code>S_IFDIR</code>). Now it&#39;s time to give the directory its voice.</h2>\n<!-- END_MS -->\n\n\n<!-- MS_ID: filesystem-m3 -->\n<!-- MS_ID: filesystem-m3 -->\n<h1 id=\"milestone-3-directory-operations\">Milestone 3: Directory Operations</h1>\n<h2 id=\"the-directory-is-a-lie-you-have-always-believed\">The Directory Is a Lie You Have Always Believed</h2>\n<p>You have been lied to since the first time you opened a file manager.\nThe GUI shows you folders. Nested, hierarchical, expandable folders. You double-click a folder and it opens. You drag files into folders. You see a tree structure â€” a visual hierarchy where folders contain other folders and files live inside them. The entire metaphor screams: <strong>folders are containers. Files live inside them. The two are fundamentally different things.</strong>\nNow open a terminal and run this:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /tmp</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">total</span><span style=\"color:#79B8FF\"> 24</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">drwxrwxrwt</span><span style=\"color:#79B8FF\">  8</span><span style=\"color:#9ECBFF\"> root</span><span style=\"color:#9ECBFF\"> root</span><span style=\"color:#79B8FF\"> 4096</span><span style=\"color:#9ECBFF\"> Mar</span><span style=\"color:#79B8FF\">  1</span><span style=\"color:#9ECBFF\"> 12:00</span><span style=\"color:#9ECBFF\"> .</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">drwxr-xr-x</span><span style=\"color:#79B8FF\"> 20</span><span style=\"color:#9ECBFF\"> root</span><span style=\"color:#9ECBFF\"> root</span><span style=\"color:#79B8FF\"> 4096</span><span style=\"color:#9ECBFF\"> Mar</span><span style=\"color:#79B8FF\">  1</span><span style=\"color:#9ECBFF\"> 12:00</span><span style=\"color:#9ECBFF\"> ..</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">drwx------</span><span style=\"color:#79B8FF\">  2</span><span style=\"color:#9ECBFF\"> user</span><span style=\"color:#9ECBFF\"> user</span><span style=\"color:#79B8FF\"> 4096</span><span style=\"color:#9ECBFF\"> Mar</span><span style=\"color:#79B8FF\">  1</span><span style=\"color:#9ECBFF\"> 12:00</span><span style=\"color:#9ECBFF\"> some_dir</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">-rw-r--r--</span><span style=\"color:#79B8FF\">  1</span><span style=\"color:#9ECBFF\"> user</span><span style=\"color:#9ECBFF\"> user</span><span style=\"color:#79B8FF\">  142</span><span style=\"color:#9ECBFF\"> Mar</span><span style=\"color:#79B8FF\">  1</span><span style=\"color:#9ECBFF\"> 12:00</span><span style=\"color:#9ECBFF\"> some_file.txt</span></span></code></pre></div>\n<p>Notice that <code>some_dir</code> is listed with <code>d</code> permissions and <code>some_file.txt</code> is listed with <code>-</code> permissions. The <code>d</code> tells you the type. But that <code>4096</code> size for <code>some_dir</code>? That is exactly one block. One file-sized block. A directory has a <em>size</em>. It has an <em>inode number</em>. It has timestamps. It has an owner. Every single field you built in Milestone 2&#39;s <code>inode_t</code> applies to directories.\nBecause <strong>a directory is a file</strong>.\nNot &quot;kind of like a file.&quot; Not &quot;similar to a file.&quot; A directory <em>is</em> a file, with one difference: its data blocks contain a structured array of records mapping names to inode numbers instead of containing application data. The VFS (Virtual Filesystem Switch â€” the kernel&#39;s abstraction layer over all filesystem types) gives directories the <code>S_IFDIR</code> type bit in <code>mode</code>, and the kernel interprets that to mean &quot;the data in this file&#39;s blocks is a list of directory entries, not raw data.&quot; But the storage mechanism â€” inode pointing to data blocks â€” is identical.\nThis revelation collapses three separate &quot;things&quot; (files, folders, the path system) into one. And once you understand that a directory is a file, the path resolution algorithm <code>/home/user/projects/file.txt â†’ inode 42</code> becomes completely mechanical, blindingly obvious, and satisfying in its recursive simplicity.\nLet&#39;s build it.</p>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m3-directory-tree.svg\" alt=\"Directory Tree as Inode Graph â€” From Structure to Mental Model\"></p>\n<hr>\n<h2 id=\"the-fundamental-tension-hierarchical-names-flat-blocks\">The Fundamental Tension: Hierarchical Names, Flat Blocks</h2>\n<p>Here is the core hardware and design constraint you are negotiating with:\n<strong>Humans organize knowledge hierarchically and refer to things by name. Storage hardware is a flat array of numbered blocks with no concept of names, hierarchies, or relationships.</strong>\nWhen you type <code>/usr/bin/gcc</code>, you are expressing a 3-level hierarchy: root â†’ <code>usr</code> â†’ <code>bin</code> â†’ <code>gcc</code>. The disk stores four separate block regions: one for the root directory&#39;s entry list, one for <code>/usr</code>&#39;s entry list, one for <code>/bin</code>&#39;s entry list, and one for <code>gcc</code>&#39;s actual inode and data blocks. The &quot;hierarchy&quot; exists nowhere on disk as a single structure. It is an emergent property of files that point to other files.\nEvery path lookup must be <em>computed</em> by walking this chain. There is no shortcut. There is no global hash table. <code>getattr(&quot;/usr/bin/gcc&quot;)</code> requires at minimum:</p>\n<ol>\n<li>Read root directory&#39;s data blocks â†’ find <code>usr</code> â†’ get inode 14</li>\n<li>Read inode 14&#39;s data blocks â†’ find <code>bin</code> â†’ get inode 81  </li>\n<li>Read inode 81&#39;s data blocks â†’ find <code>gcc</code> â†’ get inode 4431</li>\n<li>Read inode 4431 â†’ this is your file\nThat&#39;s 4+ disk reads for a trivial path. For <code>/usr/lib/python3.11/site-packages/numpy/core/_multiarray_umath.cpython-311-x86_64-linux-gnu.so</code> (a real file path), you&#39;d walk 9 levels. Linux solves this with the <strong>dcache</strong> (directory entry cache) â€” a kernel-level in-memory hash table mapping <code>(parent_inode, name) â†’ child_inode</code>. In your FUSE filesystem, every path lookup must traverse from root unless you implement a dcache. This is the central performance problem of directory-based filesystems, and FUSE exposes it nakedly.\nThe numbers: on a cold cache, each directory lookup requires 1â€“2 disk reads (inode block + data block). An SSD costs ~100Î¼s per read. A 9-component path = 18 reads = ~1.8ms just for the lookup, before any data is read. The Linux dcache converts this to nanoseconds for hot paths.</li>\n</ol>\n<hr>\n<h2 id=\"the-directory-entry-on-disk-format\">The Directory Entry: On-Disk Format</h2>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m3-directory-entry-layout.svg\" alt=\"Directory Entry Structure â€” On-Disk Format\"></p>\n<p>A directory&#39;s data blocks contain a sequence of <strong>directory entries</strong> (dirents). Each entry is a variable-length record with a fixed-size header and a variable-length name field. Here is the design we&#39;ll use, closely modeled after ext2&#39;s format:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Directory entry â€” on-disk format.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * BYTE LAYOUT:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 0: inode_num  (4 bytes) â€” 0 means deleted/unused entry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 4: rec_len    (2 bytes) â€” total length of this record (for skipping)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 6: name_len   (1 byte)  â€” length of name field (NOT null-terminated length)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 7: file_type  (1 byte)  â€” type hint: 0=unknown, 1=regular, 2=directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 8: name       (name_len bytes) â€” the filename, NOT null-terminated on disk</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   [padding to align rec_len to a 4-byte boundary]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * rec_len is CRITICAL: it tells you how many bytes to advance to find the NEXT entry.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This allows entries to span variable widths while keeping the scan efficient.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * The last entry in a block has rec_len extended to fill the remaining space,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * acting as a sentinel so you know where the block ends.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_FILENAME_LEN</span><span style=\"color:#79B8FF\">   255</span><span style=\"color:#6A737D\">    /* POSIX NAME_MAX */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DIRENT_HEADER_SIZE</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#6A737D\">      /* inode_num + rec_len + name_len + file_type */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* File type constants for dirent.file_type */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> FT_UNKNOWN</span><span style=\"color:#79B8FF\">   0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> FT_REG_FILE</span><span style=\"color:#79B8FF\">  1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> FT_DIR</span><span style=\"color:#79B8FF\">       2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> FT_SYMLINK</span><span style=\"color:#79B8FF\">   7</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * In-memory representation â€” easier to work with than the raw on-disk format.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * We serialize to/from the variable-length on-disk format manually.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> inode_num;</span><span style=\"color:#6A737D\">          /* target inode number (0 = free slot) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> rec_len;</span><span style=\"color:#6A737D\">            /* total record length including padding */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\">  name_len;</span><span style=\"color:#6A737D\">           /* length of name, not including any null */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\">  file_type;</span><span style=\"color:#6A737D\">          /* FT_* constant */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\">     name</span><span style=\"color:#E1E4E8\">[MAX_FILENAME_LEN </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">  /* name, always null-terminated in memory */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">dirent_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n<p>The <code>rec_len</code> field deserves careful attention. It is <strong>not</strong> <code>DIRENT_HEADER_SIZE + name_len</code>. It is the total number of bytes consumed by this entry in the directory block, which includes:</p>\n<ol>\n<li>The fixed 8-byte header</li>\n<li>The name bytes (<code>name_len</code>)</li>\n<li>Padding bytes to align the next entry to a 4-byte boundary</li>\n<li>For the <strong>last</strong> active entry in a block, <code>rec_len</code> is extended to fill the remaining bytes of the block â€” this entry &quot;owns&quot; all remaining space\nThis variable-length, forward-linked record format means directory scanning is always sequential: read entry at offset 0, advance by <code>rec_len</code>, read next entry, repeat until you&#39;ve consumed <code>BLOCK_SIZE</code> bytes.</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Compute the actual (padded) record length for a given name length.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Entries are padded to 4-byte alignment.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   name_len=1  â†’ 8 + 1 = 9  â†’ pad to 12</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   name_len=2  â†’ 8 + 2 = 10 â†’ pad to 12</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   name_len=3  â†’ 8 + 3 = 11 â†’ pad to 12</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   name_len=4  â†’ 8 + 4 = 12 â†’ already aligned</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   name_len=8  â†’ 8 + 8 = 16 â†’ already aligned</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint16_t</span><span style=\"color:#B392F0\"> dirent_actual_len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#FFAB70\"> name_len</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> raw </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> DIRENT_HEADER_SIZE </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> name_len;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\">)((raw </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#F97583\">u</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   /* round up to next multiple of 4 */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Write a dirent_t to a raw byte buffer at a given offset.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns the number of bytes written (rec_len).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint16_t</span><span style=\"color:#B392F0\"> dirent_write_to_buf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> offset</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                     const</span><span style=\"color:#79B8FF\"> dirent_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">de</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> buf </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> offset;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(p </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">de->inode_num, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(p </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">de->rec_len,   </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(p </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">de->name_len,  </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(p </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 7</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">de->file_type, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(p </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">, de->name, de->name_len);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* zero the padding bytes */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> actual </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dirent_actual_len</span><span style=\"color:#E1E4E8\">(de->name_len);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (actual </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> DIRENT_HEADER_SIZE </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> de->name_len) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memset</span><span style=\"color:#E1E4E8\">(p </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> DIRENT_HEADER_SIZE </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> de->name_len, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               actual </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> DIRENT_HEADER_SIZE </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> de->name_len);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> de->rec_len;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Read a dirent_t from a raw byte buffer at a given offset.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns the rec_len to advance to the next entry.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns 0 if the entry is a deleted slot (inode_num == 0 but rec_len != 0).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint16_t</span><span style=\"color:#B392F0\"> dirent_read_from_buf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> uint8_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> offset</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                                      dirent_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">de</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> uint8_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> buf </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> offset;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">de->inode_num, p </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">de->rec_len,   p </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">de->name_len,  p </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">de->file_type, p </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 7</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (de->rec_len </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> DIRENT_HEADER_SIZE </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> de->rec_len </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> BLOCK_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">    /* corrupted entry â€” stop scan */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (de->name_len </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> de->name_len </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> MAX_FILENAME_LEN) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memcpy</span><span style=\"color:#E1E4E8\">(de->name, p </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">, de->name_len);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    de->name[de->name_len] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   /* always null-terminate in memory */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> de->rec_len;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<blockquote>\n<p><strong>Why variable-length entries instead of fixed-size?</strong>\nFixed-size entries are simpler to implement, but they waste enormous space. If you allocate 256 bytes per entry (to hold the max 255-char filename), a directory with 100 files named <code>a</code>, <code>b</code>, <code>c</code> consumes 25KB just for entries that average 9 bytes each. Variable-length entries pack at density proportional to actual name length. The downside: you cannot randomly access entry N without scanning from the start. For directories with hundreds of entries, this linear scan becomes a bottleneck â€” which is why ext4 introduced <code>htree</code> (hash-tree) directories as an optimization (see Knowledge Cascade below).</p>\n</blockquote>\n<hr>\n<h2 id=\"scanning-a-directory-block\">Scanning a Directory Block</h2>\n<p>The workhorse of all directory operations is scanning a directory&#39;s data blocks for a specific name. Let&#39;s implement this as a clean, reusable primitive:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Scan all entries in a single directory data block.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Calls callback for each valid entry (inode_num != 0).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * callback return values:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   0  â†’ continue scanning</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   1  â†’ stop scanning, entry found (caller checks de->inode_num)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *  &#x3C;0  â†’ stop scanning, error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns the inode number of the matching entry, 0 if not found, &#x3C;0 on error.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">dirent_callback_t</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> dirent_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">de, </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">userdata);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> scan_dir_block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> uint8_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">block_buf</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                          dirent_callback_t</span><span style=\"color:#FFAB70\"> cb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">userdata</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (offset </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> DIRENT_HEADER_SIZE </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        dirent_t</span><span style=\"color:#E1E4E8\"> de;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint16_t</span><span style=\"color:#E1E4E8\"> rec_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dirent_read_from_buf</span><span style=\"color:#E1E4E8\">(block_buf, offset, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">de);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (rec_len </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">     /* corrupted â€” stop */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (de.inode_num </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span><span style=\"color:#6A737D\">     /* skip deleted entries */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            int</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> cb</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">de, userdata);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        offset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> rec_len;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Callback + userdata for name lookup */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">target_name;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\">    found_inode;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">lookup_ctx_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> lookup_cb</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> dirent_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">de</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">userdata</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    lookup_ctx_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">ctx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">lookup_ctx_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)userdata;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (de->name_len </span><span style=\"color:#F97583\">==</span><span style=\"color:#B392F0\"> strlen</span><span style=\"color:#E1E4E8\">(ctx->target_name) </span><span style=\"color:#F97583\">&#x26;&#x26;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memcmp</span><span style=\"color:#E1E4E8\">(de->name, ctx->target_name, de->name_len) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ctx->found_inode </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> de->inode_num;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   /* found â€” stop scan */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   /* keep scanning */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Look up a single name component in a directory inode.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns the inode number of the matching entry, or 0 if not found.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns &#x3C;0 on I/O error.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> dir_lookup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">               const</span><span style=\"color:#79B8FF\"> inode_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">dir_inode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">S_ISDIR</span><span style=\"color:#E1E4E8\">(dir_inode->mode)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTDIR;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    lookup_ctx_t</span><span style=\"color:#E1E4E8\"> ctx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { .target_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> name, .found_inode </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Scan each direct block of the directory */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> N_DIRECT; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (dir_inode->blocks[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, dir_inode->blocks[i], buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> scan_dir_block</span><span style=\"color:#E1E4E8\">(buf, lookup_cb, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">ctx);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)ctx.found_inode;</span><span style=\"color:#6A737D\">   /* found */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* For milestone 3, we handle directories up to 12 direct blocks (48KB).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * In practice, that's 48KB / ~12 bytes avg per entry â‰ˆ 4000 entries â€”</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * sufficient for most use cases. Single-indirect support is straightforward</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * to add by extending this loop to use inode_get_block() instead. */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   /* not found */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<blockquote>\n<p><strong>Hardware Soul â€” Directory Scan Performance</strong>:\nScanning a directory&#39;s data blocks is a sequential memory read of 4KB chunks. Once the first block is in the L1 or L2 cache (64KB and 256KB respectively on typical x86-64), subsequent scans of the same directory data are at memory speed: ~4ns per cache line (64 bytes), covering 8 entries per cache line for short names. A 100-entry directory fits in 2â€“3 cache lines&#39; worth of data â€” the entire lookup completes in under 20ns from L1. The bottleneck is the initial disk read if the block is cold: ~100Î¼s on SSD. This 5,000Ã— gap between cached and uncached lookup is exactly what Linux&#39;s dcache eliminates.</p>\n</blockquote>\n<hr>\n<h2 id=\"path-resolution-walking-the-tree\">Path Resolution: Walking the Tree</h2>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m3-path-resolution.svg\" alt=\"Path Resolution â€” Walking /home/user/file.txt\"></p>\n<p>Path resolution is the algorithm that converts a string like <code>/home/user/projects/file.txt</code> into an inode number. It is one of the most frequently executed operations in any OS, and every single call to <code>open()</code>, <code>stat()</code>, <code>access()</code>, <code>mkdir()</code>, <code>rename()</code>, and most other syscalls triggers it.\n[[EXPLAIN:vfs-namei-â€”-the-kernel-path-resolution-engine|VFS namei â€” how the Linux kernel resolves pathnames through dentry cache and filesystem methods]]\nThe algorithm is beautifully simple:</p>\n<ol>\n<li>Start at the root inode (if path begins with <code>/</code>) or the current working directory inode (if relative path)</li>\n<li>Tokenize the path by <code>/</code> separators, skipping empty components</li>\n<li>For each component <code>name</code>:\na. Verify the current inode is a directory (<code>S_ISDIR(mode)</code>)\nb. Scan the directory&#39;s data blocks for an entry matching <code>name</code>\nc. Get the inode number from that entry\nd. Load that inode â€” it becomes the &quot;current inode&quot; for the next component</li>\n<li>After the last component, return the inode number\nThe <code>..</code> and <code>.</code> entries are <strong>real directory entries stored on disk</strong> â€” not special kernel magic. When you hit <code>..</code>, you look it up like any other name, find its inode number, load that inode, and continue. When you hit <code>.</code>, you find the same inode you&#39;re already at. The tree traversal is entirely implemented by the normal lookup mechanism.</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Resolve a path to an inode number.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * path:      absolute path (must start with '/') or relative path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * root_ino:  inode number of the filesystem root (from sb->root_inode)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * cwd_ino:   inode number of the current working directory (use root_ino</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *            if you don't track per-process cwd)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns inode number on success, or a negative errno value.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> path_resolve</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                 const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> root_ino</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> cwd_ino</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (path </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Determine starting inode */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> current_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '/'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> root_ino </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> cwd_ino;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Work on a mutable copy of the path for tokenization */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> path_copy</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(path) </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(path_copy)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENAMETOOLONG;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    strncpy</span><span style=\"color:#E1E4E8\">(path_copy, path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(path_copy) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    path_copy</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(path_copy) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Tokenize by '/' and walk each component */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">saveptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">component </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strtok_r</span><span style=\"color:#E1E4E8\">(path_copy, </span><span style=\"color:#9ECBFF\">\"/\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">saveptr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (component </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Skip empty components (result of consecutive '/' in path) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">component</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            component </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strtok_r</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"/\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">saveptr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Enforce filename length limit */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(component) </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> MAX_FILENAME_LEN) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENAMETOOLONG;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Load the current directory inode */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        inode_t</span><span style=\"color:#E1E4E8\"> dir_inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, current_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dir_inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Must be a directory to descend into */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">S_ISDIR</span><span style=\"color:#E1E4E8\">(dir_inode.mode)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTDIR;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Look up this component in the directory */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> child_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dir_lookup</span><span style=\"color:#E1E4E8\">(fd, sb, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dir_inode, component);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (child_ino </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOENT;</span><span style=\"color:#6A737D\">    /* not found */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (child_ino </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> child_ino;</span><span style=\"color:#6A737D\">  /* I/O error */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)child_ino;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        component </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strtok_r</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"/\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">saveptr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)current_ino;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Variant: resolve all but the last component, returning the parent inode</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * and the final component name. Used by create, mkdir, unlink, rename.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Example: path = \"/home/user/new_file.txt\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   â†’ parent_ino = inode of \"/home/user\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   â†’ name_out   = \"new_file.txt\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> path_resolve_parent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> root_ino</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> cwd_ino</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">parent_ino_out</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">name_out</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> name_max</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Find the last '/' to split parent path from final component */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">last_slash </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strrchr</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#9ECBFF\">'/'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (last_slash </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Relative path with no slash â€” parent is cwd */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        *</span><span style=\"color:#E1E4E8\">parent_ino_out </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cwd_ino;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(path) </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> name_max) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENAMETOOLONG;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        strncpy</span><span style=\"color:#E1E4E8\">(name_out, path, name_max </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        name_out</span><span style=\"color:#E1E4E8\">[name_max </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (last_slash </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> path) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Path like \"/filename\" â€” parent is root */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        *</span><span style=\"color:#E1E4E8\">parent_ino_out </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> root_ino;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Path like \"/home/user/filename\" â€” resolve parent portion */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#FFAB70\"> parent_path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> parent_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)(last_slash </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> path);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (parent_len </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(parent_path)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENAMETOOLONG;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memcpy</span><span style=\"color:#E1E4E8\">(parent_path, path, parent_len);</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        parent_path</span><span style=\"color:#E1E4E8\">[parent_len] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> p </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> path_resolve</span><span style=\"color:#E1E4E8\">(fd, sb, parent_path, root_ino, cwd_ino);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (p </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> p;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        *</span><span style=\"color:#E1E4E8\">parent_ino_out </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)p;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Extract the final component */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">filename </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> last_slash </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(filename) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span><span style=\"color:#6A737D\">    /* trailing slash */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(filename) </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> name_max) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENAMETOOLONG;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    strncpy</span><span style=\"color:#E1E4E8\">(name_out, filename, name_max </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    name_out</span><span style=\"color:#E1E4E8\">[name_max </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<blockquote>\n<p><strong>Three-Level View â€” What Happens When <code>path_resolve(&quot;/usr/bin/gcc&quot;)</code> Runs</strong></p>\n<table>\n<thead>\n<tr>\n<th>Level</th>\n<th>What Happens</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Application</strong></td>\n<td>Calls <code>open(&quot;/usr/bin/gcc&quot;, O_RDONLY)</code>. The path string lives in process memory.</td>\n</tr>\n<tr>\n<td><strong>OS / Kernel (Linux)</strong></td>\n<td>The VFS <code>namei</code> subsystem tokenizes the path and walks the dcache (dentry cache). If <code>(root_ino, &quot;usr&quot;)</code> is in the dcache, it returns the child dentry without any disk I/O. For a cold cache, it calls your filesystem&#39;s <code>lookup</code> method for each component. The kernel tracks the current directory per-process via <code>task_struct.fs-&gt;pwd</code>.</td>\n</tr>\n<tr>\n<td><strong>Hardware</strong></td>\n<td>For each directory block read: the block device driver issues a read request. The DMA controller transfers 4KB from disk into a kernel page cache page. Your filesystem code then scans that memory â€” at memory bus speed (~50GB/s), scanning 4KB takes under 100ns.</td>\n</tr>\n</tbody></table>\n</blockquote>\n<hr>\n<h2 id=\"adding-and-removing-entries-the-mutation-api\">Adding and Removing Entries: The Mutation API</h2>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m3-dir-entry-deletion.svg\" alt=\"Directory Entry Removal â€” Before/After Block State\"></p>\n<h3 id=\"add_entry-writing-a-new-name\"><code>add_entry</code>: Writing a New Name</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Add a directory entry to a directory inode.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Appends the new entry to the first data block with space, or allocates</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * a new block if all existing blocks are full.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * dir_ino:    inode number of the directory to modify</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * name:       filename to add (must not already exist)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * target_ino: inode number the new entry points to</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * file_type:  FT_DIR or FT_REG_FILE (stored as a hint in the entry)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns 0 on success, negative errno on failure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * NOTE: Does NOT modify the target inode's nlinks â€” caller is responsible.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This separation keeps add_entry general-purpose.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> dir_add_entry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                  uint32_t</span><span style=\"color:#FFAB70\"> dir_ino</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                  uint32_t</span><span style=\"color:#FFAB70\"> target_ino</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#FFAB70\"> file_type</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(name) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#B392F0\"> strlen</span><span style=\"color:#E1E4E8\">(name) </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> MAX_FILENAME_LEN) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> dir_inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, dir_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dir_inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">S_ISDIR</span><span style=\"color:#E1E4E8\">(dir_inode.mode)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTDIR;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* First pass: check name doesn't already exist */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">dir_lookup</span><span style=\"color:#E1E4E8\">(fd, sb, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dir_inode, name) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EEXIST;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> needed </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dirent_actual_len</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(name));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Search existing blocks for a slot with enough free space */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> N_DIRECT; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> blk </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> dir_inode.blocks[i];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (blk </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, blk, buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Scan entries to find the last active entry in this block.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * We can steal space from its rec_len \"tail\" if there's room. */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint16_t</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (offset </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> DIRENT_HEADER_SIZE </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            dirent_t</span><span style=\"color:#E1E4E8\"> de;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint16_t</span><span style=\"color:#E1E4E8\"> advance </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dirent_read_from_buf</span><span style=\"color:#E1E4E8\">(buf, offset, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">de);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (advance </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint16_t</span><span style=\"color:#E1E4E8\"> actual_size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (de.inode_num </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /* Deleted entry â€” its entire rec_len is free */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                actual_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                actual_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dirent_actual_len</span><span style=\"color:#E1E4E8\">(de.name_len);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint16_t</span><span style=\"color:#E1E4E8\"> free_space </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> de.rec_len </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> actual_size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (free_space </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> needed) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /* Enough space after this entry (or in its deleted slot).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                 * Split: shrink this entry's rec_len to actual_size,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                 * write new entry in the freed space. */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (de.inode_num </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    /* Shrink the existing entry's rec_len */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    de.rec_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> actual_size;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    dirent_write_to_buf</span><span style=\"color:#E1E4E8\">(buf, offset, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">de);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /* Write the new entry in the freed space */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                uint16_t</span><span style=\"color:#E1E4E8\"> new_offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> (de.inode_num </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ?</span><span style=\"color:#E1E4E8\"> actual_size </span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                dirent_t</span><span style=\"color:#E1E4E8\"> new_de </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    .inode_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> target_ino,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    .rec_len   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> free_space,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    .name_len  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(name),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    .file_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> file_type,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                };</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                memcpy</span><span style=\"color:#E1E4E8\">(new_de.name, name, new_de.name_len);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                new_de.name[new_de.name_len] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                dirent_write_to_buf</span><span style=\"color:#E1E4E8\">(buf, new_offset, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">new_de);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, blk, buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /* Update directory mtime/ctime */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                dir_inode.mtime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> dir_inode.ctime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#B392F0\"> write_inode</span><span style=\"color:#E1E4E8\">(fd, sb, dir_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dir_inode);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            offset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> advance;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* No space in existing blocks â€” allocate a new directory block */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> new_blk </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_block</span><span style=\"color:#E1E4E8\">(fd, sb);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (new_blk </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOSPC;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Find a free direct block slot in the inode */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> slot </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> N_DIRECT; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (dir_inode.blocks[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { slot </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> i; </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (slot </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOSPC;</span><span style=\"color:#6A737D\">   /* all 12 direct blocks in use */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Initialize the new block with the new entry occupying full block */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    dirent_t</span><span style=\"color:#E1E4E8\"> new_de </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .inode_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> target_ino,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .rec_len   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE,</span><span style=\"color:#6A737D\">     /* owns entire block */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .name_len  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(name),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .file_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> file_type,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(new_de.name, name, new_de.name_len);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_de.name[new_de.name_len] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    dirent_write_to_buf</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">new_de);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_blk, buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dir_inode.blocks[slot] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_blk;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dir_inode.size </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dir_inode.mtime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> dir_inode.ctime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> write_inode</span><span style=\"color:#E1E4E8\">(fd, sb, dir_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dir_inode);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>The entry split strategy â€” shrinking the last entry&#39;s <code>rec_len</code> to make room for a new entry in its &quot;tail&quot; space â€” is exactly how ext2 works. This packs entries densely and avoids frequent block allocations for directories with moderate entry counts.</p>\n<h3 id=\"remove_entry-deleting-a-name\"><code>remove_entry</code>: Deleting a Name</h3>\n<p>Removing a directory entry does <strong>not</strong> physically shift entries in memory or free space immediately. Instead, it uses one of two strategies:</p>\n<ol>\n<li><strong>Set <code>inode_num = 0</code></strong>: Mark the entry as deleted. The <code>rec_len</code> remains unchanged, so the scanner skips it (it&#39;s still in the linked chain for forward scanning, just logically absent). Free space is only reclaimed when <code>add_entry</code> detects a deleted slot or empty tail space.</li>\n<li><strong>Expand the previous entry&#39;s <code>rec_len</code></strong>: Find the preceding entry and extend its <code>rec_len</code> to absorb the deleted entry&#39;s space. This is cleaner and immediately merges the free space, but requires tracking the &quot;previous entry&quot; during the scan.\nWe&#39;ll implement strategy 2 (the ext2 approach) for cleaner space recovery:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Remove a directory entry by name.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Decrements the target inode's nlinks and frees it if nlinks reaches 0.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns 0 on success, -ENOENT if not found, negative errno on error.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> dir_remove_entry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                     uint32_t</span><span style=\"color:#FFAB70\"> dir_ino</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> dir_inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, dir_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dir_inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">S_ISDIR</span><span style=\"color:#E1E4E8\">(dir_inode.mode)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTDIR;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> N_DIRECT; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> blk </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> dir_inode.blocks[i];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (blk </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, blk, buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint16_t</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint16_t</span><span style=\"color:#E1E4E8\"> prev_offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#E1E4E8\"> found </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> target_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (offset </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> DIRENT_HEADER_SIZE </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            dirent_t</span><span style=\"color:#E1E4E8\"> de;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint16_t</span><span style=\"color:#E1E4E8\"> advance </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dirent_read_from_buf</span><span style=\"color:#E1E4E8\">(buf, offset, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">de);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (advance </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (de.inode_num </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                de.name_len </span><span style=\"color:#F97583\">==</span><span style=\"color:#B392F0\"> strlen</span><span style=\"color:#E1E4E8\">(name) </span><span style=\"color:#F97583\">&#x26;&#x26;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                memcmp</span><span style=\"color:#E1E4E8\">(de.name, name, de.name_len) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /* Found the entry to remove */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                target_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> de.inode_num;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (offset </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    /* First entry in block: just zero out inode_num */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    /* (Cannot merge backwards â€” there is no previous entry) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    uint32_t</span><span style=\"color:#E1E4E8\"> zero </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    memcpy</span><span style=\"color:#E1E4E8\">(buf </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> offset, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">zero, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    /* Merge: expand previous entry's rec_len to absorb this one */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                    dirent_t</span><span style=\"color:#E1E4E8\"> prev_de;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    dirent_read_from_buf</span><span style=\"color:#E1E4E8\">(buf, prev_offset, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">prev_de);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    prev_de.rec_len </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> de.rec_len;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    dirent_write_to_buf</span><span style=\"color:#E1E4E8\">(buf, prev_offset, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">prev_de);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                found </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (de.inode_num </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) prev_offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> offset;</span><span style=\"color:#6A737D\">  /* track last valid entry */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            offset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> advance;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (found) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, blk, buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Update directory mtime/ctime */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            dir_inode.mtime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> dir_inode.ctime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_inode</span><span style=\"color:#E1E4E8\">(fd, sb, dir_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dir_inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Decrement target inode's nlinks */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            inode_t</span><span style=\"color:#E1E4E8\"> target_inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, target_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">target_inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (target_inode.nlinks </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) target_inode.nlinks</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            target_inode.ctime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (target_inode.nlinks </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /* Last link removed â€” free the inode and all its blocks.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                 * In a real filesystem, check for open file descriptors first.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                 * For now, free immediately. Milestone 5 handles the open fd case. */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#B392F0\"> free_inode</span><span style=\"color:#E1E4E8\">(fd, sb, target_ino);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> write_inode</span><span style=\"color:#E1E4E8\">(fd, sb, target_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">target_inode);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOENT;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<blockquote>\n<p><strong>Pitfall â€” Removing <code>.</code> and <code>..</code></strong>: Your <code>dir_remove_entry</code> must refuse to remove entries named <code>.</code> and <code>..</code>. These are structural entries that maintain link counts and tree integrity. Add a guard at the top:</p>\n<pre><code class=\"language-c\">if (strcmp(name, &quot;.&quot;) == 0 || strcmp(name, &quot;..&quot;) == 0) return -EINVAL;\n</code></pre>\n</blockquote>\n<hr>\n<h2 id=\"mkdir-creating-a-directory\"><code>mkdir</code>: Creating a Directory</h2>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m3-mkdir-state-evolution.svg\" alt=\"mkdir /home/user/projects â€” Step-by-Step State Changes\"></p>\n<p><code>mkdir</code> is not just &quot;create an inode and add a directory entry.&quot; It involves a precise sequence of state changes that maintain link count invariants. Let&#39;s trace through exactly what must happen when you call <code>mkdir(&quot;/home/user/projects&quot;)</code>:</p>\n<ol>\n<li>Resolve <code>/home/user</code> â†’ get parent inode number <code>parent_ino</code></li>\n<li>Verify <code>projects</code> doesn&#39;t already exist in parent</li>\n<li>Allocate a new inode for the new directory</li>\n<li>Initialize the new directory inode (<code>mode = S_IFDIR | 0755</code>, <code>nlinks = 2</code>)</li>\n<li>Allocate a data block for the new directory&#39;s initial entries</li>\n<li>Write <code>.</code> (pointing to new inode) and <code>..</code> (pointing to parent inode) into that block</li>\n<li>Write the new directory inode to disk with the data block pointer set</li>\n<li>Add an entry for <code>projects</code> in the parent directory (incrementing parent&#39;s <code>nlinks</code>)</li>\n<li>Increment the parent inode&#39;s <code>nlinks</code> by 1 (because <code>..</code> in the new dir points to parent)\nStep 9 is the one developers forget. The parent&#39;s <code>nlinks</code> count tracks how many things point <em>to</em> it. When you create a child directory, that child&#39;s <code>..</code> entry points to the parent â€” so the parent gains one more reference, and its <code>nlinks</code> increments.</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Before mkdir projects:\n  /home/user  â†’  inode 7  â†’  nlinks = 2 (one for /home/user entry, one for /home/user/. entry)\nAfter mkdir projects:\n  /home/user  â†’  inode 7  â†’  nlinks = 3 (added: /home/user/projects/.. â†’ inode 7)</code></pre></div>\n<p>This is why deeply nested directories cause high <code>nlinks</code> on parent directories. And it&#39;s why <code>find -maxdepth N</code> can use <code>nlinks</code> to prune: if a directory&#39;s <code>nlinks</code> equals 2, it has no subdirectories (only <code>.</code> and the parent&#39;s entry), so <code>find</code> can skip descending.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Create a new directory at the given path.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * parent_ino: inode number of the parent directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * name:       name of the new directory (single component, not a path)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * mode:       permission bits (will be OR'd with S_IFDIR)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * uid, gid:   owner</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns the new directory's inode number on success, negative errno on failure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> fs_mkdir</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">             uint32_t</span><span style=\"color:#FFAB70\"> parent_ino</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">             uint16_t</span><span style=\"color:#FFAB70\"> mode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> uid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> gid</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Validate */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(name) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#B392F0\"> strlen</span><span style=\"color:#E1E4E8\">(name) </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> MAX_FILENAME_LEN) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> parent_inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, parent_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">parent_inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">S_ISDIR</span><span style=\"color:#E1E4E8\">(parent_inode.mode)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTDIR;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Check name doesn't already exist */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">dir_lookup</span><span style=\"color:#E1E4E8\">(fd, sb, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">parent_inode, name) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EEXIST;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 1: Allocate new inode */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> new_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_inode</span><span style=\"color:#E1E4E8\">(fd, sb);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (new_ino </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOSPC;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 2: Allocate a data block for . and .. entries */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> data_blk </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_block</span><span style=\"color:#E1E4E8\">(fd, sb);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (data_blk </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Roll back inode allocation â€” don't leak */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* In a journaled filesystem this wouldn't be needed.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * For now, manually mark inode free in bitmap. */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint8_t</span><span style=\"color:#FFAB70\"> ibmap</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        read_block</span><span style=\"color:#E1E4E8\">(fd, INODE_BITMAP_BLOCK, ibmap);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        bitmap_clear</span><span style=\"color:#E1E4E8\">(ibmap, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_ino </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        write_block</span><span style=\"color:#E1E4E8\">(fd, INODE_BITMAP_BLOCK, ibmap);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sb->free_inodes</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOSPC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 3: Write . and .. into the data block */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> dir_data</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(dir_data, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* '.' entry â€” points to ourselves */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    dirent_t</span><span style=\"color:#E1E4E8\"> dot </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .inode_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_ino,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .name_len  </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .file_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> FT_DIR,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dot.rec_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dirent_actual_len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(dot.name, </span><span style=\"color:#9ECBFF\">\".\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">); dot.name[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    dirent_write_to_buf</span><span style=\"color:#E1E4E8\">(dir_data, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dot);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* '..' entry â€” points to parent; owns rest of block */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    dirent_t</span><span style=\"color:#E1E4E8\"> dotdot </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .inode_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parent_ino,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .name_len  </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .file_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> FT_DIR,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> dot_actual </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dirent_actual_len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dotdot.rec_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> dot_actual;</span><span style=\"color:#6A737D\">  /* owns remaining space */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(dotdot.name, </span><span style=\"color:#9ECBFF\">\"..\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">); dotdot.name[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    dirent_write_to_buf</span><span style=\"color:#E1E4E8\">(dir_data, dot_actual, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dotdot);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)data_blk, dir_data) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 4: Initialize and write the new directory inode */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> new_inode;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">new_inode, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(new_inode));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_inode.mode    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\">)(S_IFDIR </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> (mode </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0</span><span style=\"color:#79B8FF\">777</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_inode.uid     </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> uid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_inode.gid     </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_inode.nlinks  </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">          /* '.' + parent entry pointing to us */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_inode.size    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_inode.blocks[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)data_blk;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> now </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_inode.atime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_inode.mtime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_inode.ctime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> now;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">new_inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 5: Add entry in parent directory */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dir_add_entry</span><span style=\"color:#E1E4E8\">(fd, sb, parent_ino, name, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_ino, FT_DIR);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 6: Increment parent's nlinks (for the '..' in new dir) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, parent_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">parent_inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parent_inode.nlinks</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parent_inode.ctime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_inode</span><span style=\"color:#E1E4E8\">(fd, sb, parent_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">parent_inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> new_ino;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"rmdir-removing-a-directory\"><code>rmdir</code>: Removing a Directory</h2>\n<p><code>rmdir</code> is the inverse of <code>mkdir</code>, but with a critical safety check: <strong>a directory can only be removed if it is empty</strong>. &quot;Empty&quot; means it contains exactly two entries: <code>.</code> and <code>..</code>. Any additional entry â€” file, subdirectory, or anything else â€” means <code>rmdir</code> must fail with <code>ENOTEMPTY</code>.\n[[EXPLAIN:posix-rmdir-atomicity-â€”-why-rmdir-cannot-be-interrupted-and-leave-orphaned-inodes|POSIX rmdir atomicity â€” why rmdir is atomic in the kernel and what happens if it isn&#39;t]]</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Check if a directory is empty (contains only '.' and '..').</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns true if empty, false otherwise.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> dir_is_empty</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> inode_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">dir_inode</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> N_DIRECT; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (dir_inode->blocks[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, dir_inode->blocks[i], buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint16_t</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (offset </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> DIRENT_HEADER_SIZE </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            dirent_t</span><span style=\"color:#E1E4E8\"> de;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint16_t</span><span style=\"color:#E1E4E8\"> advance </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dirent_read_from_buf</span><span style=\"color:#E1E4E8\">(buf, offset, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">de);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (advance </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (de.inode_num </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /* Found a real entry â€” check if it's '.' or '..' */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                bool</span><span style=\"color:#E1E4E8\"> is_dot    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (de.name_len </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> de.name[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '.'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                bool</span><span style=\"color:#E1E4E8\"> is_dotdot </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (de.name_len </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> de.name[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '.'</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> de.name[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '.'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">is_dot </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">is_dotdot) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">    /* non-empty: found a real entry */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            offset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> advance;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Remove an empty directory.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * parent_ino: inode number of the parent directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * name:       name of the directory to remove</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns 0 on success, -ENOTEMPTY if directory has entries,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * -ENOENT if not found, negative errno on error.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> fs_rmdir</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">             uint32_t</span><span style=\"color:#FFAB70\"> parent_ino</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Cannot remove '.' or '..' */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strcmp</span><span style=\"color:#E1E4E8\">(name, </span><span style=\"color:#9ECBFF\">\".\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#B392F0\"> strcmp</span><span style=\"color:#E1E4E8\">(name, </span><span style=\"color:#9ECBFF\">\"..\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Resolve the target directory */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> parent_inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, parent_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">parent_inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> target_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dir_lookup</span><span style=\"color:#E1E4E8\">(fd, sb, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">parent_inode, name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (target_ino </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOENT;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (target_ino </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> target_ino;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> target_inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)target_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">target_inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">S_ISDIR</span><span style=\"color:#E1E4E8\">(target_inode.mode)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTDIR;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Safety check: must be empty */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">dir_is_empty</span><span style=\"color:#E1E4E8\">(fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">target_inode)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTEMPTY;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Remove the entry from parent (this also decrements target's nlinks via remove_entry) */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* But wait â€” we need to handle nlinks carefully for directories. The target directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * has nlinks=2 normally (parent entry + '.' self-reference). We also need to decrement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * parent's nlinks for the lost '..' reference. Let's do this manually. */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 1: Remove the name entry from parent directory.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * We bypass dir_remove_entry's automatic nlinks decrement and do it manually</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * to also handle the parent's nlinks. */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Find and zero the entry in parent's blocks */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> found </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> N_DIRECT </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">found; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (parent_inode.blocks[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, parent_inode.blocks[i], buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint16_t</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, prev_offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (offset </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> DIRENT_HEADER_SIZE </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            dirent_t</span><span style=\"color:#E1E4E8\"> de;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint16_t</span><span style=\"color:#E1E4E8\"> advance </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dirent_read_from_buf</span><span style=\"color:#E1E4E8\">(buf, offset, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">de);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (advance </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (de.inode_num </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)target_ino </span><span style=\"color:#F97583\">&#x26;&#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                de.name_len </span><span style=\"color:#F97583\">==</span><span style=\"color:#B392F0\"> strlen</span><span style=\"color:#E1E4E8\">(name) </span><span style=\"color:#F97583\">&#x26;&#x26;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                memcmp</span><span style=\"color:#E1E4E8\">(de.name, name, de.name_len) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /* Merge into previous or zero */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (offset </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    uint32_t</span><span style=\"color:#E1E4E8\"> zero </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    memcpy</span><span style=\"color:#E1E4E8\">(buf </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> offset, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">zero, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                    dirent_t</span><span style=\"color:#E1E4E8\"> prev_de;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    dirent_read_from_buf</span><span style=\"color:#E1E4E8\">(buf, prev_offset, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">prev_de);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    prev_de.rec_len </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> de.rec_len;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    dirent_write_to_buf</span><span style=\"color:#E1E4E8\">(buf, prev_offset, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">prev_de);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                write_block</span><span style=\"color:#E1E4E8\">(fd, parent_inode.blocks[i], buf);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                found </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (de.inode_num </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) prev_offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> offset;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            offset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> advance;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">found) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOENT;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 2: Decrement parent's nlinks (lost the '..' reference from removed dir) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, parent_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">parent_inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (parent_inode.nlinks </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) parent_inode.nlinks</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parent_inode.mtime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parent_inode.ctime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_inode</span><span style=\"color:#E1E4E8\">(fd, sb, parent_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">parent_inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 3: Free the target directory inode and its data blocks */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> free_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)target_ino);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"hard-links-one-file-many-names\">Hard Links: One File, Many Names</h2>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m3-link-count.svg\" alt=\"Hard Links and Link Count â€” Visual Proof\"></p>\n<p>The <code>link()</code> syscall creates a hard link â€” a new directory entry pointing to an <em>existing</em> inode. No data is copied. No new inode is created. Just one new name that references the same inode, and that inode&#39;s <code>nlinks</code> counter increments by one.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Create a hard link.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Adds 'new_name' in 'dir_ino' pointing to the inode at 'target_path'.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Rules:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *  - Cannot hard link a directory (would create cycles, break tree structure)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *  - target inode must exist</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *  - new_name must not already exist in dir_ino</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns 0 on success, negative errno on failure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> fs_link</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint32_t</span><span style=\"color:#FFAB70\"> target_ino</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> dir_ino</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">new_name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Load target inode */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> target_inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, target_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">target_inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Hard links to directories are forbidden â€” would create cycles */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">S_ISDIR</span><span style=\"color:#E1E4E8\">(target_inode.mode)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EPERM;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Check nlinks won't overflow (uint16_t max = 65535) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (target_inode.nlinks </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 65535</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EMLINK;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Add the new directory entry */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> file_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> S_ISREG</span><span style=\"color:#E1E4E8\">(target_inode.mode) </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> FT_REG_FILE </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> FT_UNKNOWN;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dir_add_entry</span><span style=\"color:#E1E4E8\">(fd, sb, dir_ino, new_name, target_ino, file_type);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Increment target inode's nlinks */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    target_inode.nlinks</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    target_inode.ctime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> write_inode</span><span style=\"color:#E1E4E8\">(fd, sb, target_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">target_inode);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>The prohibition on hard-linking directories is a fundamental rule of Unix filesystems. If you could hard-link a directory, you could create:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>mkdir A\nlink A A/loop   # A contains an entry 'loop' pointing to A itself</code></pre></div>\n<p>Now <code>A/loop/loop/loop/...</code> is an infinite descent. <code>find /</code>, <code>du /</code>, <code>fsck</code> â€” every tool that walks the directory tree would loop forever. The kernel forbids it at the syscall level (<code>link()</code> returns <code>EPERM</code> for directories). The exception: <code>mkdir</code> itself creates <code>.</code> and <code>..</code>, which <em>are</em> directory hard links â€” but the kernel treats these specially and breaks the cycle by knowing that <code>..</code> from root points to root.</p>\n<h3 id=\"unlink-removing-a-file\"><code>unlink()</code>: Removing a File</h3>\n<p><code>unlink()</code> removes a directory entry (just like <code>remove_entry</code>). It is the complement to <code>link()</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Remove a file (not a directory) from a directory.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Decrements nlinks; frees inode if nlinks reaches 0.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Use fs_rmdir for directories.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> fs_unlink</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">              uint32_t</span><span style=\"color:#FFAB70\"> dir_ino</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> dir_inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, dir_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dir_inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> target_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dir_lookup</span><span style=\"color:#E1E4E8\">(fd, sb, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dir_inode, name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (target_ino </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOENT;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (target_ino </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> target_ino;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Verify it's not a directory */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> target_inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)target_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">target_inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">S_ISDIR</span><span style=\"color:#E1E4E8\">(target_inode.mode)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EISDIR;</span><span style=\"color:#6A737D\">   /* use rmdir instead */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* dir_remove_entry handles nlinks decrement and inode freeing */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> dir_remove_entry</span><span style=\"color:#E1E4E8\">(fd, sb, dir_ino, name);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"the-and-contract\">The <code>.</code> and <code>..</code> Contract</h2>\n<p>The <code>.</code> and <code>..</code> entries are real directory entries stored in real data blocks. They are <strong>not</strong> generated on-the-fly by the kernel. Let&#39;s verify this claim by looking at what we write during <code>mkfs</code> and <code>mkdir</code>:</p>\n<ul>\n<li><strong><code>.</code></strong>: inode_num = this directory&#39;s own inode number, name = &quot;.&quot;</li>\n<li><strong><code>..</code></strong>: inode_num = parent directory&#39;s inode number, name = &quot;..&quot;\nFor the root directory specifically, <strong><code>..</code> points to itself</strong> â€” root&#39;s parent is root. This creates a natural base case for path traversal algorithms that follow <code>..</code> chains: when you reach a node where <code>.</code> and <code>..</code> are the same inode, you are at the root.</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Verify the '.' entry in a directory block is correct */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> verify_dot_entries</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                       uint32_t</span><span style=\"color:#FFAB70\"> dir_ino</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> expected_parent_ino</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> dir_inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, dir_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dir_inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">S_ISDIR</span><span style=\"color:#E1E4E8\">(dir_inode.mode)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTDIR;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (dir_inode.blocks[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span><span style=\"color:#6A737D\">   /* no data block */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, dir_inode.blocks[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* First entry must be '.' pointing to self */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    dirent_t</span><span style=\"color:#E1E4E8\"> dot;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> advance </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dirent_read_from_buf</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dot);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (advance </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (dot.inode_num </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> dir_ino) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"CORRUPT: '.' entry in inode </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> points to </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> (expected </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                dir_ino, dot.inode_num, dir_ino);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (dot.name_len </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> dot.name[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> '.'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"CORRUPT: first entry in inode </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> is not '.'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, dir_ino);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Second entry must be '..' pointing to parent */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    dirent_t</span><span style=\"color:#E1E4E8\"> dotdot;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    dirent_read_from_buf</span><span style=\"color:#E1E4E8\">(buf, advance, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dotdot);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (dotdot.inode_num </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> expected_parent_ino) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"CORRUPT: '..' entry in inode </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> points to </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> (expected </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                dir_ino, dotdot.inode_num, expected_parent_ino);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (dotdot.name_len </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        dotdot.name[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> '.'</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> dotdot.name[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> '.'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"CORRUPT: second entry in inode </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> is not '..'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, dir_ino);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   /* valid */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"readdir-listing-a-directory\"><code>readdir</code>: Listing a Directory</h2>\n<p>FUSE (Milestone 5) calls <code>readdir</code> for every <code>ls</code> command. Here is the core implementation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Iterate over all entries in a directory.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Calls callback for each non-deleted entry (including '.' and '..').</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Used by FUSE's readdir callback and by dir_is_empty.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> void</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">readdir_cb_t</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">name, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> inode_num,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                              uint8_t</span><span style=\"color:#E1E4E8\"> file_type, </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">userdata);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> dir_readdir</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                uint32_t</span><span style=\"color:#FFAB70\"> dir_ino</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">readdir_cb_t</span><span style=\"color:#FFAB70\"> cb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">userdata</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> dir_inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, dir_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dir_inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">S_ISDIR</span><span style=\"color:#E1E4E8\">(dir_inode.mode)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTDIR;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> N_DIRECT; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (dir_inode.blocks[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, dir_inode.blocks[i], buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint16_t</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (offset </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> DIRENT_HEADER_SIZE </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            dirent_t</span><span style=\"color:#E1E4E8\"> de;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint16_t</span><span style=\"color:#E1E4E8\"> advance </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dirent_read_from_buf</span><span style=\"color:#E1E4E8\">(buf, offset, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">de);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (advance </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (de.inode_num </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                cb</span><span style=\"color:#E1E4E8\">(de.name, de.inode_num, de.file_type, userdata);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            offset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> advance;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<blockquote>\n<p><strong>Hardware Soul â€” <code>readdir</code> at Speed</strong>:\nA directory with 1,000 entries across 3 data blocks (three 4KB reads) takes ~300Î¼s on a cold SSD, ~30ns from L1 cache. The sequential access pattern is optimal for hardware prefetchers: the CPU sees a stride-0 access pattern through the 4KB block and prefetches the next cache lines automatically. For warm-cache <code>ls</code> performance, the bottleneck is almost never the directory block reads â€” it&#39;s the subsequent <code>stat()</code> calls, each of which reads a different inode block (likely random access into the inode table).</p>\n</blockquote>\n<hr>\n<h2 id=\"validation-testing-the-directory-layer\">Validation: Testing the Directory Layer</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_directory_layer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">=== Directory Layer Tests ===</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> root_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sb->root_inode;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 1: mkdir a subdirectory */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> user_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_mkdir</span><span style=\"color:#E1E4E8\">(fd, sb, root_ino, </span><span style=\"color:#9ECBFF\">\"user\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">755</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(user_ino </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: mkdir 'user' â†’ inode </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, user_ino);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 2: path resolution */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> resolved </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> path_resolve</span><span style=\"color:#E1E4E8\">(fd, sb, </span><span style=\"color:#9ECBFF\">\"/user\"</span><span style=\"color:#E1E4E8\">, root_ino, root_ino);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(resolved </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> user_ino);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: path_resolve('/user') = </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, resolved);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 3: nested mkdir */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> projects_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_mkdir</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)user_ino, </span><span style=\"color:#9ECBFF\">\"projects\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                 0</span><span style=\"color:#79B8FF\">755</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(projects_ino </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> nested </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> path_resolve</span><span style=\"color:#E1E4E8\">(fd, sb, </span><span style=\"color:#9ECBFF\">\"/user/projects\"</span><span style=\"color:#E1E4E8\">, root_ino, root_ino);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(nested </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> projects_ino);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: nested path resolution works</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 4: verify parent nlinks incremented */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> user_inode;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)user_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">user_inode);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(user_inode.nlinks </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  /* '.' + /user entry + /user/projects/.. */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: parent nlinks = </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> (correct)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, user_inode.nlinks);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 5: '.' and '..' entries */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">verify_dot_entries</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)projects_ino,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                               (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)user_ino) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: '.' and '..' entries verified</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 6: duplicate name rejected */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">fs_mkdir</span><span style=\"color:#E1E4E8\">(fd, sb, root_ino, </span><span style=\"color:#9ECBFF\">\"user\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">755</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EEXIST);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: duplicate mkdir rejected with EEXIST</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 7: rmdir empty directory */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> empty_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_mkdir</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)user_ino, </span><span style=\"color:#9ECBFF\">\"empty\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                              0</span><span style=\"color:#79B8FF\">755</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(empty_ino </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">fs_rmdir</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)user_ino, </span><span style=\"color:#9ECBFF\">\"empty\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Verify inode is now free */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> ibmap</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    read_block</span><span style=\"color:#E1E4E8\">(fd, INODE_BITMAP_BLOCK, ibmap);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">bitmap_test</span><span style=\"color:#E1E4E8\">(ibmap, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)empty_ino </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: rmdir empty directory, inode freed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 8: rmdir non-empty directory fails */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">fs_rmdir</span><span style=\"color:#E1E4E8\">(fd, sb, root_ino, </span><span style=\"color:#9ECBFF\">\"user\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTEMPTY);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: rmdir non-empty directory rejected</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 9: ENOENT for missing path */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">path_resolve</span><span style=\"color:#E1E4E8\">(fd, sb, </span><span style=\"color:#9ECBFF\">\"/nonexistent\"</span><span style=\"color:#E1E4E8\">, root_ino, root_ino) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOENT);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: path_resolve nonexistent returns ENOENT</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 10: Hard link */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Create a file first (borrow from Milestone 4 â€” just allocate and init an inode) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> file_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_inode</span><span style=\"color:#E1E4E8\">(fd, sb);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(file_ino </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> file_inode;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    inode_init_file</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">file_inode, </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">644</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    write_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)file_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">file_inode);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    dir_add_entry</span><span style=\"color:#E1E4E8\">(fd, sb, root_ino, </span><span style=\"color:#9ECBFF\">\"original\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)file_ino, FT_REG_FILE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    file_inode.nlinks </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    write_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)file_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">file_inode);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">fs_link</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)file_ino, root_ino, </span><span style=\"color:#9ECBFF\">\"hardlink\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)file_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">file_inode);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(file_inode.nlinks </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: hard link created, nlinks = </span><span style=\"color:#79B8FF\">%u\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, file_inode.nlinks);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 11: Unlink one, inode survives */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">fs_unlink</span><span style=\"color:#E1E4E8\">(fd, sb, root_ino, </span><span style=\"color:#9ECBFF\">\"original\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)file_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">file_inode);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(file_inode.nlinks </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: unlink one link, nlinks = </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> (inode survives)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, file_inode.nlinks);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 12: Unlink last link, inode freed */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">fs_unlink</span><span style=\"color:#E1E4E8\">(fd, sb, root_ino, </span><span style=\"color:#9ECBFF\">\"hardlink\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    read_block</span><span style=\"color:#E1E4E8\">(fd, INODE_BITMAP_BLOCK, ibmap);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">bitmap_test</span><span style=\"color:#E1E4E8\">(ibmap, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)file_ino </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: last unlink frees inode</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"=== All Directory Tests Passed ===</span><span style=\"color:#79B8FF\">\\n\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"concurrency-warning-races-in-directory-modification\">Concurrency Warning: Races in Directory Modification</h2>\n<p>If multiple threads (as in FUSE with <code>default_permissions</code> and multi-threaded mode) concurrently modify the same directory, you have a race condition. Consider:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Thread A: dir_lookup(&quot;file&quot;)    â†’ not found (0)\nThread B: dir_add_entry(&quot;file&quot;) â†’ creates entry\nThread A: dir_add_entry(&quot;file&quot;) â†’ creates DUPLICATE entry!</code></pre></div>\n<p>The name-uniqueness check in <code>dir_add_entry</code> and the lookup are not atomic. In Milestone 5, you will add a per-directory mutex or a global filesystem lock. For now, document this limitation and test only single-threaded:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Thread safety: All directory operations on a given directory inode</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * must be serialized. The caller (FUSE callbacks in Milestone 5) is</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * responsible for holding the appropriate lock before calling these functions.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * A simple approach: one global pthread_mutex_t protecting all FS state.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * A better approach: per-inode read-write locks (readers can share, writers exclusive).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span></code></pre></div>\n<h2 id=\"explaindirectory-locking-strategies-global-lock-vs-per-inode-vs-hierarchical-lockingdirectory-locking-strategies-global-lock-vs-per-inode-vs-hierarchical-locking-for-concurrent-filesystem-access\">[[EXPLAIN:directory-locking-strategies-â€”-global-lock-vs-per-inode-vs-hierarchical-locking|Directory locking strategies â€” global lock vs. per-inode vs. hierarchical locking for concurrent filesystem access]]</h2>\n<h2 id=\"knowledge-cascade-one-directory-ten-worlds\">Knowledge Cascade: One Directory, Ten Worlds</h2>\n<p>You have built what appears to be a simple name-to-inode lookup table. But the ideas behind it permeate systems across every domain.</p>\n<h3 id=\"symbolic-links-vs-hard-links-now-obvious\">Symbolic Links vs. Hard Links: Now Obvious</h3>\n<p>With directory entries fully understood, the hard link vs. symbolic link distinction resolves itself completely.\n<strong>Hard link</strong>: a new directory entry pointing to an <em>existing inode</em>. <code>link(&quot;/existing&quot;, &quot;/alias&quot;)</code> writes one new <code>dirent_t</code> record. One inode, two names. The inode&#39;s <code>nlinks</code> increments. Delete either name â€” the inode survives. Delete both â€” the inode is freed. No indirection, no path lookup at the target, no dangling reference possible. The alias and the original are truly identical in the filesystem&#39;s view.\n<strong>Symbolic link</strong> [[EXPLAIN:symbolic-links-â€”-files-containing-a-target-path-string-resolved-at-access-time|Symbolic links â€” files containing a target path string, resolved at every access]]: a new inode whose <code>mode</code> is <code>S_IFLNK</code> and whose data block contains a <em>path string</em>. <code>symlink(&quot;/existing&quot;, &quot;/symlink&quot;)</code> creates a new inode (new <code>nlinks=1</code>), writes the string <code>/existing</code> into its data block, and creates a directory entry pointing to that inode. When the kernel encounters <code>S_IFLNK</code> during path resolution, it reads the link&#39;s data block, gets the path string, and re-starts path resolution from scratch with that string. The target inode&#39;s <code>nlinks</code> is NOT incremented â€” the symlink has no knowledge of the target inode at all, only the target <em>path</em>.\nThis means:</p>\n<ul>\n<li>Delete the original: hard links still work (shared inode survives), symlinks break (&quot;dangling symlink&quot;)</li>\n<li>Move the original to a different path: hard links still work, symlinks break</li>\n<li>Symlinks can cross filesystem boundaries (the target path is just a string), hard links cannot (inode numbers are filesystem-local)</li>\n<li>Symlinks can point to directories; hard links to directories are forbidden\nNow you see why: hard links are inode-level operations (increment <code>nlinks</code>, add <code>dirent_t</code>). Symlinks are inode-creation operations with a path payload.</li>\n</ul>\n<h3 id=\"dns-resolution-the-same-algorithm\">DNS Resolution: The Same Algorithm</h3>\n<p>The path resolution algorithm you just implemented â€” walk a hierarchy component by component, each level stored at a different &quot;authority&quot; â€” is structurally identical to [[EXPLAIN:dns-resolution-â€”-recursive-hierarchical-name-lookup-from-root-to-authoritative-server|DNS resolution â€” recursive hierarchical name lookup]].\n<code>/home/user/file.txt</code> â†’ resolve:</p>\n<ul>\n<li><code>/</code> (root) â†’ scan for <code>home</code> â†’ inode 14</li>\n<li>inode 14 â†’ scan for <code>user</code> â†’ inode 82</li>\n<li>inode 82 â†’ scan for <code>file.txt</code> â†’ inode 1041\n<code>www.example.com.</code> â†’ resolve:</li>\n<li><code>.</code> (root nameservers) â†’ query for <code>com.</code> â†’ NS record for com. authority</li>\n<li><code>com.</code> authority â†’ query for <code>example.com.</code> â†’ NS record for example.com. authority</li>\n<li><code>example.com.</code> authority â†’ query for <code>www.example.com.</code> â†’ A record: 93.184.216.34\nIn both cases: hierarchical namespace, each component stored at a specific authority, walk from root to leaf. The difference is that filesystem lookup is local (disk reads), while DNS is distributed (network queries). The BIND nameserver&#39;s zone file format even looks like a directory entry: <code>(name, class, type, rdata)</code> where <code>rdata</code> is the &quot;inode number&quot; (IP address, or pointer to next authority).\nThis cross-domain connection is not superficial. DNS negative caching (caching NXDOMAIN responses to avoid re-querying for missing entries) is the exact analogue of the Linux VFS dcache caching ENOENT results. Both systems solve the same &quot;frequent lookups of hierarchical names with high locality&quot; problem.</li>\n</ul>\n<h3 id=\"container-overlay-filesystems-overlayfs-docker\">Container Overlay Filesystems (OverlayFS / Docker)</h3>\n<p>[[EXPLAIN:overlayfs-â€”-union-mount-filesystem-that-layers-directories-for-copy-on-write-container-images|OverlayFS â€” union mount filesystem layering directories for Docker container images]]\nDocker&#39;s layers are a direct consequence of understanding directory entries as data. When you build a Docker image:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Layer 1 (base OS):       /bin/bash, /etc/hosts, /lib/...\nLayer 2 (your app):      /app/server, /app/config.json\nLayer 3 (runtime write): /tmp/cache, /var/log/app.log</code></pre></div>\n<p>OverlayFS merges these by stacking directory entry tables. The &quot;upper&quot; layer&#39;s entries take precedence. A file deleted in an upper layer is represented by a <strong>whiteout entry</strong> â€” a special directory entry (in Linux: a character device with major/minor 0,0, or an entry with the <code>.wh.</code> prefix) that signals &quot;this name is deleted in this layer.&quot; Any lookup that finds a whiteout stops and returns ENOENT, even if a lower layer has an entry with the same name.\nThis is precisely your <code>inode_num = 0</code> sentinel for deleted entries â€” a &quot;whiteout&quot; marker in a specific layer&#39;s directory block. The &quot;union mount&quot; view is the result of scanning layers in order and applying precedence rules to the merged list of directory entries.\nUnderstanding your <code>dirent_t</code> with <code>inode_num = 0</code> for deleted slots is understanding Docker&#39;s layer isolation model at the filesystem level.</p>\n<h3 id=\"database-index-lookups-the-linear-scan-problem\">Database Index Lookups: The Linear Scan Problem</h3>\n<p>You have just implemented linear scan directory lookup: iterate every entry until you find the name. For a directory with 10 entries this is fast. For a directory with 100,000 entries (a common pattern in <code>/var/spool/mail</code> or large upload directories), this is catastrophically slow.\next2 uses linear scan. ext4 introduced <code>htree</code> directories: when a directory grows beyond a threshold, its entry layout switches from the flat linear format to a <strong>B-tree indexed by the hash of the filename</strong>. The root node of the B-tree lives in the first directory block. Lookups compute <code>hash(name)</code>, walk the B-tree to find the leaf block containing entries with that hash, then scan the leaf block (small because hash-identical names are rare).\nThis is <strong>exactly</strong> the difference between a sequential scan and a hash index in a database. A table with no index requires full sequential scan for point lookups. Adding a hash index converts that to O(1). ext4&#39;s <code>dir_index</code> feature flag marks filesystems where this optimization is active.\nThe performance numbers: linear scan at 100,000 entries in a single directory costs <del>100,000 memory comparisons, ~24 block reads (</del>2.4ms from SSD, <del>240ms from spinning disk per lookup). The B-tree index converts this to ~3 block reads per lookup (</del>300Î¼s from SSD). At 100 lookups/second, the difference is 240ms vs. 30ms â€” an 8Ã— throughput improvement.</p>\n<h3 id=\"git-tree-objects-directories-all-the-way-down\">Git Tree Objects: Directories All The Way Down</h3>\n<p>[[EXPLAIN:git-objects-â€”-content-addressable-store-of-blobs-trees-commits-and-tags|Git objects â€” content-addressable store of blobs (file data), trees (directories), commits, and tags]]\nGit&#39;s internal object model is a direct implementation of the same inode/directory abstraction you just built:</p>\n<table>\n<thead>\n<tr>\n<th>Git Concept</th>\n<th>Filesystem Equivalent</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Blob object</strong></td>\n<td>File data (data blocks)</td>\n</tr>\n<tr>\n<td><strong>Tree object</strong></td>\n<td>Directory entry list (<code>dirent_t[]</code> array)</td>\n</tr>\n<tr>\n<td><strong>Commit object</strong></td>\n<td>Inode for a snapshot (mode, owner, size â†’ author, date, message; blocks[0] â†’ root tree SHA)</td>\n</tr>\n<tr>\n<td><strong>SHA-256 hash</strong></td>\n<td>Inode number (unique identifier for the content)</td>\n</tr>\n<tr>\n<td>A Git tree object contains entries: <code>(mode, name, SHA)</code> â€” where mode is the file type, name is the filename, and SHA is the content hash of the blob or subtree. This is your <code>dirent_t</code> with <code>(file_type, name, inode_num)</code> where <code>inode_num</code> is replaced by a content hash.</td>\n<td></td>\n</tr>\n<tr>\n<td>A Git commit is an inode with a tree pointer (<code>blocks[0]</code> â†’ root tree) and metadata (author, timestamp, message). The filesystem hierarchy encoded in Git is navigated exactly like your directory tree: <code>git show HEAD:src/main.c</code> resolves <code>HEAD</code> â†’ commit object â†’ root tree â†’ <code>src</code> subtree â†’ <code>main.c</code> blob. Four object lookups, identical to your 4-hop path resolution.</td>\n<td></td>\n</tr>\n<tr>\n<td>Understanding this connection means understanding why <code>git checkout</code> is fast (it reads blobs from the object store and writes them to the working tree â€” two filesystem-level operations), why <code>git status</code> can be slow in large repos (it must hash every file to compare with the index), and why <code>git bisect</code> works without a database (the commit graph is navigable through object references, just like your directory tree).</td>\n<td></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"design-decisions\">Design Decisions</h2>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Used By</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Variable-length dirents with rec_len (chosen âœ“)</strong></td>\n<td>Space-efficient for short names; proven format; scan-only so cache-friendly</td>\n<td>O(n) lookup; scan required to find free space; deletion leaves holes</td>\n<td>ext2/3/4, our implementation</td>\n</tr>\n<tr>\n<td>Fixed-size dirents (256 bytes each)</td>\n<td>O(1) indexed access by entry number; simpler implementation</td>\n<td>Wastes 247 bytes for a 1-char filename; common case (short names) pays for worst case</td>\n<td>FAT32 (11-byte 8.3 names, fixed), small embedded FSes</td>\n</tr>\n<tr>\n<td>Hash-tree directory (htree)</td>\n<td>O(1) lookup via filename hash; scales to millions of entries</td>\n<td>Complex implementation; hash collisions need linear fallback; not crash-safe without journaling</td>\n<td>ext4 (dir_index feature), NTFS, HFS+</td>\n</tr>\n<tr>\n<td>B-tree directory index</td>\n<td>Self-balancing; O(log n) worst case; handles any distribution</td>\n<td>Complex; rebalancing on every insert/delete; overkill for &lt; 10k entries</td>\n<td>XFS (B-tree directories by default), ReiserFS</td>\n</tr>\n<tr>\n<td>For our purposes, variable-length linear dirents give you the correct behavior and correct on-disk format. The htree optimization is a straightforward engineering addition â€” the same <code>dirent_t</code> format is used at the leaf level, only the lookup mechanism changes.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"before-you-move-on-pitfall-checklist\">Before You Move On: Pitfall Checklist</h2>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Name uniqueness on <code>add_entry</code></strong>: <code>dir_lookup</code> must be called before every <code>dir_add_entry</code>. A duplicate name causes ambiguous lookups â€” the first matching entry wins in a scan, making one of the two entries permanently unreachable.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Parent nlinks on <code>mkdir</code></strong>: After creating a child directory, increment the parent&#39;s <code>nlinks</code> by 1. After <code>rmdir</code>, decrement it. Every subdirectory represents one <code>..</code> reference to the parent. The invariant: <code>parent.nlinks = 2 + number_of_child_directories</code>.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Root&#39;s <code>..</code> points to root</strong>: During <code>mkfs</code>, verify that <code>path_resolve(&quot;/..&quot;)</code> returns <code>root_ino</code>, not an error. Root is its own parent. This is a base case for all <code>..</code> traversal.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Max filename length enforced</strong>: Every function that accepts a name parameter must check <code>strlen(name) &lt;= MAX_FILENAME_LEN</code>. A 256-byte name silently overflows <code>name_len</code> (which is <code>uint8_t</code>, max 255) and writes garbage <code>rec_len</code> values that corrupt the directory block scan.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Hard links to directories are forbidden</strong>: <code>fs_link</code> must return <code>-EPERM</code> for <code>S_ISDIR</code> targets. Without this check, you can create filesystem cycles that loop <code>find</code> and <code>du</code> forever.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong><code>rmdir</code> only on empty directories</strong>: <code>dir_is_empty</code> must be called before any removal. Check that it skips deleted entries (<code>inode_num == 0</code>) correctly â€” a block with only deleted entries should be considered empty.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Bitmap-before-inode write order</strong>: In <code>mkdir</code>, write the bitmap marking the new inode and data block as used <em>before</em> writing the new inode to the inode table. If you crash between the two writes, a used-but-uninitiated inode (bitmap=1, inode data=garbage) is detectable by <code>fsck</code> as an orphan. A valid-inode-pointing-to-a-free-block (inode written, bitmap not yet updated) is a double-allocation bug.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong><code>ctime</code> updates on all inode modifications</strong>: <code>dir_add_entry</code> and <code>dir_remove_entry</code> must update <code>dir_inode.ctime</code> (and <code>mtime</code>). <code>fs_link</code> must update <code>target_inode.ctime</code>. These timestamps are used by <code>rsync</code> for change detection.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong><code>strtok_r</code> not <code>strtok</code></strong>: Path resolution uses <code>strtok_r</code> (reentrant version). <code>strtok</code> uses a global static pointer and is not thread-safe. In the FUSE multi-threaded environment (Milestone 5), using <code>strtok</code> causes intermittent path resolution corruption that is nearly impossible to debug.</li>\n</ul>\n<hr>\n<h2 id=\"what-you39ve-built-and-what-comes-next\">What You&#39;ve Built and What Comes Next</h2>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-L0-satellite-map.svg\" alt=\"Filesystem Atlas â€” Satellite Map (Home Base)\"></p>\n<h2 id=\"you-have-collapsed-the-illusion-of-the-quotfolderquot-a-directory-is-a-file-its-data-blocks-are-a-linked-sequence-of-name-inode_number-records-the-entire-filesystem-tree-emerges-from-files-pointing-to-other-files-path-resolution-is-a-mechanical-scan-read-a-block-find-the-name-follow-the-inode-number-repeat-the-and-entries-that-make-cd-work-are-stored-as-ordinary-bytes-in-ordinary-data-blocks-the-elegance-is-complete-every-part-of-the-filesystem-the-superblock-block-0-the-bitmaps-blocks-12-the-inode-table-the-journal-and-the-directory-tree-is-made-from-the-same-substrate-4kb-blocks-the-naming-system-that-makes-the-tree-navigable-is-itself-stored-in-the-tree-but-look-at-what39s-missing-you-can-create-directories-and-add-entries-but-you-cannot-yet-read-or-write-actual-file-data-a-regular-file-s_ifreg-whose-blocks-array-points-to-data-blocks-containing-bytes-is-not-yet-implemented-in-milestone-4-you-will-build-readinode-offset-length-and-writeinode-offset-data-the-operations-that-traverse-the-block-pointer-tree-from-milestone-2-and-move-data-between-the-application-and-disk-you-will-implement-truncate-shrinking-and-extending-files-handle-the-read-modify-write-problem-for-partial-block-writes-and-support-sparse-files-where-holes-read-as-zeros-the-filesystem-is-almost-complete-two-milestones-ago-you-had-a-flat-block-array-now-you-have-a-navigable-tree-of-named-files-the-blocks-are-starting-to-look-like-a-filesystem\">You have collapsed the illusion of the &quot;folder.&quot; A directory is a file. Its data blocks are a linked sequence of <code>(name, inode_number)</code> records. The entire filesystem tree emerges from files pointing to other files. Path resolution is a mechanical scan: read a block, find the name, follow the inode number, repeat. The <code>.</code> and <code>..</code> entries that make <code>cd ..</code> work are stored as ordinary bytes in ordinary data blocks.\nThe elegance is complete: every part of the filesystem â€” the superblock (block 0), the bitmaps (blocks 1â€“2), the inode table, the journal, and the directory tree â€” is made from the same substrate: 4KB blocks. The naming system that makes the tree navigable is itself stored <em>in</em> the tree.\nBut look at what&#39;s missing: you can create directories and add entries, but you cannot yet read or write actual file data. A regular file (<code>S_IFREG</code>) whose <code>blocks[]</code> array points to data blocks containing bytes is not yet implemented. In Milestone 4, you will build <code>read(inode, offset, length)</code> and <code>write(inode, offset, data)</code> â€” the operations that traverse the block pointer tree from Milestone 2 and move data between the application and disk. You will implement <code>truncate</code> (shrinking and extending files), handle the read-modify-write problem for partial block writes, and support sparse files where holes read as zeros.\nThe filesystem is almost complete. Two milestones ago, you had a flat block array. Now you have a navigable tree of named files. The blocks are starting to look like a filesystem.</h2>\n<!-- END_MS -->\n\n\n<!-- MS_ID: filesystem-m4 -->\n<!-- MS_ID: filesystem-m4 -->\n<h1 id=\"milestone-4-file-readwrite-operations\">Milestone 4: File Read/Write Operations</h1>\n<h2 id=\"the-lie-every-developer-believes-about-file-writes\">The Lie Every Developer Believes About File Writes</h2>\n<p>You have written file I/O code hundreds of times. You have called <code>write(fd, buf, 100)</code> and trusted that those 100 bytes landed at the right place on disk. Your mental model is reasonable: files are byte-addressable, persistent arrays. You write to offset 5000, bytes 5000â€“5099 change. Simple.\nNow consider what your hardware actually sees when you ask it to change byte 5001.\nThe disk does not know what byte 5001 is. The disk only understands one unit of transfer: a block. Four kilobytes. The disk will not read 1 byte, will not write 1 byte, will not even acknowledge the concept. To change byte 5001 in a file, you must:</p>\n<ol>\n<li><strong>Read</strong> the entire 4KB block containing byte 5001 into RAM</li>\n<li><strong>Modify</strong> the single byte you care about, in memory</li>\n<li><strong>Write</strong> the entire 4KB block back to disk\nThis is a <strong>read-modify-write (RMW) cycle</strong>. And it is not an implementation quirk you can engineer around â€” it is the fundamental physics of block storage. Every file write, no matter how small, triggers this cycle if the write does not align perfectly to block boundaries.\nIt gets worse. Your file&#39;s data does not live at a fixed disk location. It lives somewhere pointed to by the inode&#39;s block pointer tree â€” the structure you built in Milestone 2. So before you can even begin the RMW cycle, you must translate the file offset into a disk block number by traversing that tree. Then perform the RMW. Then update the inode if the file grew. Then update timestamps.\nWhat looks like &quot;write 100 bytes&quot; is actually a multi-step dance involving potentially 4â€“6 disk operations. This is the gap between the POSIX abstraction and the hardware reality. This milestone is where you close that gap â€” by building the machinery that makes the abstraction work, understanding exactly what it costs, and seeing why the rest of systems programming (databases, SSDs, buffer caches) exists largely to compensate for this fundamental mismatch.</li>\n</ol>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m4-write-rmw.svg\" alt=\"Write â€” The Read-Modify-Write Cycle\"></p>\n<hr>\n<h2 id=\"the-fundamental-tension-byte-addressable-api-block-addressable-storage\">The Fundamental Tension: Byte-Addressable API, Block-Addressable Storage</h2>\n<p>The POSIX file API is byte-oriented:</p>\n<ul>\n<li><code>read(fd, buf, n)</code> â€” read exactly <code>n</code> bytes from the current position</li>\n<li><code>write(fd, buf, n)</code> â€” write exactly <code>n</code> bytes to the current position</li>\n<li><code>lseek(fd, offset, SEEK_SET)</code> â€” position to any byte offset\nThe storage hardware is block-oriented:</li>\n<li>Transfer unit: 4,096 bytes (or 512 bytes at the sector level)</li>\n<li>Operations: read block N, write block N</li>\n<li>No concept of partial block access\nThe filesystem is the translator. It must implement the byte-addressable API entirely on top of block-level primitives. Every operation must be decomposed into:</li>\n</ul>\n<ol>\n<li><strong>Which block(s) does this byte range touch?</strong> (offset arithmetic)</li>\n<li><strong>Where is each of those blocks on disk?</strong> (pointer tree traversal from Milestone 2)</li>\n<li><strong>Which RMW cycles are needed?</strong> (for writes that don&#39;t fill entire blocks)</li>\n<li><strong>Which new blocks need allocation?</strong> (for writes that extend the file)</li>\n<li><strong>What metadata needs updating?</strong> (inode size, timestamps)\nThe concrete numbers driving this tension:</li>\n</ol>\n<ul>\n<li>Writing 1 byte costs: 1 block read (100Î¼s SSD) + 1 block write (100Î¼s SSD) = <strong>200Î¼s minimum</strong></li>\n<li>A purely sequential 4KB-aligned write costs: 1 block write = <strong>100Î¼s</strong></li>\n<li>The ratio: a 1-byte random write is 2Ã— more expensive than a 4KB write, even though it transfers 4096Ã— less data\nThis is why database designers lose sleep over random I/O patterns. This is why SSDs use write buffers. This is why the Linux page cache exists. Every optimization in every storage system is ultimately trying to avoid unnecessary RMW cycles.</li>\n</ul>\n<hr>\n<h2 id=\"create_file-bringing-a-file-into-existence\"><code>create_file</code>: Bringing a File Into Existence</h2>\n<p>Before you can read or write a file, it must exist. <code>create_file</code> bridges Milestone 3&#39;s directory layer and Milestone 2&#39;s inode layer into a single coherent operation.</p>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m4-create-file-trace.svg\" alt=\"create_file â€” Full Operation Trace\"></p>\n<p>The operation is a composition of primitives you have already built:</p>\n<ol>\n<li>Verify the parent directory exists and does not already contain <code>name</code></li>\n<li>Allocate a new inode from the inode bitmap</li>\n<li>Initialize the inode (regular file, <code>nlinks = 1</code>, <code>size = 0</code>, all block pointers zero)</li>\n<li>Write the initialized inode to the inode table on disk</li>\n<li>Add a directory entry in the parent directory pointing to the new inode</li>\n<li>Return the new inode number\nNotice that step 6 returns the inode number, not a file descriptor. Your filesystem layer operates on inode numbers directly. The FUSE integration in Milestone 5 will translate between POSIX file descriptors and inode numbers.</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;time.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Create a new regular file in a parent directory.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * fd:         open file descriptor of the disk image</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * sb:         superblock (updated in place for free counts)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * parent_ino: inode number of the parent directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * name:       filename to create (single component, not a full path)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * mode:       permission bits; will be OR'd with S_IFREG</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * uid, gid:   owner</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns the new file's inode number on success, negative errno on failure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> fs_create_file</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                   uint32_t</span><span style=\"color:#FFAB70\"> parent_ino</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                   uint16_t</span><span style=\"color:#FFAB70\"> mode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> uid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> gid</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Validate parent */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> parent_inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, parent_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">parent_inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">S_ISDIR</span><span style=\"color:#E1E4E8\">(parent_inode.mode)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTDIR;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Check name length and uniqueness */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> name_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strlen</span><span style=\"color:#E1E4E8\">(name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (name_len </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> name_len </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> MAX_FILENAME_LEN) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">dir_lookup</span><span style=\"color:#E1E4E8\">(fd, sb, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">parent_inode, name) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EEXIST;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Allocate new inode */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> new_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_inode</span><span style=\"color:#E1E4E8\">(fd, sb);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (new_ino </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOSPC;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Initialize inode for a regular empty file */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> new_inode;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">new_inode, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(new_inode));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_inode.mode   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\">)(S_IFREG </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> (mode </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0</span><span style=\"color:#79B8FF\">777</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_inode.uid    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> uid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_inode.gid    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_inode.nlinks </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_inode.size   </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">       /* empty file â€” no data yet */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> now </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_inode.atime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_inode.mtime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_inode.ctime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> now;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* All block pointers start as 0 (null) â€” no blocks allocated yet */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Write inode to disk */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">new_inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Roll back inode allocation */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint8_t</span><span style=\"color:#FFAB70\"> ibmap</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        read_block</span><span style=\"color:#E1E4E8\">(fd, INODE_BITMAP_BLOCK, ibmap);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        bitmap_clear</span><span style=\"color:#E1E4E8\">(ibmap, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_ino </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        write_block</span><span style=\"color:#E1E4E8\">(fd, INODE_BITMAP_BLOCK, ibmap);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sb->free_inodes</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Add directory entry in parent */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dir_add_entry</span><span style=\"color:#E1E4E8\">(fd, sb, parent_ino, name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                          (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_ino, FT_REG_FILE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Best-effort cleanup: free the inode */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        free_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_ino);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> new_ino;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<blockquote>\n<p><strong>Design note</strong>: You write the inode to disk <em>before</em> adding the directory entry. If you crash between the two writes, you have an allocated inode that no directory entry points to â€” an &quot;orphan.&quot; This is detectable and recoverable by <code>fsck</code> (it can scan all inodes and verify every allocated inode has at least one directory reference). The reverse â€” directory entry pointing to an uninitialized inode â€” is far worse, because code would follow the inode number, read garbage, and potentially corrupt the filesystem. Bitmap-before-inode, inode-before-dirent: this is the safe write ordering without journaling.</p>\n</blockquote>\n<hr>\n<h2 id=\"offset-arithmetic-the-two-level-translation\">Offset Arithmetic: The Two-Level Translation</h2>\n<p>Before implementing <code>read</code> and <code>write</code>, you need to deeply understand the offset-to-block translation. This is where bugs hide, where off-by-ones silently corrupt neighboring files, and where the whole system&#39;s correctness lives.</p>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m4-offset-to-block-flowchart.svg\" alt=\"Offset-to-Block Decision Flowchart\"></p>\n<p>Given a file offset (a byte position within the file), you need three things:</p>\n<ol>\n<li><strong>Block index</strong> (<code>block_index = offset / BLOCK_SIZE</code>): which logical block of the file, starting at 0</li>\n<li><strong>Byte offset within block</strong> (<code>block_offset = offset % BLOCK_SIZE</code>): how far into that block</li>\n<li><strong>Disk block number</strong>: obtained by calling <code>inode_get_block(fd, inode, block_index * BLOCK_SIZE, &amp;disk_block_num)</code> â€” the function you built in Milestone 2\nLet&#39;s trace a concrete example. A <code>read</code> starting at file offset 6,000 for 5,000 bytes:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>File offset 6000:\n  block_index   = 6000 / 4096 = 1\n  block_offset  = 6000 % 4096 = 1904\nBytes [6000 .. 8191] are in block index 1, starting at position 1904\n  â†’ 4096 - 1904 = 2192 bytes available in this block\nBytes [8192 .. 10999] are in block index 2, starting at position 0\n  â†’ remaining 2808 bytes of the 5000-byte request\nSo this 5000-byte read requires two block reads.</code></pre></div>\n\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m4-read-trace.svg\" alt=\"read(inode, offset=6000, length=5000) â€” Complete Data Walk\"></p>\n<p>The general algorithm for any multi-block operation:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>remaining = total_length\ncurrent_offset = start_offset\nwhile remaining &gt; 0:\n    block_index  = current_offset / BLOCK_SIZE\n    block_offset = current_offset % BLOCK_SIZE\n    chunk_size   = min(BLOCK_SIZE - block_offset, remaining)\n    # get disk block number for block_index\n    # do block I/O using chunk_size at block_offset\n    current_offset += chunk_size\n    remaining      -= chunk_size</code></pre></div>\n<h2 id=\"this-loop-is-the-skeleton-of-both-read-and-write-the-difference-is-what-you-do-with-the-block-once-you-have-it\">This loop is the skeleton of both <code>read</code> and <code>write</code>. The difference is what you do with the block once you have it.</h2>\n<h2 id=\"fs_read-reading-data-through-the-pointer-tree\"><code>fs_read</code>: Reading Data Through the Pointer Tree</h2>\n<p>Reading is the simpler of the two operations because it is read-only: you traverse the pointer tree, fetch blocks, copy data, update <code>atime</code>. No allocation, no RMW cycle.\nThe one nuance: when <code>inode_get_block</code> returns 0 (a null pointer â€” a sparse hole), you must zero-fill the output buffer for that range. No disk I/O. No allocation. Zeros come from CPU registers, not from disk.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Read data from a file.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * fd:       disk image file descriptor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * sb:       superblock</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * ino:      inode number of the file to read</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * offset:   byte offset within the file to start reading</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * buf:      caller-allocated buffer to receive data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * length:   number of bytes to read</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns the number of bytes actually read on success (may be less</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * than length if offset + length extends past the end of file),</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * or negative errno on error.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#B392F0\"> fs_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                uint32_t</span><span style=\"color:#FFAB70\"> ino</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#FFAB70\"> offset</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> length</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">S_ISREG</span><span style=\"color:#E1E4E8\">(inode.mode)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Clamp to end of file â€” cannot read past EOF */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (offset </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> inode.size) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (offset </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> length </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> inode.size) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)(inode.size </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> offset);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">out </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)buf;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\">   remaining </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> length;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> cur_offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> offset;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\">  block_buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (remaining </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* How many bytes into the current block, and how many to copy from it */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> block_off  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)(cur_offset </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\">   chunk      </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> block_off;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (chunk </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> remaining) chunk </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> remaining;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Translate file offset â†’ disk block number via inode pointer tree */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> disk_block;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> inode_get_block</span><span style=\"color:#E1E4E8\">(fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                cur_offset </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> block_off, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">disk_block);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (disk_block </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * Sparse hole: this block has never been written.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * Return zeros â€” no disk I/O needed.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * This is the correct POSIX behavior: holes read as zero bytes.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            memset</span><span style=\"color:#E1E4E8\">(out, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, chunk);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Read the block from disk */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, disk_block, block_buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            memcpy</span><span style=\"color:#E1E4E8\">(out, block_buf </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> block_off, chunk);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        out        </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> chunk;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cur_offset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> chunk;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        remaining  </span><span style=\"color:#F97583\">-=</span><span style=\"color:#E1E4E8\"> chunk;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Update atime.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * In production, use the 'relatime' heuristic (only update if atime</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * is older than mtime/ctime) to avoid write-per-read amplification.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * For correctness, update unconditionally here.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode.atime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    write_inode</span><span style=\"color:#E1E4E8\">(fd, sb, ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#E1E4E8\">)length;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<blockquote>\n<p><strong>Hardware Soul â€” Where Are Those Zero Bytes From?</strong>\nWhen <code>disk_block == 0</code> and you call <code>memset(out, 0, chunk)</code>, this is a write to the user&#39;s buffer in RAM. The CPU issues store instructions; modern CPUs can zero ~64 bytes per cycle using SIMD (SSE/AVX <code>vpxor</code> + <code>vmovdqu</code>). For a 4KB sparse read, this is ~64 CPU cycles â€” under 30ns. Compare to a real disk read: ~100Î¼s on SSD. Sparse reads are <strong>3,000Ã— faster</strong> than real reads. This is not a quirk; it is a design choice. Holes are free to read, which is why VM disk images work efficiently even when provisioned as 100GB but containing only 2GB of real data.</p>\n</blockquote>\n<hr>\n<h2 id=\"fs_write-the-read-modify-write-reality\"><code>fs_write</code>: The Read-Modify-Write Reality</h2>\n<p>Writing is where the complexity lives. Three distinct cases must be handled, and they can all occur within a single <code>write</code> call:\n<strong>Case 1: Write completely fills one or more blocks</strong> (offset is block-aligned, length is a multiple of <code>BLOCK_SIZE</code>)\nâ†’ No RMW needed. Read zero existing content. Just allocate the block if needed and write full 4KB chunks.\n<strong>Case 2: Write starts or ends in the middle of a block</strong> (partial first or last block)\nâ†’ RMW required. Read the existing block content, overwrite the portion being written, write the whole block back.\n<strong>Case 3: Write extends the file past EOF and the partial block at EOF has existing content</strong>\nâ†’ Partial RMW: read the existing partial block (which may be partially written), zero-fill up to <code>BLOCK_SIZE</code>, write new data on top, then write back.</p>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m4-write-rmw.svg\" alt=\"Write â€” The Read-Modify-Write Cycle\"></p>\n<p>The implementation handles all three cases in a single unified loop by always reading the block before writing if the write is partial:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Write data to a file.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * fd:       disk image file descriptor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * sb:       superblock (updated: free_blocks)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * ino:      inode number of the file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * offset:   byte offset within the file to start writing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * buf:      data to write</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * length:   number of bytes to write</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns the number of bytes written on success (always equals length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * unless a real error occurs), negative errno on failure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Side effects:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   - Allocates new data blocks as needed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   - Allocates indirect/double-indirect pointer blocks as needed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   - Updates inode.size if writing past current EOF</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   - Updates inode.mtime and inode.ctime</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#B392F0\"> fs_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                 uint32_t</span><span style=\"color:#FFAB70\"> ino</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#FFAB70\"> offset</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                 const</span><span style=\"color:#F97583\"> void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> length</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (length </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">S_ISREG</span><span style=\"color:#E1E4E8\">(inode.mode)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Check file size limit (our inode uses uint32_t for size â†’ max ~4GB) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (offset </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> length </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)UINT32_MAX) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFBIG;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> uint8_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">in  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> uint8_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)buf;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\">   remaining </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> length;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> cur_offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> offset;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\">  block_buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (remaining </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> block_off  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)(cur_offset </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\">   chunk      </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> block_off;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (chunk </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> remaining) chunk </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> remaining;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#E1E4E8\"> partial_write  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (block_off </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> (chunk </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Get current disk block number for this file offset (may be 0 = hole) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> disk_block;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> inode_get_block</span><span style=\"color:#E1E4E8\">(fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                cur_offset </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> block_off, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">disk_block);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (disk_block </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Block not yet allocated â€” allocate a new one */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            int</span><span style=\"color:#E1E4E8\"> new_blk </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_block</span><span style=\"color:#E1E4E8\">(fd, sb);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (new_blk </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOSPC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            disk_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_blk;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * Record the new block number in the inode pointer tree.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * inode_set_block may allocate indirect/double-indirect blocks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * if the file offset is in those regions.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> inode_set_block</span><span style=\"color:#E1E4E8\">(fd, sb, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                cur_offset </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> block_off, disk_block);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * Zero-initialize the newly allocated block.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * WHY: If this is a partial write (we won't fill the entire block),</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * we need the rest of the block to contain zeros, not garbage from</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * whatever previously occupied this disk location.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * If the write IS full-block, the memset is overwritten immediately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * below. Slight inefficiency for full-block writes; correctness</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * for partial writes.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            memset</span><span style=\"color:#E1E4E8\">(block_buf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (partial_write) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * Block exists and this is a partial write: read existing content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * so we can preserve the bytes we're not overwriting.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * This is the READ in \"read-modify-write\".</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * Cost: 1 block read (~100Î¼s SSD) that would not be needed if</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * writes were always block-aligned.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, disk_block, block_buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Copy the new data into the buffer at the correct offset within the block.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * For full-block writes: block_off == 0, chunk == BLOCK_SIZE.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * For partial writes: we modify only the [block_off, block_off+chunk) range.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memcpy</span><span style=\"color:#E1E4E8\">(block_buf </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> block_off, in, chunk);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Write the (possibly modified) block back to disk */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, disk_block, block_buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        in         </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> chunk;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cur_offset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> chunk;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        remaining  </span><span style=\"color:#F97583\">-=</span><span style=\"color:#E1E4E8\"> chunk;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Update inode metadata.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Only extend size â€” writing within existing content does not shrink the file.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (cur_offset </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> inode.size) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        inode.size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)cur_offset;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> now </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode.mtime  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> now;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode.ctime  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> now;</span><span style=\"color:#6A737D\">   /* inode metadata changed (size may have changed) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_inode</span><span style=\"color:#E1E4E8\">(fd, sb, ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#E1E4E8\">)length;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Let&#39;s trace through the concrete example from the chapter opening: <code>write(fd, buf, 100)</code> at offset 5000:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>offset = 5000, length = 100\nIteration 1:\n  block_off = 5000 % 4096 = 904\n  chunk     = min(4096 - 904, 100) = min(3192, 100) = 100\n  partial_write = true  (block_off != 0)\n  â†’ inode_get_block for block index 1\n  â†’ if disk_block exists: read_block (THE READ in RMW)\n  â†’ memcpy(block_buf + 904, in, 100)  (THE MODIFY)\n  â†’ write_block  (THE WRITE)\n  â†’ remaining = 0, loop ends\nTotal disk operations: 1 read + 1 write = 2 block I/Os\nData actually modified: 100 bytes\nData transferred to/from disk: 4096 + 4096 = 8192 bytes\nWrite amplification factor: 81.92Ã—</code></pre></div>\n<p>Eighty-two times more data moved than the actual payload. For a 1-byte write, the amplification is 8192Ã—. This is not a bug; it is the unavoidable cost of block-aligned storage.</p>\n<blockquote>\n<p><strong>Hardware Soul â€” Block Write Ordering on SSD</strong>\nWhen <code>write_block</code> returns, the data is in the kernel&#39;s <strong>page cache</strong> â€” kernel memory, not on any persistent storage. The kernel may hold it there for seconds or minutes, coalescing multiple writes to the same block before flushing. This is why <code>write()</code> is fast in practice despite the RMW overhead: subsequent writes to the same block hit the page cache (memory speed) instead of disk. The page cache converts your RMW cycle from a disk operation into a memory operation. Only when the page is eventually flushed (dirty page writeback, <code>fsync</code>, or unmount) does the actual disk I/O occur. For your filesystem running on top of a host kernel, this cache layer is automatic. Your filesystem is inside the cache from the host OS&#39;s perspective.</p>\n</blockquote>\n<hr>\n<h2 id=\"sparse-file-writes-skipping-the-gap\">Sparse File Writes: Skipping the Gap</h2>\n<p>The sparse file case is handled naturally by your write loop, but it deserves explicit attention because the behavior is subtle.\nConsider: <code>fs_write(fd, sb, ino, 1000000000, &quot;X&quot;, 1)</code> â€” writing one byte at offset one billion, into a file that was previously empty.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Iteration 1:\n  cur_offset  = 1,000,000,000\n  block_off   = 1,000,000,000 % 4096 = 3904\n  chunk       = 4096 - 3904 = 192... but wait, length=1, so chunk=1\n  block_index = 1,000,000,000 / 4096 = 244,140 (in the double-indirect region)\n  inode_get_block â†’ returns disk_block = 0 (no block allocated)\n  alloc_block â†’ returns new disk block number\n  inode_set_block(fd, sb, &amp;inode, 999,996,416, new_block)\n    â†’ this allocates the double-indirect block (if not yet allocated)\n    â†’ this allocates the single-indirect block within it (if not yet allocated)\n    â†’ stores new_block in the correct slot\n  memset(block_buf, 0, BLOCK_SIZE)  â† entire block is zeroed\n  block_buf[3904] = 'X'             â† our one byte\n  write_block(fd, new_block, block_buf)\nAfter loop:\n  inode.size = 1,000,000,001</code></pre></div>\n<p>The blocks between offset 0 and offset 999,996,416 are <strong>never touched</strong>. They remain as null pointers in the inode&#39;s block pointer tree. Every <code>inode_get_block</code> call for any offset in that range returns 0, and every <code>fs_read</code> call for that range returns zeros from <code>memset</code>. The file appears to be 1GB but uses only:</p>\n<ul>\n<li>1 data block (4KB)</li>\n<li>1 single-indirect block (4KB)</li>\n<li>1 double-indirect block (4KB)\nTotal on-disk: 12KB. Logical size: ~1GB. [[EXPLAIN:thin-provisioning-â€”-storage-allocation-deferred-until-first-write|Thin provisioning â€” deferred storage allocation where capacity is reserved logically but not physically allocated until written]]</li>\n</ul>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m2-sparse-file.svg\" alt=\"Sparse File â€” Null Pointers as Holes\"></p>\n<h2 id=\"this-is-not-a-special-mode-you-enable-sparse-files-are-the-default-behavior-of-null-block-pointers-the-file-you-create-is-automatically-sparse-if-you-write-at-high-offsets-without-filling-in-between\">This is not a special mode you enable. Sparse files are the <strong>default</strong> behavior of null block pointers. The file you create is automatically sparse if you write at high offsets without filling in between.</h2>\n<h2 id=\"append-writing-at-the-end\">Append: Writing at the End</h2>\n<p>Append is a special case of write where the starting offset is always <code>inode.size</code> (the current end of file). It is not fundamentally different from a mid-file write, but it has one important optimization opportunity: you never need to RMW the last block if the previous write happened to fill it exactly.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Append data to the end of a file.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Convenience wrapper around fs_write.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns number of bytes written, or negative errno.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#B392F0\"> fs_append</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                  uint32_t</span><span style=\"color:#FFAB70\"> ino</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> length</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Read current inode to get the file size (= append offset) */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> fs_write</span><span style=\"color:#E1E4E8\">(fd, sb, ino, (</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)inode.size, buf, length);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>The interesting case for append: what if the previous write ended at offset 4095 (one byte before a block boundary)? The next append&#39;s first byte lands at offset 4096 â€” a perfect block boundary. <code>block_off = 4096 % 4096 = 0</code>. The first iteration has <code>partial_write = false</code> if <code>chunk == BLOCK_SIZE</code>. No read needed. This is why sequential append-only workloads (log files, write-ahead journals, streaming data) are efficient at the block layer: they naturally generate full-block writes without RMW overhead.</p>\n<blockquote>\n<p>The lesson: if you control your write pattern, <strong>align writes to block boundaries</strong>. A log that always writes in 4KB chunks avoids every RMW cycle. This is not an accident â€” it is the same reason database write-ahead logs (WAL), Kafka partitions, and your Milestone 6 journal all use block-sized writes: they are optimizing away the most expensive per-operation cost.</p>\n</blockquote>\n<hr>\n<h2 id=\"fs_truncate-the-inverse-of-write\"><code>fs_truncate</code>: The Inverse of Write</h2>\n<p>Truncation changes a file&#39;s size without moving data. It has two symmetric cases:\n<strong>Shrink</strong> (<code>new_size &lt; inode.size</code>): free all blocks that are now beyond the new end, zero out the partial last block if the new size is not block-aligned, update the inode pointer tree to null out freed entries.\n<strong>Extend</strong> (<code>new_size &gt; inode.size</code>): do nothing to existing data or pointers â€” the new region is implicitly a sparse hole. Update <code>inode.size</code>. Future reads in the extended region return zeros.\nThe extend case is trivially correct with sparse files: since null block pointers already read as zeros, you just need to update <code>inode.size</code>. The shrink case requires careful traversal.</p>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m4-truncate-shrink.svg\" alt=\"Truncate Shrink â€” Freeing Blocks Beyond New Size\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Truncate a file to new_size bytes.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * If new_size > inode.size: extend (hole-filling, no allocation needed).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * If new_size &#x3C; inode.size: shrink (free blocks beyond new_size, update pointers).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * If new_size == inode.size: no-op (but still update ctime).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns 0 on success, negative errno on failure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> fs_truncate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                uint32_t</span><span style=\"color:#FFAB70\"> ino</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#FFAB70\"> new_size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (new_size </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)UINT32_MAX) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFBIG;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">S_ISREG</span><span style=\"color:#E1E4E8\">(inode.mode)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (new_size </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> inode.size) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Extend: the new range [inode.size, new_size) is a sparse hole.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * No block allocation needed. Just update size.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Future reads in this range return zeros via the sparse-hole path.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        inode.size  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        inode.mtime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inode.ctime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> write_inode</span><span style=\"color:#E1E4E8\">(fd, sb, ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (new_size </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> inode.size) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        inode.ctime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> write_inode</span><span style=\"color:#E1E4E8\">(fd, sb, ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Shrink: new_size &#x3C; inode.size.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * We need to free every block whose file offset is >= new_size.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Additionally, if new_size is not block-aligned, we must zero out</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * the tail of the last retained block.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Strategy: iterate through block indices from first_free_block_index</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * to the end of the file, free each block, and null its pointer.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> new_last_block  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (new_size </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                                :</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)((new_size </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> old_last_block  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (inode.size </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                                  :</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)((inode.size </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 1: Zero-fill the tail of the last retained block (partial block at new_size) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (new_size </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> (new_size </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> disk_block;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> inode_get_block</span><span style=\"color:#E1E4E8\">(fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                (</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)new_last_block </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">disk_block);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (disk_block </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint8_t</span><span style=\"color:#FFAB70\"> block_buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, disk_block, block_buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint32_t</span><span style=\"color:#E1E4E8\"> zero_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)(new_size </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            memset</span><span style=\"color:#E1E4E8\">(block_buf </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> zero_start, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> zero_start);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, disk_block, block_buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 2: Free all blocks with index > new_last_block (or all if new_size == 0) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> first_to_free </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (new_size </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> :</span><span style=\"color:#E1E4E8\"> (new_last_block </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> bi </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> first_to_free; bi </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> old_last_block; bi</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> disk_block;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> inode_get_block</span><span style=\"color:#E1E4E8\">(fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                (</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)bi </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">disk_block);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* best-effort during truncate */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (disk_block </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            free_block</span><span style=\"color:#E1E4E8\">(fd, sb, disk_block);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Null out the pointer in the inode/indirect block */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            inode_set_block</span><span style=\"color:#E1E4E8\">(fd, sb, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                            (</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)bi </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 3: Free indirect pointer blocks that are now entirely empty.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * After nulling data block pointers, check if single-indirect and</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * double-indirect blocks themselves are now empty and can be freed.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    truncate_free_indirect_if_empty</span><span style=\"color:#E1E4E8\">(fd, sb, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_size);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 4: Update inode */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode.size  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode.mtime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inode.ctime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> write_inode</span><span style=\"color:#E1E4E8\">(fd, sb, ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>The <code>truncate_free_indirect_if_empty</code> function checks whether the single-indirect and double-indirect pointer blocks should themselves be freed. This matters when truncating a large file down to something smaller than 48KB (below the direct-block threshold):</p>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m4-truncate-with-indirect.svg\" alt=\"Truncate Below Indirect Threshold â€” Freeing Indirect Blocks\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * After nulling data block pointers during shrink-truncate,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * check if the indirect pointer blocks themselves are now all-zeros</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * and can be freed.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> truncate_free_indirect_if_empty</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                                             inode_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                             uint32_t</span><span style=\"color:#FFAB70\"> new_size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> single_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)N_DIRECT </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> double_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> single_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)PTRS_PER_BLOCK </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* If new_size is within direct block range and single-indirect exists */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)new_size </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> single_start </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> inode->single_indirect </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* All data pointers in this block should already be nulled.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Free the single-indirect block itself. */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        free_block</span><span style=\"color:#E1E4E8\">(fd, sb, inode->single_indirect);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        inode->single_indirect </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* If new_size is within (direct + single-indirect) range and double-indirect exists */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)new_size </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> double_start </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> inode->double_indirect </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * For full correctness: scan each entry in the double-indirect block,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * free any remaining single-indirect blocks within it.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * The loop above already freed their data block pointers;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * we now free the single-indirect blocks themselves.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, inode->double_indirect, buf) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">ptrs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)buf;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> PTRS_PER_BLOCK; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ptrs</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    /* Check if this single-indirect block is now all zeros */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    uint8_t</span><span style=\"color:#FFAB70\"> si_buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, </span><span style=\"color:#FFAB70\">ptrs</span><span style=\"color:#E1E4E8\">[i], si_buf) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        bool</span><span style=\"color:#E1E4E8\"> all_zero </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; j </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE; j</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">si_buf</span><span style=\"color:#E1E4E8\">[j] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { all_zero </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        if</span><span style=\"color:#E1E4E8\"> (all_zero) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                            free_block</span><span style=\"color:#E1E4E8\">(fd, sb, </span><span style=\"color:#FFAB70\">ptrs</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                            ptrs</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            write_block</span><span style=\"color:#E1E4E8\">(fd, inode->double_indirect, buf);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* If new_size is in direct range, free the double-indirect block too */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)new_size </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> single_start) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            free_block</span><span style=\"color:#E1E4E8\">(fd, sb, inode->double_indirect);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            inode->double_indirect </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<blockquote>\n<p><strong>Pitfall â€” Truncation and Partial Block Zeroing</strong>: When you shrink a file to <code>new_size = 5000</code>, the last retained block (block index 1, covering file offsets 4096â€“8191) must have its bytes from 5000 to 8191 zeroed out. If you skip this step, the bytes from 5000 to 8191 remain on disk as whatever the file previously contained. If the file is later extended back past 5000 (via <code>truncate</code> extend), those &quot;ghost bytes&quot; reappear as if they were written, even though the file never logically contained them at those positions. This is a <strong>security vulnerability</strong> in multi-user systems â€” one user&#39;s file data leaks into another user&#39;s file after truncation and re-extension. Always zero the tail of the last retained block.</p>\n</blockquote>\n<hr>\n<h2 id=\"metadata-correctness-size-mtime-ctime\">Metadata Correctness: Size, mtime, ctime</h2>\n<p>Every write and truncate operation must update inode metadata. Getting this right matters for correctness of tools like <code>rsync</code>, <code>make</code>, and every backup system that uses timestamps and file sizes for change detection.\nThe rules:</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th><code>size</code></th>\n<th><code>mtime</code></th>\n<th><code>ctime</code></th>\n<th><code>atime</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>write</code> (data changes)</td>\n<td>Update if grown</td>\n<td>Always update</td>\n<td>Always update</td>\n<td>Unchanged</td>\n</tr>\n<tr>\n<td><code>truncate</code> (size changes)</td>\n<td>Always update</td>\n<td>Always update</td>\n<td>Always update</td>\n<td>Unchanged</td>\n</tr>\n<tr>\n<td><code>read</code> (data accessed)</td>\n<td>No change</td>\n<td>No change</td>\n<td>No change</td>\n<td>Update</td>\n</tr>\n<tr>\n<td><code>chmod</code>, <code>chown</code> (meta changes)</td>\n<td>No change</td>\n<td>No change</td>\n<td>Always update</td>\n<td>Unchanged</td>\n</tr>\n<tr>\n<td>A subtle correctness requirement: <code>ctime</code> must update whenever <strong>anything</strong> in the inode changes â€” including <code>size</code>, <code>mtime</code>, and <code>nlinks</code>. The reason: <code>ctime</code> is the &quot;inode change time,&quot; not just the &quot;data change time.&quot; A rename operation (which changes directory entries but not data) must update <code>ctime</code> on the affected inode. <code>mtime</code> only tracks data changes.</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Helper: update inode metadata after a write operation.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Call this instead of manually setting fields â€” ensures consistency.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> update_write_metadata</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">inode_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                   uint64_t</span><span style=\"color:#FFAB70\"> new_end_offset</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> now </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (new_end_offset </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> inode->size) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        inode->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_end_offset;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode->mtime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> now;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode->ctime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> now;</span><span style=\"color:#6A737D\">   /* size and mtime both changed â†’ ctime must change */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"three-level-view-what-happens-when-fs_write-runs\">Three-Level View: What Happens When <code>fs_write</code> Runs</h2>\n<p>Let&#39;s trace <code>fs_write(fd, sb, ino=7, offset=8192, buf=&quot;Hello&quot;, length=5)</code> â€” writing &quot;Hello&quot; at a block-aligned offset in a small file.</p>\n<table>\n<thead>\n<tr>\n<th>Level</th>\n<th>What Happens</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Application (your code)</strong></td>\n<td>Calls <code>fs_write</code>. Arithmetic: <code>block_off = 8192 % 4096 = 0</code>, <code>chunk = min(4096, 5) = 5</code>, <code>partial_write = true</code> (chunk &lt; BLOCK_SIZE). Calls <code>inode_get_block(fd, &amp;inode, 8192, &amp;disk_block)</code>.</td>\n</tr>\n<tr>\n<td><strong>Your Filesystem Layer</strong></td>\n<td><code>inode_get_block</code> computes <code>block_index = 2</code> â†’ within direct range â†’ returns <code>inode.blocks[2]</code>. If it&#39;s 0: <code>alloc_block(fd, sb)</code> reads the bitmap block, finds free bit, sets it, writes bitmap back, returns disk block number. <code>inode_set_block</code> stores the new disk block number in <code>inode.blocks[2]</code>. <code>memset(block_buf, 0, 4096)</code> zeroes new block. <code>memcpy(block_buf + 0, &quot;Hello&quot;, 5)</code>. <code>write_block(fd, disk_block, block_buf)</code> calls <code>write(fd, buf, 4096)</code> at the right offset in the image file.</td>\n</tr>\n<tr>\n<td><strong>Host OS / Hardware</strong></td>\n<td>The host kernel receives the <code>write</code> syscall. The disk image file&#39;s page in the page cache is found (or faulted in). The 4096 bytes are written to the kernel&#39;s page cache page â€” marking it dirty. The <code>write</code> syscall returns immediately. Eventually, the page daemon (or an <code>fsync</code>) flushes this dirty page to the actual storage device via block I/O. The device DMA controller transfers the page from kernel memory to disk buffer. Disk confirms write. Page marked clean.</td>\n</tr>\n<tr>\n<td>The key observation: your <code>write_block</code> returns before the data hits physical storage. The data exists in the host kernel&#39;s page cache â€” safe from process crashes but not from power failures. This is why <code>fsync(fd)</code> on your disk image file descriptor matters before claiming a write is &quot;committed.&quot;</td>\n<td></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"design-decision-when-to-flush-the-inode\">Design Decision: When to Flush the Inode</h2>\n<p>After a <code>write</code>, you must update the inode (<code>size</code>, <code>mtime</code>, <code>ctime</code>) and write it to disk. But how often?</p>\n<table>\n<thead>\n<tr>\n<th>Strategy</th>\n<th>Write Frequency</th>\n<th>Data Safety</th>\n<th>Performance</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>After every write (chosen âœ“ for now)</strong></td>\n<td>Every <code>fs_write</code> call</td>\n<td>Good: metadata matches data at all times (within page cache lag)</td>\n<td>Poor: 1 inode write per data write = 2Ã— disk I/Os</td>\n</tr>\n<tr>\n<td>Batch: flush inode on <code>close</code> / <code>fsync</code></td>\n<td>Once at close/sync</td>\n<td>Poor: crash between write and close loses size update; reads see wrong size</td>\n<td>Better: inode writes amortized over many data writes</td>\n</tr>\n<tr>\n<td>Write-through cache: dirty inode in memory, flush asynchronously</td>\n<td>Asynchronously</td>\n<td>With journaling: excellent; without: crash window</td>\n<td>Best throughput</td>\n</tr>\n<tr>\n<td>For your standalone implementation without a buffer cache, &quot;after every write&quot; is the correct choice â€” it is simple and correct. The journal in Milestone 6 will group inode updates with data writes into atomic transactions, both improving safety and enabling the batched flush optimization.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>The numbers: on a filesystem with 1,000 sequential 512-byte writes to the same file, the &quot;after every write&quot; strategy generates 1,000 inode writes and 1,000 data block writes (the data writes coalesce since they&#39;re in the same 4KB block after the first). The batched strategy generates ~1 inode write and ~1 data write. For sequential small writes, this is a 500Ã— difference in inode write operations. This is one reason why <code>write</code> performance degrades sharply for small random writes to the same file.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"unit-tests-verifying-round-trip-correctness\">Unit Tests: Verifying Round-Trip Correctness</h2>\n<p>Your acceptance criteria demand round-trip verification. Here is a comprehensive test suite:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;assert.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Full test suite for file read/write operations.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Run after mkfs on a fresh disk image.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Assumes root_ino is valid and accessible.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_file_operations</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">=== File Read/Write Tests ===</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> root_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sb->root_inode;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ------------------------------------------------------------------ */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 1: create_file basic */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> file_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_create_file</span><span style=\"color:#E1E4E8\">(fd, sb, root_ino, </span><span style=\"color:#9ECBFF\">\"test.txt\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                   0</span><span style=\"color:#79B8FF\">644</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(file_ino </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> inode;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)file_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">S_ISREG</span><span style=\"color:#E1E4E8\">(inode.mode));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(inode.size </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(inode.nlinks </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: create_file â†’ inode </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, size=0</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, file_ino);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ------------------------------------------------------------------ */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 2: write and read back â€” small (sub-block, aligned) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">msg </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"Hello, Filesystem!\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> msg_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strlen</span><span style=\"color:#E1E4E8\">(msg);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> written </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_write</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)file_ino,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                                0</span><span style=\"color:#E1E4E8\">, msg, msg_len);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(written </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#E1E4E8\">)msg_len);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)file_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(inode.size </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> msg_len);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> read_buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(read_buf, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">AA</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(read_buf));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> nread </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_read</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)file_ino,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                             0</span><span style=\"color:#E1E4E8\">, read_buf, msg_len);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(nread </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#E1E4E8\">)msg_len);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">memcmp</span><span style=\"color:#E1E4E8\">(read_buf, msg, msg_len) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: write + read round-trip (small, aligned)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ------------------------------------------------------------------ */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 3: partial write â€” crosses NO block boundary */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">patch </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"World\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    written </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_write</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)file_ino, </span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">, patch, </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(written </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nread </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_read</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)file_ino, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, read_buf, msg_len);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(nread </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#E1E4E8\">)msg_len);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">memcmp</span><span style=\"color:#E1E4E8\">(read_buf, </span><span style=\"color:#9ECBFF\">\"Hello, World!stem!\"</span><span style=\"color:#E1E4E8\">, msg_len) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: partial overwrite within single block</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ------------------------------------------------------------------ */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 4: write crossing a block boundary */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* File currently ends at offset msg_len. Write so it crosses block 0â†’1 */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* First, extend to block boundary - 50 bytes */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pre_boundary </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 50</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> fill_buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(fill_buf, </span><span style=\"color:#9ECBFF\">'A'</span><span style=\"color:#E1E4E8\">, pre_boundary);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Overwrite from offset 0 with BLOCK_SIZE-50 bytes of 'A' */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Then write 100 bytes of 'B' crossing the boundary */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    written </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_write</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)file_ino, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, fill_buf, pre_boundary);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(written </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#E1E4E8\">)pre_boundary);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> cross_buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(cross_buf, </span><span style=\"color:#9ECBFF\">'B'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    written </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_write</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)file_ino,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        pre_boundary, cross_buf, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(written </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Verify: 50 bytes of 'B' in block 0 tail, 50 bytes of 'B' in block 1 head */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> verify</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nread </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_read</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)file_ino, pre_boundary, verify, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(nread </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">verify</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'B'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Verify pre-boundary bytes are still 'A' */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> check_a</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nread </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_read</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)file_ino,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    pre_boundary </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">, check_a, </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(nread </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">check_a</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'A'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: write crossing block boundary (block 0 â†’ block 1)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ------------------------------------------------------------------ */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 5: sparse file â€” write at high offset */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> sparse_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_create_file</span><span style=\"color:#E1E4E8\">(fd, sb, root_ino, </span><span style=\"color:#9ECBFF\">\"sparse.txt\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                     0</span><span style=\"color:#79B8FF\">644</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(sparse_ino </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> sparse_data</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">'S'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'P'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'A'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'R'</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> sparse_offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)BLOCK_SIZE </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* well into direct range */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    written </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_write</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)sparse_ino,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        sparse_offset, sparse_data, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(written </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Read the hole (offset 0) â€” must be zeros */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> hole_buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nread </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_read</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)sparse_ino, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, hole_buf, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(nread </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">hole_buf</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Read the written data */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> sparse_read</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nread </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_read</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)sparse_ino,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    sparse_offset, sparse_read, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(nread </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">memcmp</span><span style=\"color:#E1E4E8\">(sparse_read, sparse_data, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Verify inode size but minimal block allocation */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)sparse_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(inode.size </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> sparse_offset </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: sparse file â€” hole reads as zeros, data reads correctly</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ------------------------------------------------------------------ */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 6: truncate shrink â€” reduce to half */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> trunc_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_create_file</span><span style=\"color:#E1E4E8\">(fd, sb, root_ino, </span><span style=\"color:#9ECBFF\">\"trunc.txt\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                    0</span><span style=\"color:#79B8FF\">644</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(trunc_ino </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> trunc_data</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(trunc_data, </span><span style=\"color:#9ECBFF\">'T'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(trunc_data));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    written </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_write</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)trunc_ino,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                        0</span><span style=\"color:#E1E4E8\">, trunc_data, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(trunc_data));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(written </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(trunc_data));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> free_before </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sb->free_blocks;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> tr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_truncate</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)trunc_ino, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(tr </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)trunc_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(inode.size </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Two blocks should have been freed */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(sb->free_blocks </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> free_before </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Verify truncated data: first block still readable */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> trunc_read</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nread </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_read</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)trunc_ino, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, trunc_read, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(nread </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">trunc_read</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'T'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Verify reading past new EOF returns 0 */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nread </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_read</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)trunc_ino, BLOCK_SIZE, trunc_read, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(nread </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: truncate shrink â€” size updated, blocks freed, data preserved</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ------------------------------------------------------------------ */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 7: truncate extend (sparse extend) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ext_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_create_file</span><span style=\"color:#E1E4E8\">(fd, sb, root_ino, </span><span style=\"color:#9ECBFF\">\"ext.txt\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                  0</span><span style=\"color:#79B8FF\">644</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(ext_ino </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> small_data</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(small_data, </span><span style=\"color:#9ECBFF\">'E'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_write</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)ext_ino, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, small_data, </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> free_before_ext </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sb->free_blocks;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_truncate</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)ext_ino, BLOCK_SIZE </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(tr </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)ext_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(inode.size </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* No new blocks should have been allocated (extension is sparse) */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(sb->free_blocks </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> free_before_ext);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Reads in extended region should return zeros */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> ext_read</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nread </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_read</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)ext_ino, BLOCK_SIZE, ext_read, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(nread </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 64</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ext_read</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: truncate extend â€” sparse, no allocation, reads as zeros</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ------------------------------------------------------------------ */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 8: append */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> app_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_create_file</span><span style=\"color:#E1E4E8\">(fd, sb, root_ino, </span><span style=\"color:#9ECBFF\">\"append.txt\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                  0</span><span style=\"color:#79B8FF\">644</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(app_ino </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> line_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> snprintf</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(line), </span><span style=\"color:#9ECBFF\">\"Line </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, i);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        ssize_t</span><span style=\"color:#E1E4E8\"> wr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_append</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)app_ino, line, (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)line_len);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(wr </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> line_len);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)app_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(inode.size </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: append â€” 10 lines written sequentially</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ------------------------------------------------------------------ */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 9: read past EOF returns truncated data */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nread </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_read</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)file_ino,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    inode.size </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">, read_buf, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(nread </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: read past EOF returns 0</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ------------------------------------------------------------------ */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 10: mtime/ctime updated after write */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ts_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_create_file</span><span style=\"color:#E1E4E8\">(fd, sb, root_ino, </span><span style=\"color:#9ECBFF\">\"ts.txt\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                 0</span><span style=\"color:#79B8FF\">644</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(ts_ino </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)ts_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> create_mtime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inode.mtime;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Sleep briefly to ensure timestamp difference is detectable */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* In a real test, you'd mock time; here we just verify it's non-zero */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_write</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)ts_ino, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"X\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)ts_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(inode.mtime </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> create_mtime);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(inode.ctime </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> create_mtime);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(inode.size </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: mtime/ctime updated after write</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ------------------------------------------------------------------ */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test 11: truncate zeroes tail of partial block */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> zero_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_create_file</span><span style=\"color:#E1E4E8\">(fd, sb, root_ino, </span><span style=\"color:#9ECBFF\">\"zero.txt\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                   0</span><span style=\"color:#79B8FF\">644</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(zero_ino </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> full_block</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(full_block, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">FF</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_write</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)zero_ino, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, full_block, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Truncate to 512 bytes â€” tail of block should be zeroed */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_truncate</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)zero_ino, </span><span style=\"color:#79B8FF\">512</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Extend back to BLOCK_SIZE â€” bytes 512..4095 must be zero, not 0xFF */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_truncate</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)zero_ino, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> after_extend</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_read</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)zero_ino, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, after_extend, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 512</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">after_extend</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FF</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 512</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">after_extend</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">00</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: truncate zeroes tail of partial block</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"=== All File I/O Tests Passed ===</span><span style=\"color:#79B8FF\">\\n\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"knowledge-cascade-one-write-ten-worlds\">Knowledge Cascade: One Write, Ten Worlds</h2>\n<p>You have just built the operation that every storage system in existence is trying to optimize. The read-modify-write cycle you implemented is the fundamental bottleneck of block storage. Every major pattern in storage systems engineering is a response to this single fact.</p>\n<h3 id=\"database-write-amplification-and-lsm-trees\">Database Write Amplification and LSM-Trees</h3>\n<p>[[EXPLAIN:lsm-tree-â€”-log-structured-merge-tree-batch-random-writes-into-sequential-io|LSM-tree â€” Log-Structured Merge Tree, converts random writes into sequential I/O by batching in a memtable]]\nYour <code>fs_write</code> at a random offset costs: 1 block read + 1 block write = 2 disk operations per write, regardless of how many bytes you actually changed. For a database updating 8-byte rows randomly across a 10GB table, every row update triggers this 2-operation cycle for a 4096-byte block â€” writing ~0.2% of the data you read. This is <em>write amplification</em>: you write more to disk than your actual payload requires.\nThe consequence is profound: a spinning disk doing 100 random IOPS can sustain 100 random row updates per second â€” terrible for any write-heavy workload. LevelDB and RocksDB exist as the answer to this problem. The LSM-tree (Log-Structured Merge Tree) collects all writes in a <strong>memtable</strong> (an in-memory sorted structure), then writes the memtable to disk as a <strong>sequential SSTable</strong> (Sorted String Table) when it fills. Random writes become sequential writes. Your random <code>fs_write</code> at arbitrary offsets becomes a sequential append to the SSTable. The &quot;merge&quot; in LSM-Tree is the background process that consolidates multiple SSTables into one, handling the complexity that random access has been deferred to.\nUnderstanding your <code>fs_write</code> and its RMW cost is understanding <em>why the LSM-tree is the right data structure for write-heavy workloads</em>. It is not a clever trick; it is the logical response to a physical constraint you now understand from first principles.</p>\n<h3 id=\"ssd-write-amplification-compound-costs\">SSD Write Amplification: Compound Costs</h3>\n<p>Your filesystem&#39;s write amplification sits on top of the SSD&#39;s own write amplification, and the two multiply.\n[[EXPLAIN:nand-flash-write-constraints-â€”-write-in-pages-erase-in-larger-blocks-requiring-flash-translation-layer|NAND flash write constraints â€” NAND cells write in pages (<del>4-16KB) and erase in much larger blocks (</del>128-512KB), requiring a Flash Translation Layer]]\nWhen your <code>fs_write</code> triggers a 4KB block write, the SSD receives a 4KB write request to a logical block address (LBA). Internally, NAND flash cannot overwrite: it must erase before writing. Erase operations work on &quot;erase blocks&quot; of 128KBâ€“1MB. If the SSD&#39;s target page is not in an empty erase block, the SSD must:</p>\n<ol>\n<li>Read the entire erase block (128KB) into an internal buffer</li>\n<li>Erase the erase block (an expensive ~1ms operation)</li>\n<li>Write the modified page back plus all the other pages that were in that erase block\nA 4KB write from your filesystem may cause 128KB of physical NAND writes internally. On top of your filesystem&#39;s own amplification (writing 4096 bytes to update 100 bytes), you now have the SSD amplifying that 4096-byte write by 32Ã— internally. A 100-byte application write â†’ 4096-byte filesystem block â†’ 128KB NAND write: 1,280Ã— total amplification.\nThis is why SSDs use large internal caches (DRAM or SLC NAND) to buffer writes, why SSD firmware includes sophisticated write scheduling, why <code>fstrim</code> exists (to inform the SSD which blocks are logically free so it can garbage-collect proactively), and why &quot;write endurance&quot; (total bytes written before NAND cell failure) is a key SSD specification. You are not just writing to your filesystem; you are writing to a physical system with its own internal indirection layer.</li>\n</ol>\n<h3 id=\"the-linux-page-cache-why-your-writes-aren39t-that-slow\">The Linux Page Cache: Why Your Writes Aren&#39;t That Slow</h3>\n<p>If your <code>fs_write</code> caused an actual disk RMW on every call, interactive applications would be unusable. A text editor writing one character at a time to a file would need 200Î¼s per character â€” 50 characters per second maximum throughput. That&#39;s slower than a 1970s teletype.\nThe Linux page cache (also called the buffer cache in older literature) is the mechanism that makes this bearable. Every block your filesystem reads or writes goes through the page cache:</p>\n<ul>\n<li><strong>Read</strong>: if the 4KB block is in the cache (a &quot;cache hit&quot;), return from memory (<del>100ns). If not (a &quot;cache miss&quot;), read from disk (</del>100Î¼s), store in cache, return.</li>\n<li><strong>Write</strong>: store in cache (mark page &quot;dirty&quot;), return immediately. The kernel writes dirty pages to disk asynchronously in the background (via <code>pdflush</code>/<code>kworker</code> threads), coalescing multiple writes to the same block into a single disk write.\nFor your <code>fs_write</code> calling into a test, the &quot;write&quot; to disk is actually a write to the kernel&#39;s page cache, which returns at memory speed. The RMW cycle becomes: read block from page cache (100ns if hot), modify in memory, mark dirty. No disk I/O unless the page cache is under memory pressure or <code>fsync</code> is called.\nUnderstanding why the page cache exists requires understanding the RMW cycle. The page cache is precisely the buffer that transforms &quot;every write is an RMW&quot; into &quot;every write is a memory operation, with asynchronous disk flushing when convenient.&quot; Without the page cache, your text editor, web browser, and every other interactive application that writes small amounts of data would be unusable.<blockquote>\n<p>ðŸ”­ <strong>Deep Dive</strong>: Robert Love&#39;s &quot;Linux Kernel Development&quot; (3rd ed.), Chapter 16 covers the page cache and writeback mechanism in detail. The <code>struct address_space</code> and <code>struct page</code> types are the kernel data structures that implement what you are experiencing as fast writes. For the specific writeback mechanism: Chapter 16.2 &quot;Dirty Page Writeback.&quot;</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"sparse-files-and-cloud-thin-provisioning\">Sparse Files and Cloud Thin Provisioning</h3>\n<p>Every major cloud provider&#39;s block storage product (AWS EBS, Google Persistent Disk, Azure Managed Disks) is implemented using the sparse file principle you just built. When you provision a 1TB EBS volume in AWS, AWS does not immediately allocate 1TB of physical storage. It creates a metadata record saying &quot;this volume is 1TB&quot; and allocates physical storage only as you write to it. This is called <strong>thin provisioning</strong>.\nA VM disk image file on ext4 or XFS on the hypervisor host is a sparse file. The QCOW2 format (used by QEMU/KVM) implements its own internal sparse allocation, on top of the host filesystem&#39;s sparse support, giving two levels of sparseness. A container using an overlay filesystem has its base layer as a sparse-ish collection of files, with only the written-to files consuming real storage in the upper layer.\nThe economic implication: cloud providers can &quot;oversell&quot; storage capacity, knowing that users who provision 1TB typically write far less than 1TB. The system works because sparse writes are free until the data is actually written. When a hypervisor host runs out of physical storage because too many VMs simultaneously started writing heavily, that is a &quot;storage balloon&quot; event â€” and your <code>alloc_block</code> returning <code>-ENOSPC</code> is the filesystem-level symptom that applications see.</p>\n<h3 id=\"copy-on-write-filesystems-avoiding-rmw-entirely\">Copy-on-Write Filesystems: Avoiding RMW Entirely</h3>\n<p>Your <code>fs_write</code> modifies blocks in place: read the existing block, modify bytes, write it back to the same location. This is called <strong>update-in-place</strong> (or write-in-place). ZFS and Btrfs take a radically different approach: <strong>copy-on-write (CoW)</strong>.\n[[EXPLAIN:copy-on-write-filesystems-â€”-modified-blocks-written-to-new-locations-with-atomic-pointer-updates|Copy-on-write filesystems â€” modified blocks written to new locations and pointer updated atomically, never overwriting existing data]]\nIn a CoW filesystem, when you write to a block:</p>\n<ol>\n<li>Allocate a <em>new</em> disk block</li>\n<li>Write the modified content to the new block</li>\n<li>Update the inode&#39;s block pointer to point to the new block</li>\n<li>Mark the old block as free\nThe old block is never overwritten. The write goes to a new location. The critical insight: step 3 (updating the inode pointer) is a small, atomic metadata write. If the system crashes between steps 2 and 3, the old block is still intact (the inode still points to it). There is no torn-write state: either the old content is visible (pointer not yet updated) or the new content is visible (pointer updated). The intermediate state â€” half old, half new â€” is impossible.\nThis eliminates the crash consistency problem that Milestone 6 solves with journaling. ZFS and Btrfs never need <code>fsck</code>. The entire filesystem tree is a tree of immutable blocks with pointer updates propagated to the root. The root block&#39;s pointer update is the single atomic commit that makes a write permanent.\nThe downside: CoW creates fragmentation aggressively, since no write ever goes to the same location twice. Solid-state drives handle this better than spinning disks (which prefer sequential access), but even SSDs degrade with severe fragmentation. Btrfs requires periodic <code>btrfs balance</code> runs to defragment; ZFS handles it with its pool-level free space management.\nUnderstanding your in-place <code>fs_write</code> is understanding why CoW is a different tradeoff: you trade simpler crash recovery for higher fragmentation and more complex space management.</li>\n</ol>\n<h3 id=\"the-o_direct-flag-bypassing-the-buffer-cache\">The O_DIRECT Flag: Bypassing the Buffer Cache</h3>\n<h2 id=\"explaindirect-io-o_direct-bypassing-the-kernel-page-cache-for-user-controlled-bufferingdirect-io-o_direct-bypassing-the-kernel-page-cache-requiring-aligned-buffers-used-by-databases-for-self-managed-caching-when-you-open-a-file-with-o_direct-you-instruct-the-kernel-to-bypass-the-page-cache-entirely-your-reads-and-writes-go-directly-to-the-block-device-the-constraints-buffer-addresses-and-lengths-must-be-block-aligned-typically-512-byte-or-4096-byte-aligned-who-uses-o_direct-databases-mysql-innodb-postgresql-with-synchronous_commit-on-oracle-all-optionally-use-o_direct-to-manage-their-own-buffer-pools-instead-of-relying-on-the-os-page-cache-why-because-the-database-knows-its-access-patterns-better-than-the-os-a-sequential-full-table-scan-should-not-pollute-the-page-cache-with-pages-that-will-never-be-read-again-evicting-hot-index-pages-the-database39s-buffer-pool-implements-its-own-lruclock-eviction-policy-tuned-to-database-access-patterns-your-fs_write-calls-the-kernel39s-write-syscall-which-goes-through-the-page-cache-if-you-were-building-a-database-storage-engine-directly-on-your-filesystem-not-through-a-posix-file-you-might-want-o_direct-semantics-to-avoid-double-buffering-your-database-buffer-pool-the-os-page-cache-both-holding-the-same-data-understanding-block-level-io-is-a-prerequisite-for-understanding-why-o_direct-exists-and-when-to-use-it\">[[EXPLAIN:direct-i/o-o_direct-â€”-bypassing-the-kernel-page-cache-for-user-controlled-buffering|Direct I/O (O_DIRECT) â€” bypassing the kernel page cache, requiring aligned buffers, used by databases for self-managed caching]]\nWhen you open a file with <code>O_DIRECT</code>, you instruct the kernel to bypass the page cache entirely. Your reads and writes go directly to the block device. The constraints: buffer addresses and lengths must be block-aligned (typically 512-byte or 4096-byte aligned).\nWho uses <code>O_DIRECT</code>? Databases. MySQL InnoDB, PostgreSQL (with <code>synchronous_commit = on</code>), Oracle â€” all optionally use O_DIRECT to manage their own buffer pools instead of relying on the OS page cache. Why? Because the database knows its access patterns better than the OS. A sequential full table scan should not pollute the page cache with pages that will never be read again, evicting hot index pages. The database&#39;s buffer pool implements its own LRU/clock eviction policy tuned to database access patterns.\nYour <code>fs_write</code> calls the kernel&#39;s <code>write()</code> syscall, which goes through the page cache. If you were building a database storage engine directly on your filesystem (not through a POSIX file), you might want <code>O_DIRECT</code> semantics to avoid double-buffering (your database buffer pool + the OS page cache both holding the same data). Understanding block-level I/O is a prerequisite for understanding why <code>O_DIRECT</code> exists and when to use it.</h2>\n<h2 id=\"before-you-move-on-pitfall-checklist\">Before You Move On: Pitfall Checklist</h2>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Partial block writes zero-fill new blocks</strong>: When <code>alloc_block</code> returns a new block and the write is partial, call <code>memset(block_buf, 0, BLOCK_SIZE)</code> before writing the new content. A fresh block from the disk image may contain garbage bytes from previous filesystem operations. If you write &quot;Hello&quot; at offset 904 of a new block without zeroing first, bytes 0â€“903 and 908â€“4095 contain undefined data from whatever previously occupied that disk location.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>RMW only when block exists</strong>: Only call <code>read_block</code> in the write path if <code>disk_block != 0</code> and the write is partial. If the block was just allocated (<code>disk_block</code> was 0 and you called <code>alloc_block</code>), skip the read â€” you already zeroed the buffer with <code>memset</code>. Calling <code>read_block</code> on a freshly allocated block reads uninitialized disk content, defeating the zero-fill.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Update inode size only on growth</strong>: <code>inode.size = max(inode.size, offset + length)</code>. Writing at offset 0 on a 100-byte file with 5 bytes must not shrink the file to 5 bytes. The write path never shrinks the size â€” only <code>fs_truncate</code> does.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Truncate partial-block zeroing</strong>: When truncating to a size that is not block-aligned, zero bytes from <code>new_size % BLOCK_SIZE</code> to <code>BLOCK_SIZE - 1</code> in the last retained block. Skipping this leaks previous file content into subsequent truncate-extend cycles â€” a security bug in multi-user systems.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Free indirect blocks during truncate</strong>: When truncating below the single-indirect threshold (48KB), free the single-indirect block itself after nulling its data pointers. When truncating below the double-indirect threshold, free all single-indirect blocks within the double-indirect and then the double-indirect block. Each freed indirect block is 4KB of disk space that <code>sb-&gt;free_blocks</code> must account for.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Block allocation failure rollback</strong>: If <code>alloc_block</code> returns <code>-ENOSPC</code> mid-write, you have already written some blocks. The partial write has occurred. Return the bytes actually written (not an error) if any data was written, or <code>-ENOSPC</code> if nothing was written. POSIX specifies that a partial write is legitimate. Do not leave the inode in an inconsistent state (update <code>size</code> and timestamps to reflect what was actually written).</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong><code>inode_set_block</code> for newly allocated blocks</strong>: After calling <code>alloc_block</code> to get a new disk block number, always call <code>inode_set_block(fd, sb, &amp;inode, file_offset, disk_block)</code> to record the pointer before writing data to the block. If you write data first and then crash before recording the pointer, the data is unreachable (leaked block). The order: allocate â†’ record pointer â†’ write data.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong><code>atime</code> update on reads</strong>: <code>fs_read</code> must update <code>inode.atime</code> and call <code>write_inode</code>. This causes a write for every read â€” the &quot;atime write amplification&quot; problem. For FUSE (Milestone 5), implement <code>relatime</code>: only update <code>atime</code> if <code>atime &lt; mtime</code>. This reduces the write-per-read to cases where the file has been modified since last access â€” typically once per read session rather than once per read call.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>EOF clamp in <code>fs_read</code></strong>: If <code>offset &gt;= inode.size</code>, return 0 immediately (not an error). If <code>offset + length &gt; inode.size</code>, clamp <code>length = inode.size - offset</code>. Reading past EOF is not an error in POSIX; it returns 0 bytes. An unclamped read would access blocks beyond the file&#39;s logical size, potentially reading another file&#39;s data if those blocks happen to be allocated.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Block 0 is never a data block</strong>: The <code>alloc_block</code> function should never return 0 (the superblock&#39;s disk block number). If <code>disk_block == 0</code> after <code>alloc_block</code>, something is catastrophically wrong. Add an assertion: <code>assert(disk_block &gt;= sb-&gt;data_block_start)</code> after every <code>alloc_block</code> call. Similarly, in <code>inode_get_block</code>, a returned <code>disk_block == 0</code> means &quot;sparse hole&quot; â€” not a pointer to the superblock. The convention that 0 is the null/sparse sentinel is what makes this work, and it requires that legitimate data blocks always have numbers â‰¥ <code>data_block_start</code>.</li>\n</ul>\n<hr>\n<h2 id=\"what-you39ve-built-and-what-comes-next\">What You&#39;ve Built and What Comes Next</h2>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-L0-satellite-map.svg\" alt=\"Filesystem Atlas â€” Satellite Map (Home Base)\"></p>\n<h2 id=\"you-now-have-a-complete-working-filesystem-in-the-sense-that-it-can-create-files-name-them-in-directories-store-arbitrary-byte-content-in-them-via-a-multi-level-block-pointer-tree-retrieve-that-content-by-inode-number-and-byte-offset-grow-and-shrink-files-through-write-and-truncate-and-support-sparse-files-where-holes-cost-nothing-but-there-is-a-gap-between-quotworking-filesystem-libraryquot-and-quota-filesystem-you-can-actually-usequot-right-now-you-can-only-interact-with-your-filesystem-by-calling-fs_read-fs_write-fs_create_file-directly-from-c-code-you-cannot-use-standard-unix-tools-ls-cat-cp-vim-grep-against-your-filesystem-you-cannot-mount-it-it-is-a-library-not-a-filesystem-in-the-unix-sense-milestone-5-closes-that-gap-via-fuse-filesystem-in-userspace-fuse-provides-a-mechanism-for-running-a-filesystem-in-userspace-your-process-while-the-kernel-routes-vfs-calls-from-any-application-to-your-callbacks-you-will-implement-a-thin-translation-layer-that-maps-fuse-callback-arguments-path-strings-posix-stat-structs-file-handle-integers-to-your-internal-operations-path-resolution-fs_read-fs_write-inode_t-after-milestone-5-you-will-be-able-to-run-mount-t-fuse-myfs-mntmyfs-and-then-cp-r-documents-mntmyfs-and-have-your-filesystem-actually-store-those-files-the-block-level-io-you-just-built-is-the-foundation-every-fuse-callback-for-every-file-operation-read-write-create-truncate-getattr-will-ultimately-call-the-functions-in-this-milestone-the-work-you-have-done-here-is-the-engine-fuse-is-the-transmission-that-connects-it-to-the-outside-world\">You now have a complete, working filesystem â€” in the sense that it can create files, name them in directories, store arbitrary byte content in them via a multi-level block pointer tree, retrieve that content by inode number and byte offset, grow and shrink files through write and truncate, and support sparse files where holes cost nothing.\nBut there is a gap between &quot;working filesystem library&quot; and &quot;a filesystem you can actually use.&quot; Right now, you can only interact with your filesystem by calling <code>fs_read</code>, <code>fs_write</code>, <code>fs_create_file</code> directly from C code. You cannot use standard Unix tools â€” <code>ls</code>, <code>cat</code>, <code>cp</code>, <code>vim</code>, <code>grep</code> â€” against your filesystem. You cannot mount it. It is a library, not a filesystem in the Unix sense.\nMilestone 5 closes that gap via <strong>FUSE</strong> (Filesystem in Userspace). FUSE provides a mechanism for running a filesystem in userspace (your process) while the kernel routes VFS calls from any application to your callbacks. You will implement a thin translation layer that maps FUSE callback arguments (path strings, POSIX stat structs, file handle integers) to your internal operations (path resolution, <code>fs_read</code>, <code>fs_write</code>, <code>inode_t</code>). After Milestone 5, you will be able to run <code>mount -t fuse ./myfs /mnt/myfs</code> and then <code>cp -r ~/Documents /mnt/myfs/</code> and have your filesystem actually store those files.\nThe block-level I/O you just built is the foundation. Every FUSE callback for every file operation â€” <code>read</code>, <code>write</code>, <code>create</code>, <code>truncate</code>, <code>getattr</code> â€” will ultimately call the functions in this milestone. The work you have done here is the engine; FUSE is the transmission that connects it to the outside world.</h2>\n<!-- END_MS -->\n\n\n<!-- MS_ID: filesystem-m5 -->\n<!-- MS_ID: filesystem-m5 -->\n<h1 id=\"milestone-5-fuse-integration\">Milestone 5: FUSE Integration</h1>\n<h2 id=\"the-wall-that-was-never-there\">The Wall That Was Never There</h2>\n<p>You have built a complete filesystem. It can format a raw disk image, allocate blocks and inodes, store file data across a multi-level block pointer tree, create and navigate a directory hierarchy, and read or write arbitrary byte ranges with correct sparse-file semantics. Every function you have written is correct. Every test passes.\nAnd yet: if you open a terminal right now and type <code>ls /mnt/myfs</code>, nothing happens. Your filesystem does not exist as far as the operating system is concerned. <code>cat</code>, <code>cp</code>, <code>grep</code>, <code>vim</code> â€” none of these tools can see a single byte you have stored. You have built a library, not a filesystem.\nMost developers hit this point and assume the solution requires kernel programming. Surely, they think, to make the OS route <code>open(&quot;/mnt/myfs/file.txt&quot;)</code> to your code, you need to write a kernel module â€” modify the VFS layer, compile against kernel headers, deal with <code>MODULE_LICENSE(&quot;GPL&quot;)</code>, and risk a kernel panic every time you make a mistake. The VFS feels like a wall between userspace code and the rest of the OS.\nThat wall does not exist.\n<strong>FUSE</strong> (Filesystem in USErspace) is a kernel module â€” already present in every modern Linux system â€” that acts as a relay. When any process on the system makes a VFS call (<code>open</code>, <code>stat</code>, <code>read</code>, <code>write</code>, <code>mkdir</code>) against a FUSE-mounted path, the kernel&#39;s VFS dispatches that call to the FUSE kernel module, which serializes it into a message, writes it to <code>/dev/fuse</code>, and blocks waiting for a response. Your userspace process is reading from that same <code>/dev/fuse</code> file descriptor. You receive the request, call your internal filesystem functions, serialize the result, and write it back. The FUSE module receives the response, unpacks it, and returns it to the calling process â€” which has no idea this round-trip through userspace ever happened.\n[[EXPLAIN:fuse-architecture-â€”-how-userspace-filesystems-intercept-vfs-calls|FUSE architecture â€” how userspace filesystems intercept VFS calls]]\nThe latency cost of this relay is real: approximately 2â€“5 microseconds per operation, dominated by two context switches (kernelâ†’user for dispatch, userâ†’kernel for response). For metadata-heavy workloads like <code>find</code> or <code>git status</code>, this adds up. For data-heavy workloads like streaming a video file, the per-byte overhead disappears into the block transfer cost. Production filesystems built on FUSE include GlusterFS, SSHFS, rclone mount, mergerfs, and Google&#39;s internal Colossus client. FUSE is not a toy.\nThe real surprise â€” the one that shapes everything in this milestone â€” is this: <strong>FUSE calls your code with path strings, not inode numbers</strong>. When <code>ls /mnt/myfs/home/user</code> runs, FUSE&#39;s <code>readdir</code> callback receives the string <code>&quot;/home/user&quot;</code>. Before you can call a single one of your internal functions, you must resolve that path to an inode number. The <code>path_resolve</code> function you built in Milestone 3 is not just one feature among many â€” it is the hottest code path in your entire filesystem.\nLet&#39;s wire this up.</p>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m5-fuse-architecture.svg\" alt=\"FUSE Architecture â€” Kernel/Userspace Data Flow\"></p>\n<hr>\n<h2 id=\"the-fundamental-tension-vfs-contract-userspace-implementation\">The Fundamental Tension: VFS Contract, Userspace Implementation</h2>\n<p>[[EXPLAIN:vfs-abstraction-layer-â€”-the-kernel-interface-all-filesystems-must-implement|VFS abstraction layer â€” the kernel&#39;s unified interface that ext4, XFS, NFS, and your filesystem all implement]]\nThe kernel&#39;s VFS (Virtual Filesystem Switch) defines a contract: every filesystem, whether it is ext4 built into the kernel, NFS communicating over the network, or your FUSE implementation running as a userspace process, must implement a specific set of operations. In the kernel, these are function pointers grouped into three C structures:</p>\n<ul>\n<li><code>struct inode_operations</code>: operations on inodes (<code>lookup</code>, <code>create</code>, <code>mkdir</code>, <code>unlink</code>, <code>rename</code>, <code>getattr</code>, <code>chmod</code>, <code>utimes</code>)</li>\n<li><code>struct file_operations</code>: operations on open files (<code>open</code>, <code>read</code>, <code>write</code>, <code>release</code>, <code>readdir</code>)</li>\n<li><code>struct super_operations</code>: operations on the filesystem itself (<code>statfs</code>, <code>sync_fs</code>, <code>put_super</code>)\nThe FUSE kernel module implements all of these by forwarding them over the <code>/dev/fuse</code> channel to your process. <code>libfuse</code> â€” the C library you link against â€” handles the low-level protocol: reading requests from the file descriptor, dispatching them to function pointers you register, and writing responses back.\nYour job is to fill in those function pointers with implementations that call your Milestone 1â€“4 code. The architectural tension is this:\n<strong>The VFS contract is inode-based. FUSE delivers path-based requests. Your internal functions are inode-based. Every FUSE callback must perform path resolution to bridge the gap.</strong>\nFor a filesystem mounted at <code>/mnt/myfs</code>, when a process calls <code>stat(&quot;/mnt/myfs/home/user/file.txt&quot;)</code>:</li>\n</ul>\n<ol>\n<li>The kernel VFS resolves the mount point, sees it&#39;s FUSE-backed</li>\n<li>FUSE kernel module packages the request: opcode=<code>GETATTR</code>, path=<code>&quot;/home/user/file.txt&quot;</code></li>\n<li>Your process receives it, calls <code>path_resolve(fd, sb, &quot;/home/user/file.txt&quot;, root_ino, root_ino)</code></li>\n<li>That traverses three directory blocks, returns inode 1041</li>\n<li>You call <code>read_inode(fd, sb, 1041, &amp;inode)</code>, convert to a POSIX <code>struct stat</code>, and return it</li>\n<li>FUSE kernel module delivers the <code>stat</code> result to the calling process\nStep 3â€“4 is 3+ disk reads on a cold cache. For a process that calls <code>stat</code> on 10,000 files (like <code>find</code> or <code>git status</code>), that is 30,000+ cold disk reads just for path resolution. This is why the Linux VFS maintains a <strong>dcache</strong> (directory entry cache): a kernel-level hash table mapping <code>(parent_inode_number, filename)</code> to child inode number. FUSE can optionally tell the kernel to cache lookup results, dramatically reducing path resolution costs. We will implement this with entry timeouts.\nThe numbers matter here:</li>\n</ol>\n<ul>\n<li>Cold path resolution (3 disk reads Ã— 100Î¼s per SSD read) = ~300Î¼s per lookup</li>\n<li>With dcache hit: ~1Î¼s (pure kernel memory access)</li>\n<li>With FUSE entry timeout cache: after first lookup, subsequent lookups return cached result for the configured timeout duration\nThis 300Ã— difference between cached and uncached lookup explains why <code>ls</code> on a freshly mounted FUSE filesystem feels slow, while the second <code>ls</code> feels instant.</li>\n</ul>\n<hr>\n<h2 id=\"installing-libfuse-and-project-structure\">Installing libfuse and Project Structure</h2>\n<p>Before writing a single callback, set up your build environment. On Linux, libfuse 3.x is the current major version and the one we will use:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Debian/Ubuntu</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> apt-get</span><span style=\"color:#9ECBFF\"> install</span><span style=\"color:#9ECBFF\"> libfuse3-dev</span><span style=\"color:#9ECBFF\"> fuse3</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Fedora/RHEL</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> dnf</span><span style=\"color:#9ECBFF\"> install</span><span style=\"color:#9ECBFF\"> fuse3-devel</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pkg-config</span><span style=\"color:#79B8FF\"> --modversion</span><span style=\"color:#9ECBFF\"> fuse3</span></span></code></pre></div>\n<p>Your project now has two main entry points: <code>mkfs.c</code> (from Milestone 1) and <code>myfs.c</code> (the FUSE daemon). A sensible Makefile:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">makefile</span><pre class=\"arch-pre shiki-highlighted\"><code>CC      = gcc\nCFLAGS  = -Wall -Wextra -g -O2 $(shell pkg-config --cflags fuse3)\nLDFLAGS = $(shell pkg-config --libs fuse3)\nSRCS_COMMON = block.c bitmap.c inode.c dir.c file.c\nSRCS_MKFS   = mkfs.c $(SRCS_COMMON)\nSRCS_MYFS   = myfs.c $(SRCS_COMMON)\nall: mkfs myfs\nmkfs: $(SRCS_MKFS)\n\t$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)\nmyfs: $(SRCS_MYFS)\n\t$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)\nclean:\n\trm -f mkfs myfs *.o</code></pre></div>\n<p>Notice <code>FUSE_USE_VERSION</code> â€” this macro tells libfuse which API version you target. Always set it before including the FUSE header:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * myfs.c â€” FUSE integration layer.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * MUST define FUSE_USE_VERSION before including fuse.h.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * 31 targets the libfuse 3.x \"high-level\" API.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> FUSE_USE_VERSION</span><span style=\"color:#79B8FF\"> 31</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;fuse.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;fcntl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;pthread.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;time.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"fs.h\"</span><span style=\"color:#6A737D\">   /* your superblock_t, inode_t, all Milestone 1-4 functions */</span></span></code></pre></div>\n<hr>\n<h2 id=\"global-state-the-filesystem-context\">Global State: The Filesystem Context</h2>\n<p>Your FUSE daemon is a long-running process that holds all filesystem state. The state must be accessible from every FUSE callback, which libfuse delivers on different threads. Package everything into a single context struct:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Global filesystem context.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Initialized during mount; accessed by all FUSE callbacks.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Thread safety: All filesystem operations acquire fs_lock before</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * modifying any shared state. A coarse-grained global mutex is correct</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * for initial implementation; Milestone 6 will introduce per-transaction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * locking via the journal.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * MEMORY LAYOUT:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   fs_ctx:                  ~512 bytes (struct + sb fields)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   fs_ctx.sb:               4096 bytes (superblock, kept in memory)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Lock overhead (pthread): 40 bytes typical</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">         fd;</span><span style=\"color:#6A737D\">             /* file descriptor of the disk image */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    superblock_t</span><span style=\"color:#E1E4E8\"> sb;</span><span style=\"color:#6A737D\">            /* in-memory copy of the superblock */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_mutex_t</span><span style=\"color:#E1E4E8\"> lock;</span><span style=\"color:#6A737D\">       /* global filesystem mutex */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\">        image_path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\"> /* path to disk image, for fsync on unmount */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">fs_ctx_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> fs_ctx_t</span><span style=\"color:#E1E4E8\"> g_fs;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * RAII-style lock helpers.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Use these in every callback â€” never call pthread_mutex_lock directly.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> fs_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)   { </span><span style=\"color:#B392F0\">pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.lock); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> fs_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.lock); }</span></span></code></pre></div>\n<blockquote>\n<p><strong>Hardware Soul â€” Cache Line Contention on the Global Lock</strong>\nThe <code>g_fs</code> struct is accessed by multiple threads simultaneously. The <code>pthread_mutex_t</code> at offset <code>8 + 4096 = 4104</code> bytes into the struct â€” this is on a different cache line (64 bytes) than the <code>fd</code> and <code>sb</code> fields. This matters: when one thread holds the lock and another thread spins waiting, the spinning thread repeatedly reads the mutex state, keeping that cache line hot. If the mutex shared a cache line with <code>fd</code> or <code>sb</code>, every lock acquisition would invalidate the <code>fd</code> cache line in the holder&#39;s CPU, causing false sharing. The struct layout above avoids this naturally because <code>sb</code> is 4096 bytes and pushes <code>lock</code> onto its own cache line.\nThe <code>fuse_get_context()</code> function provides per-call information (UID, GID, PID of the calling process). You can use it inside callbacks to implement permission checking:</p>\n</blockquote>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Get the context inside a FUSE callback */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> fuse_context </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">ctx </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fuse_get_context</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uid_t</span><span style=\"color:#E1E4E8\"> caller_uid </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ctx</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">uid;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">gid_t</span><span style=\"color:#E1E4E8\"> caller_gid </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ctx</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">gid;</span></span></code></pre></div>\n<hr>\n<h2 id=\"the-path-translation-problem-your-central-design\">The Path Translation Problem: Your Central Design</h2>\n<p>Every FUSE high-level API callback receives a path string. Your internal functions operate on inode numbers. The translation is <code>path_resolve</code> from Milestone 3. But calling <code>path_resolve</code> naively in every callback carries a cost: each component lookup is a directory block read.\nWe need a helper that cleanly bridges this gap and handles the common case (getting an inode for a path, then doing something with it):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Resolve a path to an inode number.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns inode number (> 0) on success, negative errno on failure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This is the hottest function in the FUSE layer. Every callback</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * starts here. Profile first if optimizing.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Thread safety: Caller must hold fs_lock.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> resolve_path</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> path_resolve</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, path,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        g_fs.sb.root_inode, g_fs.sb.root_inode);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Resolve a path and read its inode into *out.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns 0 on success, negative errno on failure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Thread safety: Caller must hold fs_lock.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> path_to_inode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">ino_out</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">inode_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">inode_out</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> resolve_path</span><span style=\"color:#E1E4E8\">(path);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ino </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> ino;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)ino, inode_out) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">ino_out </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)ino;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>For operations that need both a parent directory and a leaf name (create, mkdir, unlink, rmdir, rename), we need path decomposition:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Split \"/home/user/file.txt\" into parent_path=\"/home/user\" and name=\"file.txt\".</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns 0 on success, -EINVAL if path has no parent (root).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Writes into caller-supplied buffers. parent_buf must be PATH_MAX bytes.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * name_out points into path (no allocation needed) â€” do not modify.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Thread safety: No shared state; safe to call without lock.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> split_path</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                      char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">parent_buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> parent_buf_size</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                      const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> **</span><span style=\"color:#FFAB70\">name_out</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">last_slash </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strrchr</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#9ECBFF\">'/'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (last_slash </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">name_out </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> last_slash </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">name_out </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span><span style=\"color:#6A737D\">   /* trailing slash */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> parent_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)(last_slash </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> path);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (parent_len </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* parent is root: path = \"/filename\" */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (parent_buf_size </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENAMETOOLONG;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        parent_buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '/'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        parent_buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (parent_len </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> parent_buf_size) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENAMETOOLONG;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memcpy</span><span style=\"color:#E1E4E8\">(parent_buf, path, parent_len);</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        parent_buf</span><span style=\"color:#E1E4E8\">[parent_len] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"mapping-inodes-to-struct-stat-the-inode_to_stat-bridge\">Mapping Inodes to <code>struct stat</code>: The <code>inode_to_stat</code> Bridge</h2>\n<p>Every FUSE callback that returns file metadata â€” <code>getattr</code>, <code>lookup</code>, <code>readdir</code> â€” must fill in a POSIX <code>struct stat</code>. This struct is what <code>ls -la</code>, <code>stat</code>, and <code>fstat</code> return to applications. Getting it right is critical: <code>ls</code> calls <code>getattr</code> on every path, and if <code>getattr</code> returns wrong values, nothing works.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Convert an in-memory inode_t to a POSIX struct stat.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * struct stat field mapping:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   st_ino     â† inode number</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   st_mode    â† inode.mode (already in POSIX format: S_IFDIR | 0755, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   st_nlink   â† inode.nlinks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   st_uid     â† inode.uid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   st_gid     â† inode.gid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   st_size    â† inode.size (logical file size in bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   st_blocks  â† computed: disk blocks used Ã— 512-byte units (POSIX convention)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   st_blksize â† 4096 (preferred I/O block size hint to applications)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   st_atime   â† inode.atime</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   st_mtime   â† inode.mtime</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   st_ctime   â† inode.ctime</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Note: st_blocks is in 512-byte units by POSIX convention, even though</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * our actual block size is 4096. Multiply logical block count by 8</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * (4096/512 = 8) to get the correct st_blocks value.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> inode_to_stat</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> inode_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> ino_num</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                            struct</span><span style=\"color:#E1E4E8\"> stat </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">st</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(st, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">st));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    st->st_ino     </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ino_num;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    st->st_mode    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inode->mode;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    st->st_nlink   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inode->nlinks;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    st->st_uid     </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inode->uid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    st->st_gid     </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inode->gid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    st->st_size    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inode->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    st->st_blksize </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Compute number of 512-byte blocks actually allocated on disk.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * For sparse files: count only non-null direct block pointers.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * For a full count including indirect blocks, we'd need to traverse</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * the pointer tree. For simplicity, approximate from size.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    st->st_blocks  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">off_t</span><span style=\"color:#E1E4E8\">)inode->size </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 511</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 512</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Timestamps: struct stat uses struct timespec for nanosecond precision.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Our inode stores only second-precision Unix timestamps.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * The .tv_nsec field is 0 â€” acceptable for our implementation. */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    st->st_atim.tv_sec  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inode->atime;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    st->st_atim.tv_nsec </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    st->st_mtim.tv_sec  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inode->mtime;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    st->st_mtim.tv_nsec </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    st->st_ctim.tv_sec  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inode->ctime;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    st->st_ctim.tv_nsec </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<blockquote>\n<p><strong>The <code>getattr</code> Pitfall</strong>: <code>getattr</code> is the first callback FUSE invokes for virtually every operation. Before <code>ls</code> can list directory contents, it calls <code>getattr</code> on the directory itself. Before <code>open</code> can open a file, the kernel calls <code>getattr</code>. Before <code>cp</code> can copy, <code>getattr</code> on both source and destination. If your <code>getattr</code> implementation is wrong or slow, nothing else in the system works. Test it first, test it exhaustively, test it before anything else.</p>\n</blockquote>\n<hr>\n<h2 id=\"implementing-the-core-callbacks\">Implementing the Core Callbacks</h2>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m5-callback-mapping.svg\" alt=\"FUSE Callbacks â†’ Internal Operations Mapping Table\"></p>\n<h3 id=\"getattr-the-most-called-callback\"><code>getattr</code> â€” The Most Called Callback</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * getattr â€” Get file attributes.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Called by: stat(), lstat(), fstat(), open(), ls, find, cp, mv â€” everything.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This is the hottest callback in the system.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * FUSE high-level API signature:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   path:   absolute path within the mount (e.g., \"/home/user/file.txt\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   st:     struct stat to fill in</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   fi:     file info (may be NULL for path-based calls; non-NULL for fd-based)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns 0 on success, negative errno on failure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> myfs_getattr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> stat </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">st</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         struct</span><span style=\"color:#E1E4E8\"> fuse_file_info </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">fi</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)fi;</span><span style=\"color:#6A737D\">   /* unused in our implementation */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_lock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ino;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> path_to_inode</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fs_unlock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> r;</span><span style=\"color:#6A737D\">   /* -ENOENT, -EIO, etc. */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    inode_to_stat</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode, ino, st);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_unlock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"readdir-directory-listing\"><code>readdir</code> â€” Directory Listing</h3>\n<p><code>readdir</code> is called when any program lists directory contents: <code>ls</code>, <code>find</code>, <code>opendir</code>/<code>readdir</code> loops, <code>glob</code>. libfuse&#39;s high-level API provides a <code>filler</code> function that you call for each entry:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * readdir â€” List directory contents.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Called by: ls, find, opendir/readdir, glob expansion.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * For each entry, call filler(buf, name, stat_or_NULL, offset, fill_flags).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returning stat is optional (NULL means FUSE will call getattr separately).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Providing stat avoids an extra getattr round-trip â€” do it for performance.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * We always output '.' and '..' first, as POSIX requires.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">buf;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    fuse_fill_dir_t</span><span style=\"color:#E1E4E8\"> filler;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> error;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">sb;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">readdir_ctx_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> readdir_emit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> inode_num</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                          uint8_t</span><span style=\"color:#FFAB70\"> file_type</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">userdata</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    readdir_ctx_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">ctx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">readdir_ctx_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)userdata;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ctx->error </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* short-circuit on previous error */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> stat st;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">st, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(st));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Read the inode to fill stat â€” costs a disk read per entry.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * For large directories this adds up; a future optimization would</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * cache inode reads here. */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(ctx->fd, ctx->sb, inode_num, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        inode_to_stat</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode, inode_num, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">st);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Populate minimal stat from directory entry type hint */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        st.st_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inode_num;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        st.st_mode </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (file_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> FT_DIR) </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> S_IFDIR </span><span style=\"color:#F97583\">|</span><span style=\"color:#F97583\"> 0</span><span style=\"color:#79B8FF\">755</span><span style=\"color:#F97583\"> :</span><span style=\"color:#E1E4E8\"> S_IFREG </span><span style=\"color:#F97583\">|</span><span style=\"color:#F97583\"> 0</span><span style=\"color:#79B8FF\">644</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ctx-></span><span style=\"color:#B392F0\">filler</span><span style=\"color:#E1E4E8\">(ctx->buf, name, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">st, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, FUSE_FILL_DIR_PLUS);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ctx->error </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOMEM;</span><span style=\"color:#6A737D\">  /* filler returns non-zero when buffer is full */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> myfs_readdir</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">fuse_fill_dir_t</span><span style=\"color:#FFAB70\"> filler</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         off_t</span><span style=\"color:#FFAB70\"> offset</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> fuse_file_info </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">fi</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         enum</span><span style=\"color:#E1E4E8\"> fuse_readdir_flags </span><span style=\"color:#FFAB70\">flags</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)offset; (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)fi; (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)flags;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_lock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ino;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> path_to_inode</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">fs_unlock</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">S_ISDIR</span><span style=\"color:#E1E4E8\">(inode.mode)) { </span><span style=\"color:#B392F0\">fs_unlock</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTDIR; }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    readdir_ctx_t</span><span style=\"color:#E1E4E8\"> ctx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .buf    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> buf,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .filler </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> filler,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .error  </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .fd     </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> g_fs.fd,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .sb     </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* dir_readdir calls readdir_emit for each entry (including '.' and '..') */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    dir_readdir</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, ino, readdir_emit, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">ctx);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_unlock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ctx.error;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"open-and-release-file-handle-lifecycle\"><code>open</code> and <code>release</code> â€” File Handle Lifecycle</h3>\n<p>In libfuse&#39;s high-level API, <code>open</code> does not need to allocate OS-level resources â€” libfuse handles that. Your <code>open</code> implementation validates that the file exists and is accessible. The <code>fi-&gt;fh</code> field (file handle) lets you store a per-open-file opaque value â€” we store the inode number there for fast access in subsequent <code>read</code>/<code>write</code> calls:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * open â€” Open a file.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Called when any process calls open(2), fopen(3), etc.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * fi->flags contains the open flags (O_RDONLY, O_WRONLY, O_RDWR, O_TRUNC, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * We validate existence and permissions here.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * We store the inode number in fi->fh to avoid re-resolving the path on every read/write.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> myfs_open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> fuse_file_info </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">fi</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_lock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ino;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> path_to_inode</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">fs_unlock</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">S_ISDIR</span><span style=\"color:#E1E4E8\">(inode.mode)) { </span><span style=\"color:#B392F0\">fs_unlock</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EISDIR; }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Handle O_TRUNC flag: truncate file to zero on open */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fi->flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> O_TRUNC) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_truncate</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, ino, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">fs_unlock</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Store inode number in file handle for fast access later */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fi->fh </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ino;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Set direct_io flag to bypass FUSE's page cache for this file.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Without this, FUSE caches file data in the kernel's page cache,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * which can serve stale reads if another process modifies the file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * directly. For our implementation, disable kernel-side page caching</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * to ensure reads always go through our fs_read() function.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Trade-off: disabling the kernel page cache means every read causes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * a call to our read callback. For read-heavy workloads, enabling the</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * cache (removing this line) dramatically improves performance.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fi->direct_io </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_unlock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * release â€” Called when the last reference to an open file is closed.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Note: \"release\" in FUSE means \"the last open file descriptor is closed.\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This is NOT called for every close(2) â€” only when the kernel's reference</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * count for this file drops to zero. Multiple opens of the same file by the</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * same process may result in only one release.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Here: flush any pending writes, clean up per-file state.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> myfs_release</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> fuse_file_info </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">fi</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)path;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_lock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* fsync the disk image to ensure all writes are durable.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * In production, you would do this selectively (only if file was written).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * fi->fh holds the inode number we stored in open(). */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fsync</span><span style=\"color:#E1E4E8\">(g_fs.fd);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)fi;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_unlock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<blockquote>\n<p><strong><code>open</code> vs <code>create</code> in FUSE</strong>: When a process calls <code>open(&quot;path&quot;, O_CREAT | O_WRONLY, 0644)</code>, FUSE will call the <code>create</code> callback if you have registered it, or fall back to calling <code>mknod</code> followed by <code>open</code> if you haven&#39;t. You MUST register <code>create</code> â€” if you omit it, <code>echo &quot;text&quot; &gt; file</code> will fail because the shell uses <code>O_CREAT</code>. The <code>mknod</code> fallback does not work correctly for regular files.</p>\n</blockquote>\n<h3 id=\"create-the-o_creat-path\"><code>create</code> â€” The O_CREAT Path</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * create â€” Create and open a file atomically.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Called when: open(O_CREAT | O_WRONLY), open(O_CREAT | O_RDWR),</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *              creat(2), fopen(\"w\"), echo > file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Must create the file AND open it. Store inode number in fi->fh.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * If the file already exists and O_EXCL is set, return -EEXIST.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> myfs_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">mode_t</span><span style=\"color:#FFAB70\"> mode</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        struct</span><span style=\"color:#E1E4E8\"> fuse_file_info </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">fi</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> parent_path</span><span style=\"color:#E1E4E8\">[PATH_MAX];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">name;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> split_path</span><span style=\"color:#E1E4E8\">(path, parent_path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(parent_path), </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_lock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Resolve parent directory */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> parent_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> resolve_path</span><span style=\"color:#E1E4E8\">(parent_path);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (parent_ino </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">fs_unlock</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> parent_ino; }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* If O_EXCL: fail if file already exists */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> parent_inode;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    read_inode</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)parent_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">parent_inode);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> existing </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dir_lookup</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">parent_inode, name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (existing </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (fi->flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> O_EXCL) { </span><span style=\"color:#B392F0\">fs_unlock</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EEXIST; }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* File exists, O_EXCL not set: open existing file */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        fi->fh </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)existing;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (fi->flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> O_TRUNC)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fs_truncate</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)existing, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fs_unlock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Get caller identity for ownership */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> fuse_context </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">ctx </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fuse_get_context</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Create the new file */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> new_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_create_file</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                  (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)parent_ino, name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                  (</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\">)(mode </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0</span><span style=\"color:#79B8FF\">777</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                  (</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\">)ctx->uid,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                  (</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\">)ctx->gid);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (new_ino </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">fs_unlock</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> new_ino; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fi->fh       </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)new_ino;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fi->direct_io </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Persist superblock (free counts changed) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> sb_buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(sb_buf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(sb_buf, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(g_fs.sb));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    write_block</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, sb_buf);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_unlock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"read-and-write-data-plane-callbacks\"><code>read</code> and <code>write</code> â€” Data Plane Callbacks</h3>\n<p>These are the most performance-critical callbacks. FUSE delivers <code>read</code> requests with a pre-allocated buffer; <code>write</code> requests with the data to write. Both use the inode number stored in <code>fi-&gt;fh</code> from <code>open</code>/<code>create</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * read â€” Read data from an open file.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * size: maximum bytes to return (FUSE may request up to 128KB at once)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * offset: byte offset within the file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns number of bytes actually read (may be less than size at EOF).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> myfs_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                      off_t</span><span style=\"color:#FFAB70\"> offset</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> fuse_file_info </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">fi</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)path;</span><span style=\"color:#6A737D\">   /* fi->fh has the inode number from open() */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (offset </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_lock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> nread </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_read</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                             (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)fi->fh,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                             (</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)offset, buf, size);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_unlock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)nread;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * write â€” Write data to an open file.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns number of bytes written (should always equal size â€” partial</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * writes indicate errors; FUSE will retry). Return negative errno on error.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> myfs_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                       off_t</span><span style=\"color:#FFAB70\"> offset</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> fuse_file_info </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">fi</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)path;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (offset </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_lock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> nwritten </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_write</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                 (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)fi->fh,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                 (</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)offset, buf, size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (nwritten </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Persist superblock (free block count may have changed) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint8_t</span><span style=\"color:#FFAB70\"> sb_buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memset</span><span style=\"color:#E1E4E8\">(sb_buf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memcpy</span><span style=\"color:#E1E4E8\">(sb_buf, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(g_fs.sb));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        write_block</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, sb_buf);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_unlock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)nwritten;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"mkdir-and-rmdir\"><code>mkdir</code> and <code>rmdir</code></h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> myfs_mkdir</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">mode_t</span><span style=\"color:#FFAB70\"> mode</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> parent_path</span><span style=\"color:#E1E4E8\">[PATH_MAX];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">name;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> split_path</span><span style=\"color:#E1E4E8\">(path, parent_path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(parent_path), </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_lock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> parent_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> resolve_path</span><span style=\"color:#E1E4E8\">(parent_path);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (parent_ino </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">fs_unlock</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> parent_ino; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> fuse_context </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">ctx </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fuse_get_context</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> new_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_mkdir</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                            (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)parent_ino, name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                            (</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\">)(mode </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0</span><span style=\"color:#79B8FF\">777</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                            (</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\">)ctx->uid,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                            (</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\">)ctx->gid);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (new_ino </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">fs_unlock</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> new_ino; }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Persist superblock */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> sb_buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(sb_buf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(sb_buf, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(g_fs.sb));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    write_block</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, sb_buf);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_unlock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> myfs_rmdir</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> parent_path</span><span style=\"color:#E1E4E8\">[PATH_MAX];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">name;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> split_path</span><span style=\"color:#E1E4E8\">(path, parent_path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(parent_path), </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_lock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> parent_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> resolve_path</span><span style=\"color:#E1E4E8\">(parent_path);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (parent_ino </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">fs_unlock</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> parent_ino; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_rmdir</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)parent_ino, name);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_unlock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"unlink-file-deletion\"><code>unlink</code> â€” File Deletion</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> myfs_unlink</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> parent_path</span><span style=\"color:#E1E4E8\">[PATH_MAX];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">name;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> split_path</span><span style=\"color:#E1E4E8\">(path, parent_path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(parent_path), </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_lock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> parent_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> resolve_path</span><span style=\"color:#E1E4E8\">(parent_path);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (parent_ino </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">fs_unlock</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> parent_ino; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_unlink</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)parent_ino, name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint8_t</span><span style=\"color:#FFAB70\"> sb_buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memset</span><span style=\"color:#E1E4E8\">(sb_buf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memcpy</span><span style=\"color:#E1E4E8\">(sb_buf, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(g_fs.sb));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        write_block</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, sb_buf);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_unlock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"truncate-resize-from-path\"><code>truncate</code> â€” Resize from Path</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> myfs_truncate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">off_t</span><span style=\"color:#FFAB70\"> new_size</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                           struct</span><span style=\"color:#E1E4E8\"> fuse_file_info </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">fi</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (new_size </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_lock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ino;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fi </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* fd-based truncate: fi->fh has inode number */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)fi->fh;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        r </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* path-based truncate */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        inode_t</span><span style=\"color:#E1E4E8\"> inode;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> path_to_inode</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_truncate</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, ino, (</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)new_size);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_unlock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"chmod-and-utimens-metadata-changes\"><code>chmod</code> and <code>utimens</code> â€” Metadata Changes</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> myfs_chmod</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">mode_t</span><span style=\"color:#FFAB70\"> mode</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                       struct</span><span style=\"color:#E1E4E8\"> fuse_file_info </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">fi</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)fi;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_lock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ino;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> path_to_inode</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">fs_unlock</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r; }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Replace permission bits; preserve file type bits */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode.mode </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (inode.mode </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> S_IFMT) </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> (mode </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0</span><span style=\"color:#79B8FF\">7777</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode.ctime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> write_inode</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_unlock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> myfs_utimens</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> timespec </span><span style=\"color:#FFAB70\">ts</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         struct</span><span style=\"color:#E1E4E8\"> fuse_file_info </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">fi</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)fi;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_lock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ino;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> path_to_inode</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">fs_unlock</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r; }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ts[0] = atime, ts[1] = mtime */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ts</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].tv_nsec </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> UTIME_OMIT)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        inode.atime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">ts</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].tv_sec;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ts</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">].tv_nsec </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> UTIME_OMIT)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        inode.mtime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">ts</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">].tv_sec;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inode.ctime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> write_inode</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_unlock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"rename-the-hardest-operation\"><code>rename</code>: The Hardest Operation</h2>\n<p><code>rename</code> is the most complex single operation in any filesystem. At the POSIX level, <code>rename(old, new)</code> must be <strong>atomic</strong>: any process that observes the filesystem either sees the old name or the new name, never a state where neither exists. This is a crash-consistency requirement even before Milestone 6&#39;s journal.\nThe implementation must handle four distinct cases:</p>\n<ol>\n<li><strong>Simple rename in the same directory</strong>: <code>rename(&quot;/home/user/a&quot;, &quot;/home/user/b&quot;)</code></li>\n<li><strong>Move to different directory</strong>: <code>rename(&quot;/home/user/a&quot;, &quot;/tmp/a&quot;)</code>  </li>\n<li><strong>Replace an existing file</strong>: <code>rename(&quot;/tmp/new&quot;, &quot;/tmp/old&quot;)</code> â€” <code>old</code> must be atomically replaced</li>\n<li><strong>Replace with a directory</strong>: the target must be an empty directory</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * rename â€” Move/rename a file or directory.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * POSIX guarantees: if new_path already exists, it is atomically replaced.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Without journaling, we approximate atomicity by careful write ordering:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   1. Write new directory entry pointing to the inode</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   2. Remove old directory entry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * If we crash between 1 and 2, the file has two names â€” detectable by fsck.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * If we crash after 2 but before 1... well, ordering prevents this.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * flags: RENAME_NOREPLACE (fail if new_path exists), RENAME_EXCHANGE (swap),</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *        etc. We implement only the basic rename (flags == 0).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> myfs_rename</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">old_path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">new_path</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        unsigned</span><span style=\"color:#F97583\"> int</span><span style=\"color:#FFAB70\"> flags</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (flags </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span><span style=\"color:#6A737D\">   /* RENAME_NOREPLACE etc. not implemented */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> old_parent</span><span style=\"color:#E1E4E8\">[PATH_MAX], </span><span style=\"color:#FFAB70\">new_parent</span><span style=\"color:#E1E4E8\">[PATH_MAX];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">old_name, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">new_name;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> split_path</span><span style=\"color:#E1E4E8\">(old_path, old_parent, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(old_parent), </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">old_name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> split_path</span><span style=\"color:#E1E4E8\">(new_path, new_parent, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(new_parent), </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">new_name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_lock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> old_parent_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> resolve_path</span><span style=\"color:#E1E4E8\">(old_parent);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (old_parent_ino </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">fs_unlock</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> old_parent_ino; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> new_parent_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> resolve_path</span><span style=\"color:#E1E4E8\">(new_parent);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (new_parent_ino </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">fs_unlock</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> new_parent_ino; }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Find the inode we're moving */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> old_parent_inode;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    read_inode</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)old_parent_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">old_parent_inode);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> src_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dir_lookup</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">old_parent_inode, old_name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (src_ino </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">fs_unlock</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> src_ino </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ?</span><span style=\"color:#E1E4E8\"> src_ino </span><span style=\"color:#F97583\">:</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOENT; }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> src_inode;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    read_inode</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)src_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">src_inode);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Check if new_path already exists */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> new_parent_inode;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    read_inode</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_parent_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">new_parent_inode);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> dst_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dir_lookup</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">new_parent_inode, new_name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (dst_ino </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* new_path exists: must atomically replace it */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        inode_t</span><span style=\"color:#E1E4E8\"> dst_inode;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        read_inode</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)dst_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dst_inode);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">S_ISDIR</span><span style=\"color:#E1E4E8\">(src_inode.mode) </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#B392F0\">S_ISDIR</span><span style=\"color:#E1E4E8\">(dst_inode.mode))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            { </span><span style=\"color:#B392F0\">fs_unlock</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTDIR; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">S_ISDIR</span><span style=\"color:#E1E4E8\">(src_inode.mode) </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#B392F0\"> S_ISDIR</span><span style=\"color:#E1E4E8\">(dst_inode.mode))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            { </span><span style=\"color:#B392F0\">fs_unlock</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EISDIR; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">S_ISDIR</span><span style=\"color:#E1E4E8\">(dst_inode.mode) </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#B392F0\">dir_is_empty</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dst_inode))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            { </span><span style=\"color:#B392F0\">fs_unlock</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTEMPTY; }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Remove the existing destination entry (freeing dst if nlinks â†’ 0) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">S_ISDIR</span><span style=\"color:#E1E4E8\">(dst_inode.mode))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_rmdir</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_parent_ino, new_name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_unlink</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_parent_ino, new_name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">fs_unlock</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r; }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Reload new_parent_inode as it may have changed */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        read_inode</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_parent_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">new_parent_inode);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 1: Add new entry in destination directory */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> ft </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> S_ISDIR</span><span style=\"color:#E1E4E8\">(src_inode.mode) </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> FT_DIR </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> FT_REG_FILE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dir_add_entry</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                      (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_parent_ino, new_name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                      (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)src_ino, ft);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">fs_unlock</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r; }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* If moving a directory, update its '..' entry to point to new parent */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">S_ISDIR</span><span style=\"color:#E1E4E8\">(src_inode.mode) </span><span style=\"color:#F97583\">&#x26;&#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)old_parent_ino </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_parent_ino) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Read src directory's data block, update '..' inode_num */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint8_t</span><span style=\"color:#FFAB70\"> dir_buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (src_inode.blocks[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            read_block</span><span style=\"color:#E1E4E8\">(g_fs.fd, src_inode.blocks[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], dir_buf) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* '..' is the second entry; find and update it */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            dirent_t</span><span style=\"color:#E1E4E8\"> dot;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint16_t</span><span style=\"color:#E1E4E8\"> dot_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dirent_read_from_buf</span><span style=\"color:#E1E4E8\">(dir_buf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dot);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (dot_len </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                dirent_t</span><span style=\"color:#E1E4E8\"> dotdot;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                dirent_read_from_buf</span><span style=\"color:#E1E4E8\">(dir_buf, dot_len, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dotdot);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                dotdot.inode_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_parent_ino;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                dirent_write_to_buf</span><span style=\"color:#E1E4E8\">(dir_buf, dot_len, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dotdot);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                write_block</span><span style=\"color:#E1E4E8\">(g_fs.fd, src_inode.blocks[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], dir_buf);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Old parent loses one '..' reference; new parent gains one */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        inode_t</span><span style=\"color:#E1E4E8\"> op_inode, np_inode;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        read_inode</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)old_parent_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">op_inode);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        read_inode</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_parent_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">np_inode);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (op_inode.nlinks </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) op_inode.nlinks</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        np_inode.nlinks</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        op_inode.ctime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> np_inode.ctime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        write_inode</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)old_parent_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">op_inode);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        write_inode</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_parent_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">np_inode);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 2: Remove old entry from source directory */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Use a lower-level removal that does NOT decrement src_ino's nlinks */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* (we're not deleting the file, just moving the directory entry) */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Temporarily increment nlinks to prevent free_inode on remove */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    src_inode.nlinks</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    write_inode</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)src_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">src_inode);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dir_remove_entry</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)old_parent_ino, old_name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* dir_remove_entry decremented nlinks; restore to correct value */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        read_inode</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)src_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">src_inode);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* nlinks is correct now: dir_remove_entry decremented by 1, which undoes our +1 */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        src_inode.ctime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        write_inode</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)src_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">src_inode);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Persist superblock */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> sb_buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(sb_buf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(sb_buf, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(g_fs.sb));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    write_block</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, sb_buf);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_unlock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<blockquote>\n<p><strong>Rename Atomicity Without a Journal</strong>: The write ordering above (add new entry â†’ remove old entry) guarantees that if you crash mid-rename, the file is accessible under at least one name. The worst case is the file having two names temporarily â€” a &quot;hard link&quot; that <code>fsck</code> can detect. Milestone 6&#39;s journal will make rename truly atomic: both operations are in one transaction, applied together or not at all.</p>\n</blockquote>\n<hr>\n<h2 id=\"concurrency-the-locking-model\">Concurrency: The Locking Model</h2>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m5-locking-strategy.svg\" alt=\"FUSE Concurrency â€” Lock Hierarchy and Critical Sections\"></p>\n<p>FUSE by default dispatches callbacks on multiple threads simultaneously. The <code>default_permissions</code> option handles POSIX permission checking in the kernel before your callback is invoked. You still need to protect your shared state.\n[[EXPLAIN:pthread-mutex-vs-rwlock-â€”-exclusive-vs-shared-locking-tradeoffs|pthread_mutex_t vs. pthread_rwlock_t â€” when to use exclusive locking vs. reader-writer locks]]\nThe three-tier locking model for a production FUSE filesystem:</p>\n<table>\n<thead>\n<tr>\n<th>Level</th>\n<th>Scope</th>\n<th>Mechanism</th>\n<th>When to use</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Global mutex (chosen âœ“)</strong></td>\n<td>All filesystem state</td>\n<td><code>pthread_mutex_t</code></td>\n<td>Correct, simple, sufficient for most workloads</td>\n</tr>\n<tr>\n<td><strong>Per-inode rwlock</strong></td>\n<td>Single inode&#39;s data + metadata</td>\n<td><code>pthread_rwlock_t</code></td>\n<td>High-concurrency reads; complex to implement correctly</td>\n</tr>\n<tr>\n<td><strong>Lock-free bitmaps</strong></td>\n<td>Block/inode allocation</td>\n<td>Atomic bit operations</td>\n<td>Highest performance; requires careful memory ordering</td>\n</tr>\n<tr>\n<td>For this milestone, the global mutex is correct and appropriate. The single lock serializes all filesystem operations, making your code trivially safe for concurrent access. The performance cost: concurrent <code>read</code> calls from two processes must take turns, even though they could theoretically proceed in parallel.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>The global lock is standard for FUSE implementations. Even the Linux ext4 filesystem uses per-filesystem locks for many operations. The key is that the lock is held only during your callback execution â€” disk I/O inside the callback holds the lock, which means a slow disk blocks other filesystem operations. A future optimization would use asynchronous I/O and release the lock while waiting for disk, but this requires a fundamentally different architecture.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Register a single-threaded FUSE with:</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> fuse_operations myfs_ops </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { ... };</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* In main(), when calling fuse_main: add \"-s\" to argv to force single-threaded mode */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Or explicitly use fuse_session_loop_mt() vs fuse_session_loop() */</span></span></code></pre></div>\n<p>For the initial implementation, single-threaded mode is recommended to eliminate concurrency bugs while you get the callbacks right. Enable multi-threading once all callbacks are working:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Force single-threaded FUSE for initial development */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Add \"-s\" to fuse args to disable multithreading */</span></span></code></pre></div>\n<hr>\n<h2 id=\"the-mountunmount-lifecycle\">The Mount/Unmount Lifecycle</h2>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m5-mount-unmount-lifecycle.svg\" alt=\"Mount/Unmount Lifecycle â€” State Machine\"></p>\n<p>Two callbacks control the filesystem&#39;s lifecycle: <code>init</code> (called once when FUSE is ready to serve requests) and <code>destroy</code> (called once when the filesystem unmounts). These are your constructors and destructors:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * init â€” Called when FUSE is ready to handle requests.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * conn: connection info (protocol version, capabilities).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * cfg:  FUSE configuration options (caching behavior, timeouts).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns a pointer passed to all subsequent callbacks as userdata.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * (We use global state instead, so return NULL.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">myfs_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> fuse_conn_info </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">conn</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        struct</span><span style=\"color:#E1E4E8\"> fuse_config </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">cfg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)conn;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * entry_timeout: how long the kernel caches \"name â†’ inode\" lookups.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Setting to 0 disables caching â€” correctness first.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Setting to 1.0 (1 second) dramatically speeds up repeated path lookups.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Trade-off: stale cache if another process modifies the filesystem</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * directly (not through FUSE). For our single-client model, 1.0 is safe.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cfg->entry_timeout </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cfg->attr_timeout  </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* how long to cache stat results */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cfg->negative_timeout </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.5</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* how long to cache ENOENT results */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cfg->use_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   /* use our inode numbers in readdir and getattr */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * destroy â€” Called when FUSE unmounts.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Flush all pending I/O to disk. Release all resources.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * After this returns, the disk image must be in a consistent state.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> myfs_destroy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">private_data</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)private_data;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_lock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Flush all dirty kernel page cache pages for our disk image to disk.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Without fsync here, recently written data may still be in the kernel's</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * page cache and lost if the system shuts down after unmount.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fsync</span><span style=\"color:#E1E4E8\">(g_fs.fd);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Persist the current superblock (free counts) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> sb_buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(sb_buf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(sb_buf, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(g_fs.sb));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    write_block</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, sb_buf);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Final fsync after superblock write */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fsync</span><span style=\"color:#E1E4E8\">(g_fs.fd);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(g_fs.fd);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_destroy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.lock);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_unlock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Note: do not call fs_unlock() after destroying the mutex */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<blockquote>\n<p><strong>Pitfall â€” Not fsyncing on Unmount</strong>: When you unmount a FUSE filesystem, the kernel calls your <code>destroy</code> callback. If you do not call <code>fsync(g_fs.fd)</code> before <code>close</code>, any data written by your callbacks but not yet flushed by the host kernel&#39;s writeback daemon is lost. The sequence is: your <code>myfs_write</code> â†’ host kernel page cache (dirty) â†’ eventual writeback â†’ disk. The writeback may not have happened by the time <code>destroy</code> is called. <code>fsync</code> forces the flush. This is especially important for the superblock â€” always write and fsync the superblock last, after all data blocks.</p>\n</blockquote>\n<hr>\n<h2 id=\"statfs-disk-space-reporting\"><code>statfs</code> â€” Disk Space Reporting</h2>\n<p><code>df</code> and <code>df -h</code> call <code>statfs</code> to report available disk space. Without it, standard tools cannot report how much space your filesystem has:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> myfs_statfs</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> statvfs </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">stbuf</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)path;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_lock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(stbuf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">stbuf));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stbuf->f_bsize   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE;</span><span style=\"color:#6A737D\">               /* filesystem block size */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stbuf->f_frsize  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE;</span><span style=\"color:#6A737D\">               /* fragment size (same) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stbuf->f_blocks  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> g_fs.sb.total_blocks </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> g_fs.sb.data_block_start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stbuf->f_bfree   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> g_fs.sb.free_blocks;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stbuf->f_bavail  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> g_fs.sb.free_blocks;</span><span style=\"color:#6A737D\">      /* no reserved blocks */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stbuf->f_files   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> g_fs.sb.total_inodes;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stbuf->f_ffree   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> g_fs.sb.free_inodes;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stbuf->f_favail  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> g_fs.sb.free_inodes;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stbuf->f_namemax </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> MAX_FILENAME_LEN;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_unlock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"wiring-everything-together-main-and-registration\">Wiring Everything Together: <code>main</code> and Registration</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * FUSE operations table.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Every NULL field uses FUSE's default behavior.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Explicitly NULL-ify operations you haven't implemented â€” don't leave</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * function pointers uninitialized (they point to garbage in C).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> fuse_operations myfs_ops </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .init       </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> myfs_init,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .destroy    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> myfs_destroy,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .getattr    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> myfs_getattr,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .readdir    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> myfs_readdir,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .open       </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> myfs_open,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .create     </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> myfs_create,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .read       </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> myfs_read,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .write      </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> myfs_write,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .release    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> myfs_release,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .mkdir      </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> myfs_mkdir,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .rmdir      </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> myfs_rmdir,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .unlink     </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> myfs_unlink,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .rename     </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> myfs_rename,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .truncate   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> myfs_truncate,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .chmod      </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> myfs_chmod,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .utimens    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> myfs_utimens,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .statfs     </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> myfs_statfs,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Not implemented in this milestone: */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .link       </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">   /* hard links: call fs_link from Milestone 3 */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .symlink    </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">   /* symbolic links: future extension */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .readlink   </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .mknod      </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">   /* we use create instead */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .chown      </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">   /* future: update uid/gid */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .flush      </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .fsync      </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * main â€” Mount the filesystem.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Usage: ./myfs &#x3C;disk_image> &#x3C;mountpoint> [fuse options]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Example: ./myfs disk.img /mnt/myfs -f -d   (-f foreground, -d debug)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *          ./myfs disk.img /mnt/myfs -s       (-s single-threaded)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * We consume the first argument (disk_image) ourselves; the rest</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * are passed to fuse_main.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#F97583\">[]</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (argc </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Usage: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> &#x3C;disk_image> &#x3C;mountpoint> [fuse options]</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">image_path </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Remove disk_image from argv so fuse_main sees only its own args */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* argv[0] = program name, argv[1] = image_path, argv[2..] = fuse args */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    argc</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">   /* shift: argv[0]=program, argv[1]=mountpoint, ... */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    argv</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Open the disk image */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    g_fs.fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(image_path, O_RDWR);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (g_fs.fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"open disk image\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Read and validate the superblock */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> sb_buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, sb_buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Failed to read superblock</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(g_fs.fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb, sb_buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(g_fs.sb));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (g_fs.sb.magic </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> FS_MAGIC) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Invalid filesystem magic: 0x</span><span style=\"color:#79B8FF\">%08X</span><span style=\"color:#9ECBFF\"> (expected 0x</span><span style=\"color:#79B8FF\">%08X</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                g_fs.sb.magic, FS_MAGIC);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(g_fs.fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Initialize the global mutex */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">pthread_mutex_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.lock, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"pthread_mutex_init\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(g_fs.fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    strncpy</span><span style=\"color:#E1E4E8\">(g_fs.image_path, image_path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(g_fs.image_path) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Mounting </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, image_path);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Total blocks: </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\">, Free blocks: </span><span style=\"color:#79B8FF\">%u\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           g_fs.sb.total_blocks, g_fs.sb.free_blocks);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Total inodes: </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\">, Free inodes: </span><span style=\"color:#79B8FF\">%u\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           g_fs.sb.total_inodes, g_fs.sb.free_inodes);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Hand off to FUSE */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> fuse_main</span><span style=\"color:#E1E4E8\">(argc, argv, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">myfs_ops, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"the-ls-la-trace-what-actually-happens\">The <code>ls -la</code> Trace: What Actually Happens</h2>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m5-ls-trace.svg\" alt=\"'ls -la /mnt/myfs/home' â€” Complete Syscall-to-Block Trace\"></p>\n<p>Let&#39;s trace exactly what happens when you run <code>ls -la /mnt/myfs/home</code> against your mounted filesystem. This is the Three-Level View in full operation:</p>\n<table>\n<thead>\n<tr>\n<th>Step</th>\n<th>POSIX Syscall</th>\n<th>FUSE Callback</th>\n<th>Your Code</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td><code>stat(&quot;/mnt/myfs/home&quot;)</code></td>\n<td><code>getattr(&quot;/home&quot;)</code></td>\n<td><code>path_resolve</code> â†’ dir_lookup in root â†’ read inode 14 â†’ <code>inode_to_stat</code></td>\n</tr>\n<tr>\n<td>2</td>\n<td><code>opendir(&quot;/mnt/myfs/home&quot;)</code></td>\n<td><code>opendir</code> (handled by libfuse)</td>\n<td>â€”</td>\n</tr>\n<tr>\n<td>3</td>\n<td><code>readdir(dir)</code> â†’ first batch</td>\n<td><code>readdir(&quot;/home&quot;)</code></td>\n<td><code>dir_readdir</code> â†’ scan blocks â†’ <code>filler(&quot;.&quot;, ...), filler(&quot;user&quot;, ...)</code></td>\n</tr>\n<tr>\n<td>4</td>\n<td>For each entry name: <code>lstat(&quot;/mnt/myfs/home/user&quot;)</code></td>\n<td><code>getattr(&quot;/home/user&quot;)</code></td>\n<td><code>path_resolve(&quot;/home/user&quot;)</code> â†’ 2 dir lookups â†’ read inode â†’ <code>inode_to_stat</code></td>\n</tr>\n<tr>\n<td>5</td>\n<td>Repeat step 4 for every entry</td>\n<td>â€”</td>\n<td>â€”</td>\n</tr>\n<tr>\n<td>The critical insight: <code>ls -la</code> calls <code>getattr</code> <strong>once per entry in the directory</strong>, plus once for the directory itself. A directory with 100 entries generates 101 <code>getattr</code> calls. Each <code>getattr</code> call, cold, costs 3+ disk reads for path resolution. With the <code>attr_timeout</code> cache set to 1.0 second, the second <code>ls</code> on the same directory costs only ~1Î¼s per entry (all cache hits).</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Hardware Soul â€” The Context Switch Cost</strong>\nEach FUSE callback involves two context switches: kernelâ†’user (FUSE module writes request to /dev/fuse) and userâ†’kernel (your process writes response back). A context switch on modern x86-64 costs ~2,000â€“5,000 CPU cycles, or ~1â€“2.5Î¼s at 2GHz. For a <code>getattr</code> that hits the inode cache (100ns disk read from page cache), the context switch dominates: the round-trip is ~3Î¼s, of which 2Î¼s is context-switch overhead and only 0.1Î¼s is actual work. This is why FUSE adds latency per-operation rather than per-byte: the overhead is constant per call, not proportional to data size.</p>\n</blockquote>\n<hr>\n<h2 id=\"building-and-mounting-your-first-real-mount\">Building and Mounting: Your First Real Mount</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Step 1: Format a 16MB disk image with 1024 inodes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./mkfs</span><span style=\"color:#9ECBFF\"> disk.img</span><span style=\"color:#79B8FF\"> 4096</span><span style=\"color:#79B8FF\"> 1024</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Step 2: Create a mount point</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#9ECBFF\"> /tmp/myfs_mount</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Step 3: Mount (foreground mode with debug output)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./myfs</span><span style=\"color:#9ECBFF\"> disk.img</span><span style=\"color:#9ECBFF\"> /tmp/myfs_mount</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#79B8FF\"> -d</span><span style=\"color:#79B8FF\"> -s</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># In another terminal:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Step 4: Test with standard Unix tools</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /tmp/myfs_mount/</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#9ECBFF\"> /tmp/myfs_mount/testdir</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Hello, Filesystem!\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /tmp/myfs_mount/testdir/hello.txt</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /tmp/myfs_mount/testdir/hello.txt</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cp</span><span style=\"color:#9ECBFF\"> /etc/hosts</span><span style=\"color:#9ECBFF\"> /tmp/myfs_mount/hosts_copy</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /tmp/myfs_mount/</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Step 5: Unmount</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">fusermount3</span><span style=\"color:#79B8FF\"> -u</span><span style=\"color:#9ECBFF\"> /tmp/myfs_mount</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Step 6: Verify persistence â€” remount and check data survived</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./myfs</span><span style=\"color:#9ECBFF\"> disk.img</span><span style=\"color:#9ECBFF\"> /tmp/myfs_mount</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /tmp/myfs_mount/testdir/hello.txt</span><span style=\"color:#6A737D\">  # Must print \"Hello, Filesystem!\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">fusermount3</span><span style=\"color:#79B8FF\"> -u</span><span style=\"color:#9ECBFF\"> /tmp/myfs_mount</span></span></code></pre></div>\n<p>The <code>-f</code> flag runs FUSE in the foreground (so you see debug output and can Ctrl+C to unmount). The <code>-d</code> flag enables verbose FUSE debugging showing every callback invocation. The <code>-s</code> flag enforces single-threaded mode â€” essential while debugging.\nIf anything fails, FUSE&#39;s debug output shows exactly which callback returned which error. Common failures and their causes:</p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Callback</th>\n<th>Likely Cause</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ls: cannot access &#39;/mnt&#39;: Transport endpoint is not connected</code></td>\n<td>â€”</td>\n<td>Previous mount crashed; run <code>fusermount3 -u /mnt</code> first</td>\n</tr>\n<tr>\n<td><code>ls</code> shows nothing, no error</td>\n<td><code>readdir</code></td>\n<td><code>filler</code> not called for <code>.</code> and <code>..</code>; or <code>getattr</code> returning wrong mode</td>\n</tr>\n<tr>\n<td><code>cat</code> returns empty</td>\n<td><code>read</code></td>\n<td><code>fs_read</code> returning 0 before EOF; check offset clamping</td>\n</tr>\n<tr>\n<td><code>echo &gt; file</code> succeeds but data lost on remount</td>\n<td><code>write</code>/<code>destroy</code></td>\n<td>Not fsyncing disk image in <code>destroy</code></td>\n</tr>\n<tr>\n<td><code>cp</code> into mount returns <code>ENOSPC</code></td>\n<td><code>write</code>/<code>create</code></td>\n<td><code>alloc_block</code> returning -1; check bitmap and free block count</td>\n</tr>\n<tr>\n<td><code>mkdir</code> succeeds but <code>ls</code> shows wrong permissions</td>\n<td><code>getattr</code></td>\n<td><code>inode_to_stat</code> not copying <code>st_mode</code> correctly</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"integration-test-suite\">Integration Test Suite</h2>\n<p>Write a shell script that exercises every FUSE callback through real Unix tool invocations:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">#!/bin/bash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># test_fuse.sh â€” Integration test for FUSE-mounted filesystem</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">set</span><span style=\"color:#79B8FF\"> -euo</span><span style=\"color:#9ECBFF\"> pipefail</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">DISK</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"./test_disk.img\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">MOUNT</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"./test_mount\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">FS</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"./myfs\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">MKFS</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"./mkfs\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cleanup</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fusermount3</span><span style=\"color:#79B8FF\"> -u</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    rm</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$DISK</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    rmdir</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">trap</span><span style=\"color:#9ECBFF\"> cleanup</span><span style=\"color:#9ECBFF\"> EXIT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Setup</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">$MKFS </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">$DISK</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> 4096 1024</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">$FS </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">$DISK</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> -s &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">FUSE_PID</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">$!</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sleep</span><span style=\"color:#79B8FF\"> 0.5</span><span style=\"color:#6A737D\">   # Wait for FUSE to be ready</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"=== FUSE Integration Tests ===\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 1: Root directory accessible</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/null</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"OK: root directory accessible\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 2: mkdir and ls</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/testdir\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> \"testdir\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/null</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"OK: mkdir creates directory visible to ls\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 3: File creation and write</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Hello, Filesystem!\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/testdir/hello.txt\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"OK: echo > file works\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 4: File read</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">CONTENT</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/testdir/hello.txt\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">[ </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">$CONTENT</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"Hello, Filesystem!\"</span><span style=\"color:#E1E4E8\"> ]</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"OK: cat reads correct content\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 5: File permissions</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">chmod</span><span style=\"color:#79B8FF\"> 0600</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/testdir/hello.txt\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">PERMS</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#79B8FF\">stat</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"%a\"</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/testdir/hello.txt\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">[ </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">$PERMS</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"600\"</span><span style=\"color:#E1E4E8\"> ]</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"OK: chmod works\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 6: cp into mount</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cp</span><span style=\"color:#9ECBFF\"> /etc/hostname</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/hostname_copy\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">diff</span><span style=\"color:#9ECBFF\"> /etc/hostname</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/hostname_copy\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"OK: cp works, content matches\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 7: Large file (multi-block)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dd</span><span style=\"color:#9ECBFF\"> if=/dev/urandom</span><span style=\"color:#9ECBFF\"> of=/tmp/test_large</span><span style=\"color:#9ECBFF\"> bs=</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#9ECBFF\"> count=</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\">/dev/null</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cp</span><span style=\"color:#9ECBFF\"> /tmp/test_large</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/large_file\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">diff</span><span style=\"color:#9ECBFF\"> /tmp/test_large</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/large_file\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"OK: large file (400KB) round-trip correct\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">rm</span><span style=\"color:#9ECBFF\"> /tmp/test_large</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 8: rename</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mv</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/testdir/hello.txt\"</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/testdir/renamed.txt\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">[ </span><span style=\"color:#F97583\">!</span><span style=\"color:#F97583\"> -e</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/testdir/hello.txt\"</span><span style=\"color:#E1E4E8\"> ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">CONTENT</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/testdir/renamed.txt\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">[ </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">$CONTENT</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"Hello, Filesystem!\"</span><span style=\"color:#E1E4E8\"> ]</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"OK: rename works\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 9: rmdir</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/emptydir\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">rmdir</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/emptydir\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">[ </span><span style=\"color:#F97583\">!</span><span style=\"color:#F97583\"> -e</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/emptydir\"</span><span style=\"color:#E1E4E8\"> ]</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"OK: rmdir works\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 10: unlink</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">rm</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/testdir/renamed.txt\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">[ </span><span style=\"color:#F97583\">!</span><span style=\"color:#F97583\"> -e</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/testdir/renamed.txt\"</span><span style=\"color:#E1E4E8\"> ]</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"OK: rm (unlink) works\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 11: df reports reasonable values</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">df</span><span style=\"color:#79B8FF\"> -h</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> Filesystem</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/null</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"OK: statfs/df works\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 12: Unmount and remount â€” data must persist</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">fusermount3</span><span style=\"color:#79B8FF\"> -u</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">wait</span><span style=\"color:#E1E4E8\"> $FUSE_PID </span><span style=\"color:#F97583\">2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">$FS </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">$DISK</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> -s &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">FUSE_PID</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">$!</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sleep</span><span style=\"color:#79B8FF\"> 0.5</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">HOSTNAME_CONTENT</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/hostname_copy\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">[ </span><span style=\"color:#F97583\">-n</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$HOSTNAME_CONTENT</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> ]</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"OK: data persists across unmount/remount\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">fusermount3</span><span style=\"color:#79B8FF\"> -u</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">wait</span><span style=\"color:#E1E4E8\"> $FUSE_PID </span><span style=\"color:#F97583\">2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"=== All Integration Tests Passed ===\"</span></span></code></pre></div>\n<hr>\n<h2 id=\"three-level-view-one-open-syscall\">Three-Level View: One <code>open()</code> Syscall</h2>\n<p>Let&#39;s trace <code>open(&quot;/mnt/myfs/home/user/file.txt&quot;, O_RDONLY)</code> from application through hardware:</p>\n<table>\n<thead>\n<tr>\n<th>Level</th>\n<th>What Happens</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Application</strong></td>\n<td>Calls <code>open(2)</code> syscall. CPU switches to kernel mode via syscall interrupt.</td>\n</tr>\n<tr>\n<td><strong>OS / Kernel VFS</strong></td>\n<td><code>do_sys_open()</code> â†’ <code>file_open_name()</code> â†’ <code>path_openat()</code>. VFS walks the mount table: <code>/mnt/myfs</code> is a FUSE mount. Hands off to the FUSE kernel module. FUSE module serializes: opcode=<code>LOOKUP</code> for each path component, queued to <code>/dev/fuse</code>. Blocks waiting.</td>\n</tr>\n<tr>\n<td><strong>Your Process</strong></td>\n<td>libfuse reads from <code>/dev/fuse</code>. Dispatches to <code>getattr(&quot;/home/user/file.txt&quot;)</code>. Your <code>myfs_getattr</code> calls <code>path_resolve</code> â†’ 3 directory block reads â†’ inode read. Returns <code>struct stat</code>. libfuse serializes response, writes to <code>/dev/fuse</code>.</td>\n</tr>\n<tr>\n<td><strong>Kernel again</strong></td>\n<td>FUSE module receives response. VFS gets the file&#39;s inode attributes. Constructs a <code>struct file</code> kernel object. Returns the file descriptor integer to the calling process.</td>\n</tr>\n<tr>\n<td><strong>Hardware</strong></td>\n<td>For cold-cache directory reads: 4 Ã— 100Î¼s SSD reads = 400Î¼s. Page cache fill: DMA transfer from SSD to kernel memory. For warm-cache: 4 Ã— 100ns = 400ns.</td>\n</tr>\n<tr>\n<td>The total latency for a warm-cache <code>open</code> through FUSE: ~3â€“5Î¼s (two context switches) + ~400ns (cache hits) â‰ˆ <strong>4Î¼s</strong>. For comparison, <code>open</code> on a native ext4 file: ~1â€“2Î¼s (one kernel-level path walk, no context switch). The FUSE overhead is 2â€“4Ã— for latency-sensitive operations.</td>\n<td></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"knowledge-cascade-one-fuse-mount-ten-worlds\">Knowledge Cascade: One FUSE Mount, Ten Worlds</h2>\n<h3 id=\"vfs-as-universal-contract-ext4-xfs-nfs-your-filesystem\">VFS as Universal Contract: ext4, XFS, NFS, Your Filesystem</h3>\n<p>The VFS layer you have just implemented against (via FUSE) is the same interface that every Linux filesystem implements. ext4, XFS, tmpfs, procfs, sysfs, and NFS all register <code>inode_operations</code> and <code>file_operations</code> function pointers with the VFS. FUSE simply adds a forwarding layer that sends those calls to userspace instead of handling them in-kernel.\nThis means: everything you built in this milestone â€” the callback signatures, the error codes, the <code>struct stat</code> semantics, the <code>rename</code> atomicity requirement â€” reflects the VFS contract. When you read the ext4 source code (<code>fs/ext4/file.c</code>, <code>fs/ext4/dir.c</code>), you will see the same function signatures: <code>ext4_file_read_iter</code>, <code>ext4_readdir</code>, <code>ext4_create</code>, <code>ext4_rename</code>. The difference is that ext4&#39;s implementations directly manipulate kernel data structures while yours calls across a process boundary. The interface is identical.\nThis knowledge unlocks reading kernel filesystem source code with clarity. The VFS is not a mystery; it is a well-defined interface that you have now implemented.\n[[EXPLAIN:linux-vfs-inode-operations-struct-â€”-the-kernel-interface-every-filesystem-implements|Linux VFS inode_operations struct â€” the complete list of function pointers every kernel filesystem must implement]]</p>\n<h3 id=\"microkernel-architecture-inside-a-monolithic-kernel\">Microkernel Architecture Inside a Monolithic Kernel</h3>\n<p>FUSE is a microkernel pattern embedded inside Linux&#39;s monolithic kernel. In a pure microkernel (QNX, Minix, L4), all device drivers, filesystems, and services run as separate userspace processes communicating via message passing. The kernel provides only IPC, scheduling, and memory management. Everything else â€” including the filesystem â€” is a userspace server.\nLinux chose the monolithic design for performance: fewer context switches, shared address space, faster function calls. But FUSE grafts the microkernel pattern onto it for filesystems specifically, trading the 2â€“5Î¼s per-operation overhead for:</p>\n<ul>\n<li><strong>Crash safety</strong>: a bug in your filesystem crashes your process, not the kernel. No kernel panic, no system crash, no reboot required.</li>\n<li><strong>Language freedom</strong>: FUSE filesystems can be written in Python, Go, Rust, Java â€” anything with a <code>/dev/fuse</code> binding. sshfs was originally written in C but go-fuse enables Go implementations.</li>\n<li><strong>Development velocity</strong>: modify your filesystem, kill the old process, mount again. No kernel module recompilation, no <code>insmod</code>/<code>rmmod</code>, no risk of hanging the kernel during development.\nThis is the exact trade-off that separates QNX (used in automotive safety systems â€” a crash cannot take down the OS) from early Linux (maximum performance â€” filesystem bugs can kernel-panic). FUSE gives Linux the microkernel safety property for filesystem development specifically.</li>\n</ul>\n<h3 id=\"grpc-and-ipc-fuse-is-an-rpc-system\">gRPC and IPC: FUSE is an RPC System</h3>\n<p>[[EXPLAIN:rpc-protocol-â€”-remote-procedure-call-serialization-and-dispatch-over-a-channel|RPC protocol â€” serializing a function call with arguments into bytes, sending over a channel, and deserializing the response]]\nThe <code>/dev/fuse</code> protocol is an RPC system. When the kernel dispatches <code>getattr(&quot;/home/user/file.txt&quot;)</code>, it serializes the request into a binary message:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>[unique_id: uint64] [opcode: uint32=FUSE_GETATTR] [len: uint32] [nodeid: uint64] [path: bytes]</code></pre></div>\n<p>Your process reads this message, dispatches based on <code>opcode</code>, executes the handler, and serializes the response:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>[unique_id: uint64 (matches request)] [error: int32=0] [attr: struct fuse_attr]</code></pre></div>\n<p>This is structurally identical to gRPC: a client (kernel) serializes a request with a unique ID, sends it over a channel (/dev/fuse â†” network socket), a server (your process) deserializes and handles it, returns a response with the matching ID. The FUSE protocol uses binary encoding (like Protocol Buffers in gRPC); the flow control (one outstanding request per &quot;session&quot;) is simpler than gRPC&#39;s multiplexing, but the pattern is identical.\nUnderstanding FUSE as an RPC system means understanding why latency-sensitive FUSE operations have a fixed overhead: two message serializations and two context switches per call, regardless of data size. This is the same overhead that makes gRPC unsuitable for high-frequency, low-payload calls (where Protocol Buffers serialization overhead dominates over per-byte cost).</p>\n<h3 id=\"thread-safety-as-a-first-class-design-concern\">Thread Safety as a First-Class Design Concern</h3>\n<p>Your global <code>pthread_mutex_t</code> is your first production-grade use of concurrent locking in this project. The patterns you applied here â€” acquire-before-access, release-before-return, covering all code paths including error paths â€” are the same patterns used in every concurrent system.\nThe classic pitfall you avoided: returning early from a callback without releasing the lock:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* BUG: lock never released if path_to_inode returns early */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> myfs_getattr_BUGGY</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> stat </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">st</span><span style=\"color:#E1E4E8\">, ...) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_lock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ino;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> path_to_inode</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r;</span><span style=\"color:#6A737D\">   /* â† DEADLOCK: lock never released */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ... */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_unlock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* CORRECT: always release before return */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> myfs_getattr_CORRECT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> stat </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">st</span><span style=\"color:#E1E4E8\">, ...) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_lock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ino;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> path_to_inode</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">fs_unlock</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r; }</span><span style=\"color:#6A737D\">   /* â† unlock on error path */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ... */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_unlock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>This pattern â€” &quot;unlock on every exit path&quot; â€” is what C++ RAII (<code>std::lock_guard</code>), Rust&#39;s <code>MutexGuard</code>, and Go&#39;s <code>defer mu.Unlock()</code> automate. In C, you must discipline yourself to write <code>fs_unlock()</code> before every <code>return</code>. This is a real reason why systems programming in C is error-prone: the compiler does not enforce lock pairing.\nThe alternative you should know about for future optimization: <strong>per-inode reader-writer locks</strong>. Reads from different files can proceed concurrently (multiple readers share the rwlock), but a write to any file still needs exclusive access to that file&#39;s inode. The global mutex forces all operations to serialize, even two concurrent reads of completely unrelated files. A <code>pthread_rwlock_t</code> per inode eliminates this unnecessary serialization. The complexity cost: lock ordering (always acquire parent-directory lock before child-inode lock), deadlock detection, and the overhead of N mutexes instead of 1.</p>\n<h3 id=\"path-resolution-as-the-performance-bottleneck\">Path Resolution as the Performance Bottleneck</h3>\n<p>Every FUSE callback starts with a path-to-inode translation. For a filesystem mounted at <code>/mnt/myfs</code>, a 5-component path like <code>/home/user/projects/src/main.c</code> requires 5 directory lookups, each requiring:</p>\n<ol>\n<li>Read the inode for the current directory (1 block read)</li>\n<li>Read the data block(s) of that directory and scan entries (1+ block reads)\nThat is 10+ disk reads per path resolution, cold. With the page cache warm, it drops to 10+ memory reads (~1Î¼s total). With the FUSE <code>entry_timeout</code> cache set to 1.0 second, the kernel caches the translation and your callback is not invoked at all for subsequent lookups within the timeout window.\nThis is why profiling always points to <code>path_resolve</code> as the hottest function. The optimization path is:</li>\n<li><strong>FUSE entry/attr timeouts</strong> (already implemented above): free, effective for repeated accesses</li>\n<li><strong>In-process path cache</strong>: a hash map <code>(path_string â†’ inode_number)</code> in your process memory, consulted before calling <code>path_resolve</code>. Invalidate on any write operation.</li>\n<li><strong>Inode-number-based API</strong>: libfuse&#39;s &quot;low-level&quot; API works with inode numbers directly, similar to how the kernel VFS works internally. This requires implementing <code>lookup</code> (returns inode number for a name in a parent) instead of path-based <code>getattr</code>. The kernel caches these lookup results in the dcache and passes inode numbers in subsequent calls, eliminating repeated path walks.\nThe low-level FUSE API (<code>fuse_lowlevel.h</code>) is the production path for performance-critical filesystems. It mirrors the kernel&#39;s VFS interface exactly: every call carries a parent inode number and a name, not a full path. GlusterFS, the Ceph FUSE client, and most high-performance FUSE filesystems use the low-level API. The high-level API (what we implemented) is simpler to write but sacrifices this optimization.</li>\n</ol>\n<hr>\n<h2 id=\"before-you-move-on-pitfall-checklist\">Before You Move On: Pitfall Checklist</h2>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> <strong><code>getattr</code> on root works</strong>: Run <code>ls /mnt/myfs</code> with no files. It must work. <code>getattr(&quot;/&quot;)</code> must return the root inode&#39;s <code>struct stat</code> with <code>st_mode = S_IFDIR | 0755</code> and <code>st_nlink &gt;= 2</code>. If this fails, nothing else will.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong><code>create</code> registered, not <code>mknod</code></strong>: Shell redirection (<code>echo &gt; file</code>) calls <code>open(O_CREAT)</code> which FUSE dispatches to <code>create</code>. Register <code>myfs_ops.create</code>. If it&#39;s NULL, file creation silently fails.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong><code>readdir</code> emits <code>.</code> and <code>..</code></strong>: Some tools (Python&#39;s <code>os.listdir</code>, <code>find</code>) depend on <code>.</code> and <code>..</code> being in the readdir output. Your <code>dir_readdir</code> emits them because they are real directory entries â€” verify with <code>ls -a</code>.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong><code>fi-&gt;fh</code> stores inode number in <code>open</code>/<code>create</code></strong>: Your <code>read</code> and <code>write</code> callbacks use <code>(uint32_t)fi-&gt;fh</code> as the inode number. Verify that <code>fi-&gt;fh</code> is set correctly in <code>open</code> and <code>create</code>. A zero value means you forgot to set it and <code>read</code>/<code>write</code> will operate on inode 0 (invalid).</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong><code>fsync</code> in <code>destroy</code></strong>: Unmounting without <code>fsync(g_fs.fd)</code> can lose recently written data. Test by writing a file, unmounting immediately, and remounting â€” data must be present.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Lock on every code path</strong>: Every callback that accesses <code>g_fs</code> must call <code>fs_lock()</code> at entry and <code>fs_unlock()</code> before every <code>return</code>. Run with <code>-s</code> (single-threaded) first to verify correctness, then remove <code>-s</code> and stress test with concurrent <code>cp</code> commands to verify thread safety.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Magic number validation in <code>main</code></strong>: Verify <code>g_fs.sb.magic == FS_MAGIC</code> before mounting. A typo in the image path that points to a random file would otherwise mount garbage as a filesystem, causing confusing crashes in every callback.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong><code>rename</code> handles same-directory rename</strong>: <code>rename(&quot;/a&quot;, &quot;/b&quot;)</code> has <code>old_parent == new_parent</code>. Your implementation must handle this case without double-locking or corrupting the parent directory.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>FUSE options <code>-f -s</code> for development</strong>: Always develop with <code>-f</code> (foreground) so Ctrl+C unmounts cleanly, and <code>-s</code> (single-threaded) to eliminate concurrency issues while debugging. Add <code>-d</code> for verbose callback tracing.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong><code>fusermount3 -u</code> on crashed mount</strong>: If your process crashes without unmounting, the mount point is left in a broken state. Running <code>./myfs disk.img /mnt -f</code> again fails with &quot;Transport endpoint is not connected.&quot; Always <code>fusermount3 -u /mnt</code> before remounting after a crash.</li>\n</ul>\n<hr>\n<h2 id=\"what-you39ve-built-and-what-comes-next\">What You&#39;ve Built and What Comes Next</h2>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-L0-satellite-map.svg\" alt=\"Filesystem Atlas â€” Satellite Map (Home Base)\"></p>\n<h2 id=\"you-have-crossed-the-final-boundary-between-quotlibraryquot-and-quotoperating-system-componentquot-your-filesystem-is-now-a-real-mount-point-standard-unix-tools-ls-cat-cp-find-grep-vim-work-against-it-without-modification-without-knowing-your-code-exists-the-vfs-contract-is-satisfied-the-fuse-relay-is-wired-the-entire-stack-from-user-application-through-kernel-vfs-through-fuse-through-your-c-code-through-block-level-io-runs-seamlessly-but-there-is-a-crack-in-the-foundation-and-you-have-known-about-it-since-milestone-1-every-write-to-your-filesystem-is-a-race-condition-not-a-concurrency-race-a-time-race-against-power-failure-consider-echo-quotcritical-dataquot-gt-mntmyfsimportanttxt-calls-your-create-callback-which-writes-the-block-bitmap-the-inode-and-the-directory-entry-in-three-separate-disk-operations-if-power-fails-between-the-bitmap-write-and-the-inode-write-you-have-a-leaked-block-that-the-bitmap-marks-as-used-but-no-inode-references-if-power-fails-between-the-inode-write-and-the-directory-entry-write-you-have-an-orphaned-inode-that-no-path-can-reach-if-power-fails-during-the-rename-you-just-implemented-after-adding-the-new-entry-but-before-removing-the-old-one-you-have-a-file-with-two-names-in-all-these-cases-after-a-reboot-your-filesystem-is-in-an-inconsistent-state-the-data-blocks-may-be-intact-but-the-metadata-bitmaps-inode-table-directory-entries-is-incoherent-fsck-can-repair-some-of-these-by-brute-force-scanning-all-blocks-and-reconstructing-consistent-metadata-but-that-takes-minutes-on-a-large-filesystem-and-sometimes-loses-data-milestone-6-solves-this-definitively-with-write-ahead-journaling-every-multi-step-operation-is-wrapped-in-a-transaction-write-all-changes-to-a-sequential-journal-region-first-write-a-commit-record-atomically-then-apply-the-changes-to-the-primary-data-structures-on-crash-scan-the-journal-replay-all-committed-transactions-discard-incomplete-ones-the-filesystem-is-always-consistent-after-recovery-not-just-quotrecoverablequot-but-guaranteed-consistent-by-the-structure-of-the-write-protocol-the-filesystem-is-almost-production-ready-one-milestone-remains\">You have crossed the final boundary between &quot;library&quot; and &quot;operating system component.&quot; Your filesystem is now a real mount point. Standard Unix tools â€” <code>ls</code>, <code>cat</code>, <code>cp</code>, <code>find</code>, <code>grep</code>, <code>vim</code> â€” work against it without modification, without knowing your code exists. The VFS contract is satisfied. The FUSE relay is wired. The entire stack from user application through kernel VFS through FUSE through your C code through block-level I/O runs seamlessly.\nBut there is a crack in the foundation, and you have known about it since Milestone 1. Every write to your filesystem is a race condition. Not a concurrency race â€” a <strong>time race</strong> against power failure. Consider: <code>echo &quot;critical data&quot; &gt; /mnt/myfs/important.txt</code> calls your <code>create</code> callback, which writes the block bitmap, the inode, and the directory entry in three separate disk operations. If power fails between the bitmap write and the inode write, you have a leaked block that the bitmap marks as used but no inode references. If power fails between the inode write and the directory entry write, you have an orphaned inode that no path can reach. If power fails during the <code>rename</code> you just implemented â€” after adding the new entry but before removing the old one â€” you have a file with two names.\nIn all these cases, after a reboot, your filesystem is in an inconsistent state. The data blocks may be intact, but the metadata â€” bitmaps, inode table, directory entries â€” is incoherent. <code>fsck</code> can repair some of these by brute-force scanning all blocks and reconstructing consistent metadata, but that takes minutes on a large filesystem and sometimes loses data.\nMilestone 6 solves this definitively with <strong>write-ahead journaling</strong>. Every multi-step operation is wrapped in a transaction: write all changes to a sequential journal region first, write a commit record atomically, then apply the changes to the primary data structures. On crash: scan the journal, replay all committed transactions, discard incomplete ones. The filesystem is always consistent after recovery â€” not just &quot;recoverable,&quot; but <strong>guaranteed consistent</strong> by the structure of the write protocol.\nThe filesystem is almost production-ready. One milestone remains.</h2>\n<!-- END_MS -->\n\n\n<!-- MS_ID: filesystem-m6 -->\n<!-- MS_ID: filesystem-m6 -->\n<h1 id=\"milestone-6-write-ahead-journaling-and-crash-recovery\">Milestone 6: Write-Ahead Journaling and Crash Recovery</h1>\n<h2 id=\"the-lie-your-code-has-been-telling\">The Lie Your Code Has Been Telling</h2>\n<p>Every filesystem operation you have written since Milestone 1 has contained a silent assumption so pervasive you probably never noticed it: that writes to the disk image happen in exactly the order your code issues them.\nYou call <code>write_block(fd, BLOCK_BITMAP_BLOCK, bitmap)</code> and then <code>write_inode(fd, sb, new_ino, &amp;inode)</code>. You feel safe because the bitmap is written before the inode â€” if you crash between the two, at worst you have a leaked block (bitmap says &quot;used,&quot; no inode points to it), and that is recoverable. You have been relying on write ordering as your crash consistency strategy.\nThat assumption is false. And the falseness is not subtle.\nHere is the chain of reordering that can happen between your <code>write_block</code> call and the bits reaching magnetic media or NAND cells:</p>\n<ol>\n<li><strong>The host kernel&#39;s page cache</strong>: When your process calls <code>write(fd, buf, 4096)</code> via <code>write_block</code>, the kernel copies the data into a page cache page and marks it dirty. The actual flush happens asynchronously via the kernel&#39;s writeback daemon, which decides order and timing based on I/O scheduler heuristics â€” not your call order.</li>\n<li><strong>The disk&#39;s write buffer</strong>: Modern HDDs and SSDs have DRAM write buffers of 64MB to 1GB. The disk accepts writes from the OS and reorders them internally to optimize head seek (HDD) or program/erase sequencing (SSD). Unless you issue a barrier or <code>fsync</code>, the disk&#39;s buffer is unconstrained.</li>\n<li><strong>The disk controller&#39;s NCQ (Native Command Queuing)</strong>: HDDs queue up to 32 commands and reorder them by rotational position. Your bitmap write, queued before your inode write, may execute second because the inode block happens to be at a more favorable rotational position when the command is dispatched.\nThe result: you call <code>write_block(bitmap)</code> then <code>write_block(inode)</code>. The disk writes the inode first. You suffer a power failure. On recovery, the inode exists on disk pointing to a block that the bitmap marks as free â€” potentially double-allocated to a new file. <strong>Data corruption. Not a leaked block. Actual data from two files occupying the same disk block.</strong>\n[[EXPLAIN:write-ahead-logging-â€”-the-principle-of-logging-intent-before-action|Write-ahead logging â€” the principle of logging intent before action]]\nThe only mechanism that actually enforces ordering is <code>fsync</code>. When you call <code>fsync(fd)</code>, the kernel flushes all dirty pages for that file descriptor to the device and waits for the device to confirm that the data is durable â€” not just in the device&#39;s buffer, but confirmed written to stable storage. After <code>fsync</code> returns, you have a guarantee: everything written to <code>fd</code> before the call is on disk in the order the flushes were issued.\nWrite-ahead logging (WAL) is the design pattern that weaponizes this guarantee. The protocol is simple and absolute:</li>\n<li>Write all changes to a <strong>sequential journal region</strong> on disk</li>\n<li>Call <code>fsync</code> â€” all journal writes are now durable and ordered</li>\n<li>Write a <strong>commit record</strong> to the journal indicating this transaction is complete</li>\n<li>Call <code>fsync</code> again â€” the commit record is now durable</li>\n<li>Write the actual changes to their permanent locations (inode table, bitmaps, directory blocks)</li>\n<li>Call <code>fsync</code> â€” the main data structures now reflect the committed state\nIf power fails at any point before step 4, the commit record does not exist. On recovery, the partial journal entries are discarded. The main data structures are unchanged â€” perfectly consistent, as if the operation never happened.\nIf power fails between step 4 and step 6, the commit record exists. On recovery, the journal entries are replayed against the main data structures. The operation is completed. The filesystem is consistent.\nThe journal is not an optimization. It is the fundamental mechanism that makes crash consistency possible without a full filesystem scan. Without it, the only recovery option is <code>fsck</code> â€” which must read every inode, every bitmap, and every directory block on the entire filesystem to reconstruct consistent state. On a 10TB disk at 500MB/s sequential read speed, that is six hours of downtime every time someone trips over a power cable.</li>\n</ol>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m6-transaction-lifecycle.svg\" alt=\"Transaction Lifecycle â€” Begin â†’ Journal â†’ Commit â†’ Apply â†’ End\"></p>\n<hr>\n<h2 id=\"the-fundamental-tension-atomicity-on-non-atomic-hardware\">The Fundamental Tension: Atomicity on Non-Atomic Hardware</h2>\n<p>Here is the core hardware constraint you are negotiating with:\n<strong>A filesystem update requires multiple disk writes. Each disk write is independently atomic at the sector level (512 bytes or 4KB). No multi-block operation is atomic at the hardware level.</strong>\nCreating a file requires at minimum: one bitmap write (inode bitmap), one inode table write, one directory block write, and potentially a bitmap write for the data block. Four separate 4KB writes. The hardware can guarantee that each individual 4KB sector write either completes or does not â€” it will not write half a sector. But there is no hardware primitive for &quot;write these four blocks atomically.&quot;\nThe software solution â€” WAL â€” synthesizes atomicity from sequential writes plus a commit record. The key insight is that a single 4KB sector write <em>is</em> hardware-atomic. If the commit record fits in one sector (and journal commit records are small â€” a few dozen bytes), the commit write is atomic. Either the commit record is present on disk or it is not. There is no half-written commit record. The commit record becomes the single atomic boundary that separates &quot;committed&quot; from &quot;not committed,&quot; and the journal structure ensures that a missing commit record always means &quot;safe to discard.&quot;</p>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m6-crash-scenarios.svg\" alt=\"Three Crash Scenarios â€” What Happens and Why\"></p>\n<p>The numbers that drive the design:</p>\n<ul>\n<li>Journal write of 4KB: ~100Î¼s on SSD (same as any block write)</li>\n<li><code>fsync</code> call: ~100Î¼sâ€“1ms on SSD depending on device and host OS</li>\n<li>Journal entry overhead: 2Ã— <code>fsync</code> per transaction minimum (journal flush + commit flush)</li>\n<li>Benefit: O(journal_size) recovery instead of O(filesystem_size) recovery</li>\n<li>Typical journal size: 4MBâ€“128MB (1,024â€“32,768 blocks at 4KB)</li>\n<li>Recovery time from 4MB journal: ~40ms (400 block reads at SSD speed)</li>\n<li>Recovery time from full fsck on 10TB disk: hours</li>\n</ul>\n<hr>\n<h2 id=\"journal-region-on-disk-layout\">Journal Region: On-Disk Layout</h2>\n<p>The journal occupies a contiguous region of blocks configured in the superblock. From Milestone 1, you already reserved <code>sb-&gt;journal_start</code> and <code>sb-&gt;journal_blocks</code> for this purpose. Now you give that region a structure.</p>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m6-journal-region-layout.svg\" alt=\"Journal Region â€” On-Disk Layout with Wrap-Around\"></p>\n<p>The journal region has three kinds of content:</p>\n<ol>\n<li><strong>Journal superblock</strong> (first block of the journal region): stores the journal&#39;s head, tail, and sequence number. This is the journal&#39;s own metadata â€” distinct from the filesystem superblock.</li>\n<li><strong>Transaction entries</strong> (the body): a circular buffer of journal blocks, each either a metadata block copy or a descriptor block describing what follows.</li>\n<li><strong>Commit blocks</strong>: special single-block entries that mark transaction boundaries.\nWe implement a simplified but correct journal with these on-disk structures:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> JOURNAL_MAGIC</span><span style=\"color:#F97583\">       0x</span><span style=\"color:#79B8FF\">4A4F5552</span><span style=\"color:#6A737D\">    /* \"JOUR\" in ASCII */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> JOURNAL_BLOCK_SIZE</span><span style=\"color:#E1E4E8\">  BLOCK_SIZE</span><span style=\"color:#6A737D\">    /* 4096 bytes */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Journal block types */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> JB_TYPE_SUPER</span><span style=\"color:#F97583\">    0x</span><span style=\"color:#79B8FF\">01</span><span style=\"color:#6A737D\">    /* journal superblock */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> JB_TYPE_DESC</span><span style=\"color:#F97583\">     0x</span><span style=\"color:#79B8FF\">02</span><span style=\"color:#6A737D\">    /* descriptor: describes following data blocks */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> JB_TYPE_COMMIT</span><span style=\"color:#F97583\">   0x</span><span style=\"color:#79B8FF\">03</span><span style=\"color:#6A737D\">    /* commit record: transaction is complete */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> JB_TYPE_REVOKE</span><span style=\"color:#F97583\">   0x</span><span style=\"color:#79B8FF\">04</span><span style=\"color:#6A737D\">    /* revoke: this block should not be replayed */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Journal Superblock â€” lives at journal_start (first block of journal region).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * BYTE LAYOUT:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset  0: j_magic          (4 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset  4: j_block_type     (4 bytes) â€” always JB_TYPE_SUPER</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset  8: j_sequence       (4 bytes) â€” next transaction sequence number</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 12: j_head           (4 bytes) â€” first block with live data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 16: j_tail           (4 bytes) â€” first free block (circular)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 20: j_total_blocks   (4 bytes) â€” total blocks in journal region (excluding superblock)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 24: reserved         (4072 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Total: 4096 bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#B392F0\"> __attribute__</span><span style=\"color:#E1E4E8\">((packed)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> j_magic;</span><span style=\"color:#6A737D\">           /* JOURNAL_MAGIC */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> j_block_type;</span><span style=\"color:#6A737D\">      /* JB_TYPE_SUPER */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> j_sequence;</span><span style=\"color:#6A737D\">        /* monotonically increasing transaction counter */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> j_head;</span><span style=\"color:#6A737D\">            /* offset of oldest committed, unapplied transaction */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> j_tail;</span><span style=\"color:#6A737D\">            /* offset where next write goes */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> j_total_blocks;</span><span style=\"color:#6A737D\">    /* usable journal blocks (journal_blocks - 1) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\">  reserved</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 24</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">journal_super_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">_Static_assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">journal_super_t</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">               \"journal_super_t must be exactly 4096 bytes\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Journal Descriptor Block â€” precedes a set of data blocks in the journal.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * A descriptor block describes the next N data blocks in the journal:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * which filesystem block each one belongs to, and how many blocks follow.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * After the descriptor block come exactly j_nr_blocks raw copies of metadata.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * BYTE LAYOUT:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset  0: j_magic          (4 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset  4: j_block_type     (4 bytes) â€” JB_TYPE_DESC</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset  8: j_sequence       (4 bytes) â€” transaction this belongs to</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 12: j_nr_blocks      (4 bytes) â€” number of data blocks that follow</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 16: j_blocks[0..N]   (8 bytes each) â€” target filesystem block numbers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *              (max N = (BLOCK_SIZE - 16) / 8 = 510 blocks per descriptor)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Total: 4096 bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_BLOCKS_PER_DESC</span><span style=\"color:#E1E4E8\">  ((BLOCK_SIZE </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#B392F0\"> __attribute__</span><span style=\"color:#E1E4E8\">((packed)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> j_magic;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> j_block_type;</span><span style=\"color:#6A737D\">      /* JB_TYPE_DESC */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> j_sequence;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> j_nr_blocks;</span><span style=\"color:#6A737D\">       /* how many data blocks follow this descriptor */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#FFAB70\"> j_blocks</span><span style=\"color:#E1E4E8\">[MAX_BLOCKS_PER_DESC];</span><span style=\"color:#6A737D\"> /* target block numbers (0-indexed from j_blocks[0]) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">journal_desc_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">_Static_assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">journal_desc_t</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">               \"journal_desc_t must be exactly 4096 bytes\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Commit Block â€” marks the end of a transaction.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * A transaction is committed if and only if a commit block with a matching</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * sequence number exists in the journal after its descriptor and data blocks.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * The commit block is written LAST, after fsync of the preceding data.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * It is small enough to fit in a single atomic sector write.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * BYTE LAYOUT:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset  0: j_magic          (4 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset  4: j_block_type     (4 bytes) â€” JB_TYPE_COMMIT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset  8: j_sequence       (4 bytes) â€” must match the descriptor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 12: j_checksum       (4 bytes) â€” CRC32 of all journaled block data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Offset 16: reserved         (4080 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Total: 4096 bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#B392F0\"> __attribute__</span><span style=\"color:#E1E4E8\">((packed)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> j_magic;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> j_block_type;</span><span style=\"color:#6A737D\">      /* JB_TYPE_COMMIT */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> j_sequence;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> j_checksum;</span><span style=\"color:#6A737D\">        /* simple sum of all journaled bytes */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\">  reserved</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">journal_commit_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">_Static_assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">journal_commit_t</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> BLOCK_SIZE,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">               \"journal_commit_t must be exactly 4096 bytes\"</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m6-journal-entry-format.svg\" alt=\"Journal Entry Structure â€” Byte Layout\"></p>\n<p>The journal operates as a <strong>circular buffer</strong> of blocks. The <code>j_head</code> and <code>j_tail</code> pointers â€” offsets into the journal region, not absolute disk block numbers â€” define the live region:</p>\n<ul>\n<li><code>j_tail</code>: where the next write goes (producer end)</li>\n<li><code>j_head</code>: the oldest live entry (consumer end, advanced during checkpointing)</li>\n<li>When <code>j_tail</code> wraps around to <code>j_head</code>, the journal is full â€” block until checkpoint\nThe absolute disk block number for journal offset <code>N</code> is:</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> journal_abs_block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> journal_offset</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Offset 0 is the journal superblock; data starts at offset 1 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> sb->journal_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> (journal_offset </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> sb->j_total_blocks);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"the-transaction-api\">The Transaction API</h2>\n<p>Every filesystem operation that modifies metadata must be wrapped in a transaction. The transaction API has four calls:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * In-memory transaction state.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * A transaction accumulates block changes before committing them atomically.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Maximum transaction size: limited by journal capacity and descriptor block size.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_TXNBLOCKS</span><span style=\"color:#79B8FF\">   64</span><span style=\"color:#6A737D\">   /* max blocks in one transaction */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">          fd;</span><span style=\"color:#6A737D\">             /* disk image fd */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">sb;</span><span style=\"color:#6A737D\">            /* filesystem superblock */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    journal_super_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">jsuper;</span><span style=\"color:#6A737D\">     /* journal superblock (in-memory, flushed on commit) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\">     sequence;</span><span style=\"color:#6A737D\">       /* this transaction's sequence number */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Accumulated dirty blocks */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\">     nr_blocks;</span><span style=\"color:#6A737D\">      /* count of blocks pending */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#FFAB70\">     block_nums</span><span style=\"color:#E1E4E8\">[MAX_TXNBLOCKS];</span><span style=\"color:#6A737D\">     /* filesystem block numbers */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\">      block_data</span><span style=\"color:#E1E4E8\">[MAX_TXNBLOCKS][BLOCK_SIZE];</span><span style=\"color:#6A737D\"> /* block contents */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">txn_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Journal superblock in memory â€” loaded at mount, persisted at checkpoint */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> journal_super_t</span><span style=\"color:#E1E4E8\"> g_jsuper;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Load the journal superblock from disk.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Called once during filesystem mount.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> journal_load</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, sb->journal_start, buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_jsuper, buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(g_jsuper));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (g_jsuper.j_magic </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> JOURNAL_MAGIC) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* First mount after mkfs: initialize the journal superblock */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_jsuper, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(g_jsuper));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        g_jsuper.j_magic        </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> JOURNAL_MAGIC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        g_jsuper.j_block_type   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> JB_TYPE_SUPER;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        g_jsuper.j_sequence     </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        g_jsuper.j_head         </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        g_jsuper.j_tail         </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        g_jsuper.j_total_blocks </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sb->journal_blocks </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> journal_persist_super</span><span style=\"color:#E1E4E8\">(fd, sb);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Write the journal superblock to disk.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> journal_persist_super</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_jsuper, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(g_jsuper));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> write_block</span><span style=\"color:#E1E4E8\">(fd, sb->journal_start, buf);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"txn_begin-opening-a-transaction\"><code>txn_begin</code>: Opening a Transaction</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Begin a new transaction.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Initializes the in-memory transaction state. No disk I/O yet.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * The transaction accumulates changes until txn_commit() is called.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Every filesystem operation that modifies metadata must begin with this call.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * NEVER modify inode table, bitmaps, or directory blocks without an active transaction.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> txn_begin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">txn_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">txn</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(txn, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">txn));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    txn->fd       </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> fd;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    txn->sb       </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sb;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    txn->jsuper   </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">g_jsuper;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    txn->sequence </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> g_jsuper.j_sequence;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    txn->nr_blocks </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"txn_journal_block-recording-a-change\"><code>txn_journal_block</code>: Recording a Change</h3>\n<p>Instead of calling <code>write_block</code> directly, every metadata write goes through <code>txn_journal_block</code>. This records the block&#39;s new content in the transaction but does not write to the block&#39;s final destination yet:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Record a block change in the current transaction.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * block_num: the FILESYSTEM block number that will eventually be updated.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * data:      the new 4KB content for that block.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This does NOT write to block_num on disk yet. The actual write happens</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * in txn_commit() after the journal entry is made durable.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns 0 on success, -ENOSPC if the transaction is full.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * NOTE: If block_num is already in the transaction's pending list,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * we update its entry (this is the \"revoke\" optimization for blocks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * modified multiple times within one transaction).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> txn_journal_block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">txn_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">txn</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> block_num</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Check if this block is already in the transaction */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> txn->nr_blocks; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (txn->block_nums[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> block_num) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Update existing entry â€” no need for duplicate journal writes */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            memcpy</span><span style=\"color:#E1E4E8\">(txn->block_data[i], data, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (txn->nr_blocks </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> MAX_TXNBLOCKS) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOSPC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    txn->block_nums[txn->nr_blocks] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block_num;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(txn->block_data[txn->nr_blocks], data, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    txn->nr_blocks</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"txn_commit-the-critical-path\"><code>txn_commit</code>: The Critical Path</h3>\n<p>This is the most important function in the entire journaling system. Every design decision here traces back to the crash consistency guarantee:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Commit a transaction.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Protocol (each step must complete before the next begins):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   1. Write descriptor block to journal (describes which blocks follow)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   2. Write all journaled block copies to journal</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   3. fsync the disk image â†’ journal entries are durable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   4. Write commit block to journal</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   5. fsync again â†’ commit record is durable (POINT OF NO RETURN)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   6. Write each block to its actual filesystem location</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   7. fsync â†’ main data structures updated</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   8. Advance journal tail; update sequence number</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * After step 5: transaction is committed. Crash recovery WILL replay it.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Before step 5: transaction is not committed. Crash recovery WILL NOT replay it.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns 0 on success, negative errno on failure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> txn_commit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">txn_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">txn</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (txn->nr_blocks </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   /* empty transaction â€” nothing to do */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">sb    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> txn->sb;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    journal_super_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">js </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> txn->jsuper;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd              </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> txn->fd;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Check journal has enough space for: 1 descriptor + nr_blocks data + 1 commit */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> blocks_needed </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> txn->nr_blocks </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> journal_used  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (js->j_tail </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> js->j_head)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                             ?</span><span style=\"color:#E1E4E8\"> (js->j_tail </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> js->j_head)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                             :</span><span style=\"color:#E1E4E8\"> (js->j_total_blocks </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> js->j_head </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> js->j_tail);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> journal_free  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> js->j_total_blocks </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> journal_used;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (blocks_needed </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> journal_free) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Journal is full. In production: block until checkpoint completes.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * For our implementation: force a checkpoint inline.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * This is the \"journal full\" condition that can block writers.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> journal_checkpoint</span><span style=\"color:#E1E4E8\">(fd, sb);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Recompute after checkpoint */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        journal_used  </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   /* checkpoint cleared the journal */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        journal_free  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> js->j_total_blocks;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (blocks_needed </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> journal_free) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOSPC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- STEP 1: Write descriptor block to journal --- */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> desc_buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(desc_buf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    journal_desc_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">desc </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">journal_desc_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)desc_buf;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    desc->j_magic      </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> JOURNAL_MAGIC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    desc->j_block_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> JB_TYPE_DESC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    desc->j_sequence   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> txn->sequence;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    desc->j_nr_blocks  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> txn->nr_blocks;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> txn->nr_blocks; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        desc->j_blocks[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> txn->block_nums[i];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> journal_pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> js->j_tail;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> desc_abs    </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> journal_abs_block</span><span style=\"color:#E1E4E8\">(sb, journal_pos);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, desc_abs, desc_buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    journal_pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (journal_pos </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> js->j_total_blocks;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- STEP 2: Write each block's data copy to journal --- */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> checksum </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> txn->nr_blocks; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> data_abs </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> journal_abs_block</span><span style=\"color:#E1E4E8\">(sb, journal_pos);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, data_abs, txn->block_data[i]) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Accumulate checksum for commit block */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">words </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)txn->block_data[i];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; j </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)(BLOCK_SIZE </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)); j</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            checksum </span><span style=\"color:#F97583\">+=</span><span style=\"color:#FFAB70\"> words</span><span style=\"color:#E1E4E8\">[j];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        journal_pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (journal_pos </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> js->j_total_blocks;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- STEP 3: fsync â€” all journal writes durable --- */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * This fsync is MANDATORY and NON-NEGOTIABLE.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Without it, the OS may reorder the journal data writes relative to</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * the commit block write. The commit block could reach disk before the</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * descriptor or data blocks, creating a committed-but-unreplayable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * transaction. The fsync establishes a memory barrier at the hardware level:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * everything before this call is on stable storage before anything after</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * this call begins writing.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">fsync</span><span style=\"color:#E1E4E8\">(fd) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- STEP 4: Write commit block --- */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> commit_buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(commit_buf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    journal_commit_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">commit </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">journal_commit_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)commit_buf;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    commit->j_magic      </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> JOURNAL_MAGIC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    commit->j_block_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> JB_TYPE_COMMIT;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    commit->j_sequence   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> txn->sequence;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    commit->j_checksum   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> checksum;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> commit_abs  </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> journal_abs_block</span><span style=\"color:#E1E4E8\">(sb, journal_pos);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, commit_abs, commit_buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    journal_pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (journal_pos </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> js->j_total_blocks;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- STEP 5: fsync â€” commit record is durable (POINT OF NO RETURN) --- */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * After this fsync returns, the transaction is committed.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * If power fails any time after this point, recovery WILL replay this</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * transaction. The commit block on stable storage is the guarantee.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * If power fails before this fsync completes (including during the fsync),</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * the commit block is not durable. Recovery will not find it. The</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * transaction is treated as aborted. The main data structures are unchanged.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">fsync</span><span style=\"color:#E1E4E8\">(fd) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- STEP 6: Write blocks to their actual filesystem locations --- */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Only now do we update the actual inode table, bitmaps, and directory blocks.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * The order here does not matter for crash consistency â€” if we crash during</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * step 6, the journal commit record guarantees recovery will complete the writes.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * We write in the order they appear in the transaction for simplicity.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> txn->nr_blocks; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, txn->block_nums[i], txn->block_data[i]) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * This write failed, but the journal is committed.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * Recovery will re-apply this transaction on next mount.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * Safe to return error â€” the filesystem remains consistent.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- STEP 7: fsync â€” main data structures updated --- */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * This fsync is advisory for crash consistency (recovery handles the</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * case where it doesn't happen), but it improves performance by</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * allowing the journal to be checkpointed sooner: we know the</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * in-place writes completed, so the journal entries are redundant.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fsync</span><span style=\"color:#E1E4E8\">(fd);</span><span style=\"color:#6A737D\">   /* best-effort; ignore return value */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- STEP 8: Advance journal tail and sequence number --- */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    js->j_tail     </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> journal_pos;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    js->j_sequence </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> txn->sequence </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    journal_persist_super</span><span style=\"color:#E1E4E8\">(fd, sb);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m6-fsync-ordering.svg\" alt=\"The fsync Ordering Guarantee â€” Why Order Matters\"></p>\n<blockquote>\n<p><strong>Hardware Soul â€” Why Two <code>fsync</code> Calls?</strong>\nThe first <code>fsync</code> (step 3) flushes the journal data pages from the kernel&#39;s page cache to the disk&#39;s write buffer, and instructs the disk to flush its write buffer to stable media. On SSDs, this typically takes 100â€“500Î¼s depending on the write buffer state. The second <code>fsync</code> (step 5) does the same for the commit block. Why two? Because the commit block&#39;s durability is the single binary condition that separates &quot;committed&quot; from &quot;not committed.&quot; Without the first <code>fsync</code>, the disk might write the commit block before the data blocks (internal reordering). With the first <code>fsync</code>, we know: the data blocks are on stable media, then the commit block is written. The ordering is established at the hardware level. On an SSD with power-loss protection (enterprise SSDs, NVMe with capacitors), the first <code>fsync</code> cost can be eliminated using disk-level barriers â€” but that requires more complex device capability detection. Two <code>fsync</code> calls is the conservative, universally correct approach.</p>\n</blockquote>\n<hr>\n<h2 id=\"the-txn_journal_block-wrapper-idiom\">The <code>txn_journal_block</code> Wrapper Idiom</h2>\n<p>Every metadata write in your codebase â€” every call to <code>write_inode</code>, <code>write_block</code> for bitmaps, every directory entry modification â€” must be converted to use <code>txn_journal_block</code>. Here is the pattern:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Journaled wrapper for write_inode.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Instead of writing to the inode table immediately, record the</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * intended change in the active transaction.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Caller must have an active txn_t and must call txn_commit() at the</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * end of the operation.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> txn_write_inode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">txn_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">txn</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> inode_num</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> inode_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">sb </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> txn->sb;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (inode_num </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> inode_num </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> sb->total_inodes) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> idx           </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inode_num </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> block_num     </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sb->inode_table_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> idx </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> INODES_PER_BLOCK;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> slot_in_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> idx </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> INODES_PER_BLOCK;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Read the current inode block content */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> read_block</span><span style=\"color:#E1E4E8\">(txn->fd, block_num, buf);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Apply the change in memory */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(buf </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> slot_in_block </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> INODE_SIZE, inode, INODE_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Record in transaction â€” no disk write yet */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> txn_journal_block</span><span style=\"color:#E1E4E8\">(txn, block_num, buf);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Journaled wrapper for block bitmap update.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Records the bitmap change in the transaction.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> txn_write_block_bitmap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">txn_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">txn</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">bitmap</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> txn_journal_block</span><span style=\"color:#E1E4E8\">(txn, BLOCK_BITMAP_BLOCK, bitmap);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Journaled wrapper for inode bitmap update.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> txn_write_inode_bitmap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">txn_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">txn</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">bitmap</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> txn_journal_block</span><span style=\"color:#E1E4E8\">(txn, INODE_BITMAP_BLOCK, bitmap);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Here is what <code>fs_create_file</code> looks like when converted to use journaling:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Journaled version of fs_create_file.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Wraps all metadata changes in a single atomic transaction.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * If ANY step fails before txn_commit(), the transaction is abandoned.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * No partial changes will appear in the filesystem.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * If the process crashes after txn_commit() but before the in-place</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * writes complete, recovery will replay the transaction on next mount.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> fs_create_file_journaled</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                              uint32_t</span><span style=\"color:#FFAB70\"> parent_ino</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                              uint16_t</span><span style=\"color:#FFAB70\"> mode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> uid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> gid</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    txn_t</span><span style=\"color:#E1E4E8\"> txn;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    txn_begin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">txn, fd, sb);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- 1. Validate parent --- */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> parent_inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, parent_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">parent_inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">S_ISDIR</span><span style=\"color:#E1E4E8\">(parent_inode.mode)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTDIR;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">dir_lookup</span><span style=\"color:#E1E4E8\">(fd, sb, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">parent_inode, name) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EEXIST;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- 2. Allocate inode (in-memory only for now) --- */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Read inode bitmap, find free slot, mark used */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> ibmap</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, INODE_BITMAP_BLOCK, ibmap) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> new_ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> bitmap_find_free</span><span style=\"color:#E1E4E8\">(ibmap, sb->total_inodes);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (new_ino </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOSPC;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    bitmap_set</span><span style=\"color:#E1E4E8\">(ibmap, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_ino);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Journal the bitmap change â€” not written to disk yet */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    txn_write_inode_bitmap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">txn, ibmap);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> new_ino_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_ino </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* 1-based */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- 3. Initialize new inode --- */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> new_inode;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">new_inode, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(new_inode));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_inode.mode   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\">)(S_IFREG </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> (mode </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0</span><span style=\"color:#79B8FF\">777</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_inode.uid    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> uid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_inode.gid    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_inode.nlinks </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_inode.size   </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> now </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_inode.atime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_inode.mtime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_inode.ctime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> now;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Journal the new inode */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    txn_write_inode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">txn, new_ino_num, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">new_inode);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- 4. Add directory entry --- */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * dir_add_entry modifies the parent directory's data blocks.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * We need to capture the modified block and journal it.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * In a full implementation, dir_add_entry would take a txn_t parameter.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * For clarity, we show the pattern inline here.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ... (see full implementation with txn-aware dir_add_entry below) ... */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- 5. Update parent inode mtime/ctime --- */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parent_inode.mtime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parent_inode.ctime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> now;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    txn_write_inode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">txn, parent_ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">parent_inode);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- 6. Update superblock free counts --- */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sb->free_inodes</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Journal the superblock block (block 0) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> sb_buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(sb_buf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, BLOCK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(sb_buf, sb, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">sb));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    txn_journal_block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">txn, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, sb_buf);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* --- 7. COMMIT: write journal + fsync twice + write in place + fsync --- */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> txn_commit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">txn);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Commit failed. Rollback the in-memory sb free count. */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sb->free_inodes</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)new_ino_num;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"the-key-structural-change-every-operation-now-builds-up-a-set-of-block-changes-in-txn-then-commits-them-all-atomically-if-any-step-fails-before-txn_commit-the-transaction-is-simply-abandoned-txn-goes-out-of-scope-nothing-was-written-to-disk-the-filesystem-is-unchanged\">The key structural change: every operation now builds up a set of block changes in <code>txn</code>, then commits them all atomically. If any step fails before <code>txn_commit</code>, the transaction is simply abandoned â€” <code>txn</code> goes out of scope, nothing was written to disk, the filesystem is unchanged.</h2>\n<h2 id=\"journal-recovery-replaying-on-mount\">Journal Recovery: Replaying on Mount</h2>\n<p>[[EXPLAIN:write-ahead-log-replay-â€”-scanning-the-log-and-re-applying-committed-operations|Write-ahead log replay â€” scanning committed journal entries and re-applying operations to primary data structures]]\nRecovery happens at mount time, before the filesystem is made available for use. The algorithm:</p>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m6-replay-algorithm.svg\" alt=\"Journal Replay Algorithm â€” Recovery Flowchart\"></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>1. Read journal superblock â†’ get j_head and j_tail\n2. Scan from j_head toward j_tail:\n   a. Read block at current position\n   b. Check j_magic â€” if invalid, stop (journal is empty past here)\n   c. If JB_TYPE_DESC: remember the descriptor (block list + sequence)\n   d. Read the following data blocks (one per entry in descriptor)\n   e. Look for JB_TYPE_COMMIT with matching j_sequence\n   f. If commit found: REPLAY â€” write each data block to its target\n   g. If commit NOT found before hitting another descriptor or invalid block:\n      DISCARD â€” skip to next descriptor or stop\n3. After all committed transactions replayed: checkpoint (mark journal clean)</code></pre></div>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Replay the journal on mount.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Scans all journal blocks from j_head to j_tail.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Applies committed transactions. Discards incomplete transactions.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * After this function returns, the filesystem is in a consistent state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * matching the most recent committed transaction.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns 0 on success (including \"no recovery needed\"), negative errno on error.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> journal_recover</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    journal_super_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">js </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">g_jsuper;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (js->j_head </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> js->j_tail) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Journal is empty â€” nothing to replay */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"journal_recover: journal is clean, no replay needed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"journal_recover: replaying journal (head=</span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\">, tail=</span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           js->j_head, js->j_tail);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> js->j_head;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> replayed </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (pos </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> js->j_tail) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> abs_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> journal_abs_block</span><span style=\"color:#E1E4E8\">(sb, pos);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, abs_block, buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"journal_recover: I/O error at journal offset </span><span style=\"color:#79B8FF\">%u\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, pos);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Examine the block type */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">magic </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)buf;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">btype </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)(buf </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">magic </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> JOURNAL_MAGIC) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* No more valid journal entries */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"journal_recover: end of valid entries at offset </span><span style=\"color:#79B8FF\">%u\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, pos);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">btype </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> JB_TYPE_DESC) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Not a descriptor â€” could be a stale commit or other block; skip */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (pos </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> js->j_total_blocks;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Found a descriptor block */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        journal_desc_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">desc </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">journal_desc_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)buf;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> seq          </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> desc->j_sequence;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> nr_blocks    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> desc->j_nr_blocks;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (nr_blocks </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> MAX_BLOCKS_PER_DESC </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> nr_blocks </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"journal_recover: corrupt descriptor (nr_blocks=</span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    nr_blocks);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Read the data blocks that follow the descriptor */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> data_pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (pos </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> js->j_total_blocks;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint8_t</span><span style=\"color:#FFAB70\"> data_bufs</span><span style=\"color:#E1E4E8\">[MAX_TXNBLOCKS][BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> checksum_computed </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> nr_blocks; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint32_t</span><span style=\"color:#E1E4E8\"> data_abs </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> journal_abs_block</span><span style=\"color:#E1E4E8\">(sb, data_pos);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, data_abs, </span><span style=\"color:#FFAB70\">data_bufs</span><span style=\"color:#E1E4E8\">[i]) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"journal_recover: I/O error reading data block </span><span style=\"color:#79B8FF\">%u\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, i);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            const</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">words </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">data_bufs</span><span style=\"color:#E1E4E8\">[i];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; j </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)(BLOCK_SIZE </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)); j</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                checksum_computed </span><span style=\"color:#F97583\">+=</span><span style=\"color:#FFAB70\"> words</span><span style=\"color:#E1E4E8\">[j];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            data_pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (data_pos </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> js->j_total_blocks;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Look for the commit block at data_pos */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> commit_abs </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> journal_abs_block</span><span style=\"color:#E1E4E8\">(sb, data_pos);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint8_t</span><span style=\"color:#FFAB70\"> commit_buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, commit_abs, commit_buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"journal_recover: I/O error reading commit block</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        journal_commit_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">commit </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">journal_commit_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)commit_buf;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (commit->j_magic      </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> JOURNAL_MAGIC </span><span style=\"color:#F97583\">||</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            commit->j_block_type </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> JB_TYPE_COMMIT </span><span style=\"color:#F97583\">||</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            commit->j_sequence   </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> seq) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * No valid commit block for this transaction.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * The transaction was incomplete at crash time â€” discard it.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * This is the correct behavior: a missing commit record means</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * the transaction never durably completed. We act as if the</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * operation never started. The filesystem metadata below is</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * unchanged from the last committed transaction.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"journal_recover: incomplete txn seq=</span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> discarded</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, seq);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (pos </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> js->j_total_blocks;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Validate checksum.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * A checksum mismatch means either the data blocks are corrupt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * or the commit block belongs to a different transaction (false match).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (commit->j_checksum </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> checksum_computed) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"journal_recover: checksum mismatch in txn seq=</span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    \"(expected 0x</span><span style=\"color:#79B8FF\">%08X</span><span style=\"color:#9ECBFF\">, got 0x</span><span style=\"color:#79B8FF\">%08X</span><span style=\"color:#9ECBFF\">) â€” discarding</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    seq, commit->j_checksum, checksum_computed);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> data_pos </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * REPLAY: write each journaled block to its filesystem location.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Idempotency: if we crash DURING replay and replay is run again,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * these writes are safe to apply multiple times. Each write is</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * exactly the same data written to the same block. Replaying</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * a transaction twice produces the same result as replaying it once.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * This is the idempotency guarantee that makes WAL replay correct.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"journal_recover: replaying committed txn seq=</span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> (</span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> blocks)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               seq, nr_blocks);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> nr_blocks; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint32_t</span><span style=\"color:#E1E4E8\"> target_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)desc->j_blocks[i];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_block</span><span style=\"color:#E1E4E8\">(fd, target_block, </span><span style=\"color:#FFAB70\">data_bufs</span><span style=\"color:#E1E4E8\">[i]) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"journal_recover: failed to write block </span><span style=\"color:#79B8FF\">%u\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        target_block);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        replayed</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Advance past this transaction's descriptor + data + commit */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (data_pos </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> js->j_total_blocks;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Flush replayed writes to disk */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (replayed </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">fsync</span><span style=\"color:#E1E4E8\">(fd) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"journal_recover: replayed </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> transactions</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, replayed);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Checkpoint: mark journal as clean */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> journal_checkpoint</span><span style=\"color:#E1E4E8\">(fd, sb);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"metadata-only-journaling\">Metadata-Only Journaling</h2>\n<p>[[EXPLAIN:journaling-modes-â€”-metadata-only-vs-full-data-journaling-tradeoff|Journaling modes â€” the tradeoff between metadata-only journaling (ext3 default) and full data journaling (higher safety, higher write amplification)]]\nYour journal records metadata changes: inode table blocks, bitmap blocks, directory data blocks. It does <strong>not</strong> journal file data blocks. This is the <strong>metadata journaling</strong> mode (called &quot;ordered&quot; mode in ext3/ext4 terminology). The distinction matters enormously for performance:</p>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m6-metadata-vs-full-journaling.svg\" alt=\"Metadata-Only vs. Full Journaling â€” Write Amplification Comparison\"></p>\n<table>\n<thead>\n<tr>\n<th>Mode</th>\n<th>What&#39;s journaled</th>\n<th>Write amplification</th>\n<th>Crash behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Metadata only (chosen âœ“)</strong></td>\n<td>Inodes, bitmaps, directories</td>\n<td>2â€“3Ã— for metadata, 1Ã— for data</td>\n<td>Data written before crash may be lost; metadata is always consistent</td>\n</tr>\n<tr>\n<td>Full journaling</td>\n<td>Metadata + file data</td>\n<td>2Ã— for all writes</td>\n<td>All committed writes survive crash</td>\n</tr>\n<tr>\n<td>Writeback</td>\n<td>Metadata only, no ordering</td>\n<td>~2Ã— for metadata</td>\n<td>Metadata consistent; data blocks may contain garbage</td>\n</tr>\n<tr>\n<td>Metadata-only journaling with ordered data writes (the safe default) means: before journaling the inode that points to a data block, ensure the data block has been written to disk. The protocol for a file write operation is:</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<ol>\n<li>Write file data blocks to their final locations (no journal)</li>\n<li><code>fsync(fd)</code> â€” data blocks are durable</li>\n<li>Begin transaction</li>\n<li>Journal inode update (new size, new block pointers)</li>\n<li>Commit transaction</li>\n<li><code>fsync(fd)</code> â€” inode update is durable\nIf you crash between steps 1 and 5: the data exists on disk but the inode does not point to it. From the filesystem&#39;s perspective, the write never happened. The file has its old size and old content. Data is lost but the filesystem is consistent.\nIf you crash after step 5: the inode points to the written data. The write is committed. Full durability.</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Journaled file write â€” ordered metadata journaling mode.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Protocol:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   1. Write data blocks to final locations (not journaled)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   2. fsync â€” data is durable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   3. Journal inode update (new size + any new block pointer changes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   4. Commit journal transaction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This ensures: if crash between 1 and 3, old inode is intact (old file content).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * If crash after 4, inode reflects new content.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> fs_write_journaled</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        uint32_t</span><span style=\"color:#FFAB70\"> ino</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#FFAB70\"> offset</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        const</span><span style=\"color:#F97583\"> void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> length</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 1 &#x26; 2: Write data blocks directly (not journaled) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> written </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_write</span><span style=\"color:#E1E4E8\">(fd, sb, ino, offset, buf, length);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (written </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)written;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* fsync data before journaling the metadata */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">fsync</span><span style=\"color:#E1E4E8\">(fd) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 3 &#x26; 4: Journal the inode metadata update */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    txn_t</span><span style=\"color:#E1E4E8\"> txn;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    txn_begin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">txn, fd, sb);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* The inode was already updated in-place by fs_write above.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Re-read and journal the current (updated) inode block. */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> idx       </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ino </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> block_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sb->inode_table_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> idx </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> INODES_PER_BLOCK;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\">  iblock</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_block</span><span style=\"color:#E1E4E8\">(fd, block_num, iblock) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    txn_journal_block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">txn, block_num, iblock);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> txn_commit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">txn);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<blockquote>\n<p><strong>Why Not Journal Data Too?</strong>\nFull journaling doubles the write load for all file writes â€” every byte written to a file is written twice: once to the journal, once to the final location. For a filesystem serving a 1Gbps network storage workload, full journaling would halve effective write throughput and double the SSD write endurance consumption. Metadata-only journaling adds overhead only for metadata operations (which are small and infrequent relative to data writes), while keeping data writes on the fast path. ext4&#39;s default mode is &quot;ordered&quot; â€” metadata journaled, data written to disk before the journal transaction commits. This is what you implemented above.</p>\n</blockquote>\n<hr>\n<h2 id=\"journal-checkpointing\">Journal Checkpointing</h2>\n<p>A checkpoint marks journal entries as no longer needed â€” their changes have been applied to the main data structures. Without checkpointing, the circular journal buffer fills up and all filesystem operations block.</p>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m6-checkpoint.svg\" alt=\"Journal Checkpoint â€” Reclaiming Journal Space\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Checkpoint the journal.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * A checkpoint declares: all committed transactions have been applied</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * to the main data structures. The journal can now be reused from the</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * beginning (j_head reset to j_tail, effectively clearing the journal).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * When to checkpoint:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   - When the journal is getting full (&#x3C; 20% free)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   - On unmount (ensure all changes are in main structures)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   - Periodically by a background thread (every N seconds)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * After checkpoint, recovery from a crash replays no transactions â€”</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * the journal is empty. This is the desired post-checkpoint state.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns 0 on success, negative errno on failure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> journal_checkpoint</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    journal_super_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">js </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">g_jsuper;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * All committed transactions have already been applied to the main</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * data structures by txn_commit() step 6. The journal entries are</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * now redundant. We just need to fsync to ensure the in-place writes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * are durable, then reset the journal head to the tail.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Ensure all in-place writes from prior transactions are on disk */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">fsync</span><span style=\"color:#E1E4E8\">(fd) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Reset journal: head catches up to tail.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * The journal is now empty â€” no transactions to replay.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * On next crash recovery, nothing will be replayed.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    js->j_head </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> js->j_tail;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Persist the updated journal superblock.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * This write must be durable before we return â€” otherwise a crash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * immediately after checkpoint could leave j_head pointing to the</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * wrong location, causing spurious transaction replay.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> journal_persist_super</span><span style=\"color:#E1E4E8\">(fd, sb);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (r </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> r;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">fsync</span><span style=\"color:#E1E4E8\">(fd) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIO;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"journal_checkpoint: journal cleared (sequence=</span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           js->j_sequence);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"idempotency-the-safety-net-for-replay\">Idempotency: The Safety Net for Replay</h2>\n<p>[[EXPLAIN:idempotent-operations-â€”-safe-to-apply-multiple-times-without-changing-the-result|Idempotent operations â€” an operation where applying it once or N times produces the same result, required for safe retry and replay semantics]]\nA critical property of WAL replay is that it may apply a transaction multiple times. Consider: the system crashes during replay itself (a &quot;crash during recovery&quot;). When the system reboots again, it replays the same journal entries again. Replaying a committed transaction twice must produce the same result as replaying it once.\nYour journal writes are idempotent because each journal entry records the <strong>final state</strong> of a block, not a delta. Writing &quot;inode 7&#39;s block pointer 0 is now block 2500&quot; twice leaves the inode in exactly the same state as writing it once. This is fundamentally different from a delta log like &quot;increment free_blocks by 1&quot; â€” replaying that twice would corrupt the free count.\nThe same idempotency requirement appears throughout distributed systems:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Verify idempotency in your journaled operations.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This test replays a transaction twice and checks that the result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * is the same as replaying it once.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_idempotent_replay</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Create a file, capture the transaction */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ino </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fs_create_file_journaled</span><span style=\"color:#E1E4E8\">(fd, sb, sb->root_inode,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                                        \"idempotent_test\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">644</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(ino </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Read the committed inode state */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> inode_after_create;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode_after_create);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Simulate replay: write the same blocks again (as recovery would) */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* In a real test, we would parse the journal and re-apply the blocks */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* For simplicity: write the inode block to itself twice */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> idx       </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)ino </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> block_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sb->inode_table_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> idx </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> INODES_PER_BLOCK;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[BLOCK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    read_block</span><span style=\"color:#E1E4E8\">(fd, block_num, buf);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* First replay */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    write_block</span><span style=\"color:#E1E4E8\">(fd, block_num, buf);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> after_replay1;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">after_replay1);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Second replay â€” same data, same target */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    write_block</span><span style=\"color:#E1E4E8\">(fd, block_num, buf);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    inode_t</span><span style=\"color:#E1E4E8\"> after_replay2;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    read_inode</span><span style=\"color:#E1E4E8\">(fd, sb, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)ino, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">after_replay2);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* All three must be identical */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">memcmp</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">inode_after_create, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">after_replay1, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">inode_t</span><span style=\"color:#E1E4E8\">)) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">memcmp</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">after_replay1, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">after_replay2, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">inode_t</span><span style=\"color:#E1E4E8\">)) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OK: replay is idempotent</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"crash-simulation-test\">Crash Simulation Test</h2>\n<p>The acceptance criteria require a crash simulation test. You cannot test crash recovery without simulating a crash. The approach: send <code>SIGKILL</code> to the filesystem process mid-operation, then remount and verify consistency.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">#!/bin/bash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># crash_test.sh â€” Verify crash recovery correctness</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">set</span><span style=\"color:#79B8FF\"> -euo</span><span style=\"color:#9ECBFF\"> pipefail</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">DISK</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"./crash_test.img\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">MOUNT</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"./crash_mount\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">FS</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"./myfs\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">MKFS</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"./mkfs\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cleanup</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fusermount3</span><span style=\"color:#79B8FF\"> -u</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    kill</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$FUSE_PID</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    rm</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$DISK</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    rmdir</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">trap</span><span style=\"color:#9ECBFF\"> cleanup</span><span style=\"color:#9ECBFF\"> EXIT</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">$MKFS </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">$DISK</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> 8192 2048</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"=== Crash Recovery Test ===\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Phase 1: Mount and create files</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">$FS </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">$DISK</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> -s &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">FUSE_PID</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">$!</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sleep</span><span style=\"color:#79B8FF\"> 0.5</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Create a directory and several files</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/important_dir\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"critical data 1\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/important_dir/file1.txt\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"critical data 2\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/important_dir/file2.txt\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Start a background operation that will be interrupted</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">seq</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        echo</span><span style=\"color:#9ECBFF\"> \"data </span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> >></span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/important_dir/growing_file.txt\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mkdir</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/dir_</span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    done</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">BG_OP_PID</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">$!</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Let the background operation run briefly, then simulate power failure</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sleep</span><span style=\"color:#79B8FF\"> 0.1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># CRASH: send SIGKILL (unclean shutdown â€” no destroy callback)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">kill</span><span style=\"color:#79B8FF\"> -9</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$FUSE_PID</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">kill</span><span style=\"color:#79B8FF\"> -9</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$BG_OP_PID</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">wait</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$FUSE_PID</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">wait</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$BG_OP_PID</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Unmount the broken FUSE endpoint</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">fusermount3</span><span style=\"color:#79B8FF\"> -u</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Simulated crash. Remounting for recovery...\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sleep</span><span style=\"color:#79B8FF\"> 0.5</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Phase 2: Mount again â€” journal_recover() runs automatically</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">$FS </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">$DISK</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> -s &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">FUSE_PID</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">$!</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sleep</span><span style=\"color:#79B8FF\"> 1.0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Recovery complete. Verifying filesystem consistency...\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check: files that were fully committed before crash must be intact</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">CONTENT1</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/important_dir/file1.txt\"</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> echo</span><span style=\"color:#9ECBFF\"> \"MISSING\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">CONTENT2</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/important_dir/file2.txt\"</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> echo</span><span style=\"color:#9ECBFF\"> \"MISSING\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">[ </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">$CONTENT1</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"critical data 1\"</span><span style=\"color:#E1E4E8\"> ] &#x26;&#x26; </span><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"OK: file1.txt intact\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ||</span><span style=\"color:#79B8FF\"> echo</span><span style=\"color:#9ECBFF\"> \"FAIL: file1.txt content wrong: '</span><span style=\"color:#E1E4E8\">$CONTENT1</span><span style=\"color:#9ECBFF\">'\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">[ </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">$CONTENT2</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"critical data 2\"</span><span style=\"color:#E1E4E8\"> ] &#x26;&#x26; </span><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"OK: file2.txt intact\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ||</span><span style=\"color:#79B8FF\"> echo</span><span style=\"color:#9ECBFF\"> \"FAIL: file2.txt content wrong: '</span><span style=\"color:#E1E4E8\">$CONTENT2</span><span style=\"color:#9ECBFF\">'\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check: no orphaned inodes (all allocated inodes have at least one directory reference)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># This would require a custom fsck tool; for now, verify basic mount works</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/null</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"OK: root directory accessible after recovery\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">/important_dir\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/null</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"OK: important_dir accessible after recovery\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check: df reports sane numbers (no negative free block counts)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">df</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> Filesystem</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> awk</span><span style=\"color:#9ECBFF\"> '{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    if ($4 &#x3C; 0) { print \"FAIL: negative free blocks\"; exit 1; }</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    else { print \"OK: block counts are sane\"; }</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">}'</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">fusermount3</span><span style=\"color:#79B8FF\"> -u</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MOUNT</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">wait</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$FUSE_PID</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"=== Crash Recovery Test Complete ===\"</span></span></code></pre></div>\n<hr>\n<h2 id=\"integrating-the-journal-into-mountunmount\">Integrating the Journal Into Mount/Unmount</h2>\n<p>The journal requires two additions to your FUSE lifecycle from Milestone 5:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Updated myfs_init: run journal recovery before serving requests.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">myfs_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> fuse_conn_info </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">conn</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        struct</span><span style=\"color:#E1E4E8\"> fuse_config </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">cfg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)conn;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cfg->entry_timeout    </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cfg->attr_timeout     </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cfg->negative_timeout </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.5</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cfg->use_ino          </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Load journal superblock */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">journal_load</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"FATAL: failed to load journal superblock</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* In production: abort mount. For development: continue with warning. */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Replay committed transactions from any prior crash */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">journal_recover</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"WARNING: journal recovery encountered errors</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Continue mounting â€” partial recovery is better than no mount */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Updated myfs_destroy: checkpoint journal before unmount.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> myfs_destroy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">private_data</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)private_data;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fs_lock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Checkpoint: ensure all committed transactions are in main structures */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    journal_checkpoint</span><span style=\"color:#E1E4E8\">(g_fs.fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.sb);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Final fsync to ensure checkpoint is durable */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fsync</span><span style=\"color:#E1E4E8\">(g_fs.fd);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(g_fs.fd);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_destroy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_fs.lock);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Note: fs_unlock() NOT called after mutex destroy */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"three-level-view-what-happens-during-txn_commit\">Three-Level View: What Happens During <code>txn_commit</code></h2>\n<p>Let&#39;s trace <code>txn_commit(&amp;txn)</code> for a two-block transaction (one inode update, one bitmap update):</p>\n<table>\n<thead>\n<tr>\n<th>Level</th>\n<th>What Happens</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Application (your code)</strong></td>\n<td>Calls <code>write_block(fd, desc_abs, desc_buf)</code> â€” writes 4KB descriptor. Calls <code>write_block(fd, data1_abs, inode_block)</code> â€” writes 4KB inode copy. Calls <code>write_block(fd, data2_abs, bitmap_block)</code> â€” writes 4KB bitmap copy. Calls <code>fsync(fd)</code>. Calls <code>write_block(fd, commit_abs, commit_buf)</code>. Calls <code>fsync(fd)</code>. Then writes inode block and bitmap block to actual locations. Final <code>fsync</code>.</td>\n</tr>\n<tr>\n<td><strong>OS / Kernel</strong></td>\n<td>First three <code>write_block</code> calls: data goes into kernel page cache (dirty pages). <code>fsync(fd)</code>: kernel submits all dirty pages for <code>fd</code> to the block layer in order, issues a FLUSH CACHE command to the disk. Waits for disk to confirm. Returns. Second set of <code>write_block</code> calls: page cache again. Second <code>fsync</code>: same sequence. Total: 5 dirty-page writes to page cache + 2 FLUSH CACHE commands to disk + 2 disk acknowledgments.</td>\n</tr>\n<tr>\n<td><strong>Hardware</strong></td>\n<td>First <code>fsync</code>: disk receives write commands for descriptor + data1 + data2 blocks. Disk schedules them (possibly reorders for efficiency within this batch). Disk flushes its write buffer to NAND (SSD) or commits rotational writes to platter (HDD). Disk sends ACK. The FLUSH CACHE command is the barrier: everything before it is durable before anything after it starts. Second <code>fsync</code>: same for commit block. The commit block is now on stable media â€” the transaction is committed.</td>\n</tr>\n<tr>\n<td>The critical asymmetry: within each <code>fsync</code> group, the disk may reorder writes freely. But no write in the second group (commit) can reach stable storage before the first <code>fsync</code> completes. That ordering at the <code>fsync</code> boundary is the entire mechanism.</td>\n<td></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"knowledge-cascade-one-journal-ten-domains\">Knowledge Cascade: One Journal, Ten Domains</h2>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-m6-wal-cross-domain.svg\" alt=\"WAL Everywhere â€” Filesystem Journal vs. Database WAL vs. Distributed Log\"></p>\n<h3 id=\"database-wal-the-identical-pattern\">Database WAL: The Identical Pattern</h3>\n<p>You just built the same crash recovery mechanism that every production database uses. The structural identity is exact:\n<strong>PostgreSQL WAL</strong>: PostgreSQL writes changes to WAL segments before applying them to heap pages. Each WAL record has a Log Sequence Number (LSN), analogous to your <code>j_sequence</code>. A &quot;checkpoint&quot; in PostgreSQL writes all dirty buffer pool pages to disk and records the checkpoint LSN â€” analogous to your <code>journal_checkpoint</code>. Recovery after a crash replays WAL from the last checkpoint LSN. The <code>pg_wal</code> directory in every PostgreSQL data directory is your journal region.\n<strong>SQLite WAL mode</strong>: SQLite&#39;s WAL file contains uncommitted changes. Readers see the database file (clean) plus any committed WAL entries. Writers append to the WAL. A checkpoint copies WAL entries to the main database file. The WAL <code>shm</code> (shared memory) file tracks which WAL frames are committed â€” analogous to your journal superblock&#39;s head/tail pointers.\n<strong>MySQL InnoDB redo log</strong>: InnoDB&#39;s <code>ib_logfile0</code> and <code>ib_logfile1</code> form a circular log (exactly like your journal region with wrap-around). The &quot;log sequence number&quot; is a monotonic 64-bit counter. Crash recovery reads from the last checkpoint LSN to the current write position and replays all redo log entries. The &quot;fuzzy checkpoint&quot; mechanism flushes dirty pages asynchronously and advances the checkpoint LSN â€” your <code>journal_checkpoint</code> in graduated form.\nThe concepts are identical at every level: transaction, sequence number, commit record, head pointer, tail pointer, replay, checkpoint. You have built the foundation that makes these systems&#39; crash consistency possible.</p>\n<h3 id=\"redis-aof-durability-vs-performance\">Redis AOF: Durability vs. Performance</h3>\n<p>Redis Append-Only File (AOF) is a write-ahead log for an in-memory database. Every write command (<code>SET</code>, <code>LPUSH</code>, <code>ZADD</code>) is appended to the AOF file before the in-memory data structure is modified. On restart, Redis replays the AOF from the beginning to reconstruct state.\nThe AOF has three durability modes: <code>always</code> (fsync after every command â€” maximum durability, lowest performance), <code>everysec</code> (fsync once per second â€” at most one second of data loss on crash), and <code>no</code> (let the OS flush â€” maximum performance, OS controls durability). These map directly to the tradeoff your journal exposes:</p>\n<ul>\n<li><code>always</code> = your protocol with <code>fsync</code> after every transaction</li>\n<li><code>everysec</code> = batch transactions, fsync once per second (amortize fsync cost across many operations)</li>\n<li><code>no</code> = skip fsync (fast but loses data on crash)\nThe <code>everysec</code> mode trades one second of potential data loss for dramatically higher throughput â€” relevant whenever the cost of the <code>fsync</code> dominates transaction latency. For your filesystem, you could implement a similar optimization: buffer multiple transactions in the journal and fsync once per 100ms, accepting that a crash loses at most 100ms of committed transactions.</li>\n</ul>\n<h3 id=\"raft-and-distributed-wal\">Raft and Distributed WAL</h3>\n<p>[[EXPLAIN:raft-consensus-algorithm-â€”-replicated-state-machine-using-a-replicated-log|Raft consensus algorithm â€” achieving crash-consistent agreement across multiple nodes by replicating a write-ahead log]]\nSingle-node WAL is the foundation for understanding distributed consensus. The Raft consensus algorithm â€” used in etcd (Kubernetes&#39; database), CockroachDB, TiKV, and Consul â€” is fundamentally a distributed WAL with the additional constraint that the commit record requires a quorum of nodes to acknowledge receipt.\nIn Raft:</p>\n<ul>\n<li>Your <code>txn_begin</code> = Raft leader receives a client request</li>\n<li>Your <code>txn_journal_block</code> = Raft leader appends the log entry (with index and term)</li>\n<li>Your first <code>fsync</code> = the leader flushes the log to its local disk AND sends AppendEntries RPC to followers</li>\n<li>The &quot;majority acknowledgment&quot; = equivalent to your commit <code>fsync</code> â€” the transaction cannot be lost because a majority of nodes have it durably</li>\n<li>Your <code>apply</code> (writing blocks to final locations) = Raft&#39;s &quot;apply to state machine&quot; (updating key-value store, etc.)\nThe crash recovery protocol in Raft mirrors your journal recovery: a new leader scans committed log entries and re-applies any that may not have reached the state machine. The idempotency requirement is identical: applying the same log entry twice must produce the same state as applying it once.\nUnderstanding your single-node journal makes Raft&#39;s log replication intuitive rather than mysterious. The &quot;distributed&quot; part adds leader election and quorum logic; the &quot;WAL&quot; part is exactly what you built.</li>\n</ul>\n<h3 id=\"fsync-and-the-durability-api\"><code>fsync</code> and the Durability API</h3>\n<p>Understanding the journal explains every <code>fsync</code>-related performance complaint you will ever encounter.\n[[EXPLAIN:fsync-vs-fdatasync-â€”-the-difference-between-flushing-metadata-and-data|fsync vs. fdatasync â€” fsync flushes both data and metadata (file size, modification time); fdatasync flushes only data, skipping metadata unless required for correct reads]]\nThe classic complaint: &quot;why is my database write throughput only 1,000 writes/second on an SSD rated for 100,000 IOPS?&quot; The answer: the database calls <code>fsync</code> (or <code>fdatasync</code>) after every committed transaction to ensure durability. Each <code>fsync</code> requires a FLUSH CACHE command to the SSD, which takes 100Î¼sâ€“1ms depending on the device and its write buffer state. At 1ms per fsync, maximum throughput is 1,000 fsyncs/second. The SSD&#39;s rated IOPS don&#39;t matter â€” the bottleneck is the barrier cost, not the raw write speed.\nSolutions used in production:</p>\n<ul>\n<li><strong>Group commit</strong>: buffer multiple transactions, fsync once. PostgreSQL&#39;s <code>synchronous_commit = on</code> with multiple concurrent writers naturally groups their commits into one WAL flush.</li>\n<li><strong>Write-ahead log on separate device</strong>: put the WAL on a dedicated SSD with power-loss protection capacitors (enterprise SSDs). These devices guarantee that all data in the write buffer survives a power failure, so <code>fsync</code> returns immediately after the buffer accepts the write.</li>\n<li><strong>Battery-backed write cache</strong>: RAID controllers with BBU (Battery Backup Unit) can acknowledge <code>fsync</code> as soon as data enters the cache â€” the battery ensures the cache survives power loss long enough to flush to disk.</li>\n<li><strong>Ordered writes without fsync</strong> (dangerous): some applications skip <code>fsync</code> entirely and rely on the OS page cache writeback ordering being &quot;good enough.&quot; This works until it doesn&#39;t â€” any crash during a multi-block operation can corrupt the data structure. This is what your journal was invented to prevent.</li>\n</ul>\n<h3 id=\"copy-on-write-eliminating-journaling39s-complexity\">Copy-on-Write: Eliminating Journaling&#39;s Complexity</h3>\n<p>Understanding why journaling is complex motivates understanding why ZFS and Btrfs chose a completely different architecture.\nIn a copy-on-write (CoW) filesystem, a write to a block never modifies the existing block. Instead:</p>\n<ol>\n<li>Allocate a new block</li>\n<li>Write new content to the new block</li>\n<li>Update the parent pointer (in the inode or B-tree node) to point to the new block</li>\n<li>The old block is now unreferenced â€” free it\nThe atomic operation is step 3: a single pointer update. If the system crashes before the pointer update, the old block is still intact (the old pointer still points to it). If it crashes after, the new pointer is valid. The intermediate state â€” &quot;new block written but pointer not yet updated&quot; â€” is always safe: the new block is unreferenced, and the old block is still the live version.\nCoW extends this: updating the inode requires writing a new inode block (step 3 for the parent of the block pointer). Updating the inode block requires updating the inode table block. This cascades all the way to the filesystem&#39;s root block â€” called the &quot;tree root&quot; or &quot;uberblock&quot; in ZFS. The final atomic write is the uberblock update: a single 4KB write that atomically commits the entire set of changes. If the uberblock write succeeds, the entire transaction is committed. If it fails, the old uberblock is still valid.\nThe price: <strong>every write fragments the filesystem</strong>, because writes never go to the same location twice. Over time, a CoW filesystem&#39;s data becomes highly fragmented. ZFS handles this with its pool-level allocation, spread across many disks. Btrfs requires periodic <code>btrfs balance</code> runs to defragment. The CoW design trades journaling complexity for fragmentation management complexity â€” a different tradeoff, not a free lunch.\nNow you understand WHY both approaches exist: journaling gives you the performance of in-place writes at the cost of maintaining a separate write path (the journal); CoW eliminates the journal at the cost of fragmentation and more complex space management. Neither is universally superior.</li>\n</ol>\n<h3 id=\"fsck-the-pre-journal-alternative\">fsck: The Pre-Journal Alternative</h3>\n<p>Before journaling, the only recovery mechanism was <code>fsck</code> (filesystem check). On an unclean mount (power failure, crash), <code>fsck</code> would scan every inode in the inode table, every directory block, and every bitmap block to verify consistency. It would detect:</p>\n<ul>\n<li>Inode with nlinks &gt; 0 but no directory entry referencing it (orphaned inode) â†’ move to <code>lost+found</code></li>\n<li>Block marked used in bitmap but not referenced by any inode (leaked block) â†’ mark free</li>\n<li>Block referenced by an inode but marked free in bitmap (double allocation) â†’ dangerous â€” usually requires user intervention</li>\n<li>Directory entry referencing an invalid inode number â†’ remove the entry\nThe time complexity of <code>fsck</code> is O(filesystem size) â€” it must read every metadata block. On a 10TB filesystem at 500MB/s: 20TB of metadata reads Ã· 500MB/s = ~11 hours minimum. In practice, because metadata is scattered (bitmaps are sequential but inode table and directory blocks are random-access), the actual time is much longer on spinning disks due to seek overhead.\nJournaling reduces recovery to O(journal size). The journal is typically 64MBâ€“1GB, readable in under a second on modern SSDs. This is the quantitative argument for journaling: not correctness (fsck achieves correctness eventually), but the difference between 10ms recovery and 10 hours recovery.\nYour <code>journal_recover</code> function is the alternative to running <code>fsck</code> after every unclean mount. The guarantee: after <code>journal_recover</code> completes, the filesystem is in exactly the state it would be in if the committed transactions had been applied cleanly. No scanning, no heuristics, no <code>lost+found</code>.</li>\n</ul>\n<hr>\n<h2 id=\"before-you-move-on-pitfall-checklist\">Before You Move On: Pitfall Checklist</h2>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Two <code>fsync</code> calls per commit, in order</strong>: First <code>fsync</code> after journal data writes (before commit block). Second <code>fsync</code> after commit block write. Remove either one and the crash consistency guarantee is broken. Verify by adding a <code>sleep(1)</code> between the first and second <code>fsync</code> and simulating a crash â€” you should see the transaction treated as aborted on recovery.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Commit record in one atomic write</strong>: The commit block must be written in a single <code>write_block</code> call (one 4KB block write). A commit record that spans multiple block writes is not atomic â€” a crash mid-write produces a partial commit record that your recovery code must detect and discard. Your <code>journal_commit_t</code> is 4KB and written atomically. Verify: the magic number check at the start of the block is your signal that the block is a valid, complete commit record.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Idempotent operations â€” no delta records</strong>: Journal entries record the final state of each block, not deltas (&quot;increment by 1&quot;). Verify: write two identical <code>txn_journal_block</code> calls for the same block with the same data. The second call should update the in-transaction copy (deduplication). Replaying the same transaction twice must produce the same filesystem state. Add a test that calls <code>journal_recover</code> twice on the same committed journal and checks that the second recovery produces no changes.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Circular journal wrap-around</strong>: The <code>journal_abs_block</code> function must correctly wrap around. Test: format a filesystem with <code>journal_blocks = 16</code> (very small journal). Write 20 transactions. Verify that the journal pointer wraps and older transactions are correctly checkpointed before being overwritten. An off-by-one in the wrap-around calculation causes either early wrap (losing live journal entries) or failure to wrap (writing past journal bounds into data blocks).</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Journal recovery before accepting FUSE requests</strong>: <code>journal_recover</code> must complete before <code>myfs_init</code> returns. If FUSE starts serving requests while recovery is in progress, operations may observe partially replayed state. The <code>myfs_init</code> function is called before FUSE starts the event loop â€” recovery there is safe and correct.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Checkpoint before journal full</strong>: If the journal fills (no space for a new transaction), your <code>txn_commit</code> must either block or force an immediate checkpoint. An undetected full-journal condition causes <code>txn_commit</code> to overwrite live journal entries (unrecovered committed transactions) with new transaction data. Add a <code>blocks_needed &gt; journal_free</code> check in <code>txn_commit</code> and trigger <code>journal_checkpoint</code> proactively.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Metadata-only: <code>fsync</code> data before journaling inode</strong>: In ordered metadata journaling mode, always write and fsync the file&#39;s data blocks BEFORE journaling the inode that points to them. If the inode is journaled first and you crash before the data write, recovery replays the inode update but the data block contains garbage from a previous file. The ordering: data write â†’ data fsync â†’ journal inode update â†’ journal commit.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Do not journal data blocks</strong>: Block bitmap updates and inode table blocks are metadata â€” journal them. File data blocks (blocks in the data region pointed to by inodes) are not metadata â€” do not journal them. Journaling data doubles write amplification. Verify: in your transaction&#39;s <code>block_nums</code> array, no entry should have a value â‰¥ <code>sb-&gt;data_block_start</code> unless it is a directory data block (which IS metadata).</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Checksum validation in recovery</strong>: Your recovery code validates the commit block&#39;s checksum against the data blocks. A corrupted journal entry (partial write of a data block due to torn write) should be detected by checksum mismatch and discarded. Verify: flip a single bit in a journaled data block before writing the commit record, then run recovery and confirm the transaction is discarded rather than replayed with corrupt data.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Superblock update in transactions</strong>: Any operation that modifies <code>sb-&gt;free_blocks</code> or <code>sb-&gt;free_inodes</code> must journal the superblock block (block 0) as part of that transaction. An uncommitted superblock update that survives a crash will show incorrect free counts, causing <code>ENOSPC</code> errors when space is actually available or allocating blocks that the free count says don&#39;t exist.</li>\n</ul>\n<hr>\n<h2 id=\"what-you39ve-built-and-what-it-means\">What You&#39;ve Built and What It Means</h2>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fdiag-L0-satellite-map.svg\" alt=\"Filesystem Atlas â€” Satellite Map (Home Base)\"></p>\n<h2 id=\"you-have-completed-the-filesystem-not-a-toy-a-crash-consistent-journaled-filesystem-that-can-be-trusted-with-real-data-the-chain-is-complete-raw-block-device-abstraction-bitmap-based-allocation-inode-metadata-with-multi-level-indirection-directory-entries-and-path-resolution-file-readwrite-with-sparse-file-support-fuse-integration-for-real-os-mounting-and-now-write-ahead-journaling-for-crash-consistency-step-back-and-look-at-what-you-understand-now-that-you-did-not-before-this-milestone-you-understand-why-databases-call-fsync-you-understand-why-skipping-fsync-loses-data-you-understand-why-postgresql-has-wal-segments-why-sqlite-has-a-wal-file-why-mysql-has-redo-logs-they-are-all-solving-the-same-problem-you-just-solved-making-multi-step-metadata-updates-atomic-despite-non-atomic-hardware-despite-os-write-reordering-despite-disk-write-buffer-reordering-the-journal-is-not-a-database-invention-it-is-a-universal-pattern-for-crash-consistency-you-understand-why-zfs-never-needs-fsck-you-understand-why-ext439s-dir_index-feature-requires-a-journal-aware-implementation-the-b-tree-restructuring-touches-multiple-blocks-that-must-be-atomic-you-understand-why-ntfs-has-a-logfile-you-understand-why-every-serious-storage-system-from-sqlite-to-kafka-to-etcd-maintains-a-sequential-write-ahead-log-as-its-first-and-most-fundamental-data-structure-the-disk-does-not-know-you-exist-but-now-you-know-how-to-make-it-remember-exactly-what-you-committed-and-nothing-more\">You have completed the filesystem. Not a toy â€” a crash-consistent, journaled filesystem that can be trusted with real data. The chain is complete: raw block device abstraction, bitmap-based allocation, inode metadata with multi-level indirection, directory entries and path resolution, file read/write with sparse file support, FUSE integration for real OS mounting, and now write-ahead journaling for crash consistency.\nStep back and look at what you understand now that you did not before this milestone.\nYou understand why databases call <code>fsync</code>. You understand why skipping <code>fsync</code> loses data. You understand why PostgreSQL has WAL segments, why SQLite has a WAL file, why MySQL has redo logs â€” they are all solving the same problem you just solved: making multi-step metadata updates atomic despite non-atomic hardware, despite OS write reordering, despite disk write buffer reordering. The journal is not a database invention. It is a universal pattern for crash consistency.\nYou understand why ZFS never needs <code>fsck</code>. You understand why ext4&#39;s <code>dir_index</code> feature requires a journal-aware implementation (the B-tree restructuring touches multiple blocks that must be atomic). You understand why NTFS has a <code>$LogFile</code>. You understand why every serious storage system â€” from SQLite to Kafka to etcd â€” maintains a sequential write-ahead log as its first and most fundamental data structure.\nThe disk does not know you exist. But now you know how to make it remember exactly what you committed â€” and nothing more.</h2>\n<!-- END_MS -->\n\n\n<h2 id=\"system-overview\">System Overview</h2>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Fsystem-overview.svg\" alt=\"System Overview\"></p>\n<h1 id=\"tdd\">TDD</h1>\n<p>A ground-up inode-based filesystem built in six layered milestones, each milestone a self-contained module with explicit hardware constraints, byte-level memory layouts, and crash-consistency guarantees. Every module is designed so an engineer can open it, read the diagrams, and begin implementation without ambiguity. The architecture negotiates the fundamental tension between byte-addressable software abstractions and block-addressable hardware reality at every layer.</p>\n<!-- TDD_MOD_ID: filesystem-m1 -->\n<h1 id=\"module-technical-design-specification-block-layer-and-mkfs-filesystem-m1\">Module Technical Design Specification: Block Layer and mkfs (filesystem-m1)</h1>\n<h2 id=\"1-module-charter\">1. Module Charter</h2>\n<p>The <strong>Block Layer and mkfs</strong> module serves as the foundational substrate for the entire filesystem. Its primary responsibility is to provide a reliable block-level I/O abstraction over a flat file (disk image) and to establish the physical on-disk layout required for higher-level metadata structures. </p>\n<p><strong>Scope:</strong></p>\n<ul>\n<li>Implements <code>read_block</code> and <code>write_block</code> primitives with strict 4KB alignment.</li>\n<li>Defines the <code>superblock_t</code> structure and its exact byte-level serialization.</li>\n<li>Implements bit-level allocation tracking (bitmaps) for data blocks and inodes.</li>\n<li>Provides a formatting tool (<code>mkfs</code>) to initialize a disk image with a valid root directory.</li>\n</ul>\n<p><strong>Out of Scope:</strong></p>\n<ul>\n<li>Multi-level inode pointer traversal (Milestone 2).</li>\n<li>Directory entry management beyond the initial root creation (Milestone 3).</li>\n<li>Write-ahead journaling logic (Milestone 6), though space is reserved.</li>\n<li>In-memory buffer caching (all I/O is direct to/from the host OS page cache).</li>\n</ul>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>Every disk operation must occur in units of exactly 4096 bytes.</li>\n<li>Block 0 is always the Superblock; it can never be allocated for data.</li>\n<li>The block bitmap only tracks blocks in the &quot;Data Region&quot;; bit 0 of the bitmap corresponds to the first block of the data region.</li>\n<li>All on-disk structures must be little-endian and packed (no compiler padding).</li>\n</ul>\n<hr>\n<h2 id=\"2-file-structure\">2. File Structure</h2>\n<p>The implementation follows a strict creation order to ensure dependencies are met:</p>\n<ol>\n<li><code>fs_types.h</code>: Constant definitions (Magic numbers, block sizes, region offsets).</li>\n<li><code>block_io.h / block_io.c</code>: Low-level <code>lseek/read/write</code> wrappers.</li>\n<li><code>bitmap.h / bitmap.c</code>: Bit-level manipulation and search logic.</li>\n<li><code>superblock.h / superblock.c</code>: Layout calculation and serialization.</li>\n<li><code>mkfs.c</code>: The standalone CLI tool for image initialization.</li>\n<li><code>test_m1.c</code>: Verification suite for the block layer.</li>\n</ol>\n<hr>\n<h2 id=\"3-complete-data-model\">3. Complete Data Model</h2>\n<h3 id=\"31-superblock-superblock_t\">3.1. Superblock (superblock_t)</h3>\n<p>The Superblock is the &quot;Birth Certificate&quot; of the filesystem. It resides at byte offset 0.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Offset</th>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0x00</td>\n<td align=\"left\"><code>s_magic</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Magic Number (0xDEADC0DE).</td>\n</tr>\n<tr>\n<td align=\"left\">0x04</td>\n<td align=\"left\"><code>s_version</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Filesystem version (default 1).</td>\n</tr>\n<tr>\n<td align=\"left\">0x08</td>\n<td align=\"left\"><code>s_block_size</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Always 4096. Used for validation.</td>\n</tr>\n<tr>\n<td align=\"left\">0x0C</td>\n<td align=\"left\"><code>s_total_blocks</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Total size of the image in blocks.</td>\n</tr>\n<tr>\n<td align=\"left\">0x10</td>\n<td align=\"left\"><code>s_total_inodes</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Total capacity of the inode table.</td>\n</tr>\n<tr>\n<td align=\"left\">0x14</td>\n<td align=\"left\"><code>s_free_blocks</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Current count of unallocated data blocks.</td>\n</tr>\n<tr>\n<td align=\"left\">0x18</td>\n<td align=\"left\"><code>s_free_inodes</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Current count of unallocated inodes.</td>\n</tr>\n<tr>\n<td align=\"left\">0x1C</td>\n<td align=\"left\"><code>s_inode_bmap_start</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Block index for Inode Bitmap (usually 1).</td>\n</tr>\n<tr>\n<td align=\"left\">0x20</td>\n<td align=\"left\"><code>s_block_bmap_start</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Block index for Block Bitmap (usually 2).</td>\n</tr>\n<tr>\n<td align=\"left\">0x24</td>\n<td align=\"left\"><code>s_inode_table_start</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">First block of the Inode Table.</td>\n</tr>\n<tr>\n<td align=\"left\">0x28</td>\n<td align=\"left\"><code>s_inode_table_len</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Number of blocks in the Inode Table.</td>\n</tr>\n<tr>\n<td align=\"left\">0x2C</td>\n<td align=\"left\"><code>s_journal_start</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">First block of the Journal region.</td>\n</tr>\n<tr>\n<td align=\"left\">0x30</td>\n<td align=\"left\"><code>s_journal_len</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Number of blocks reserved for Journal.</td>\n</tr>\n<tr>\n<td align=\"left\">0x34</td>\n<td align=\"left\"><code>s_data_region_start</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">First block available for file data.</td>\n</tr>\n<tr>\n<td align=\"left\">0x38</td>\n<td align=\"left\"><code>s_root_inode</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Inode number of the root directory (usually 1).</td>\n</tr>\n<tr>\n<td align=\"left\">0x3C</td>\n<td align=\"left\"><code>s_reserved</code></td>\n<td align=\"left\"><code>uint8_t[4036]</code></td>\n<td align=\"left\">Padding to reach exactly 4096 bytes.</td>\n</tr>\n</tbody></table>\n<h3 id=\"32-inode-stub-inode_t\">3.2. Inode Stub (inode_t)</h3>\n<p>A minimal definition required for <code>mkfs</code> to initialize the root directory. Full implementation occurs in M2.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> INODE_SIZE</span><span style=\"color:#79B8FF\"> 128</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> N_DIRECT</span><span style=\"color:#79B8FF\"> 12</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#B392F0\"> __attribute__</span><span style=\"color:#E1E4E8\">((packed)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> i_mode;</span><span style=\"color:#6A737D\">          // 0x00: File type + permissions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> i_nlinks;</span><span style=\"color:#6A737D\">        // 0x02: Hard link count</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> i_size;</span><span style=\"color:#6A737D\">          // 0x04: File size in bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> i_atime;</span><span style=\"color:#6A737D\">         // 0x08: Access time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> i_mtime;</span><span style=\"color:#6A737D\">         // 0x0C: Modification time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> i_ctime;</span><span style=\"color:#6A737D\">         // 0x10: Metadata change time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#FFAB70\"> i_blocks</span><span style=\"color:#E1E4E8\">[N_DIRECT];</span><span style=\"color:#6A737D\"> // 0x14: Direct block pointers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> i_single_ind;</span><span style=\"color:#6A737D\">    // 0x44: Single indirect pointer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> i_double_ind;</span><span style=\"color:#6A737D\">    // 0x48: Double indirect pointer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\">  i_pad</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">52</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">       // Padding to 128 bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">inode_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"4-interface-contracts\">4. Interface Contracts</h2>\n<h3 id=\"41-block-io-layer\">4.1. Block I/O Layer</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Reads a 4KB block from the disk image.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#6A737D\"> Open file descriptor to the image.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> block_num</span><span style=\"color:#6A737D\"> Logical block index (0 to s_total_blocks - 1).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#6A737D\"> Destination buffer (must be at least 4096 bytes).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@return</span><span style=\"color:#6A737D\"> 0 on success, -EIO on short read, -EINVAL on bounds error.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> read_block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> block_num</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Writes a 4KB block to the disk image.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#6A737D\"> Open file descriptor.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> block_num</span><span style=\"color:#6A737D\"> Logical block index.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#6A737D\"> Source buffer.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@return</span><span style=\"color:#6A737D\"> 0 on success, -EIO on short write.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> write_block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> block_num</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<h3 id=\"42-bitmap-allocator\">4.2. Bitmap Allocator</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Allocates a data block from the free block bitmap.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@return</span><span style=\"color:#6A737D\"> The absolute disk block number, or -ENOSPC if full.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@note</span><span style=\"color:#6A737D\"> Triggers a read-modify-write on the bitmap block.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> alloc_data_block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Frees a data block and updates the bitmap.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> block_num</span><span style=\"color:#6A737D\"> Absolute disk block address.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> free_data_block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> block_num</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"5-algorithm-specification\">5. Algorithm Specification</h2>\n<h3 id=\"51-on-disk-layout-computation\">5.1. On-Disk Layout Computation</h3>\n<p>During <code>mkfs</code>, the regions must be calculated based on user-provided counts.</p>\n<ol>\n<li><strong>Block 0</strong>: Superblock.</li>\n<li><strong>Block 1</strong>: Inode Bitmap. Size: 1 block (supports up to 32,768 inodes).</li>\n<li><strong>Block 2</strong>: Block Bitmap. Size: 1 block (supports up to 32,768 data blocks).</li>\n<li><strong>Inode Table</strong>: Starts at Block 3. <ul>\n<li><code>table_blocks = (total_inodes * INODE_SIZE + BLOCK_SIZE - 1) / BLOCK_SIZE</code>.</li>\n</ul>\n</li>\n<li><strong>Journal Region</strong>: Starts at <code>3 + table_blocks</code>. <ul>\n<li>Default size: 1024 blocks (4MB).</li>\n</ul>\n</li>\n<li><strong>Data Region</strong>: Starts at <code>journal_start + journal_len</code>.<ul>\n<li>Total usable data blocks = <code>total_blocks - data_region_start</code>.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"52-bitmap-search-bitmap_find_free\">5.2. Bitmap Search (<code>bitmap_find_free</code>)</h3>\n<p>To minimize CPU cycles, the search should be byte-aligned before checking bits.</p>\n<ol>\n<li>Iterate through the 4096 bytes of the bitmap buffer.</li>\n<li>If <code>byte[i] == 0xFF</code>, skip (all 8 bits in this byte are used).</li>\n<li>If <code>byte[i] &lt; 0xFF</code>, find the first zero bit using <code>__builtin_ctz(~byte[i])</code> or a manual loop.</li>\n<li>Calculate <code>index = i * 8 + bit_position</code>.</li>\n<li>Ensure <code>index &lt; tracked_items_limit</code>.</li>\n<li>Return <code>index</code>.</li>\n</ol>\n<h3 id=\"53-root-directory-initialization\">5.3. Root Directory Initialization</h3>\n<p><code>mkfs</code> must create a valid <code>/</code> to make the disk mountable.</p>\n<ol>\n<li>Allocate Inode 1 (Bit 0 in Inode Bitmap).</li>\n<li>Allocate Data Block 0 (Bit 0 in Block Bitmap).</li>\n<li>Initialize <code>inode_t</code> for root: <code>mode = S_IFDIR | 0755</code>, <code>nlinks = 2</code>, <code>size = 4096</code>, <code>blocks[0] = s_data_region_start</code>.</li>\n<li>Write two directory entries to the first data block: <code>.</code> pointing to Inode 1, <code>..</code> pointing to Inode 1.</li>\n<li>Update Superblock <code>free_blocks</code> and <code>free_inodes</code>.</li>\n</ol>\n<hr>\n<h2 id=\"6-error-handling-matrix\">6. Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error</th>\n<th align=\"left\">Detected By</th>\n<th align=\"left\">Recovery</th>\n<th align=\"left\">User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>EINVAL</code></td>\n<td align=\"left\"><code>read_block</code></td>\n<td align=\"left\">Reject operation; do not seek.</td>\n<td align=\"left\">Yes (API return)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EIO</code></td>\n<td align=\"left\"><code>write_block</code></td>\n<td align=\"left\">Image file might be read-only or disk full.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ENOSPC</code></td>\n<td align=\"left\"><code>alloc_data_block</code></td>\n<td align=\"left\">Fail file creation or write.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\">Magic Mismatch</td>\n<td align=\"left\"><code>main/mount</code></td>\n<td align=\"left\">Refuse to mount; protect data.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\">Short Write</td>\n<td align=\"left\"><code>write_block</code></td>\n<td align=\"left\">Attempt <code>fsync</code>; if still short, return <code>EIO</code>.</td>\n<td align=\"left\">Yes</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"7-implementation-sequence-with-checkpoints\">7. Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-block-io-bedrock-2-hours\">Phase 1: Block I/O Bedrock (2 Hours)</h3>\n<p>Implement <code>read_block</code>, <code>write_block</code>, and <code>validate_block_num</code>. Create a small test utility that opens a file, writes &quot;DEADBEEF&quot; to block 5, and reads it back.\n<strong>Checkpoint:</strong> <code>block_test disk.img</code> successfully writes/reads block 5.</p>\n<h3 id=\"phase-2-serialization-amp-layout-3-hours\">Phase 2: Serialization &amp; Layout (3 Hours)</h3>\n<p>Define <code>superblock_t</code> with <code>__attribute__((packed))</code>. Implement <code>compute_layout</code>. Write a small tool to print where regions would live for a 100MB disk.\n<strong>Checkpoint:</strong> <code>layout_calc 100MB</code> prints <code>Data Region starts at block 1059</code>.</p>\n<h3 id=\"phase-3-the-allocator-3-hours\">Phase 3: The Allocator (3 Hours)</h3>\n<p>Implement <code>bitmap_find_free</code> and the <code>alloc/free</code> wrappers.\n<strong>Checkpoint:</strong> <code>test_alloc</code> allocates 10 blocks, verifies bits are set in the bitmap block, frees 5, and verifies bits are cleared.</p>\n<h3 id=\"phase-4-mkfs-5-hours\">Phase 4: mkfs (5 Hours)</h3>\n<p>Combine all logic into <code>mkfs.c</code>. It must:</p>\n<ol>\n<li>Create the file.</li>\n<li>Write the Superblock.</li>\n<li>Zero out the bitmaps and inode table.</li>\n<li>Manually inject the Root Inode and its first Data Block.\n<strong>Checkpoint:</strong> <code>hexdump -C disk.img</code> shows <code>DE AD C0 DE</code> at offset 0 and the string <code>.</code> at the start of the data region.</li>\n</ol>\n<hr>\n<h2 id=\"8-test-specification\">8. Test Specification</h2>\n<h3 id=\"81-happy-path-formatting\">8.1. Happy Path: Formatting</h3>\n<ul>\n<li><strong>Input</strong>: <code>mkfs disk.img 4096 1024</code></li>\n<li><strong>Assertion</strong>: File size is exactly 16,777,216 bytes. Superblock fields match calculated layout. Root inode (Inode 1) has <code>nlinks == 2</code>.</li>\n</ul>\n<h3 id=\"82-edge-case-boundary-allocation\">8.2. Edge Case: Boundary Allocation</h3>\n<ul>\n<li><strong>Input</strong>: Allocate blocks until <code>alloc_data_block</code> returns <code>-ENOSPC</code>.</li>\n<li><strong>Assertion</strong>: Number of successful allocations must exactly equal <code>s_total_blocks - s_data_region_start</code>.</li>\n</ul>\n<h3 id=\"83-failure-case-invalid-mount\">8.3. Failure Case: Invalid Mount</h3>\n<ul>\n<li><strong>Input</strong>: Point a mock mount function to a text file.</li>\n<li><strong>Assertion</strong>: Function returns <code>-EINVAL</code> because magic number <code>0xDEADC0DE</code> is not found at offset 0.</li>\n</ul>\n<hr>\n<h2 id=\"9-performance-targets\">9. Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target</th>\n<th align=\"left\">Measurement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Block Write Latency</td>\n<td align=\"left\">&lt; 200Î¼s (SSD)</td>\n<td align=\"left\"><code>clock_gettime</code> around <code>write_block</code></td>\n</tr>\n<tr>\n<td align=\"left\">Bitmap Scan</td>\n<td align=\"left\">&lt; 500ns</td>\n<td align=\"left\">Benchmark <code>bitmap_find_free</code> with 32k bits set</td>\n</tr>\n<tr>\n<td align=\"left\">mkfs Throughput</td>\n<td align=\"left\">&gt; 100 MB/s</td>\n<td align=\"left\">Format a 1GB image; time the process</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"10-hardware-soul-cache-amp-alignment\">10. Hardware Soul (Cache &amp; Alignment)</h2>\n<ol>\n<li><strong>Cache Line Alignment</strong>: The <code>superblock_t</code> is 4096 bytes. When read into memory, it spans exactly 64 cache lines (assuming 64B lines). The &quot;hot&quot; fields (magic, free counts) are at the start of the first cache line.</li>\n<li><strong>TLB Impact</strong>: Because our block size matches the x86-64 page size (4KB), every <code>read_block</code> into a page-aligned buffer minimizes TLB misses during the <code>memcpy</code> or syscall transition.</li>\n<li><strong>Read-Modify-Write</strong>: <code>alloc_data_block</code> fetches one 4KB block (the bitmap). This block resides in the host OS Page Cache. Subsequent allocations within the same 32,768-block range will result in Page Cache hits, avoiding physical disk I/O until the kernel flushes dirty pages.</li>\n</ol>\n<hr>\n<h3 id=\"\"></h3>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Ftdd-diag-1.svg\" alt=\"Block Device Abstraction â€” read_block/write_block Data Flow\"></p>\n<p><strong>Logical to Physical Mapping in mkfs</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">text</span><pre class=\"arch-pre shiki-highlighted\"><code>[Disk Image File]\n|\n|-- [Block 0: Superblock] (4KB)\n|-- [Block 1: Inode Bitmap] (4KB)\n|-- [Block 2: Block Bitmap] (4KB)\n|-- [Block 3 to N: Inode Table] (Variable)\n|-- [Block N+1 to M: Journal] (Default 4MB)\n|-- [Block M+1 to End: Data Region] (Usable blocks)</code></pre></div>\n\n<h3 id=\"\"></h3>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Ftdd-diag-2.svg\" alt=\"On-Disk Layout â€” Complete Block Map\"></p>\n<p><strong>Bitmap Bit Manipulation</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">text</span><pre class=\"arch-pre shiki-highlighted\"><code>Byte Index = bit_index / 8\nBit Mask   = 1 &lt;&lt; (bit_index % 8)\n\n[00001011]  &lt;- Byte 0\n ^   ^  ^\n |   |  bit 0 (Used)\n |   bit 3 (Used)\n bit 7 (Free)</code></pre></div>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: filesystem-m2 -->\n<h1 id=\"module-technical-design-specification-inode-management-filesystem-m2\">Module Technical Design Specification: Inode Management (filesystem-m2)</h1>\n<h2 id=\"1-module-charter\">1. Module Charter</h2>\n<p>The <strong>Inode Management</strong> module is the structural heart of the filesystem. It defines the identity and data-mapping capability of every file and directory in the system. While the Block Layer (M1) provides raw containers, this module provides the hierarchical pointer machinery required to transform those containers into variable-sized, addressable files.</p>\n<p><strong>Scope:</strong></p>\n<ul>\n<li>Definition and serialization of the 128-byte <code>inode_t</code> structure.</li>\n<li>Implementation of the multi-level block pointer tree (Direct, Single-Indirect, Double-Indirect).</li>\n<li>Logic for logical-to-physical block translation (<code>inode_get_block</code>).</li>\n<li>On-demand allocation of indirect blocks during file growth (<code>inode_set_block</code>).</li>\n<li>Atomic-style inode allocation from bitmaps and recursive, bottom-up deallocation of entire pointer trees.</li>\n<li>Enforcement of sparse file semantics where unallocated regions (holes) are represented by null pointers.</li>\n</ul>\n<p><strong>Out of Scope:</strong></p>\n<ul>\n<li>Directory entry parsing or path-to-inode resolution (Milestone 3).</li>\n<li>Moving actual file data bytes (Milestone 4).</li>\n<li>Cache management or buffer pooling.</li>\n</ul>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>Inode numbers are 1-based; Inode 0 is strictly reserved as a NULL/Invalid sentinel.</li>\n<li>A block pointer value of <code>0</code> always represents a sparse hole; it must never point to the Superblock (Block 0).</li>\n<li>Recursive deallocation must free data blocks before freeing the indirect blocks that point to them to avoid orphaning.</li>\n<li>Any modification to an inode&#39;s pointer tree requires an update to the inode&#39;s <code>i_ctime</code>.</li>\n</ul>\n<hr>\n<h2 id=\"2-file-structure\">2. File Structure</h2>\n<p>Implementation follows the recursive complexity of the pointer tree:</p>\n<ol>\n<li><code>inode.h</code>: Definition of <code>inode_t</code>, constants for limits, and function prototypes.</li>\n<li><code>inode_io.c</code>: Serialization logic (<code>read_inode</code>, <code>write_inode</code>) and table offset math.</li>\n<li><code>inode_alloc.c</code>: Bitmap integration for <code>alloc_inode</code> and basic <code>free_inode</code>.</li>\n<li><code>inode_tree.c</code>: The core traversal engine (<code>inode_get_block</code>, <code>inode_set_block</code>).</li>\n<li><code>inode_free_recursive.c</code>: Depth-first traversal for full tree reclamation.</li>\n<li><code>test_m2.c</code>: Comprehensive test suite verifying 4GB file addressing and sparse holes.</li>\n</ol>\n<hr>\n<h2 id=\"3-complete-data-model\">3. Complete Data Model</h2>\n<h3 id=\"31-inode-structure-inode_t\">3.1. Inode Structure (inode_t)</h3>\n<p>Each inode occupies exactly 128 bytes. There are 32 inodes per 4KB block.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Offset</th>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0x00</td>\n<td align=\"left\"><code>i_mode</code></td>\n<td align=\"left\"><code>uint16_t</code></td>\n<td align=\"left\">File type (High 4 bits) + Permissions (Low 12 bits).</td>\n</tr>\n<tr>\n<td align=\"left\">0x02</td>\n<td align=\"left\"><code>i_nlinks</code></td>\n<td align=\"left\"><code>uint16_t</code></td>\n<td align=\"left\">Reference count (Hard links). Inode is freed when this is 0.</td>\n</tr>\n<tr>\n<td align=\"left\">0x04</td>\n<td align=\"left\"><code>i_uid</code></td>\n<td align=\"left\"><code>uint16_t</code></td>\n<td align=\"left\">Owner User ID.</td>\n</tr>\n<tr>\n<td align=\"left\">0x06</td>\n<td align=\"left\"><code>i_gid</code></td>\n<td align=\"left\"><code>uint16_t</code></td>\n<td align=\"left\">Owner Group ID.</td>\n</tr>\n<tr>\n<td align=\"left\">0x08</td>\n<td align=\"left\"><code>i_size</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Logical file size in bytes (max ~4GB).</td>\n</tr>\n<tr>\n<td align=\"left\">0x0C</td>\n<td align=\"left\"><code>i_atime</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Access time (Unix timestamp).</td>\n</tr>\n<tr>\n<td align=\"left\">0x10</td>\n<td align=\"left\"><code>i_mtime</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Data modification time.</td>\n</tr>\n<tr>\n<td align=\"left\">0x14</td>\n<td align=\"left\"><code>i_ctime</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Inode metadata change time.</td>\n</tr>\n<tr>\n<td align=\"left\">0x18</td>\n<td align=\"left\"><code>i_blocks[12]</code></td>\n<td align=\"left\"><code>uint32_t[12]</code></td>\n<td align=\"left\">Direct block pointers (Addresses first 48KB).</td>\n</tr>\n<tr>\n<td align=\"left\">0x48</td>\n<td align=\"left\"><code>i_single_ind</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Pointer to a block of 1024 pointers (+4MB).</td>\n</tr>\n<tr>\n<td align=\"left\">0x4C</td>\n<td align=\"left\"><code>i_double_ind</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Pointer to a block of 1024 single-indirect pointers (+4GB).</td>\n</tr>\n<tr>\n<td align=\"left\">0x50</td>\n<td align=\"left\"><code>i_reserved</code></td>\n<td align=\"left\"><code>uint8_t[48]</code></td>\n<td align=\"left\">Zero-filled padding to 128 bytes.</td>\n</tr>\n</tbody></table>\n<p><strong>Hardware Soul (Alignment):</strong></p>\n<ul>\n<li><strong>Packed:</strong> The struct uses <code>__attribute__((packed))</code> to ensure field offsets are identical across architectures.</li>\n<li><strong>Cache Line:</strong> Two <code>inode_t</code> structs (256B) fit exactly into four 64-byte L1 cache lines.</li>\n<li><strong>RMW Cycle:</strong> Updating one inode requires reading 4096 bytes (32 inodes), modifying 128, and writing 4096.</li>\n</ul>\n<h3 id=\"32-indirect-block-format\">3.2. Indirect Block Format</h3>\n<p>An indirect block is simply a raw 4KB block treated as an array of block addresses.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTRS_PER_BLOCK</span><span style=\"color:#E1E4E8\"> (BLOCK_SIZE </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">))</span><span style=\"color:#6A737D\"> // 1024 pointers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#79B8FF\"> indirect_block_t</span><span style=\"color:#E1E4E8\">[PTRS_PER_BLOCK];</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"4-interface-contracts\">4. Interface Contracts</h2>\n<h3 id=\"41-lifecycle-management\">4.1. Lifecycle Management</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Allocate a new inode from the inode bitmap.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@return</span><span style=\"color:#6A737D\"> 1-based inode number, or -ENOSPC.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> alloc_inode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Free an inode and recursively reclaim all associated data and indirect blocks.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> inode_num</span><span style=\"color:#6A737D\"> 1-based index.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> free_inode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> inode_num</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Initialize an inode struct with default values based on type.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> inode_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">inode_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> mode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> uid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> gid</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<h3 id=\"42-block-translation-engine\">4.2. Block Translation Engine</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Translates a logical file offset to an absolute disk block address.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> offset</span><span style=\"color:#6A737D\"> Byte offset in file.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> out_block</span><span style=\"color:#6A737D\"> Absolute disk block number. 0 indicates a sparse hole.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@return</span><span style=\"color:#6A737D\"> 0 on success, -EFBIG if offset exceeds 4GB limit.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> inode_get_block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> inode_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#FFAB70\"> offset</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">out_block</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Maps a logical file offset to a specific disk block. </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Allocates indirect blocks if necessary to reach the required depth.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> disk_block</span><span style=\"color:#6A737D\"> Absolute block address to store.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> inode_set_block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">inode_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#FFAB70\"> offset</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> disk_block</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"5-algorithm-specification\">5. Algorithm Specification</h2>\n<h3 id=\"51-the-traversal-logic-inode_get_block\">5.1. The Traversal Logic (<code>inode_get_block</code>)</h3>\n<p>The translation follows a branching decision based on the logical block index <code>bi = offset / 4096</code>.</p>\n<ol>\n<li><strong>Direct (0 &lt;= bi &lt; 12)</strong>:<ul>\n<li>Return <code>inode-&gt;i_blocks[bi]</code>.</li>\n</ul>\n</li>\n<li><strong>Single Indirect (12 &lt;= bi &lt; 1024 + 12)</strong>:<ul>\n<li>If <code>inode-&gt;i_single_ind == 0</code>, return <code>0</code> (Hole).</li>\n<li>Read block <code>inode-&gt;i_single_ind</code>.</li>\n<li>Return <code>indirect_block[bi - 12]</code>.</li>\n</ul>\n</li>\n<li><strong>Double Indirect (1024+12 &lt;= bi &lt; 1024^2 + 1024 + 12)</strong>:<ul>\n<li>If <code>inode-&gt;i_double_ind == 0</code>, return <code>0</code>.</li>\n<li>Read <code>inode-&gt;i_double_ind</code> into <code>buf_outer</code>.</li>\n<li><code>outer_idx = (bi - 1036) / 1024</code>.</li>\n<li><code>inner_idx = (bi - 1036) % 1024</code>.</li>\n<li>If <code>buf_outer[outer_idx] == 0</code>, return <code>0</code>.</li>\n<li>Read <code>buf_outer[outer_idx]</code> into <code>buf_inner</code>.</li>\n<li>Return <code>buf_inner[inner_idx]</code>.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"52-recursive-deallocation-free_inode\">5.2. Recursive Deallocation (<code>free_inode</code>)</h3>\n<p>To prevent leaks, deallocation must follow a Post-Order Traversal (Bottom-Up).</p>\n<ol>\n<li><strong>Level 0</strong>: Loop <code>i_blocks[0..11]</code>. If non-zero, <code>free_data_block</code>.</li>\n<li><strong>Level 1</strong>: If <code>i_single_ind != 0</code>:<ul>\n<li>Read block. Loop all 1024 pointers. If non-zero, <code>free_data_block</code>.</li>\n<li><code>free_data_block(i_single_ind)</code>.</li>\n</ul>\n</li>\n<li><strong>Level 2</strong>: If <code>i_double_ind != 0</code>:<ul>\n<li>Read <code>i_double_ind</code> (Outer).</li>\n<li>For each <code>p_outer</code> in Outer:<ul>\n<li>If <code>p_outer != 0</code>:<ul>\n<li>Read <code>p_outer</code> (Inner).</li>\n<li>For each <code>p_inner</code> in Inner: if <code>p_inner != 0</code>, <code>free_data_block</code>.</li>\n<li><code>free_data_block(p_outer)</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>free_data_block(i_double_ind)</code>.</li>\n</ul>\n</li>\n<li>Clear bits in Inode Bitmap and decrement <code>s_free_inodes</code>.</li>\n</ol>\n<h3 id=\"53-sparse-allocation-inode_set_block\">5.3. Sparse Allocation (<code>inode_set_block</code>)</h3>\n<p>When writing to a previously unallocated offset, the filesystem must &quot;fill&quot; the path to that block.</p>\n<ol>\n<li>Calculate target depth (Direct, Single, or Double).</li>\n<li>If the required indirect block pointer is <code>0</code>:<ul>\n<li><code>new_block = alloc_data_block(fd, sb)</code>.</li>\n<li>Zero out <code>new_block</code> (crucial to avoid garbage pointers).</li>\n<li>Update parent pointer to <code>new_block</code>.</li>\n</ul>\n</li>\n<li>Descend to next level and repeat until the final data pointer slot is reached.</li>\n<li>Write the <code>disk_block</code> value into the leaf slot.</li>\n</ol>\n<hr>\n<h2 id=\"6-error-handling-matrix\">6. Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error</th>\n<th align=\"left\">Detected By</th>\n<th align=\"left\">Recovery</th>\n<th align=\"left\">User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>EINVAL</code></td>\n<td align=\"left\"><code>read_inode</code></td>\n<td align=\"left\">Validate number range (1 to <code>total_inodes</code>).</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EFBIG</code></td>\n<td align=\"left\"><code>inode_get_block</code></td>\n<td align=\"left\">Prevent seeking/writing beyond ~4GB.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ENOSPC</code></td>\n<td align=\"left\"><code>inode_set_block</code></td>\n<td align=\"left\">Allocation of indirect block failed. Fail the write.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EIO</code></td>\n<td align=\"left\"><code>write_inode</code></td>\n<td align=\"left\">Device error during RMW cycle.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\">Corruption</td>\n<td align=\"left\"><code>inode_get_block</code></td>\n<td align=\"left\">If a pointer &gt; <code>total_blocks</code>, return <code>EIO</code> and log.</td>\n<td align=\"left\">Yes</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"7-implementation-sequence-with-checkpoints\">7. Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-serialization-amp-inode-table-math-3-hours\">Phase 1: Serialization &amp; Inode Table Math (3 Hours)</h3>\n<p>Implement <code>read_inode</code> and <code>write_inode</code>. </p>\n<ul>\n<li><strong>Offset Math:</strong> <code>byte_offset = (sb-&gt;s_inode_table_start * 4096) + ((ino-1) * 128)</code>.</li>\n<li><strong>Read-Modify-Write:</strong> Ensure <code>write_inode</code> reads the 4KB block, modifies the 128B slot, and writes back.\n<strong>Checkpoint:</strong> Using a hex editor, manually change Inode 5&#39;s <code>i_mode</code> and verify <code>read_inode</code> sees the change.</li>\n</ul>\n<h3 id=\"phase-2-inode-lifecycle-3-hours\">Phase 2: Inode Lifecycle (3 Hours)</h3>\n<p>Implement <code>alloc_inode</code>, <code>free_inode</code> (stubbed for direct blocks), and <code>inode_init</code>.\n<strong>Checkpoint:</strong> Allocate 100 inodes, verify bitmap bits are set, then free them and verify bits are cleared.</p>\n<h3 id=\"phase-3-the-translation-engine-4-hours\">Phase 3: The Translation Engine (4 Hours)</h3>\n<p>Implement <code>inode_get_block</code> and <code>inode_set_block</code> for Direct and Single-Indirect regions.</p>\n<ul>\n<li><strong>Math Check:</strong> 48KB boundary is the transition point.\n<strong>Checkpoint:</strong> Write a block at offset 64KB (Single Indirect), read it back, and verify the physical block address is stored in the indirect block.</li>\n</ul>\n<h3 id=\"phase-4-recursive-reclamation-4-hours\">Phase 4: Recursive Reclamation (4 Hours)</h3>\n<p>Implement the full depth-first <code>free_inode</code> including double-indirection.\n<strong>Checkpoint:</strong> Create a 10MB file (Double Indirect). Record <code>s_free_blocks</code>. Delete file. Verify <code>s_free_blocks</code> returns exactly to the previous value.</p>\n<hr>\n<h2 id=\"8-test-specification\">8. Test Specification</h2>\n<h3 id=\"81-sparse-file-integrity\">8.1. Sparse File Integrity</h3>\n<ol>\n<li>Create new inode.</li>\n<li>Call <code>inode_get_block</code> at offset 1GB.</li>\n<li><strong>Assertion:</strong> <code>out_block == 0</code>.</li>\n<li>Call <code>inode_set_block</code> at offset 1GB with block 5000.</li>\n<li><strong>Assertion:</strong> <code>inode-&gt;i_double_ind != 0</code>. <code>inode_get_block</code> at offset 500MB still returns 0.</li>\n</ol>\n<h3 id=\"82-address-boundary-transitions\">8.2. Address Boundary Transitions</h3>\n<ol>\n<li>Set block at offset 49,151 (Last byte of Direct 11).</li>\n<li>Set block at offset 49,152 (First byte of Single Indirect).</li>\n<li><strong>Assertion:</strong> Block 11 is in <code>i_blocks[11]</code>. Block 12 is in the first slot of <code>i_single_ind</code>.</li>\n</ol>\n<h3 id=\"83-recursive-cleanup-leak-detection\">8.3. Recursive Cleanup (Leak Detection)</h3>\n<ol>\n<li>Write a file that uses exactly 1 double-indirect block, 2 single-indirect blocks, and 12 direct blocks.</li>\n<li>Calculate total metadata blocks: 1 + 2 = 3 blocks.</li>\n<li>Total blocks used = 3 + data blocks.</li>\n<li>Call <code>free_inode</code>.</li>\n<li><strong>Assertion:</strong> Superblock <code>s_free_blocks</code> increases by exactly <code>3 + data_count</code>.</li>\n</ol>\n<hr>\n<h2 id=\"9-performance-targets\">9. Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target</th>\n<th align=\"left\">Measurement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Inode Translation (Direct)</td>\n<td align=\"left\">O(1) Memory Access</td>\n<td align=\"left\">No <code>read_block</code> calls.</td>\n</tr>\n<tr>\n<td align=\"left\">Inode Translation (Single)</td>\n<td align=\"left\">1 Disk I/O</td>\n<td align=\"left\">Exactly one <code>read_block</code>.</td>\n</tr>\n<tr>\n<td align=\"left\">Inode Translation (Double)</td>\n<td align=\"left\">2 Disk I/Os</td>\n<td align=\"left\">Exactly two <code>read_block</code> calls.</td>\n</tr>\n<tr>\n<td align=\"left\">Inode Table Density</td>\n<td align=\"left\">32 inodes/block</td>\n<td align=\"left\"><code>_Static_assert(sizeof(inode_t) == 128)</code>.</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"10-concurrency-specification\">10. Concurrency Specification</h2>\n<p>While the project is currently single-threaded, the design requires:</p>\n<ol>\n<li><strong>Serialization:</strong> Inodes must be locked before <code>inode_set_block</code> begins, as it modifies internal pointers and may trigger block allocations that update the Superblock.</li>\n<li><strong>Order of Operations:</strong> To avoid corruption on crash, the <strong>Indirect Block</strong> must be zeroed and written to disk <strong>before</strong> the parent inode pointer is updated and written.</li>\n</ol>\n<hr>\n<h3 id=\"\"></h3>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Ftdd-diag-8.svg\" alt=\"inode_t Structure â€” Byte-Level Memory Layout (128 bytes)\"></p>\n<p><strong>Inode Block Pointer Tree</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">text</span><pre class=\"arch-pre shiki-highlighted\"><code>inode_t (128B)\n|\n|-- [0..11] Direct Pointers -------&gt; [Data Block] (4KB)\n|\n|-- [12] Single Indirect ----------&gt; [Pointer Block] (4KB)\n|                                    |-- [0..1023] --------&gt; [Data Block]\n|\n|-- [13] Double Indirect ----------&gt; [Outer Pointer Block] (4KB)\n                                     |-- [0..1023]\n                                         |\n                                         --&gt; [Inner Pointer Block] (4KB)\n                                             |-- [0..1023] --&gt; [Data Block]</code></pre></div>\n\n<h3 id=\"\"></h3>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Ftdd-diag-9.svg\" alt=\"Inode Block Pointer Tree â€” Direct, Single-Indirect, Double-Indirect\"></p>\n<p><strong>Memory Layout of Inode Table Block</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">text</span><pre class=\"arch-pre shiki-highlighted\"><code>Disk Block (4096 Bytes)\n+----------------+----------------+----------------+-----+----------------+\n| Inode 1 (128B) | Inode 2 (128B) | Inode 3 (128B) | ... | Inode 32 (128) |\n+----------------+----------------+----------------+-----+----------------+\n^                ^                ^\n0x00             0x80             0x100</code></pre></div>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: filesystem-m3 -->\n<h1 id=\"module-technical-design-specification-directory-operations-filesystem-m3\">Module Technical Design Specification: Directory Operations (filesystem-m3)</h1>\n<h2 id=\"1-module-charter\">1. Module Charter</h2>\n<p>The <strong>Directory Operations</strong> module transforms the flat, numeric inode space into a human-navigable hierarchical tree. It implements the &quot;Directory is a special file&quot; abstraction, where data blocks contain variable-length directory entry records mapping UTF-8 strings to inode numbers.</p>\n<p><strong>Scope:</strong></p>\n<ul>\n<li>Definition of the variable-length on-disk <code>dirent</code> format and the <code>rec_len</code> skip-logic.</li>\n<li>Implementation of linear directory scanning for name lookups and entry additions.</li>\n<li>Path resolution engine supporting absolute and relative paths, including <code>.</code> and <code>..</code> traversal.</li>\n<li>Atomic-style directory mutations (<code>mkdir</code>, <code>rmdir</code>, <code>link</code>, <code>unlink</code>) with strict adherence to POSIX link-count invariants.</li>\n<li>Support for directory entry merging during deletion to prevent fragmentation within blocks.</li>\n</ul>\n<p><strong>Out of Scope:</strong></p>\n<ul>\n<li>Higher-level FUSE callback wrappers (Milestone 5).</li>\n<li>Directory indexing optimizations like HTrees or B-Trees (linear scan only).</li>\n<li>Multi-threaded locking (deferred to the global FUSE lock).</li>\n</ul>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>Every directory MUST contain <code>.</code> (self) and <code>..</code> (parent) as its first two entries.</li>\n<li>The <code>rec_len</code> of the last entry in a directory block MUST extend to the end of the 4KB block.</li>\n<li>Directory entries must never span across two physical blocks.</li>\n<li>Hard links to directories are strictly forbidden to prevent filesystem cycles.</li>\n<li>Root directory&#39;s <code>..</code> entry points to itself (Inode 1).</li>\n</ul>\n<hr>\n<h2 id=\"2-file-structure\">2. File Structure</h2>\n<p>Implementation follows a dependency-driven sequence:</p>\n<ol>\n<li><code>dir.h</code>: Structure definitions for on-disk and in-memory directory entries.</li>\n<li><code>dir_rec.c</code>: Low-level record manipulation (padding, length calculation, buffer serialization).</li>\n<li><code>dir_scan.c</code>: Linear scanning logic (<code>dir_lookup</code>, <code>dir_readdir</code>).</li>\n<li><code>dir_path.c</code>: Recursive path resolution and component splitting using <code>strtok_r</code>.</li>\n<li><code>dir_write.c</code>: Mutation logic (<code>dir_add_entry</code> with splitting, <code>dir_remove_entry</code> with merging).</li>\n<li><code>dir_op.c</code>: High-level POSIX-style operations (<code>fs_mkdir</code>, <code>fs_rmdir</code>, <code>fs_link</code>, <code>fs_unlink</code>).</li>\n<li><code>test_m3.c</code>: Integration tests for tree navigation and link-count correctness.</li>\n</ol>\n<hr>\n<h2 id=\"3-complete-data-model\">3. Complete Data Model</h2>\n<h3 id=\"31-on-disk-directory-entry-physical-layout\">3.1. On-Disk Directory Entry (Physical Layout)</h3>\n<p>Entries are variable-length. The header is exactly 8 bytes. The name is NOT null-terminated on disk to save space; <code>name_len</code> provides the boundary.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Offset</th>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0x00</td>\n<td align=\"left\"><code>d_inode</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Target Inode Number. 0 = Deleted/Empty Slot.</td>\n</tr>\n<tr>\n<td align=\"left\">0x04</td>\n<td align=\"left\"><code>d_rec_len</code></td>\n<td align=\"left\"><code>uint16_t</code></td>\n<td align=\"left\">Distance to the next record header in bytes.</td>\n</tr>\n<tr>\n<td align=\"left\">0x06</td>\n<td align=\"left\"><code>d_name_len</code></td>\n<td align=\"left\"><code>uint8_t</code></td>\n<td align=\"left\">Actual length of the filename string.</td>\n</tr>\n<tr>\n<td align=\"left\">0x07</td>\n<td align=\"left\"><code>d_file_type</code></td>\n<td align=\"left\"><code>uint8_t</code></td>\n<td align=\"left\">Hint: 1=Reg, 2=Dir, 7=Symlink.</td>\n</tr>\n<tr>\n<td align=\"left\">0x08</td>\n<td align=\"left\"><code>d_name[...]</code></td>\n<td align=\"left\"><code>char[]</code></td>\n<td align=\"left\">Filename string (1 to 255 bytes).</td>\n</tr>\n<tr>\n<td align=\"left\">Ends</td>\n<td align=\"left\"><code>padding</code></td>\n<td align=\"left\"><code>uint8_t[]</code></td>\n<td align=\"left\">0-3 bytes to ensure the NEXT record starts on a 4-byte boundary.</td>\n</tr>\n</tbody></table>\n<p><strong>Hardware Soul (Alignment &amp; Scanning):</strong></p>\n<ul>\n<li><strong>4-Byte Alignment:</strong> Every <code>d_rec_len</code> is a multiple of 4. This ensures <code>uint32_t</code> fields in the next header are naturally aligned, preventing unaligned access penalties on sensitive architectures.</li>\n<li><strong>Skip-Logic:</strong> To find &quot;FileB&quot; in a block, the CPU reads the header of &quot;FileA&quot;, adds <code>d_rec_len</code> to the current pointer, and jumps directly to &quot;FileB&quot;.</li>\n</ul>\n<h3 id=\"32-in-memory-representation-dirent_t\">3.2. In-Memory Representation (dirent_t)</h3>\n<p>Used for passing data between internal functions.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_FILENAME_LEN</span><span style=\"color:#79B8FF\"> 255</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DIRENT_HEADER_SIZE</span><span style=\"color:#79B8FF\"> 8</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> inode_num;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> rec_len;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\">  name_len;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\">  file_type;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\">     name</span><span style=\"color:#E1E4E8\">[MAX_FILENAME_LEN </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\"> // Null-terminated for C string compatibility</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">dirent_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"4-interface-contracts\">4. Interface Contracts</h2>\n<h3 id=\"41-lookup-and-resolution\">4.1. Lookup and Resolution</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Resolves a full path (e.g., \"/usr/bin/gcc\") to an inode number.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#6A737D\"> Null-terminated path string.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@return</span><span style=\"color:#6A737D\"> Inode number > 0, or negative errno.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> path_resolve</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Resolves the parent directory of a path.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#6A737D\"> Input path.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> out_parent_ino</span><span style=\"color:#6A737D\"> Set to parent inode number.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> out_name</span><span style=\"color:#6A737D\"> Buffer for the final component name (e.g., \"gcc\").</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@return</span><span style=\"color:#6A737D\"> 0 on success.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> path_resolve_parent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">out_parent_ino</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">out_name</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<h3 id=\"42-directory-mutation\">4.2. Directory Mutation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Adds a name->inode mapping to a directory.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@return</span><span style=\"color:#6A737D\"> 0 or -EEXIST if name found.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> dir_add_entry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> dir_ino</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> target_ino</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#FFAB70\"> type</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Removes a name mapping. Merges the record's space into the previous entry.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@return</span><span style=\"color:#6A737D\"> 0 or -ENOENT.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> dir_remove_entry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> dir_ino</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"5-algorithm-specification\">5. Algorithm Specification</h2>\n<h3 id=\"51-directory-entry-packing-dir_add_entry\">5.1. Directory Entry Packing (<code>dir_add_entry</code>)</h3>\n<p>When adding &quot;NewFile&quot; (Needed space = <code>actual_len(7)</code> = 12 bytes):</p>\n<ol>\n<li><strong>Iterate</strong> existing directory blocks.</li>\n<li>For each block, <strong>scan</strong> records using <code>rec_len</code>.</li>\n<li>For each record, calculate its <code>min_required_len = align4(8 + name_len)</code>.</li>\n<li><strong>Find Free Space:</strong> <code>available_gap = current_rec_len - min_required_len</code>.</li>\n<li>If <code>available_gap &gt;= needed_space</code>:<ul>\n<li><strong>Split:</strong> Set <code>current_record-&gt;rec_len = min_required_len</code>.</li>\n<li><strong>Insert:</strong> Write new record at <code>offset + min_required_len</code> with <code>rec_len = available_gap</code>.</li>\n<li>Return success.</li>\n</ul>\n</li>\n<li>If no gap found in any block, allocate a new data block via <code>alloc_data_block</code>, initialize it with one record where <code>rec_len = 4096</code>.</li>\n</ol>\n<h3 id=\"52-path-resolution-engine-path_resolve\">5.2. Path Resolution Engine (<code>path_resolve</code>)</h3>\n<ol>\n<li><strong>Start:</strong> <code>current_ino = sb-&gt;s_root_inode</code> if path starts with <code>/</code>, else <code>cwd</code>.</li>\n<li><strong>Tokenize:</strong> Use <code>strtok_r</code> with <code>/</code> as delimiter.</li>\n<li><strong>Loop components:</strong><ul>\n<li>Call <code>read_inode(current_ino)</code>.</li>\n<li>Verify <code>S_ISDIR(mode)</code>. Return <code>-ENOTDIR</code> if not.</li>\n<li>Call <code>dir_lookup(current_ino, component_name)</code>.</li>\n<li>If returns 0, return <code>-ENOENT</code>.</li>\n<li><code>current_ino = result</code>.</li>\n</ul>\n</li>\n<li><strong>End:</strong> Return <code>current_ino</code>.</li>\n</ol>\n<h3 id=\"53-link-count-invariants-fs_mkdir-fs_rmdir\">5.3. Link Count Invariants (<code>fs_mkdir</code> / <code>fs_rmdir</code>)</h3>\n<p>Creating a directory <code>D</code> inside parent <code>P</code>:</p>\n<ol>\n<li><code>P-&gt;i_nlinks</code> increases by 1 (because <code>D/..</code> points to <code>P</code>).</li>\n<li><code>D-&gt;i_nlinks</code> is initialized to 2 (<code>D/.</code> and <code>P/D</code>).</li>\n</ol>\n<p>Removing directory <code>D</code>:</p>\n<ol>\n<li>Check if <code>D</code> is empty (scan data blocks, verify only <code>.</code> and <code>..</code> exist).</li>\n<li><code>P-&gt;i_nlinks</code> decreases by 1.</li>\n<li><code>D-&gt;i_nlinks</code> drops to 0; triggers <code>free_inode</code>.</li>\n</ol>\n<hr>\n<h2 id=\"6-error-handling-matrix\">6. Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error</th>\n<th align=\"left\">Detected By</th>\n<th align=\"left\">Recovery</th>\n<th align=\"left\">User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>ENOTEMPTY</code></td>\n<td align=\"left\"><code>fs_rmdir</code></td>\n<td align=\"left\">Abort removal if entries &gt; 2 found.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EEXIST</code></td>\n<td align=\"left\"><code>dir_add_entry</code></td>\n<td align=\"left\">Return error; prevent duplicate names.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EPERM</code></td>\n<td align=\"left\"><code>fs_link</code></td>\n<td align=\"left\">If target is <code>S_IFDIR</code>, reject to prevent cycles.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ENAMETOOLONG</code></td>\n<td align=\"left\"><code>path_resolve</code></td>\n<td align=\"left\">Reject if component &gt; 255 bytes.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ELOOP</code></td>\n<td align=\"left\"><code>path_resolve</code></td>\n<td align=\"left\">(Advanced) Count components; reject if &gt; 1024.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EIO</code></td>\n<td align=\"left\"><code>dir_scan</code></td>\n<td align=\"left\">If <code>rec_len == 0</code> or overlaps, stop and return error.</td>\n<td align=\"left\">Yes</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"7-implementation-sequence-with-checkpoints\">7. Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-serialization-primitives-3-hours\">Phase 1: Serialization Primitives (3 Hours)</h3>\n<p>Implement <code>dirent_actual_len</code> and buffer serializers. Ensure 4-byte padding logic is perfect.\n<strong>Checkpoint:</strong> Write a &quot;FileA&quot; entry followed by &quot;FileB&quot;. Verify &quot;FileB&quot; starts at an address divisible by 4.</p>\n<h3 id=\"phase-2-scanning-3-hours\">Phase 2: Scanning (3 Hours)</h3>\n<p>Implement <code>dir_lookup</code>. It must iterate through <code>inode-&gt;i_blocks</code> (using M2 logic) and walk the <code>rec_len</code> chain.\n<strong>Checkpoint:</strong> Manually create a directory block in <code>mkfs</code>. Use <code>dir_lookup</code> to find the inode of <code>..</code>.</p>\n<h3 id=\"phase-3-path-resolution-4-hours\">Phase 3: Path Resolution (4 Hours)</h3>\n<p>Implement <code>path_resolve</code> and <code>split_path</code>.\n<strong>Checkpoint:</strong> Resolve <code>/</code> (returns 1). Resolve <code>/././.</code> (returns 1). Resolve <code>/nonexistent</code> (returns -ENOENT).</p>\n<h3 id=\"phase-4-mutation-5-hours\">Phase 4: Mutation (5 Hours)</h3>\n<p>Implement <code>dir_add_entry</code> and <code>dir_remove_entry</code>. Focus on the <code>rec_len</code> manipulation.\n<strong>Checkpoint:</strong> Add 3 files. Remove the middle file. Verify the first file&#39;s <code>rec_len</code> now covers the gap where the middle file was.</p>\n<h3 id=\"phase-5-posix-operations-4-hours\">Phase 5: POSIX Operations (4 Hours)</h3>\n<p>Implement <code>fs_mkdir</code>, <code>fs_rmdir</code>, <code>fs_link</code>.\n<strong>Checkpoint:</strong> <code>mkdir(&quot;/test&quot;)</code>, verify <code>root-&gt;i_nlinks == 3</code>. <code>rmdir(&quot;/test&quot;)</code>, verify <code>root-&gt;i_nlinks == 2</code>.</p>\n<hr>\n<h2 id=\"8-test-specification\">8. Test Specification</h2>\n<h3 id=\"81-hierarchical-persistence\">8.1. Hierarchical Persistence</h3>\n<ol>\n<li><code>fs_mkdir(root, &quot;a&quot;)</code>.</li>\n<li><code>fs_mkdir(a_ino, &quot;b&quot;)</code>.</li>\n<li><code>path_resolve(&quot;/a/b&quot;)</code>.</li>\n<li><strong>Assertion:</strong> Returns <code>b_ino</code>. <code>b_ino-&gt;i_blocks[0]</code> contains <code>..</code> pointing to <code>a_ino</code>.</li>\n</ol>\n<h3 id=\"82-empty-directory-constraint\">8.2. Empty Directory Constraint</h3>\n<ol>\n<li><code>fs_mkdir(root, &quot;dir&quot;)</code>.</li>\n<li><code>fs_create_file(dir_ino, &quot;file&quot;)</code>.</li>\n<li><code>fs_rmdir(root, &quot;dir&quot;)</code>.</li>\n<li><strong>Assertion:</strong> Returns <code>-ENOTEMPTY</code>. File still exists.</li>\n</ol>\n<h3 id=\"83-hard-link-integrity\">8.3. Hard Link Integrity</h3>\n<ol>\n<li><code>fs_link(file_ino, root, &quot;alias&quot;)</code>.</li>\n<li><strong>Assertion:</strong> <code>file_ino-&gt;i_nlinks == 2</code>.</li>\n<li><code>fs_unlink(root, &quot;file&quot;)</code>.</li>\n<li><strong>Assertion:</strong> <code>file_ino-&gt;i_nlinks == 1</code>. Inode is NOT freed. Data is still readable via &quot;alias&quot;.</li>\n</ol>\n<hr>\n<h2 id=\"9-performance-targets\">9. Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target</th>\n<th align=\"left\">Measurement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Name Lookup</td>\n<td align=\"left\">O(N) entries</td>\n<td align=\"left\">Benchmark 1000 entries in one block.</td>\n</tr>\n<tr>\n<td align=\"left\">Path Resolve</td>\n<td align=\"left\">O(M) components</td>\n<td align=\"left\">Resolve 10-level deep path.</td>\n</tr>\n<tr>\n<td align=\"left\">Add Entry</td>\n<td align=\"left\">&lt; 2 Disk I/Os</td>\n<td align=\"left\">Usually 1 read (find space) + 1 write.</td>\n</tr>\n<tr>\n<td align=\"left\">Memory Overhead</td>\n<td align=\"left\">8B per entry</td>\n<td align=\"left\">Excludes name string.</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"\"></h3>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Ftdd-diag-15.svg\" alt=\"Directory Entry On-Disk Format â€” Byte Layout and rec_len Chain\"></p>\n<p><strong>On-Disk Directory Block Layout</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">text</span><pre class=\"arch-pre shiki-highlighted\"><code>Block Offset: 0\n[ Inode: 1 | RecLen: 12 | NameLen: 1 | Type: 2 | Name: &quot;.&quot;  | Pad: 3 ]\nBlock Offset: 12\n[ Inode: 1 | RecLen: 12 | NameLen: 2 | Type: 2 | Name: &quot;..&quot; | Pad: 2 ]\nBlock Offset: 24\n[ Inode: 5 | RecLen: 4072| NameLen: 4 | Type: 1 | Name: &quot;file&quot;| Pad: 0 ]\n                                ^\n                                |--- RecLen of last entry fills the block</code></pre></div>\n\n<h3 id=\"\"></h3>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Ftdd-diag-16.svg\" alt=\"Path Resolution â€” Walking /home/user/file.txt Step by Step\"></p>\n<p><strong>Directory Entry Removal (Merging)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">text</span><pre class=\"arch-pre shiki-highlighted\"><code>BEFORE:\n[ Entry A (RecLen: 12) ] [ Entry B (RecLen: 16) ] [ Entry C (RecLen: 4068) ]\n\nAFTER REMOVE(B):\n[ Entry A (RecLen: 28) ]                          [ Entry C (RecLen: 4068) ]\n           ^------- A's RecLen increased (12 + 16)</code></pre></div>\n\n<h3 id=\"\"></h3>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Ftdd-diag-17.svg\" alt=\"Directory as Inode Graph â€” Tree Structure and Link Counts\"></p>\n<p><strong>Path Resolution Flow</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">text</span><pre class=\"arch-pre shiki-highlighted\"><code>Path: &quot;/home/user/doc.txt&quot;\n\n1. Lookup &quot;home&quot; in Inode 1 (Root) -&gt; Inode 10\n2. Lookup &quot;user&quot; in Inode 10       -&gt; Inode 45\n3. Lookup &quot;doc.txt&quot; in Inode 45    -&gt; Inode 102\n4. Return 102</code></pre></div>\n\n<!-- END_TDD_MOD -->\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: filesystem-m4 -->\n<h1 id=\"module-technical-design-specification-file-readwrite-operations-filesystem-m4\">Module Technical Design Specification: File Read/Write Operations (filesystem-m4)</h1>\n<h2 id=\"1-module-charter\">1. Module Charter</h2>\n<p>The <strong>File Read/Write Operations</strong> module implements the data plane of the filesystem. It bridges the gap between byte-addressable application requests and the block-addressable hardware reality. This module is responsible for the life cycle of regular file data, including creation, sequential and random access, and resizing.</p>\n<p><strong>Scope:</strong></p>\n<ul>\n<li><strong>Creation:</strong> Orchestrating inode allocation and directory entry insertion for new files.</li>\n<li><strong>Read Logic:</strong> Implementing byte-to-block mapping, handling sparse &quot;holes&quot; via zero-filling, and enforcing End-Of-File (EOF) boundaries.</li>\n<li><strong>Write Logic:</strong> Implementing the Read-Modify-Write (RMW) cycle for partial-block updates and on-demand block allocation for file growth.</li>\n<li><strong>Truncation:</strong> Reclaiming disk space during shrink operations (including recursive indirect block cleanup) and implementing &quot;thin&quot; extension via sparse holes.</li>\n<li><strong>Metadata Sync:</strong> Ensuring <code>i_size</code>, <code>i_atime</code>, <code>i_mtime</code>, and <code>i_ctime</code> are updated according to POSIX semantics.</li>\n</ul>\n<p><strong>Out of Scope:</strong></p>\n<ul>\n<li>FUSE kernel-to-user relay (Milestone 5).</li>\n<li>Atomic crash consistency via journaling (Milestone 6).</li>\n<li>Permission/ACL enforcement (deferred to the VFS layer).</li>\n</ul>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li><code>fs_read</code> never returns more than <code>inode.i_size - offset</code> bytes.</li>\n<li>A sparse hole (disk block pointer = 0) must return exactly zeroed bytes without performing disk I/O.</li>\n<li><code>fs_write</code> at an offset &gt; <code>inode.i_size</code> automatically creates a sparse hole between the old EOF and the new write start.</li>\n<li><code>fs_truncate</code> (shrink) must zero-fill the byte range from <code>new_size</code> to the next 4KB boundary in the last retained block to prevent data leakage.</li>\n</ul>\n<hr>\n<h2 id=\"2-file-structure\">2. File Structure</h2>\n<p>Implementation proceeds from basic creation to complex mutation:</p>\n<ol>\n<li><code>file_ops.h</code>: Function prototypes and offset arithmetic macros.</li>\n<li><code>file_create.c</code>: High-level file creation logic.</li>\n<li><code>file_read.c</code>: The read path and sparse hole handling.</li>\n<li><code>file_write.c</code>: The write path, RMW logic, and allocation-on-demand.</li>\n<li><code>file_truncate.c</code>: Shrink/Extend logic and recursive block freeing.</li>\n<li><code>test_m4.c</code>: Comprehensive I/O suite (Round-trip verification, sparse tests, 4GB boundary tests).</li>\n</ol>\n<hr>\n<h2 id=\"3-complete-data-model\">3. Complete Data Model</h2>\n<p>This module relies on the <code>inode_t</code> structure defined in Milestone 2. Every operation navigates this structure&#39;s block pointer tree.</p>\n<h3 id=\"31-inode-metadata-inode_t-reference-table\">3.1. Inode Metadata (inode_t) Reference Table</h3>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Offset</th>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0x00</td>\n<td align=\"left\"><code>i_mode</code></td>\n<td align=\"left\"><code>uint16_t</code></td>\n<td align=\"left\">Must have <code>S_IFREG</code> (0100000) for these ops.</td>\n</tr>\n<tr>\n<td align=\"left\">0x04</td>\n<td align=\"left\"><code>i_size</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Logical size. Clamps <code>fs_read</code>; updated by <code>fs_write</code>.</td>\n</tr>\n<tr>\n<td align=\"left\">0x18</td>\n<td align=\"left\"><code>i_blocks[12]</code></td>\n<td align=\"left\"><code>uint32_t[12]</code></td>\n<td align=\"left\">Direct pointers for offsets 0 to 49,151.</td>\n</tr>\n<tr>\n<td align=\"left\">0x48</td>\n<td align=\"left\"><code>i_single_ind</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Pointer to 1024 addresses (49,152 to 4,243,455).</td>\n</tr>\n<tr>\n<td align=\"left\">0x4C</td>\n<td align=\"left\"><code>i_double_ind</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Pointer to 1024^2 addresses (up to ~4.29GB).</td>\n</tr>\n</tbody></table>\n<h3 id=\"32-internal-operation-context\">3.2. Internal Operation Context</h3>\n<p>Operations decompose a requested byte range <code>[offset, offset + length)</code> into a sequence of block-sized &quot;chunks&quot;.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Variable</th>\n<th align=\"left\">Definition</th>\n<th align=\"left\">Formula</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>block_index</code></td>\n<td align=\"left\">0-based logical block</td>\n<td align=\"left\"><code>offset / 4096</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>block_off</code></td>\n<td align=\"left\">Starting byte in block</td>\n<td align=\"left\"><code>offset % 4096</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>chunk</code></td>\n<td align=\"left\">Bytes to process in this block</td>\n<td align=\"left\"><code>min(4096 - block_off, remaining_len)</code></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"4-interface-contracts\">4. Interface Contracts</h2>\n<h3 id=\"41-file-lifecycle\">4.1. File Lifecycle</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Creates a regular file.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> parent_ino</span><span style=\"color:#6A737D\"> Inode of the directory to hold the file.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#6A737D\"> Filename (max 255 chars).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> mode</span><span style=\"color:#6A737D\"> Permissions (e.g., 0644).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@return</span><span style=\"color:#6A737D\"> New 1-based inode number, or negative errno (EEXIST, ENOSPC).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> fs_create_file</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> parent_ino</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                   const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> mode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> uid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> gid</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<h3 id=\"42-the-data-plane\">4.2. The Data Plane</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Reads data from a regular file.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#6A737D\"> Destination buffer.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@return</span><span style=\"color:#6A737D\"> Actual bytes read. Returns 0 if offset >= i_size.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@note</span><span style=\"color:#6A737D\"> Clamps length to i_size. Zero-fills sparse holes.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#B392F0\"> fs_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> ino</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                uint64_t</span><span style=\"color:#FFAB70\"> offset</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> length</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Writes data to a regular file.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@return</span><span style=\"color:#6A737D\"> Bytes written (always 'length' on success).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@note</span><span style=\"color:#6A737D\"> Triggers RMW for partial blocks. Allocates blocks on growth.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#B392F0\"> fs_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> ino</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                 uint64_t</span><span style=\"color:#FFAB70\"> offset</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> length</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Convenience wrapper for writing at current i_size.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#B392F0\"> fs_append</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> ino</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                  const</span><span style=\"color:#F97583\"> void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> length</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<h3 id=\"43-resizing\">4.3. Resizing</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Resizes a file to new_size.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@note</span><span style=\"color:#6A737D\"> Shrink: frees blocks > new_size and zeroes the last block's tail.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@note</span><span style=\"color:#6A737D\"> Extend: updates i_size, creating a sparse hole.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> fs_truncate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> ino</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#FFAB70\"> new_size</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"5-algorithm-specification\">5. Algorithm Specification</h2>\n<h3 id=\"51-fs_read-the-zero-fill-loop\">5.1. <code>fs_read</code>: The Zero-Fill Loop</h3>\n<ol>\n<li><strong>Read Inode:</strong> Load <code>inode_t</code> for <code>ino</code>.</li>\n<li><strong>Validate:</strong> Return <code>-EINVAL</code> if not <code>S_IFREG</code>.</li>\n<li><strong>Clamp:</strong> If <code>offset &gt;= i_size</code>, return <code>0</code>. If <code>offset + length &gt; i_size</code>, set <code>length = i_size - offset</code>.</li>\n<li><strong>Loop:</strong> While <code>remaining &gt; 0</code>:<ul>\n<li>Calculate <code>block_index</code>, <code>block_off</code>, and <code>chunk</code>.</li>\n<li>Call <code>inode_get_block(block_index * 4096)</code> (from M2).</li>\n<li><strong>Case Hole (<code>disk_block == 0</code>):</strong> <code>memset(buf + progress, 0, chunk)</code>. Skip Disk I/O.</li>\n<li><strong>Case Data (<code>disk_block != 0</code>):</strong> <code>read_block(disk_block, temp_buf)</code>. <code>memcpy(buf + progress, temp_buf + block_off, chunk)</code>.</li>\n<li>Update <code>progress</code>, <code>remaining</code>, <code>offset</code>.</li>\n</ul>\n</li>\n<li><strong>Metadata:</strong> Update <code>i_atime = now()</code>. Write Inode.</li>\n</ol>\n<h3 id=\"52-fs_write-the-read-modify-write-rmw-engine\">5.2. <code>fs_write</code>: The Read-Modify-Write (RMW) Engine</h3>\n<ol>\n<li><strong>Read Inode:</strong> Load <code>inode_t</code>.</li>\n<li><strong>Capacity Check:</strong> If <code>offset + length &gt; 4GB</code>, return <code>-EFBIG</code>.</li>\n<li><strong>Loop:</strong> While <code>remaining &gt; 0</code>:<ul>\n<li>Calculate <code>block_index</code>, <code>block_off</code>, and <code>chunk</code>.</li>\n<li>Determine if RMW is needed: <code>bool partial = (block_off != 0 || chunk &lt; 4096)</code>.</li>\n<li><code>inode_get_block</code> â†’ <code>disk_block</code>.</li>\n<li><strong>Case New Block (<code>disk_block == 0</code>):</strong><ul>\n<li><code>disk_block = alloc_data_block()</code>.</li>\n<li><code>inode_set_block(..., disk_block)</code>.</li>\n<li><code>memset(temp_buf, 0, 4096)</code>. (Ensures hole-alignment).</li>\n</ul>\n</li>\n<li><strong>Case Existing Block (<code>disk_block != 0</code>):</strong><ul>\n<li>If <code>partial</code>, <code>read_block(disk_block, temp_buf)</code>.</li>\n</ul>\n</li>\n<li><strong>Modify:</strong> <code>memcpy(temp_buf + block_off, buf + progress, chunk)</code>.</li>\n<li><strong>Write:</strong> <code>write_block(disk_block, temp_buf)</code>.</li>\n<li>Update <code>progress</code>, <code>remaining</code>, <code>offset</code>.</li>\n</ul>\n</li>\n<li><strong>Metadata:</strong> If <code>offset &gt; i_size</code>, <code>i_size = offset</code>. Set <code>i_mtime = i_ctime = now()</code>. Write Inode.</li>\n</ol>\n<h3 id=\"53-fs_truncate-shrink-with-data-leak-protection\">5.3. <code>fs_truncate</code>: Shrink with Data Leak Protection</h3>\n<ol>\n<li><strong>Read Inode.</strong></li>\n<li><strong>Extend Case (<code>new_size &gt; i_size</code>):</strong> Update <code>i_size</code>. Write Inode. Done.</li>\n<li><strong>Shrink Case (<code>new_size &lt; i_size</code>):</strong><ul>\n<li><strong>Zero Tail:</strong> Find the block index containing <code>new_size</code>. If <code>new_size % 4096 != 0</code>:<ul>\n<li><code>inode_get_block</code> â†’ <code>disk_block</code>.</li>\n<li>If <code>disk_block != 0</code>, <code>read_block</code>, <code>memset</code> bytes from <code>new_size % 4096</code> to 4095, <code>write_block</code>.</li>\n</ul>\n</li>\n<li><strong>Free Blocks:</strong> Iterate <code>bi</code> from <code>(new_size + 4095) / 4096</code> to <code>(old_size + 4095) / 4096</code>.<ul>\n<li>Call <code>inode_get_block(bi * 4096)</code>.</li>\n<li>If <code>disk_block != 0</code>, <code>free_data_block(disk_block)</code>.</li>\n<li><code>inode_set_block(..., 0)</code>. (Null the pointer).</li>\n</ul>\n</li>\n<li><strong>Cleanup:</strong> Call <code>truncate_free_indirect_if_empty</code> (M2 logic) to reclaim indirect pointer blocks.</li>\n</ul>\n</li>\n<li><strong>Metadata:</strong> <code>i_size = new_size</code>, <code>i_mtime = i_ctime = now()</code>.</li>\n</ol>\n<hr>\n<h2 id=\"6-error-handling-matrix\">6. Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error</th>\n<th align=\"left\">Detected By</th>\n<th align=\"left\">Recovery</th>\n<th align=\"left\">User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>ENOSPC</code></td>\n<td align=\"left\"><code>fs_write</code></td>\n<td align=\"left\">Stop write; return partial bytes written or error.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EFBIG</code></td>\n<td align=\"left\"><code>fs_write</code></td>\n<td align=\"left\">Reject write before allocation.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EINVAL</code></td>\n<td align=\"left\"><code>fs_read</code></td>\n<td align=\"left\">Ensure inode is regular file (<code>S_ISREG</code>).</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EIO</code></td>\n<td align=\"left\"><code>read_block</code></td>\n<td align=\"left\">Return I/O error; filesystem may be inconsistent.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\">Data Leak</td>\n<td align=\"left\"><code>fs_truncate</code></td>\n<td align=\"left\">Zeroing the tail of the partial block prevents reading old data.</td>\n<td align=\"left\">No (Internal)</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"7-implementation-sequence-with-checkpoints\">7. Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-creation-amp-math-2-hours\">Phase 1: Creation &amp; Math (2 Hours)</h3>\n<p>Implement <code>fs_create_file</code>. Use M2 <code>alloc_inode</code> and M3 <code>dir_add_entry</code>. Implement internal offset-to-block helpers.\n<strong>Checkpoint:</strong> <code>mkfs</code> a disk, call <code>fs_create_file(&quot;/test.txt&quot;)</code>. Verify <code>ls</code> shows the file.</p>\n<h3 id=\"phase-2-the-read-path-3-hours\">Phase 2: The Read Path (3 Hours)</h3>\n<p>Implement <code>fs_read</code>. Ensure it handles offsets correctly. Add <code>memset(0)</code> logic for sparse holes.\n<strong>Checkpoint:</strong> Manually set a block pointer in an inode to 0. Read 4KB at that offset. Verify buffer is all zeros and <code>read_block</code> was never called.</p>\n<h3 id=\"phase-3-the-write-path-4-hours\">Phase 3: The Write Path (4 Hours)</h3>\n<p>Implement <code>fs_write</code>. Implement the RMW cycle logic.\n<strong>Checkpoint:</strong> Write &quot;Hello&quot; at offset 0. Read back. Write &quot;World&quot; at offset 6. Read back. Verify &quot;Hello World&quot; is present (proves RMW preserved the space between them).</p>\n<h3 id=\"phase-4-truncate-amp-append-4-hours\">Phase 4: Truncate &amp; Append (4 Hours)</h3>\n<p>Implement <code>fs_truncate</code> (shrink/extend) and <code>fs_append</code>.\n<strong>Checkpoint:</strong> Create 10MB file. Truncate to 1MB. Verify <code>s_free_blocks</code> increases by ~2304 blocks.</p>\n<hr>\n<h2 id=\"8-test-specification\">8. Test Specification</h2>\n<h3 id=\"81-partial-block-rmw-verification\">8.1. Partial Block RMW Verification</h3>\n<ul>\n<li><strong>Test:</strong> Write &quot;A&quot; at offset 4095 (end of block 0) and &quot;B&quot; at 4096 (start of block 1).</li>\n<li><strong>Assertion:</strong> <code>fs_read</code> returns &quot;AB&quot; across the 4KB boundary. Block 0 and Block 1 must have been allocated.</li>\n</ul>\n<h3 id=\"82-sparse-hole-expansion\">8.2. Sparse Hole Expansion</h3>\n<ul>\n<li><strong>Test:</strong> Write &quot;X&quot; at offset 0. Write &quot;Y&quot; at offset 1,000,000.</li>\n<li><strong>Assertion:</strong> <code>fs_read</code> at offset 500,000 returns 0s. <code>i_size</code> is 1,000,001. <code>s_free_blocks</code> indicates only 2 data blocks (plus indirects) were used.</li>\n</ul>\n<h3 id=\"83-data-leakage-security\">8.3. Data Leakage (Security)</h3>\n<ul>\n<li><strong>Test:</strong> Write 4KB of <code>0xFF</code> to a file. Truncate to 10 bytes. Truncate back to 4KB (Extend).</li>\n<li><strong>Assertion:</strong> Reading bytes 11â€“4095 returns <code>0x00</code>, NOT <code>0xFF</code>.</li>\n</ul>\n<hr>\n<h2 id=\"9-performance-targets\">9. Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target</th>\n<th align=\"left\">Measurement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Sequential Read</td>\n<td align=\"left\">&gt; 200 MB/s</td>\n<td align=\"left\">DD from mount to /dev/null</td>\n</tr>\n<tr>\n<td align=\"left\">Aligned Write</td>\n<td align=\"left\">1 Disk I/O / 4KB</td>\n<td align=\"left\">No <code>read_block</code> calls in write path</td>\n</tr>\n<tr>\n<td align=\"left\">Random 1-byte Write</td>\n<td align=\"left\">2 Disk I/Os</td>\n<td align=\"left\">1 Read + 1 Write (RMW)</td>\n</tr>\n<tr>\n<td align=\"left\">Sparse Read</td>\n<td align=\"left\">&lt; 50ns / block</td>\n<td align=\"left\"><code>clock_gettime</code> for 4KB hole</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"10-hardware-soul-cache-and-alignment\">10. Hardware Soul (Cache and Alignment)</h2>\n<h3 id=\"101-write-amplification-analysis\">10.1. Write Amplification Analysis</h3>\n<p>Every write that is not 4096-byte aligned and 4096-byte sized triggers a Read-Modify-Write.</p>\n<ul>\n<li><strong>Example:</strong> <code>write(fd, &quot;a&quot;, 1)</code></li>\n<li><strong>Cost:</strong><ol>\n<li><code>read_block(n)</code>: 4096 bytes into RAM.</li>\n<li><code>memcpy</code>: 1 byte.</li>\n<li><code>write_block(n)</code>: 4096 bytes to Disk.</li>\n</ol>\n</li>\n<li><strong>Amplification:</strong> 8192 / 1 = 8192x.</li>\n<li><strong>Mitigation:</strong> Applications should buffer I/O to 4KB boundaries (e.g., <code>setvbuf</code> in C).</li>\n</ul>\n<h3 id=\"102-tlb-and-page-alignment\">10.2. TLB and Page Alignment</h3>\n<p>Our <code>block_buf</code> is 4096 bytes. To optimize performance, the buffer passed to <code>read(2)/write(2)</code> of the disk image should be <strong>page-aligned</strong> (using <code>posix_memalign</code>). This ensures that the kernel&#39;s Direct Memory Access (DMA) can map the buffer directly to physical disk sectors without an intermediate copy (Zero-Copy I/O).</p>\n<hr>\n<h3 id=\"\"></h3>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Ftdd-diag-21.svg\" alt=\"fs_write Read-Modify-Write Cycle â€” Before/After Block State\"></p>\n<p><strong>Read-Modify-Write (RMW) Decision Flow</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">text</span><pre class=\"arch-pre shiki-highlighted\"><code>Write Request (Offset, Length)\n|\n|-- Is Offset % 4096 == 0 AND Length &gt;= 4096?\n|   |-- YES: Full Block Write\n|   |   |-- No existing block? Allocate &amp; Write.\n|   |   |-- Existing block? Overwrite directly.\n|   |\n|   |-- NO: Partial Block Write (RMW)\n|       |-- No existing block? Allocate &amp; Zero-Fill.\n|       |-- Existing block? READ block into buffer.\n|       |-- MODIFY buffer with user data.\n|       |-- WRITE buffer back to disk.</code></pre></div>\n\n<h3 id=\"\"></h3>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Ftdd-diag-22.svg\" alt=\"fs_read(offset=6000, length=5000) â€” Cross-Block Data Walk\"></p>\n<p><strong>File Offset Arithmetic</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">text</span><pre class=\"arch-pre shiki-highlighted\"><code>File Offset: 10,000\nBlock Size:  4,096\n\nBlock Index: 10,000 / 4,096 = 2  (0-indexed)\nBlock Off:   10,000 % 4,096 = 1,808\nRemaining:   10,000 to End\nChunk:       min(4,096 - 1,808, total_len) = 2,288</code></pre></div>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: filesystem-m5 -->\n<h1 id=\"module-technical-design-specification-fuse-integration-filesystem-m5\">Module Technical Design Specification: FUSE Integration (filesystem-m5)</h1>\n<h2 id=\"1-module-charter\">1. Module Charter</h2>\n<p>The <strong>FUSE Integration</strong> module is the definitive bridge between the internal block-and-inode machinery and the Linux Virtual Filesystem (VFS). It provides the high-level interface that allows the operating system to treat a raw disk image as a mountable directory. </p>\n<p><strong>Scope:</strong></p>\n<ul>\n<li><strong>Translation:</strong> Converting VFS path-based requests into internal inode-based operations using the Milestone 3 resolution engine.</li>\n<li><strong>State Management:</strong> Maintaining the global filesystem context (<code>fs_ctx_t</code>), including the disk image file descriptor, the in-memory superblock, and a coarse-grained serialization lock.</li>\n<li><strong>Resource Mapping:</strong> Mapping internal <code>inode_t</code> fields to POSIX <code>struct stat</code> and <code>struct statvfs</code> records for system-wide compatibility.</li>\n<li><strong>Lifecycle:</strong> Orchestrating the mount-time initialization (including recovery hooks) and the unmount-time cleanup (ensuring metadata and data durability via <code>fsync</code>).</li>\n<li><strong>Optimization:</strong> Leveraging FUSE entry and attribute timeouts to mitigate the performance penalties of path resolution over the FUSE kernel-user boundary.</li>\n</ul>\n<p><strong>Out of Scope:</strong></p>\n<ul>\n<li>In-kernel filesystem logic (this is strictly a userspace daemon).</li>\n<li>Low-level FUSE protocol handling (delegated to <code>libfuse3</code>).</li>\n<li>Fine-grained locking or lock-free data structures (single global mutex).</li>\n</ul>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>Every callback must acquire the global <code>fs_lock</code> before accessing the <code>fs_ctx_t</code> or calling internal FS functions.</li>\n<li>The <code>fi-&gt;fh</code> (file handle) must be populated with the inode number during <code>open</code>/<code>create</code> to bypass path resolution in <code>read</code>/<code>write</code>.</li>\n<li>All callbacks must return negative errno values on failure (e.g., <code>-ENOENT</code>) as per the FUSE specification.</li>\n<li>No callback may return to the kernel without releasing the global lock, regardless of the error path.</li>\n</ul>\n<hr>\n<h2 id=\"2-file-structure\">2. File Structure</h2>\n<p>Implementation follows a strict integration sequence, moving from global state to specific VFS operations:</p>\n<ol>\n<li><code>myfs_main.c</code>: Entry point, argument parsing, and <code>fuse_main</code> invocation.</li>\n<li><code>fuse_context.h</code>: Definition of <code>FsCtx</code> and global lock macros.</li>\n<li><code>fuse_bridge.c</code>: Conversion logic (<code>inode_to_stat</code>, <code>path_to_inode</code>).</li>\n<li><code>fuse_ops_meta.c</code>: Implementation of <code>getattr</code>, <code>statfs</code>, <code>chmod</code>, <code>utimens</code>.</li>\n<li><code>fuse_ops_dir.c</code>: Implementation of <code>readdir</code>, <code>mkdir</code>, <code>rmdir</code>, <code>rename</code>, <code>unlink</code>.</li>\n<li><code>fuse_ops_file.c</code>: Implementation of <code>open</code>, <code>create</code>, <code>read</code>, <code>write</code>, <code>truncate</code>, <code>release</code>.</li>\n<li><code>Makefile</code>: Integration with <code>pkg-config --cflags --libs fuse3</code>.</li>\n</ol>\n<hr>\n<h2 id=\"3-complete-data-model\">3. Complete Data Model</h2>\n<h3 id=\"31-global-filesystem-context-fsctx\">3.1. Global Filesystem Context (FsCtx)</h3>\n<p>This structure resides in the heap/global segment of the FUSE daemon. It is the single source of truth for the mounted instance.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd;</span><span style=\"color:#6A737D\">                    // 0x00: Disk image file descriptor</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    superblock_t</span><span style=\"color:#E1E4E8\"> sb;</span><span style=\"color:#6A737D\">           // 0x04: In-memory copy of the superblock (4096 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_mutex_t</span><span style=\"color:#E1E4E8\"> lock;</span><span style=\"color:#6A737D\">      // 0x1004: Global coarse-grained lock (usually 40 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> mount_flags;</span><span style=\"color:#6A737D\">      // 0x102C: Internal flags (direct_io, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> image_path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">      // 0x1030: Path to the .img file for persistence</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} FsCtx;</span><span style=\"color:#6A737D\">                       // Total Size: ~4400 bytes</span></span></code></pre></div>\n\n<p><strong>Hardware Soul (Cache Line Analysis):</strong></p>\n<ul>\n<li><strong>Superblock Separation:</strong> The <code>sb</code> field (4KB) acts as a massive buffer that physically separates the <code>fd</code> and the <code>lock</code>. On modern CPUs with 64B cache lines, this ensures that frequent lock acquisitions (which dirty the cache line containing the mutex) do not cause false-sharing with the <code>fd</code> or other configuration flags.</li>\n<li><strong>Alignment:</strong> <code>FsCtx</code> should be page-aligned (<code>posix_memalign</code>) to ensure the <code>sb</code> field is aligned with the host&#39;s page cache, facilitating zero-copy reads from the image file into the context.</li>\n</ul>\n<h3 id=\"32-fuse-file-handle-fi-gtfh\">3.2. FUSE File Handle (fi-&gt;fh)</h3>\n<p>We utilize the 64-bit <code>fh</code> field in <code>struct fuse_file_info</code> to cache the inode number. This is critical for performance.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field</th>\n<th align=\"left\">Value</th>\n<th align=\"left\">Why?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>fi-&gt;fh</code></td>\n<td align=\"left\"><code>uint64_t(inode_num)</code></td>\n<td align=\"left\">Avoids calling <code>path_resolve</code> in every <code>read()</code> and <code>write()</code> call.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>fi-&gt;direct_io</code></td>\n<td align=\"left\"><code>1</code></td>\n<td align=\"left\">Bypasses the FUSE kernel page cache. Ensures correctness for the single-node implementation.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>fi-&gt;keep_cache</code></td>\n<td align=\"left\"><code>0</code></td>\n<td align=\"left\">Discard host-side page cache on close to prevent stale data.</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"4-interface-contracts\">4. Interface Contracts</h2>\n<h3 id=\"41-the-path-to-inode-bridge\">4.1. The Path-to-Inode Bridge</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Resolves a path to an inode number and fetches the inode.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#6A737D\"> Absolute path from FUSE.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> out_ino</span><span style=\"color:#6A737D\"> Target inode number.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> out_inode</span><span style=\"color:#6A737D\"> Pointer to a stack-allocated inode_t to fill.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@return</span><span style=\"color:#6A737D\"> 0 on success, -ENOENT or -EIO on failure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@note</span><span style=\"color:#6A737D\"> MUST be called while holding g_fs.lock.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> bridge_path_to_inode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">out_ino</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">inode_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">out_inode</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Maps inode_t fields to struct stat.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> st</span><span style=\"color:#6A737D\"> Pointer to the FUSE-provided stat structure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> bridge_inode_to_stat</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> ino_num</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> inode_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> stat </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">st</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<h3 id=\"42-core-fuse-callbacks-the-vfs-contract\">4.2. Core FUSE Callbacks (The VFS Contract)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Metadata</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> myfs_getattr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> stat </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">st</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> fuse_file_info </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">fi</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> myfs_statfs</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> statvfs </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">stbuf</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Directories</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> myfs_readdir</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">fuse_fill_dir_t</span><span style=\"color:#FFAB70\"> filler</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        off_t</span><span style=\"color:#FFAB70\"> offset</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> fuse_file_info </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">fi</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">enum</span><span style=\"color:#E1E4E8\"> fuse_readdir_flags </span><span style=\"color:#FFAB70\">flags</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> myfs_mkdir</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">mode_t</span><span style=\"color:#FFAB70\"> mode</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Files</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> myfs_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">mode_t</span><span style=\"color:#FFAB70\"> mode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> fuse_file_info </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">fi</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> myfs_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">off_t</span><span style=\"color:#FFAB70\"> offset</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> fuse_file_info </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">fi</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> myfs_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">off_t</span><span style=\"color:#FFAB70\"> offset</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> fuse_file_info </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">fi</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> myfs_truncate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">off_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> fuse_file_info </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">fi</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"5-algorithm-specification\">5. Algorithm Specification</h2>\n<h3 id=\"51-the-getattr-hot-path\">5.1. The <code>getattr</code> Hot-Path</h3>\n<p><code>getattr</code> is called by the kernel for almost every operation. </p>\n<ol>\n<li><strong>Lock:</strong> <code>pthread_mutex_lock(&amp;g_fs.lock)</code>.</li>\n<li><strong>Resolve:</strong> Call <code>path_resolve(path)</code>.</li>\n<li><strong>Handle Error:</strong> If <code>-ENOENT</code>, unlock and return <code>-ENOENT</code> immediately.</li>\n<li><strong>Read:</strong> Call <code>read_inode</code> for the resolved inode number.</li>\n<li><strong>Convert:</strong> Call <code>bridge_inode_to_stat</code>.<ul>\n<li><code>st-&gt;st_blocks</code> = <code>(inode-&gt;size + 511) / 512</code> (POSIX expects 512B blocks).</li>\n<li><code>st-&gt;st_blksize</code> = <code>4096</code>.</li>\n</ul>\n</li>\n<li><strong>Unlock:</strong> <code>pthread_mutex_unlock(&amp;g_fs.lock)</code>.</li>\n<li><strong>Return:</strong> <code>0</code>.</li>\n</ol>\n<h3 id=\"52-readdir-filler-loop\">5.2. <code>readdir</code> Filler Loop</h3>\n<ol>\n<li>Resolve <code>path</code> to <code>dir_ino</code>.</li>\n<li>Read <code>dir_ino</code> and verify <code>S_ISDIR</code>.</li>\n<li>Define a local context for the readdir callback.</li>\n<li>Invoke <code>dir_readdir(dir_ino, callback_fn)</code>.</li>\n<li>Inside <code>callback_fn</code>:<ul>\n<li>Call <code>filler(buf, name, &amp;st, 0, 0)</code>.</li>\n<li>If <code>filler</code> returns non-zero (buffer full), abort the scan and return <code>0</code> (FUSE will resume).</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"53-atomic-rename\">5.3. Atomic Rename</h3>\n<ol>\n<li>Identify <code>src_parent_path</code> and <code>src_name</code> from <code>old_path</code>.</li>\n<li>Identify <code>dst_parent_path</code> and <code>dst_name</code> from <code>new_path</code>.</li>\n<li><strong>Locking:</strong> Acquire <code>g_fs.lock</code>.</li>\n<li><strong>Validation:</strong><ul>\n<li>Resolve <code>src_ino</code>.</li>\n<li>If <code>new_path</code> exists, resolve <code>dst_ino</code> and check if <code>S_ISDIR</code> match.</li>\n<li>If <code>dst_ino</code> is a directory, verify it is empty.</li>\n</ul>\n</li>\n<li><strong>Mutation:</strong><ul>\n<li><code>dir_add_entry(dst_parent, dst_name, src_ino)</code>.</li>\n<li><code>dir_remove_entry(src_parent, src_name)</code>.</li>\n<li>Update <code>ctime</code> for <code>src_ino</code> and both parents.</li>\n</ul>\n</li>\n<li><strong>Unlock.</strong></li>\n</ol>\n<hr>\n<h2 id=\"6-error-handling-matrix\">6. Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error</th>\n<th align=\"left\">Detected By</th>\n<th align=\"left\">Recovery</th>\n<th align=\"left\">User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>ENOENT</code></td>\n<td align=\"left\"><code>path_resolve</code></td>\n<td align=\"left\">Standard return to VFS; shell prints &quot;No such file&quot;.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ENOTEMPTY</code></td>\n<td align=\"left\"><code>fs_rmdir</code></td>\n<td align=\"left\">Directory has entries; reject removal.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EBADF</code></td>\n<td align=\"left\"><code>myfs_read</code></td>\n<td align=\"left\"><code>fi-&gt;fh</code> is 0 or invalid.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EACCES</code></td>\n<td align=\"left\">FUSE Kernel</td>\n<td align=\"left\">Kernel checks <code>st_mode</code> returned by <code>getattr</code>.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ENOMEM</code></td>\n<td align=\"left\"><code>filler</code></td>\n<td align=\"left\">FUSE buffer is full; current readdir batch complete.</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EIO</code></td>\n<td align=\"left\"><code>read_block</code></td>\n<td align=\"left\">Disk image corrupted or unreadable.</td>\n<td align=\"left\">Yes</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"7-implementation-sequence-with-checkpoints\">7. Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-the-context-and-mount-2-hours\">Phase 1: The Context and Mount (2 Hours)</h3>\n<p>Implement <code>main</code> and the FUSE <code>init</code>/<code>destroy</code> callbacks.</p>\n<ul>\n<li><strong>init:</strong> Open the disk image, read the superblock into <code>g_fs.sb</code>, initialize the mutex.</li>\n<li><strong>destroy:</strong> <code>fsync(g_fs.fd)</code>, write the superblock back to block 0, close <code>fd</code>.\n<strong>Checkpoint:</strong> <code>./myfs disk.img /mnt/test</code> runs and waits. <code>mount | grep myfs</code> shows the mount point.</li>\n</ul>\n<h3 id=\"phase-2-metadata-and-navigation-3-hours\">Phase 2: Metadata and Navigation (3 Hours)</h3>\n<p>Implement <code>bridge_path_to_inode</code>, <code>bridge_inode_to_stat</code>, and <code>getattr</code>.\n<strong>Checkpoint:</strong> <code>ls /mnt/test</code> does not return &quot;Permission Denied&quot; or &quot;Invalid Argument&quot; (though it may be empty).</p>\n<h3 id=\"phase-3-directory-contents-3-hours\">Phase 3: Directory Contents (3 Hours)</h3>\n<p>Implement <code>readdir</code> (using Milestone 3 primitives).\n<strong>Checkpoint:</strong> <code>ls -la /mnt/test</code> correctly displays <code>.</code> and <code>..</code> with correct inode numbers (Inode 1).</p>\n<h3 id=\"phase-4-file-data-4-hours\">Phase 4: File Data (4 Hours)</h3>\n<p>Implement <code>create</code>, <code>open</code>, <code>read</code>, and <code>write</code>.</p>\n<ul>\n<li><strong>Crucial:</strong> In <code>open</code>, set <code>fi-&gt;fh = ino_num</code>.</li>\n<li><strong>Crucial:</strong> In <code>read</code>, use <code>(uint32_t)fi-&gt;fh</code>.\n<strong>Checkpoint:</strong> <code>echo &quot;hello&quot; &gt; /mnt/test/file.txt</code> followed by <code>cat /mnt/test/file.txt</code> works.</li>\n</ul>\n<h3 id=\"phase-5-the-full-posix-set-4-hours\">Phase 5: The Full POSIX Set (4 Hours)</h3>\n<p>Implement <code>mkdir</code>, <code>rmdir</code>, <code>unlink</code>, <code>truncate</code>, <code>rename</code>.\n<strong>Checkpoint:</strong> <code>mkdir</code>, <code>mv</code>, <code>rm</code> all behave exactly like a native ext4 directory.</p>\n<hr>\n<h2 id=\"8-test-specification\">8. Test Specification</h2>\n<h3 id=\"81-round-trip-persistence\">8.1. Round-Trip Persistence</h3>\n<ol>\n<li>Mount <code>disk.img</code>.</li>\n<li><code>mkdir /mnt/test/data</code>.</li>\n<li><code>echo &quot;bytes&quot; &gt; /mnt/test/data/file.bin</code>.</li>\n<li>Unmount (<code>fusermount3 -u</code>).</li>\n<li>Remount.</li>\n<li><strong>Assertion:</strong> <code>cat /mnt/test/data/file.bin</code> returns &quot;bytes&quot;.</li>\n</ol>\n<h3 id=\"82-concurrent-access-stress\">8.2. Concurrent Access (Stress)</h3>\n<ol>\n<li>In terminal A: <code>while true; do ls -R /mnt/test; done</code>.</li>\n<li>In terminal B: <code>while true; do dd if=/dev/urandom of=/mnt/test/stress bs=4k count=10; done</code>.</li>\n<li><strong>Assertion:</strong> No kernel panics, no &quot;Transport endpoint not connected&quot;, no deadlocks.</li>\n</ol>\n<h3 id=\"83-sparse-file-verification-via-tools\">8.3. Sparse File Verification via Tools</h3>\n<ol>\n<li><code>truncate -s 1G /mnt/test/huge</code>.</li>\n<li><code>ls -l /mnt/test/huge</code> shows 1GB.</li>\n<li><code>du -h /mnt/test/huge</code> shows 0.</li>\n<li><strong>Assertion:</strong> Filesystem correctly reports logical vs physical size via <code>getattr</code>.</li>\n</ol>\n<hr>\n<h2 id=\"9-performance-targets\">9. Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target</th>\n<th align=\"left\">Measurement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>getattr</code> Latency</td>\n<td align=\"left\">&lt; 5ms (Cold)</td>\n<td align=\"left\"><code>time ls /mnt/test</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>read</code> Throughput</td>\n<td align=\"left\">&gt; 80% of Raw Image Read</td>\n<td align=\"left\"><code>dd</code> from mount vs <code>dd</code> from image</td>\n</tr>\n<tr>\n<td align=\"left\">Context Switch</td>\n<td align=\"left\">&lt; 10Î¼s per call</td>\n<td align=\"left\"><code>strace -c</code> total time / call count</td>\n</tr>\n<tr>\n<td align=\"left\">Unmount Time</td>\n<td align=\"left\">&lt; 1s</td>\n<td align=\"left\"><code>time fusermount3 -u</code></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"10-concurrency-specification-global-lock\">10. Concurrency Specification (Global Lock)</h2>\n<p>The global mutex implementation follows a &quot;Leaf-Only Locking&quot; strategy:</p>\n<ol>\n<li><strong>Acquisition:</strong> Every callback acquires <code>g_fs.lock</code> at the first line of execution.</li>\n<li><strong>Recursion:</strong> Internal functions (like <code>path_resolve</code>) <strong>MUST NOT</strong> acquire the lock themselves, as the mutex is non-recursive.</li>\n<li><strong>I/O:</strong> The lock is held during <code>read_block/write_block</code>. While this serializes I/O, it ensures that the Superblock and Bitmaps remain consistent across threads without complex fine-grained coordination.</li>\n<li><strong>Release:</strong> The lock is released only at the <code>return</code> statement of the FUSE callback.</li>\n</ol>\n<hr>\n<h3 id=\"\"></h3>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Ftdd-diag-27.svg\" alt=\"FUSE Architecture â€” Kernel/Userspace Data Flow\"></p>\n<p><strong>FUSE to Internal FS Call Flow</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">text</span><pre class=\"arch-pre shiki-highlighted\"><code>Application: open(&quot;/mnt/myfs/doc.txt&quot;)\n      |\n      V (System Call)\nLinux Kernel VFS\n      |\n      V (FUSE Kernel Module)\n/dev/fuse &lt;--- (Writes Request: OPEN, path=&quot;/doc.txt&quot;)\n      |\n      V (Context Switch)\nlibfuse (Reads /dev/fuse)\n      |\n      V (Calls myfs_open)\n+---------------------------------------+\n| myfs_open(&quot;/doc.txt&quot;)                 |\n| 1. lock(g_fs.lock)                    |\n| 2. ino = path_resolve(&quot;/doc.txt&quot;)     |\n| 3. fi-&gt;fh = ino                       |\n| 4. unlock(g_fs.lock)                  |\n| 5. return 0                           |\n+---------------------------------------+</code></pre></div>\n\n<h3 id=\"\"></h3>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Ftdd-diag-28.svg\" alt=\"FUSE Callbacks â†’ Internal Operations Mapping Table\"></p>\n<p><strong>Stat Bridge Mapping</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">text</span><pre class=\"arch-pre shiki-highlighted\"><code>inode_t (Internal)              struct stat (POSIX)\n+-----------------+             +-------------------+\n| i_mode          | ----------&gt; | st_mode           |\n| i_nlinks        | ----------&gt; | st_nlink          |\n| i_uid / i_gid   | ----------&gt; | st_uid / st_gid   |\n| i_size          | ----------&gt; | st_size           |\n| i_atime         | ----------&gt; | st_atim.tv_sec    |\n| i_mtime         | ----------&gt; | st_mtim.tv_sec    |\n| (ino_num)       | ----------&gt; | st_ino            |\n+-----------------+             +-------------------+</code></pre></div>\n\n\n<!-- END_TDD_MOD -->\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: filesystem-m6 -->\n<h1 id=\"module-technical-design-specification-write-ahead-journaling-and-crash-recovery-filesystem-m6\">Module Technical Design Specification: Write-Ahead Journaling and Crash Recovery (filesystem-m6)</h1>\n<h2 id=\"1-module-charter\">1. Module Charter</h2>\n<p>The <strong>Write-Ahead Journaling and Crash Recovery</strong> module is the final and most critical layer of the filesystem, providing a mathematical guarantee of metadata consistency in the event of power failure or system crash. It implements a sequential, circular write-ahead log (WAL) that captures intended metadata changes before they are applied to the primary on-disk structures.</p>\n<p><strong>Scope:</strong></p>\n<ul>\n<li><strong>Atomicity:</strong> Wrapping multi-block metadata updates (e.g., <code>mkdir</code> which touches a bitmap, two inodes, and a directory block) into single, atomic transactions.</li>\n<li><strong>Durability:</strong> Implementing the double-<code>fsync</code> protocol to ensure journal entries and commit records are persisted to physical media in the correct order.</li>\n<li><strong>Recovery:</strong> Automated scanning and replaying of the journal at mount-time to restore the filesystem to its last known consistent state.</li>\n<li><strong>Checkpointing:</strong> Managing the circular buffer life cycle, including flushing journaled changes to their final locations and advancing the journal head.</li>\n<li><strong>Integration:</strong> Converting all existing mutation logic (from M2, M3, and M4) to use a transaction-based API rather than direct block writes.</li>\n</ul>\n<p><strong>Out of Scope:</strong></p>\n<ul>\n<li><strong>Data Journaling:</strong> Only metadata (bitmaps, inodes, directory blocks) is journaled. File data blocks are written using &quot;ordered&quot; mode (data-first, then metadata-journal).</li>\n<li><strong>Distributed Consensus:</strong> This is a single-node consistency mechanism.</li>\n<li><strong>Checksum Offloading:</strong> Checksums are computed in software, not via hardware CRC32 instructions (for portability).</li>\n</ul>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>No metadata block may be written to its permanent location until its corresponding transaction&#39;s <strong>Commit Record</strong> is durable on disk.</li>\n<li>Journal replay must be <strong>idempotent</strong>: replaying the same transaction multiple times must produce the same result as a single replay.</li>\n<li>The <code>j_head</code> must never be overtaken by <code>j_tail</code>; the filesystem must block and checkpoint if the journal is full.</li>\n<li>All journaled blocks must be exactly 4096 bytes and aligned to 4KB boundaries.</li>\n</ul>\n<hr>\n<h2 id=\"2-file-structure\">2. File Structure</h2>\n<p>Implementation follows a transition from data definitions to transaction logic, followed by recovery and integration.</p>\n<ol>\n<li><code>journal_types.h</code>: On-disk structure definitions for the journal superblock, descriptors, and commit blocks.</li>\n<li><code>journal_io.c</code>: Low-level journal region addressing and circular buffer math (<code>journal_abs_block</code>).</li>\n<li><code>txn.h / txn.c</code>: The Transaction API (<code>txn_begin</code>, <code>txn_journal_block</code>, <code>txn_commit</code>).</li>\n<li><code>recovery.c</code>: The crash recovery engine (<code>journal_recover</code>) and idempotency checks.</li>\n<li><code>checkpoint.c</code>: Journal clearing logic (<code>journal_checkpoint</code>) and background flush coordination.</li>\n<li><code>journal_wrappers.c</code>: Journaled versions of <code>write_inode</code>, <code>bitmap_set</code>, etc.</li>\n<li><code>test_m6_crash.c</code>: A simulation suite that kills the process mid-transaction to verify recovery.</li>\n</ol>\n<hr>\n<h2 id=\"3-complete-data-model\">3. Complete Data Model</h2>\n<h3 id=\"31-journal-superblock-journal_super_t\">3.1. Journal Superblock (<code>journal_super_t</code>)</h3>\n<p>Resides at absolute block <code>sb-&gt;s_journal_start</code>. It tracks the live region of the circular log.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Offset</th>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0x00</td>\n<td align=\"left\"><code>j_magic</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\"><code>0x4A4F5552</code> (&quot;JOUR&quot;).</td>\n</tr>\n<tr>\n<td align=\"left\">0x04</td>\n<td align=\"left\"><code>j_block_type</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Always <code>0x01</code> (Superblock).</td>\n</tr>\n<tr>\n<td align=\"left\">0x08</td>\n<td align=\"left\"><code>j_sequence</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Monotonic ID of the next transaction to be written.</td>\n</tr>\n<tr>\n<td align=\"left\">0x0C</td>\n<td align=\"left\"><code>j_head</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Index of the oldest unapplied transaction in the journal.</td>\n</tr>\n<tr>\n<td align=\"left\">0x10</td>\n<td align=\"left\"><code>j_tail</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Index where the next transaction will be written.</td>\n</tr>\n<tr>\n<td align=\"left\">0x14</td>\n<td align=\"left\"><code>j_total_blocks</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Number of usable blocks in the journal (usually <code>s_journal_len - 1</code>).</td>\n</tr>\n<tr>\n<td align=\"left\">0x18</td>\n<td align=\"left\"><code>j_reserved</code></td>\n<td align=\"left\"><code>uint8_t[4072]</code></td>\n<td align=\"left\">Padding to 4096 bytes.</td>\n</tr>\n</tbody></table>\n<h3 id=\"32-descriptor-block-journal_desc_t\">3.2. Descriptor Block (<code>journal_desc_t</code>)</h3>\n<p>Describes the &quot;payload&quot; of a transaction. It lists which filesystem blocks are being updated.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Offset</th>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0x00</td>\n<td align=\"left\"><code>j_magic</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\"><code>0x4A4F5552</code>.</td>\n</tr>\n<tr>\n<td align=\"left\">0x04</td>\n<td align=\"left\"><code>j_block_type</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Always <code>0x02</code> (Descriptor).</td>\n</tr>\n<tr>\n<td align=\"left\">0x08</td>\n<td align=\"left\"><code>j_sequence</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Transaction sequence ID.</td>\n</tr>\n<tr>\n<td align=\"left\">0x0C</td>\n<td align=\"left\"><code>j_nr_blocks</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Number of data blocks immediately following this descriptor.</td>\n</tr>\n<tr>\n<td align=\"left\">0x10</td>\n<td align=\"left\"><code>j_block_map[500]</code></td>\n<td align=\"left\"><code>uint64_t[500]</code></td>\n<td align=\"left\">The target block numbers in the primary FS for each journaled block.</td>\n</tr>\n</tbody></table>\n<h3 id=\"33-commit-block-journal_commit_t\">3.3. Commit Block (<code>journal_commit_t</code>)</h3>\n<p>The &quot;Atomic Sentinel&quot;. Its presence on disk signifies a successful transaction.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Offset</th>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0x00</td>\n<td align=\"left\"><code>j_magic</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\"><code>0x4A4F5552</code>.</td>\n</tr>\n<tr>\n<td align=\"left\">0x04</td>\n<td align=\"left\"><code>j_block_type</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Always <code>0x03</code> (Commit).</td>\n</tr>\n<tr>\n<td align=\"left\">0x08</td>\n<td align=\"left\"><code>j_sequence</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Must match the corresponding Descriptor sequence.</td>\n</tr>\n<tr>\n<td align=\"left\">0x0C</td>\n<td align=\"left\"><code>j_checksum</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Cumulative sum of all bytes in the transaction&#39;s data blocks.</td>\n</tr>\n<tr>\n<td align=\"left\">0x10</td>\n<td align=\"left\"><code>j_reserved</code></td>\n<td align=\"left\"><code>uint8_t[4080]</code></td>\n<td align=\"left\">Padding to 4096 bytes.</td>\n</tr>\n</tbody></table>\n<h3 id=\"34-in-memory-transaction-txn_t\">3.4. In-Memory Transaction (<code>txn_t</code>)</h3>\n<p>Accumulates changes before flushing.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_TXN_BLOCKS</span><span style=\"color:#79B8FF\"> 64</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> sequence;</span><span style=\"color:#6A737D\">                // Sequence number for this txn</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> nr_blocks;</span><span style=\"color:#6A737D\">              // Current count of dirty metadata blocks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#FFAB70\"> targets</span><span style=\"color:#E1E4E8\">[MAX_TXN_BLOCKS];</span><span style=\"color:#6A737D\"> // Original FS block numbers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\">  data</span><span style=\"color:#E1E4E8\">[MAX_TXN_BLOCKS][</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\"> // New content for these blocks</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">txn_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"4-interface-contracts\">4. Interface Contracts</h2>\n<h3 id=\"41-transaction-life-cycle\">4.1. Transaction Life Cycle</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Starts a new metadata transaction.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> txn</span><span style=\"color:#6A737D\"> Pointer to stack-allocated txn_t.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> txn_begin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">txn_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">txn</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Stages a metadata block for journaling. </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * If the block is already in the txn, it is overwritten (deduplication).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@return</span><span style=\"color:#6A737D\"> 0 on success, -ENOSPC if txn is full (64 blocks).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> txn_journal_block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">txn_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">txn</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> fs_block_num</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Executes the 8-step commit protocol.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@return</span><span style=\"color:#6A737D\"> 0 on success. If returns &#x3C; 0, the FS must remain in its PRE-txn state.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> txn_commit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">txn_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">txn</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<h3 id=\"42-recovery-amp-maintenance\">4.2. Recovery &amp; Maintenance</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Scans the journal and replays all committed transactions.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * MUST be called before FUSE starts.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> journal_recover</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Flushes the circular buffer and resets j_head to j_tail.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> journal_checkpoint</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">superblock_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sb</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"5-algorithm-specification\">5. Algorithm Specification</h2>\n<h3 id=\"51-the-txn_commit-protocol-8-step\">5.1. The <code>txn_commit</code> Protocol (8-Step)</h3>\n<p>To ensure durability, the commit follows a strict ordering of writes and barriers:</p>\n<ol>\n<li><strong>Prepare Descriptor:</strong> Populate <code>journal_desc_t</code> with <code>nr_blocks</code> and <code>targets</code>.</li>\n<li><strong>Write Descriptor:</strong> <code>write_block(abs_journal_tail++, desc)</code>.</li>\n<li><strong>Write Data:</strong> For each block in <code>txn-&gt;data</code>, <code>write_block(abs_journal_tail++, data)</code>.</li>\n<li><strong>Barrier 1:</strong> <code>fsync(fd)</code>. Ensures journal data is on disk before the commit record exists.</li>\n<li><strong>Write Commit:</strong> <code>write_block(abs_journal_tail++, commit_record)</code>.</li>\n<li><strong>Barrier 2 (The Point of No Return):</strong> <code>fsync(fd)</code>. Transaction is now durable.</li>\n<li><strong>Apply In-Place:</strong> Iterate through <code>txn-&gt;targets</code> and write <code>txn-&gt;data</code> to the primary FS region.</li>\n<li><strong>Update Super:</strong> Update <code>g_jsuper.j_tail</code>, <code>g_jsuper.j_sequence++</code>, and <code>write_block(sb-&gt;j_start, jsuper)</code>.</li>\n</ol>\n<h3 id=\"52-journal_recover-replay-logic\">5.2. <code>journal_recover</code> (Replay Logic)</h3>\n<p>On mount, the system performs a linear scan of the journal region.</p>\n<ol>\n<li>Load <code>journal_super_t</code>.</li>\n<li>Set <code>current_pos = j_head</code>.</li>\n<li><strong>While</strong> <code>current_pos != j_tail</code>:<ul>\n<li>Read <code>desc = read_block(current_pos)</code>.</li>\n<li>If <code>desc-&gt;j_type != JB_TYPE_DESC</code>, advance <code>current_pos</code> and continue.</li>\n<li>Locate the <strong>Commit Block</strong> at <code>current_pos + 1 + desc-&gt;j_nr_blocks</code>.</li>\n<li><strong>If</strong> Commit Block exists AND <code>commit-&gt;j_sequence == desc-&gt;j_sequence</code> AND Checksum matches:<ul>\n<li><strong>REPLAY:</strong> For <code>i</code> in <code>0..desc-&gt;j_nr_blocks</code>:<ul>\n<li><code>data = read_block(current_pos + 1 + i)</code>.</li>\n<li><code>write_block(desc-&gt;j_block_map[i], data)</code>.</li>\n</ul>\n</li>\n<li>Advance <code>current_pos</code> past the commit block.</li>\n</ul>\n</li>\n<li><strong>Else</strong>:<ul>\n<li><strong>DISCARD:</strong> The transaction was not committed. Stop recovery.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Call <code>journal_checkpoint</code> to clear the log.</li>\n</ol>\n<h3 id=\"53-ordered-data-write-metadata-only-mode\">5.3. Ordered Data Write (Metadata-Only Mode)</h3>\n<p>When a file is written (<code>fs_write</code>), we must ensure the data blocks land on disk <em>before</em> the metadata (inode size/pointers) that references them is journaled.</p>\n<ol>\n<li><strong>Write File Data:</strong> Use <code>write_block</code> directly on the data region blocks.</li>\n<li><strong>Barrier:</strong> <code>fsync(fd)</code>.</li>\n<li><strong>Start Transaction:</strong> <code>txn_begin</code>.</li>\n<li><strong>Journal Inode:</strong> <code>txn_journal_block(inode_table_block)</code>.</li>\n<li><strong>Commit:</strong> <code>txn_commit</code>.\n<em>Why?</em> If we crash between 2 and 5, the data is on disk but the inode size is old. No corruption. If we crash between 4 and 5, the data is there, but the transaction isn&#39;t committed. Still no corruption.</li>\n</ol>\n<hr>\n<h2 id=\"6-error-handling-matrix\">6. Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error</th>\n<th align=\"left\">Detected By</th>\n<th align=\"left\">Recovery</th>\n<th align=\"left\">User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>ENOSPC</code> (Journal)</td>\n<td align=\"left\"><code>txn_commit</code></td>\n<td align=\"left\">Invoke <code>journal_checkpoint</code> immediately to free space.</td>\n<td align=\"left\">No (Delayed)</td>\n</tr>\n<tr>\n<td align=\"left\">Checksum Fail</td>\n<td align=\"left\"><code>journal_recover</code></td>\n<td align=\"left\">Discard the transaction; assume it was a partial write during crash.</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EIO</code> (Barrier 1)</td>\n<td align=\"left\"><code>txn_commit</code></td>\n<td align=\"left\">Fail the transaction. Data has not been applied in-place.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EIO</code> (Barrier 2)</td>\n<td align=\"left\"><code>txn_commit</code></td>\n<td align=\"left\">FATAL. The filesystem state is now ambiguous.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\">Wrap-around</td>\n<td align=\"left\"><code>journal_abs_block</code></td>\n<td align=\"left\"><code>index % j_total_blocks</code>. Ensure block 0 of region is skipped.</td>\n<td align=\"left\">No</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"7-implementation-sequence-with-checkpoints\">7. Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-journal-basics-3-hours\">Phase 1: Journal Basics (3 Hours)</h3>\n<p>Define all <code>packed</code> structures. Implement <code>journal_abs_block</code> for circular addressing. Implement <code>journal_load</code> and <code>journal_persist_super</code>.\n<strong>Checkpoint:</strong> <code>test_journal_layout</code> formats a journal and verifies the superblock is written correctly at the start of the journal region.</p>\n<h3 id=\"phase-2-the-transaction-engine-5-hours\">Phase 2: The Transaction Engine (5 Hours)</h3>\n<p>Implement <code>txn_begin</code>, <code>txn_journal_block</code> (with deduplication logic), and the 8-step <code>txn_commit</code>.\n<strong>Checkpoint:</strong> Call <code>txn_commit</code> on a 5-block update. Use <code>hexdump</code> on the <code>.img</code> file to verify the Descriptor, Data, and Commit blocks appear in sequence in the journal region.</p>\n<h3 id=\"phase-3-recovery-amp-checkpointing-6-hours\">Phase 3: Recovery &amp; Checkpointing (6 Hours)</h3>\n<p>Implement <code>journal_recover</code> and <code>journal_checkpoint</code>. </p>\n<ul>\n<li><strong>Idempotency Test:</strong> Write a transaction, call <code>journal_recover</code> twice, and verify the filesystem state is identical after both calls.\n<strong>Checkpoint:</strong> Manually write a committed transaction to the journal but do <em>not</em> apply it in-place. Run <code>journal_recover</code>. Verify the primary FS blocks now match the journaled data.</li>\n</ul>\n<h3 id=\"phase-4-integration-4-hours\">Phase 4: Integration (4 Hours)</h3>\n<p>Convert <code>write_inode</code>, <code>bitmap_set</code>, and directory mutations to use <code>txn_t</code>.\n<strong>Checkpoint:</strong> <code>mkdir(&quot;/test&quot;)</code> now results in multiple blocks appearing in the journal before the directory is visible in <code>ls</code>.</p>\n<h3 id=\"phase-5-the-crash-simulation-4-hours\">Phase 5: The Crash Simulation (4 Hours)</h3>\n<p>Write a test that kills the FUSE process using <code>SIGKILL</code> during the middle of <code>txn_commit</code> (between step 3 and 5). \n<strong>Checkpoint:</strong> Mount the image again. Verify that the &quot;interrupted&quot; operation either fully happened or did not happen at all, but the filesystem remains mountable and <code>fsck</code> passes.</p>\n<hr>\n<h2 id=\"8-test-specification\">8. Test Specification</h2>\n<h3 id=\"81-atomic-rename-verification\">8.1. Atomic <code>rename</code> Verification</h3>\n<ol>\n<li><code>rename(&quot;/A&quot;, &quot;/B&quot;)</code>. </li>\n<li>Internally, this involves <code>dir_remove(A)</code> and <code>dir_add(B)</code>.</li>\n<li>Inject a crash between these two internal steps.</li>\n<li><strong>Assertion:</strong> After recovery, either the file is at <code>/A</code> OR at <code>/B</code>. It must NEVER be at both, and it must NEVER be at neither.</li>\n</ol>\n<h3 id=\"82-journal-wrap-around\">8.2. Journal Wrap-around</h3>\n<ol>\n<li>Set journal size to 10 blocks.</li>\n<li>Write 5 transactions of 3 blocks each.</li>\n<li><strong>Assertion:</strong> The system correctly triggers checkpoints when <code>j_tail</code> approaches <code>j_head</code>, and the journal continues to function using circular logic.</li>\n</ol>\n<h3 id=\"83-idempotent-replay\">8.3. Idempotent Replay</h3>\n<ol>\n<li>Commit a transaction that sets Inode 5&#39;s size to 100 bytes.</li>\n<li>Manually run <code>journal_recover</code> twice.</li>\n<li><strong>Assertion:</strong> Inode 5 size is 100 bytes. The second replay did not &quot;increment&quot; or corrupt the value.</li>\n</ol>\n<hr>\n<h2 id=\"9-performance-targets\">9. Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target</th>\n<th align=\"left\">Measurement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>txn_commit</code> (Metadata)</td>\n<td align=\"left\">&lt; 2ms (SSD)</td>\n<td align=\"left\">Two <code>fsync</code> barriers + sequential writes.</td>\n</tr>\n<tr>\n<td align=\"left\">Recovery (4MB Journal)</td>\n<td align=\"left\">&lt; 50ms</td>\n<td align=\"left\">Time from <code>journal_load</code> to <code>journal_checkpoint</code>.</td>\n</tr>\n<tr>\n<td align=\"left\">Write Amplification</td>\n<td align=\"left\">~2.5x</td>\n<td align=\"left\">Ratio of (Journal Bytes + FS Bytes) / (User Bytes) for metadata.</td>\n</tr>\n<tr>\n<td align=\"left\">Throughput (Ordered)</td>\n<td align=\"left\">&gt; 90% of M4</td>\n<td align=\"left\">Data blocks bypass the journal; metadata is small.</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"10-hardware-soul-atomic-writes\">10. Hardware Soul (Atomic Writes)</h2>\n<h3 id=\"101-the-sector-atomicity-assumption\">10.1. The Sector Atomicity Assumption</h3>\n<p>Our design relies on the fact that a <strong>single sector write (512B or 4KB)</strong> is atomic at the hardware level. The <code>journal_commit_t</code> block is the lynchpin. Because we write it in a single block operation (4KB), the hardware ensures it is either fully written or not written at all. We never have to handle a &quot;half-written&quot; commit record.</p>\n<h3 id=\"102-barrier-analysis\">10.2. Barrier Analysis</h3>\n<ul>\n<li><strong>Barrier 1:</strong> Protects against the disk controller&#39;s Out-of-Order execution. It ensures the &quot;intent&quot; (data blocks) is physically on the platters/NAND before the &quot;permission&quot; (commit record) is granted.</li>\n<li><strong>Barrier 2:</strong> Protects against the &quot;Volatile Write Cache&quot; (DRAM on the disk). It ensures the commit record is persistent, making the transaction a permanent part of history before we begin the &quot;messy&quot; in-place updates.</li>\n</ul>\n<hr>\n<h3 id=\"diagramtdd-diag-32\">{{DIAGRAM:tdd-diag-32}}</h3>\n<p><strong>Circular Journal Buffer States</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">text</span><pre class=\"arch-pre shiki-highlighted\"><code>[S][D][B1][B2][C][.][.][.][.][.]\n ^  ^           ^  ^\n |  j_head      |  j_tail (Next write)\n j_super        j_tail - 1 (Last Commit)\n\nWrap-around:\n[.][.][.][S][D][B1][B2][C][D][B1]\n ^        ^                 ^\n j_tail   j_super           j_head</code></pre></div>\n\n<h3 id=\"\"></h3>\n<p><img src=\"/api/project/filesystem/architecture-doc/asset?path=diagrams%2Ftdd-diag-33.svg\" alt=\"Journal Entry Structures â€” Byte Layout for DESC, COMMIT, and Journal Superblock\"></p>\n<p><strong>The Transaction Write Pipeline</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">text</span><pre class=\"arch-pre shiki-highlighted\"><code>1. txn_journal_block(B5) -&gt; Mem Buffer\n2. txn_journal_block(B10) -&gt; Mem Buffer\n3. txn_commit()\n   |-- Write Desc (B5, B10) to Journal\n   |-- Write Data (B5_new, B10_new) to Journal\n   |-- fsync() &lt;------------------------------- Barrier 1\n   |-- Write Commit to Journal\n   |-- fsync() &lt;------------------------------- Barrier 2 (Durability Point)\n   |-- Write B5_new to Inode Table\n   |-- Write B10_new to Inode Bitmap\n   |-- Update Journal Super (Advance Tail)</code></pre></div>\n<!-- END_TDD_MOD -->\n\n\n<h1 id=\"project-structure-filesystem-implementation\">Project Structure: Filesystem Implementation</h1>\n<h2 id=\"directory-tree\">Directory Tree</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">text</span><pre class=\"arch-pre shiki-highlighted\"><code>filesystem-root/\nâ”œâ”€â”€ include/                 # Header Definitions\nâ”‚   â”œâ”€â”€ fs_types.h          # Global constants and magic (M1)\nâ”‚   â”œâ”€â”€ block_io.h          # Block read/write prototypes (M1)\nâ”‚   â”œâ”€â”€ bitmap.h            # Bitmap manipulation macros (M1)\nâ”‚   â”œâ”€â”€ superblock.h        # Superblock structure (M1)\nâ”‚   â”œâ”€â”€ inode.h             # Inode structure &amp; limits (M2)\nâ”‚   â”œâ”€â”€ dir.h               # Dirent structures (M3)\nâ”‚   â”œâ”€â”€ file_ops.h          # File I/O prototypes (M4)\nâ”‚   â”œâ”€â”€ fuse_context.h      # Global FsCtx &amp; locking (M5)\nâ”‚   â”œâ”€â”€ journal_types.h     # Journaling block types (M6)\nâ”‚   â””â”€â”€ txn.h               # Transaction API (M6)\nâ”œâ”€â”€ src/                     # Source Implementation\nâ”‚   â”œâ”€â”€ core/               # Layer 1: Block Foundation\nâ”‚   â”‚   â”œâ”€â”€ block_io.c      # lseek/read/write wrappers (M1)\nâ”‚   â”‚   â”œâ”€â”€ bitmap.c        # Bit-level search logic (M1)\nâ”‚   â”‚   â””â”€â”€ superblock.c    # Layout &amp; serialization (M1)\nâ”‚   â”œâ”€â”€ inode/              # Layer 2: Metadata Management\nâ”‚   â”‚   â”œâ”€â”€ inode_io.c      # Inode RMW cycles (M2)\nâ”‚   â”‚   â”œâ”€â”€ inode_alloc.c   # Inode bitmap integration (M2)\nâ”‚   â”‚   â”œâ”€â”€ inode_tree.c    # Indirect pointer traversal (M2)\nâ”‚   â”‚   â””â”€â”€ inode_free_recursive.c # Depth-first reclamation (M2)\nâ”‚   â”œâ”€â”€ dir/                # Layer 3: Directory Hierarchy\nâ”‚   â”‚   â”œâ”€â”€ dir_rec.c       # Record padding/length math (M3)\nâ”‚   â”‚   â”œâ”€â”€ dir_scan.c      # Linear entry scanning (M3)\nâ”‚   â”‚   â”œâ”€â”€ dir_path.c      # Recursive path resolution (M3)\nâ”‚   â”‚   â”œâ”€â”€ dir_write.c     # Entry splitting/merging (M3)\nâ”‚   â”‚   â””â”€â”€ dir_op.c        # mkdir/rmdir/link logic (M3)\nâ”‚   â”œâ”€â”€ file/               # Layer 4: File Data Plane\nâ”‚   â”‚   â”œâ”€â”€ file_create.c   # File-specific allocation (M4)\nâ”‚   â”‚   â”œâ”€â”€ file_read.c     # Sparse hole handling (M4)\nâ”‚   â”‚   â”œâ”€â”€ file_write.c    # RMW data engine (M4)\nâ”‚   â”‚   â””â”€â”€ file_truncate.c # Shrink/Extend space recovery (M4)\nâ”‚   â”œâ”€â”€ fuse/               # Layer 5: OS Integration\nâ”‚   â”‚   â”œâ”€â”€ myfs_main.c     # libfuse entry point (M5)\nâ”‚   â”‚   â”œâ”€â”€ fuse_bridge.c   # path-to-inode translation (M5)\nâ”‚   â”‚   â”œâ”€â”€ fuse_ops_meta.c # getattr/statfs/chmod (M5)\nâ”‚   â”‚   â”œâ”€â”€ fuse_ops_dir.c  # readdir/mkdir/unlink (M5)\nâ”‚   â”‚   â””â”€â”€ fuse_ops_file.c # open/read/write/release (M5)\nâ”‚   â””â”€â”€ journal/            # Layer 6: Consistency\nâ”‚       â”œâ”€â”€ journal_io.c    # Circular buffer math (M6)\nâ”‚       â”œâ”€â”€ txn.c           # 8-step commit protocol (M6)\nâ”‚       â”œâ”€â”€ recovery.c      # Mount-time log replay (M6)\nâ”‚       â”œâ”€â”€ checkpoint.c    # Log flushing/truncation (M6)\nâ”‚       â””â”€â”€ journal_wrappers.c # Transactional metadata APIs (M6)\nâ”œâ”€â”€ tools/                   # Standalone Utilities\nâ”‚   â””â”€â”€ mkfs.c              # Disk image formatter (M1)\nâ”œâ”€â”€ tests/                   # Verification Suites\nâ”‚   â”œâ”€â”€ test_m1.c           # Block layer verification\nâ”‚   â”œâ”€â”€ test_m2.c           # Pointer tree integrity\nâ”‚   â”œâ”€â”€ test_m3.c           # Directory/Link invariants\nâ”‚   â”œâ”€â”€ test_m4.c           # Sparse I/O &amp; RMW tests\nâ”‚   â””â”€â”€ test_m6_crash.c     # SIGKILL consistency tests\nâ”œâ”€â”€ build/                   # Compiled binaries (Artifact)\nâ”œâ”€â”€ Makefile                 # Pkg-config &amp; build system (M5)\nâ”œâ”€â”€ README.md               # Project Documentation\nâ”œâ”€â”€ disk.img                # Generated 4KB-block image (Artifact)\nâ””â”€â”€ mnt/                     # FUSE mount point (Artifact)</code></pre></div>\n\n<h2 id=\"creation-order\">Creation Order</h2>\n<ol>\n<li><strong>Block Layer (M1)</strong>: Establish <code>block_io.c</code> and <code>mkfs.c</code>. Ensure you can format a 16MB file and read the magic number back via <code>test_m1.c</code>.</li>\n<li><strong>Inode Engine (M2)</strong>: Build the pointer tree. Crucial: Test <code>inode_get_block</code> with high offsets to verify single/double indirection.</li>\n<li><strong>Namespace (M3)</strong>: Implement <code>dir_path.c</code> and <code>dir_add_entry</code>. Verify that <code>path_resolve</code> can find the root inode <code>.</code> and <code>..</code>.</li>\n<li><strong>Data Plane (M4)</strong>: Implement <code>file_write.c</code>. Verify that partial writes trigger the Read-Modify-Write cycle and don&#39;t corrupt the rest of the block.</li>\n<li><strong>FUSE Bridge (M5)</strong>: Connect your C functions to <code>myfs_main.c</code>. Use the <code>-f -d -s</code> flags to watch calls flow from the OS into your code.</li>\n<li><strong>Consistency (M6)</strong>: Refactor metadata writes into <code>txn_commit</code>. Use <code>test_m6_crash.c</code> to verify that interrupted <code>mkdir</code> calls don&#39;t leak inodes.</li>\n</ol>\n<h2 id=\"file-count-summary\">File Count Summary</h2>\n<ul>\n<li>Total files: 35</li>\n<li>Directories: 9</li>\n<li>Estimated lines of code: ~4,500 lines of C (excluding tests)</li>\n</ul>\n<h1 id=\"-beyond-the-atlas-further-reading\">ðŸ“š Beyond the Atlas: Further Reading</h1>\n<h2 id=\"i-core-architecture-amp-the-inode\">I. Core Architecture &amp; The Inode</h2>\n<p><strong>Paper</strong>: McKusick, M. K., et al. (1984). <em>A Fast File System for UNIX</em>.\n<strong>Code</strong>: <a href=\"https://github.com/torvalds/linux/blob/master/fs/ext2/inode.c\">Linux Kernel: fs/ext2/inode.c</a> â€” <code>ext2_get_block</code> is the classic implementation of the indirection tree.\n<strong>Best Explanation</strong>: <a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/file-implementation.pdf\">OSTEP: Chapter 40 - File System Implementation</a>.\n<strong>Why</strong>: This chapter provides the clearest visual breakdown of how bitmapped allocation and inode tables interact in a &quot;Simple File System.&quot;\n<strong>Pedagogical Timing</strong>: Read <strong>BEFORE Milestone 1</strong>. It establishes the mental model of the disk as an array of blocks that you will spend the rest of the project implementing.</p>\n<p><strong>Code</strong>: <a href=\"https://github.com/torvalds/linux/blob/master/fs/ext4/extents.c\">Linux Kernel: fs/ext4/extents.c</a> â€” Specifically the <code>ext4_ext_binsearch</code> function.\n<strong>Best Explanation</strong>: <a href=\"https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout#Extents\">Ext4 Disk Layout (Kernel.org Wiki)</a>.\n<strong>Why</strong>: This is the industry successor to the indirection tree you build in Milestone 2, essential for understanding modern large-scale storage.\n<strong>Pedagogical Timing</strong>: Read <strong>AFTER Milestone 2</strong>. Once you&#39;ve struggled with the math of triple-indirection, you will immediately appreciate why &quot;extents&quot; are a more efficient way to track contiguous data.</p>\n<h2 id=\"ii-vfs-amp-path-resolution\">II. VFS &amp; Path Resolution</h2>\n<p><strong>Paper</strong>: Kleiman, S. R. (1986). <em>Vnodes: An Architecture for Multiple File System Types in Sun UNIX</em>.\n<strong>Code</strong>: <a href=\"https://github.com/torvalds/linux/blob/master/fs/namei.c\">Linux Kernel: fs/namei.c</a> â€” The <code>link_path_walk</code> function is the actual engine behind <code>path_resolve</code>.\n<strong>Best Explanation</strong>: <a href=\"https://lwn.net/Articles/649115/\">The Path Lookup Series (LWN.net)</a> â€” Specifically &quot;Part 2: Components of the path.&quot;\n<strong>Why</strong>: Neil Brown provides the most exhaustive explanation of the &quot;walking&quot; process and the subtle complexity of symlinks and mount points.\n<strong>Pedagogical Timing</strong>: Read <strong>DURING Milestone 3</strong>. Use it to debug your logic for <code>..</code> and trailing slashes in your path resolution engine.</p>\n<h2 id=\"iii-userspace-integration-fuse\">III. Userspace Integration (FUSE)</h2>\n<p><strong>Paper</strong>: Vangoor, B. R., et al. (2017). <em>To FUSE or Not to FUSE: Performance of User-Level File Systems</em>.\n<strong>Code</strong>: <a href=\"https://github.com/libfuse/libfuse/blob/master/example/hello.c\">libfuse: example/hello.c</a>.\n<strong>Best Explanation</strong>: <a href=\"https://www.kernel.org/doc/html/latest/filesystems/fuse.html\">FUSE Kernel Documentation</a>.\n<strong>Why</strong>: It explains the protocol that lives inside <code>/dev/fuse</code>, clarifying how requests move from the VFS to your C code.\n<strong>Pedagogical Timing</strong>: Read <strong>BEFORE Milestone 5</strong>. You need to understand that FUSE is a message-passing protocol before you try to debug context switches and locking.</p>\n<h2 id=\"iv-persistence-amp-crash-safety\">IV. Persistence &amp; Crash Safety</h2>\n<p><strong>Paper</strong>: Prabhakaran, V., et al. (2005). <em>Analysis and Evolution of Journaling File Systems</em>.\n<strong>Code</strong>: <a href=\"https://github.com/torvalds/linux/blob/master/fs/jbd2/transaction.c\">Linux Kernel: fs/jbd2/transaction.c</a> â€” Look for <code>jbd2_journal_commit_transaction</code>.\n<strong>Best Explanation</strong>: <a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/file-journaling.pdf\">OSTEP: Chapter 42 - Crash Consistency: FSCK and Journaling</a>.\n<strong>Why</strong>: It provides a narrative walkthrough of the &quot;Why&quot; behind write-ahead logging using the same block-level terminology as this project.\n<strong>Pedagogical Timing</strong>: Read <strong>BEFORE starting Milestone 6</strong>. This is a conceptually heavy module; the OSTEP chapter acts as the necessary map before you write the code.</p>\n<p><strong>Explanation</strong>: <a href=\"https://www.sqlite.org/atomiccommit.html\">SQLite: Atomic Commit In SQLite</a> â€” Section 3.0 &quot;The Rollback Journal.&quot;\n<strong>Why</strong>: This is a perfect example of how a database implements the same &quot;intent-to-write&quot; logic at the application level to ensure atomicity.\n<strong>Pedagogical Timing</strong>: Read <strong>AFTER Milestone 6</strong>. It will help you realize that your filesystem&#39;s journal and a database&#39;s WAL are essentially the same machine built for different purposes.</p>\n<h2 id=\"v-hardware-interaction-the-physical-layer\">V. Hardware Interaction (The Physical Layer)</h2>\n<p><strong>Spec</strong>: <a href=\"https://nvmexpress.org/developers/nvme-specification/\">NVMe Express Base Specification, Revision 2.0</a> â€” Section 3.1.3 &quot;Logical Block Address (LBA).&quot;\n<strong>Best Explanation</strong>: <a href=\"https://codingwithcody.com/2018/12/03/the-lba-is-a-lie/\">The LBA is a Lie: An Introduction to SSDs (Cody Littlewood)</a>.\n<strong>Why</strong>: It shatters the illusion that writing to &quot;Block 5&quot; means writing to the 5th physical slot on an SSD, explaining the &quot;Flash Translation Layer.&quot;\n<strong>Pedagogical Timing</strong>: Read <strong>AFTER Milestone 4</strong>. You&#39;ve implemented software-level indirection; now see how the hardware implements its own hidden indirection for wear leveling.</p>\n<h2 id=\"vi-memory-management-parallelism\">VI. Memory Management Parallelism</h2>\n<p><strong>Code</strong>: <a href=\"https://github.com/jemalloc/jemalloc/blob/dev/src/bitmap.c\">jemalloc: src/bitmap.c</a>.\n<strong>Best Explanation</strong>: <a href=\"https://www.kernel.org/doc/gorman/pdf/understand.pdf\">Understanding the Linux Virtual Memory Manager (Mel Gorman)</a> â€” Chapter 6 &quot;Page Frame Allocation.&quot;\n<strong>Why</strong>: This shows that the bitmap allocator you built in Milestone 1 is identical to how the Linux kernel manages physical RAM.\n<strong>Pedagogical Timing</strong>: Read <strong>AFTER Milestone 1</strong>. It validates that the patterns you are learning (bitmaps, alignment, metadata) are universal in systems engineering.</p>\n","toc":[{"level":1,"text":"ðŸŽ¯ Project Charter: Filesystem Implementation","id":"-project-charter-filesystem-implementation"},{"level":2,"text":"What You Are Building","id":"what-you-are-building"},{"level":2,"text":"Why This Project Exists","id":"why-this-project-exists"},{"level":2,"text":"What You Will Be Able to Do When Done","id":"what-you-will-be-able-to-do-when-done"},{"level":2,"text":"Final Deliverable","id":"final-deliverable"},{"level":2,"text":"Is This Project For You?","id":"is-this-project-for-you"},{"level":2,"text":"Estimated Effort","id":"estimated-effort"},{"level":2,"text":"Definition of Done","id":"definition-of-done"},{"level":1,"text":"Filesystem Implementation: An Interactive Atlas","id":"filesystem-implementation-an-interactive-atlas"},{"level":1,"text":"Milestone 1: Block Layer and mkfs","id":"milestone-1-block-layer-and-mkfs"},{"level":2,"text":"The Disk Does Not Know You Exist","id":"the-disk-does-not-know-you-exist"},{"level":2,"text":"The Fundamental Tension: Fixed Blocks vs. Variable Reality","id":"the-fundamental-tension-fixed-blocks-vs-variable-reality"},{"level":2,"text":"The Disk Image: A File That Pretends to Be a Disk","id":"the-disk-image-a-file-that-pretends-to-be-a-disk"},{"level":2,"text":"On-Disk Layout: The Filesystem as a Database","id":"on-disk-layout-the-filesystem-as-a-database"},{"level":2,"text":"The Superblock: Your Filesystem&#39;s Birth Certificate","id":"the-superblock-your-filesystem39s-birth-certificate"},{"level":2,"text":"Bitmaps: One Bit per Block, Two States of Truth","id":"bitmaps-one-bit-per-block-two-states-of-truth"},{"level":2,"text":"Designing for Crash Safety: The Two-Write Problem","id":"designing-for-crash-safety-the-two-write-problem"},{"level":2,"text":"mkfs: Formatting the Raw Image","id":"mkfs-formatting-the-raw-image"},{"level":2,"text":"Verification: Reading Back What You Wrote","id":"verification-reading-back-what-you-wrote"},{"level":2,"text":"Run this immediately after mkfs. If it passes, every piece of data you wrote survives a round-trip to disk and back â€” the most basic contract of a storage system.","id":"run-this-immediately-after-mkfs-if-it-passes-every-piece-of-data-you-wrote-survives-a-round-trip-to-disk-and-back-the-most-basic-contract-of-a-storage-system"},{"level":2,"text":"Three-Level View: What Happens When write_block Executes","id":"three-level-view-what-happens-when-write_block-executes"},{"level":2,"text":"Key Design Decisions","id":"key-design-decisions"},{"level":2,"text":"Knowledge Cascade: One Concept, Ten Connections","id":"knowledge-cascade-one-concept-ten-connections"},{"level":2,"text":"You just built a block allocator backed by a bitmap that sits on top of a flat address space of fixed-size chunks. This is not a filesystem-specific idea. It is one of the fundamental patterns of systems programming:\nâ†’ Database Page Management\nPostgreSQL, SQLite, and MySQL all store data in &quot;pages&quot; â€” fixed-size blocks (8KB in Postgres, 4KB in SQLite by default). Their internal page managers maintain a freelist or bitmap of free pages. The &quot;heap file&quot; in Postgres is literally a sequence of 8KB pages, with a &quot;free space map&quot; (FSM) tracking available space per page. Your superblock is Postgres&#39;s pg_control file. Your bitmap is the FSM. Building a filesystem gives you the mental model to read database internals with clarity.\nâ†’ The SSD Flash Translation Layer (FTL)\nWhen you call write_block(fd, 500, buf), you are writing to logical block 500. But inside your SSD, logical block 500 does not map to a fixed physical NAND page. The FTL maintains its own mapping table (logical-to-physical, LPT), performs wear leveling (distributing writes evenly across cells), and manages its own garbage collection when pages need to be erased. Your filesystem sits on top of a block abstraction that is itself implemented by another system with its own block abstraction. Indirection all the way down.\nâ†’ Memory Allocators (jemalloc, tcmalloc, mimalloc)\nmalloc() faces the same problem from a different angle: carve variable-size allocations from fixed-size OS pages (4KB). jemalloc&#39;s slab allocator tracks free slots within a page using... a bitmap. Each jemalloc &quot;run&quot; is a region of pages dedicated to a specific allocation size class, with a bitmap marking which slots are occupied. Your bitmap_find_free and bitmap_set are functionally identical to what jemalloc executes on every malloc. The problem is universal; the solution is the same.\nâ†’ Virtual Memory and Physical Frame Allocation\nThe Linux kernel maintains a &quot;buddy allocator&quot; for physical memory pages, with bitmaps at each order level tracking which frames are free. When your process calls mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_ANONYMOUS, -1, 0), the kernel runs a bitmap scan nearly identical to your bitmap_find_free, then marks the physical frame allocated, and records the mapping in your process&#39;s page table. Your filesystem&#39;s block allocator is the on-disk analogue of the kernel&#39;s physical frame allocator.\nâ†’ Disk Image Forensics\nYou now understand on-disk layout precisely enough to examine a raw disk image with hexdump -C disk.img | head -100 and identify the magic number at offset 0, the total block count at offset 12, and the free block count at offset 20. Forensic tools like Autopsy, The Sleuth Kit, and foremost work by reading raw disk images and interpreting known filesystem structures at known byte offsets â€” exactly what your verify_filesystem function does. With the knowledge from this milestone, you can recover files from a &quot;deleted&quot; (but not overwritten) partition by finding inodes in the inode table and following their block pointers.\nâ†’ RAID and Storage Systems\nRAID controllers manage arrays of physical blocks with their own parity metadata. A RAID-5 controller maintains a &quot;stripe map&quot; tracking which data blocks correspond to which parity blocks â€” another form of block-level metadata management. The same free/used tracking problem appears at every storage abstraction layer.","id":"you-just-built-a-block-allocator-backed-by-a-bitmap-that-sits-on-top-of-a-flat-address-space-of-fixed-size-chunks-this-is-not-a-filesystem-specific-idea-it-is-one-of-the-fundamental-patterns-of-systems-programming-database-page-management-postgresql-sqlite-and-mysql-all-store-data-in-quotpagesquot-fixed-size-blocks-8kb-in-postgres-4kb-in-sqlite-by-default-their-internal-page-managers-maintain-a-freelist-or-bitmap-of-free-pages-the-quotheap-filequot-in-postgres-is-literally-a-sequence-of-8kb-pages-with-a-quotfree-space-mapquot-fsm-tracking-available-space-per-page-your-superblock-is-postgres39s-pg_control-file-your-bitmap-is-the-fsm-building-a-filesystem-gives-you-the-mental-model-to-read-database-internals-with-clarity-the-ssd-flash-translation-layer-ftl-when-you-call-write_blockfd-500-buf-you-are-writing-to-logical-block-500-but-inside-your-ssd-logical-block-500-does-not-map-to-a-fixed-physical-nand-page-the-ftl-maintains-its-own-mapping-table-logical-to-physical-lpt-performs-wear-leveling-distributing-writes-evenly-across-cells-and-manages-its-own-garbage-collection-when-pages-need-to-be-erased-your-filesystem-sits-on-top-of-a-block-abstraction-that-is-itself-implemented-by-another-system-with-its-own-block-abstraction-indirection-all-the-way-down-memory-allocators-jemalloc-tcmalloc-mimalloc-malloc-faces-the-same-problem-from-a-different-angle-carve-variable-size-allocations-from-fixed-size-os-pages-4kb-jemalloc39s-slab-allocator-tracks-free-slots-within-a-page-using-a-bitmap-each-jemalloc-quotrunquot-is-a-region-of-pages-dedicated-to-a-specific-allocation-size-class-with-a-bitmap-marking-which-slots-are-occupied-your-bitmap_find_free-and-bitmap_set-are-functionally-identical-to-what-jemalloc-executes-on-every-malloc-the-problem-is-universal-the-solution-is-the-same-virtual-memory-and-physical-frame-allocation-the-linux-kernel-maintains-a-quotbuddy-allocatorquot-for-physical-memory-pages-with-bitmaps-at-each-order-level-tracking-which-frames-are-free-when-your-process-calls-mmapnull-4096-prot_readprot_write-map_anonymous-1-0-the-kernel-runs-a-bitmap-scan-nearly-identical-to-your-bitmap_find_free-then-marks-the-physical-frame-allocated-and-records-the-mapping-in-your-process39s-page-table-your-filesystem39s-block-allocator-is-the-on-disk-analogue-of-the-kernel39s-physical-frame-allocator-disk-image-forensics-you-now-understand-on-disk-layout-precisely-enough-to-examine-a-raw-disk-image-with-hexdump-c-diskimg-head-100-and-identify-the-magic-number-at-offset-0-the-total-block-count-at-offset-12-and-the-free-block-count-at-offset-20-forensic-tools-like-autopsy-the-sleuth-kit-and-foremost-work-by-reading-raw-disk-images-and-interpreting-known-filesystem-structures-at-known-byte-offsets-exactly-what-your-verify_filesystem-function-does-with-the-knowledge-from-this-milestone-you-can-recover-files-from-a-quotdeletedquot-but-not-overwritten-partition-by-finding-inodes-in-the-inode-table-and-following-their-block-pointers-raid-and-storage-systems-raid-controllers-manage-arrays-of-physical-blocks-with-their-own-parity-metadata-a-raid-5-controller-maintains-a-quotstripe-mapquot-tracking-which-data-blocks-correspond-to-which-parity-blocks-another-form-of-block-level-metadata-management-the-same-freeused-tracking-problem-appears-at-every-storage-abstraction-layer"},{"level":2,"text":"Before You Move On: Pitfall Checklist","id":"before-you-move-on-pitfall-checklist"},{"level":2,"text":"What You&#39;ve Built and What Comes Next","id":"what-you39ve-built-and-what-comes-next"},{"level":2,"text":"You started with nothing. A flat file. You gave it a grammar: block 0 is the superblock, blocks 1 and 2 are bitmaps, then the inode table, then the journal, then data. You built tools to allocate and free blocks and inodes with one-bit precision. You formatted a raw image into a valid filesystem with a root directory.\nBut look at what the root directory actually contains right now: two entries (. and ..) sitting in one data block. The &quot;inode&quot; for the root directory contains a block pointer to that data block. The &quot;inode&quot; has a size, a mode, and a link count â€” but those fields are barely populated. In Milestone 2, you build the full inode structure: the direct and indirect block pointer tree that lets a single inode track a file from 1 byte to several gigabytes. That&#39;s where the on-disk layout stops being about where things live, and starts being about how much they can grow.\nThe disk doesn&#39;t know you exist. But now you know how to make it remember anything you want.","id":"you-started-with-nothing-a-flat-file-you-gave-it-a-grammar-block-0-is-the-superblock-blocks-1-and-2-are-bitmaps-then-the-inode-table-then-the-journal-then-data-you-built-tools-to-allocate-and-free-blocks-and-inodes-with-one-bit-precision-you-formatted-a-raw-image-into-a-valid-filesystem-with-a-root-directory-but-look-at-what-the-root-directory-actually-contains-right-now-two-entries-and-sitting-in-one-data-block-the-quotinodequot-for-the-root-directory-contains-a-block-pointer-to-that-data-block-the-quotinodequot-has-a-size-a-mode-and-a-link-count-but-those-fields-are-barely-populated-in-milestone-2-you-build-the-full-inode-structure-the-direct-and-indirect-block-pointer-tree-that-lets-a-single-inode-track-a-file-from-1-byte-to-several-gigabytes-that39s-where-the-on-disk-layout-stops-being-about-where-things-live-and-starts-being-about-how-much-they-can-grow-the-disk-doesn39t-know-you-exist-but-now-you-know-how-to-make-it-remember-anything-you-want"},{"level":1,"text":"Milestone 2: Inode Management","id":"milestone-2-inode-management"},{"level":2,"text":"A File Is Not Its Name, Not Its Data, Not Its Location","id":"a-file-is-not-its-name-not-its-data-not-its-location"},{"level":2,"text":"The Fundamental Tension: Fixed Metadata, Variable Data","id":"the-fundamental-tension-fixed-metadata-variable-data"},{"level":2,"text":"Here is the physical constraint that makes this design challenging:\nThe inode must be fixed-size. The files it describes have variable size.\nAn inode occupies exactly 128 bytes in the inode table (or 256 bytes in ext4, but always fixed). This size cannot change after the filesystem is formatted. Yet a text file might be 47 bytes, while a disk image might be 40 gigabytes. The same inode structure must represent both.\nIf you tried to embed the block pointer list directly in the inode scaled to the file size, you would need variable-size inodes â€” which makes the inode table impossible to index directly (you cannot do inode_table_block + inode_num * sizeof(inode_t) if inodes have different sizes). You would need a separate map of inode locations, which is just pushing the indirection one level up.\nThe solution is indirection. For small files, the inode contains direct pointers to data blocks â€” fast, simple, no extra I/O. For medium files, the inode contains a pointer to a block full of pointers â€” one extra disk read, many more blocks reachable. For large files, the inode contains a pointer to a block full of pointers to blocks full of pointers â€” two extra disk reads, files up to several gigabytes.\nThis is the key insight to internalize before you write a single line of code: the inode does not contain data. The inode contains a tree of pointers to data. The tree has a fixed root (the inode fields), but it can grow additional levels as the file grows.\nLet&#39;s build it.","id":"here-is-the-physical-constraint-that-makes-this-design-challenging-the-inode-must-be-fixed-size-the-files-it-describes-have-variable-size-an-inode-occupies-exactly-128-bytes-in-the-inode-table-or-256-bytes-in-ext4-but-always-fixed-this-size-cannot-change-after-the-filesystem-is-formatted-yet-a-text-file-might-be-47-bytes-while-a-disk-image-might-be-40-gigabytes-the-same-inode-structure-must-represent-both-if-you-tried-to-embed-the-block-pointer-list-directly-in-the-inode-scaled-to-the-file-size-you-would-need-variable-size-inodes-which-makes-the-inode-table-impossible-to-index-directly-you-cannot-do-inode_table_block-inode_num-sizeofinode_t-if-inodes-have-different-sizes-you-would-need-a-separate-map-of-inode-locations-which-is-just-pushing-the-indirection-one-level-up-the-solution-is-indirection-for-small-files-the-inode-contains-direct-pointers-to-data-blocks-fast-simple-no-extra-io-for-medium-files-the-inode-contains-a-pointer-to-a-block-full-of-pointers-one-extra-disk-read-many-more-blocks-reachable-for-large-files-the-inode-contains-a-pointer-to-a-block-full-of-pointers-to-blocks-full-of-pointers-two-extra-disk-reads-files-up-to-several-gigabytes-this-is-the-key-insight-to-internalize-before-you-write-a-single-line-of-code-the-inode-does-not-contain-data-the-inode-contains-a-tree-of-pointers-to-data-the-tree-has-a-fixed-root-the-inode-fields-but-it-can-grow-additional-levels-as-the-file-grows-let39s-build-it"},{"level":2,"text":"The Inode Structure: 128 Bytes That Describe a Universe","id":"the-inode-structure-128-bytes-that-describe-a-universe"},{"level":2,"text":"Reading and Writing Inodes: The Inode Table","id":"reading-and-writing-inodes-the-inode-table"},{"level":2,"text":"Inode Allocation and Deallocation","id":"inode-allocation-and-deallocation"},{"level":2,"text":"The Block Pointer Tree: File Offset to Disk Block","id":"the-block-pointer-tree-file-offset-to-disk-block"},{"level":2,"text":"[[EXPLAIN:multi-level-indirection-â€”-pointer-to-pointer-to-data-pattern|Multi-level indirection â€” pointer-to-pointer-to-data pattern]]","id":"explainmulti-level-indirection-pointer-to-pointer-to-data-patternmulti-level-indirection-pointer-to-pointer-to-data-pattern"},{"level":2,"text":"Sparse Files: When Nothing Is Something","id":"sparse-files-when-nothing-is-something"},{"level":2,"text":"Timestamps: The Three Clocks","id":"timestamps-the-three-clocks"},{"level":2,"text":"The ctime field trips up developers who assume it means &quot;creation time.&quot; Unix filesystems traditionally have no creation time (some modern filesystems add crtime or btime as an extension). ctime is the &quot;inode change time&quot; â€” it updates whenever anything in the inode changes, including the link count, permissions, or owner. This means that chmod and chown update ctime but not mtime.\nThe atime update-on-every-read is one of the most notorious filesystem performance problems. A disk that serves mostly reads will perform writes for atime on every read â€” doubling I/O load on the inode block. Linux introduced the relatime mount option (update atime only if it&#39;s older than mtime/ctime) and noatime (never update atime). Your FUSE integration in Milestone 5 will expose this as a mount option.","id":"the-ctime-field-trips-up-developers-who-assume-it-means-quotcreation-timequot-unix-filesystems-traditionally-have-no-creation-time-some-modern-filesystems-add-crtime-or-btime-as-an-extension-ctime-is-the-quotinode-change-timequot-it-updates-whenever-anything-in-the-inode-changes-including-the-link-count-permissions-or-owner-this-means-that-chmod-and-chown-update-ctime-but-not-mtime-the-atime-update-on-every-read-is-one-of-the-most-notorious-filesystem-performance-problems-a-disk-that-serves-mostly-reads-will-perform-writes-for-atime-on-every-read-doubling-io-load-on-the-inode-block-linux-introduced-the-relatime-mount-option-update-atime-only-if-it39s-older-than-mtimectime-and-noatime-never-update-atime-your-fuse-integration-in-milestone-5-will-expose-this-as-a-mount-option"},{"level":2,"text":"Block Capacity Math: Exactly How Big Can Files Get?","id":"block-capacity-math-exactly-how-big-can-files-get"},{"level":2,"text":"Note that size is stored as uint32_t in our inode (4 bytes, max ~4.29 GB). For files larger than 4GB, you would need uint64_t for the size field â€” which is how ext4, XFS, and every modern filesystem implement it. The 32-bit size field is a design limitation of our simplified implementation; it matches the original ext2 design.","id":"note-that-size-is-stored-as-uint32_t-in-our-inode-4-bytes-max-429-gb-for-files-larger-than-4gb-you-would-need-uint64_t-for-the-size-field-which-is-how-ext4-xfs-and-every-modern-filesystem-implement-it-the-32-bit-size-field-is-a-design-limitation-of-our-simplified-implementation-it-matches-the-original-ext2-design"},{"level":2,"text":"The Structural Parallel: Inode Pointers and Page Tables","id":"the-structural-parallel-inode-pointers-and-page-tables"},{"level":2,"text":"Reference Counting: The Link Count Contract","id":"reference-counting-the-link-count-contract"},{"level":2,"text":"Putting It Together: Inode Initialization","id":"putting-it-together-inode-initialization"},{"level":2,"text":"Validation: Testing the Inode Implementation","id":"validation-testing-the-inode-implementation"},{"level":2,"text":"Design Decisions: Why This Pointer Scheme?","id":"design-decisions-why-this-pointer-scheme"},{"level":2,"text":"Knowledge Cascade: One Inode, Ten Worlds","id":"knowledge-cascade-one-inode-ten-worlds"},{"level":2,"text":"You have built a fixed-size metadata structure with a tree of pointers to variable-size content. This pattern is not unique to filesystems. It is the fundamental pattern for indexing variable-size data with fixed-size metadata.\nâ†’ B-Trees and Database Indexes\nYour indirect block pointer tree is a radix tree with fixed fanout (1024). A B-tree is the same concept generalized: internal nodes are &quot;indirect blocks&quot; holding pointers to children; leaf nodes are &quot;data blocks&quot; holding actual values. The branching factor varies by page size and key size. PostgreSQL&#39;s B-tree index pages, InnoDB&#39;s clustered index, and SQLite&#39;s B-tree pages all implement this same &quot;fixed-size nodes, variable-depth tree&quot; principle. ext4&#39;s extent tree is literally a B-tree embedded in the inode. Understanding your double-indirect pointers gives you the mental model to read any B-tree implementation and immediately see the parallel.\nâ†’ x86-64 Virtual Memory Page Tables\nAs shown above, the CPU&#39;s page table walker performs the same operation as your inode_get_block â€” traversing a multi-level array of pointers to translate an index into a physical resource. CR3 register is the &quot;inode&quot;; page directory entries are the &quot;double-indirect block&quot;; page table entries are the &quot;single-indirect block&quot;; physical page frames are the &quot;data blocks.&quot; If you understand your inode_get_block function, you understand how the MMU hardware walks page tables. This insight unlocks reading /proc/PID/maps, understanding TLB shootdowns, and reasoning about memory-mapped file performance.\nâ†’ Sparse Files in Production Systems\nVirtual machine disk images (QCOW2, VMDK, VDI) rely on sparse file support from the host filesystem. A 100GB VM disk image containing mostly zeroes occupies only the space for actual writes on an ext4 or XFS host. cp --sparse=always and rsync --sparse are tools that preserve this sparseness. Backing databases (QCOW2 copy-on-write) work by allocating blocks on first write â€” exactly what your inode_set_block does when a block is first written. Understanding null pointers = holes means understanding how VM provisioning achieves &quot;thin provisioning.&quot;\nâ†’ Reference Counting in Language Runtimes\nnlinks in the inode solves the same problem as std::shared_ptr&lt;T&gt;::use_count() in C++, Arc::strong_count() in Rust, CPython&#39;s ob_refcnt, and Swift&#39;s ARC. The pattern is universal: a shared resource tracks the number of references to it; when that count reaches zero, the resource is freed. The filesystem version has one complication that smart pointers don&#39;t: the &quot;open but unlinked&quot; case, where a process can hold a file descriptor to a file whose nlinks has dropped to zero. This is the filesystem equivalent of a &quot;weak reference&quot; keeping a resource alive â€” the nlinks = 0 condition is the destructor trigger, but only fires when no &quot;strong holds&quot; (open file descriptors) remain.\nâ†’ Git Object Storage and Content-Addressable Systems\nGit&#39;s object store faces an identical design challenge: fixed-size metadata (a commit object: author, timestamp, message, parent pointers, tree pointer) pointing to variable-size content (file trees and blobs). Git&#39;s &quot;tree objects&quot; map filenames to blob hashes â€” exactly like your inode&#39;s block pointer array maps block indices to disk block numbers. Git&#39;s blob objects are like your data blocks. The metadata/content separation in your inode design is the same abstraction that makes content-addressable storage, Docker image layers, and Merkle trees work. When you understand inodes, you understand why Git&#39;s &quot;pack files,&quot; Docker&#39;s &quot;layers,&quot; and your filesystem&#39;s &quot;data blocks&quot; are all solving the same structural problem.\nâ†’ Object Storage Metadata (S3, GCS)\nCloud object storage systems maintain metadata records for each object: size, creation time, content-type, ETag (hash), owner, access permissions. This metadata is small (hundreds of bytes) and lives in a separate system from the object data (potentially terabytes). The metadata-to-data separation is architecturally identical to your inode. When you upload a 5TB file to S3, a few hundred bytes of metadata are written to a distributed key-value store, while the data itself flows through a separate data plane to redundant storage servers. Your inode is the on-disk instantiation of this split that cloud engineers implement at global scale.","id":"you-have-built-a-fixed-size-metadata-structure-with-a-tree-of-pointers-to-variable-size-content-this-pattern-is-not-unique-to-filesystems-it-is-the-fundamental-pattern-for-indexing-variable-size-data-with-fixed-size-metadata-b-trees-and-database-indexes-your-indirect-block-pointer-tree-is-a-radix-tree-with-fixed-fanout-1024-a-b-tree-is-the-same-concept-generalized-internal-nodes-are-quotindirect-blocksquot-holding-pointers-to-children-leaf-nodes-are-quotdata-blocksquot-holding-actual-values-the-branching-factor-varies-by-page-size-and-key-size-postgresql39s-b-tree-index-pages-innodb39s-clustered-index-and-sqlite39s-b-tree-pages-all-implement-this-same-quotfixed-size-nodes-variable-depth-treequot-principle-ext439s-extent-tree-is-literally-a-b-tree-embedded-in-the-inode-understanding-your-double-indirect-pointers-gives-you-the-mental-model-to-read-any-b-tree-implementation-and-immediately-see-the-parallel-x86-64-virtual-memory-page-tables-as-shown-above-the-cpu39s-page-table-walker-performs-the-same-operation-as-your-inode_get_block-traversing-a-multi-level-array-of-pointers-to-translate-an-index-into-a-physical-resource-cr3-register-is-the-quotinodequot-page-directory-entries-are-the-quotdouble-indirect-blockquot-page-table-entries-are-the-quotsingle-indirect-blockquot-physical-page-frames-are-the-quotdata-blocksquot-if-you-understand-your-inode_get_block-function-you-understand-how-the-mmu-hardware-walks-page-tables-this-insight-unlocks-reading-procpidmaps-understanding-tlb-shootdowns-and-reasoning-about-memory-mapped-file-performance-sparse-files-in-production-systems-virtual-machine-disk-images-qcow2-vmdk-vdi-rely-on-sparse-file-support-from-the-host-filesystem-a-100gb-vm-disk-image-containing-mostly-zeroes-occupies-only-the-space-for-actual-writes-on-an-ext4-or-xfs-host-cp-sparsealways-and-rsync-sparse-are-tools-that-preserve-this-sparseness-backing-databases-qcow2-copy-on-write-work-by-allocating-blocks-on-first-write-exactly-what-your-inode_set_block-does-when-a-block-is-first-written-understanding-null-pointers-holes-means-understanding-how-vm-provisioning-achieves-quotthin-provisioningquot-reference-counting-in-language-runtimes-nlinks-in-the-inode-solves-the-same-problem-as-stdshared_ptrlttgtuse_count-in-c-arcstrong_count-in-rust-cpython39s-ob_refcnt-and-swift39s-arc-the-pattern-is-universal-a-shared-resource-tracks-the-number-of-references-to-it-when-that-count-reaches-zero-the-resource-is-freed-the-filesystem-version-has-one-complication-that-smart-pointers-don39t-the-quotopen-but-unlinkedquot-case-where-a-process-can-hold-a-file-descriptor-to-a-file-whose-nlinks-has-dropped-to-zero-this-is-the-filesystem-equivalent-of-a-quotweak-referencequot-keeping-a-resource-alive-the-nlinks-0-condition-is-the-destructor-trigger-but-only-fires-when-no-quotstrong-holdsquot-open-file-descriptors-remain-git-object-storage-and-content-addressable-systems-git39s-object-store-faces-an-identical-design-challenge-fixed-size-metadata-a-commit-object-author-timestamp-message-parent-pointers-tree-pointer-pointing-to-variable-size-content-file-trees-and-blobs-git39s-quottree-objectsquot-map-filenames-to-blob-hashes-exactly-like-your-inode39s-block-pointer-array-maps-block-indices-to-disk-block-numbers-git39s-blob-objects-are-like-your-data-blocks-the-metadatacontent-separation-in-your-inode-design-is-the-same-abstraction-that-makes-content-addressable-storage-docker-image-layers-and-merkle-trees-work-when-you-understand-inodes-you-understand-why-git39s-quotpack-filesquot-docker39s-quotlayersquot-and-your-filesystem39s-quotdata-blocksquot-are-all-solving-the-same-structural-problem-object-storage-metadata-s3-gcs-cloud-object-storage-systems-maintain-metadata-records-for-each-object-size-creation-time-content-type-etag-hash-owner-access-permissions-this-metadata-is-small-hundreds-of-bytes-and-lives-in-a-separate-system-from-the-object-data-potentially-terabytes-the-metadata-to-data-separation-is-architecturally-identical-to-your-inode-when-you-upload-a-5tb-file-to-s3-a-few-hundred-bytes-of-metadata-are-written-to-a-distributed-key-value-store-while-the-data-itself-flows-through-a-separate-data-plane-to-redundant-storage-servers-your-inode-is-the-on-disk-instantiation-of-this-split-that-cloud-engineers-implement-at-global-scale"},{"level":2,"text":"Before You Move On: Pitfall Checklist","id":"before-you-move-on-pitfall-checklist"},{"level":2,"text":"What You&#39;ve Built and What Comes Next","id":"what-you39ve-built-and-what-comes-next"},{"level":2,"text":"You now have a complete inode layer. A fixed-size structure that can represent any file from 0 bytes to 4GB. A pointer tree with three levels of indirection that costs zero extra disk reads for small files, one extra read for medium files, and two extra reads for large files. Sparse files where null pointers cost nothing. Reference counting that properly tracks all names pointing to a file. And the ability to serialize all of this to and from exact byte positions on disk.\nBut an inode has no name. Inodes don&#39;t know what they&#39;re called â€” that knowledge lives in the directory. A directory is a special kind of file whose data blocks contain structured records mapping names to inode numbers. In Milestone 3, you&#39;ll build those directory entries, implement the path resolution algorithm that translates /home/user/projects/file.txt into a sequence of inode lookups, and implement mkdir, rmdir, link, and unlink with their correct link count semantics.\nThe inode&#39;s mode field already knows whether it&#39;s a directory (S_IFDIR). Now it&#39;s time to give the directory its voice.","id":"you-now-have-a-complete-inode-layer-a-fixed-size-structure-that-can-represent-any-file-from-0-bytes-to-4gb-a-pointer-tree-with-three-levels-of-indirection-that-costs-zero-extra-disk-reads-for-small-files-one-extra-read-for-medium-files-and-two-extra-reads-for-large-files-sparse-files-where-null-pointers-cost-nothing-reference-counting-that-properly-tracks-all-names-pointing-to-a-file-and-the-ability-to-serialize-all-of-this-to-and-from-exact-byte-positions-on-disk-but-an-inode-has-no-name-inodes-don39t-know-what-they39re-called-that-knowledge-lives-in-the-directory-a-directory-is-a-special-kind-of-file-whose-data-blocks-contain-structured-records-mapping-names-to-inode-numbers-in-milestone-3-you39ll-build-those-directory-entries-implement-the-path-resolution-algorithm-that-translates-homeuserprojectsfiletxt-into-a-sequence-of-inode-lookups-and-implement-mkdir-rmdir-link-and-unlink-with-their-correct-link-count-semantics-the-inode39s-mode-field-already-knows-whether-it39s-a-directory-s_ifdir-now-it39s-time-to-give-the-directory-its-voice"},{"level":1,"text":"Milestone 3: Directory Operations","id":"milestone-3-directory-operations"},{"level":2,"text":"The Directory Is a Lie You Have Always Believed","id":"the-directory-is-a-lie-you-have-always-believed"},{"level":2,"text":"The Fundamental Tension: Hierarchical Names, Flat Blocks","id":"the-fundamental-tension-hierarchical-names-flat-blocks"},{"level":2,"text":"The Directory Entry: On-Disk Format","id":"the-directory-entry-on-disk-format"},{"level":2,"text":"Scanning a Directory Block","id":"scanning-a-directory-block"},{"level":2,"text":"Path Resolution: Walking the Tree","id":"path-resolution-walking-the-tree"},{"level":2,"text":"Adding and Removing Entries: The Mutation API","id":"adding-and-removing-entries-the-mutation-api"},{"level":3,"text":"add_entry: Writing a New Name","id":"add_entry-writing-a-new-name"},{"level":3,"text":"remove_entry: Deleting a Name","id":"remove_entry-deleting-a-name"},{"level":2,"text":"mkdir: Creating a Directory","id":"mkdir-creating-a-directory"},{"level":2,"text":"rmdir: Removing a Directory","id":"rmdir-removing-a-directory"},{"level":2,"text":"Hard Links: One File, Many Names","id":"hard-links-one-file-many-names"},{"level":3,"text":"unlink(): Removing a File","id":"unlink-removing-a-file"},{"level":2,"text":"The . and .. Contract","id":"the-and-contract"},{"level":2,"text":"readdir: Listing a Directory","id":"readdir-listing-a-directory"},{"level":2,"text":"Validation: Testing the Directory Layer","id":"validation-testing-the-directory-layer"},{"level":2,"text":"Concurrency Warning: Races in Directory Modification","id":"concurrency-warning-races-in-directory-modification"},{"level":2,"text":"[[EXPLAIN:directory-locking-strategies-â€”-global-lock-vs-per-inode-vs-hierarchical-locking|Directory locking strategies â€” global lock vs. per-inode vs. hierarchical locking for concurrent filesystem access]]","id":"explaindirectory-locking-strategies-global-lock-vs-per-inode-vs-hierarchical-lockingdirectory-locking-strategies-global-lock-vs-per-inode-vs-hierarchical-locking-for-concurrent-filesystem-access"},{"level":2,"text":"Knowledge Cascade: One Directory, Ten Worlds","id":"knowledge-cascade-one-directory-ten-worlds"},{"level":3,"text":"Symbolic Links vs. Hard Links: Now Obvious","id":"symbolic-links-vs-hard-links-now-obvious"},{"level":3,"text":"DNS Resolution: The Same Algorithm","id":"dns-resolution-the-same-algorithm"},{"level":3,"text":"Container Overlay Filesystems (OverlayFS / Docker)","id":"container-overlay-filesystems-overlayfs-docker"},{"level":3,"text":"Database Index Lookups: The Linear Scan Problem","id":"database-index-lookups-the-linear-scan-problem"},{"level":3,"text":"Git Tree Objects: Directories All The Way Down","id":"git-tree-objects-directories-all-the-way-down"},{"level":2,"text":"Design Decisions","id":"design-decisions"},{"level":2,"text":"Before You Move On: Pitfall Checklist","id":"before-you-move-on-pitfall-checklist"},{"level":2,"text":"What You&#39;ve Built and What Comes Next","id":"what-you39ve-built-and-what-comes-next"},{"level":2,"text":"You have collapsed the illusion of the &quot;folder.&quot; A directory is a file. Its data blocks are a linked sequence of (name, inode_number) records. The entire filesystem tree emerges from files pointing to other files. Path resolution is a mechanical scan: read a block, find the name, follow the inode number, repeat. The . and .. entries that make cd .. work are stored as ordinary bytes in ordinary data blocks.\nThe elegance is complete: every part of the filesystem â€” the superblock (block 0), the bitmaps (blocks 1â€“2), the inode table, the journal, and the directory tree â€” is made from the same substrate: 4KB blocks. The naming system that makes the tree navigable is itself stored in the tree.\nBut look at what&#39;s missing: you can create directories and add entries, but you cannot yet read or write actual file data. A regular file (S_IFREG) whose blocks[] array points to data blocks containing bytes is not yet implemented. In Milestone 4, you will build read(inode, offset, length) and write(inode, offset, data) â€” the operations that traverse the block pointer tree from Milestone 2 and move data between the application and disk. You will implement truncate (shrinking and extending files), handle the read-modify-write problem for partial block writes, and support sparse files where holes read as zeros.\nThe filesystem is almost complete. Two milestones ago, you had a flat block array. Now you have a navigable tree of named files. The blocks are starting to look like a filesystem.","id":"you-have-collapsed-the-illusion-of-the-quotfolderquot-a-directory-is-a-file-its-data-blocks-are-a-linked-sequence-of-name-inode_number-records-the-entire-filesystem-tree-emerges-from-files-pointing-to-other-files-path-resolution-is-a-mechanical-scan-read-a-block-find-the-name-follow-the-inode-number-repeat-the-and-entries-that-make-cd-work-are-stored-as-ordinary-bytes-in-ordinary-data-blocks-the-elegance-is-complete-every-part-of-the-filesystem-the-superblock-block-0-the-bitmaps-blocks-12-the-inode-table-the-journal-and-the-directory-tree-is-made-from-the-same-substrate-4kb-blocks-the-naming-system-that-makes-the-tree-navigable-is-itself-stored-in-the-tree-but-look-at-what39s-missing-you-can-create-directories-and-add-entries-but-you-cannot-yet-read-or-write-actual-file-data-a-regular-file-s_ifreg-whose-blocks-array-points-to-data-blocks-containing-bytes-is-not-yet-implemented-in-milestone-4-you-will-build-readinode-offset-length-and-writeinode-offset-data-the-operations-that-traverse-the-block-pointer-tree-from-milestone-2-and-move-data-between-the-application-and-disk-you-will-implement-truncate-shrinking-and-extending-files-handle-the-read-modify-write-problem-for-partial-block-writes-and-support-sparse-files-where-holes-read-as-zeros-the-filesystem-is-almost-complete-two-milestones-ago-you-had-a-flat-block-array-now-you-have-a-navigable-tree-of-named-files-the-blocks-are-starting-to-look-like-a-filesystem"},{"level":1,"text":"Milestone 4: File Read/Write Operations","id":"milestone-4-file-readwrite-operations"},{"level":2,"text":"The Lie Every Developer Believes About File Writes","id":"the-lie-every-developer-believes-about-file-writes"},{"level":2,"text":"The Fundamental Tension: Byte-Addressable API, Block-Addressable Storage","id":"the-fundamental-tension-byte-addressable-api-block-addressable-storage"},{"level":2,"text":"create_file: Bringing a File Into Existence","id":"create_file-bringing-a-file-into-existence"},{"level":2,"text":"Offset Arithmetic: The Two-Level Translation","id":"offset-arithmetic-the-two-level-translation"},{"level":2,"text":"This loop is the skeleton of both read and write. The difference is what you do with the block once you have it.","id":"this-loop-is-the-skeleton-of-both-read-and-write-the-difference-is-what-you-do-with-the-block-once-you-have-it"},{"level":2,"text":"fs_read: Reading Data Through the Pointer Tree","id":"fs_read-reading-data-through-the-pointer-tree"},{"level":2,"text":"fs_write: The Read-Modify-Write Reality","id":"fs_write-the-read-modify-write-reality"},{"level":2,"text":"Sparse File Writes: Skipping the Gap","id":"sparse-file-writes-skipping-the-gap"},{"level":2,"text":"This is not a special mode you enable. Sparse files are the default behavior of null block pointers. The file you create is automatically sparse if you write at high offsets without filling in between.","id":"this-is-not-a-special-mode-you-enable-sparse-files-are-the-default-behavior-of-null-block-pointers-the-file-you-create-is-automatically-sparse-if-you-write-at-high-offsets-without-filling-in-between"},{"level":2,"text":"Append: Writing at the End","id":"append-writing-at-the-end"},{"level":2,"text":"fs_truncate: The Inverse of Write","id":"fs_truncate-the-inverse-of-write"},{"level":2,"text":"Metadata Correctness: Size, mtime, ctime","id":"metadata-correctness-size-mtime-ctime"},{"level":2,"text":"Three-Level View: What Happens When fs_write Runs","id":"three-level-view-what-happens-when-fs_write-runs"},{"level":2,"text":"Design Decision: When to Flush the Inode","id":"design-decision-when-to-flush-the-inode"},{"level":2,"text":"Unit Tests: Verifying Round-Trip Correctness","id":"unit-tests-verifying-round-trip-correctness"},{"level":2,"text":"Knowledge Cascade: One Write, Ten Worlds","id":"knowledge-cascade-one-write-ten-worlds"},{"level":3,"text":"Database Write Amplification and LSM-Trees","id":"database-write-amplification-and-lsm-trees"},{"level":3,"text":"SSD Write Amplification: Compound Costs","id":"ssd-write-amplification-compound-costs"},{"level":3,"text":"The Linux Page Cache: Why Your Writes Aren&#39;t That Slow","id":"the-linux-page-cache-why-your-writes-aren39t-that-slow"},{"level":3,"text":"Sparse Files and Cloud Thin Provisioning","id":"sparse-files-and-cloud-thin-provisioning"},{"level":3,"text":"Copy-on-Write Filesystems: Avoiding RMW Entirely","id":"copy-on-write-filesystems-avoiding-rmw-entirely"},{"level":3,"text":"The O_DIRECT Flag: Bypassing the Buffer Cache","id":"the-o_direct-flag-bypassing-the-buffer-cache"},{"level":2,"text":"[[EXPLAIN:direct-i/o-o_direct-â€”-bypassing-the-kernel-page-cache-for-user-controlled-buffering|Direct I/O (O_DIRECT) â€” bypassing the kernel page cache, requiring aligned buffers, used by databases for self-managed caching]]\nWhen you open a file with O_DIRECT, you instruct the kernel to bypass the page cache entirely. Your reads and writes go directly to the block device. The constraints: buffer addresses and lengths must be block-aligned (typically 512-byte or 4096-byte aligned).\nWho uses O_DIRECT? Databases. MySQL InnoDB, PostgreSQL (with synchronous_commit = on), Oracle â€” all optionally use O_DIRECT to manage their own buffer pools instead of relying on the OS page cache. Why? Because the database knows its access patterns better than the OS. A sequential full table scan should not pollute the page cache with pages that will never be read again, evicting hot index pages. The database&#39;s buffer pool implements its own LRU/clock eviction policy tuned to database access patterns.\nYour fs_write calls the kernel&#39;s write() syscall, which goes through the page cache. If you were building a database storage engine directly on your filesystem (not through a POSIX file), you might want O_DIRECT semantics to avoid double-buffering (your database buffer pool + the OS page cache both holding the same data). Understanding block-level I/O is a prerequisite for understanding why O_DIRECT exists and when to use it.","id":"explaindirect-io-o_direct-bypassing-the-kernel-page-cache-for-user-controlled-bufferingdirect-io-o_direct-bypassing-the-kernel-page-cache-requiring-aligned-buffers-used-by-databases-for-self-managed-caching-when-you-open-a-file-with-o_direct-you-instruct-the-kernel-to-bypass-the-page-cache-entirely-your-reads-and-writes-go-directly-to-the-block-device-the-constraints-buffer-addresses-and-lengths-must-be-block-aligned-typically-512-byte-or-4096-byte-aligned-who-uses-o_direct-databases-mysql-innodb-postgresql-with-synchronous_commit-on-oracle-all-optionally-use-o_direct-to-manage-their-own-buffer-pools-instead-of-relying-on-the-os-page-cache-why-because-the-database-knows-its-access-patterns-better-than-the-os-a-sequential-full-table-scan-should-not-pollute-the-page-cache-with-pages-that-will-never-be-read-again-evicting-hot-index-pages-the-database39s-buffer-pool-implements-its-own-lruclock-eviction-policy-tuned-to-database-access-patterns-your-fs_write-calls-the-kernel39s-write-syscall-which-goes-through-the-page-cache-if-you-were-building-a-database-storage-engine-directly-on-your-filesystem-not-through-a-posix-file-you-might-want-o_direct-semantics-to-avoid-double-buffering-your-database-buffer-pool-the-os-page-cache-both-holding-the-same-data-understanding-block-level-io-is-a-prerequisite-for-understanding-why-o_direct-exists-and-when-to-use-it"},{"level":2,"text":"Before You Move On: Pitfall Checklist","id":"before-you-move-on-pitfall-checklist"},{"level":2,"text":"What You&#39;ve Built and What Comes Next","id":"what-you39ve-built-and-what-comes-next"},{"level":2,"text":"You now have a complete, working filesystem â€” in the sense that it can create files, name them in directories, store arbitrary byte content in them via a multi-level block pointer tree, retrieve that content by inode number and byte offset, grow and shrink files through write and truncate, and support sparse files where holes cost nothing.\nBut there is a gap between &quot;working filesystem library&quot; and &quot;a filesystem you can actually use.&quot; Right now, you can only interact with your filesystem by calling fs_read, fs_write, fs_create_file directly from C code. You cannot use standard Unix tools â€” ls, cat, cp, vim, grep â€” against your filesystem. You cannot mount it. It is a library, not a filesystem in the Unix sense.\nMilestone 5 closes that gap via FUSE (Filesystem in Userspace). FUSE provides a mechanism for running a filesystem in userspace (your process) while the kernel routes VFS calls from any application to your callbacks. You will implement a thin translation layer that maps FUSE callback arguments (path strings, POSIX stat structs, file handle integers) to your internal operations (path resolution, fs_read, fs_write, inode_t). After Milestone 5, you will be able to run mount -t fuse ./myfs /mnt/myfs and then cp -r ~/Documents /mnt/myfs/ and have your filesystem actually store those files.\nThe block-level I/O you just built is the foundation. Every FUSE callback for every file operation â€” read, write, create, truncate, getattr â€” will ultimately call the functions in this milestone. The work you have done here is the engine; FUSE is the transmission that connects it to the outside world.","id":"you-now-have-a-complete-working-filesystem-in-the-sense-that-it-can-create-files-name-them-in-directories-store-arbitrary-byte-content-in-them-via-a-multi-level-block-pointer-tree-retrieve-that-content-by-inode-number-and-byte-offset-grow-and-shrink-files-through-write-and-truncate-and-support-sparse-files-where-holes-cost-nothing-but-there-is-a-gap-between-quotworking-filesystem-libraryquot-and-quota-filesystem-you-can-actually-usequot-right-now-you-can-only-interact-with-your-filesystem-by-calling-fs_read-fs_write-fs_create_file-directly-from-c-code-you-cannot-use-standard-unix-tools-ls-cat-cp-vim-grep-against-your-filesystem-you-cannot-mount-it-it-is-a-library-not-a-filesystem-in-the-unix-sense-milestone-5-closes-that-gap-via-fuse-filesystem-in-userspace-fuse-provides-a-mechanism-for-running-a-filesystem-in-userspace-your-process-while-the-kernel-routes-vfs-calls-from-any-application-to-your-callbacks-you-will-implement-a-thin-translation-layer-that-maps-fuse-callback-arguments-path-strings-posix-stat-structs-file-handle-integers-to-your-internal-operations-path-resolution-fs_read-fs_write-inode_t-after-milestone-5-you-will-be-able-to-run-mount-t-fuse-myfs-mntmyfs-and-then-cp-r-documents-mntmyfs-and-have-your-filesystem-actually-store-those-files-the-block-level-io-you-just-built-is-the-foundation-every-fuse-callback-for-every-file-operation-read-write-create-truncate-getattr-will-ultimately-call-the-functions-in-this-milestone-the-work-you-have-done-here-is-the-engine-fuse-is-the-transmission-that-connects-it-to-the-outside-world"},{"level":1,"text":"Milestone 5: FUSE Integration","id":"milestone-5-fuse-integration"},{"level":2,"text":"The Wall That Was Never There","id":"the-wall-that-was-never-there"},{"level":2,"text":"The Fundamental Tension: VFS Contract, Userspace Implementation","id":"the-fundamental-tension-vfs-contract-userspace-implementation"},{"level":2,"text":"Installing libfuse and Project Structure","id":"installing-libfuse-and-project-structure"},{"level":2,"text":"Global State: The Filesystem Context","id":"global-state-the-filesystem-context"},{"level":2,"text":"The Path Translation Problem: Your Central Design","id":"the-path-translation-problem-your-central-design"},{"level":2,"text":"Mapping Inodes to struct stat: The inode_to_stat Bridge","id":"mapping-inodes-to-struct-stat-the-inode_to_stat-bridge"},{"level":2,"text":"Implementing the Core Callbacks","id":"implementing-the-core-callbacks"},{"level":3,"text":"getattr â€” The Most Called Callback","id":"getattr-the-most-called-callback"},{"level":3,"text":"readdir â€” Directory Listing","id":"readdir-directory-listing"},{"level":3,"text":"open and release â€” File Handle Lifecycle","id":"open-and-release-file-handle-lifecycle"},{"level":3,"text":"create â€” The O_CREAT Path","id":"create-the-o_creat-path"},{"level":3,"text":"read and write â€” Data Plane Callbacks","id":"read-and-write-data-plane-callbacks"},{"level":3,"text":"mkdir and rmdir","id":"mkdir-and-rmdir"},{"level":3,"text":"unlink â€” File Deletion","id":"unlink-file-deletion"},{"level":3,"text":"truncate â€” Resize from Path","id":"truncate-resize-from-path"},{"level":3,"text":"chmod and utimens â€” Metadata Changes","id":"chmod-and-utimens-metadata-changes"},{"level":2,"text":"rename: The Hardest Operation","id":"rename-the-hardest-operation"},{"level":2,"text":"Concurrency: The Locking Model","id":"concurrency-the-locking-model"},{"level":2,"text":"The Mount/Unmount Lifecycle","id":"the-mountunmount-lifecycle"},{"level":2,"text":"statfs â€” Disk Space Reporting","id":"statfs-disk-space-reporting"},{"level":2,"text":"Wiring Everything Together: main and Registration","id":"wiring-everything-together-main-and-registration"},{"level":2,"text":"The ls -la Trace: What Actually Happens","id":"the-ls-la-trace-what-actually-happens"},{"level":2,"text":"Building and Mounting: Your First Real Mount","id":"building-and-mounting-your-first-real-mount"},{"level":2,"text":"Integration Test Suite","id":"integration-test-suite"},{"level":2,"text":"Three-Level View: One open() Syscall","id":"three-level-view-one-open-syscall"},{"level":2,"text":"Knowledge Cascade: One FUSE Mount, Ten Worlds","id":"knowledge-cascade-one-fuse-mount-ten-worlds"},{"level":3,"text":"VFS as Universal Contract: ext4, XFS, NFS, Your Filesystem","id":"vfs-as-universal-contract-ext4-xfs-nfs-your-filesystem"},{"level":3,"text":"Microkernel Architecture Inside a Monolithic Kernel","id":"microkernel-architecture-inside-a-monolithic-kernel"},{"level":3,"text":"gRPC and IPC: FUSE is an RPC System","id":"grpc-and-ipc-fuse-is-an-rpc-system"},{"level":3,"text":"Thread Safety as a First-Class Design Concern","id":"thread-safety-as-a-first-class-design-concern"},{"level":3,"text":"Path Resolution as the Performance Bottleneck","id":"path-resolution-as-the-performance-bottleneck"},{"level":2,"text":"Before You Move On: Pitfall Checklist","id":"before-you-move-on-pitfall-checklist"},{"level":2,"text":"What You&#39;ve Built and What Comes Next","id":"what-you39ve-built-and-what-comes-next"},{"level":2,"text":"You have crossed the final boundary between &quot;library&quot; and &quot;operating system component.&quot; Your filesystem is now a real mount point. Standard Unix tools â€” ls, cat, cp, find, grep, vim â€” work against it without modification, without knowing your code exists. The VFS contract is satisfied. The FUSE relay is wired. The entire stack from user application through kernel VFS through FUSE through your C code through block-level I/O runs seamlessly.\nBut there is a crack in the foundation, and you have known about it since Milestone 1. Every write to your filesystem is a race condition. Not a concurrency race â€” a time race against power failure. Consider: echo &quot;critical data&quot; &gt; /mnt/myfs/important.txt calls your create callback, which writes the block bitmap, the inode, and the directory entry in three separate disk operations. If power fails between the bitmap write and the inode write, you have a leaked block that the bitmap marks as used but no inode references. If power fails between the inode write and the directory entry write, you have an orphaned inode that no path can reach. If power fails during the rename you just implemented â€” after adding the new entry but before removing the old one â€” you have a file with two names.\nIn all these cases, after a reboot, your filesystem is in an inconsistent state. The data blocks may be intact, but the metadata â€” bitmaps, inode table, directory entries â€” is incoherent. fsck can repair some of these by brute-force scanning all blocks and reconstructing consistent metadata, but that takes minutes on a large filesystem and sometimes loses data.\nMilestone 6 solves this definitively with write-ahead journaling. Every multi-step operation is wrapped in a transaction: write all changes to a sequential journal region first, write a commit record atomically, then apply the changes to the primary data structures. On crash: scan the journal, replay all committed transactions, discard incomplete ones. The filesystem is always consistent after recovery â€” not just &quot;recoverable,&quot; but guaranteed consistent by the structure of the write protocol.\nThe filesystem is almost production-ready. One milestone remains.","id":"you-have-crossed-the-final-boundary-between-quotlibraryquot-and-quotoperating-system-componentquot-your-filesystem-is-now-a-real-mount-point-standard-unix-tools-ls-cat-cp-find-grep-vim-work-against-it-without-modification-without-knowing-your-code-exists-the-vfs-contract-is-satisfied-the-fuse-relay-is-wired-the-entire-stack-from-user-application-through-kernel-vfs-through-fuse-through-your-c-code-through-block-level-io-runs-seamlessly-but-there-is-a-crack-in-the-foundation-and-you-have-known-about-it-since-milestone-1-every-write-to-your-filesystem-is-a-race-condition-not-a-concurrency-race-a-time-race-against-power-failure-consider-echo-quotcritical-dataquot-gt-mntmyfsimportanttxt-calls-your-create-callback-which-writes-the-block-bitmap-the-inode-and-the-directory-entry-in-three-separate-disk-operations-if-power-fails-between-the-bitmap-write-and-the-inode-write-you-have-a-leaked-block-that-the-bitmap-marks-as-used-but-no-inode-references-if-power-fails-between-the-inode-write-and-the-directory-entry-write-you-have-an-orphaned-inode-that-no-path-can-reach-if-power-fails-during-the-rename-you-just-implemented-after-adding-the-new-entry-but-before-removing-the-old-one-you-have-a-file-with-two-names-in-all-these-cases-after-a-reboot-your-filesystem-is-in-an-inconsistent-state-the-data-blocks-may-be-intact-but-the-metadata-bitmaps-inode-table-directory-entries-is-incoherent-fsck-can-repair-some-of-these-by-brute-force-scanning-all-blocks-and-reconstructing-consistent-metadata-but-that-takes-minutes-on-a-large-filesystem-and-sometimes-loses-data-milestone-6-solves-this-definitively-with-write-ahead-journaling-every-multi-step-operation-is-wrapped-in-a-transaction-write-all-changes-to-a-sequential-journal-region-first-write-a-commit-record-atomically-then-apply-the-changes-to-the-primary-data-structures-on-crash-scan-the-journal-replay-all-committed-transactions-discard-incomplete-ones-the-filesystem-is-always-consistent-after-recovery-not-just-quotrecoverablequot-but-guaranteed-consistent-by-the-structure-of-the-write-protocol-the-filesystem-is-almost-production-ready-one-milestone-remains"},{"level":1,"text":"Milestone 6: Write-Ahead Journaling and Crash Recovery","id":"milestone-6-write-ahead-journaling-and-crash-recovery"},{"level":2,"text":"The Lie Your Code Has Been Telling","id":"the-lie-your-code-has-been-telling"},{"level":2,"text":"The Fundamental Tension: Atomicity on Non-Atomic Hardware","id":"the-fundamental-tension-atomicity-on-non-atomic-hardware"},{"level":2,"text":"Journal Region: On-Disk Layout","id":"journal-region-on-disk-layout"},{"level":2,"text":"The Transaction API","id":"the-transaction-api"},{"level":3,"text":"txn_begin: Opening a Transaction","id":"txn_begin-opening-a-transaction"},{"level":3,"text":"txn_journal_block: Recording a Change","id":"txn_journal_block-recording-a-change"},{"level":3,"text":"txn_commit: The Critical Path","id":"txn_commit-the-critical-path"},{"level":2,"text":"The txn_journal_block Wrapper Idiom","id":"the-txn_journal_block-wrapper-idiom"},{"level":2,"text":"The key structural change: every operation now builds up a set of block changes in txn, then commits them all atomically. If any step fails before txn_commit, the transaction is simply abandoned â€” txn goes out of scope, nothing was written to disk, the filesystem is unchanged.","id":"the-key-structural-change-every-operation-now-builds-up-a-set-of-block-changes-in-txn-then-commits-them-all-atomically-if-any-step-fails-before-txn_commit-the-transaction-is-simply-abandoned-txn-goes-out-of-scope-nothing-was-written-to-disk-the-filesystem-is-unchanged"},{"level":2,"text":"Journal Recovery: Replaying on Mount","id":"journal-recovery-replaying-on-mount"},{"level":2,"text":"Metadata-Only Journaling","id":"metadata-only-journaling"},{"level":2,"text":"Journal Checkpointing","id":"journal-checkpointing"},{"level":2,"text":"Idempotency: The Safety Net for Replay","id":"idempotency-the-safety-net-for-replay"},{"level":2,"text":"Crash Simulation Test","id":"crash-simulation-test"},{"level":2,"text":"Integrating the Journal Into Mount/Unmount","id":"integrating-the-journal-into-mountunmount"},{"level":2,"text":"Three-Level View: What Happens During txn_commit","id":"three-level-view-what-happens-during-txn_commit"},{"level":2,"text":"Knowledge Cascade: One Journal, Ten Domains","id":"knowledge-cascade-one-journal-ten-domains"},{"level":3,"text":"Database WAL: The Identical Pattern","id":"database-wal-the-identical-pattern"},{"level":3,"text":"Redis AOF: Durability vs. Performance","id":"redis-aof-durability-vs-performance"},{"level":3,"text":"Raft and Distributed WAL","id":"raft-and-distributed-wal"},{"level":3,"text":"fsync and the Durability API","id":"fsync-and-the-durability-api"},{"level":3,"text":"Copy-on-Write: Eliminating Journaling&#39;s Complexity","id":"copy-on-write-eliminating-journaling39s-complexity"},{"level":3,"text":"fsck: The Pre-Journal Alternative","id":"fsck-the-pre-journal-alternative"},{"level":2,"text":"Before You Move On: Pitfall Checklist","id":"before-you-move-on-pitfall-checklist"},{"level":2,"text":"What You&#39;ve Built and What It Means","id":"what-you39ve-built-and-what-it-means"},{"level":2,"text":"You have completed the filesystem. Not a toy â€” a crash-consistent, journaled filesystem that can be trusted with real data. The chain is complete: raw block device abstraction, bitmap-based allocation, inode metadata with multi-level indirection, directory entries and path resolution, file read/write with sparse file support, FUSE integration for real OS mounting, and now write-ahead journaling for crash consistency.\nStep back and look at what you understand now that you did not before this milestone.\nYou understand why databases call fsync. You understand why skipping fsync loses data. You understand why PostgreSQL has WAL segments, why SQLite has a WAL file, why MySQL has redo logs â€” they are all solving the same problem you just solved: making multi-step metadata updates atomic despite non-atomic hardware, despite OS write reordering, despite disk write buffer reordering. The journal is not a database invention. It is a universal pattern for crash consistency.\nYou understand why ZFS never needs fsck. You understand why ext4&#39;s dir_index feature requires a journal-aware implementation (the B-tree restructuring touches multiple blocks that must be atomic). You understand why NTFS has a $LogFile. You understand why every serious storage system â€” from SQLite to Kafka to etcd â€” maintains a sequential write-ahead log as its first and most fundamental data structure.\nThe disk does not know you exist. But now you know how to make it remember exactly what you committed â€” and nothing more.","id":"you-have-completed-the-filesystem-not-a-toy-a-crash-consistent-journaled-filesystem-that-can-be-trusted-with-real-data-the-chain-is-complete-raw-block-device-abstraction-bitmap-based-allocation-inode-metadata-with-multi-level-indirection-directory-entries-and-path-resolution-file-readwrite-with-sparse-file-support-fuse-integration-for-real-os-mounting-and-now-write-ahead-journaling-for-crash-consistency-step-back-and-look-at-what-you-understand-now-that-you-did-not-before-this-milestone-you-understand-why-databases-call-fsync-you-understand-why-skipping-fsync-loses-data-you-understand-why-postgresql-has-wal-segments-why-sqlite-has-a-wal-file-why-mysql-has-redo-logs-they-are-all-solving-the-same-problem-you-just-solved-making-multi-step-metadata-updates-atomic-despite-non-atomic-hardware-despite-os-write-reordering-despite-disk-write-buffer-reordering-the-journal-is-not-a-database-invention-it-is-a-universal-pattern-for-crash-consistency-you-understand-why-zfs-never-needs-fsck-you-understand-why-ext439s-dir_index-feature-requires-a-journal-aware-implementation-the-b-tree-restructuring-touches-multiple-blocks-that-must-be-atomic-you-understand-why-ntfs-has-a-logfile-you-understand-why-every-serious-storage-system-from-sqlite-to-kafka-to-etcd-maintains-a-sequential-write-ahead-log-as-its-first-and-most-fundamental-data-structure-the-disk-does-not-know-you-exist-but-now-you-know-how-to-make-it-remember-exactly-what-you-committed-and-nothing-more"},{"level":2,"text":"System Overview","id":"system-overview"},{"level":1,"text":"TDD","id":"tdd"},{"level":1,"text":"Module Technical Design Specification: Block Layer and mkfs (filesystem-m1)","id":"module-technical-design-specification-block-layer-and-mkfs-filesystem-m1"},{"level":2,"text":"1. Module Charter","id":"1-module-charter"},{"level":2,"text":"2. File Structure","id":"2-file-structure"},{"level":2,"text":"3. Complete Data Model","id":"3-complete-data-model"},{"level":3,"text":"3.1. Superblock (superblock_t)","id":"31-superblock-superblock_t"},{"level":3,"text":"3.2. Inode Stub (inode_t)","id":"32-inode-stub-inode_t"},{"level":2,"text":"4. Interface Contracts","id":"4-interface-contracts"},{"level":3,"text":"4.1. Block I/O Layer","id":"41-block-io-layer"},{"level":3,"text":"4.2. Bitmap Allocator","id":"42-bitmap-allocator"},{"level":2,"text":"5. Algorithm Specification","id":"5-algorithm-specification"},{"level":3,"text":"5.1. On-Disk Layout Computation","id":"51-on-disk-layout-computation"},{"level":3,"text":"5.2. Bitmap Search (bitmap_find_free)","id":"52-bitmap-search-bitmap_find_free"},{"level":3,"text":"5.3. Root Directory Initialization","id":"53-root-directory-initialization"},{"level":2,"text":"6. Error Handling Matrix","id":"6-error-handling-matrix"},{"level":2,"text":"7. Implementation Sequence with Checkpoints","id":"7-implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Block I/O Bedrock (2 Hours)","id":"phase-1-block-io-bedrock-2-hours"},{"level":3,"text":"Phase 2: Serialization &amp; Layout (3 Hours)","id":"phase-2-serialization-amp-layout-3-hours"},{"level":3,"text":"Phase 3: The Allocator (3 Hours)","id":"phase-3-the-allocator-3-hours"},{"level":3,"text":"Phase 4: mkfs (5 Hours)","id":"phase-4-mkfs-5-hours"},{"level":2,"text":"8. Test Specification","id":"8-test-specification"},{"level":3,"text":"8.1. Happy Path: Formatting","id":"81-happy-path-formatting"},{"level":3,"text":"8.2. Edge Case: Boundary Allocation","id":"82-edge-case-boundary-allocation"},{"level":3,"text":"8.3. Failure Case: Invalid Mount","id":"83-failure-case-invalid-mount"},{"level":2,"text":"9. Performance Targets","id":"9-performance-targets"},{"level":2,"text":"10. Hardware Soul (Cache &amp; Alignment)","id":"10-hardware-soul-cache-amp-alignment"},{"level":3,"text":"","id":""},{"level":3,"text":"","id":""},{"level":1,"text":"Module Technical Design Specification: Inode Management (filesystem-m2)","id":"module-technical-design-specification-inode-management-filesystem-m2"},{"level":2,"text":"1. Module Charter","id":"1-module-charter"},{"level":2,"text":"2. File Structure","id":"2-file-structure"},{"level":2,"text":"3. Complete Data Model","id":"3-complete-data-model"},{"level":3,"text":"3.1. Inode Structure (inode_t)","id":"31-inode-structure-inode_t"},{"level":3,"text":"3.2. Indirect Block Format","id":"32-indirect-block-format"},{"level":2,"text":"4. Interface Contracts","id":"4-interface-contracts"},{"level":3,"text":"4.1. Lifecycle Management","id":"41-lifecycle-management"},{"level":3,"text":"4.2. Block Translation Engine","id":"42-block-translation-engine"},{"level":2,"text":"5. Algorithm Specification","id":"5-algorithm-specification"},{"level":3,"text":"5.1. The Traversal Logic (inode_get_block)","id":"51-the-traversal-logic-inode_get_block"},{"level":3,"text":"5.2. Recursive Deallocation (free_inode)","id":"52-recursive-deallocation-free_inode"},{"level":3,"text":"5.3. Sparse Allocation (inode_set_block)","id":"53-sparse-allocation-inode_set_block"},{"level":2,"text":"6. Error Handling Matrix","id":"6-error-handling-matrix"},{"level":2,"text":"7. Implementation Sequence with Checkpoints","id":"7-implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Serialization &amp; Inode Table Math (3 Hours)","id":"phase-1-serialization-amp-inode-table-math-3-hours"},{"level":3,"text":"Phase 2: Inode Lifecycle (3 Hours)","id":"phase-2-inode-lifecycle-3-hours"},{"level":3,"text":"Phase 3: The Translation Engine (4 Hours)","id":"phase-3-the-translation-engine-4-hours"},{"level":3,"text":"Phase 4: Recursive Reclamation (4 Hours)","id":"phase-4-recursive-reclamation-4-hours"},{"level":2,"text":"8. Test Specification","id":"8-test-specification"},{"level":3,"text":"8.1. Sparse File Integrity","id":"81-sparse-file-integrity"},{"level":3,"text":"8.2. Address Boundary Transitions","id":"82-address-boundary-transitions"},{"level":3,"text":"8.3. Recursive Cleanup (Leak Detection)","id":"83-recursive-cleanup-leak-detection"},{"level":2,"text":"9. Performance Targets","id":"9-performance-targets"},{"level":2,"text":"10. Concurrency Specification","id":"10-concurrency-specification"},{"level":3,"text":"","id":""},{"level":3,"text":"","id":""},{"level":1,"text":"Module Technical Design Specification: Directory Operations (filesystem-m3)","id":"module-technical-design-specification-directory-operations-filesystem-m3"},{"level":2,"text":"1. Module Charter","id":"1-module-charter"},{"level":2,"text":"2. File Structure","id":"2-file-structure"},{"level":2,"text":"3. Complete Data Model","id":"3-complete-data-model"},{"level":3,"text":"3.1. On-Disk Directory Entry (Physical Layout)","id":"31-on-disk-directory-entry-physical-layout"},{"level":3,"text":"3.2. In-Memory Representation (dirent_t)","id":"32-in-memory-representation-dirent_t"},{"level":2,"text":"4. Interface Contracts","id":"4-interface-contracts"},{"level":3,"text":"4.1. Lookup and Resolution","id":"41-lookup-and-resolution"},{"level":3,"text":"4.2. Directory Mutation","id":"42-directory-mutation"},{"level":2,"text":"5. Algorithm Specification","id":"5-algorithm-specification"},{"level":3,"text":"5.1. Directory Entry Packing (dir_add_entry)","id":"51-directory-entry-packing-dir_add_entry"},{"level":3,"text":"5.2. Path Resolution Engine (path_resolve)","id":"52-path-resolution-engine-path_resolve"},{"level":3,"text":"5.3. Link Count Invariants (fs_mkdir / fs_rmdir)","id":"53-link-count-invariants-fs_mkdir-fs_rmdir"},{"level":2,"text":"6. Error Handling Matrix","id":"6-error-handling-matrix"},{"level":2,"text":"7. Implementation Sequence with Checkpoints","id":"7-implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Serialization Primitives (3 Hours)","id":"phase-1-serialization-primitives-3-hours"},{"level":3,"text":"Phase 2: Scanning (3 Hours)","id":"phase-2-scanning-3-hours"},{"level":3,"text":"Phase 3: Path Resolution (4 Hours)","id":"phase-3-path-resolution-4-hours"},{"level":3,"text":"Phase 4: Mutation (5 Hours)","id":"phase-4-mutation-5-hours"},{"level":3,"text":"Phase 5: POSIX Operations (4 Hours)","id":"phase-5-posix-operations-4-hours"},{"level":2,"text":"8. Test Specification","id":"8-test-specification"},{"level":3,"text":"8.1. Hierarchical Persistence","id":"81-hierarchical-persistence"},{"level":3,"text":"8.2. Empty Directory Constraint","id":"82-empty-directory-constraint"},{"level":3,"text":"8.3. Hard Link Integrity","id":"83-hard-link-integrity"},{"level":2,"text":"9. Performance Targets","id":"9-performance-targets"},{"level":3,"text":"","id":""},{"level":3,"text":"","id":""},{"level":3,"text":"","id":""},{"level":1,"text":"Module Technical Design Specification: File Read/Write Operations (filesystem-m4)","id":"module-technical-design-specification-file-readwrite-operations-filesystem-m4"},{"level":2,"text":"1. Module Charter","id":"1-module-charter"},{"level":2,"text":"2. File Structure","id":"2-file-structure"},{"level":2,"text":"3. Complete Data Model","id":"3-complete-data-model"},{"level":3,"text":"3.1. Inode Metadata (inode_t) Reference Table","id":"31-inode-metadata-inode_t-reference-table"},{"level":3,"text":"3.2. Internal Operation Context","id":"32-internal-operation-context"},{"level":2,"text":"4. Interface Contracts","id":"4-interface-contracts"},{"level":3,"text":"4.1. File Lifecycle","id":"41-file-lifecycle"},{"level":3,"text":"4.2. The Data Plane","id":"42-the-data-plane"},{"level":3,"text":"4.3. Resizing","id":"43-resizing"},{"level":2,"text":"5. Algorithm Specification","id":"5-algorithm-specification"},{"level":3,"text":"5.1. fs_read: The Zero-Fill Loop","id":"51-fs_read-the-zero-fill-loop"},{"level":3,"text":"5.2. fs_write: The Read-Modify-Write (RMW) Engine","id":"52-fs_write-the-read-modify-write-rmw-engine"},{"level":3,"text":"5.3. fs_truncate: Shrink with Data Leak Protection","id":"53-fs_truncate-shrink-with-data-leak-protection"},{"level":2,"text":"6. Error Handling Matrix","id":"6-error-handling-matrix"},{"level":2,"text":"7. Implementation Sequence with Checkpoints","id":"7-implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Creation &amp; Math (2 Hours)","id":"phase-1-creation-amp-math-2-hours"},{"level":3,"text":"Phase 2: The Read Path (3 Hours)","id":"phase-2-the-read-path-3-hours"},{"level":3,"text":"Phase 3: The Write Path (4 Hours)","id":"phase-3-the-write-path-4-hours"},{"level":3,"text":"Phase 4: Truncate &amp; Append (4 Hours)","id":"phase-4-truncate-amp-append-4-hours"},{"level":2,"text":"8. Test Specification","id":"8-test-specification"},{"level":3,"text":"8.1. Partial Block RMW Verification","id":"81-partial-block-rmw-verification"},{"level":3,"text":"8.2. Sparse Hole Expansion","id":"82-sparse-hole-expansion"},{"level":3,"text":"8.3. Data Leakage (Security)","id":"83-data-leakage-security"},{"level":2,"text":"9. Performance Targets","id":"9-performance-targets"},{"level":2,"text":"10. Hardware Soul (Cache and Alignment)","id":"10-hardware-soul-cache-and-alignment"},{"level":3,"text":"10.1. Write Amplification Analysis","id":"101-write-amplification-analysis"},{"level":3,"text":"10.2. TLB and Page Alignment","id":"102-tlb-and-page-alignment"},{"level":3,"text":"","id":""},{"level":3,"text":"","id":""},{"level":1,"text":"Module Technical Design Specification: FUSE Integration (filesystem-m5)","id":"module-technical-design-specification-fuse-integration-filesystem-m5"},{"level":2,"text":"1. Module Charter","id":"1-module-charter"},{"level":2,"text":"2. File Structure","id":"2-file-structure"},{"level":2,"text":"3. Complete Data Model","id":"3-complete-data-model"},{"level":3,"text":"3.1. Global Filesystem Context (FsCtx)","id":"31-global-filesystem-context-fsctx"},{"level":3,"text":"3.2. FUSE File Handle (fi-&gt;fh)","id":"32-fuse-file-handle-fi-gtfh"},{"level":2,"text":"4. Interface Contracts","id":"4-interface-contracts"},{"level":3,"text":"4.1. The Path-to-Inode Bridge","id":"41-the-path-to-inode-bridge"},{"level":3,"text":"4.2. Core FUSE Callbacks (The VFS Contract)","id":"42-core-fuse-callbacks-the-vfs-contract"},{"level":2,"text":"5. Algorithm Specification","id":"5-algorithm-specification"},{"level":3,"text":"5.1. The getattr Hot-Path","id":"51-the-getattr-hot-path"},{"level":3,"text":"5.2. readdir Filler Loop","id":"52-readdir-filler-loop"},{"level":3,"text":"5.3. Atomic Rename","id":"53-atomic-rename"},{"level":2,"text":"6. Error Handling Matrix","id":"6-error-handling-matrix"},{"level":2,"text":"7. Implementation Sequence with Checkpoints","id":"7-implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: The Context and Mount (2 Hours)","id":"phase-1-the-context-and-mount-2-hours"},{"level":3,"text":"Phase 2: Metadata and Navigation (3 Hours)","id":"phase-2-metadata-and-navigation-3-hours"},{"level":3,"text":"Phase 3: Directory Contents (3 Hours)","id":"phase-3-directory-contents-3-hours"},{"level":3,"text":"Phase 4: File Data (4 Hours)","id":"phase-4-file-data-4-hours"},{"level":3,"text":"Phase 5: The Full POSIX Set (4 Hours)","id":"phase-5-the-full-posix-set-4-hours"},{"level":2,"text":"8. Test Specification","id":"8-test-specification"},{"level":3,"text":"8.1. Round-Trip Persistence","id":"81-round-trip-persistence"},{"level":3,"text":"8.2. Concurrent Access (Stress)","id":"82-concurrent-access-stress"},{"level":3,"text":"8.3. Sparse File Verification via Tools","id":"83-sparse-file-verification-via-tools"},{"level":2,"text":"9. Performance Targets","id":"9-performance-targets"},{"level":2,"text":"10. Concurrency Specification (Global Lock)","id":"10-concurrency-specification-global-lock"},{"level":3,"text":"","id":""},{"level":3,"text":"","id":""},{"level":1,"text":"Module Technical Design Specification: Write-Ahead Journaling and Crash Recovery (filesystem-m6)","id":"module-technical-design-specification-write-ahead-journaling-and-crash-recovery-filesystem-m6"},{"level":2,"text":"1. Module Charter","id":"1-module-charter"},{"level":2,"text":"2. File Structure","id":"2-file-structure"},{"level":2,"text":"3. Complete Data Model","id":"3-complete-data-model"},{"level":3,"text":"3.1. Journal Superblock (journal_super_t)","id":"31-journal-superblock-journal_super_t"},{"level":3,"text":"3.2. Descriptor Block (journal_desc_t)","id":"32-descriptor-block-journal_desc_t"},{"level":3,"text":"3.3. Commit Block (journal_commit_t)","id":"33-commit-block-journal_commit_t"},{"level":3,"text":"3.4. In-Memory Transaction (txn_t)","id":"34-in-memory-transaction-txn_t"},{"level":2,"text":"4. Interface Contracts","id":"4-interface-contracts"},{"level":3,"text":"4.1. Transaction Life Cycle","id":"41-transaction-life-cycle"},{"level":3,"text":"4.2. Recovery &amp; Maintenance","id":"42-recovery-amp-maintenance"},{"level":2,"text":"5. Algorithm Specification","id":"5-algorithm-specification"},{"level":3,"text":"5.1. The txn_commit Protocol (8-Step)","id":"51-the-txn_commit-protocol-8-step"},{"level":3,"text":"5.2. journal_recover (Replay Logic)","id":"52-journal_recover-replay-logic"},{"level":3,"text":"5.3. Ordered Data Write (Metadata-Only Mode)","id":"53-ordered-data-write-metadata-only-mode"},{"level":2,"text":"6. Error Handling Matrix","id":"6-error-handling-matrix"},{"level":2,"text":"7. Implementation Sequence with Checkpoints","id":"7-implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Journal Basics (3 Hours)","id":"phase-1-journal-basics-3-hours"},{"level":3,"text":"Phase 2: The Transaction Engine (5 Hours)","id":"phase-2-the-transaction-engine-5-hours"},{"level":3,"text":"Phase 3: Recovery &amp; Checkpointing (6 Hours)","id":"phase-3-recovery-amp-checkpointing-6-hours"},{"level":3,"text":"Phase 4: Integration (4 Hours)","id":"phase-4-integration-4-hours"},{"level":3,"text":"Phase 5: The Crash Simulation (4 Hours)","id":"phase-5-the-crash-simulation-4-hours"},{"level":2,"text":"8. Test Specification","id":"8-test-specification"},{"level":3,"text":"8.1. Atomic rename Verification","id":"81-atomic-rename-verification"},{"level":3,"text":"8.2. Journal Wrap-around","id":"82-journal-wrap-around"},{"level":3,"text":"8.3. Idempotent Replay","id":"83-idempotent-replay"},{"level":2,"text":"9. Performance Targets","id":"9-performance-targets"},{"level":2,"text":"10. Hardware Soul (Atomic Writes)","id":"10-hardware-soul-atomic-writes"},{"level":3,"text":"10.1. The Sector Atomicity Assumption","id":"101-the-sector-atomicity-assumption"},{"level":3,"text":"10.2. Barrier Analysis","id":"102-barrier-analysis"},{"level":3,"text":"{{DIAGRAM:tdd-diag-32}}","id":"diagramtdd-diag-32"},{"level":3,"text":"","id":""},{"level":1,"text":"Project Structure: Filesystem Implementation","id":"project-structure-filesystem-implementation"},{"level":2,"text":"Directory Tree","id":"directory-tree"},{"level":2,"text":"Creation Order","id":"creation-order"},{"level":2,"text":"File Count Summary","id":"file-count-summary"},{"level":1,"text":"ðŸ“š Beyond the Atlas: Further Reading","id":"-beyond-the-atlas-further-reading"},{"level":2,"text":"I. Core Architecture &amp; The Inode","id":"i-core-architecture-amp-the-inode"},{"level":2,"text":"II. VFS &amp; Path Resolution","id":"ii-vfs-amp-path-resolution"},{"level":2,"text":"III. Userspace Integration (FUSE)","id":"iii-userspace-integration-fuse"},{"level":2,"text":"IV. Persistence &amp; Crash Safety","id":"iv-persistence-amp-crash-safety"},{"level":2,"text":"V. Hardware Interaction (The Physical Layer)","id":"v-hardware-interaction-the-physical-layer"},{"level":2,"text":"VI. Memory Management Parallelism","id":"vi-memory-management-parallelism"}],"title":"ðŸŽ¯ Project Charter: Filesystem Implementation","markdown":"# ðŸŽ¯ Project Charter: Filesystem Implementation\n\n## What You Are Building\nYou are building a fully functional, on-disk, inode-based filesystem that integrates directly with the Linux kernel via FUSE. Unlike a simple memory-based simulation, your filesystem will store data in a persistent 4KB-block-aligned disk image, support multi-level indirect block pointers for large files, provide a hierarchical directory tree, and implement a circular write-ahead journal (WAL) to ensure metadata remains consistent even if the power is cut mid-write.\n\n## Why This Project Exists\nMost developers treat the filesystem as a reliable, infinite, byte-addressable array, but storage hardware is actually a rigid, finite collection of blocks. Building a filesystem from scratch forces you to bridge this gap manually. You will learn to negotiate the \"read-modify-write\" cycles inherent in SSDs, implement the same indirection logic used in CPU page tables, and master the atomic commit protocols that prevent data corruption in production databases like PostgreSQL and SQLite.\n\n## What You Will Be Able to Do When Done\n- **Design on-disk layouts:** Calculate exactly where superblocks, bitmaps, and inode tables live on a raw device.\n- **Manage multi-level indirection:** Implement direct, single-indirect, and double-indirect pointers to address files up to 4GB.\n- **Implement Path Resolution:** Build the recursion logic that translates strings like `/home/user/file.txt` into specific inode identifiers.\n- **Expose Userspace Filesystems:** Use the FUSE API to mount your code as a real Linux mount point accessible by `ls`, `cp`, and `vim`.\n- **Guarantee Crash Consistency:** Build a write-ahead journal that can replay committed transactions after a simulated system crash.\n\n## Final Deliverable\nA complete C or Rust system consisting of ~4,000 lines of code across two primary binaries:\n1. **`mkfs`**: A formatting tool that initializes raw files into valid filesystem images.\n2. **`myfs`**: A FUSE daemon that mounts the image. \nThe system is complete when you can mount your filesystem, copy a git repository into it, `SIGKILL` the process during a write, and see the filesystem recover perfectly upon remounting.\n\n## Is This Project For You?\n**You should start this if you:**\n- Are comfortable with C or Rust, specifically manual memory management and pointers.\n- Understand bitwise operations (masks, shifts) for bitmap manipulation.\n- Have a basic grasp of POSIX File I/O (`open`, `lseek`, `read`, `write`).\n\n**Come back after you've learned:**\n- **Struct Packing:** Understanding how compilers align data in memory (e.g., `__attribute__((packed))`).\n- **Basic Data Structures:** You must be comfortable with linked lists and tree-like traversal.\n\n## Estimated Effort\n| Phase | Time |\n|-------|------|\n| **Phase 1:** Block Layer and mkfs | ~12 hours |\n| **Phase 2:** Inode Management | ~12 hours |\n| **Phase 3:** Directory Operations | ~12 hours |\n| **Phase 4:** File Read/Write Operations | ~12 hours |\n| **Phase 5:** FUSE Integration | ~12 hours |\n| **Phase 6:** Write-Ahead Journaling | ~15 hours |\n| **Total** | **~75 hours** |\n\n## Definition of Done\nThe project is complete when:\n- The `mkfs` tool generates an image that passes a validation script checking superblock magic numbers and root directory invariants.\n- The filesystem can be mounted via FUSE and supports standard Unix commands (`ls -la`, `mkdir`, `rm`, `cp`, `mv`).\n- The system correctly handles \"sparse files,\" where seeking past EOF and writing does not consume physical disk blocks for the gap.\n- A \"Crash Test\" script successfully triggers a `SIGKILL` during a metadata-heavy operation, and `journal_recover` restores the filesystem to a consistent state on the next mount.\n- All internal consistency checks (assertions on block numbers and link counts) pass under a concurrent workload of at least 4 threads.\n\n---\n\n# Filesystem Implementation: An Interactive Atlas\n\nThis project builds a complete inode-based filesystem from raw blocks up through FUSE mounting and write-ahead journaling. You will start with nothing but a flat file acting as a disk image, and layer increasingly sophisticated abstractions: block I/O, bitmap allocation, inode metadata with multi-level indirection, directory trees with path resolution, full POSIX-like file operations, real OS integration via FUSE, and finally crash-consistent journaling. Each layer reveals how the operating system transforms a dumb array of 4KB blocks into the rich tree of files and directories that every program takes for granted.\n\nThe atlas is structured so that each milestone shatters a common misconception about how filesystems work, then cascades that insight into 3-5 connected domains. By the end, you won't just have a working filesystem â€” you'll understand why databases use WAL, why SSDs have FTLs, why `fsync` matters, and why every storage system on earth is really just a block allocator with opinions.\n\n\n\n<!-- MS_ID: filesystem-m1 -->\n# Milestone 1: Block Layer and mkfs\n## The Disk Does Not Know You Exist\nYou have written thousands of files. You have called `fopen`, `fwrite`, `fclose` without thinking twice. You have an intuition â€” a reasonable one â€” that when you write \"Hello\" to a file, those five bytes land somewhere on the disk in sequence, and the OS just keeps track of where they are.\nThat intuition is completely wrong.\nThe disk has no concept of your file. It has no concept of bytes. It has no concept of names, paths, or even the idea that one chunk of data \"belongs together.\" The disk is a machine that answers exactly two questions: \"Give me block number N\" and \"Store these bytes at block number N.\" Block N is always the same size â€” 4,096 bytes â€” and the disk treats all of them identically. Block 7 is not more important than block 7,000,000. They are interchangeable containers.\nEverything you have ever experienced as a \"file\" â€” its name, its size, its permissions, the fact that its contents are logically contiguous even when physically scattered â€” is a fiction maintained entirely by software. The filesystem is the author of that fiction. And this milestone is where you learn to write it from scratch.\n\n![Before/After mkfs â€” Raw vs. Formatted](./diagrams/diag-m1-before-after-mkfs.svg)\n\n---\n## The Fundamental Tension: Fixed Blocks vs. Variable Reality\n[[EXPLAIN:block-device-abstraction-â€”-why-disks-speak-in-fixed-size-blocks,-not-bytes|Block device abstraction â€” why disks speak in fixed-size blocks, not bytes]]\nHere is the core hardware constraint you are negotiating with for this entire project:\n**Storage hardware speaks in fixed, aligned blocks. Software demands arbitrary byte ranges.**\nA spinning magnetic disk reads and writes in sectors (typically 512 bytes, modern \"Advanced Format\" drives: 4,096 bytes). The read/write head sweeps across a platter â€” you cannot tell it to read 5 bytes starting at byte offset 7,234. You must read the entire sector containing those bytes, modify what you need in memory, and write the entire sector back. This is called a **read-modify-write cycle**, and you will encounter it in every layer of this project.\nSSDs are even more constrained. NAND flash cells can only be written in \"pages\" (4â€“16 KB) and only erased in larger \"blocks\" (128â€“512 KB). The SSD's internal controller â€” called the Flash Translation Layer (FTL) â€” hides these constraints behind a block interface identical to what a spinning disk presents.\n> The numbers that matter:\n> - A read of any size within one 4KB block = 1 disk I/O operation\n> - Two reads that span a 4KB boundary = 2 disk I/O operations\n> - Misaligned access that crosses block boundaries = double the cost\nYour filesystem inherits this constraint from below. You will define a block size of 4,096 bytes (4KB). Everything you store â€” superblock metadata, bitmaps, inode tables, directory entries, file data â€” must be packed into an integer number of 4KB blocks. Nothing lives between blocks. Nothing spans blocks unless you explicitly manage it.\nThis is the deal. Let's build around it.\n---\n## The Disk Image: A File That Pretends to Be a Disk\nYou do not have a spare disk lying around for development. You don't need one. A regular file on your host OS can serve as a perfectly faithful disk simulation. You will open a file (`disk.img`), and every 4KB region within that file corresponds to one block.\n\n![Block Device â€” read_block/write_block Translation](./diagrams/diag-m1-block-device-abstraction.svg)\n\nThis is your block device abstraction. Two functions. Nothing else:\n```c\nint read_block(int fd, uint32_t block_num, void *buf);\nint write_block(int fd, uint32_t block_num, const void *buf);\n```\n`fd` is the open file descriptor of your disk image. `block_num` is the logical address. `buf` is exactly `BLOCK_SIZE` (4,096) bytes. The implementation is a seek followed by a read or write:\n```c\n#include <unistd.h>\n#include <stdint.h>\n#include <string.h>\n#include <errno.h>\n#define BLOCK_SIZE   4096\n#define SECTOR_SIZE  512   /* kept for reference; we use BLOCK_SIZE units */\nint read_block(int fd, uint32_t block_num, void *buf) {\n    off_t offset = (off_t)block_num * BLOCK_SIZE;\n    if (lseek(fd, offset, SEEK_SET) == (off_t)-1) {\n        return -errno;\n    }\n    ssize_t n = read(fd, buf, BLOCK_SIZE);\n    if (n != BLOCK_SIZE) {\n        return (n < 0) ? -errno : -EIO;\n    }\n    return 0;\n}\nint write_block(int fd, uint32_t block_num, const void *buf) {\n    off_t offset = (off_t)block_num * BLOCK_SIZE;\n    if (lseek(fd, offset, SEEK_SET) == (off_t)-1) {\n        return -errno;\n    }\n    ssize_t n = write(fd, buf, BLOCK_SIZE);\n    if (n != BLOCK_SIZE) {\n        return (n < 0) ? -errno : -EIO;\n    }\n    return 0;\n}\n```\nEvery single operation in this project â€” reading a superblock, scanning a bitmap, fetching an inode, reading file data â€” will eventually call one of these two functions. They are the bedrock. Everything above them is metadata management.\n> **Hardware Soul**: What happens when `read_block` executes? Your host OS's VFS layer intercepts the `read` syscall. The kernel checks the page cache â€” if the 4KB chunk is already cached in RAM, no disk I/O occurs; the data is copied from kernel memory to your buffer in nanoseconds. If it's not cached (cold miss), the kernel submits a block I/O request, the disk controller fetches the sector(s), the data lands in a kernel buffer, and then gets copied to your process. That cold miss costs 50â€“150 Î¼s on an SSD, or 5â€“10 ms on a spinning disk. Your block abstraction hides this, but the latency is always there underneath.\n**Pitfall to avoid**: Always validate `block_num < total_blocks` before calling into these functions. A bug that passes `block_num = 3,000,000` into a disk image with only 1,000 blocks will happily seek to byte offset 12 billion and either hit EOF or extend the file. Add a bounds check:\n```c\n/* Always called before read_block / write_block */\nstatic int validate_block_num(uint32_t block_num, uint32_t total_blocks) {\n    if (block_num >= total_blocks) {\n        return -EINVAL;\n    }\n    return 0;\n}\n```\n---\n## On-Disk Layout: The Filesystem as a Database\nYou have a flat array of 4KB blocks. Your filesystem needs to store several kinds of data:\n1. **The filesystem's own description** â€” how big is it? how many inodes? where do things live? â†’ **Superblock**\n2. **Which blocks are free and which are in use?** â†’ **Block Bitmap**\n3. **Which inode numbers are free and which are in use?** â†’ **Inode Bitmap**\n4. **The actual inode structures** (file metadata: size, permissions, block pointers) â†’ **Inode Table**\n5. **The journal** (for crash recovery in Milestone 6) â†’ **Journal Region**\n6. **The actual file and directory data** â†’ **Data Blocks**\nThese must be arranged in a specific order in the block array, and every component must know where to find every other component. The superblock is the bootstrap record that makes this possible â€” it stores the positions and sizes of everything else.\n\n![On-Disk Layout â€” Complete Block Map](./diagrams/diag-m1-disk-layout.svg)\n\nHere is the layout we will use:\n| Block Range | Contents |\n|---|---|\n| Block 0 | Superblock |\n| Block 1 | Block Bitmap (tracks data blocks) |\n| Block 2 | Inode Bitmap |\n| Blocks 3â€“N | Inode Table (N depends on inode count) |\n| Blocks N+1â€“M | Journal Region |\n| Blocks M+1â€“end | Data Blocks |\nThe exact values of N and M are computed from the superblock fields â€” which means you need to understand the superblock first.\n---\n## The Superblock: Your Filesystem's Birth Certificate\n[[EXPLAIN:on-disk-serialization-â€”-packing-structs-to-exact-byte-layouts-with-fixed-width-types|On-disk serialization â€” packing structs to exact byte layouts with fixed-width types]]\nThe superblock lives in block 0. It is the first thing read when you mount the filesystem, and the source of truth for every other layout calculation. If the superblock is corrupted, the filesystem is unreadable â€” there is no way to find anything else.\nHere is every field and why it exists:\n```c\n#include <stdint.h>\n#define FS_MAGIC        0xDEADC0DE   /* arbitrary identifier; proves this is OUR filesystem */\n#define FS_VERSION      1\n#define BLOCK_SIZE      4096\n#define INODE_SIZE      128          /* bytes per inode; must divide evenly into BLOCK_SIZE */\n#define INODES_PER_BLOCK (BLOCK_SIZE / INODE_SIZE)   /* 32 inodes per block */\n/*\n * Superblock â€” always resides in block 0.\n *\n * BYTE LAYOUT (all little-endian, packed):\n *   Offset  0: magic           (4 bytes)\n *   Offset  4: version         (4 bytes)\n *   Offset  8: block_size      (4 bytes)\n *   Offset 12: total_blocks    (4 bytes)\n *   Offset 16: total_inodes    (4 bytes)\n *   Offset 20: free_blocks     (4 bytes)\n *   Offset 24: free_inodes     (4 bytes)\n *   Offset 28: inode_table_start (4 bytes)\n *   Offset 32: inode_table_blocks (4 bytes)\n *   Offset 36: journal_start   (4 bytes)\n *   Offset 40: journal_blocks  (4 bytes)\n *   Offset 44: data_block_start (4 bytes)\n *   Offset 48: root_inode      (4 bytes)\n *   ...reserved...             (4044 bytes to fill block)\n *   Total: 4096 bytes (1 block)\n */\ntypedef struct __attribute__((packed)) {\n    uint32_t magic;              /* must equal FS_MAGIC to be a valid filesystem */\n    uint32_t version;            /* filesystem format version */\n    uint32_t block_size;         /* always BLOCK_SIZE (4096) â€” stored for validation */\n    uint32_t total_blocks;       /* total number of blocks in the image */\n    uint32_t total_inodes;       /* maximum number of inodes */\n    uint32_t free_blocks;        /* count of currently unallocated data blocks */\n    uint32_t free_inodes;        /* count of currently unallocated inodes */\n    uint32_t inode_table_start;  /* block number where inode table begins */\n    uint32_t inode_table_blocks; /* how many blocks the inode table occupies */\n    uint32_t journal_start;      /* block number where journal region begins */\n    uint32_t journal_blocks;     /* how many blocks the journal occupies */\n    uint32_t data_block_start;   /* block number where data blocks begin */\n    uint32_t root_inode;         /* inode number of the root directory (/) */\n    uint8_t  reserved[BLOCK_SIZE - 52]; /* pad to exactly one block */\n} superblock_t;\n```\n> **Why `__attribute__((packed))`?** The C compiler inserts invisible padding bytes between struct fields to align them to their natural size (a `uint32_t` is normally aligned to a 4-byte boundary). When you write this struct to disk and read it back on a different system â€” or even the same system after recompilation â€” padding bytes may shift. `__attribute__((packed))` tells GCC/Clang to remove all padding: every field occupies exactly the bytes you declared. This is mandatory for any struct that lives on disk. The tradeoff: packed struct access may generate slower unaligned memory reads on some architectures. For disk I/O, this is irrelevant.\n\n![Superblock Structure â€” Byte-Level Memory Layout](./diagrams/diag-m1-superblock-struct.svg)\n\n**The magic number** deserves special attention. `0xDEADC0DE` is not just vanity â€” it is a safety gate. When you implement mounting, the very first check is:\n```c\nif (sb.magic != FS_MAGIC) {\n    fprintf(stderr, \"Not a valid filesystem image (bad magic: 0x%08X)\\n\", sb.magic);\n    return -EINVAL;\n}\n```\nWithout this check, your filesystem code will happily interpret a random file, a truncated image, or a different filesystem format as valid â€” and then corrupt it. Every filesystem has a magic number: ext4 uses `0xEF53`, FAT32 uses `0x28` at offset 66, XFS uses `\"XFSB\"` as ASCII bytes.\n**Layout calculations** â€” all positions are derived from the superblock, computed once during `mkfs` and stored:\n```c\n/* Given: total_blocks, total_inodes\n * Compute: all region positions */\nstatic void compute_layout(uint32_t total_blocks, uint32_t total_inodes,\n                            superblock_t *sb) {\n    sb->block_size      = BLOCK_SIZE;\n    sb->total_blocks    = total_blocks;\n    sb->total_inodes    = total_inodes;\n    /* Fixed positions */\n    /* Block 0: superblock (already implicit) */\n    /* Block 1: block bitmap */\n    /* Block 2: inode bitmap */\n    uint32_t inode_table_start = 3;\n    uint32_t inode_table_blocks = (total_inodes + INODES_PER_BLOCK - 1)\n                                   / INODES_PER_BLOCK;\n    /* e.g., 1024 inodes / 32 per block = 32 blocks for inode table */\n    uint32_t journal_start  = inode_table_start + inode_table_blocks;\n    uint32_t journal_blocks = 1024;  /* 4MB journal; tune as needed */\n    uint32_t data_start = journal_start + journal_blocks;\n    sb->inode_table_start  = inode_table_start;\n    sb->inode_table_blocks = inode_table_blocks;\n    sb->journal_start      = journal_start;\n    sb->journal_blocks     = journal_blocks;\n    sb->data_block_start   = data_start;\n    /* Free counts: subtract everything used by metadata */\n    sb->free_blocks = total_blocks - data_start;  /* data blocks only */\n    sb->free_inodes = total_inodes - 1;            /* inode 1 reserved for root */\n    sb->root_inode  = 1;\n    sb->magic       = FS_MAGIC;\n    sb->version     = FS_VERSION;\n}\n```\n> **Off-by-one protection**: Notice `free_blocks = total_blocks - data_start`. This is exact â€” it means blocks 0 through `data_start - 1` are all metadata and are never treated as allocatable data blocks. The block bitmap only tracks data blocks, so bitmap bit 0 corresponds to disk block `data_block_start`, not disk block 0. This offset must be applied consistently everywhere â€” allocating from the bitmap gives you a *data block index*, which you add to `data_block_start` to get the actual disk block number.\n---\n## Bitmaps: One Bit per Block, Two States of Truth\n[[EXPLAIN:bitmap-data-structure-â€”-bit-level-allocation-tracking|Bitmap data structure â€” bit-level allocation tracking]]\nTo track which blocks and inodes are free, you need a data structure that is:\n1. **Compact** â€” tracking 1,000,000 blocks should not cost 1,000,000 bytes\n2. **Fast to scan** â€” finding the first free block must be quick\n3. **Easy to update** â€” marking a block used or free must be a simple write\nA bitmap satisfies all three. One bit per tracked item: `0` means free, `1` means used. 4KB of bitmap = 4096 Ã— 8 = 32,768 bits = 32,768 blocks tracked. A filesystem with 1 million data blocks needs only 32 bitmap blocks (~128KB) to track them all.\n\n![Bitmap Allocation â€” Bit-Level Operations](./diagrams/diag-m1-bitmap-ops.svg)\n\nYour block bitmap lives in block 1. It is allocated exactly one block (4KB = 32,768 bits), which limits your filesystem to 32,768 data blocks (128MB). For a learning project, this is fine. Real filesystems use multiple bitmap blocks per block group (ext4) or more sophisticated free space trees (XFS, Btrfs).\n```c\n/*\n * Bitmap operations.\n * The bitmap is stored in memory as uint8_t[BLOCK_SIZE].\n * Each bit corresponds to one block or inode.\n *\n * Bit layout within a byte (standard, big-endian bit order):\n *   byte[0] bit 7 â†’ index 0\n *   byte[0] bit 6 â†’ index 1\n *   ...\n *   byte[0] bit 0 â†’ index 7\n *   byte[1] bit 7 â†’ index 8\n *   ...\n *\n * We use the simpler little-endian bit order here:\n *   byte[i / 8] bit (i % 8)\n */\n/* Test whether bit at index is set (1 = used) */\nstatic inline int bitmap_test(const uint8_t *bitmap, uint32_t index) {\n    return (bitmap[index / 8] >> (index % 8)) & 1;\n}\n/* Set bit at index (mark as used) */\nstatic inline void bitmap_set(uint8_t *bitmap, uint32_t index) {\n    bitmap[index / 8] |= (1u << (index % 8));\n}\n/* Clear bit at index (mark as free) */\nstatic inline void bitmap_clear(uint8_t *bitmap, uint32_t index) {\n    bitmap[index / 8] &= ~(1u << (index % 8));\n}\n/*\n * Find the first free bit in the bitmap.\n * Returns the index of the first 0 bit, or -1 if all bits are set (full).\n * \n * Optimization: scan byte-by-byte first; skip fully-used bytes (0xFF) fast.\n */\nstatic int bitmap_find_free(const uint8_t *bitmap, uint32_t total_items) {\n    uint32_t num_bytes = (total_items + 7) / 8;\n    for (uint32_t byte_idx = 0; byte_idx < num_bytes; byte_idx++) {\n        if (bitmap[byte_idx] == 0xFF) {\n            continue;  /* all 8 bits used â€” skip entire byte */\n        }\n        /* At least one free bit in this byte; find which one */\n        for (int bit = 0; bit < 8; bit++) {\n            uint32_t index = byte_idx * 8 + bit;\n            if (index >= total_items) {\n                return -1;  /* ran past the valid range */\n            }\n            if (!((bitmap[byte_idx] >> bit) & 1)) {\n                return (int)index;\n            }\n        }\n    }\n    return -1;  /* bitmap full */\n}\n```\n**Block allocation in full context** â€” combining disk I/O with bitmap logic:\n```c\n/*\n * Allocate a data block. Returns disk block number, or -1 on failure.\n * The block bitmap is in disk block 1 (BLOCK_BITMAP_BLOCK).\n */\n#define BLOCK_BITMAP_BLOCK  1\n#define INODE_BITMAP_BLOCK  2\nint alloc_block(int fd, superblock_t *sb) {\n    uint8_t bitmap[BLOCK_SIZE];\n    /* Step 1: Load the block bitmap from disk */\n    if (read_block(fd, BLOCK_BITMAP_BLOCK, bitmap) != 0) {\n        return -1;\n    }\n    /* Step 2: Find a free bit */\n    int data_idx = bitmap_find_free(bitmap, sb->free_blocks + \n                                    (sb->total_blocks - sb->data_block_start \n                                     - sb->free_blocks));\n    /* Simpler: track total data blocks separately */\n    uint32_t data_blocks_total = sb->total_blocks - sb->data_block_start;\n    data_idx = bitmap_find_free(bitmap, data_blocks_total);\n    if (data_idx < 0) {\n        return -1;  /* disk full */\n    }\n    /* Step 3: Mark it used */\n    bitmap_set(bitmap, (uint32_t)data_idx);\n    /* Step 4: Write bitmap back to disk â€” MUST happen before returning */\n    if (write_block(fd, BLOCK_BITMAP_BLOCK, bitmap) != 0) {\n        return -1;\n    }\n    /* Step 5: Update superblock free count */\n    sb->free_blocks--;\n    /* Note: caller must persist the superblock update too */\n    /* Step 6: Return the DISK block number (offset by data_block_start) */\n    return (int)(sb->data_block_start + (uint32_t)data_idx);\n}\n/*\n * Free a data block. disk_block_num is the actual disk block number.\n */\nint free_block(int fd, superblock_t *sb, uint32_t disk_block_num) {\n    if (disk_block_num < sb->data_block_start ||\n        disk_block_num >= sb->total_blocks) {\n        return -EINVAL;  /* cannot free a metadata block */\n    }\n    uint8_t bitmap[BLOCK_SIZE];\n    if (read_block(fd, BLOCK_BITMAP_BLOCK, bitmap) != 0) {\n        return -EIO;\n    }\n    uint32_t data_idx = disk_block_num - sb->data_block_start;\n    bitmap_clear(bitmap, data_idx);\n    if (write_block(fd, BLOCK_BITMAP_BLOCK, bitmap) != 0) {\n        return -EIO;\n    }\n    sb->free_blocks++;\n    return 0;\n}\n```\nThe inode bitmap is identical in structure, just stored in block 2 and tracking inode numbers rather than data blocks. Implement `alloc_inode` and `free_inode` the same way, substituting `INODE_BITMAP_BLOCK` and `sb->total_inodes`.\n> **Hardware Soul â€” Bitmap Scan Performance**: The `bitmap_find_free` function scans sequentially. This is intentional: sequential memory access is extremely cache-friendly. Your entire block bitmap fits in a single 4KB block â€” which fits in a single L1 cache line fetch (actually 64 L1 cache lines at 64 bytes each, but the sequential scan will prefetch them automatically). Scanning 32,768 bits sequentially is ~4,000 byte comparisons â€” at 32 bytes per cycle, under 200 CPU cycles, under 100ns. The disk read to load the bitmap is 1000Ã— slower. The bitmap scan itself is never the bottleneck.\n> **Why not a free list instead?** A linked list of free blocks (used by early Unix filesystems) has O(1) allocation but requires updating two disk blocks per allocation (the list head block and the freed/allocated block). Scanning a full bitmap has O(n) worst case but O(1) in practice for nearly-empty filesystems. The bigger win: bitmaps are trivially crash-recoverable â€” you can reconstruct the correct bitmap by scanning all inodes.\n---\n## Designing for Crash Safety: The Two-Write Problem\nBefore writing `mkfs`, you need to internalize one consequence of working with blocks that will affect every write operation you ever implement:\n**A crash between two writes leaves the filesystem in an inconsistent state.**\nExample: to allocate block 500, you must:\n1. Set bit 500 in the block bitmap (marks it used)\n2. Update the inode's block pointer to point to 500\nIf the power dies between step 1 and step 2, you now have a block that is marked as used but that no inode points to â€” a **leaked block**. If the power dies between step 2 and step 1 (if you do it in the other order), you have a block that an inode thinks it owns but that is also marked free â€” which means it could be allocated to a different file, causing **data corruption**.\nThis is the crash consistency problem. Milestone 6 solves it properly with journaling. For now, establish the discipline: **always write to the bitmap before writing to the structure that references it**. When in doubt, bitmap first.\n---\n## mkfs: Formatting the Raw Image\n`mkfs` stands for \"make filesystem.\" It is the tool that transforms a raw, unformatted file (a flat blob of zeros) into a valid filesystem that your code can mount and operate on. Every filesystem has one: `mkfs.ext4`, `mkfs.xfs`, `mkfs.fat`.\nYour `mkfs` must perform these operations in order:\n\n![mkfs Initialization Sequence](./diagrams/diag-m1-mkfs-sequence.svg)\n\n1. Create (or truncate) the disk image file to the desired size\n2. Compute the on-disk layout (call `compute_layout`)\n3. Write the superblock to block 0\n4. Zero the block bitmap (block 1) â€” all blocks free\n5. Zero the inode bitmap (block 2) â€” all inodes free\n6. Zero the inode table blocks\n7. Allocate inode 1 for the root directory\n8. Initialize the root directory (a special file whose data contains directory entries for `.` and `..`)\n9. Flush everything to disk\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <errno.h>\n/* Minimal inode structure â€” full version in Milestone 2 */\n#define N_DIRECT_PTRS  12\ntypedef struct __attribute__((packed)) {\n    uint16_t mode;          /* file type + permissions */\n    uint16_t uid;\n    uint32_t size;          /* file size in bytes */\n    uint32_t atime;\n    uint32_t mtime;\n    uint32_t ctime;\n    uint16_t nlinks;        /* hard link count */\n    uint16_t _pad;\n    uint32_t blocks[N_DIRECT_PTRS];  /* direct block pointers */\n    uint32_t single_indirect;\n    uint32_t double_indirect;\n    uint8_t  reserved[12];  /* pad to 128 bytes */\n} inode_t;\n_Static_assert(sizeof(inode_t) == 128, \"inode_t must be exactly 128 bytes\");\n/* Minimal directory entry â€” full version in Milestone 3 */\ntypedef struct __attribute__((packed)) {\n    uint32_t inode_num;     /* 0 = free/unused entry */\n    uint16_t rec_len;       /* total length of this entry */\n    uint8_t  name_len;      /* length of name field */\n    uint8_t  file_type;     /* 0=unknown, 1=regular, 2=directory */\n    char     name[256];     /* null-padded, NOT null-terminated necessarily */\n} dirent_t;\n/* File type constants (stored in mode high bits) */\n#define S_IFDIR  0040000\n#define S_IFREG  0100000\n#define DEFAULT_DIR_MODE  (S_IFDIR | 0755)\n/*\n * Write an inode to the inode table on disk.\n * inode_num: 1-based inode number (0 is reserved/invalid)\n */\nint write_inode(int fd, const superblock_t *sb, uint32_t inode_num,\n                const inode_t *inode) {\n    if (inode_num == 0 || inode_num > sb->total_inodes) {\n        return -EINVAL;\n    }\n    /* Convert inode number to disk position */\n    uint32_t idx          = inode_num - 1;  /* 0-based index into inode table */\n    uint32_t block_offset = idx / INODES_PER_BLOCK;\n    uint32_t block_num    = sb->inode_table_start + block_offset;\n    uint32_t slot_in_block = idx % INODES_PER_BLOCK;\n    uint8_t buf[BLOCK_SIZE];\n    if (read_block(fd, block_num, buf) != 0) {\n        return -EIO;\n    }\n    /* Copy inode into the correct slot within this block */\n    memcpy(buf + slot_in_block * INODE_SIZE, inode, INODE_SIZE);\n    return write_block(fd, block_num, buf);\n}\n/*\n * mkfs: initialize a fresh filesystem image.\n *\n * image_path: path to create the disk image\n * total_blocks: desired size in 4KB blocks (e.g., 4096 = 16MB image)\n * total_inodes: maximum number of inodes\n */\nint mkfs(const char *image_path, uint32_t total_blocks, uint32_t total_inodes) {\n    /* --- Step 1: Create and size the image file --- */\n    int fd = open(image_path, O_RDWR | O_CREAT | O_TRUNC, 0644);\n    if (fd < 0) {\n        perror(\"open\");\n        return -1;\n    }\n    /* Extend the file to total_blocks * BLOCK_SIZE bytes */\n    if (ftruncate(fd, (off_t)total_blocks * BLOCK_SIZE) != 0) {\n        perror(\"ftruncate\");\n        close(fd);\n        return -1;\n    }\n    /* --- Step 2: Compute layout and initialize superblock --- */\n    superblock_t sb;\n    memset(&sb, 0, sizeof(sb));\n    compute_layout(total_blocks, total_inodes, &sb);\n    /* --- Step 3: Write superblock to block 0 --- */\n    uint8_t block_buf[BLOCK_SIZE];\n    memset(block_buf, 0, BLOCK_SIZE);\n    memcpy(block_buf, &sb, sizeof(sb));\n    if (write_block(fd, 0, block_buf) != 0) {\n        fprintf(stderr, \"Failed to write superblock\\n\");\n        close(fd);\n        return -1;\n    }\n    /* --- Step 4: Zero the block bitmap (block 1) --- */\n    memset(block_buf, 0, BLOCK_SIZE);\n    if (write_block(fd, BLOCK_BITMAP_BLOCK, block_buf) != 0) {\n        close(fd);\n        return -1;\n    }\n    /* --- Step 5: Zero the inode bitmap (block 2) --- */\n    if (write_block(fd, INODE_BITMAP_BLOCK, block_buf) != 0) {\n        close(fd);\n        return -1;\n    }\n    /* --- Step 6: Zero the inode table --- */\n    for (uint32_t i = 0; i < sb.inode_table_blocks; i++) {\n        memset(block_buf, 0, BLOCK_SIZE);\n        if (write_block(fd, sb.inode_table_start + i, block_buf) != 0) {\n            close(fd);\n            return -1;\n        }\n    }\n    /* --- Step 7: Mark inode 1 as used in inode bitmap --- */\n    uint8_t inode_bmap[BLOCK_SIZE];\n    memset(inode_bmap, 0, BLOCK_SIZE);\n    bitmap_set(inode_bmap, 0);  /* bit 0 â†’ inode number 1 (1-based) */\n    if (write_block(fd, INODE_BITMAP_BLOCK, inode_bmap) != 0) {\n        close(fd);\n        return -1;\n    }\n    /* --- Step 8: Allocate a data block for root directory's entries --- */\n    /* Manually allocate block 0 of data blocks for root dir content */\n    uint8_t block_bmap[BLOCK_SIZE];\n    memset(block_bmap, 0, BLOCK_SIZE);\n    bitmap_set(block_bmap, 0);  /* first data block used by root dir */\n    if (write_block(fd, BLOCK_BITMAP_BLOCK, block_bmap) != 0) {\n        close(fd);\n        return -1;\n    }\n    uint32_t root_data_block = sb.data_block_start;  /* data block index 0 */\n    /* --- Step 9: Create root directory inode --- */\n    inode_t root_inode;\n    memset(&root_inode, 0, sizeof(root_inode));\n    root_inode.mode    = DEFAULT_DIR_MODE;\n    root_inode.nlinks  = 2;      /* '.' and the reference from parent (itself) */\n    root_inode.size    = BLOCK_SIZE;\n    root_inode.blocks[0] = root_data_block;\n    uint32_t now = (uint32_t)time(NULL);\n    root_inode.atime = root_inode.mtime = root_inode.ctime = now;\n    if (write_inode(fd, &sb, sb.root_inode, &root_inode) != 0) {\n        close(fd);\n        return -1;\n    }\n    /* --- Step 10: Write '.' and '..' entries into root's data block --- */\n    uint8_t dir_block[BLOCK_SIZE];\n    memset(dir_block, 0, BLOCK_SIZE);\n    /* Entry for '.' â€” points to root inode itself */\n    dirent_t *dot = (dirent_t *)dir_block;\n    dot->inode_num  = sb.root_inode;\n    dot->name_len   = 1;\n    dot->file_type  = 2;  /* directory */\n    dot->rec_len    = sizeof(dirent_t);\n    memcpy(dot->name, \".\", 1);\n    /* Entry for '..' â€” root's parent is also root */\n    dirent_t *dotdot = (dirent_t *)(dir_block + sizeof(dirent_t));\n    dotdot->inode_num = sb.root_inode;\n    dotdot->name_len  = 2;\n    dotdot->file_type = 2;\n    dotdot->rec_len   = sizeof(dirent_t);\n    memcpy(dotdot->name, \"..\", 2);\n    if (write_block(fd, root_data_block, dir_block) != 0) {\n        close(fd);\n        return -1;\n    }\n    /* --- Step 11: Persist the updated superblock (free counts changed) --- */\n    sb.free_blocks--;  /* one data block used by root dir */\n    sb.free_inodes--;  /* inode 1 used by root dir */\n    memset(block_buf, 0, BLOCK_SIZE);\n    memcpy(block_buf, &sb, sizeof(sb));\n    if (write_block(fd, 0, block_buf) != 0) {\n        close(fd);\n        return -1;\n    }\n    printf(\"mkfs: created %s (%u blocks, %u inodes)\\n\",\n           image_path, total_blocks, total_inodes);\n    printf(\"  Superblock at block 0\\n\");\n    printf(\"  Block bitmap at block %u\\n\", BLOCK_BITMAP_BLOCK);\n    printf(\"  Inode bitmap at block %u\\n\", INODE_BITMAP_BLOCK);\n    printf(\"  Inode table: blocks %uâ€“%u (%u blocks)\\n\",\n           sb.inode_table_start,\n           sb.inode_table_start + sb.inode_table_blocks - 1,\n           sb.inode_table_blocks);\n    printf(\"  Journal: blocks %uâ€“%u\\n\",\n           sb.journal_start,\n           sb.journal_start + sb.journal_blocks - 1);\n    printf(\"  Data blocks: %uâ€“%u (%u available)\\n\",\n           sb.data_block_start, total_blocks - 1,\n           sb.free_blocks);\n    close(fd);\n    return 0;\n}\nint main(int argc, char *argv[]) {\n    if (argc != 4) {\n        fprintf(stderr, \"Usage: mkfs <image> <total_blocks> <total_inodes>\\n\");\n        fprintf(stderr, \"  Example: mkfs disk.img 4096 1024\\n\");\n        return 1;\n    }\n    uint32_t total_blocks = (uint32_t)atoi(argv[2]);\n    uint32_t total_inodes = (uint32_t)atoi(argv[3]);\n    return mkfs(argv[1], total_blocks, total_inodes) == 0 ? 0 : 1;\n}\n```\n---\n## Verification: Reading Back What You Wrote\nAfter `mkfs` runs, write a simple verification function that reads the image back and validates every invariant:\n```c\nint verify_filesystem(const char *image_path) {\n    int fd = open(image_path, O_RDONLY);\n    if (fd < 0) { perror(\"open\"); return -1; }\n    /* Read and validate superblock */\n    uint8_t buf[BLOCK_SIZE];\n    read_block(fd, 0, buf);\n    superblock_t *sb = (superblock_t *)buf;\n    if (sb->magic != FS_MAGIC) {\n        fprintf(stderr, \"FAIL: bad magic number 0x%08X\\n\", sb->magic);\n        close(fd); return -1;\n    }\n    printf(\"OK: magic number 0x%08X\\n\", sb->magic);\n    printf(\"OK: %u total blocks, %u total inodes\\n\",\n           sb->total_blocks, sb->total_inodes);\n    printf(\"OK: data blocks start at block %u\\n\", sb->data_block_start);\n    /* Verify root inode exists and is a directory */\n    uint32_t root_ino = sb->root_inode;\n    uint32_t idx          = root_ino - 1;\n    uint32_t block_num    = sb->inode_table_start + idx / INODES_PER_BLOCK;\n    uint32_t slot         = idx % INODES_PER_BLOCK;\n    read_block(fd, block_num, buf);\n    inode_t *root = (inode_t *)(buf + slot * INODE_SIZE);\n    if ((root->mode & S_IFDIR) == 0) {\n        fprintf(stderr, \"FAIL: root inode is not a directory\\n\");\n        close(fd); return -1;\n    }\n    if (root->nlinks != 2) {\n        fprintf(stderr, \"FAIL: root nlinks = %u, expected 2\\n\", root->nlinks);\n        close(fd); return -1;\n    }\n    printf(\"OK: root inode %u is a directory with nlinks=%u\\n\",\n           root_ino, root->nlinks);\n    /* Verify inode bitmap marks root inode as used */\n    read_block(fd, INODE_BITMAP_BLOCK, buf);\n    if (!bitmap_test(buf, root_ino - 1)) {\n        fprintf(stderr, \"FAIL: root inode not marked used in bitmap\\n\");\n        close(fd); return -1;\n    }\n    printf(\"OK: root inode bit set in inode bitmap\\n\");\n    /* Read root directory's data block, find '.' entry */\n    read_block(fd, root->blocks[0], buf);\n    dirent_t *dot = (dirent_t *)buf;\n    if (dot->inode_num != root_ino || dot->name[0] != '.') {\n        fprintf(stderr, \"FAIL: first entry in root is not '.'\\n\");\n        close(fd); return -1;\n    }\n    printf(\"OK: root directory has '.' â†’ inode %u\\n\", dot->inode_num);\n    close(fd);\n    printf(\"Filesystem image: VERIFIED\\n\");\n    return 0;\n}\n```\nRun this immediately after `mkfs`. If it passes, every piece of data you wrote survives a round-trip to disk and back â€” the most basic contract of a storage system.\n---\n## Three-Level View: What Happens When `write_block` Executes\nLet's trace what actually happens when your code calls `write_block(fd, 1, bitmap)` â€” writing the block bitmap to disk.\n| Level | What Happens |\n|---|---|\n| **Application (your code)** | Calls `write(fd, buf, 4096)` via your `write_block` wrapper. Control transfers to the kernel via a syscall interrupt. |\n| **OS / Kernel** | The VFS layer receives the write. The kernel allocates a 4KB page in the **page cache** (kernel memory) and copies your `buf` there. The page is now \"dirty.\" The kernel may not write to disk immediately â€” it batches writes for efficiency. The `write` syscall returns as soon as the data is in the page cache. |\n| **Hardware** | Eventually (on `fsync`, or when the kernel decides to flush), the block I/O scheduler submits a write request to the disk driver. The disk DMA controller transfers the 4KB from kernel memory to the disk's write buffer. The disk confirms completion. The page cache page is marked clean. |\n> **The subtle danger**: When `write_block` returns `0`, your data is in the kernel page cache â€” not necessarily on disk. A power loss between the `write` call and the disk flush loses your data. Later in this project (and in Milestone 6), you will use `fsync(fd)` to force the kernel to flush all dirty pages to disk before returning. For `mkfs`, call `fsync(fd)` before `close(fd)` to guarantee the freshly formatted image is actually on disk.\n```c\n/* Add this before close() in mkfs */\nif (fsync(fd) != 0) {\n    perror(\"fsync\");\n    /* non-fatal for mkfs in development, but fatal in production */\n}\n```\n---\n## Key Design Decisions\nThere are real choices to make at this layer. Here are the most impactful:\n**Fixed inode count vs. dynamic inode allocation**\n| Option | Pros | Cons | Used By |\n|---|---|---|---|\n| **Fixed count at mkfs time (chosen âœ“)** | Simple bitmap; O(1) allocation; layout fully known at format time | Running out of inodes with space remaining (classic ext2/ext3 problem on mail servers) | ext2, ext3, your implementation |\n| Dynamic inode allocation | Inodes grow as needed; no `df -i` exhaustion | Complex; requires indirect structures for inode lookup | XFS, ext4 (flexible block groups) |\n**Bitmap per region vs. free list**\n| Option | Pros | Cons | Used By |\n|---|---|---|---|\n| **Bitmap (chosen âœ“)** | Compact; crash-recoverable (rebuild from inodes); sequential scan | O(n) scan for allocation; fragmentation over time | ext2/3/4, most simple filesystems |\n| Free list / extent list | O(1) allocation; naturally tracks contiguous free regions | Requires careful crash recovery; complexity | XFS (B-tree free space), NTFS |\n**Block size: 4KB vs. alternatives**\n4KB is the dominant choice because it matches the virtual memory page size on x86-64 (and ARM). This means: block-aligned I/O never triggers partial-page reads; memory-mapped files (`mmap`) map naturally; the OS page cache handles blocks without padding. Larger blocks (8KB, 16KB) reduce metadata overhead for large files but waste space for small files (a 1-byte file consumes an entire 8KB block). Smaller blocks (1KB, 2KB) reduce internal fragmentation but require more metadata to track the same data.\n---\n## Knowledge Cascade: One Concept, Ten Connections\nYou just built a block allocator backed by a bitmap that sits on top of a flat address space of fixed-size chunks. This is not a filesystem-specific idea. It is one of the fundamental patterns of systems programming:\n**â†’ Database Page Management**\nPostgreSQL, SQLite, and MySQL all store data in \"pages\" â€” fixed-size blocks (8KB in Postgres, 4KB in SQLite by default). Their internal page managers maintain a freelist or bitmap of free pages. The \"heap file\" in Postgres is literally a sequence of 8KB pages, with a \"free space map\" (FSM) tracking available space per page. Your superblock is Postgres's `pg_control` file. Your bitmap is the FSM. Building a filesystem gives you the mental model to read database internals with clarity.\n**â†’ The SSD Flash Translation Layer (FTL)**\nWhen you call `write_block(fd, 500, buf)`, you are writing to logical block 500. But inside your SSD, logical block 500 does not map to a fixed physical NAND page. The FTL maintains its own mapping table (logical-to-physical, LPT), performs wear leveling (distributing writes evenly across cells), and manages its own garbage collection when pages need to be erased. Your filesystem sits on top of a block abstraction that is itself implemented by another system with its own block abstraction. Indirection all the way down.\n**â†’ Memory Allocators (jemalloc, tcmalloc, mimalloc)**\n`malloc()` faces the same problem from a different angle: carve variable-size allocations from fixed-size OS pages (4KB). jemalloc's slab allocator tracks free slots within a page using... a bitmap. Each `jemalloc` \"run\" is a region of pages dedicated to a specific allocation size class, with a bitmap marking which slots are occupied. Your `bitmap_find_free` and `bitmap_set` are functionally identical to what jemalloc executes on every `malloc`. The problem is universal; the solution is the same.\n**â†’ Virtual Memory and Physical Frame Allocation**\nThe Linux kernel maintains a \"buddy allocator\" for physical memory pages, with bitmaps at each order level tracking which frames are free. When your process calls `mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_ANONYMOUS, -1, 0)`, the kernel runs a bitmap scan nearly identical to your `bitmap_find_free`, then marks the physical frame allocated, and records the mapping in your process's page table. Your filesystem's block allocator is the on-disk analogue of the kernel's physical frame allocator.\n**â†’ Disk Image Forensics**\nYou now understand on-disk layout precisely enough to examine a raw disk image with `hexdump -C disk.img | head -100` and identify the magic number at offset 0, the total block count at offset 12, and the free block count at offset 20. Forensic tools like `Autopsy`, `The Sleuth Kit`, and `foremost` work by reading raw disk images and interpreting known filesystem structures at known byte offsets â€” exactly what your `verify_filesystem` function does. With the knowledge from this milestone, you can recover files from a \"deleted\" (but not overwritten) partition by finding inodes in the inode table and following their block pointers.\n**â†’ RAID and Storage Systems**\nRAID controllers manage arrays of physical blocks with their own parity metadata. A RAID-5 controller maintains a \"stripe map\" tracking which data blocks correspond to which parity blocks â€” another form of block-level metadata management. The same free/used tracking problem appears at every storage abstraction layer.\n---\n## Before You Move On: Pitfall Checklist\nRun through this checklist before calling Milestone 1 complete:\n- [ ] **Magic number validation**: does your mount code refuse images with a bad magic number?\n- [ ] **Block 0 protection**: can you accidentally allocate block 0 (the superblock) as a data block? Add a guard: `assert(alloc_block(...) >= sb->data_block_start)`.\n- [ ] **Bitmap index vs. disk block number**: are you consistently converting between \"data block index\" (0-based offset into data region) and \"disk block number\" (absolute block address)?\n- [ ] **`fsync` on mkfs exit**: is your freshly formatted image actually on disk or still in the page cache?\n- [ ] **`__attribute__((packed))` on all disk structs**: did you verify `sizeof(superblock_t) == BLOCK_SIZE` with `_Static_assert`?\n- [ ] **Root inode link count = 2**: `.` and `..` each count as one hard link. This is a filesystem invariant that tools like `fsck` check.\n- [ ] **Superblock free count accuracy**: after `mkfs`, `sb.free_blocks` must equal `total_blocks - data_block_start - 1` (one block used by root directory data). Off-by-one here causes cascading errors in Milestone 2.\n---\n## What You've Built and What Comes Next\n\n![Filesystem Atlas â€” Satellite Map (Home Base)](./diagrams/diag-L0-satellite-map.svg)\n\nYou started with nothing. A flat file. You gave it a grammar: block 0 is the superblock, blocks 1 and 2 are bitmaps, then the inode table, then the journal, then data. You built tools to allocate and free blocks and inodes with one-bit precision. You formatted a raw image into a valid filesystem with a root directory.\nBut look at what the root directory actually contains right now: two entries (`.` and `..`) sitting in one data block. The \"inode\" for the root directory contains a block pointer to that data block. The \"inode\" has a size, a mode, and a link count â€” but those fields are barely populated. In Milestone 2, you build the full inode structure: the direct and indirect block pointer tree that lets a single inode track a file from 1 byte to several gigabytes. That's where the on-disk layout stops being about *where* things live, and starts being about *how much* they can grow.\nThe disk doesn't know you exist. But now you know how to make it remember anything you want.\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: filesystem-m2 -->\n<!-- MS_ID: filesystem-m2 -->\n# Milestone 2: Inode Management\n## A File Is Not Its Name, Not Its Data, Not Its Location\nYou have used files your entire programming career. You have opened them, read them, written to them, deleted them. You have a mental model â€” reasonable, intuitive, and almost entirely wrong about what is actually happening on disk.\nHere is the model most developers carry: a file is a named container. The name tells you where it is. The contents are stored somewhere nearby. The file \"has\" its data the way a folder holds documents.\nNow consider this: you can have two names for the same file (hard links), and deleting one name does not delete the file. You can have a file that is 10 gigabytes according to `ls -l` but occupies only 4 kilobytes on disk. You can rename a file without moving a single byte of its data. You can have a file with no name at all, still open, still readable, living in limbo between deletion and the last `close()`.\nNone of this makes sense under the \"file is a named container\" model. It makes perfect sense once you understand the inode.\nThe fundamental design of Unix-derived filesystems separates three things that seem inseparable:\n1. **The name** â€” lives in a directory entry. Just a string pointing to an inode number.\n2. **The metadata** â€” lives in the inode. Size, permissions, timestamps, owner, block pointers.\n3. **The data** â€” lives in data blocks. The inode points to them; they do not know they belong to any file.\nThe inode is the **identity** of a file. Names come and go. Data blocks are allocated and freed. The inode is the fixed center around which everything else orbits. This milestone, you build the inode â€” 128 bytes of metadata that can describe a file from 0 bytes to several gigabytes.\n\n![Inode Structure â€” Complete Byte Layout](./diagrams/diag-m2-inode-struct.svg)\n\n---\n## The Fundamental Tension: Fixed Metadata, Variable Data\nHere is the physical constraint that makes this design challenging:\n**The inode must be fixed-size. The files it describes have variable size.**\nAn inode occupies exactly 128 bytes in the inode table (or 256 bytes in ext4, but always fixed). This size cannot change after the filesystem is formatted. Yet a text file might be 47 bytes, while a disk image might be 40 gigabytes. The same inode structure must represent both.\nIf you tried to embed the block pointer list directly in the inode scaled to the file size, you would need variable-size inodes â€” which makes the inode table impossible to index directly (you cannot do `inode_table_block + inode_num * sizeof(inode_t)` if inodes have different sizes). You would need a separate map of inode locations, which is just pushing the indirection one level up.\nThe solution is **indirection**. For small files, the inode contains direct pointers to data blocks â€” fast, simple, no extra I/O. For medium files, the inode contains a pointer to a *block full of pointers* â€” one extra disk read, many more blocks reachable. For large files, the inode contains a pointer to a *block full of pointers to blocks full of pointers* â€” two extra disk reads, files up to several gigabytes.\nThis is the key insight to internalize before you write a single line of code: **the inode does not contain data. The inode contains a tree of pointers to data.** The tree has a fixed root (the inode fields), but it can grow additional levels as the file grows.\nLet's build it.\n---\n## The Inode Structure: 128 Bytes That Describe a Universe\nEvery field in the inode exists for a specific operational reason. There is no dead weight here â€” this is 128 bytes under tight space pressure.\n[[EXPLAIN:on-disk-serialization-â€”-packing-structs-to-exact-byte-layouts-with-fixed-width-types|On-disk serialization â€” packing structs to exact byte layouts with fixed-width types]]\n```c\n#include <stdint.h>\n#include <time.h>\n#define BLOCK_SIZE          4096\n#define INODE_SIZE          128\n#define INODES_PER_BLOCK    (BLOCK_SIZE / INODE_SIZE)   /* 32 */\n#define N_DIRECT            12     /* number of direct block pointers */\n/*\n * Inode structure â€” always exactly 128 bytes on disk.\n *\n * BYTE LAYOUT (all fields little-endian, packed):\n *   Offset  0: mode           (2 bytes) â€” file type + permissions\n *   Offset  2: uid            (2 bytes) â€” owner user ID\n *   Offset  4: gid            (2 bytes) â€” owner group ID\n *   Offset  6: nlinks         (2 bytes) â€” hard link count\n *   Offset  8: size           (4 bytes) â€” file size in bytes\n *   Offset 12: atime          (4 bytes) â€” last access time (Unix timestamp)\n *   Offset 16: mtime          (4 bytes) â€” last modification time\n *   Offset 20: ctime          (4 bytes) â€” last metadata change time\n *   Offset 24: blocks[0..11]  (48 bytes) â€” 12 direct block pointers\n *   Offset 72: single_indirect (4 bytes)\n *   Offset 76: double_indirect (4 bytes)\n *   Offset 80: reserved       (48 bytes) â€” pad to 128 bytes\n *   Total: 128 bytes exactly\n */\ntypedef struct __attribute__((packed)) {\n    uint16_t mode;                  /* file type bits + permission bits */\n    uint16_t uid;                   /* owner UID */\n    uint16_t gid;                   /* owner GID */\n    uint16_t nlinks;                /* hard link count; free inode when this hits 0 */\n    uint32_t size;                  /* file size in bytes (logical, not disk usage) */\n    uint32_t atime;                 /* last access time */\n    uint32_t mtime;                 /* last data modification time */\n    uint32_t ctime;                 /* last inode change time (chmod, chown, link) */\n    uint32_t blocks[N_DIRECT];     /* direct block pointers: blocks[0] is file offset 0 */\n    uint32_t single_indirect;       /* points to a block containing 1024 block pointers */\n    uint32_t double_indirect;       /* points to a block of single-indirect pointers */\n    uint8_t  reserved[48];          /* future use; must be zeroed */\n} inode_t;\n_Static_assert(sizeof(inode_t) == INODE_SIZE,\n               \"inode_t must be exactly 128 bytes\");\n```\nLet's examine each field's purpose carefully:\n**`mode` (2 bytes)**: This single 16-bit field encodes two things at once. The high bits identify the *file type* (regular file, directory, symbolic link, device, etc.). The low 12 bits encode *permissions* (read/write/execute for owner, group, and others â€” the familiar `rwxr-xr-x` pattern). The POSIX standard defines these bit positions:\n```c\n/* File type bits (high 4 bits of mode, shifted into bits 12-15) */\n#define S_IFMT   0170000  /* mask for file type bits */\n#define S_IFREG  0100000  /* regular file */\n#define S_IFDIR  0040000  /* directory */\n#define S_IFLNK  0120000  /* symbolic link */\n#define S_IFBLK  0060000  /* block device */\n#define S_IFCHR  0020000  /* character device */\n#define S_IFIFO  0010000  /* named pipe (FIFO) */\n/* Permission bits (low 9 bits) */\n#define S_IRUSR  0400     /* owner read */\n#define S_IWUSR  0200     /* owner write */\n#define S_IXUSR  0100     /* owner execute */\n#define S_IRGRP  0040     /* group read */\n#define S_IROTH  0004     /* others read */\n/* ... etc. */\n/* Helper macros to test file type */\n#define S_ISDIR(m)  (((m) & S_IFMT) == S_IFDIR)\n#define S_ISREG(m)  (((m) & S_IFMT) == S_IFREG)\n```\nA regular file with `rwxr-xr-x` permissions: `mode = 0100755` (octal). A directory with `rwxr-xr-x`: `mode = 0040755`.\n**`nlinks` (2 bytes)**: The hard link count. Every directory entry pointing to this inode increments this counter. When you `rm` a file, the directory entry is removed and `nlinks` decrements. Only when `nlinks` hits 0 *and* no process has the file open should the inode be freed. This is reference counting â€” the same principle used by C++'s `shared_ptr` and Rust's `Arc`. The inode is the shared resource; directory entries are the shared references.\n**`size` (4 bytes)**: The *logical* file size in bytes. This is what `ls -l` shows you. It is **not** the amount of disk space the file consumes. A sparse file with 1 byte written at offset 999,999,999 has `size = 1,000,000,000` but allocates only 2 data blocks (8KB). The relationship between `size` and actual disk usage is the heart of sparse files, discussed below.\n**`atime`, `mtime`, `ctime` (4 bytes each)**: Unix timestamps (seconds since January 1, 1970). \n- `atime` updates on every read (often disabled in modern Linux with `noatime` mount option for performance â€” every read causing a write is expensive)\n- `mtime` updates when file *data* changes\n- `ctime` updates when the inode *metadata* changes (permissions, link count, owner) â€” note: `ctime` is NOT \"creation time\"; Unix has no native creation time field in the traditional inode\n**`blocks[N_DIRECT]` (48 bytes)**: Twelve `uint32_t` values. Each is a disk block number, or zero if that block is not allocated. `blocks[0]` contains the data starting at file offset 0. `blocks[1]` contains the data at file offset 4096. `blocks[11]` contains data at offset 45,056. Together they address the first 48KB of any file.\n**`single_indirect` (4 bytes)**: A pointer to an *indirect block* â€” a 4KB block whose entire contents are an array of `uint32_t` block pointers. Each pointer in that indirect block points to a data block. A 4KB indirect block holds `4096 / 4 = 1024` pointers. So the single-indirect pointer can reach an additional `1024 Ã— 4KB = 4MB` of file data.\n**`double_indirect` (4 bytes)**: A pointer to a block containing 1024 *single-indirect block pointers*. Each of those points to a block with 1024 data block pointers. Total capacity: `1024 Ã— 1024 Ã— 4KB = 4GB`.\n\n![Inode Block Pointer Tree â€” Direct, Single-Indirect, Double-Indirect](./diagrams/diag-m2-pointer-tree.svg)\n\n> **Why stop at double-indirect?** Most filesystems add a triple-indirect pointer for files up to 4TB. For this project, double-indirect gives you 4GB+ files which is sufficient. ext2/ext3 use triple-indirect. ext4 abandoned this entire scheme in favor of \"extents\" â€” contiguous run-length encoded block ranges â€” which are far more efficient for large sequential files. We'll note where extents fit in the knowledge cascade.\n---\n## Reading and Writing Inodes: The Inode Table\nMilestone 1 established that inodes live in the inode table â€” a contiguous region of blocks starting at `sb->inode_table_start`. With 32 inodes per block (`INODES_PER_BLOCK`), inode number `N` lives in:\n```\nblock  = inode_table_start + (N - 1) / INODES_PER_BLOCK\noffset = ((N - 1) % INODES_PER_BLOCK) * INODE_SIZE\n```\nThe `N - 1` converts from 1-based inode numbers (inode 0 is reserved/invalid) to 0-based array indices.\n```c\n/*\n * Read inode from disk.\n * inode_num: 1-based inode number (must be >= 1 and <= total_inodes)\n * out: caller-allocated inode_t to populate\n * Returns 0 on success, negative errno on failure.\n */\nint read_inode(int fd, const superblock_t *sb,\n               uint32_t inode_num, inode_t *out) {\n    if (inode_num == 0 || inode_num > sb->total_inodes) {\n        return -EINVAL;\n    }\n    uint32_t idx           = inode_num - 1;\n    uint32_t block_num     = sb->inode_table_start + idx / INODES_PER_BLOCK;\n    uint32_t slot_in_block = idx % INODES_PER_BLOCK;\n    uint8_t buf[BLOCK_SIZE];\n    int ret = read_block(fd, block_num, buf);\n    if (ret != 0) return ret;\n    memcpy(out, buf + slot_in_block * INODE_SIZE, INODE_SIZE);\n    return 0;\n}\n/*\n * Write inode to disk.\n * This is a read-modify-write: we read the block, update one inode slot,\n * then write the whole block back. We cannot write just the 128-byte inode\n * because the block device only supports full-block writes.\n */\nint write_inode(int fd, const superblock_t *sb,\n                uint32_t inode_num, const inode_t *inode) {\n    if (inode_num == 0 || inode_num > sb->total_inodes) {\n        return -EINVAL;\n    }\n    uint32_t idx           = inode_num - 1;\n    uint32_t block_num     = sb->inode_table_start + idx / INODES_PER_BLOCK;\n    uint32_t slot_in_block = idx % INODES_PER_BLOCK;\n    uint8_t buf[BLOCK_SIZE];\n    int ret = read_block(fd, block_num, buf);\n    if (ret != 0) return ret;\n    memcpy(buf + slot_in_block * INODE_SIZE, inode, INODE_SIZE);\n    return write_block(fd, block_num, buf);\n}\n```\n> **Hardware Soul â€” Read-Modify-Write on Inode Updates**: Every `write_inode` call is actually a read-modify-write cycle. You read 4096 bytes (one block containing 32 inodes), modify 128 bytes in memory, then write 4096 bytes back. This means every inode update costs 2 disk I/Os instead of 1. Real filesystems address this through a page cache: the block is likely already in RAM from a recent read, so the \"read\" is a cache hit at ~100ns. Only the write hits disk. But the write-amplification factor of 32Ã— (writing 4096 bytes to modify 128) is real and unavoidable at the block device level. This is one reason ext4 packs multiple inode modifications into a single transaction.\n---\n## Inode Allocation and Deallocation\nAllocating an inode follows the same bitmap pattern as block allocation from Milestone 1:\n```c\n#define INODE_BITMAP_BLOCK  2\n/*\n * Allocate a new inode.\n * Returns the inode number (1-based) on success, -1 if none free.\n * The caller is responsible for initializing and writing the inode.\n */\nint alloc_inode(int fd, superblock_t *sb) {\n    if (sb->free_inodes == 0) return -1;\n    uint8_t bitmap[BLOCK_SIZE];\n    if (read_block(fd, INODE_BITMAP_BLOCK, bitmap) != 0) return -1;\n    /* Find first free bit (0 = free) */\n    uint32_t total_inodes = sb->total_inodes;\n    for (uint32_t byte_idx = 0; byte_idx < (total_inodes + 7) / 8; byte_idx++) {\n        if (bitmap[byte_idx] == 0xFF) continue;\n        for (int bit = 0; bit < 8; bit++) {\n            uint32_t idx = byte_idx * 8 + bit;\n            if (idx >= total_inodes) return -1;\n            if (!((bitmap[byte_idx] >> bit) & 1)) {\n                /* Found free inode */\n                bitmap[byte_idx] |= (1u << bit);\n                if (write_block(fd, INODE_BITMAP_BLOCK, bitmap) != 0) return -1;\n                sb->free_inodes--;\n                return (int)(idx + 1);   /* convert 0-based index â†’ 1-based number */\n            }\n        }\n    }\n    return -1;\n}\n```\nDeallocation is where the real complexity lives. To free an inode, you must:\n1. Free all **direct** data blocks (up to 12)\n2. If `single_indirect != 0`: read that block, free all non-zero block pointers within it, then free the indirect block itself\n3. If `double_indirect != 0`: read that block, for each non-zero entry (which is itself a single-indirect block), read that block, free all its data block pointers, free the single-indirect block, then free the double-indirect block\n4. Clear the inode in the inode table (zero it out)\n5. Clear the inode's bit in the inode bitmap\nSteps 2 and 3 describe **recursive block freeing** â€” following the pointer tree to its leaves and freeing bottom-up. Missing this is the most common bug in inode implementations: you free the data blocks and the inode, but orphan the indirect pointer blocks, permanently leaking them until a `fsck` scan.\n\n![Inode Deallocation â€” Recursive Block Freeing](./diagrams/diag-m2-inode-deallocation.svg)\n\n```c\n/*\n * Free a single data block by its disk block number.\n * Clears the bit in the block bitmap and updates sb->free_blocks.\n */\nstatic int free_data_block(int fd, superblock_t *sb, uint32_t disk_block_num) {\n    if (disk_block_num == 0) return 0;    /* null pointer â€” nothing to free */\n    if (disk_block_num < sb->data_block_start ||\n        disk_block_num >= sb->total_blocks) {\n        return -EINVAL;   /* never free metadata blocks */\n    }\n    uint8_t bitmap[BLOCK_SIZE];\n    if (read_block(fd, BLOCK_BITMAP_BLOCK, bitmap) != 0) return -EIO;\n    uint32_t data_idx = disk_block_num - sb->data_block_start;\n    bitmap[data_idx / 8] &= ~(1u << (data_idx % 8));\n    if (write_block(fd, BLOCK_BITMAP_BLOCK, bitmap) != 0) return -EIO;\n    sb->free_blocks++;\n    return 0;\n}\n/*\n * Free all blocks pointed to by a single-indirect block,\n * then free the indirect block itself.\n *\n * indirect_block_num: disk block number of the single-indirect block.\n *                     If 0, this is a null pointer (sparse region) â€” do nothing.\n */\nstatic int free_single_indirect(int fd, superblock_t *sb,\n                                uint32_t indirect_block_num) {\n    if (indirect_block_num == 0) return 0;\n    uint8_t buf[BLOCK_SIZE];\n    if (read_block(fd, indirect_block_num, buf) != 0) return -EIO;\n    /* The indirect block contains 1024 uint32_t block pointers */\n    uint32_t *ptrs = (uint32_t *)buf;\n    uint32_t ptrs_per_block = BLOCK_SIZE / sizeof(uint32_t);  /* 1024 */\n    for (uint32_t i = 0; i < ptrs_per_block; i++) {\n        if (ptrs[i] != 0) {\n            free_data_block(fd, sb, ptrs[i]);\n        }\n    }\n    /* Now free the indirect block itself */\n    return free_data_block(fd, sb, indirect_block_num);\n}\n/*\n * Free all blocks reachable through a double-indirect block,\n * then free the double-indirect block itself.\n */\nstatic int free_double_indirect(int fd, superblock_t *sb,\n                                uint32_t dindirect_block_num) {\n    if (dindirect_block_num == 0) return 0;\n    uint8_t buf[BLOCK_SIZE];\n    if (read_block(fd, dindirect_block_num, buf) != 0) return -EIO;\n    uint32_t *ptrs = (uint32_t *)buf;\n    uint32_t ptrs_per_block = BLOCK_SIZE / sizeof(uint32_t);\n    for (uint32_t i = 0; i < ptrs_per_block; i++) {\n        if (ptrs[i] != 0) {\n            /* Each entry here is itself a single-indirect block */\n            free_single_indirect(fd, sb, ptrs[i]);\n        }\n    }\n    return free_data_block(fd, sb, dindirect_block_num);\n}\n/*\n * Free an inode and all its associated data blocks.\n * After this call, inode_num may be reallocated to a new file.\n */\nint free_inode(int fd, superblock_t *sb, uint32_t inode_num) {\n    inode_t inode;\n    if (read_inode(fd, sb, inode_num, &inode) != 0) return -EIO;\n    /* Step 1: Free all direct data blocks */\n    for (int i = 0; i < N_DIRECT; i++) {\n        if (inode.blocks[i] != 0) {\n            free_data_block(fd, sb, inode.blocks[i]);\n        }\n    }\n    /* Step 2: Free single-indirect chain */\n    free_single_indirect(fd, sb, inode.single_indirect);\n    /* Step 3: Free double-indirect chain */\n    free_double_indirect(fd, sb, inode.double_indirect);\n    /* Step 4: Zero the inode in the table */\n    inode_t zeroed;\n    memset(&zeroed, 0, sizeof(zeroed));\n    if (write_inode(fd, sb, inode_num, &zeroed) != 0) return -EIO;\n    /* Step 5: Clear inode bitmap bit */\n    uint8_t bitmap[BLOCK_SIZE];\n    if (read_block(fd, INODE_BITMAP_BLOCK, bitmap) != 0) return -EIO;\n    uint32_t idx = inode_num - 1;\n    bitmap[idx / 8] &= ~(1u << (idx % 8));\n    if (write_block(fd, INODE_BITMAP_BLOCK, bitmap) != 0) return -EIO;\n    sb->free_inodes++;\n    return 0;\n}\n```\n> **Pitfall â€” Bitmap Load on Every Block Free**: The `free_data_block` function above reads and writes the bitmap for every single block freed. Freeing an inode with 12 direct blocks + 1024 indirect blocks = 1036 blocks freed = 2072 bitmap I/Os. This is acceptable for correctness but catastrophically slow for production. Real implementations load the bitmap once, clear all bits in memory, then write it back once. For now, correctness first. When you integrate with Milestone 6 journaling, you will batch these operations anyway.\n---\n## The Block Pointer Tree: File Offset to Disk Block\nThe most important operation on an inode â€” used by every read and write â€” is **translating a file offset to a disk block number**. Given \"byte offset 150,000 in this file, which disk block is it in?\", the function must navigate the pointer tree.\n\n![File Offset â†’ Block Number Translation](./diagrams/diag-m2-offset-to-block.svg)\n\nLet's work through the math first, then implement it:\n```\nFile offset 0 to 49,151:\n  Block index 0â€“11 â†’ inode.blocks[0] through inode.blocks[11]\n  (12 direct blocks Ã— 4096 bytes = 49,152 bytes)\nFile offset 49,152 to 4,243,455:\n  Block index 12 to 1035 â†’ single-indirect region\n  (1024 blocks Ã— 4096 = 4,194,304 bytes = 4MB)\n  To find block at file offset X in single-indirect range:\n    single_idx = (X / BLOCK_SIZE) - N_DIRECT\n    read inode.single_indirect block\n    return ptrs[single_idx]\nFile offset 4,243,456 and beyond:\n  Block index 1036 and beyond â†’ double-indirect region\n  block_index = X / BLOCK_SIZE\n  dbl_idx = block_index - N_DIRECT - PTRS_PER_BLOCK   /* offset into double-indirect */\n  outer = dbl_idx / PTRS_PER_BLOCK   /* which single-indirect block within the double */\n  inner = dbl_idx % PTRS_PER_BLOCK   /* which data block within that single-indirect */\n  read inode.double_indirect block â†’ get ptrs[outer] (a single-indirect block)\n  read ptrs[outer] block â†’ get ptrs[inner] (the data block)\n```\n```c\n#define PTRS_PER_BLOCK      (BLOCK_SIZE / sizeof(uint32_t))    /* 1024 */\n#define DIRECT_LIMIT        ((uint64_t)N_DIRECT * BLOCK_SIZE)\n#define SINGLE_LIMIT        (DIRECT_LIMIT + (uint64_t)PTRS_PER_BLOCK * BLOCK_SIZE)\n#define DOUBLE_LIMIT        (SINGLE_LIMIT + (uint64_t)PTRS_PER_BLOCK * PTRS_PER_BLOCK * BLOCK_SIZE)\n/*\n * Translate a file byte offset to a disk block number.\n *\n * offset: byte offset within the file\n * inode:  the file's inode\n * out_block_num: set to the disk block number (0 if the block is a hole)\n *\n * Returns 0 on success, negative errno on I/O error.\n * Returns 0 with *out_block_num = 0 for sparse regions (valid, not an error).\n */\nint inode_get_block(int fd, const inode_t *inode,\n                    uint64_t offset, uint32_t *out_block_num) {\n    uint64_t block_index = offset / BLOCK_SIZE;\n    *out_block_num = 0;    /* default: hole / unallocated */\n    if (offset >= DOUBLE_LIMIT) {\n        return -EFBIG;    /* beyond our addressing capacity */\n    }\n    /* --- Direct region --- */\n    if (block_index < N_DIRECT) {\n        *out_block_num = inode->blocks[block_index];\n        return 0;\n    }\n    /* --- Single-indirect region --- */\n    if (block_index < N_DIRECT + PTRS_PER_BLOCK) {\n        if (inode->single_indirect == 0) {\n            *out_block_num = 0;    /* entire region is a hole */\n            return 0;\n        }\n        uint8_t buf[BLOCK_SIZE];\n        if (read_block(fd, inode->single_indirect, buf) != 0) return -EIO;\n        uint32_t *ptrs = (uint32_t *)buf;\n        uint32_t single_idx = (uint32_t)(block_index - N_DIRECT);\n        *out_block_num = ptrs[single_idx];\n        return 0;\n    }\n    /* --- Double-indirect region --- */\n    if (inode->double_indirect == 0) {\n        *out_block_num = 0;    /* entire double-indirect region is a hole */\n        return 0;\n    }\n    uint64_t dbl_offset = block_index - N_DIRECT - PTRS_PER_BLOCK;\n    uint32_t outer_idx  = (uint32_t)(dbl_offset / PTRS_PER_BLOCK);\n    uint32_t inner_idx  = (uint32_t)(dbl_offset % PTRS_PER_BLOCK);\n    /* Read double-indirect block â†’ get outer single-indirect block pointer */\n    uint8_t buf[BLOCK_SIZE];\n    if (read_block(fd, inode->double_indirect, buf) != 0) return -EIO;\n    uint32_t *outer_ptrs = (uint32_t *)buf;\n    uint32_t single_block = outer_ptrs[outer_idx];\n    if (single_block == 0) {\n        *out_block_num = 0;    /* this single-indirect slot is a hole */\n        return 0;\n    }\n    /* Read single-indirect block â†’ get data block pointer */\n    if (read_block(fd, single_block, buf) != 0) return -EIO;\n    uint32_t *inner_ptrs = (uint32_t *)buf;\n    *out_block_num = inner_ptrs[inner_idx];\n    return 0;\n}\n```\nThe corresponding \"set block\" operation â€” assigning a disk block number to a given file offset â€” is used by the write path in Milestone 4. It must create indirect and double-indirect blocks if they don't yet exist:\n```c\n/*\n * Set the disk block number for a given file offset.\n * If indirect blocks need to be created to hold the pointer, allocates them.\n *\n * Returns 0 on success, negative errno on failure.\n */\nint inode_set_block(int fd, superblock_t *sb, inode_t *inode,\n                    uint64_t offset, uint32_t disk_block_num) {\n    uint64_t block_index = offset / BLOCK_SIZE;\n    if (offset >= DOUBLE_LIMIT) return -EFBIG;\n    /* --- Direct region --- */\n    if (block_index < N_DIRECT) {\n        inode->blocks[block_index] = disk_block_num;\n        return 0;\n    }\n    /* --- Single-indirect region --- */\n    if (block_index < N_DIRECT + PTRS_PER_BLOCK) {\n        /* Allocate the indirect block if it doesn't exist yet */\n        if (inode->single_indirect == 0) {\n            int blk = alloc_block(fd, sb);\n            if (blk < 0) return -ENOSPC;\n            /* Zero the new indirect block */\n            uint8_t zeros[BLOCK_SIZE];\n            memset(zeros, 0, BLOCK_SIZE);\n            if (write_block(fd, (uint32_t)blk, zeros) != 0) return -EIO;\n            inode->single_indirect = (uint32_t)blk;\n        }\n        uint8_t buf[BLOCK_SIZE];\n        if (read_block(fd, inode->single_indirect, buf) != 0) return -EIO;\n        uint32_t *ptrs = (uint32_t *)buf;\n        uint32_t single_idx = (uint32_t)(block_index - N_DIRECT);\n        ptrs[single_idx] = disk_block_num;\n        return write_block(fd, inode->single_indirect, buf);\n    }\n    /* --- Double-indirect region --- */\n    uint64_t dbl_offset = block_index - N_DIRECT - PTRS_PER_BLOCK;\n    uint32_t outer_idx  = (uint32_t)(dbl_offset / PTRS_PER_BLOCK);\n    uint32_t inner_idx  = (uint32_t)(dbl_offset % PTRS_PER_BLOCK);\n    /* Allocate the double-indirect block if needed */\n    if (inode->double_indirect == 0) {\n        int blk = alloc_block(fd, sb);\n        if (blk < 0) return -ENOSPC;\n        uint8_t zeros[BLOCK_SIZE];\n        memset(zeros, 0, BLOCK_SIZE);\n        if (write_block(fd, (uint32_t)blk, zeros) != 0) return -EIO;\n        inode->double_indirect = (uint32_t)blk;\n    }\n    uint8_t buf[BLOCK_SIZE];\n    if (read_block(fd, inode->double_indirect, buf) != 0) return -EIO;\n    uint32_t *outer_ptrs  = (uint32_t *)buf;\n    uint32_t single_block = outer_ptrs[outer_idx];\n    /* Allocate the single-indirect block within the double-indirect if needed */\n    if (single_block == 0) {\n        int blk = alloc_block(fd, sb);\n        if (blk < 0) return -ENOSPC;\n        uint8_t zeros[BLOCK_SIZE];\n        memset(zeros, 0, BLOCK_SIZE);\n        if (write_block(fd, (uint32_t)blk, zeros) != 0) return -EIO;\n        outer_ptrs[outer_idx] = (uint32_t)blk;\n        single_block = (uint32_t)blk;\n        if (write_block(fd, inode->double_indirect, buf) != 0) return -EIO;\n    }\n    /* Now read the single-indirect block and set the data pointer */\n    if (read_block(fd, single_block, buf) != 0) return -EIO;\n    uint32_t *inner_ptrs = (uint32_t *)buf;\n    inner_ptrs[inner_idx] = disk_block_num;\n    return write_block(fd, single_block, buf);\n}\n```\n[[EXPLAIN:multi-level-indirection-â€”-pointer-to-pointer-to-data-pattern|Multi-level indirection â€” pointer-to-pointer-to-data pattern]]\n---\n## Sparse Files: When Nothing Is Something\nLook at `inode_get_block` again. Notice what happens when `block_index < N_DIRECT` and `inode->blocks[block_index] == 0`: you return `*out_block_num = 0` with no error. A zero block pointer means the block is **unallocated** â€” it is a *hole* in the file. When a read operation encounters a zero block pointer, it must return zero bytes without doing any disk I/O.\n\n![Sparse File â€” Null Pointers as Holes](./diagrams/diag-m2-sparse-file.svg)\n\nThis is how sparse files work. Consider:\n```c\nint create_sparse_file_example(int fd, superblock_t *sb, uint32_t inode_num) {\n    inode_t inode;\n    memset(&inode, 0, sizeof(inode));\n    inode.mode = S_IFREG | 0644;\n    inode.nlinks = 1;\n    /* Write one byte at offset 0 */\n    uint32_t block0 = (uint32_t)alloc_block(fd, sb);\n    uint8_t buf[BLOCK_SIZE];\n    memset(buf, 0, BLOCK_SIZE);\n    buf[0] = 'A';\n    write_block(fd, block0, buf);\n    inode.blocks[0] = block0;\n    /* Write one byte at offset 999,999,999 â€” deep in double-indirect range */\n    /* inode_set_block will allocate the indirect blocks as needed */\n    uint32_t blockN = (uint32_t)alloc_block(fd, sb);\n    memset(buf, 0, BLOCK_SIZE);\n    buf[999999999 % BLOCK_SIZE] = 'Z';\n    write_block(fd, blockN, buf);\n    inode_set_block(fd, sb, &inode, 999999999, blockN);\n    /* File size: 1,000,000,000 bytes */\n    inode.size = 1000000000;\n    /* But disk usage: 2 data blocks + ~2 indirect blocks = ~16KB */\n    write_inode(fd, sb, inode_num, &inode);\n    return 0;\n}\n```\nReading byte 500,000,000 (which is between the two written offsets) will encounter a null pointer and return a zero byte â€” no disk I/O for the hole. The file appears to be 1GB, but occupies almost no disk space.\nThis is why `ls -l` and `du` report different sizes:\n```\n$ ls -l vm_disk.img\n-rw-r--r-- 1 user user 10737418240 Mar 1 12:00 vm_disk.img   # 10GB\n$ du -sh vm_disk.img\n4.0K  vm_disk.img   # Only 4KB actually allocated\n```\n> **Three-Level View â€” Where Zero Bytes Come From**\n>\n> | Level | What Happens When You Read a Sparse Hole |\n> |-------|------------------------------------------|\n> | **Application** | Calls `read(fd, buf, len)`, expects data |\n> | **Filesystem** | `inode_get_block` returns 0 for the block pointer. Instead of calling `read_block`, the read handler calls `memset(buf, 0, BLOCK_SIZE)` â€” zero-fill in RAM |\n> | **Hardware** | No disk I/O at all. The zeros are generated entirely in CPU registers and copied to the output buffer. Reads from holes are **faster** than reads from allocated blocks |\n---\n## Timestamps: The Three Clocks\nEvery inode carries three timestamps, and getting them right matters â€” tools like `rsync`, `make`, and backup software depend on correct timestamp semantics.\n```c\n#include <time.h>\n/*\n * Update inode timestamps based on the operation performed.\n *\n * Note: In production, use clock_gettime(CLOCK_REALTIME) for\n * nanosecond precision. We use time() for simplicity.\n */\nstatic uint32_t now_ts(void) {\n    return (uint32_t)time(NULL);\n}\n/* Called when file data is read */\nvoid inode_touch_atime(inode_t *inode) {\n    inode->atime = now_ts();\n    /* Note: atime update requires a write_inode() call by the caller.\n     * This is why noatime is popular: every read causes a metadata write. */\n}\n/* Called when file data is written */\nvoid inode_touch_mtime(inode_t *inode) {\n    uint32_t ts = now_ts();\n    inode->mtime = ts;\n    inode->ctime = ts;   /* data change also changes inode */\n}\n/* Called when inode metadata changes (chmod, chown, link, rename) */\nvoid inode_touch_ctime(inode_t *inode) {\n    inode->ctime = now_ts();\n}\n```\nThe `ctime` field trips up developers who assume it means \"creation time.\" Unix filesystems traditionally have no creation time (some modern filesystems add `crtime` or `btime` as an extension). `ctime` is the \"inode change time\" â€” it updates whenever anything in the inode changes, including the link count, permissions, or owner. This means that `chmod` and `chown` update `ctime` but not `mtime`.\nThe `atime` update-on-every-read is one of the most notorious filesystem performance problems. A disk that serves mostly reads will perform writes for atime on every read â€” doubling I/O load on the inode block. Linux introduced the `relatime` mount option (update atime only if it's older than mtime/ctime) and `noatime` (never update atime). Your FUSE integration in Milestone 5 will expose this as a mount option.\n---\n## Block Capacity Math: Exactly How Big Can Files Get?\nLet's work through the arithmetic precisely, because it comes up in every production filesystem conversation:\n```c\n/*\n * Maximum file size addressable by this inode scheme.\n *\n * Direct:          12 blocks Ã— 4096 bytes         =        49,152 bytes  (~48 KB)\n * Single-indirect: 1024 blocks Ã— 4096 bytes        =     4,194,304 bytes  (~4 MB)\n * Double-indirect: 1024 Ã— 1024 Ã— 4096 bytes        = 4,294,967,296 bytes  (~4 GB)\n *\n * Total:                                           = 4,299,210,752 bytes  (~4.004 GB)\n *\n * If we added triple-indirect (ext2/ext3 style):\n * Triple-indirect: 1024 Ã— 1024 Ã— 1024 Ã— 4096      = 4,398,046,511,104 bytes (~4 TB)\n */\n#define MAX_FILE_BLOCKS  (N_DIRECT + PTRS_PER_BLOCK + \\\n                          (uint64_t)PTRS_PER_BLOCK * PTRS_PER_BLOCK)\n#define MAX_FILE_SIZE    ((uint64_t)MAX_FILE_BLOCKS * BLOCK_SIZE)\n```\nNote that `size` is stored as `uint32_t` in our inode (4 bytes, max ~4.29 GB). For files larger than 4GB, you would need `uint64_t` for the size field â€” which is how ext4, XFS, and every modern filesystem implement it. The 32-bit size field is a design limitation of our simplified implementation; it matches the original ext2 design.\n---\n## The Structural Parallel: Inode Pointers and Page Tables\nHere is one of the most illuminating cross-domain connections in systems programming:\n**Your double-indirect block pointer tree is the same structure as a 3-level CPU page table.**\n\n![Inode Pointers vs. x86-64 Page Table â€” Structural Parallel](./diagrams/diag-m2-inode-vs-pagetable.svg)\n\nWhen the CPU translates a virtual address to a physical address, it walks a multi-level page table:\n```\nVirtual address (48 bits on x86-64):\n  Bits 47-39: PML4 index    â†’ which entry in the top-level table\n  Bits 38-30: PDPT index    â†’ which entry in the 2nd-level table\n  Bits 29-21: PD index      â†’ which entry in the 3rd-level table\n  Bits 20-12: PT index      â†’ which entry in the 4th-level table (page table)\n  Bits 11-0:  Page offset   â†’ byte within the physical page (4KB)\n```\nCompare this to your file offset translation:\n```\nFile offset (38 bits for our 4GB max):\n  Bits 37-22: Double-indirect index â†’ which entry in the outer pointer block\n  Bits 21-12: Single-indirect index â†’ which entry in the inner pointer block\n  Bits 11-0:  Block offset          â†’ byte within the 4KB data block\n```\nThe structural identity is exact: both systems use a tree of fixed-size pointer arrays to translate an index into a physical resource. The MMU does this in hardware with a register (CR3 on x86) pointing to the top-level table. Your filesystem does it in software with a disk block number stored in the inode.\nThe key property both share: **each level of indirection multiplies capacity by the fanout** (1024 for filesystem blocks, 512 for page table entries). This is a **radix tree** â€” fixed-width indexing that provides O(1) lookup with bounded maximum depth.\n> ðŸ”­ **Deep Dive**: x86-64 page table structure. If you want to see the hardware version of exactly what you just built, read the Intel Software Developer's Manual Volume 3, Chapter 4 (\"Paging\"). Section 4.5 covers 4-level paging with full page-walk diagrams. Every concept maps 1:1 to your double-indirect pointer tree.\n---\n## Reference Counting: The Link Count Contract\nThe `nlinks` field implements **reference counting** for inodes. This is the same pattern used by `shared_ptr` in C++, `Arc<T>` in Rust, Python's garbage collector, and every operating system's file descriptor table.\nThe contract:\n- `nlinks` starts at 1 when an inode is created (one directory entry points to it)\n- Every `link()` call (creating a hard link) increments `nlinks`\n- Every `unlink()` call (removing a directory entry) decrements `nlinks`\n- When `nlinks == 0` AND no process has the file open: free the inode\n- When `nlinks == 0` but processes still have it open: defer freeing until last `close()`\nThe \"open but unlinked\" case is important: you can `unlink(\"myfile\")` on an open file, and the file continues to exist (and be readable/writable) until the last file descriptor pointing to it is closed. Only then does `nlinks` hitting 0 trigger actual deallocation. Your filesystem's \"open file table\" (implemented in Milestone 5) tracks open file descriptors separately from `nlinks`.\nFor directories specifically:\n- A new directory starts with `nlinks = 2` (one for its own `.` entry, one for the parent's entry pointing to it)\n- Each subdirectory increments the parent's `nlinks` by 1 (because the subdirectory's `..` entry points to the parent)\n- This is why deeply nested directories have high link counts, and why `find -maxdepth N` can use `nlinks` to prune the search\n---\n## Putting It Together: Inode Initialization\nWhen a new file or directory is created, you need to initialize the inode with correct defaults:\n```c\n/*\n * Initialize a newly allocated inode for a regular file.\n * Caller must call write_inode() afterward to persist it.\n */\nvoid inode_init_file(inode_t *inode, uint16_t mode, uint16_t uid, uint16_t gid) {\n    memset(inode, 0, sizeof(*inode));\n    inode->mode   = (S_IFREG | (mode & 0777));\n    inode->uid    = uid;\n    inode->gid    = gid;\n    inode->nlinks = 1;\n    inode->size   = 0;\n    uint32_t ts   = now_ts();\n    inode->atime  = inode->mtime = inode->ctime = ts;\n    /* All block pointers zeroed by memset â€” file starts with no allocated blocks */\n    /* single_indirect and double_indirect are also 0 â€” both are null */\n}\n/*\n * Initialize a newly allocated inode for a directory.\n * nlinks starts at 2: one for the parent entry pointing to it,\n * one for the '.' entry within the directory itself.\n */\nvoid inode_init_dir(inode_t *inode, uint16_t mode, uint16_t uid, uint16_t gid) {\n    memset(inode, 0, sizeof(*inode));\n    inode->mode   = (S_IFDIR | (mode & 0777));\n    inode->uid    = uid;\n    inode->gid    = gid;\n    inode->nlinks = 2;\n    inode->size   = BLOCK_SIZE;   /* directories are sized in block units */\n    uint32_t ts   = now_ts();\n    inode->atime  = inode->mtime = inode->ctime = ts;\n}\n```\n---\n## Validation: Testing the Inode Implementation\nBefore moving to Milestone 3, verify your inode layer thoroughly:\n```c\n/*\n * Test suite for inode layer.\n * Run after mkfs to verify the inode implementation works correctly.\n */\nvoid test_inode_layer(int fd, superblock_t *sb) {\n    printf(\"\\n=== Inode Layer Tests ===\\n\");\n    /* Test 1: Allocate an inode */\n    int ino = alloc_inode(fd, sb);\n    assert(ino > 0);\n    printf(\"OK: allocated inode %d\\n\", ino);\n    /* Test 2: Initialize and write it */\n    inode_t inode;\n    inode_init_file(&inode, 0644, 1000, 1000);\n    assert(write_inode(fd, sb, (uint32_t)ino, &inode) == 0);\n    /* Test 3: Read it back and verify fields */\n    inode_t read_back;\n    assert(read_inode(fd, sb, (uint32_t)ino, &read_back) == 0);\n    assert(S_ISREG(read_back.mode));\n    assert(read_back.nlinks == 1);\n    assert(read_back.size == 0);\n    printf(\"OK: inode round-trip verified\\n\");\n    /* Test 4: Set and get a direct block pointer */\n    int blk = alloc_block(fd, sb);\n    assert(blk >= 0);\n    assert(inode_set_block(fd, sb, &inode, 0, (uint32_t)blk) == 0);\n    uint32_t got_block;\n    assert(inode_get_block(fd, &inode, 0, &got_block) == 0);\n    assert(got_block == (uint32_t)blk);\n    printf(\"OK: direct block pointer set/get\\n\");\n    /* Test 5: Sparse file â€” get block for unallocated offset */\n    assert(inode_get_block(fd, &inode, 4096 * 100, &got_block) == 0);\n    assert(got_block == 0);    /* must be 0 â€” hole */\n    printf(\"OK: sparse hole returns block 0\\n\");\n    /* Test 6: Single-indirect region */\n    int si_blk = alloc_block(fd, sb);\n    uint64_t si_offset = (uint64_t)N_DIRECT * BLOCK_SIZE;   /* first single-indirect slot */\n    assert(inode_set_block(fd, sb, &inode, si_offset, (uint32_t)si_blk) == 0);\n    assert(inode.single_indirect != 0);   /* indirect block must have been allocated */\n    assert(inode_get_block(fd, &inode, si_offset, &got_block) == 0);\n    assert(got_block == (uint32_t)si_blk);\n    printf(\"OK: single-indirect block pointer set/get\\n\");\n    /* Test 7: Double-indirect region */\n    uint64_t di_offset = (uint64_t)(N_DIRECT + PTRS_PER_BLOCK) * BLOCK_SIZE;\n    int di_blk = alloc_block(fd, sb);\n    assert(inode_set_block(fd, sb, &inode, di_offset, (uint32_t)di_blk) == 0);\n    assert(inode.double_indirect != 0);\n    assert(inode_get_block(fd, &inode, di_offset, &got_block) == 0);\n    assert(got_block == (uint32_t)di_blk);\n    printf(\"OK: double-indirect block pointer set/get\\n\");\n    /* Test 8: Free inode â€” all blocks should be reclaimed */\n    uint32_t free_before = sb->free_blocks;\n    write_inode(fd, sb, (uint32_t)ino, &inode);\n    assert(free_inode(fd, sb, (uint32_t)ino) == 0);\n    /* After freeing: all direct blocks + indirect blocks reclaimed */\n    printf(\"OK: inode freed, %u blocks reclaimed\\n\",\n           sb->free_blocks - free_before);\n    printf(\"=== All Inode Tests Passed ===\\n\\n\");\n}\n```\n---\n## Design Decisions: Why This Pointer Scheme?\nThe direct/indirect/double-indirect scheme is not the only way to map files to blocks. Here is how the alternatives compare:\n| Option | Pros | Cons | Used By |\n|--------|------|------|---------|\n| **Direct + Indirect (chosen âœ“)** | Simple traversal logic; sparse files for free; proven design | Extra I/Os for large files; fragmentation grows with file age | ext2, ext3, original Unix FFS |\n| **Extents** | Contiguous runs eliminate per-block metadata; large sequential files have 1 metadata read regardless of size; much lower fragmentation | Extent trees are complex; sparse files harder to represent | ext4, XFS (B-tree extents), NTFS, HFS+ |\n| **Block map array** | Trivially simple | Cannot represent large files without enormous inode | FAT (cluster chains), very small filesystems |\n| **B-tree block map** | Self-balancing; handles arbitrary fragmentation gracefully | Complex implementation; high constant overhead | Btrfs (copy-on-write B-tree), ZFS |\n> ext4 replaced the indirect pointer scheme with extents â€” an extent is a tuple `(start_block, length)` that describes a contiguous run of blocks. A 1GB sequential file needs only one extent record instead of 262,144 separate block pointers. This collapses the tree to nearly constant depth for sequential files. The extent tree is a B-tree embedded in the inode's block pointer fields. Building the indirect pointer scheme first (as you're doing) is the right starting point â€” extents are an optimization of the same conceptual model.\n---\n## Knowledge Cascade: One Inode, Ten Worlds\nYou have built a fixed-size metadata structure with a tree of pointers to variable-size content. This pattern is not unique to filesystems. It is **the** fundamental pattern for indexing variable-size data with fixed-size metadata.\n**â†’ B-Trees and Database Indexes**\nYour indirect block pointer tree is a radix tree with fixed fanout (1024). A B-tree is the same concept generalized: internal nodes are \"indirect blocks\" holding pointers to children; leaf nodes are \"data blocks\" holding actual values. The branching factor varies by page size and key size. PostgreSQL's B-tree index pages, InnoDB's clustered index, and SQLite's B-tree pages all implement this same \"fixed-size nodes, variable-depth tree\" principle. ext4's extent tree is literally a B-tree embedded in the inode. Understanding your double-indirect pointers gives you the mental model to read any B-tree implementation and immediately see the parallel.\n**â†’ x86-64 Virtual Memory Page Tables**\nAs shown above, the CPU's page table walker performs the same operation as your `inode_get_block` â€” traversing a multi-level array of pointers to translate an index into a physical resource. CR3 register is the \"inode\"; page directory entries are the \"double-indirect block\"; page table entries are the \"single-indirect block\"; physical page frames are the \"data blocks.\" If you understand your `inode_get_block` function, you understand how the MMU hardware walks page tables. This insight unlocks reading `/proc/PID/maps`, understanding TLB shootdowns, and reasoning about memory-mapped file performance.\n**â†’ Sparse Files in Production Systems**\nVirtual machine disk images (QCOW2, VMDK, VDI) rely on sparse file support from the host filesystem. A 100GB VM disk image containing mostly zeroes occupies only the space for actual writes on an ext4 or XFS host. `cp --sparse=always` and `rsync --sparse` are tools that preserve this sparseness. Backing databases (QCOW2 copy-on-write) work by allocating blocks on first write â€” exactly what your `inode_set_block` does when a block is first written. Understanding null pointers = holes means understanding how VM provisioning achieves \"thin provisioning.\"\n**â†’ Reference Counting in Language Runtimes**\n`nlinks` in the inode solves the same problem as `std::shared_ptr<T>::use_count()` in C++, `Arc::strong_count()` in Rust, CPython's `ob_refcnt`, and Swift's ARC. The pattern is universal: a shared resource tracks the number of references to it; when that count reaches zero, the resource is freed. The filesystem version has one complication that smart pointers don't: the \"open but unlinked\" case, where a process can hold a file descriptor to a file whose `nlinks` has dropped to zero. This is the filesystem equivalent of a \"weak reference\" keeping a resource alive â€” the `nlinks = 0` condition is the destructor trigger, but only fires when no \"strong holds\" (open file descriptors) remain.\n**â†’ Git Object Storage and Content-Addressable Systems**\nGit's object store faces an identical design challenge: fixed-size metadata (a commit object: author, timestamp, message, parent pointers, tree pointer) pointing to variable-size content (file trees and blobs). Git's \"tree objects\" map filenames to blob hashes â€” exactly like your inode's block pointer array maps block indices to disk block numbers. Git's blob objects are like your data blocks. The metadata/content separation in your inode design is the same abstraction that makes content-addressable storage, Docker image layers, and Merkle trees work. When you understand inodes, you understand why Git's \"pack files,\" Docker's \"layers,\" and your filesystem's \"data blocks\" are all solving the same structural problem.\n**â†’ Object Storage Metadata (S3, GCS)**\nCloud object storage systems maintain metadata records for each object: size, creation time, content-type, ETag (hash), owner, access permissions. This metadata is small (hundreds of bytes) and lives in a separate system from the object data (potentially terabytes). The metadata-to-data separation is architecturally identical to your inode. When you upload a 5TB file to S3, a few hundred bytes of metadata are written to a distributed key-value store, while the data itself flows through a separate data plane to redundant storage servers. Your inode is the on-disk instantiation of this split that cloud engineers implement at global scale.\n---\n## Before You Move On: Pitfall Checklist\n- [ ] **Never use block 0 as a data block**: `alloc_block` returns absolute disk block numbers starting at `data_block_start`. If you ever see `inode->blocks[i] == 0` on an allocated block, something is wrong â€” 0 is the superblock, not a data block. The null/hole sentinel works because legitimate data blocks always have numbers â‰¥ `data_block_start`.\n- [ ] **Indirect block deallocation**: Call `free_single_indirect` and `free_double_indirect` in your `free_inode`. Audit this path by counting `sb->free_blocks` before and after freeing a large file â€” the delta should match the number of data blocks plus indirect pointer blocks.\n- [ ] **Off-by-one in boundary calculations**: The single-indirect region starts at block index `N_DIRECT` (12), not `N_DIRECT + 1`. The double-indirect region starts at block index `N_DIRECT + PTRS_PER_BLOCK` (1036). An off-by-one here silently corrupts a different block than you intend.\n- [ ] **`_Static_assert` on inode size**: Add `_Static_assert(sizeof(inode_t) == 128, \"inode_t size mismatch\")`. If you add a field and forget to shrink `reserved[]`, the compiler will catch it rather than silently misaligning every inode in the table.\n- [ ] **Zero the entire inode on allocation**: `memset(&inode, 0, sizeof(inode))` before `inode_init_*`. Uninitialized garbage in `reserved[]` or unused pointer slots causes spurious non-zero pointer values that `inode_get_block` will try to read as block numbers.\n- [ ] **Update `ctime` on inode writes**: Any operation that modifies the inode (permissions change, link count change, block pointer addition) must update `ctime`. Forgetting this makes `stat()` return stale metadata that confuses rsync and backup tools.\n- [ ] **Bitmap flush before inode write**: When allocating blocks to satisfy `inode_set_block`, write the updated bitmap to disk before writing the updated inode. If you crash between the two writes, a bitmap that says the block is used but no inode pointing to it is a leaked block (safe). A bitmap that says the block is free but an inode points to it is double-allocation (catastrophic).\n---\n## What You've Built and What Comes Next\n\n![Filesystem Atlas â€” Satellite Map (Home Base)](./diagrams/diag-L0-satellite-map.svg)\n\nYou now have a complete inode layer. A fixed-size structure that can represent any file from 0 bytes to 4GB. A pointer tree with three levels of indirection that costs zero extra disk reads for small files, one extra read for medium files, and two extra reads for large files. Sparse files where null pointers cost nothing. Reference counting that properly tracks all names pointing to a file. And the ability to serialize all of this to and from exact byte positions on disk.\nBut an inode has no name. Inodes don't know what they're called â€” that knowledge lives in the directory. A directory is a special kind of file whose data blocks contain structured records mapping names to inode numbers. In Milestone 3, you'll build those directory entries, implement the path resolution algorithm that translates `/home/user/projects/file.txt` into a sequence of inode lookups, and implement `mkdir`, `rmdir`, `link`, and `unlink` with their correct link count semantics.\nThe inode's `mode` field already knows whether it's a directory (`S_IFDIR`). Now it's time to give the directory its voice.\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: filesystem-m3 -->\n<!-- MS_ID: filesystem-m3 -->\n# Milestone 3: Directory Operations\n## The Directory Is a Lie You Have Always Believed\nYou have been lied to since the first time you opened a file manager.\nThe GUI shows you folders. Nested, hierarchical, expandable folders. You double-click a folder and it opens. You drag files into folders. You see a tree structure â€” a visual hierarchy where folders contain other folders and files live inside them. The entire metaphor screams: **folders are containers. Files live inside them. The two are fundamentally different things.**\nNow open a terminal and run this:\n```bash\n$ ls -la /tmp\ntotal 24\ndrwxrwxrwt  8 root root 4096 Mar  1 12:00 .\ndrwxr-xr-x 20 root root 4096 Mar  1 12:00 ..\ndrwx------  2 user user 4096 Mar  1 12:00 some_dir\n-rw-r--r--  1 user user  142 Mar  1 12:00 some_file.txt\n```\nNotice that `some_dir` is listed with `d` permissions and `some_file.txt` is listed with `-` permissions. The `d` tells you the type. But that `4096` size for `some_dir`? That is exactly one block. One file-sized block. A directory has a *size*. It has an *inode number*. It has timestamps. It has an owner. Every single field you built in Milestone 2's `inode_t` applies to directories.\nBecause **a directory is a file**.\nNot \"kind of like a file.\" Not \"similar to a file.\" A directory *is* a file, with one difference: its data blocks contain a structured array of records mapping names to inode numbers instead of containing application data. The VFS (Virtual Filesystem Switch â€” the kernel's abstraction layer over all filesystem types) gives directories the `S_IFDIR` type bit in `mode`, and the kernel interprets that to mean \"the data in this file's blocks is a list of directory entries, not raw data.\" But the storage mechanism â€” inode pointing to data blocks â€” is identical.\nThis revelation collapses three separate \"things\" (files, folders, the path system) into one. And once you understand that a directory is a file, the path resolution algorithm `/home/user/projects/file.txt â†’ inode 42` becomes completely mechanical, blindingly obvious, and satisfying in its recursive simplicity.\nLet's build it.\n\n![Directory Tree as Inode Graph â€” From Structure to Mental Model](./diagrams/diag-m3-directory-tree.svg)\n\n---\n## The Fundamental Tension: Hierarchical Names, Flat Blocks\nHere is the core hardware and design constraint you are negotiating with:\n**Humans organize knowledge hierarchically and refer to things by name. Storage hardware is a flat array of numbered blocks with no concept of names, hierarchies, or relationships.**\nWhen you type `/usr/bin/gcc`, you are expressing a 3-level hierarchy: root â†’ `usr` â†’ `bin` â†’ `gcc`. The disk stores four separate block regions: one for the root directory's entry list, one for `/usr`'s entry list, one for `/bin`'s entry list, and one for `gcc`'s actual inode and data blocks. The \"hierarchy\" exists nowhere on disk as a single structure. It is an emergent property of files that point to other files.\nEvery path lookup must be *computed* by walking this chain. There is no shortcut. There is no global hash table. `getattr(\"/usr/bin/gcc\")` requires at minimum:\n1. Read root directory's data blocks â†’ find `usr` â†’ get inode 14\n2. Read inode 14's data blocks â†’ find `bin` â†’ get inode 81  \n3. Read inode 81's data blocks â†’ find `gcc` â†’ get inode 4431\n4. Read inode 4431 â†’ this is your file\nThat's 4+ disk reads for a trivial path. For `/usr/lib/python3.11/site-packages/numpy/core/_multiarray_umath.cpython-311-x86_64-linux-gnu.so` (a real file path), you'd walk 9 levels. Linux solves this with the **dcache** (directory entry cache) â€” a kernel-level in-memory hash table mapping `(parent_inode, name) â†’ child_inode`. In your FUSE filesystem, every path lookup must traverse from root unless you implement a dcache. This is the central performance problem of directory-based filesystems, and FUSE exposes it nakedly.\nThe numbers: on a cold cache, each directory lookup requires 1â€“2 disk reads (inode block + data block). An SSD costs ~100Î¼s per read. A 9-component path = 18 reads = ~1.8ms just for the lookup, before any data is read. The Linux dcache converts this to nanoseconds for hot paths.\n---\n## The Directory Entry: On-Disk Format\n\n![Directory Entry Structure â€” On-Disk Format](./diagrams/diag-m3-directory-entry-layout.svg)\n\nA directory's data blocks contain a sequence of **directory entries** (dirents). Each entry is a variable-length record with a fixed-size header and a variable-length name field. Here is the design we'll use, closely modeled after ext2's format:\n```c\n/*\n * Directory entry â€” on-disk format.\n *\n * BYTE LAYOUT:\n *   Offset 0: inode_num  (4 bytes) â€” 0 means deleted/unused entry\n *   Offset 4: rec_len    (2 bytes) â€” total length of this record (for skipping)\n *   Offset 6: name_len   (1 byte)  â€” length of name field (NOT null-terminated length)\n *   Offset 7: file_type  (1 byte)  â€” type hint: 0=unknown, 1=regular, 2=directory\n *   Offset 8: name       (name_len bytes) â€” the filename, NOT null-terminated on disk\n *   [padding to align rec_len to a 4-byte boundary]\n *\n * rec_len is CRITICAL: it tells you how many bytes to advance to find the NEXT entry.\n * This allows entries to span variable widths while keeping the scan efficient.\n *\n * The last entry in a block has rec_len extended to fill the remaining space,\n * acting as a sentinel so you know where the block ends.\n */\n#define MAX_FILENAME_LEN   255    /* POSIX NAME_MAX */\n#define DIRENT_HEADER_SIZE 8      /* inode_num + rec_len + name_len + file_type */\n/* File type constants for dirent.file_type */\n#define FT_UNKNOWN   0\n#define FT_REG_FILE  1\n#define FT_DIR       2\n#define FT_SYMLINK   7\n/*\n * In-memory representation â€” easier to work with than the raw on-disk format.\n * We serialize to/from the variable-length on-disk format manually.\n */\ntypedef struct {\n    uint32_t inode_num;          /* target inode number (0 = free slot) */\n    uint16_t rec_len;            /* total record length including padding */\n    uint8_t  name_len;           /* length of name, not including any null */\n    uint8_t  file_type;          /* FT_* constant */\n    char     name[MAX_FILENAME_LEN + 1];  /* name, always null-terminated in memory */\n} dirent_t;\n```\nThe `rec_len` field deserves careful attention. It is **not** `DIRENT_HEADER_SIZE + name_len`. It is the total number of bytes consumed by this entry in the directory block, which includes:\n1. The fixed 8-byte header\n2. The name bytes (`name_len`)\n3. Padding bytes to align the next entry to a 4-byte boundary\n4. For the **last** active entry in a block, `rec_len` is extended to fill the remaining bytes of the block â€” this entry \"owns\" all remaining space\nThis variable-length, forward-linked record format means directory scanning is always sequential: read entry at offset 0, advance by `rec_len`, read next entry, repeat until you've consumed `BLOCK_SIZE` bytes.\n```c\n/*\n * Compute the actual (padded) record length for a given name length.\n * Entries are padded to 4-byte alignment.\n *\n *   name_len=1  â†’ 8 + 1 = 9  â†’ pad to 12\n *   name_len=2  â†’ 8 + 2 = 10 â†’ pad to 12\n *   name_len=3  â†’ 8 + 3 = 11 â†’ pad to 12\n *   name_len=4  â†’ 8 + 4 = 12 â†’ already aligned\n *   name_len=8  â†’ 8 + 8 = 16 â†’ already aligned\n */\nstatic uint16_t dirent_actual_len(uint8_t name_len) {\n    uint16_t raw = DIRENT_HEADER_SIZE + name_len;\n    return (uint16_t)((raw + 3) & ~3u);   /* round up to next multiple of 4 */\n}\n/*\n * Write a dirent_t to a raw byte buffer at a given offset.\n * Returns the number of bytes written (rec_len).\n */\nstatic uint16_t dirent_write_to_buf(uint8_t *buf, uint16_t offset,\n                                     const dirent_t *de) {\n    uint8_t *p = buf + offset;\n    memcpy(p + 0, &de->inode_num, 4);\n    memcpy(p + 4, &de->rec_len,   2);\n    memcpy(p + 6, &de->name_len,  1);\n    memcpy(p + 7, &de->file_type, 1);\n    memcpy(p + 8, de->name, de->name_len);\n    /* zero the padding bytes */\n    uint16_t actual = dirent_actual_len(de->name_len);\n    if (actual > DIRENT_HEADER_SIZE + de->name_len) {\n        memset(p + DIRENT_HEADER_SIZE + de->name_len, 0,\n               actual - DIRENT_HEADER_SIZE - de->name_len);\n    }\n    return de->rec_len;\n}\n/*\n * Read a dirent_t from a raw byte buffer at a given offset.\n * Returns the rec_len to advance to the next entry.\n * Returns 0 if the entry is a deleted slot (inode_num == 0 but rec_len != 0).\n */\nstatic uint16_t dirent_read_from_buf(const uint8_t *buf, uint16_t offset,\n                                      dirent_t *de) {\n    const uint8_t *p = buf + offset;\n    memcpy(&de->inode_num, p + 0, 4);\n    memcpy(&de->rec_len,   p + 4, 2);\n    memcpy(&de->name_len,  p + 6, 1);\n    memcpy(&de->file_type, p + 7, 1);\n    if (de->rec_len < DIRENT_HEADER_SIZE || de->rec_len > BLOCK_SIZE) {\n        return 0;    /* corrupted entry â€” stop scan */\n    }\n    if (de->name_len > 0 && de->name_len <= MAX_FILENAME_LEN) {\n        memcpy(de->name, p + 8, de->name_len);\n    }\n    de->name[de->name_len] = '\\0';   /* always null-terminate in memory */\n    return de->rec_len;\n}\n```\n> **Why variable-length entries instead of fixed-size?**\n> Fixed-size entries are simpler to implement, but they waste enormous space. If you allocate 256 bytes per entry (to hold the max 255-char filename), a directory with 100 files named `a`, `b`, `c` consumes 25KB just for entries that average 9 bytes each. Variable-length entries pack at density proportional to actual name length. The downside: you cannot randomly access entry N without scanning from the start. For directories with hundreds of entries, this linear scan becomes a bottleneck â€” which is why ext4 introduced `htree` (hash-tree) directories as an optimization (see Knowledge Cascade below).\n---\n## Scanning a Directory Block\nThe workhorse of all directory operations is scanning a directory's data blocks for a specific name. Let's implement this as a clean, reusable primitive:\n```c\n/*\n * Scan all entries in a single directory data block.\n * Calls callback for each valid entry (inode_num != 0).\n *\n * callback return values:\n *   0  â†’ continue scanning\n *   1  â†’ stop scanning, entry found (caller checks de->inode_num)\n *  <0  â†’ stop scanning, error\n *\n * Returns the inode number of the matching entry, 0 if not found, <0 on error.\n */\ntypedef int (*dirent_callback_t)(const dirent_t *de, void *userdata);\nstatic int scan_dir_block(const uint8_t *block_buf,\n                          dirent_callback_t cb, void *userdata) {\n    uint16_t offset = 0;\n    while (offset + DIRENT_HEADER_SIZE <= BLOCK_SIZE) {\n        dirent_t de;\n        uint16_t rec_len = dirent_read_from_buf(block_buf, offset, &de);\n        if (rec_len == 0) break;     /* corrupted â€” stop */\n        if (de.inode_num != 0) {     /* skip deleted entries */\n            int r = cb(&de, userdata);\n            if (r != 0) return r;\n        }\n        offset += rec_len;\n    }\n    return 0;\n}\n/* Callback + userdata for name lookup */\ntypedef struct {\n    const char *target_name;\n    uint32_t    found_inode;\n} lookup_ctx_t;\nstatic int lookup_cb(const dirent_t *de, void *userdata) {\n    lookup_ctx_t *ctx = (lookup_ctx_t *)userdata;\n    if (de->name_len == strlen(ctx->target_name) &&\n        memcmp(de->name, ctx->target_name, de->name_len) == 0) {\n        ctx->found_inode = de->inode_num;\n        return 1;   /* found â€” stop scan */\n    }\n    return 0;   /* keep scanning */\n}\n/*\n * Look up a single name component in a directory inode.\n * Returns the inode number of the matching entry, or 0 if not found.\n * Returns <0 on I/O error.\n */\nint dir_lookup(int fd, const superblock_t *sb,\n               const inode_t *dir_inode, const char *name) {\n    if (!S_ISDIR(dir_inode->mode)) return -ENOTDIR;\n    lookup_ctx_t ctx = { .target_name = name, .found_inode = 0 };\n    uint8_t buf[BLOCK_SIZE];\n    /* Scan each direct block of the directory */\n    for (int i = 0; i < N_DIRECT; i++) {\n        if (dir_inode->blocks[i] == 0) continue;\n        if (read_block(fd, dir_inode->blocks[i], buf) != 0) return -EIO;\n        int r = scan_dir_block(buf, lookup_cb, &ctx);\n        if (r == 1) return (int)ctx.found_inode;   /* found */\n        if (r < 0)  return r;\n    }\n    /* For milestone 3, we handle directories up to 12 direct blocks (48KB).\n     * In practice, that's 48KB / ~12 bytes avg per entry â‰ˆ 4000 entries â€”\n     * sufficient for most use cases. Single-indirect support is straightforward\n     * to add by extending this loop to use inode_get_block() instead. */\n    return 0;   /* not found */\n}\n```\n> **Hardware Soul â€” Directory Scan Performance**:\n> Scanning a directory's data blocks is a sequential memory read of 4KB chunks. Once the first block is in the L1 or L2 cache (64KB and 256KB respectively on typical x86-64), subsequent scans of the same directory data are at memory speed: ~4ns per cache line (64 bytes), covering 8 entries per cache line for short names. A 100-entry directory fits in 2â€“3 cache lines' worth of data â€” the entire lookup completes in under 20ns from L1. The bottleneck is the initial disk read if the block is cold: ~100Î¼s on SSD. This 5,000Ã— gap between cached and uncached lookup is exactly what Linux's dcache eliminates.\n---\n## Path Resolution: Walking the Tree\n\n![Path Resolution â€” Walking /home/user/file.txt](./diagrams/diag-m3-path-resolution.svg)\n\nPath resolution is the algorithm that converts a string like `/home/user/projects/file.txt` into an inode number. It is one of the most frequently executed operations in any OS, and every single call to `open()`, `stat()`, `access()`, `mkdir()`, `rename()`, and most other syscalls triggers it.\n[[EXPLAIN:vfs-namei-â€”-the-kernel-path-resolution-engine|VFS namei â€” how the Linux kernel resolves pathnames through dentry cache and filesystem methods]]\nThe algorithm is beautifully simple:\n1. Start at the root inode (if path begins with `/`) or the current working directory inode (if relative path)\n2. Tokenize the path by `/` separators, skipping empty components\n3. For each component `name`:\n   a. Verify the current inode is a directory (`S_ISDIR(mode)`)\n   b. Scan the directory's data blocks for an entry matching `name`\n   c. Get the inode number from that entry\n   d. Load that inode â€” it becomes the \"current inode\" for the next component\n4. After the last component, return the inode number\nThe `..` and `.` entries are **real directory entries stored on disk** â€” not special kernel magic. When you hit `..`, you look it up like any other name, find its inode number, load that inode, and continue. When you hit `.`, you find the same inode you're already at. The tree traversal is entirely implemented by the normal lookup mechanism.\n```c\n/*\n * Resolve a path to an inode number.\n *\n * path:      absolute path (must start with '/') or relative path\n * root_ino:  inode number of the filesystem root (from sb->root_inode)\n * cwd_ino:   inode number of the current working directory (use root_ino\n *            if you don't track per-process cwd)\n *\n * Returns inode number on success, or a negative errno value.\n */\nint path_resolve(int fd, const superblock_t *sb,\n                 const char *path, uint32_t root_ino, uint32_t cwd_ino) {\n    if (path == NULL || path[0] == '\\0') return -EINVAL;\n    /* Determine starting inode */\n    uint32_t current_ino = (path[0] == '/') ? root_ino : cwd_ino;\n    /* Work on a mutable copy of the path for tokenization */\n    char path_copy[4096];\n    if (strlen(path) >= sizeof(path_copy)) return -ENAMETOOLONG;\n    strncpy(path_copy, path, sizeof(path_copy) - 1);\n    path_copy[sizeof(path_copy) - 1] = '\\0';\n    /* Tokenize by '/' and walk each component */\n    char *saveptr = NULL;\n    char *component = strtok_r(path_copy, \"/\", &saveptr);\n    while (component != NULL) {\n        /* Skip empty components (result of consecutive '/' in path) */\n        if (component[0] == '\\0') {\n            component = strtok_r(NULL, \"/\", &saveptr);\n            continue;\n        }\n        /* Enforce filename length limit */\n        if (strlen(component) > MAX_FILENAME_LEN) return -ENAMETOOLONG;\n        /* Load the current directory inode */\n        inode_t dir_inode;\n        if (read_inode(fd, sb, current_ino, &dir_inode) != 0) return -EIO;\n        /* Must be a directory to descend into */\n        if (!S_ISDIR(dir_inode.mode)) return -ENOTDIR;\n        /* Look up this component in the directory */\n        int child_ino = dir_lookup(fd, sb, &dir_inode, component);\n        if (child_ino == 0) return -ENOENT;    /* not found */\n        if (child_ino < 0)  return child_ino;  /* I/O error */\n        current_ino = (uint32_t)child_ino;\n        component = strtok_r(NULL, \"/\", &saveptr);\n    }\n    return (int)current_ino;\n}\n/*\n * Variant: resolve all but the last component, returning the parent inode\n * and the final component name. Used by create, mkdir, unlink, rename.\n *\n * Example: path = \"/home/user/new_file.txt\"\n *   â†’ parent_ino = inode of \"/home/user\"\n *   â†’ name_out   = \"new_file.txt\"\n */\nint path_resolve_parent(int fd, const superblock_t *sb,\n                         const char *path, uint32_t root_ino, uint32_t cwd_ino,\n                         uint32_t *parent_ino_out, char *name_out, size_t name_max) {\n    /* Find the last '/' to split parent path from final component */\n    const char *last_slash = strrchr(path, '/');\n    if (last_slash == NULL) {\n        /* Relative path with no slash â€” parent is cwd */\n        *parent_ino_out = cwd_ino;\n        if (strlen(path) >= name_max) return -ENAMETOOLONG;\n        strncpy(name_out, path, name_max - 1);\n        name_out[name_max - 1] = '\\0';\n        return 0;\n    }\n    if (last_slash == path) {\n        /* Path like \"/filename\" â€” parent is root */\n        *parent_ino_out = root_ino;\n    } else {\n        /* Path like \"/home/user/filename\" â€” resolve parent portion */\n        char parent_path[4096];\n        size_t parent_len = (size_t)(last_slash - path);\n        if (parent_len >= sizeof(parent_path)) return -ENAMETOOLONG;\n        memcpy(parent_path, path, parent_len);\n        parent_path[parent_len] = '\\0';\n        int p = path_resolve(fd, sb, parent_path, root_ino, cwd_ino);\n        if (p < 0) return p;\n        *parent_ino_out = (uint32_t)p;\n    }\n    /* Extract the final component */\n    const char *filename = last_slash + 1;\n    if (strlen(filename) == 0) return -EINVAL;    /* trailing slash */\n    if (strlen(filename) >= name_max) return -ENAMETOOLONG;\n    strncpy(name_out, filename, name_max - 1);\n    name_out[name_max - 1] = '\\0';\n    return 0;\n}\n```\n> **Three-Level View â€” What Happens When `path_resolve(\"/usr/bin/gcc\")` Runs**\n>\n> | Level | What Happens |\n> |-------|-------------|\n> | **Application** | Calls `open(\"/usr/bin/gcc\", O_RDONLY)`. The path string lives in process memory. |\n> | **OS / Kernel (Linux)** | The VFS `namei` subsystem tokenizes the path and walks the dcache (dentry cache). If `(root_ino, \"usr\")` is in the dcache, it returns the child dentry without any disk I/O. For a cold cache, it calls your filesystem's `lookup` method for each component. The kernel tracks the current directory per-process via `task_struct.fs->pwd`. |\n> | **Hardware** | For each directory block read: the block device driver issues a read request. The DMA controller transfers 4KB from disk into a kernel page cache page. Your filesystem code then scans that memory â€” at memory bus speed (~50GB/s), scanning 4KB takes under 100ns. |\n---\n## Adding and Removing Entries: The Mutation API\n\n![Directory Entry Removal â€” Before/After Block State](./diagrams/diag-m3-dir-entry-deletion.svg)\n\n### `add_entry`: Writing a New Name\n```c\n/*\n * Add a directory entry to a directory inode.\n * Appends the new entry to the first data block with space, or allocates\n * a new block if all existing blocks are full.\n *\n * dir_ino:    inode number of the directory to modify\n * name:       filename to add (must not already exist)\n * target_ino: inode number the new entry points to\n * file_type:  FT_DIR or FT_REG_FILE (stored as a hint in the entry)\n *\n * Returns 0 on success, negative errno on failure.\n *\n * NOTE: Does NOT modify the target inode's nlinks â€” caller is responsible.\n * This separation keeps add_entry general-purpose.\n */\nint dir_add_entry(int fd, superblock_t *sb,\n                  uint32_t dir_ino, const char *name,\n                  uint32_t target_ino, uint8_t file_type) {\n    if (strlen(name) == 0 || strlen(name) > MAX_FILENAME_LEN) return -EINVAL;\n    inode_t dir_inode;\n    if (read_inode(fd, sb, dir_ino, &dir_inode) != 0) return -EIO;\n    if (!S_ISDIR(dir_inode.mode)) return -ENOTDIR;\n    /* First pass: check name doesn't already exist */\n    if (dir_lookup(fd, sb, &dir_inode, name) > 0) return -EEXIST;\n    uint16_t needed = dirent_actual_len((uint8_t)strlen(name));\n    uint8_t buf[BLOCK_SIZE];\n    /* Search existing blocks for a slot with enough free space */\n    for (int i = 0; i < N_DIRECT; i++) {\n        uint32_t blk = dir_inode.blocks[i];\n        if (blk == 0) continue;\n        if (read_block(fd, blk, buf) != 0) return -EIO;\n        /* Scan entries to find the last active entry in this block.\n         * We can steal space from its rec_len \"tail\" if there's room. */\n        uint16_t offset = 0;\n        while (offset + DIRENT_HEADER_SIZE <= BLOCK_SIZE) {\n            dirent_t de;\n            uint16_t advance = dirent_read_from_buf(buf, offset, &de);\n            if (advance == 0) break;\n            uint16_t actual_size;\n            if (de.inode_num == 0) {\n                /* Deleted entry â€” its entire rec_len is free */\n                actual_size = 0;\n            } else {\n                actual_size = dirent_actual_len(de.name_len);\n            }\n            uint16_t free_space = de.rec_len - actual_size;\n            if (free_space >= needed) {\n                /* Enough space after this entry (or in its deleted slot).\n                 * Split: shrink this entry's rec_len to actual_size,\n                 * write new entry in the freed space. */\n                if (de.inode_num != 0) {\n                    /* Shrink the existing entry's rec_len */\n                    de.rec_len = actual_size;\n                    dirent_write_to_buf(buf, offset, &de);\n                }\n                /* Write the new entry in the freed space */\n                uint16_t new_offset = offset + (de.inode_num != 0 ? actual_size : 0);\n                dirent_t new_de = {\n                    .inode_num = target_ino,\n                    .rec_len   = free_space,\n                    .name_len  = (uint8_t)strlen(name),\n                    .file_type = file_type,\n                };\n                memcpy(new_de.name, name, new_de.name_len);\n                new_de.name[new_de.name_len] = '\\0';\n                dirent_write_to_buf(buf, new_offset, &new_de);\n                if (write_block(fd, blk, buf) != 0) return -EIO;\n                /* Update directory mtime/ctime */\n                dir_inode.mtime = dir_inode.ctime = (uint32_t)time(NULL);\n                return write_inode(fd, sb, dir_ino, &dir_inode);\n            }\n            offset += advance;\n        }\n    }\n    /* No space in existing blocks â€” allocate a new directory block */\n    int new_blk = alloc_block(fd, sb);\n    if (new_blk < 0) return -ENOSPC;\n    /* Find a free direct block slot in the inode */\n    int slot = -1;\n    for (int i = 0; i < N_DIRECT; i++) {\n        if (dir_inode.blocks[i] == 0) { slot = i; break; }\n    }\n    if (slot < 0) return -ENOSPC;   /* all 12 direct blocks in use */\n    /* Initialize the new block with the new entry occupying full block */\n    memset(buf, 0, BLOCK_SIZE);\n    dirent_t new_de = {\n        .inode_num = target_ino,\n        .rec_len   = BLOCK_SIZE,     /* owns entire block */\n        .name_len  = (uint8_t)strlen(name),\n        .file_type = file_type,\n    };\n    memcpy(new_de.name, name, new_de.name_len);\n    new_de.name[new_de.name_len] = '\\0';\n    dirent_write_to_buf(buf, 0, &new_de);\n    if (write_block(fd, (uint32_t)new_blk, buf) != 0) return -EIO;\n    dir_inode.blocks[slot] = (uint32_t)new_blk;\n    dir_inode.size += BLOCK_SIZE;\n    dir_inode.mtime = dir_inode.ctime = (uint32_t)time(NULL);\n    return write_inode(fd, sb, dir_ino, &dir_inode);\n}\n```\nThe entry split strategy â€” shrinking the last entry's `rec_len` to make room for a new entry in its \"tail\" space â€” is exactly how ext2 works. This packs entries densely and avoids frequent block allocations for directories with moderate entry counts.\n### `remove_entry`: Deleting a Name\nRemoving a directory entry does **not** physically shift entries in memory or free space immediately. Instead, it uses one of two strategies:\n1. **Set `inode_num = 0`**: Mark the entry as deleted. The `rec_len` remains unchanged, so the scanner skips it (it's still in the linked chain for forward scanning, just logically absent). Free space is only reclaimed when `add_entry` detects a deleted slot or empty tail space.\n2. **Expand the previous entry's `rec_len`**: Find the preceding entry and extend its `rec_len` to absorb the deleted entry's space. This is cleaner and immediately merges the free space, but requires tracking the \"previous entry\" during the scan.\nWe'll implement strategy 2 (the ext2 approach) for cleaner space recovery:\n```c\n/*\n * Remove a directory entry by name.\n * Decrements the target inode's nlinks and frees it if nlinks reaches 0.\n *\n * Returns 0 on success, -ENOENT if not found, negative errno on error.\n */\nint dir_remove_entry(int fd, superblock_t *sb,\n                     uint32_t dir_ino, const char *name) {\n    inode_t dir_inode;\n    if (read_inode(fd, sb, dir_ino, &dir_inode) != 0) return -EIO;\n    if (!S_ISDIR(dir_inode.mode)) return -ENOTDIR;\n    uint8_t buf[BLOCK_SIZE];\n    for (int i = 0; i < N_DIRECT; i++) {\n        uint32_t blk = dir_inode.blocks[i];\n        if (blk == 0) continue;\n        if (read_block(fd, blk, buf) != 0) return -EIO;\n        uint16_t offset = 0;\n        uint16_t prev_offset = 0;\n        bool found = false;\n        uint32_t target_ino = 0;\n        while (offset + DIRENT_HEADER_SIZE <= BLOCK_SIZE) {\n            dirent_t de;\n            uint16_t advance = dirent_read_from_buf(buf, offset, &de);\n            if (advance == 0) break;\n            if (de.inode_num != 0 &&\n                de.name_len == strlen(name) &&\n                memcmp(de.name, name, de.name_len) == 0) {\n                /* Found the entry to remove */\n                target_ino = de.inode_num;\n                if (offset == 0) {\n                    /* First entry in block: just zero out inode_num */\n                    /* (Cannot merge backwards â€” there is no previous entry) */\n                    uint32_t zero = 0;\n                    memcpy(buf + offset, &zero, 4);\n                } else {\n                    /* Merge: expand previous entry's rec_len to absorb this one */\n                    dirent_t prev_de;\n                    dirent_read_from_buf(buf, prev_offset, &prev_de);\n                    prev_de.rec_len += de.rec_len;\n                    dirent_write_to_buf(buf, prev_offset, &prev_de);\n                }\n                found = true;\n                break;\n            }\n            if (de.inode_num != 0) prev_offset = offset;  /* track last valid entry */\n            offset += advance;\n        }\n        if (found) {\n            if (write_block(fd, blk, buf) != 0) return -EIO;\n            /* Update directory mtime/ctime */\n            dir_inode.mtime = dir_inode.ctime = (uint32_t)time(NULL);\n            if (write_inode(fd, sb, dir_ino, &dir_inode) != 0) return -EIO;\n            /* Decrement target inode's nlinks */\n            inode_t target_inode;\n            if (read_inode(fd, sb, target_ino, &target_inode) != 0) return -EIO;\n            if (target_inode.nlinks > 0) target_inode.nlinks--;\n            target_inode.ctime = (uint32_t)time(NULL);\n            if (target_inode.nlinks == 0) {\n                /* Last link removed â€” free the inode and all its blocks.\n                 * In a real filesystem, check for open file descriptors first.\n                 * For now, free immediately. Milestone 5 handles the open fd case. */\n                return free_inode(fd, sb, target_ino);\n            }\n            return write_inode(fd, sb, target_ino, &target_inode);\n        }\n    }\n    return -ENOENT;\n}\n```\n> **Pitfall â€” Removing `.` and `..`**: Your `dir_remove_entry` must refuse to remove entries named `.` and `..`. These are structural entries that maintain link counts and tree integrity. Add a guard at the top:\n> ```c\n> if (strcmp(name, \".\") == 0 || strcmp(name, \"..\") == 0) return -EINVAL;\n> ```\n---\n## `mkdir`: Creating a Directory\n\n![mkdir /home/user/projects â€” Step-by-Step State Changes](./diagrams/diag-m3-mkdir-state-evolution.svg)\n\n`mkdir` is not just \"create an inode and add a directory entry.\" It involves a precise sequence of state changes that maintain link count invariants. Let's trace through exactly what must happen when you call `mkdir(\"/home/user/projects\")`:\n1. Resolve `/home/user` â†’ get parent inode number `parent_ino`\n2. Verify `projects` doesn't already exist in parent\n3. Allocate a new inode for the new directory\n4. Initialize the new directory inode (`mode = S_IFDIR | 0755`, `nlinks = 2`)\n5. Allocate a data block for the new directory's initial entries\n6. Write `.` (pointing to new inode) and `..` (pointing to parent inode) into that block\n7. Write the new directory inode to disk with the data block pointer set\n8. Add an entry for `projects` in the parent directory (incrementing parent's `nlinks`)\n9. Increment the parent inode's `nlinks` by 1 (because `..` in the new dir points to parent)\nStep 9 is the one developers forget. The parent's `nlinks` count tracks how many things point *to* it. When you create a child directory, that child's `..` entry points to the parent â€” so the parent gains one more reference, and its `nlinks` increments.\n```\nBefore mkdir projects:\n  /home/user  â†’  inode 7  â†’  nlinks = 2 (one for /home/user entry, one for /home/user/. entry)\nAfter mkdir projects:\n  /home/user  â†’  inode 7  â†’  nlinks = 3 (added: /home/user/projects/.. â†’ inode 7)\n```\nThis is why deeply nested directories cause high `nlinks` on parent directories. And it's why `find -maxdepth N` can use `nlinks` to prune: if a directory's `nlinks` equals 2, it has no subdirectories (only `.` and the parent's entry), so `find` can skip descending.\n```c\n/*\n * Create a new directory at the given path.\n *\n * parent_ino: inode number of the parent directory\n * name:       name of the new directory (single component, not a path)\n * mode:       permission bits (will be OR'd with S_IFDIR)\n * uid, gid:   owner\n *\n * Returns the new directory's inode number on success, negative errno on failure.\n */\nint fs_mkdir(int fd, superblock_t *sb,\n             uint32_t parent_ino, const char *name,\n             uint16_t mode, uint16_t uid, uint16_t gid) {\n    /* Validate */\n    if (strlen(name) == 0 || strlen(name) > MAX_FILENAME_LEN) return -EINVAL;\n    inode_t parent_inode;\n    if (read_inode(fd, sb, parent_ino, &parent_inode) != 0) return -EIO;\n    if (!S_ISDIR(parent_inode.mode)) return -ENOTDIR;\n    /* Check name doesn't already exist */\n    if (dir_lookup(fd, sb, &parent_inode, name) > 0) return -EEXIST;\n    /* Step 1: Allocate new inode */\n    int new_ino = alloc_inode(fd, sb);\n    if (new_ino < 0) return -ENOSPC;\n    /* Step 2: Allocate a data block for . and .. entries */\n    int data_blk = alloc_block(fd, sb);\n    if (data_blk < 0) {\n        /* Roll back inode allocation â€” don't leak */\n        /* In a journaled filesystem this wouldn't be needed.\n         * For now, manually mark inode free in bitmap. */\n        uint8_t ibmap[BLOCK_SIZE];\n        read_block(fd, INODE_BITMAP_BLOCK, ibmap);\n        bitmap_clear(ibmap, (uint32_t)new_ino - 1);\n        write_block(fd, INODE_BITMAP_BLOCK, ibmap);\n        sb->free_inodes++;\n        return -ENOSPC;\n    }\n    /* Step 3: Write . and .. into the data block */\n    uint8_t dir_data[BLOCK_SIZE];\n    memset(dir_data, 0, BLOCK_SIZE);\n    /* '.' entry â€” points to ourselves */\n    dirent_t dot = {\n        .inode_num = (uint32_t)new_ino,\n        .name_len  = 1,\n        .file_type = FT_DIR,\n    };\n    dot.rec_len = dirent_actual_len(1);\n    memcpy(dot.name, \".\", 1); dot.name[1] = '\\0';\n    dirent_write_to_buf(dir_data, 0, &dot);\n    /* '..' entry â€” points to parent; owns rest of block */\n    dirent_t dotdot = {\n        .inode_num = parent_ino,\n        .name_len  = 2,\n        .file_type = FT_DIR,\n    };\n    uint16_t dot_actual = dirent_actual_len(1);\n    dotdot.rec_len = BLOCK_SIZE - dot_actual;  /* owns remaining space */\n    memcpy(dotdot.name, \"..\", 2); dotdot.name[2] = '\\0';\n    dirent_write_to_buf(dir_data, dot_actual, &dotdot);\n    if (write_block(fd, (uint32_t)data_blk, dir_data) != 0) return -EIO;\n    /* Step 4: Initialize and write the new directory inode */\n    inode_t new_inode;\n    memset(&new_inode, 0, sizeof(new_inode));\n    new_inode.mode    = (uint16_t)(S_IFDIR | (mode & 0777));\n    new_inode.uid     = uid;\n    new_inode.gid     = gid;\n    new_inode.nlinks  = 2;          /* '.' + parent entry pointing to us */\n    new_inode.size    = BLOCK_SIZE;\n    new_inode.blocks[0] = (uint32_t)data_blk;\n    uint32_t now = (uint32_t)time(NULL);\n    new_inode.atime = new_inode.mtime = new_inode.ctime = now;\n    if (write_inode(fd, sb, (uint32_t)new_ino, &new_inode) != 0) return -EIO;\n    /* Step 5: Add entry in parent directory */\n    int r = dir_add_entry(fd, sb, parent_ino, name, (uint32_t)new_ino, FT_DIR);\n    if (r != 0) return r;\n    /* Step 6: Increment parent's nlinks (for the '..' in new dir) */\n    if (read_inode(fd, sb, parent_ino, &parent_inode) != 0) return -EIO;\n    parent_inode.nlinks++;\n    parent_inode.ctime = (uint32_t)time(NULL);\n    if (write_inode(fd, sb, parent_ino, &parent_inode) != 0) return -EIO;\n    return new_ino;\n}\n```\n---\n## `rmdir`: Removing a Directory\n`rmdir` is the inverse of `mkdir`, but with a critical safety check: **a directory can only be removed if it is empty**. \"Empty\" means it contains exactly two entries: `.` and `..`. Any additional entry â€” file, subdirectory, or anything else â€” means `rmdir` must fail with `ENOTEMPTY`.\n[[EXPLAIN:posix-rmdir-atomicity-â€”-why-rmdir-cannot-be-interrupted-and-leave-orphaned-inodes|POSIX rmdir atomicity â€” why rmdir is atomic in the kernel and what happens if it isn't]]\n```c\n/*\n * Check if a directory is empty (contains only '.' and '..').\n * Returns true if empty, false otherwise.\n */\nstatic bool dir_is_empty(int fd, const inode_t *dir_inode) {\n    uint8_t buf[BLOCK_SIZE];\n    for (int i = 0; i < N_DIRECT; i++) {\n        if (dir_inode->blocks[i] == 0) continue;\n        if (read_block(fd, dir_inode->blocks[i], buf) != 0) return false;\n        uint16_t offset = 0;\n        while (offset + DIRENT_HEADER_SIZE <= BLOCK_SIZE) {\n            dirent_t de;\n            uint16_t advance = dirent_read_from_buf(buf, offset, &de);\n            if (advance == 0) break;\n            if (de.inode_num != 0) {\n                /* Found a real entry â€” check if it's '.' or '..' */\n                bool is_dot    = (de.name_len == 1 && de.name[0] == '.');\n                bool is_dotdot = (de.name_len == 2 && de.name[0] == '.' && de.name[1] == '.');\n                if (!is_dot && !is_dotdot) {\n                    return false;    /* non-empty: found a real entry */\n                }\n            }\n            offset += advance;\n        }\n    }\n    return true;\n}\n/*\n * Remove an empty directory.\n *\n * parent_ino: inode number of the parent directory\n * name:       name of the directory to remove\n *\n * Returns 0 on success, -ENOTEMPTY if directory has entries,\n * -ENOENT if not found, negative errno on error.\n */\nint fs_rmdir(int fd, superblock_t *sb,\n             uint32_t parent_ino, const char *name) {\n    /* Cannot remove '.' or '..' */\n    if (strcmp(name, \".\") == 0 || strcmp(name, \"..\") == 0) return -EINVAL;\n    /* Resolve the target directory */\n    inode_t parent_inode;\n    if (read_inode(fd, sb, parent_ino, &parent_inode) != 0) return -EIO;\n    int target_ino = dir_lookup(fd, sb, &parent_inode, name);\n    if (target_ino == 0) return -ENOENT;\n    if (target_ino < 0) return target_ino;\n    inode_t target_inode;\n    if (read_inode(fd, sb, (uint32_t)target_ino, &target_inode) != 0) return -EIO;\n    if (!S_ISDIR(target_inode.mode)) return -ENOTDIR;\n    /* Safety check: must be empty */\n    if (!dir_is_empty(fd, &target_inode)) return -ENOTEMPTY;\n    /* Remove the entry from parent (this also decrements target's nlinks via remove_entry) */\n    /* But wait â€” we need to handle nlinks carefully for directories. The target directory\n     * has nlinks=2 normally (parent entry + '.' self-reference). We also need to decrement\n     * parent's nlinks for the lost '..' reference. Let's do this manually. */\n    /* Step 1: Remove the name entry from parent directory.\n     * We bypass dir_remove_entry's automatic nlinks decrement and do it manually\n     * to also handle the parent's nlinks. */\n    /* Find and zero the entry in parent's blocks */\n    uint8_t buf[BLOCK_SIZE];\n    bool found = false;\n    for (int i = 0; i < N_DIRECT && !found; i++) {\n        if (parent_inode.blocks[i] == 0) continue;\n        if (read_block(fd, parent_inode.blocks[i], buf) != 0) return -EIO;\n        uint16_t offset = 0, prev_offset = 0;\n        while (offset + DIRENT_HEADER_SIZE <= BLOCK_SIZE) {\n            dirent_t de;\n            uint16_t advance = dirent_read_from_buf(buf, offset, &de);\n            if (advance == 0) break;\n            if (de.inode_num == (uint32_t)target_ino &&\n                de.name_len == strlen(name) &&\n                memcmp(de.name, name, de.name_len) == 0) {\n                /* Merge into previous or zero */\n                if (offset == 0) {\n                    uint32_t zero = 0;\n                    memcpy(buf + offset, &zero, 4);\n                } else {\n                    dirent_t prev_de;\n                    dirent_read_from_buf(buf, prev_offset, &prev_de);\n                    prev_de.rec_len += de.rec_len;\n                    dirent_write_to_buf(buf, prev_offset, &prev_de);\n                }\n                write_block(fd, parent_inode.blocks[i], buf);\n                found = true;\n                break;\n            }\n            if (de.inode_num != 0) prev_offset = offset;\n            offset += advance;\n        }\n    }\n    if (!found) return -ENOENT;\n    /* Step 2: Decrement parent's nlinks (lost the '..' reference from removed dir) */\n    if (read_inode(fd, sb, parent_ino, &parent_inode) != 0) return -EIO;\n    if (parent_inode.nlinks > 0) parent_inode.nlinks--;\n    parent_inode.mtime = parent_inode.ctime = (uint32_t)time(NULL);\n    if (write_inode(fd, sb, parent_ino, &parent_inode) != 0) return -EIO;\n    /* Step 3: Free the target directory inode and its data blocks */\n    return free_inode(fd, sb, (uint32_t)target_ino);\n}\n```\n---\n## Hard Links: One File, Many Names\n\n![Hard Links and Link Count â€” Visual Proof](./diagrams/diag-m3-link-count.svg)\n\nThe `link()` syscall creates a hard link â€” a new directory entry pointing to an *existing* inode. No data is copied. No new inode is created. Just one new name that references the same inode, and that inode's `nlinks` counter increments by one.\n```c\n/*\n * Create a hard link.\n * Adds 'new_name' in 'dir_ino' pointing to the inode at 'target_path'.\n *\n * Rules:\n *  - Cannot hard link a directory (would create cycles, break tree structure)\n *  - target inode must exist\n *  - new_name must not already exist in dir_ino\n *\n * Returns 0 on success, negative errno on failure.\n */\nint fs_link(int fd, superblock_t *sb,\n            uint32_t target_ino, uint32_t dir_ino, const char *new_name) {\n    /* Load target inode */\n    inode_t target_inode;\n    if (read_inode(fd, sb, target_ino, &target_inode) != 0) return -EIO;\n    /* Hard links to directories are forbidden â€” would create cycles */\n    if (S_ISDIR(target_inode.mode)) return -EPERM;\n    /* Check nlinks won't overflow (uint16_t max = 65535) */\n    if (target_inode.nlinks >= 65535) return -EMLINK;\n    /* Add the new directory entry */\n    uint8_t file_type = S_ISREG(target_inode.mode) ? FT_REG_FILE : FT_UNKNOWN;\n    int r = dir_add_entry(fd, sb, dir_ino, new_name, target_ino, file_type);\n    if (r != 0) return r;\n    /* Increment target inode's nlinks */\n    target_inode.nlinks++;\n    target_inode.ctime = (uint32_t)time(NULL);\n    return write_inode(fd, sb, target_ino, &target_inode);\n}\n```\nThe prohibition on hard-linking directories is a fundamental rule of Unix filesystems. If you could hard-link a directory, you could create:\n```\nmkdir A\nlink A A/loop   # A contains an entry 'loop' pointing to A itself\n```\nNow `A/loop/loop/loop/...` is an infinite descent. `find /`, `du /`, `fsck` â€” every tool that walks the directory tree would loop forever. The kernel forbids it at the syscall level (`link()` returns `EPERM` for directories). The exception: `mkdir` itself creates `.` and `..`, which *are* directory hard links â€” but the kernel treats these specially and breaks the cycle by knowing that `..` from root points to root.\n### `unlink()`: Removing a File\n`unlink()` removes a directory entry (just like `remove_entry`). It is the complement to `link()`:\n```c\n/*\n * Remove a file (not a directory) from a directory.\n * Decrements nlinks; frees inode if nlinks reaches 0.\n *\n * Use fs_rmdir for directories.\n */\nint fs_unlink(int fd, superblock_t *sb,\n              uint32_t dir_ino, const char *name) {\n    inode_t dir_inode;\n    if (read_inode(fd, sb, dir_ino, &dir_inode) != 0) return -EIO;\n    int target_ino = dir_lookup(fd, sb, &dir_inode, name);\n    if (target_ino == 0) return -ENOENT;\n    if (target_ino < 0) return target_ino;\n    /* Verify it's not a directory */\n    inode_t target_inode;\n    if (read_inode(fd, sb, (uint32_t)target_ino, &target_inode) != 0) return -EIO;\n    if (S_ISDIR(target_inode.mode)) return -EISDIR;   /* use rmdir instead */\n    /* dir_remove_entry handles nlinks decrement and inode freeing */\n    return dir_remove_entry(fd, sb, dir_ino, name);\n}\n```\n---\n## The `.` and `..` Contract\nThe `.` and `..` entries are real directory entries stored in real data blocks. They are **not** generated on-the-fly by the kernel. Let's verify this claim by looking at what we write during `mkfs` and `mkdir`:\n- **`.`**: inode_num = this directory's own inode number, name = \".\"\n- **`..`**: inode_num = parent directory's inode number, name = \"..\"\nFor the root directory specifically, **`..` points to itself** â€” root's parent is root. This creates a natural base case for path traversal algorithms that follow `..` chains: when you reach a node where `.` and `..` are the same inode, you are at the root.\n```c\n/* Verify the '.' entry in a directory block is correct */\nint verify_dot_entries(int fd, const superblock_t *sb,\n                       uint32_t dir_ino, uint32_t expected_parent_ino) {\n    inode_t dir_inode;\n    if (read_inode(fd, sb, dir_ino, &dir_inode) != 0) return -EIO;\n    if (!S_ISDIR(dir_inode.mode)) return -ENOTDIR;\n    if (dir_inode.blocks[0] == 0) return -EINVAL;   /* no data block */\n    uint8_t buf[BLOCK_SIZE];\n    if (read_block(fd, dir_inode.blocks[0], buf) != 0) return -EIO;\n    /* First entry must be '.' pointing to self */\n    dirent_t dot;\n    uint16_t advance = dirent_read_from_buf(buf, 0, &dot);\n    if (advance == 0) return -EINVAL;\n    if (dot.inode_num != dir_ino) {\n        fprintf(stderr, \"CORRUPT: '.' entry in inode %u points to %u (expected %u)\\n\",\n                dir_ino, dot.inode_num, dir_ino);\n        return -EINVAL;\n    }\n    if (dot.name_len != 1 || dot.name[0] != '.') {\n        fprintf(stderr, \"CORRUPT: first entry in inode %u is not '.'\\n\", dir_ino);\n        return -EINVAL;\n    }\n    /* Second entry must be '..' pointing to parent */\n    dirent_t dotdot;\n    dirent_read_from_buf(buf, advance, &dotdot);\n    if (dotdot.inode_num != expected_parent_ino) {\n        fprintf(stderr, \"CORRUPT: '..' entry in inode %u points to %u (expected %u)\\n\",\n                dir_ino, dotdot.inode_num, expected_parent_ino);\n        return -EINVAL;\n    }\n    if (dotdot.name_len != 2 || \n        dotdot.name[0] != '.' || dotdot.name[1] != '.') {\n        fprintf(stderr, \"CORRUPT: second entry in inode %u is not '..'\\n\", dir_ino);\n        return -EINVAL;\n    }\n    return 0;   /* valid */\n}\n```\n---\n## `readdir`: Listing a Directory\nFUSE (Milestone 5) calls `readdir` for every `ls` command. Here is the core implementation:\n```c\n/*\n * Iterate over all entries in a directory.\n * Calls callback for each non-deleted entry (including '.' and '..').\n *\n * Used by FUSE's readdir callback and by dir_is_empty.\n */\ntypedef void (*readdir_cb_t)(const char *name, uint32_t inode_num,\n                              uint8_t file_type, void *userdata);\nint dir_readdir(int fd, const superblock_t *sb,\n                uint32_t dir_ino, readdir_cb_t cb, void *userdata) {\n    inode_t dir_inode;\n    if (read_inode(fd, sb, dir_ino, &dir_inode) != 0) return -EIO;\n    if (!S_ISDIR(dir_inode.mode)) return -ENOTDIR;\n    uint8_t buf[BLOCK_SIZE];\n    for (int i = 0; i < N_DIRECT; i++) {\n        if (dir_inode.blocks[i] == 0) continue;\n        if (read_block(fd, dir_inode.blocks[i], buf) != 0) return -EIO;\n        uint16_t offset = 0;\n        while (offset + DIRENT_HEADER_SIZE <= BLOCK_SIZE) {\n            dirent_t de;\n            uint16_t advance = dirent_read_from_buf(buf, offset, &de);\n            if (advance == 0) break;\n            if (de.inode_num != 0) {\n                cb(de.name, de.inode_num, de.file_type, userdata);\n            }\n            offset += advance;\n        }\n    }\n    return 0;\n}\n```\n> **Hardware Soul â€” `readdir` at Speed**:\n> A directory with 1,000 entries across 3 data blocks (three 4KB reads) takes ~300Î¼s on a cold SSD, ~30ns from L1 cache. The sequential access pattern is optimal for hardware prefetchers: the CPU sees a stride-0 access pattern through the 4KB block and prefetches the next cache lines automatically. For warm-cache `ls` performance, the bottleneck is almost never the directory block reads â€” it's the subsequent `stat()` calls, each of which reads a different inode block (likely random access into the inode table).\n---\n## Validation: Testing the Directory Layer\n```c\nvoid test_directory_layer(int fd, superblock_t *sb) {\n    printf(\"\\n=== Directory Layer Tests ===\\n\");\n    uint32_t root_ino = sb->root_inode;\n    /* Test 1: mkdir a subdirectory */\n    int user_ino = fs_mkdir(fd, sb, root_ino, \"user\", 0755, 1000, 1000);\n    assert(user_ino > 0);\n    printf(\"OK: mkdir 'user' â†’ inode %d\\n\", user_ino);\n    /* Test 2: path resolution */\n    int resolved = path_resolve(fd, sb, \"/user\", root_ino, root_ino);\n    assert(resolved == user_ino);\n    printf(\"OK: path_resolve('/user') = %d\\n\", resolved);\n    /* Test 3: nested mkdir */\n    int projects_ino = fs_mkdir(fd, sb, (uint32_t)user_ino, \"projects\",\n                                 0755, 1000, 1000);\n    assert(projects_ino > 0);\n    int nested = path_resolve(fd, sb, \"/user/projects\", root_ino, root_ino);\n    assert(nested == projects_ino);\n    printf(\"OK: nested path resolution works\\n\");\n    /* Test 4: verify parent nlinks incremented */\n    inode_t user_inode;\n    read_inode(fd, sb, (uint32_t)user_ino, &user_inode);\n    assert(user_inode.nlinks == 3);  /* '.' + /user entry + /user/projects/.. */\n    printf(\"OK: parent nlinks = %u (correct)\\n\", user_inode.nlinks);\n    /* Test 5: '.' and '..' entries */\n    assert(verify_dot_entries(fd, sb, (uint32_t)projects_ino,\n                               (uint32_t)user_ino) == 0);\n    printf(\"OK: '.' and '..' entries verified\\n\");\n    /* Test 6: duplicate name rejected */\n    assert(fs_mkdir(fd, sb, root_ino, \"user\", 0755, 0, 0) == -EEXIST);\n    printf(\"OK: duplicate mkdir rejected with EEXIST\\n\");\n    /* Test 7: rmdir empty directory */\n    int empty_ino = fs_mkdir(fd, sb, (uint32_t)user_ino, \"empty\",\n                              0755, 1000, 1000);\n    assert(empty_ino > 0);\n    assert(fs_rmdir(fd, sb, (uint32_t)user_ino, \"empty\") == 0);\n    /* Verify inode is now free */\n    uint8_t ibmap[BLOCK_SIZE];\n    read_block(fd, INODE_BITMAP_BLOCK, ibmap);\n    assert(!bitmap_test(ibmap, (uint32_t)empty_ino - 1));\n    printf(\"OK: rmdir empty directory, inode freed\\n\");\n    /* Test 8: rmdir non-empty directory fails */\n    assert(fs_rmdir(fd, sb, root_ino, \"user\") == -ENOTEMPTY);\n    printf(\"OK: rmdir non-empty directory rejected\\n\");\n    /* Test 9: ENOENT for missing path */\n    assert(path_resolve(fd, sb, \"/nonexistent\", root_ino, root_ino) == -ENOENT);\n    printf(\"OK: path_resolve nonexistent returns ENOENT\\n\");\n    /* Test 10: Hard link */\n    /* Create a file first (borrow from Milestone 4 â€” just allocate and init an inode) */\n    int file_ino = alloc_inode(fd, sb);\n    assert(file_ino > 0);\n    inode_t file_inode;\n    inode_init_file(&file_inode, 0644, 1000, 1000);\n    write_inode(fd, sb, (uint32_t)file_ino, &file_inode);\n    dir_add_entry(fd, sb, root_ino, \"original\", (uint32_t)file_ino, FT_REG_FILE);\n    file_inode.nlinks = 1;\n    write_inode(fd, sb, (uint32_t)file_ino, &file_inode);\n    assert(fs_link(fd, sb, (uint32_t)file_ino, root_ino, \"hardlink\") == 0);\n    read_inode(fd, sb, (uint32_t)file_ino, &file_inode);\n    assert(file_inode.nlinks == 2);\n    printf(\"OK: hard link created, nlinks = %u\\n\", file_inode.nlinks);\n    /* Test 11: Unlink one, inode survives */\n    assert(fs_unlink(fd, sb, root_ino, \"original\") == 0);\n    read_inode(fd, sb, (uint32_t)file_ino, &file_inode);\n    assert(file_inode.nlinks == 1);\n    printf(\"OK: unlink one link, nlinks = %u (inode survives)\\n\", file_inode.nlinks);\n    /* Test 12: Unlink last link, inode freed */\n    assert(fs_unlink(fd, sb, root_ino, \"hardlink\") == 0);\n    read_block(fd, INODE_BITMAP_BLOCK, ibmap);\n    assert(!bitmap_test(ibmap, (uint32_t)file_ino - 1));\n    printf(\"OK: last unlink frees inode\\n\");\n    printf(\"=== All Directory Tests Passed ===\\n\\n\");\n}\n```\n---\n## Concurrency Warning: Races in Directory Modification\nIf multiple threads (as in FUSE with `default_permissions` and multi-threaded mode) concurrently modify the same directory, you have a race condition. Consider:\n```\nThread A: dir_lookup(\"file\")    â†’ not found (0)\nThread B: dir_add_entry(\"file\") â†’ creates entry\nThread A: dir_add_entry(\"file\") â†’ creates DUPLICATE entry!\n```\nThe name-uniqueness check in `dir_add_entry` and the lookup are not atomic. In Milestone 5, you will add a per-directory mutex or a global filesystem lock. For now, document this limitation and test only single-threaded:\n```c\n/* \n * Thread safety: All directory operations on a given directory inode\n * must be serialized. The caller (FUSE callbacks in Milestone 5) is\n * responsible for holding the appropriate lock before calling these functions.\n * A simple approach: one global pthread_mutex_t protecting all FS state.\n * A better approach: per-inode read-write locks (readers can share, writers exclusive).\n */\n```\n[[EXPLAIN:directory-locking-strategies-â€”-global-lock-vs-per-inode-vs-hierarchical-locking|Directory locking strategies â€” global lock vs. per-inode vs. hierarchical locking for concurrent filesystem access]]\n---\n## Knowledge Cascade: One Directory, Ten Worlds\nYou have built what appears to be a simple name-to-inode lookup table. But the ideas behind it permeate systems across every domain.\n### Symbolic Links vs. Hard Links: Now Obvious\nWith directory entries fully understood, the hard link vs. symbolic link distinction resolves itself completely.\n**Hard link**: a new directory entry pointing to an *existing inode*. `link(\"/existing\", \"/alias\")` writes one new `dirent_t` record. One inode, two names. The inode's `nlinks` increments. Delete either name â€” the inode survives. Delete both â€” the inode is freed. No indirection, no path lookup at the target, no dangling reference possible. The alias and the original are truly identical in the filesystem's view.\n**Symbolic link** [[EXPLAIN:symbolic-links-â€”-files-containing-a-target-path-string-resolved-at-access-time|Symbolic links â€” files containing a target path string, resolved at every access]]: a new inode whose `mode` is `S_IFLNK` and whose data block contains a *path string*. `symlink(\"/existing\", \"/symlink\")` creates a new inode (new `nlinks=1`), writes the string `/existing` into its data block, and creates a directory entry pointing to that inode. When the kernel encounters `S_IFLNK` during path resolution, it reads the link's data block, gets the path string, and re-starts path resolution from scratch with that string. The target inode's `nlinks` is NOT incremented â€” the symlink has no knowledge of the target inode at all, only the target *path*.\nThis means:\n- Delete the original: hard links still work (shared inode survives), symlinks break (\"dangling symlink\")\n- Move the original to a different path: hard links still work, symlinks break\n- Symlinks can cross filesystem boundaries (the target path is just a string), hard links cannot (inode numbers are filesystem-local)\n- Symlinks can point to directories; hard links to directories are forbidden\nNow you see why: hard links are inode-level operations (increment `nlinks`, add `dirent_t`). Symlinks are inode-creation operations with a path payload.\n### DNS Resolution: The Same Algorithm\nThe path resolution algorithm you just implemented â€” walk a hierarchy component by component, each level stored at a different \"authority\" â€” is structurally identical to [[EXPLAIN:dns-resolution-â€”-recursive-hierarchical-name-lookup-from-root-to-authoritative-server|DNS resolution â€” recursive hierarchical name lookup]].\n`/home/user/file.txt` â†’ resolve:\n- `/` (root) â†’ scan for `home` â†’ inode 14\n- inode 14 â†’ scan for `user` â†’ inode 82\n- inode 82 â†’ scan for `file.txt` â†’ inode 1041\n`www.example.com.` â†’ resolve:\n- `.` (root nameservers) â†’ query for `com.` â†’ NS record for com. authority\n- `com.` authority â†’ query for `example.com.` â†’ NS record for example.com. authority\n- `example.com.` authority â†’ query for `www.example.com.` â†’ A record: 93.184.216.34\nIn both cases: hierarchical namespace, each component stored at a specific authority, walk from root to leaf. The difference is that filesystem lookup is local (disk reads), while DNS is distributed (network queries). The BIND nameserver's zone file format even looks like a directory entry: `(name, class, type, rdata)` where `rdata` is the \"inode number\" (IP address, or pointer to next authority).\nThis cross-domain connection is not superficial. DNS negative caching (caching NXDOMAIN responses to avoid re-querying for missing entries) is the exact analogue of the Linux VFS dcache caching ENOENT results. Both systems solve the same \"frequent lookups of hierarchical names with high locality\" problem.\n### Container Overlay Filesystems (OverlayFS / Docker)\n[[EXPLAIN:overlayfs-â€”-union-mount-filesystem-that-layers-directories-for-copy-on-write-container-images|OverlayFS â€” union mount filesystem layering directories for Docker container images]]\nDocker's layers are a direct consequence of understanding directory entries as data. When you build a Docker image:\n```\nLayer 1 (base OS):       /bin/bash, /etc/hosts, /lib/...\nLayer 2 (your app):      /app/server, /app/config.json\nLayer 3 (runtime write): /tmp/cache, /var/log/app.log\n```\nOverlayFS merges these by stacking directory entry tables. The \"upper\" layer's entries take precedence. A file deleted in an upper layer is represented by a **whiteout entry** â€” a special directory entry (in Linux: a character device with major/minor 0,0, or an entry with the `.wh.` prefix) that signals \"this name is deleted in this layer.\" Any lookup that finds a whiteout stops and returns ENOENT, even if a lower layer has an entry with the same name.\nThis is precisely your `inode_num = 0` sentinel for deleted entries â€” a \"whiteout\" marker in a specific layer's directory block. The \"union mount\" view is the result of scanning layers in order and applying precedence rules to the merged list of directory entries.\nUnderstanding your `dirent_t` with `inode_num = 0` for deleted slots is understanding Docker's layer isolation model at the filesystem level.\n### Database Index Lookups: The Linear Scan Problem\nYou have just implemented linear scan directory lookup: iterate every entry until you find the name. For a directory with 10 entries this is fast. For a directory with 100,000 entries (a common pattern in `/var/spool/mail` or large upload directories), this is catastrophically slow.\next2 uses linear scan. ext4 introduced `htree` directories: when a directory grows beyond a threshold, its entry layout switches from the flat linear format to a **B-tree indexed by the hash of the filename**. The root node of the B-tree lives in the first directory block. Lookups compute `hash(name)`, walk the B-tree to find the leaf block containing entries with that hash, then scan the leaf block (small because hash-identical names are rare).\nThis is **exactly** the difference between a sequential scan and a hash index in a database. A table with no index requires full sequential scan for point lookups. Adding a hash index converts that to O(1). ext4's `dir_index` feature flag marks filesystems where this optimization is active.\nThe performance numbers: linear scan at 100,000 entries in a single directory costs ~100,000 memory comparisons, ~24 block reads (~2.4ms from SSD, ~240ms from spinning disk per lookup). The B-tree index converts this to ~3 block reads per lookup (~300Î¼s from SSD). At 100 lookups/second, the difference is 240ms vs. 30ms â€” an 8Ã— throughput improvement.\n### Git Tree Objects: Directories All The Way Down\n[[EXPLAIN:git-objects-â€”-content-addressable-store-of-blobs-trees-commits-and-tags|Git objects â€” content-addressable store of blobs (file data), trees (directories), commits, and tags]]\nGit's internal object model is a direct implementation of the same inode/directory abstraction you just built:\n| Git Concept | Filesystem Equivalent |\n|---|---|\n| **Blob object** | File data (data blocks) |\n| **Tree object** | Directory entry list (`dirent_t[]` array) |\n| **Commit object** | Inode for a snapshot (mode, owner, size â†’ author, date, message; blocks[0] â†’ root tree SHA) |\n| **SHA-256 hash** | Inode number (unique identifier for the content) |\nA Git tree object contains entries: `(mode, name, SHA)` â€” where mode is the file type, name is the filename, and SHA is the content hash of the blob or subtree. This is your `dirent_t` with `(file_type, name, inode_num)` where `inode_num` is replaced by a content hash.\nA Git commit is an inode with a tree pointer (`blocks[0]` â†’ root tree) and metadata (author, timestamp, message). The filesystem hierarchy encoded in Git is navigated exactly like your directory tree: `git show HEAD:src/main.c` resolves `HEAD` â†’ commit object â†’ root tree â†’ `src` subtree â†’ `main.c` blob. Four object lookups, identical to your 4-hop path resolution.\nUnderstanding this connection means understanding why `git checkout` is fast (it reads blobs from the object store and writes them to the working tree â€” two filesystem-level operations), why `git status` can be slow in large repos (it must hash every file to compare with the index), and why `git bisect` works without a database (the commit graph is navigable through object references, just like your directory tree).\n---\n## Design Decisions\n| Option | Pros | Cons | Used By |\n|---|---|---|---|\n| **Variable-length dirents with rec_len (chosen âœ“)** | Space-efficient for short names; proven format; scan-only so cache-friendly | O(n) lookup; scan required to find free space; deletion leaves holes | ext2/3/4, our implementation |\n| Fixed-size dirents (256 bytes each) | O(1) indexed access by entry number; simpler implementation | Wastes 247 bytes for a 1-char filename; common case (short names) pays for worst case | FAT32 (11-byte 8.3 names, fixed), small embedded FSes |\n| Hash-tree directory (htree) | O(1) lookup via filename hash; scales to millions of entries | Complex implementation; hash collisions need linear fallback; not crash-safe without journaling | ext4 (dir_index feature), NTFS, HFS+ |\n| B-tree directory index | Self-balancing; O(log n) worst case; handles any distribution | Complex; rebalancing on every insert/delete; overkill for < 10k entries | XFS (B-tree directories by default), ReiserFS |\nFor our purposes, variable-length linear dirents give you the correct behavior and correct on-disk format. The htree optimization is a straightforward engineering addition â€” the same `dirent_t` format is used at the leaf level, only the lookup mechanism changes.\n---\n## Before You Move On: Pitfall Checklist\n- [ ] **Name uniqueness on `add_entry`**: `dir_lookup` must be called before every `dir_add_entry`. A duplicate name causes ambiguous lookups â€” the first matching entry wins in a scan, making one of the two entries permanently unreachable.\n- [ ] **Parent nlinks on `mkdir`**: After creating a child directory, increment the parent's `nlinks` by 1. After `rmdir`, decrement it. Every subdirectory represents one `..` reference to the parent. The invariant: `parent.nlinks = 2 + number_of_child_directories`.\n- [ ] **Root's `..` points to root**: During `mkfs`, verify that `path_resolve(\"/..\")` returns `root_ino`, not an error. Root is its own parent. This is a base case for all `..` traversal.\n- [ ] **Max filename length enforced**: Every function that accepts a name parameter must check `strlen(name) <= MAX_FILENAME_LEN`. A 256-byte name silently overflows `name_len` (which is `uint8_t`, max 255) and writes garbage `rec_len` values that corrupt the directory block scan.\n- [ ] **Hard links to directories are forbidden**: `fs_link` must return `-EPERM` for `S_ISDIR` targets. Without this check, you can create filesystem cycles that loop `find` and `du` forever.\n- [ ] **`rmdir` only on empty directories**: `dir_is_empty` must be called before any removal. Check that it skips deleted entries (`inode_num == 0`) correctly â€” a block with only deleted entries should be considered empty.\n- [ ] **Bitmap-before-inode write order**: In `mkdir`, write the bitmap marking the new inode and data block as used *before* writing the new inode to the inode table. If you crash between the two writes, a used-but-uninitiated inode (bitmap=1, inode data=garbage) is detectable by `fsck` as an orphan. A valid-inode-pointing-to-a-free-block (inode written, bitmap not yet updated) is a double-allocation bug.\n- [ ] **`ctime` updates on all inode modifications**: `dir_add_entry` and `dir_remove_entry` must update `dir_inode.ctime` (and `mtime`). `fs_link` must update `target_inode.ctime`. These timestamps are used by `rsync` for change detection.\n- [ ] **`strtok_r` not `strtok`**: Path resolution uses `strtok_r` (reentrant version). `strtok` uses a global static pointer and is not thread-safe. In the FUSE multi-threaded environment (Milestone 5), using `strtok` causes intermittent path resolution corruption that is nearly impossible to debug.\n---\n## What You've Built and What Comes Next\n\n![Filesystem Atlas â€” Satellite Map (Home Base)](./diagrams/diag-L0-satellite-map.svg)\n\nYou have collapsed the illusion of the \"folder.\" A directory is a file. Its data blocks are a linked sequence of `(name, inode_number)` records. The entire filesystem tree emerges from files pointing to other files. Path resolution is a mechanical scan: read a block, find the name, follow the inode number, repeat. The `.` and `..` entries that make `cd ..` work are stored as ordinary bytes in ordinary data blocks.\nThe elegance is complete: every part of the filesystem â€” the superblock (block 0), the bitmaps (blocks 1â€“2), the inode table, the journal, and the directory tree â€” is made from the same substrate: 4KB blocks. The naming system that makes the tree navigable is itself stored *in* the tree.\nBut look at what's missing: you can create directories and add entries, but you cannot yet read or write actual file data. A regular file (`S_IFREG`) whose `blocks[]` array points to data blocks containing bytes is not yet implemented. In Milestone 4, you will build `read(inode, offset, length)` and `write(inode, offset, data)` â€” the operations that traverse the block pointer tree from Milestone 2 and move data between the application and disk. You will implement `truncate` (shrinking and extending files), handle the read-modify-write problem for partial block writes, and support sparse files where holes read as zeros.\nThe filesystem is almost complete. Two milestones ago, you had a flat block array. Now you have a navigable tree of named files. The blocks are starting to look like a filesystem.\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: filesystem-m4 -->\n<!-- MS_ID: filesystem-m4 -->\n# Milestone 4: File Read/Write Operations\n## The Lie Every Developer Believes About File Writes\nYou have written file I/O code hundreds of times. You have called `write(fd, buf, 100)` and trusted that those 100 bytes landed at the right place on disk. Your mental model is reasonable: files are byte-addressable, persistent arrays. You write to offset 5000, bytes 5000â€“5099 change. Simple.\nNow consider what your hardware actually sees when you ask it to change byte 5001.\nThe disk does not know what byte 5001 is. The disk only understands one unit of transfer: a block. Four kilobytes. The disk will not read 1 byte, will not write 1 byte, will not even acknowledge the concept. To change byte 5001 in a file, you must:\n1. **Read** the entire 4KB block containing byte 5001 into RAM\n2. **Modify** the single byte you care about, in memory\n3. **Write** the entire 4KB block back to disk\nThis is a **read-modify-write (RMW) cycle**. And it is not an implementation quirk you can engineer around â€” it is the fundamental physics of block storage. Every file write, no matter how small, triggers this cycle if the write does not align perfectly to block boundaries.\nIt gets worse. Your file's data does not live at a fixed disk location. It lives somewhere pointed to by the inode's block pointer tree â€” the structure you built in Milestone 2. So before you can even begin the RMW cycle, you must translate the file offset into a disk block number by traversing that tree. Then perform the RMW. Then update the inode if the file grew. Then update timestamps.\nWhat looks like \"write 100 bytes\" is actually a multi-step dance involving potentially 4â€“6 disk operations. This is the gap between the POSIX abstraction and the hardware reality. This milestone is where you close that gap â€” by building the machinery that makes the abstraction work, understanding exactly what it costs, and seeing why the rest of systems programming (databases, SSDs, buffer caches) exists largely to compensate for this fundamental mismatch.\n\n![Write â€” The Read-Modify-Write Cycle](./diagrams/diag-m4-write-rmw.svg)\n\n---\n## The Fundamental Tension: Byte-Addressable API, Block-Addressable Storage\nThe POSIX file API is byte-oriented:\n- `read(fd, buf, n)` â€” read exactly `n` bytes from the current position\n- `write(fd, buf, n)` â€” write exactly `n` bytes to the current position\n- `lseek(fd, offset, SEEK_SET)` â€” position to any byte offset\nThe storage hardware is block-oriented:\n- Transfer unit: 4,096 bytes (or 512 bytes at the sector level)\n- Operations: read block N, write block N\n- No concept of partial block access\nThe filesystem is the translator. It must implement the byte-addressable API entirely on top of block-level primitives. Every operation must be decomposed into:\n1. **Which block(s) does this byte range touch?** (offset arithmetic)\n2. **Where is each of those blocks on disk?** (pointer tree traversal from Milestone 2)\n3. **Which RMW cycles are needed?** (for writes that don't fill entire blocks)\n4. **Which new blocks need allocation?** (for writes that extend the file)\n5. **What metadata needs updating?** (inode size, timestamps)\nThe concrete numbers driving this tension:\n- Writing 1 byte costs: 1 block read (100Î¼s SSD) + 1 block write (100Î¼s SSD) = **200Î¼s minimum**\n- A purely sequential 4KB-aligned write costs: 1 block write = **100Î¼s**\n- The ratio: a 1-byte random write is 2Ã— more expensive than a 4KB write, even though it transfers 4096Ã— less data\nThis is why database designers lose sleep over random I/O patterns. This is why SSDs use write buffers. This is why the Linux page cache exists. Every optimization in every storage system is ultimately trying to avoid unnecessary RMW cycles.\n---\n## `create_file`: Bringing a File Into Existence\nBefore you can read or write a file, it must exist. `create_file` bridges Milestone 3's directory layer and Milestone 2's inode layer into a single coherent operation.\n\n![create_file â€” Full Operation Trace](./diagrams/diag-m4-create-file-trace.svg)\n\nThe operation is a composition of primitives you have already built:\n1. Verify the parent directory exists and does not already contain `name`\n2. Allocate a new inode from the inode bitmap\n3. Initialize the inode (regular file, `nlinks = 1`, `size = 0`, all block pointers zero)\n4. Write the initialized inode to the inode table on disk\n5. Add a directory entry in the parent directory pointing to the new inode\n6. Return the new inode number\nNotice that step 6 returns the inode number, not a file descriptor. Your filesystem layer operates on inode numbers directly. The FUSE integration in Milestone 5 will translate between POSIX file descriptors and inode numbers.\n```c\n#include <string.h>\n#include <time.h>\n#include <errno.h>\n/*\n * Create a new regular file in a parent directory.\n *\n * fd:         open file descriptor of the disk image\n * sb:         superblock (updated in place for free counts)\n * parent_ino: inode number of the parent directory\n * name:       filename to create (single component, not a full path)\n * mode:       permission bits; will be OR'd with S_IFREG\n * uid, gid:   owner\n *\n * Returns the new file's inode number on success, negative errno on failure.\n */\nint fs_create_file(int fd, superblock_t *sb,\n                   uint32_t parent_ino, const char *name,\n                   uint16_t mode, uint16_t uid, uint16_t gid) {\n    /* Validate parent */\n    inode_t parent_inode;\n    if (read_inode(fd, sb, parent_ino, &parent_inode) != 0) return -EIO;\n    if (!S_ISDIR(parent_inode.mode)) return -ENOTDIR;\n    /* Check name length and uniqueness */\n    size_t name_len = strlen(name);\n    if (name_len == 0 || name_len > MAX_FILENAME_LEN) return -EINVAL;\n    if (dir_lookup(fd, sb, &parent_inode, name) > 0) return -EEXIST;\n    /* Allocate new inode */\n    int new_ino = alloc_inode(fd, sb);\n    if (new_ino < 0) return -ENOSPC;\n    /* Initialize inode for a regular empty file */\n    inode_t new_inode;\n    memset(&new_inode, 0, sizeof(new_inode));\n    new_inode.mode   = (uint16_t)(S_IFREG | (mode & 0777));\n    new_inode.uid    = uid;\n    new_inode.gid    = gid;\n    new_inode.nlinks = 1;\n    new_inode.size   = 0;       /* empty file â€” no data yet */\n    uint32_t now = (uint32_t)time(NULL);\n    new_inode.atime = new_inode.mtime = new_inode.ctime = now;\n    /* All block pointers start as 0 (null) â€” no blocks allocated yet */\n    /* Write inode to disk */\n    if (write_inode(fd, sb, (uint32_t)new_ino, &new_inode) != 0) {\n        /* Roll back inode allocation */\n        uint8_t ibmap[BLOCK_SIZE];\n        read_block(fd, INODE_BITMAP_BLOCK, ibmap);\n        bitmap_clear(ibmap, (uint32_t)new_ino - 1);\n        write_block(fd, INODE_BITMAP_BLOCK, ibmap);\n        sb->free_inodes++;\n        return -EIO;\n    }\n    /* Add directory entry in parent */\n    int r = dir_add_entry(fd, sb, parent_ino, name,\n                          (uint32_t)new_ino, FT_REG_FILE);\n    if (r != 0) {\n        /* Best-effort cleanup: free the inode */\n        free_inode(fd, sb, (uint32_t)new_ino);\n        return r;\n    }\n    return new_ino;\n}\n```\n> **Design note**: You write the inode to disk *before* adding the directory entry. If you crash between the two writes, you have an allocated inode that no directory entry points to â€” an \"orphan.\" This is detectable and recoverable by `fsck` (it can scan all inodes and verify every allocated inode has at least one directory reference). The reverse â€” directory entry pointing to an uninitialized inode â€” is far worse, because code would follow the inode number, read garbage, and potentially corrupt the filesystem. Bitmap-before-inode, inode-before-dirent: this is the safe write ordering without journaling.\n---\n## Offset Arithmetic: The Two-Level Translation\nBefore implementing `read` and `write`, you need to deeply understand the offset-to-block translation. This is where bugs hide, where off-by-ones silently corrupt neighboring files, and where the whole system's correctness lives.\n\n![Offset-to-Block Decision Flowchart](./diagrams/diag-m4-offset-to-block-flowchart.svg)\n\nGiven a file offset (a byte position within the file), you need three things:\n1. **Block index** (`block_index = offset / BLOCK_SIZE`): which logical block of the file, starting at 0\n2. **Byte offset within block** (`block_offset = offset % BLOCK_SIZE`): how far into that block\n3. **Disk block number**: obtained by calling `inode_get_block(fd, inode, block_index * BLOCK_SIZE, &disk_block_num)` â€” the function you built in Milestone 2\nLet's trace a concrete example. A `read` starting at file offset 6,000 for 5,000 bytes:\n```\nFile offset 6000:\n  block_index   = 6000 / 4096 = 1\n  block_offset  = 6000 % 4096 = 1904\nBytes [6000 .. 8191] are in block index 1, starting at position 1904\n  â†’ 4096 - 1904 = 2192 bytes available in this block\nBytes [8192 .. 10999] are in block index 2, starting at position 0\n  â†’ remaining 2808 bytes of the 5000-byte request\nSo this 5000-byte read requires two block reads.\n```\n\n![read(inode, offset=6000, length=5000) â€” Complete Data Walk](./diagrams/diag-m4-read-trace.svg)\n\nThe general algorithm for any multi-block operation:\n```\nremaining = total_length\ncurrent_offset = start_offset\nwhile remaining > 0:\n    block_index  = current_offset / BLOCK_SIZE\n    block_offset = current_offset % BLOCK_SIZE\n    chunk_size   = min(BLOCK_SIZE - block_offset, remaining)\n    # get disk block number for block_index\n    # do block I/O using chunk_size at block_offset\n    current_offset += chunk_size\n    remaining      -= chunk_size\n```\nThis loop is the skeleton of both `read` and `write`. The difference is what you do with the block once you have it.\n---\n## `fs_read`: Reading Data Through the Pointer Tree\nReading is the simpler of the two operations because it is read-only: you traverse the pointer tree, fetch blocks, copy data, update `atime`. No allocation, no RMW cycle.\nThe one nuance: when `inode_get_block` returns 0 (a null pointer â€” a sparse hole), you must zero-fill the output buffer for that range. No disk I/O. No allocation. Zeros come from CPU registers, not from disk.\n```c\n/*\n * Read data from a file.\n *\n * fd:       disk image file descriptor\n * sb:       superblock\n * ino:      inode number of the file to read\n * offset:   byte offset within the file to start reading\n * buf:      caller-allocated buffer to receive data\n * length:   number of bytes to read\n *\n * Returns the number of bytes actually read on success (may be less\n * than length if offset + length extends past the end of file),\n * or negative errno on error.\n */\nssize_t fs_read(int fd, superblock_t *sb,\n                uint32_t ino, uint64_t offset,\n                void *buf, size_t length) {\n    inode_t inode;\n    if (read_inode(fd, sb, ino, &inode) != 0) return -EIO;\n    if (!S_ISREG(inode.mode)) return -EINVAL;\n    /* Clamp to end of file â€” cannot read past EOF */\n    if (offset >= inode.size) return 0;\n    if (offset + length > inode.size) {\n        length = (size_t)(inode.size - offset);\n    }\n    uint8_t *out = (uint8_t *)buf;\n    size_t   remaining = length;\n    uint64_t cur_offset = offset;\n    uint8_t  block_buf[BLOCK_SIZE];\n    while (remaining > 0) {\n        /* How many bytes into the current block, and how many to copy from it */\n        uint32_t block_off  = (uint32_t)(cur_offset % BLOCK_SIZE);\n        size_t   chunk      = BLOCK_SIZE - block_off;\n        if (chunk > remaining) chunk = remaining;\n        /* Translate file offset â†’ disk block number via inode pointer tree */\n        uint32_t disk_block;\n        int r = inode_get_block(fd, &inode,\n                                cur_offset - block_off, &disk_block);\n        if (r != 0) return r;\n        if (disk_block == 0) {\n            /*\n             * Sparse hole: this block has never been written.\n             * Return zeros â€” no disk I/O needed.\n             * This is the correct POSIX behavior: holes read as zero bytes.\n             */\n            memset(out, 0, chunk);\n        } else {\n            /* Read the block from disk */\n            if (read_block(fd, disk_block, block_buf) != 0) return -EIO;\n            memcpy(out, block_buf + block_off, chunk);\n        }\n        out        += chunk;\n        cur_offset += chunk;\n        remaining  -= chunk;\n    }\n    /*\n     * Update atime.\n     * In production, use the 'relatime' heuristic (only update if atime\n     * is older than mtime/ctime) to avoid write-per-read amplification.\n     * For correctness, update unconditionally here.\n     */\n    inode.atime = (uint32_t)time(NULL);\n    write_inode(fd, sb, ino, &inode);\n    return (ssize_t)length;\n}\n```\n> **Hardware Soul â€” Where Are Those Zero Bytes From?**\n> When `disk_block == 0` and you call `memset(out, 0, chunk)`, this is a write to the user's buffer in RAM. The CPU issues store instructions; modern CPUs can zero ~64 bytes per cycle using SIMD (SSE/AVX `vpxor` + `vmovdqu`). For a 4KB sparse read, this is ~64 CPU cycles â€” under 30ns. Compare to a real disk read: ~100Î¼s on SSD. Sparse reads are **3,000Ã— faster** than real reads. This is not a quirk; it is a design choice. Holes are free to read, which is why VM disk images work efficiently even when provisioned as 100GB but containing only 2GB of real data.\n---\n## `fs_write`: The Read-Modify-Write Reality\nWriting is where the complexity lives. Three distinct cases must be handled, and they can all occur within a single `write` call:\n**Case 1: Write completely fills one or more blocks** (offset is block-aligned, length is a multiple of `BLOCK_SIZE`)\nâ†’ No RMW needed. Read zero existing content. Just allocate the block if needed and write full 4KB chunks.\n**Case 2: Write starts or ends in the middle of a block** (partial first or last block)\nâ†’ RMW required. Read the existing block content, overwrite the portion being written, write the whole block back.\n**Case 3: Write extends the file past EOF and the partial block at EOF has existing content**\nâ†’ Partial RMW: read the existing partial block (which may be partially written), zero-fill up to `BLOCK_SIZE`, write new data on top, then write back.\n\n![Write â€” The Read-Modify-Write Cycle](./diagrams/diag-m4-write-rmw.svg)\n\nThe implementation handles all three cases in a single unified loop by always reading the block before writing if the write is partial:\n```c\n/*\n * Write data to a file.\n *\n * fd:       disk image file descriptor\n * sb:       superblock (updated: free_blocks)\n * ino:      inode number of the file\n * offset:   byte offset within the file to start writing\n * buf:      data to write\n * length:   number of bytes to write\n *\n * Returns the number of bytes written on success (always equals length\n * unless a real error occurs), negative errno on failure.\n *\n * Side effects:\n *   - Allocates new data blocks as needed\n *   - Allocates indirect/double-indirect pointer blocks as needed\n *   - Updates inode.size if writing past current EOF\n *   - Updates inode.mtime and inode.ctime\n */\nssize_t fs_write(int fd, superblock_t *sb,\n                 uint32_t ino, uint64_t offset,\n                 const void *buf, size_t length) {\n    if (length == 0) return 0;\n    inode_t inode;\n    if (read_inode(fd, sb, ino, &inode) != 0) return -EIO;\n    if (!S_ISREG(inode.mode)) return -EINVAL;\n    /* Check file size limit (our inode uses uint32_t for size â†’ max ~4GB) */\n    if (offset + length > (uint64_t)UINT32_MAX) return -EFBIG;\n    const uint8_t *in  = (const uint8_t *)buf;\n    size_t   remaining = length;\n    uint64_t cur_offset = offset;\n    uint8_t  block_buf[BLOCK_SIZE];\n    while (remaining > 0) {\n        uint32_t block_off  = (uint32_t)(cur_offset % BLOCK_SIZE);\n        size_t   chunk      = BLOCK_SIZE - block_off;\n        if (chunk > remaining) chunk = remaining;\n        bool partial_write  = (block_off != 0) || (chunk < BLOCK_SIZE);\n        /* Get current disk block number for this file offset (may be 0 = hole) */\n        uint32_t disk_block;\n        int r = inode_get_block(fd, &inode,\n                                cur_offset - block_off, &disk_block);\n        if (r != 0) return r;\n        if (disk_block == 0) {\n            /* Block not yet allocated â€” allocate a new one */\n            int new_blk = alloc_block(fd, sb);\n            if (new_blk < 0) return -ENOSPC;\n            disk_block = (uint32_t)new_blk;\n            /*\n             * Record the new block number in the inode pointer tree.\n             * inode_set_block may allocate indirect/double-indirect blocks\n             * if the file offset is in those regions.\n             */\n            r = inode_set_block(fd, sb, &inode,\n                                cur_offset - block_off, disk_block);\n            if (r != 0) return r;\n            /*\n             * Zero-initialize the newly allocated block.\n             *\n             * WHY: If this is a partial write (we won't fill the entire block),\n             * we need the rest of the block to contain zeros, not garbage from\n             * whatever previously occupied this disk location.\n             *\n             * If the write IS full-block, the memset is overwritten immediately\n             * below. Slight inefficiency for full-block writes; correctness\n             * for partial writes.\n             */\n            memset(block_buf, 0, BLOCK_SIZE);\n        } else if (partial_write) {\n            /*\n             * Block exists and this is a partial write: read existing content\n             * so we can preserve the bytes we're not overwriting.\n             *\n             * This is the READ in \"read-modify-write\".\n             * Cost: 1 block read (~100Î¼s SSD) that would not be needed if\n             * writes were always block-aligned.\n             */\n            if (read_block(fd, disk_block, block_buf) != 0) return -EIO;\n        }\n        /*\n         * Copy the new data into the buffer at the correct offset within the block.\n         * For full-block writes: block_off == 0, chunk == BLOCK_SIZE.\n         * For partial writes: we modify only the [block_off, block_off+chunk) range.\n         */\n        memcpy(block_buf + block_off, in, chunk);\n        /* Write the (possibly modified) block back to disk */\n        if (write_block(fd, disk_block, block_buf) != 0) return -EIO;\n        in         += chunk;\n        cur_offset += chunk;\n        remaining  -= chunk;\n    }\n    /*\n     * Update inode metadata.\n     * Only extend size â€” writing within existing content does not shrink the file.\n     */\n    if (cur_offset > inode.size) {\n        inode.size = (uint32_t)cur_offset;\n    }\n    uint32_t now = (uint32_t)time(NULL);\n    inode.mtime  = now;\n    inode.ctime  = now;   /* inode metadata changed (size may have changed) */\n    if (write_inode(fd, sb, ino, &inode) != 0) return -EIO;\n    return (ssize_t)length;\n}\n```\nLet's trace through the concrete example from the chapter opening: `write(fd, buf, 100)` at offset 5000:\n```\noffset = 5000, length = 100\nIteration 1:\n  block_off = 5000 % 4096 = 904\n  chunk     = min(4096 - 904, 100) = min(3192, 100) = 100\n  partial_write = true  (block_off != 0)\n  â†’ inode_get_block for block index 1\n  â†’ if disk_block exists: read_block (THE READ in RMW)\n  â†’ memcpy(block_buf + 904, in, 100)  (THE MODIFY)\n  â†’ write_block  (THE WRITE)\n  â†’ remaining = 0, loop ends\nTotal disk operations: 1 read + 1 write = 2 block I/Os\nData actually modified: 100 bytes\nData transferred to/from disk: 4096 + 4096 = 8192 bytes\nWrite amplification factor: 81.92Ã—\n```\nEighty-two times more data moved than the actual payload. For a 1-byte write, the amplification is 8192Ã—. This is not a bug; it is the unavoidable cost of block-aligned storage.\n> **Hardware Soul â€” Block Write Ordering on SSD**\n> When `write_block` returns, the data is in the kernel's **page cache** â€” kernel memory, not on any persistent storage. The kernel may hold it there for seconds or minutes, coalescing multiple writes to the same block before flushing. This is why `write()` is fast in practice despite the RMW overhead: subsequent writes to the same block hit the page cache (memory speed) instead of disk. The page cache converts your RMW cycle from a disk operation into a memory operation. Only when the page is eventually flushed (dirty page writeback, `fsync`, or unmount) does the actual disk I/O occur. For your filesystem running on top of a host kernel, this cache layer is automatic. Your filesystem is inside the cache from the host OS's perspective.\n---\n## Sparse File Writes: Skipping the Gap\nThe sparse file case is handled naturally by your write loop, but it deserves explicit attention because the behavior is subtle.\nConsider: `fs_write(fd, sb, ino, 1000000000, \"X\", 1)` â€” writing one byte at offset one billion, into a file that was previously empty.\n```\nIteration 1:\n  cur_offset  = 1,000,000,000\n  block_off   = 1,000,000,000 % 4096 = 3904\n  chunk       = 4096 - 3904 = 192... but wait, length=1, so chunk=1\n  block_index = 1,000,000,000 / 4096 = 244,140 (in the double-indirect region)\n  inode_get_block â†’ returns disk_block = 0 (no block allocated)\n  alloc_block â†’ returns new disk block number\n  inode_set_block(fd, sb, &inode, 999,996,416, new_block)\n    â†’ this allocates the double-indirect block (if not yet allocated)\n    â†’ this allocates the single-indirect block within it (if not yet allocated)\n    â†’ stores new_block in the correct slot\n  memset(block_buf, 0, BLOCK_SIZE)  â† entire block is zeroed\n  block_buf[3904] = 'X'             â† our one byte\n  write_block(fd, new_block, block_buf)\nAfter loop:\n  inode.size = 1,000,000,001\n```\nThe blocks between offset 0 and offset 999,996,416 are **never touched**. They remain as null pointers in the inode's block pointer tree. Every `inode_get_block` call for any offset in that range returns 0, and every `fs_read` call for that range returns zeros from `memset`. The file appears to be 1GB but uses only:\n- 1 data block (4KB)\n- 1 single-indirect block (4KB)\n- 1 double-indirect block (4KB)\nTotal on-disk: 12KB. Logical size: ~1GB. [[EXPLAIN:thin-provisioning-â€”-storage-allocation-deferred-until-first-write|Thin provisioning â€” deferred storage allocation where capacity is reserved logically but not physically allocated until written]]\n\n![Sparse File â€” Null Pointers as Holes](./diagrams/diag-m2-sparse-file.svg)\n\nThis is not a special mode you enable. Sparse files are the **default** behavior of null block pointers. The file you create is automatically sparse if you write at high offsets without filling in between.\n---\n## Append: Writing at the End\nAppend is a special case of write where the starting offset is always `inode.size` (the current end of file). It is not fundamentally different from a mid-file write, but it has one important optimization opportunity: you never need to RMW the last block if the previous write happened to fill it exactly.\n```c\n/*\n * Append data to the end of a file.\n * Convenience wrapper around fs_write.\n *\n * Returns number of bytes written, or negative errno.\n */\nssize_t fs_append(int fd, superblock_t *sb,\n                  uint32_t ino, const void *buf, size_t length) {\n    /* Read current inode to get the file size (= append offset) */\n    inode_t inode;\n    if (read_inode(fd, sb, ino, &inode) != 0) return -EIO;\n    return fs_write(fd, sb, ino, (uint64_t)inode.size, buf, length);\n}\n```\nThe interesting case for append: what if the previous write ended at offset 4095 (one byte before a block boundary)? The next append's first byte lands at offset 4096 â€” a perfect block boundary. `block_off = 4096 % 4096 = 0`. The first iteration has `partial_write = false` if `chunk == BLOCK_SIZE`. No read needed. This is why sequential append-only workloads (log files, write-ahead journals, streaming data) are efficient at the block layer: they naturally generate full-block writes without RMW overhead.\n> The lesson: if you control your write pattern, **align writes to block boundaries**. A log that always writes in 4KB chunks avoids every RMW cycle. This is not an accident â€” it is the same reason database write-ahead logs (WAL), Kafka partitions, and your Milestone 6 journal all use block-sized writes: they are optimizing away the most expensive per-operation cost.\n---\n## `fs_truncate`: The Inverse of Write\nTruncation changes a file's size without moving data. It has two symmetric cases:\n**Shrink** (`new_size < inode.size`): free all blocks that are now beyond the new end, zero out the partial last block if the new size is not block-aligned, update the inode pointer tree to null out freed entries.\n**Extend** (`new_size > inode.size`): do nothing to existing data or pointers â€” the new region is implicitly a sparse hole. Update `inode.size`. Future reads in the extended region return zeros.\nThe extend case is trivially correct with sparse files: since null block pointers already read as zeros, you just need to update `inode.size`. The shrink case requires careful traversal.\n\n![Truncate Shrink â€” Freeing Blocks Beyond New Size](./diagrams/diag-m4-truncate-shrink.svg)\n\n```c\n/*\n * Truncate a file to new_size bytes.\n *\n * If new_size > inode.size: extend (hole-filling, no allocation needed).\n * If new_size < inode.size: shrink (free blocks beyond new_size, update pointers).\n * If new_size == inode.size: no-op (but still update ctime).\n *\n * Returns 0 on success, negative errno on failure.\n */\nint fs_truncate(int fd, superblock_t *sb,\n                uint32_t ino, uint64_t new_size) {\n    if (new_size > (uint64_t)UINT32_MAX) return -EFBIG;\n    inode_t inode;\n    if (read_inode(fd, sb, ino, &inode) != 0) return -EIO;\n    if (!S_ISREG(inode.mode)) return -EINVAL;\n    if (new_size > inode.size) {\n        /*\n         * Extend: the new range [inode.size, new_size) is a sparse hole.\n         * No block allocation needed. Just update size.\n         * Future reads in this range return zeros via the sparse-hole path.\n         */\n        inode.size  = (uint32_t)new_size;\n        inode.mtime = inode.ctime = (uint32_t)time(NULL);\n        return write_inode(fd, sb, ino, &inode);\n    }\n    if (new_size == inode.size) {\n        inode.ctime = (uint32_t)time(NULL);\n        return write_inode(fd, sb, ino, &inode);\n    }\n    /*\n     * Shrink: new_size < inode.size.\n     *\n     * We need to free every block whose file offset is >= new_size.\n     * Additionally, if new_size is not block-aligned, we must zero out\n     * the tail of the last retained block.\n     *\n     * Strategy: iterate through block indices from first_free_block_index\n     * to the end of the file, free each block, and null its pointer.\n     */\n    uint32_t new_last_block  = (new_size == 0) ? 0\n                                                : (uint32_t)((new_size - 1) / BLOCK_SIZE);\n    uint32_t old_last_block  = (inode.size == 0) ? 0\n                                                  : (uint32_t)((inode.size - 1) / BLOCK_SIZE);\n    /* Step 1: Zero-fill the tail of the last retained block (partial block at new_size) */\n    if (new_size > 0 && (new_size % BLOCK_SIZE) != 0) {\n        uint32_t disk_block;\n        int r = inode_get_block(fd, &inode,\n                                (uint64_t)new_last_block * BLOCK_SIZE, &disk_block);\n        if (r != 0) return r;\n        if (disk_block != 0) {\n            uint8_t block_buf[BLOCK_SIZE];\n            if (read_block(fd, disk_block, block_buf) != 0) return -EIO;\n            uint32_t zero_start = (uint32_t)(new_size % BLOCK_SIZE);\n            memset(block_buf + zero_start, 0, BLOCK_SIZE - zero_start);\n            if (write_block(fd, disk_block, block_buf) != 0) return -EIO;\n        }\n    }\n    /* Step 2: Free all blocks with index > new_last_block (or all if new_size == 0) */\n    uint32_t first_to_free = (new_size == 0) ? 0 : (new_last_block + 1);\n    for (uint32_t bi = first_to_free; bi <= old_last_block; bi++) {\n        uint32_t disk_block;\n        int r = inode_get_block(fd, &inode,\n                                (uint64_t)bi * BLOCK_SIZE, &disk_block);\n        if (r != 0) continue;  /* best-effort during truncate */\n        if (disk_block != 0) {\n            free_block(fd, sb, disk_block);\n            /* Null out the pointer in the inode/indirect block */\n            inode_set_block(fd, sb, &inode,\n                            (uint64_t)bi * BLOCK_SIZE, 0);\n        }\n    }\n    /* Step 3: Free indirect pointer blocks that are now entirely empty.\n     *\n     * After nulling data block pointers, check if single-indirect and\n     * double-indirect blocks themselves are now empty and can be freed.\n     */\n    truncate_free_indirect_if_empty(fd, sb, &inode, (uint32_t)new_size);\n    /* Step 4: Update inode */\n    inode.size  = (uint32_t)new_size;\n    inode.mtime = inode.ctime = (uint32_t)time(NULL);\n    return write_inode(fd, sb, ino, &inode);\n}\n```\nThe `truncate_free_indirect_if_empty` function checks whether the single-indirect and double-indirect pointer blocks should themselves be freed. This matters when truncating a large file down to something smaller than 48KB (below the direct-block threshold):\n\n![Truncate Below Indirect Threshold â€” Freeing Indirect Blocks](./diagrams/diag-m4-truncate-with-indirect.svg)\n\n```c\n/*\n * After nulling data block pointers during shrink-truncate,\n * check if the indirect pointer blocks themselves are now all-zeros\n * and can be freed.\n */\nstatic void truncate_free_indirect_if_empty(int fd, superblock_t *sb,\n                                             inode_t *inode,\n                                             uint32_t new_size) {\n    uint64_t single_start = (uint64_t)N_DIRECT * BLOCK_SIZE;\n    uint64_t double_start = single_start + (uint64_t)PTRS_PER_BLOCK * BLOCK_SIZE;\n    /* If new_size is within direct block range and single-indirect exists */\n    if ((uint64_t)new_size <= single_start && inode->single_indirect != 0) {\n        /* All data pointers in this block should already be nulled.\n         * Free the single-indirect block itself. */\n        free_block(fd, sb, inode->single_indirect);\n        inode->single_indirect = 0;\n    }\n    /* If new_size is within (direct + single-indirect) range and double-indirect exists */\n    if ((uint64_t)new_size <= double_start && inode->double_indirect != 0) {\n        /*\n         * For full correctness: scan each entry in the double-indirect block,\n         * free any remaining single-indirect blocks within it.\n         * The loop above already freed their data block pointers;\n         * we now free the single-indirect blocks themselves.\n         */\n        uint8_t buf[BLOCK_SIZE];\n        if (read_block(fd, inode->double_indirect, buf) == 0) {\n            uint32_t *ptrs = (uint32_t *)buf;\n            for (uint32_t i = 0; i < PTRS_PER_BLOCK; i++) {\n                if (ptrs[i] != 0) {\n                    /* Check if this single-indirect block is now all zeros */\n                    uint8_t si_buf[BLOCK_SIZE];\n                    if (read_block(fd, ptrs[i], si_buf) == 0) {\n                        bool all_zero = true;\n                        for (size_t j = 0; j < BLOCK_SIZE; j++) {\n                            if (si_buf[j] != 0) { all_zero = false; break; }\n                        }\n                        if (all_zero) {\n                            free_block(fd, sb, ptrs[i]);\n                            ptrs[i] = 0;\n                        }\n                    }\n                }\n            }\n            write_block(fd, inode->double_indirect, buf);\n        }\n        /* If new_size is in direct range, free the double-indirect block too */\n        if ((uint64_t)new_size <= single_start) {\n            free_block(fd, sb, inode->double_indirect);\n            inode->double_indirect = 0;\n        }\n    }\n}\n```\n> **Pitfall â€” Truncation and Partial Block Zeroing**: When you shrink a file to `new_size = 5000`, the last retained block (block index 1, covering file offsets 4096â€“8191) must have its bytes from 5000 to 8191 zeroed out. If you skip this step, the bytes from 5000 to 8191 remain on disk as whatever the file previously contained. If the file is later extended back past 5000 (via `truncate` extend), those \"ghost bytes\" reappear as if they were written, even though the file never logically contained them at those positions. This is a **security vulnerability** in multi-user systems â€” one user's file data leaks into another user's file after truncation and re-extension. Always zero the tail of the last retained block.\n---\n## Metadata Correctness: Size, mtime, ctime\nEvery write and truncate operation must update inode metadata. Getting this right matters for correctness of tools like `rsync`, `make`, and every backup system that uses timestamps and file sizes for change detection.\nThe rules:\n| Operation | `size` | `mtime` | `ctime` | `atime` |\n|-----------|--------|---------|---------|---------|\n| `write` (data changes) | Update if grown | Always update | Always update | Unchanged |\n| `truncate` (size changes) | Always update | Always update | Always update | Unchanged |\n| `read` (data accessed) | No change | No change | No change | Update |\n| `chmod`, `chown` (meta changes) | No change | No change | Always update | Unchanged |\nA subtle correctness requirement: `ctime` must update whenever **anything** in the inode changes â€” including `size`, `mtime`, and `nlinks`. The reason: `ctime` is the \"inode change time,\" not just the \"data change time.\" A rename operation (which changes directory entries but not data) must update `ctime` on the affected inode. `mtime` only tracks data changes.\n```c\n/*\n * Helper: update inode metadata after a write operation.\n * Call this instead of manually setting fields â€” ensures consistency.\n */\nstatic void update_write_metadata(inode_t *inode,\n                                   uint64_t new_end_offset) {\n    uint32_t now = (uint32_t)time(NULL);\n    if (new_end_offset > inode->size) {\n        inode->size = (uint32_t)new_end_offset;\n    }\n    inode->mtime = now;\n    inode->ctime = now;   /* size and mtime both changed â†’ ctime must change */\n}\n```\n---\n## Three-Level View: What Happens When `fs_write` Runs\nLet's trace `fs_write(fd, sb, ino=7, offset=8192, buf=\"Hello\", length=5)` â€” writing \"Hello\" at a block-aligned offset in a small file.\n| Level | What Happens |\n|-------|-------------|\n| **Application (your code)** | Calls `fs_write`. Arithmetic: `block_off = 8192 % 4096 = 0`, `chunk = min(4096, 5) = 5`, `partial_write = true` (chunk < BLOCK_SIZE). Calls `inode_get_block(fd, &inode, 8192, &disk_block)`. |\n| **Your Filesystem Layer** | `inode_get_block` computes `block_index = 2` â†’ within direct range â†’ returns `inode.blocks[2]`. If it's 0: `alloc_block(fd, sb)` reads the bitmap block, finds free bit, sets it, writes bitmap back, returns disk block number. `inode_set_block` stores the new disk block number in `inode.blocks[2]`. `memset(block_buf, 0, 4096)` zeroes new block. `memcpy(block_buf + 0, \"Hello\", 5)`. `write_block(fd, disk_block, block_buf)` calls `write(fd, buf, 4096)` at the right offset in the image file. |\n| **Host OS / Hardware** | The host kernel receives the `write` syscall. The disk image file's page in the page cache is found (or faulted in). The 4096 bytes are written to the kernel's page cache page â€” marking it dirty. The `write` syscall returns immediately. Eventually, the page daemon (or an `fsync`) flushes this dirty page to the actual storage device via block I/O. The device DMA controller transfers the page from kernel memory to disk buffer. Disk confirms write. Page marked clean. |\nThe key observation: your `write_block` returns before the data hits physical storage. The data exists in the host kernel's page cache â€” safe from process crashes but not from power failures. This is why `fsync(fd)` on your disk image file descriptor matters before claiming a write is \"committed.\"\n---\n## Design Decision: When to Flush the Inode\nAfter a `write`, you must update the inode (`size`, `mtime`, `ctime`) and write it to disk. But how often?\n| Strategy | Write Frequency | Data Safety | Performance |\n|----------|----------------|-------------|-------------|\n| **After every write (chosen âœ“ for now)** | Every `fs_write` call | Good: metadata matches data at all times (within page cache lag) | Poor: 1 inode write per data write = 2Ã— disk I/Os |\n| Batch: flush inode on `close` / `fsync` | Once at close/sync | Poor: crash between write and close loses size update; reads see wrong size | Better: inode writes amortized over many data writes |\n| Write-through cache: dirty inode in memory, flush asynchronously | Asynchronously | With journaling: excellent; without: crash window | Best throughput |\nFor your standalone implementation without a buffer cache, \"after every write\" is the correct choice â€” it is simple and correct. The journal in Milestone 6 will group inode updates with data writes into atomic transactions, both improving safety and enabling the batched flush optimization.\nThe numbers: on a filesystem with 1,000 sequential 512-byte writes to the same file, the \"after every write\" strategy generates 1,000 inode writes and 1,000 data block writes (the data writes coalesce since they're in the same 4KB block after the first). The batched strategy generates ~1 inode write and ~1 data write. For sequential small writes, this is a 500Ã— difference in inode write operations. This is one reason why `write` performance degrades sharply for small random writes to the same file.\n---\n## Unit Tests: Verifying Round-Trip Correctness\nYour acceptance criteria demand round-trip verification. Here is a comprehensive test suite:\n```c\n#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\n * Full test suite for file read/write operations.\n * Run after mkfs on a fresh disk image.\n * Assumes root_ino is valid and accessible.\n */\nvoid test_file_operations(int fd, superblock_t *sb) {\n    printf(\"\\n=== File Read/Write Tests ===\\n\");\n    uint32_t root_ino = sb->root_inode;\n    /* ------------------------------------------------------------------ */\n    /* Test 1: create_file basic */\n    int file_ino = fs_create_file(fd, sb, root_ino, \"test.txt\",\n                                   0644, 1000, 1000);\n    assert(file_ino > 0);\n    inode_t inode;\n    assert(read_inode(fd, sb, (uint32_t)file_ino, &inode) == 0);\n    assert(S_ISREG(inode.mode));\n    assert(inode.size == 0);\n    assert(inode.nlinks == 1);\n    printf(\"OK: create_file â†’ inode %d, size=0\\n\", file_ino);\n    /* ------------------------------------------------------------------ */\n    /* Test 2: write and read back â€” small (sub-block, aligned) */\n    const char *msg = \"Hello, Filesystem!\";\n    size_t msg_len = strlen(msg);\n    ssize_t written = fs_write(fd, sb, (uint32_t)file_ino,\n                                0, msg, msg_len);\n    assert(written == (ssize_t)msg_len);\n    assert(read_inode(fd, sb, (uint32_t)file_ino, &inode) == 0);\n    assert(inode.size == msg_len);\n    char read_buf[64];\n    memset(read_buf, 0xAA, sizeof(read_buf));\n    ssize_t nread = fs_read(fd, sb, (uint32_t)file_ino,\n                             0, read_buf, msg_len);\n    assert(nread == (ssize_t)msg_len);\n    assert(memcmp(read_buf, msg, msg_len) == 0);\n    printf(\"OK: write + read round-trip (small, aligned)\\n\");\n    /* ------------------------------------------------------------------ */\n    /* Test 3: partial write â€” crosses NO block boundary */\n    const char *patch = \"World\";\n    written = fs_write(fd, sb, (uint32_t)file_ino, 7, patch, 5);\n    assert(written == 5);\n    nread = fs_read(fd, sb, (uint32_t)file_ino, 0, read_buf, msg_len);\n    assert(nread == (ssize_t)msg_len);\n    assert(memcmp(read_buf, \"Hello, World!stem!\", msg_len) == 0);\n    printf(\"OK: partial overwrite within single block\\n\");\n    /* ------------------------------------------------------------------ */\n    /* Test 4: write crossing a block boundary */\n    /* File currently ends at offset msg_len. Write so it crosses block 0â†’1 */\n    /* First, extend to block boundary - 50 bytes */\n    uint32_t pre_boundary = BLOCK_SIZE - 50;\n    char fill_buf[BLOCK_SIZE];\n    memset(fill_buf, 'A', pre_boundary);\n    /* Overwrite from offset 0 with BLOCK_SIZE-50 bytes of 'A' */\n    /* Then write 100 bytes of 'B' crossing the boundary */\n    written = fs_write(fd, sb, (uint32_t)file_ino, 0, fill_buf, pre_boundary);\n    assert(written == (ssize_t)pre_boundary);\n    char cross_buf[100];\n    memset(cross_buf, 'B', 100);\n    written = fs_write(fd, sb, (uint32_t)file_ino,\n                        pre_boundary, cross_buf, 100);\n    assert(written == 100);\n    /* Verify: 50 bytes of 'B' in block 0 tail, 50 bytes of 'B' in block 1 head */\n    char verify[100];\n    nread = fs_read(fd, sb, (uint32_t)file_ino, pre_boundary, verify, 100);\n    assert(nread == 100);\n    for (int i = 0; i < 100; i++) {\n        assert(verify[i] == 'B');\n    }\n    /* Verify pre-boundary bytes are still 'A' */\n    char check_a[10];\n    nread = fs_read(fd, sb, (uint32_t)file_ino,\n                    pre_boundary - 10, check_a, 10);\n    assert(nread == 10);\n    for (int i = 0; i < 10; i++) {\n        assert(check_a[i] == 'A');\n    }\n    printf(\"OK: write crossing block boundary (block 0 â†’ block 1)\\n\");\n    /* ------------------------------------------------------------------ */\n    /* Test 5: sparse file â€” write at high offset */\n    int sparse_ino = fs_create_file(fd, sb, root_ino, \"sparse.txt\",\n                                     0644, 1000, 1000);\n    assert(sparse_ino > 0);\n    char sparse_data[4] = {'S', 'P', 'A', 'R'};\n    uint64_t sparse_offset = (uint64_t)BLOCK_SIZE * 100;  /* well into direct range */\n    written = fs_write(fd, sb, (uint32_t)sparse_ino,\n                        sparse_offset, sparse_data, 4);\n    assert(written == 4);\n    /* Read the hole (offset 0) â€” must be zeros */\n    char hole_buf[BLOCK_SIZE];\n    nread = fs_read(fd, sb, (uint32_t)sparse_ino, 0, hole_buf, BLOCK_SIZE);\n    assert(nread == BLOCK_SIZE);\n    for (int i = 0; i < BLOCK_SIZE; i++) {\n        assert(hole_buf[i] == 0);\n    }\n    /* Read the written data */\n    char sparse_read[4];\n    nread = fs_read(fd, sb, (uint32_t)sparse_ino,\n                    sparse_offset, sparse_read, 4);\n    assert(nread == 4);\n    assert(memcmp(sparse_read, sparse_data, 4) == 0);\n    /* Verify inode size but minimal block allocation */\n    assert(read_inode(fd, sb, (uint32_t)sparse_ino, &inode) == 0);\n    assert(inode.size == sparse_offset + 4);\n    printf(\"OK: sparse file â€” hole reads as zeros, data reads correctly\\n\");\n    /* ------------------------------------------------------------------ */\n    /* Test 6: truncate shrink â€” reduce to half */\n    int trunc_ino = fs_create_file(fd, sb, root_ino, \"trunc.txt\",\n                                    0644, 1000, 1000);\n    assert(trunc_ino > 0);\n    char trunc_data[BLOCK_SIZE * 3];\n    memset(trunc_data, 'T', sizeof(trunc_data));\n    written = fs_write(fd, sb, (uint32_t)trunc_ino,\n                        0, trunc_data, sizeof(trunc_data));\n    assert(written == (ssize_t)sizeof(trunc_data));\n    uint32_t free_before = sb->free_blocks;\n    int tr = fs_truncate(fd, sb, (uint32_t)trunc_ino, BLOCK_SIZE);\n    assert(tr == 0);\n    assert(read_inode(fd, sb, (uint32_t)trunc_ino, &inode) == 0);\n    assert(inode.size == BLOCK_SIZE);\n    /* Two blocks should have been freed */\n    assert(sb->free_blocks == free_before + 2);\n    /* Verify truncated data: first block still readable */\n    char trunc_read[BLOCK_SIZE];\n    nread = fs_read(fd, sb, (uint32_t)trunc_ino, 0, trunc_read, BLOCK_SIZE);\n    assert(nread == BLOCK_SIZE);\n    for (int i = 0; i < BLOCK_SIZE; i++) {\n        assert(trunc_read[i] == 'T');\n    }\n    /* Verify reading past new EOF returns 0 */\n    nread = fs_read(fd, sb, (uint32_t)trunc_ino, BLOCK_SIZE, trunc_read, 1);\n    assert(nread == 0);\n    printf(\"OK: truncate shrink â€” size updated, blocks freed, data preserved\\n\");\n    /* ------------------------------------------------------------------ */\n    /* Test 7: truncate extend (sparse extend) */\n    int ext_ino = fs_create_file(fd, sb, root_ino, \"ext.txt\",\n                                  0644, 1000, 1000);\n    assert(ext_ino > 0);\n    char small_data[10];\n    memset(small_data, 'E', 10);\n    fs_write(fd, sb, (uint32_t)ext_ino, 0, small_data, 10);\n    uint32_t free_before_ext = sb->free_blocks;\n    tr = fs_truncate(fd, sb, (uint32_t)ext_ino, BLOCK_SIZE * 5);\n    assert(tr == 0);\n    assert(read_inode(fd, sb, (uint32_t)ext_ino, &inode) == 0);\n    assert(inode.size == BLOCK_SIZE * 5);\n    /* No new blocks should have been allocated (extension is sparse) */\n    assert(sb->free_blocks == free_before_ext);\n    /* Reads in extended region should return zeros */\n    char ext_read[64];\n    nread = fs_read(fd, sb, (uint32_t)ext_ino, BLOCK_SIZE, ext_read, 64);\n    assert(nread == 64);\n    for (int i = 0; i < 64; i++) assert(ext_read[i] == 0);\n    printf(\"OK: truncate extend â€” sparse, no allocation, reads as zeros\\n\");\n    /* ------------------------------------------------------------------ */\n    /* Test 8: append */\n    int app_ino = fs_create_file(fd, sb, root_ino, \"append.txt\",\n                                  0644, 1000, 1000);\n    assert(app_ino > 0);\n    for (int i = 0; i < 10; i++) {\n        char line[32];\n        int line_len = snprintf(line, sizeof(line), \"Line %d\\n\", i);\n        ssize_t wr = fs_append(fd, sb, (uint32_t)app_ino, line, (size_t)line_len);\n        assert(wr == line_len);\n    }\n    assert(read_inode(fd, sb, (uint32_t)app_ino, &inode) == 0);\n    assert(inode.size > 0);\n    printf(\"OK: append â€” 10 lines written sequentially\\n\");\n    /* ------------------------------------------------------------------ */\n    /* Test 9: read past EOF returns truncated data */\n    nread = fs_read(fd, sb, (uint32_t)file_ino,\n                    inode.size + 1000, read_buf, 100);\n    assert(nread == 0);\n    printf(\"OK: read past EOF returns 0\\n\");\n    /* ------------------------------------------------------------------ */\n    /* Test 10: mtime/ctime updated after write */\n    int ts_ino = fs_create_file(fd, sb, root_ino, \"ts.txt\",\n                                 0644, 1000, 1000);\n    assert(ts_ino > 0);\n    assert(read_inode(fd, sb, (uint32_t)ts_ino, &inode) == 0);\n    uint32_t create_mtime = inode.mtime;\n    /* Sleep briefly to ensure timestamp difference is detectable */\n    /* In a real test, you'd mock time; here we just verify it's non-zero */\n    fs_write(fd, sb, (uint32_t)ts_ino, 0, \"X\", 1);\n    assert(read_inode(fd, sb, (uint32_t)ts_ino, &inode) == 0);\n    assert(inode.mtime >= create_mtime);\n    assert(inode.ctime >= create_mtime);\n    assert(inode.size == 1);\n    printf(\"OK: mtime/ctime updated after write\\n\");\n    /* ------------------------------------------------------------------ */\n    /* Test 11: truncate zeroes tail of partial block */\n    int zero_ino = fs_create_file(fd, sb, root_ino, \"zero.txt\",\n                                   0644, 1000, 1000);\n    assert(zero_ino > 0);\n    char full_block[BLOCK_SIZE];\n    memset(full_block, 0xFF, BLOCK_SIZE);\n    fs_write(fd, sb, (uint32_t)zero_ino, 0, full_block, BLOCK_SIZE);\n    /* Truncate to 512 bytes â€” tail of block should be zeroed */\n    fs_truncate(fd, sb, (uint32_t)zero_ino, 512);\n    /* Extend back to BLOCK_SIZE â€” bytes 512..4095 must be zero, not 0xFF */\n    fs_truncate(fd, sb, (uint32_t)zero_ino, BLOCK_SIZE);\n    char after_extend[BLOCK_SIZE];\n    fs_read(fd, sb, (uint32_t)zero_ino, 0, after_extend, BLOCK_SIZE);\n    for (int i = 0; i < 512; i++) assert(after_extend[i] == 0xFF);\n    for (int i = 512; i < BLOCK_SIZE; i++) assert(after_extend[i] == 0x00);\n    printf(\"OK: truncate zeroes tail of partial block\\n\");\n    printf(\"=== All File I/O Tests Passed ===\\n\\n\");\n}\n```\n---\n## Knowledge Cascade: One Write, Ten Worlds\nYou have just built the operation that every storage system in existence is trying to optimize. The read-modify-write cycle you implemented is the fundamental bottleneck of block storage. Every major pattern in storage systems engineering is a response to this single fact.\n### Database Write Amplification and LSM-Trees\n[[EXPLAIN:lsm-tree-â€”-log-structured-merge-tree-batch-random-writes-into-sequential-io|LSM-tree â€” Log-Structured Merge Tree, converts random writes into sequential I/O by batching in a memtable]]\nYour `fs_write` at a random offset costs: 1 block read + 1 block write = 2 disk operations per write, regardless of how many bytes you actually changed. For a database updating 8-byte rows randomly across a 10GB table, every row update triggers this 2-operation cycle for a 4096-byte block â€” writing ~0.2% of the data you read. This is *write amplification*: you write more to disk than your actual payload requires.\nThe consequence is profound: a spinning disk doing 100 random IOPS can sustain 100 random row updates per second â€” terrible for any write-heavy workload. LevelDB and RocksDB exist as the answer to this problem. The LSM-tree (Log-Structured Merge Tree) collects all writes in a **memtable** (an in-memory sorted structure), then writes the memtable to disk as a **sequential SSTable** (Sorted String Table) when it fills. Random writes become sequential writes. Your random `fs_write` at arbitrary offsets becomes a sequential append to the SSTable. The \"merge\" in LSM-Tree is the background process that consolidates multiple SSTables into one, handling the complexity that random access has been deferred to.\nUnderstanding your `fs_write` and its RMW cost is understanding *why the LSM-tree is the right data structure for write-heavy workloads*. It is not a clever trick; it is the logical response to a physical constraint you now understand from first principles.\n### SSD Write Amplification: Compound Costs\nYour filesystem's write amplification sits on top of the SSD's own write amplification, and the two multiply.\n[[EXPLAIN:nand-flash-write-constraints-â€”-write-in-pages-erase-in-larger-blocks-requiring-flash-translation-layer|NAND flash write constraints â€” NAND cells write in pages (~4-16KB) and erase in much larger blocks (~128-512KB), requiring a Flash Translation Layer]]\nWhen your `fs_write` triggers a 4KB block write, the SSD receives a 4KB write request to a logical block address (LBA). Internally, NAND flash cannot overwrite: it must erase before writing. Erase operations work on \"erase blocks\" of 128KBâ€“1MB. If the SSD's target page is not in an empty erase block, the SSD must:\n1. Read the entire erase block (128KB) into an internal buffer\n2. Erase the erase block (an expensive ~1ms operation)\n3. Write the modified page back plus all the other pages that were in that erase block\nA 4KB write from your filesystem may cause 128KB of physical NAND writes internally. On top of your filesystem's own amplification (writing 4096 bytes to update 100 bytes), you now have the SSD amplifying that 4096-byte write by 32Ã— internally. A 100-byte application write â†’ 4096-byte filesystem block â†’ 128KB NAND write: 1,280Ã— total amplification.\nThis is why SSDs use large internal caches (DRAM or SLC NAND) to buffer writes, why SSD firmware includes sophisticated write scheduling, why `fstrim` exists (to inform the SSD which blocks are logically free so it can garbage-collect proactively), and why \"write endurance\" (total bytes written before NAND cell failure) is a key SSD specification. You are not just writing to your filesystem; you are writing to a physical system with its own internal indirection layer.\n### The Linux Page Cache: Why Your Writes Aren't That Slow\nIf your `fs_write` caused an actual disk RMW on every call, interactive applications would be unusable. A text editor writing one character at a time to a file would need 200Î¼s per character â€” 50 characters per second maximum throughput. That's slower than a 1970s teletype.\nThe Linux page cache (also called the buffer cache in older literature) is the mechanism that makes this bearable. Every block your filesystem reads or writes goes through the page cache:\n- **Read**: if the 4KB block is in the cache (a \"cache hit\"), return from memory (~100ns). If not (a \"cache miss\"), read from disk (~100Î¼s), store in cache, return.\n- **Write**: store in cache (mark page \"dirty\"), return immediately. The kernel writes dirty pages to disk asynchronously in the background (via `pdflush`/`kworker` threads), coalescing multiple writes to the same block into a single disk write.\nFor your `fs_write` calling into a test, the \"write\" to disk is actually a write to the kernel's page cache, which returns at memory speed. The RMW cycle becomes: read block from page cache (100ns if hot), modify in memory, mark dirty. No disk I/O unless the page cache is under memory pressure or `fsync` is called.\nUnderstanding why the page cache exists requires understanding the RMW cycle. The page cache is precisely the buffer that transforms \"every write is an RMW\" into \"every write is a memory operation, with asynchronous disk flushing when convenient.\" Without the page cache, your text editor, web browser, and every other interactive application that writes small amounts of data would be unusable.\n> ðŸ”­ **Deep Dive**: Robert Love's \"Linux Kernel Development\" (3rd ed.), Chapter 16 covers the page cache and writeback mechanism in detail. The `struct address_space` and `struct page` types are the kernel data structures that implement what you are experiencing as fast writes. For the specific writeback mechanism: Chapter 16.2 \"Dirty Page Writeback.\"\n### Sparse Files and Cloud Thin Provisioning\nEvery major cloud provider's block storage product (AWS EBS, Google Persistent Disk, Azure Managed Disks) is implemented using the sparse file principle you just built. When you provision a 1TB EBS volume in AWS, AWS does not immediately allocate 1TB of physical storage. It creates a metadata record saying \"this volume is 1TB\" and allocates physical storage only as you write to it. This is called **thin provisioning**.\nA VM disk image file on ext4 or XFS on the hypervisor host is a sparse file. The QCOW2 format (used by QEMU/KVM) implements its own internal sparse allocation, on top of the host filesystem's sparse support, giving two levels of sparseness. A container using an overlay filesystem has its base layer as a sparse-ish collection of files, with only the written-to files consuming real storage in the upper layer.\nThe economic implication: cloud providers can \"oversell\" storage capacity, knowing that users who provision 1TB typically write far less than 1TB. The system works because sparse writes are free until the data is actually written. When a hypervisor host runs out of physical storage because too many VMs simultaneously started writing heavily, that is a \"storage balloon\" event â€” and your `alloc_block` returning `-ENOSPC` is the filesystem-level symptom that applications see.\n### Copy-on-Write Filesystems: Avoiding RMW Entirely\nYour `fs_write` modifies blocks in place: read the existing block, modify bytes, write it back to the same location. This is called **update-in-place** (or write-in-place). ZFS and Btrfs take a radically different approach: **copy-on-write (CoW)**.\n[[EXPLAIN:copy-on-write-filesystems-â€”-modified-blocks-written-to-new-locations-with-atomic-pointer-updates|Copy-on-write filesystems â€” modified blocks written to new locations and pointer updated atomically, never overwriting existing data]]\nIn a CoW filesystem, when you write to a block:\n1. Allocate a *new* disk block\n2. Write the modified content to the new block\n3. Update the inode's block pointer to point to the new block\n4. Mark the old block as free\nThe old block is never overwritten. The write goes to a new location. The critical insight: step 3 (updating the inode pointer) is a small, atomic metadata write. If the system crashes between steps 2 and 3, the old block is still intact (the inode still points to it). There is no torn-write state: either the old content is visible (pointer not yet updated) or the new content is visible (pointer updated). The intermediate state â€” half old, half new â€” is impossible.\nThis eliminates the crash consistency problem that Milestone 6 solves with journaling. ZFS and Btrfs never need `fsck`. The entire filesystem tree is a tree of immutable blocks with pointer updates propagated to the root. The root block's pointer update is the single atomic commit that makes a write permanent.\nThe downside: CoW creates fragmentation aggressively, since no write ever goes to the same location twice. Solid-state drives handle this better than spinning disks (which prefer sequential access), but even SSDs degrade with severe fragmentation. Btrfs requires periodic `btrfs balance` runs to defragment; ZFS handles it with its pool-level free space management.\nUnderstanding your in-place `fs_write` is understanding why CoW is a different tradeoff: you trade simpler crash recovery for higher fragmentation and more complex space management.\n### The O_DIRECT Flag: Bypassing the Buffer Cache\n[[EXPLAIN:direct-i/o-o_direct-â€”-bypassing-the-kernel-page-cache-for-user-controlled-buffering|Direct I/O (O_DIRECT) â€” bypassing the kernel page cache, requiring aligned buffers, used by databases for self-managed caching]]\nWhen you open a file with `O_DIRECT`, you instruct the kernel to bypass the page cache entirely. Your reads and writes go directly to the block device. The constraints: buffer addresses and lengths must be block-aligned (typically 512-byte or 4096-byte aligned).\nWho uses `O_DIRECT`? Databases. MySQL InnoDB, PostgreSQL (with `synchronous_commit = on`), Oracle â€” all optionally use O_DIRECT to manage their own buffer pools instead of relying on the OS page cache. Why? Because the database knows its access patterns better than the OS. A sequential full table scan should not pollute the page cache with pages that will never be read again, evicting hot index pages. The database's buffer pool implements its own LRU/clock eviction policy tuned to database access patterns.\nYour `fs_write` calls the kernel's `write()` syscall, which goes through the page cache. If you were building a database storage engine directly on your filesystem (not through a POSIX file), you might want `O_DIRECT` semantics to avoid double-buffering (your database buffer pool + the OS page cache both holding the same data). Understanding block-level I/O is a prerequisite for understanding why `O_DIRECT` exists and when to use it.\n---\n## Before You Move On: Pitfall Checklist\n- [ ] **Partial block writes zero-fill new blocks**: When `alloc_block` returns a new block and the write is partial, call `memset(block_buf, 0, BLOCK_SIZE)` before writing the new content. A fresh block from the disk image may contain garbage bytes from previous filesystem operations. If you write \"Hello\" at offset 904 of a new block without zeroing first, bytes 0â€“903 and 908â€“4095 contain undefined data from whatever previously occupied that disk location.\n- [ ] **RMW only when block exists**: Only call `read_block` in the write path if `disk_block != 0` and the write is partial. If the block was just allocated (`disk_block` was 0 and you called `alloc_block`), skip the read â€” you already zeroed the buffer with `memset`. Calling `read_block` on a freshly allocated block reads uninitialized disk content, defeating the zero-fill.\n- [ ] **Update inode size only on growth**: `inode.size = max(inode.size, offset + length)`. Writing at offset 0 on a 100-byte file with 5 bytes must not shrink the file to 5 bytes. The write path never shrinks the size â€” only `fs_truncate` does.\n- [ ] **Truncate partial-block zeroing**: When truncating to a size that is not block-aligned, zero bytes from `new_size % BLOCK_SIZE` to `BLOCK_SIZE - 1` in the last retained block. Skipping this leaks previous file content into subsequent truncate-extend cycles â€” a security bug in multi-user systems.\n- [ ] **Free indirect blocks during truncate**: When truncating below the single-indirect threshold (48KB), free the single-indirect block itself after nulling its data pointers. When truncating below the double-indirect threshold, free all single-indirect blocks within the double-indirect and then the double-indirect block. Each freed indirect block is 4KB of disk space that `sb->free_blocks` must account for.\n- [ ] **Block allocation failure rollback**: If `alloc_block` returns `-ENOSPC` mid-write, you have already written some blocks. The partial write has occurred. Return the bytes actually written (not an error) if any data was written, or `-ENOSPC` if nothing was written. POSIX specifies that a partial write is legitimate. Do not leave the inode in an inconsistent state (update `size` and timestamps to reflect what was actually written).\n- [ ] **`inode_set_block` for newly allocated blocks**: After calling `alloc_block` to get a new disk block number, always call `inode_set_block(fd, sb, &inode, file_offset, disk_block)` to record the pointer before writing data to the block. If you write data first and then crash before recording the pointer, the data is unreachable (leaked block). The order: allocate â†’ record pointer â†’ write data.\n- [ ] **`atime` update on reads**: `fs_read` must update `inode.atime` and call `write_inode`. This causes a write for every read â€” the \"atime write amplification\" problem. For FUSE (Milestone 5), implement `relatime`: only update `atime` if `atime < mtime`. This reduces the write-per-read to cases where the file has been modified since last access â€” typically once per read session rather than once per read call.\n- [ ] **EOF clamp in `fs_read`**: If `offset >= inode.size`, return 0 immediately (not an error). If `offset + length > inode.size`, clamp `length = inode.size - offset`. Reading past EOF is not an error in POSIX; it returns 0 bytes. An unclamped read would access blocks beyond the file's logical size, potentially reading another file's data if those blocks happen to be allocated.\n- [ ] **Block 0 is never a data block**: The `alloc_block` function should never return 0 (the superblock's disk block number). If `disk_block == 0` after `alloc_block`, something is catastrophically wrong. Add an assertion: `assert(disk_block >= sb->data_block_start)` after every `alloc_block` call. Similarly, in `inode_get_block`, a returned `disk_block == 0` means \"sparse hole\" â€” not a pointer to the superblock. The convention that 0 is the null/sparse sentinel is what makes this work, and it requires that legitimate data blocks always have numbers â‰¥ `data_block_start`.\n---\n## What You've Built and What Comes Next\n\n![Filesystem Atlas â€” Satellite Map (Home Base)](./diagrams/diag-L0-satellite-map.svg)\n\nYou now have a complete, working filesystem â€” in the sense that it can create files, name them in directories, store arbitrary byte content in them via a multi-level block pointer tree, retrieve that content by inode number and byte offset, grow and shrink files through write and truncate, and support sparse files where holes cost nothing.\nBut there is a gap between \"working filesystem library\" and \"a filesystem you can actually use.\" Right now, you can only interact with your filesystem by calling `fs_read`, `fs_write`, `fs_create_file` directly from C code. You cannot use standard Unix tools â€” `ls`, `cat`, `cp`, `vim`, `grep` â€” against your filesystem. You cannot mount it. It is a library, not a filesystem in the Unix sense.\nMilestone 5 closes that gap via **FUSE** (Filesystem in Userspace). FUSE provides a mechanism for running a filesystem in userspace (your process) while the kernel routes VFS calls from any application to your callbacks. You will implement a thin translation layer that maps FUSE callback arguments (path strings, POSIX stat structs, file handle integers) to your internal operations (path resolution, `fs_read`, `fs_write`, `inode_t`). After Milestone 5, you will be able to run `mount -t fuse ./myfs /mnt/myfs` and then `cp -r ~/Documents /mnt/myfs/` and have your filesystem actually store those files.\nThe block-level I/O you just built is the foundation. Every FUSE callback for every file operation â€” `read`, `write`, `create`, `truncate`, `getattr` â€” will ultimately call the functions in this milestone. The work you have done here is the engine; FUSE is the transmission that connects it to the outside world.\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: filesystem-m5 -->\n<!-- MS_ID: filesystem-m5 -->\n# Milestone 5: FUSE Integration\n## The Wall That Was Never There\nYou have built a complete filesystem. It can format a raw disk image, allocate blocks and inodes, store file data across a multi-level block pointer tree, create and navigate a directory hierarchy, and read or write arbitrary byte ranges with correct sparse-file semantics. Every function you have written is correct. Every test passes.\nAnd yet: if you open a terminal right now and type `ls /mnt/myfs`, nothing happens. Your filesystem does not exist as far as the operating system is concerned. `cat`, `cp`, `grep`, `vim` â€” none of these tools can see a single byte you have stored. You have built a library, not a filesystem.\nMost developers hit this point and assume the solution requires kernel programming. Surely, they think, to make the OS route `open(\"/mnt/myfs/file.txt\")` to your code, you need to write a kernel module â€” modify the VFS layer, compile against kernel headers, deal with `MODULE_LICENSE(\"GPL\")`, and risk a kernel panic every time you make a mistake. The VFS feels like a wall between userspace code and the rest of the OS.\nThat wall does not exist.\n**FUSE** (Filesystem in USErspace) is a kernel module â€” already present in every modern Linux system â€” that acts as a relay. When any process on the system makes a VFS call (`open`, `stat`, `read`, `write`, `mkdir`) against a FUSE-mounted path, the kernel's VFS dispatches that call to the FUSE kernel module, which serializes it into a message, writes it to `/dev/fuse`, and blocks waiting for a response. Your userspace process is reading from that same `/dev/fuse` file descriptor. You receive the request, call your internal filesystem functions, serialize the result, and write it back. The FUSE module receives the response, unpacks it, and returns it to the calling process â€” which has no idea this round-trip through userspace ever happened.\n[[EXPLAIN:fuse-architecture-â€”-how-userspace-filesystems-intercept-vfs-calls|FUSE architecture â€” how userspace filesystems intercept VFS calls]]\nThe latency cost of this relay is real: approximately 2â€“5 microseconds per operation, dominated by two context switches (kernelâ†’user for dispatch, userâ†’kernel for response). For metadata-heavy workloads like `find` or `git status`, this adds up. For data-heavy workloads like streaming a video file, the per-byte overhead disappears into the block transfer cost. Production filesystems built on FUSE include GlusterFS, SSHFS, rclone mount, mergerfs, and Google's internal Colossus client. FUSE is not a toy.\nThe real surprise â€” the one that shapes everything in this milestone â€” is this: **FUSE calls your code with path strings, not inode numbers**. When `ls /mnt/myfs/home/user` runs, FUSE's `readdir` callback receives the string `\"/home/user\"`. Before you can call a single one of your internal functions, you must resolve that path to an inode number. The `path_resolve` function you built in Milestone 3 is not just one feature among many â€” it is the hottest code path in your entire filesystem.\nLet's wire this up.\n\n![FUSE Architecture â€” Kernel/Userspace Data Flow](./diagrams/diag-m5-fuse-architecture.svg)\n\n---\n## The Fundamental Tension: VFS Contract, Userspace Implementation\n[[EXPLAIN:vfs-abstraction-layer-â€”-the-kernel-interface-all-filesystems-must-implement|VFS abstraction layer â€” the kernel's unified interface that ext4, XFS, NFS, and your filesystem all implement]]\nThe kernel's VFS (Virtual Filesystem Switch) defines a contract: every filesystem, whether it is ext4 built into the kernel, NFS communicating over the network, or your FUSE implementation running as a userspace process, must implement a specific set of operations. In the kernel, these are function pointers grouped into three C structures:\n- `struct inode_operations`: operations on inodes (`lookup`, `create`, `mkdir`, `unlink`, `rename`, `getattr`, `chmod`, `utimes`)\n- `struct file_operations`: operations on open files (`open`, `read`, `write`, `release`, `readdir`)\n- `struct super_operations`: operations on the filesystem itself (`statfs`, `sync_fs`, `put_super`)\nThe FUSE kernel module implements all of these by forwarding them over the `/dev/fuse` channel to your process. `libfuse` â€” the C library you link against â€” handles the low-level protocol: reading requests from the file descriptor, dispatching them to function pointers you register, and writing responses back.\nYour job is to fill in those function pointers with implementations that call your Milestone 1â€“4 code. The architectural tension is this:\n**The VFS contract is inode-based. FUSE delivers path-based requests. Your internal functions are inode-based. Every FUSE callback must perform path resolution to bridge the gap.**\nFor a filesystem mounted at `/mnt/myfs`, when a process calls `stat(\"/mnt/myfs/home/user/file.txt\")`:\n1. The kernel VFS resolves the mount point, sees it's FUSE-backed\n2. FUSE kernel module packages the request: opcode=`GETATTR`, path=`\"/home/user/file.txt\"`\n3. Your process receives it, calls `path_resolve(fd, sb, \"/home/user/file.txt\", root_ino, root_ino)`\n4. That traverses three directory blocks, returns inode 1041\n5. You call `read_inode(fd, sb, 1041, &inode)`, convert to a POSIX `struct stat`, and return it\n6. FUSE kernel module delivers the `stat` result to the calling process\nStep 3â€“4 is 3+ disk reads on a cold cache. For a process that calls `stat` on 10,000 files (like `find` or `git status`), that is 30,000+ cold disk reads just for path resolution. This is why the Linux VFS maintains a **dcache** (directory entry cache): a kernel-level hash table mapping `(parent_inode_number, filename)` to child inode number. FUSE can optionally tell the kernel to cache lookup results, dramatically reducing path resolution costs. We will implement this with entry timeouts.\nThe numbers matter here:\n- Cold path resolution (3 disk reads Ã— 100Î¼s per SSD read) = ~300Î¼s per lookup\n- With dcache hit: ~1Î¼s (pure kernel memory access)\n- With FUSE entry timeout cache: after first lookup, subsequent lookups return cached result for the configured timeout duration\nThis 300Ã— difference between cached and uncached lookup explains why `ls` on a freshly mounted FUSE filesystem feels slow, while the second `ls` feels instant.\n---\n## Installing libfuse and Project Structure\nBefore writing a single callback, set up your build environment. On Linux, libfuse 3.x is the current major version and the one we will use:\n```bash\n# Debian/Ubuntu\nsudo apt-get install libfuse3-dev fuse3\n# Fedora/RHEL\nsudo dnf install fuse3-devel\n# Verify\npkg-config --modversion fuse3\n```\nYour project now has two main entry points: `mkfs.c` (from Milestone 1) and `myfs.c` (the FUSE daemon). A sensible Makefile:\n```makefile\nCC      = gcc\nCFLAGS  = -Wall -Wextra -g -O2 $(shell pkg-config --cflags fuse3)\nLDFLAGS = $(shell pkg-config --libs fuse3)\nSRCS_COMMON = block.c bitmap.c inode.c dir.c file.c\nSRCS_MKFS   = mkfs.c $(SRCS_COMMON)\nSRCS_MYFS   = myfs.c $(SRCS_COMMON)\nall: mkfs myfs\nmkfs: $(SRCS_MKFS)\n\t$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)\nmyfs: $(SRCS_MYFS)\n\t$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)\nclean:\n\trm -f mkfs myfs *.o\n```\nNotice `FUSE_USE_VERSION` â€” this macro tells libfuse which API version you target. Always set it before including the FUSE header:\n```c\n/*\n * myfs.c â€” FUSE integration layer.\n *\n * MUST define FUSE_USE_VERSION before including fuse.h.\n * 31 targets the libfuse 3.x \"high-level\" API.\n */\n#define FUSE_USE_VERSION 31\n#include <fuse.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <pthread.h>\n#include <time.h>\n#include <unistd.h>\n#include \"fs.h\"   /* your superblock_t, inode_t, all Milestone 1-4 functions */\n```\n---\n## Global State: The Filesystem Context\nYour FUSE daemon is a long-running process that holds all filesystem state. The state must be accessible from every FUSE callback, which libfuse delivers on different threads. Package everything into a single context struct:\n```c\n/*\n * Global filesystem context.\n * Initialized during mount; accessed by all FUSE callbacks.\n *\n * Thread safety: All filesystem operations acquire fs_lock before\n * modifying any shared state. A coarse-grained global mutex is correct\n * for initial implementation; Milestone 6 will introduce per-transaction\n * locking via the journal.\n *\n * MEMORY LAYOUT:\n *   fs_ctx:                  ~512 bytes (struct + sb fields)\n *   fs_ctx.sb:               4096 bytes (superblock, kept in memory)\n *   Lock overhead (pthread): 40 bytes typical\n */\ntypedef struct {\n    int         fd;             /* file descriptor of the disk image */\n    superblock_t sb;            /* in-memory copy of the superblock */\n    pthread_mutex_t lock;       /* global filesystem mutex */\n    char        image_path[256]; /* path to disk image, for fsync on unmount */\n} fs_ctx_t;\nstatic fs_ctx_t g_fs;\n/*\n * RAII-style lock helpers.\n * Use these in every callback â€” never call pthread_mutex_lock directly.\n */\nstatic inline void fs_lock(void)   { pthread_mutex_lock(&g_fs.lock); }\nstatic inline void fs_unlock(void) { pthread_mutex_unlock(&g_fs.lock); }\n```\n> **Hardware Soul â€” Cache Line Contention on the Global Lock**\n> The `g_fs` struct is accessed by multiple threads simultaneously. The `pthread_mutex_t` at offset `8 + 4096 = 4104` bytes into the struct â€” this is on a different cache line (64 bytes) than the `fd` and `sb` fields. This matters: when one thread holds the lock and another thread spins waiting, the spinning thread repeatedly reads the mutex state, keeping that cache line hot. If the mutex shared a cache line with `fd` or `sb`, every lock acquisition would invalidate the `fd` cache line in the holder's CPU, causing false sharing. The struct layout above avoids this naturally because `sb` is 4096 bytes and pushes `lock` onto its own cache line.\nThe `fuse_get_context()` function provides per-call information (UID, GID, PID of the calling process). You can use it inside callbacks to implement permission checking:\n```c\n/* Get the context inside a FUSE callback */\nstruct fuse_context *ctx = fuse_get_context();\nuid_t caller_uid = ctx->uid;\ngid_t caller_gid = ctx->gid;\n```\n---\n## The Path Translation Problem: Your Central Design\nEvery FUSE high-level API callback receives a path string. Your internal functions operate on inode numbers. The translation is `path_resolve` from Milestone 3. But calling `path_resolve` naively in every callback carries a cost: each component lookup is a directory block read.\nWe need a helper that cleanly bridges this gap and handles the common case (getting an inode for a path, then doing something with it):\n```c\n/*\n * Resolve a path to an inode number.\n * Returns inode number (> 0) on success, negative errno on failure.\n *\n * This is the hottest function in the FUSE layer. Every callback\n * starts here. Profile first if optimizing.\n *\n * Thread safety: Caller must hold fs_lock.\n */\nstatic int resolve_path(const char *path) {\n    return path_resolve(g_fs.fd, &g_fs.sb, path,\n                        g_fs.sb.root_inode, g_fs.sb.root_inode);\n}\n/*\n * Resolve a path and read its inode into *out.\n * Returns 0 on success, negative errno on failure.\n *\n * Thread safety: Caller must hold fs_lock.\n */\nstatic int path_to_inode(const char *path, uint32_t *ino_out, inode_t *inode_out) {\n    int ino = resolve_path(path);\n    if (ino < 0) return ino;\n    if (read_inode(g_fs.fd, &g_fs.sb, (uint32_t)ino, inode_out) != 0)\n        return -EIO;\n    *ino_out = (uint32_t)ino;\n    return 0;\n}\n```\nFor operations that need both a parent directory and a leaf name (create, mkdir, unlink, rmdir, rename), we need path decomposition:\n```c\n/*\n * Split \"/home/user/file.txt\" into parent_path=\"/home/user\" and name=\"file.txt\".\n * Returns 0 on success, -EINVAL if path has no parent (root).\n *\n * Writes into caller-supplied buffers. parent_buf must be PATH_MAX bytes.\n * name_out points into path (no allocation needed) â€” do not modify.\n *\n * Thread safety: No shared state; safe to call without lock.\n */\nstatic int split_path(const char *path,\n                      char *parent_buf, size_t parent_buf_size,\n                      const char **name_out) {\n    const char *last_slash = strrchr(path, '/');\n    if (last_slash == NULL) return -EINVAL;\n    *name_out = last_slash + 1;\n    if (**name_out == '\\0') return -EINVAL;   /* trailing slash */\n    size_t parent_len = (size_t)(last_slash - path);\n    if (parent_len == 0) {\n        /* parent is root: path = \"/filename\" */\n        if (parent_buf_size < 2) return -ENAMETOOLONG;\n        parent_buf[0] = '/';\n        parent_buf[1] = '\\0';\n    } else {\n        if (parent_len >= parent_buf_size) return -ENAMETOOLONG;\n        memcpy(parent_buf, path, parent_len);\n        parent_buf[parent_len] = '\\0';\n    }\n    return 0;\n}\n```\n---\n## Mapping Inodes to `struct stat`: The `inode_to_stat` Bridge\nEvery FUSE callback that returns file metadata â€” `getattr`, `lookup`, `readdir` â€” must fill in a POSIX `struct stat`. This struct is what `ls -la`, `stat`, and `fstat` return to applications. Getting it right is critical: `ls` calls `getattr` on every path, and if `getattr` returns wrong values, nothing works.\n```c\n/*\n * Convert an in-memory inode_t to a POSIX struct stat.\n *\n * struct stat field mapping:\n *   st_ino     â† inode number\n *   st_mode    â† inode.mode (already in POSIX format: S_IFDIR | 0755, etc.)\n *   st_nlink   â† inode.nlinks\n *   st_uid     â† inode.uid\n *   st_gid     â† inode.gid\n *   st_size    â† inode.size (logical file size in bytes)\n *   st_blocks  â† computed: disk blocks used Ã— 512-byte units (POSIX convention)\n *   st_blksize â† 4096 (preferred I/O block size hint to applications)\n *   st_atime   â† inode.atime\n *   st_mtime   â† inode.mtime\n *   st_ctime   â† inode.ctime\n *\n * Note: st_blocks is in 512-byte units by POSIX convention, even though\n * our actual block size is 4096. Multiply logical block count by 8\n * (4096/512 = 8) to get the correct st_blocks value.\n */\nstatic void inode_to_stat(const inode_t *inode, uint32_t ino_num,\n                            struct stat *st) {\n    memset(st, 0, sizeof(*st));\n    st->st_ino     = ino_num;\n    st->st_mode    = inode->mode;\n    st->st_nlink   = inode->nlinks;\n    st->st_uid     = inode->uid;\n    st->st_gid     = inode->gid;\n    st->st_size    = inode->size;\n    st->st_blksize = BLOCK_SIZE;\n    /*\n     * Compute number of 512-byte blocks actually allocated on disk.\n     * For sparse files: count only non-null direct block pointers.\n     * For a full count including indirect blocks, we'd need to traverse\n     * the pointer tree. For simplicity, approximate from size.\n     */\n    st->st_blocks  = ((off_t)inode->size + 511) / 512;\n    /* Timestamps: struct stat uses struct timespec for nanosecond precision.\n     * Our inode stores only second-precision Unix timestamps.\n     * The .tv_nsec field is 0 â€” acceptable for our implementation. */\n    st->st_atim.tv_sec  = inode->atime;\n    st->st_atim.tv_nsec = 0;\n    st->st_mtim.tv_sec  = inode->mtime;\n    st->st_mtim.tv_nsec = 0;\n    st->st_ctim.tv_sec  = inode->ctime;\n    st->st_ctim.tv_nsec = 0;\n}\n```\n> **The `getattr` Pitfall**: `getattr` is the first callback FUSE invokes for virtually every operation. Before `ls` can list directory contents, it calls `getattr` on the directory itself. Before `open` can open a file, the kernel calls `getattr`. Before `cp` can copy, `getattr` on both source and destination. If your `getattr` implementation is wrong or slow, nothing else in the system works. Test it first, test it exhaustively, test it before anything else.\n---\n## Implementing the Core Callbacks\n\n![FUSE Callbacks â†’ Internal Operations Mapping Table](./diagrams/diag-m5-callback-mapping.svg)\n\n### `getattr` â€” The Most Called Callback\n```c\n/*\n * getattr â€” Get file attributes.\n *\n * Called by: stat(), lstat(), fstat(), open(), ls, find, cp, mv â€” everything.\n * This is the hottest callback in the system.\n *\n * FUSE high-level API signature:\n *   path:   absolute path within the mount (e.g., \"/home/user/file.txt\")\n *   st:     struct stat to fill in\n *   fi:     file info (may be NULL for path-based calls; non-NULL for fd-based)\n *\n * Returns 0 on success, negative errno on failure.\n */\nstatic int myfs_getattr(const char *path, struct stat *st,\n                         struct fuse_file_info *fi) {\n    (void)fi;   /* unused in our implementation */\n    fs_lock();\n    uint32_t ino;\n    inode_t inode;\n    int r = path_to_inode(path, &ino, &inode);\n    if (r < 0) {\n        fs_unlock();\n        return r;   /* -ENOENT, -EIO, etc. */\n    }\n    inode_to_stat(&inode, ino, st);\n    fs_unlock();\n    return 0;\n}\n```\n### `readdir` â€” Directory Listing\n`readdir` is called when any program lists directory contents: `ls`, `find`, `opendir`/`readdir` loops, `glob`. libfuse's high-level API provides a `filler` function that you call for each entry:\n```c\n/*\n * readdir â€” List directory contents.\n *\n * Called by: ls, find, opendir/readdir, glob expansion.\n *\n * For each entry, call filler(buf, name, stat_or_NULL, offset, fill_flags).\n * Returning stat is optional (NULL means FUSE will call getattr separately).\n * Providing stat avoids an extra getattr round-trip â€” do it for performance.\n *\n * We always output '.' and '..' first, as POSIX requires.\n */\ntypedef struct {\n    void *buf;\n    fuse_fill_dir_t filler;\n    int error;\n    int fd;\n    superblock_t *sb;\n} readdir_ctx_t;\nstatic void readdir_emit(const char *name, uint32_t inode_num,\n                          uint8_t file_type, void *userdata) {\n    readdir_ctx_t *ctx = (readdir_ctx_t *)userdata;\n    if (ctx->error != 0) return;  /* short-circuit on previous error */\n    struct stat st;\n    memset(&st, 0, sizeof(st));\n    /* Read the inode to fill stat â€” costs a disk read per entry.\n     * For large directories this adds up; a future optimization would\n     * cache inode reads here. */\n    inode_t inode;\n    if (read_inode(ctx->fd, ctx->sb, inode_num, &inode) == 0) {\n        inode_to_stat(&inode, inode_num, &st);\n    } else {\n        /* Populate minimal stat from directory entry type hint */\n        st.st_ino = inode_num;\n        st.st_mode = (file_type == FT_DIR) ? S_IFDIR | 0755 : S_IFREG | 0644;\n    }\n    int r = ctx->filler(ctx->buf, name, &st, 0, FUSE_FILL_DIR_PLUS);\n    if (r != 0) {\n        ctx->error = -ENOMEM;  /* filler returns non-zero when buffer is full */\n    }\n}\nstatic int myfs_readdir(const char *path, void *buf, fuse_fill_dir_t filler,\n                         off_t offset, struct fuse_file_info *fi,\n                         enum fuse_readdir_flags flags) {\n    (void)offset; (void)fi; (void)flags;\n    fs_lock();\n    uint32_t ino;\n    inode_t inode;\n    int r = path_to_inode(path, &ino, &inode);\n    if (r < 0) { fs_unlock(); return r; }\n    if (!S_ISDIR(inode.mode)) { fs_unlock(); return -ENOTDIR; }\n    readdir_ctx_t ctx = {\n        .buf    = buf,\n        .filler = filler,\n        .error  = 0,\n        .fd     = g_fs.fd,\n        .sb     = &g_fs.sb,\n    };\n    /* dir_readdir calls readdir_emit for each entry (including '.' and '..') */\n    dir_readdir(g_fs.fd, &g_fs.sb, ino, readdir_emit, &ctx);\n    fs_unlock();\n    return ctx.error;\n}\n```\n### `open` and `release` â€” File Handle Lifecycle\nIn libfuse's high-level API, `open` does not need to allocate OS-level resources â€” libfuse handles that. Your `open` implementation validates that the file exists and is accessible. The `fi->fh` field (file handle) lets you store a per-open-file opaque value â€” we store the inode number there for fast access in subsequent `read`/`write` calls:\n```c\n/*\n * open â€” Open a file.\n *\n * Called when any process calls open(2), fopen(3), etc.\n * fi->flags contains the open flags (O_RDONLY, O_WRONLY, O_RDWR, O_TRUNC, etc.)\n *\n * We validate existence and permissions here.\n * We store the inode number in fi->fh to avoid re-resolving the path on every read/write.\n */\nstatic int myfs_open(const char *path, struct fuse_file_info *fi) {\n    fs_lock();\n    uint32_t ino;\n    inode_t inode;\n    int r = path_to_inode(path, &ino, &inode);\n    if (r < 0) { fs_unlock(); return r; }\n    if (S_ISDIR(inode.mode)) { fs_unlock(); return -EISDIR; }\n    /* Handle O_TRUNC flag: truncate file to zero on open */\n    if (fi->flags & O_TRUNC) {\n        r = fs_truncate(g_fs.fd, &g_fs.sb, ino, 0);\n        if (r != 0) { fs_unlock(); return r; }\n    }\n    /* Store inode number in file handle for fast access later */\n    fi->fh = ino;\n    /*\n     * Set direct_io flag to bypass FUSE's page cache for this file.\n     * Without this, FUSE caches file data in the kernel's page cache,\n     * which can serve stale reads if another process modifies the file\n     * directly. For our implementation, disable kernel-side page caching\n     * to ensure reads always go through our fs_read() function.\n     *\n     * Trade-off: disabling the kernel page cache means every read causes\n     * a call to our read callback. For read-heavy workloads, enabling the\n     * cache (removing this line) dramatically improves performance.\n     */\n    fi->direct_io = 1;\n    fs_unlock();\n    return 0;\n}\n/*\n * release â€” Called when the last reference to an open file is closed.\n *\n * Note: \"release\" in FUSE means \"the last open file descriptor is closed.\"\n * This is NOT called for every close(2) â€” only when the kernel's reference\n * count for this file drops to zero. Multiple opens of the same file by the\n * same process may result in only one release.\n *\n * Here: flush any pending writes, clean up per-file state.\n */\nstatic int myfs_release(const char *path, struct fuse_file_info *fi) {\n    (void)path;\n    fs_lock();\n    /* fsync the disk image to ensure all writes are durable.\n     * In production, you would do this selectively (only if file was written).\n     * fi->fh holds the inode number we stored in open(). */\n    fsync(g_fs.fd);\n    (void)fi;\n    fs_unlock();\n    return 0;\n}\n```\n> **`open` vs `create` in FUSE**: When a process calls `open(\"path\", O_CREAT | O_WRONLY, 0644)`, FUSE will call the `create` callback if you have registered it, or fall back to calling `mknod` followed by `open` if you haven't. You MUST register `create` â€” if you omit it, `echo \"text\" > file` will fail because the shell uses `O_CREAT`. The `mknod` fallback does not work correctly for regular files.\n### `create` â€” The O_CREAT Path\n```c\n/*\n * create â€” Create and open a file atomically.\n *\n * Called when: open(O_CREAT | O_WRONLY), open(O_CREAT | O_RDWR),\n *              creat(2), fopen(\"w\"), echo > file\n *\n * Must create the file AND open it. Store inode number in fi->fh.\n * If the file already exists and O_EXCL is set, return -EEXIST.\n */\nstatic int myfs_create(const char *path, mode_t mode,\n                        struct fuse_file_info *fi) {\n    char parent_path[PATH_MAX];\n    const char *name;\n    int r = split_path(path, parent_path, sizeof(parent_path), &name);\n    if (r < 0) return r;\n    fs_lock();\n    /* Resolve parent directory */\n    int parent_ino = resolve_path(parent_path);\n    if (parent_ino < 0) { fs_unlock(); return parent_ino; }\n    /* If O_EXCL: fail if file already exists */\n    inode_t parent_inode;\n    read_inode(g_fs.fd, &g_fs.sb, (uint32_t)parent_ino, &parent_inode);\n    int existing = dir_lookup(g_fs.fd, &g_fs.sb, &parent_inode, name);\n    if (existing > 0) {\n        if (fi->flags & O_EXCL) { fs_unlock(); return -EEXIST; }\n        /* File exists, O_EXCL not set: open existing file */\n        fi->fh = (uint64_t)existing;\n        if (fi->flags & O_TRUNC)\n            fs_truncate(g_fs.fd, &g_fs.sb, (uint32_t)existing, 0);\n        fs_unlock();\n        return 0;\n    }\n    /* Get caller identity for ownership */\n    struct fuse_context *ctx = fuse_get_context();\n    /* Create the new file */\n    int new_ino = fs_create_file(g_fs.fd, &g_fs.sb,\n                                  (uint32_t)parent_ino, name,\n                                  (uint16_t)(mode & 0777),\n                                  (uint16_t)ctx->uid,\n                                  (uint16_t)ctx->gid);\n    if (new_ino < 0) { fs_unlock(); return new_ino; }\n    fi->fh       = (uint64_t)new_ino;\n    fi->direct_io = 1;\n    /* Persist superblock (free counts changed) */\n    uint8_t sb_buf[BLOCK_SIZE];\n    memset(sb_buf, 0, BLOCK_SIZE);\n    memcpy(sb_buf, &g_fs.sb, sizeof(g_fs.sb));\n    write_block(g_fs.fd, 0, sb_buf);\n    fs_unlock();\n    return 0;\n}\n```\n### `read` and `write` â€” Data Plane Callbacks\nThese are the most performance-critical callbacks. FUSE delivers `read` requests with a pre-allocated buffer; `write` requests with the data to write. Both use the inode number stored in `fi->fh` from `open`/`create`:\n```c\n/*\n * read â€” Read data from an open file.\n *\n * size: maximum bytes to return (FUSE may request up to 128KB at once)\n * offset: byte offset within the file\n * Returns number of bytes actually read (may be less than size at EOF).\n */\nstatic int myfs_read(const char *path, char *buf, size_t size,\n                      off_t offset, struct fuse_file_info *fi) {\n    (void)path;   /* fi->fh has the inode number from open() */\n    if (offset < 0) return -EINVAL;\n    fs_lock();\n    ssize_t nread = fs_read(g_fs.fd, &g_fs.sb,\n                             (uint32_t)fi->fh,\n                             (uint64_t)offset, buf, size);\n    fs_unlock();\n    return (int)nread;\n}\n/*\n * write â€” Write data to an open file.\n *\n * Returns number of bytes written (should always equal size â€” partial\n * writes indicate errors; FUSE will retry). Return negative errno on error.\n */\nstatic int myfs_write(const char *path, const char *buf, size_t size,\n                       off_t offset, struct fuse_file_info *fi) {\n    (void)path;\n    if (offset < 0) return -EINVAL;\n    fs_lock();\n    ssize_t nwritten = fs_write(g_fs.fd, &g_fs.sb,\n                                 (uint32_t)fi->fh,\n                                 (uint64_t)offset, buf, size);\n    if (nwritten > 0) {\n        /* Persist superblock (free block count may have changed) */\n        uint8_t sb_buf[BLOCK_SIZE];\n        memset(sb_buf, 0, BLOCK_SIZE);\n        memcpy(sb_buf, &g_fs.sb, sizeof(g_fs.sb));\n        write_block(g_fs.fd, 0, sb_buf);\n    }\n    fs_unlock();\n    return (int)nwritten;\n}\n```\n### `mkdir` and `rmdir`\n```c\nstatic int myfs_mkdir(const char *path, mode_t mode) {\n    char parent_path[PATH_MAX];\n    const char *name;\n    int r = split_path(path, parent_path, sizeof(parent_path), &name);\n    if (r < 0) return r;\n    fs_lock();\n    int parent_ino = resolve_path(parent_path);\n    if (parent_ino < 0) { fs_unlock(); return parent_ino; }\n    struct fuse_context *ctx = fuse_get_context();\n    int new_ino = fs_mkdir(g_fs.fd, &g_fs.sb,\n                            (uint32_t)parent_ino, name,\n                            (uint16_t)(mode & 0777),\n                            (uint16_t)ctx->uid,\n                            (uint16_t)ctx->gid);\n    if (new_ino < 0) { fs_unlock(); return new_ino; }\n    /* Persist superblock */\n    uint8_t sb_buf[BLOCK_SIZE];\n    memset(sb_buf, 0, BLOCK_SIZE);\n    memcpy(sb_buf, &g_fs.sb, sizeof(g_fs.sb));\n    write_block(g_fs.fd, 0, sb_buf);\n    fs_unlock();\n    return 0;\n}\nstatic int myfs_rmdir(const char *path) {\n    char parent_path[PATH_MAX];\n    const char *name;\n    int r = split_path(path, parent_path, sizeof(parent_path), &name);\n    if (r < 0) return r;\n    fs_lock();\n    int parent_ino = resolve_path(parent_path);\n    if (parent_ino < 0) { fs_unlock(); return parent_ino; }\n    r = fs_rmdir(g_fs.fd, &g_fs.sb, (uint32_t)parent_ino, name);\n    fs_unlock();\n    return r;\n}\n```\n### `unlink` â€” File Deletion\n```c\nstatic int myfs_unlink(const char *path) {\n    char parent_path[PATH_MAX];\n    const char *name;\n    int r = split_path(path, parent_path, sizeof(parent_path), &name);\n    if (r < 0) return r;\n    fs_lock();\n    int parent_ino = resolve_path(parent_path);\n    if (parent_ino < 0) { fs_unlock(); return parent_ino; }\n    r = fs_unlink(g_fs.fd, &g_fs.sb, (uint32_t)parent_ino, name);\n    if (r == 0) {\n        uint8_t sb_buf[BLOCK_SIZE];\n        memset(sb_buf, 0, BLOCK_SIZE);\n        memcpy(sb_buf, &g_fs.sb, sizeof(g_fs.sb));\n        write_block(g_fs.fd, 0, sb_buf);\n    }\n    fs_unlock();\n    return r;\n}\n```\n### `truncate` â€” Resize from Path\n```c\nstatic int myfs_truncate(const char *path, off_t new_size,\n                           struct fuse_file_info *fi) {\n    if (new_size < 0) return -EINVAL;\n    fs_lock();\n    uint32_t ino;\n    int r;\n    if (fi != NULL) {\n        /* fd-based truncate: fi->fh has inode number */\n        ino = (uint32_t)fi->fh;\n        r = 0;\n    } else {\n        /* path-based truncate */\n        inode_t inode;\n        r = path_to_inode(path, &ino, &inode);\n    }\n    if (r == 0)\n        r = fs_truncate(g_fs.fd, &g_fs.sb, ino, (uint64_t)new_size);\n    fs_unlock();\n    return r;\n}\n```\n### `chmod` and `utimens` â€” Metadata Changes\n```c\nstatic int myfs_chmod(const char *path, mode_t mode,\n                       struct fuse_file_info *fi) {\n    (void)fi;\n    fs_lock();\n    uint32_t ino;\n    inode_t inode;\n    int r = path_to_inode(path, &ino, &inode);\n    if (r < 0) { fs_unlock(); return r; }\n    /* Replace permission bits; preserve file type bits */\n    inode.mode = (inode.mode & S_IFMT) | (mode & 07777);\n    inode.ctime = (uint32_t)time(NULL);\n    r = write_inode(g_fs.fd, &g_fs.sb, ino, &inode);\n    fs_unlock();\n    return r;\n}\nstatic int myfs_utimens(const char *path, const struct timespec ts[2],\n                         struct fuse_file_info *fi) {\n    (void)fi;\n    fs_lock();\n    uint32_t ino;\n    inode_t inode;\n    int r = path_to_inode(path, &ino, &inode);\n    if (r < 0) { fs_unlock(); return r; }\n    /* ts[0] = atime, ts[1] = mtime */\n    if (ts[0].tv_nsec != UTIME_OMIT)\n        inode.atime = (uint32_t)ts[0].tv_sec;\n    if (ts[1].tv_nsec != UTIME_OMIT)\n        inode.mtime = (uint32_t)ts[1].tv_sec;\n    inode.ctime = (uint32_t)time(NULL);\n    r = write_inode(g_fs.fd, &g_fs.sb, ino, &inode);\n    fs_unlock();\n    return r;\n}\n```\n---\n## `rename`: The Hardest Operation\n`rename` is the most complex single operation in any filesystem. At the POSIX level, `rename(old, new)` must be **atomic**: any process that observes the filesystem either sees the old name or the new name, never a state where neither exists. This is a crash-consistency requirement even before Milestone 6's journal.\nThe implementation must handle four distinct cases:\n1. **Simple rename in the same directory**: `rename(\"/home/user/a\", \"/home/user/b\")`\n2. **Move to different directory**: `rename(\"/home/user/a\", \"/tmp/a\")`  \n3. **Replace an existing file**: `rename(\"/tmp/new\", \"/tmp/old\")` â€” `old` must be atomically replaced\n4. **Replace with a directory**: the target must be an empty directory\n```c\n/*\n * rename â€” Move/rename a file or directory.\n *\n * POSIX guarantees: if new_path already exists, it is atomically replaced.\n * Without journaling, we approximate atomicity by careful write ordering:\n *   1. Write new directory entry pointing to the inode\n *   2. Remove old directory entry\n * If we crash between 1 and 2, the file has two names â€” detectable by fsck.\n * If we crash after 2 but before 1... well, ordering prevents this.\n *\n * flags: RENAME_NOREPLACE (fail if new_path exists), RENAME_EXCHANGE (swap),\n *        etc. We implement only the basic rename (flags == 0).\n */\nstatic int myfs_rename(const char *old_path, const char *new_path,\n                        unsigned int flags) {\n    if (flags != 0) return -EINVAL;   /* RENAME_NOREPLACE etc. not implemented */\n    char old_parent[PATH_MAX], new_parent[PATH_MAX];\n    const char *old_name, *new_name;\n    int r;\n    r = split_path(old_path, old_parent, sizeof(old_parent), &old_name);\n    if (r < 0) return r;\n    r = split_path(new_path, new_parent, sizeof(new_parent), &new_name);\n    if (r < 0) return r;\n    fs_lock();\n    int old_parent_ino = resolve_path(old_parent);\n    if (old_parent_ino < 0) { fs_unlock(); return old_parent_ino; }\n    int new_parent_ino = resolve_path(new_parent);\n    if (new_parent_ino < 0) { fs_unlock(); return new_parent_ino; }\n    /* Find the inode we're moving */\n    inode_t old_parent_inode;\n    read_inode(g_fs.fd, &g_fs.sb, (uint32_t)old_parent_ino, &old_parent_inode);\n    int src_ino = dir_lookup(g_fs.fd, &g_fs.sb, &old_parent_inode, old_name);\n    if (src_ino <= 0) { fs_unlock(); return src_ino < 0 ? src_ino : -ENOENT; }\n    inode_t src_inode;\n    read_inode(g_fs.fd, &g_fs.sb, (uint32_t)src_ino, &src_inode);\n    /* Check if new_path already exists */\n    inode_t new_parent_inode;\n    read_inode(g_fs.fd, &g_fs.sb, (uint32_t)new_parent_ino, &new_parent_inode);\n    int dst_ino = dir_lookup(g_fs.fd, &g_fs.sb, &new_parent_inode, new_name);\n    if (dst_ino > 0) {\n        /* new_path exists: must atomically replace it */\n        inode_t dst_inode;\n        read_inode(g_fs.fd, &g_fs.sb, (uint32_t)dst_ino, &dst_inode);\n        if (S_ISDIR(src_inode.mode) && !S_ISDIR(dst_inode.mode))\n            { fs_unlock(); return -ENOTDIR; }\n        if (!S_ISDIR(src_inode.mode) && S_ISDIR(dst_inode.mode))\n            { fs_unlock(); return -EISDIR; }\n        if (S_ISDIR(dst_inode.mode) && !dir_is_empty(g_fs.fd, &dst_inode))\n            { fs_unlock(); return -ENOTEMPTY; }\n        /* Remove the existing destination entry (freeing dst if nlinks â†’ 0) */\n        if (S_ISDIR(dst_inode.mode))\n            r = fs_rmdir(g_fs.fd, &g_fs.sb, (uint32_t)new_parent_ino, new_name);\n        else\n            r = fs_unlink(g_fs.fd, &g_fs.sb, (uint32_t)new_parent_ino, new_name);\n        if (r < 0) { fs_unlock(); return r; }\n        /* Reload new_parent_inode as it may have changed */\n        read_inode(g_fs.fd, &g_fs.sb, (uint32_t)new_parent_ino, &new_parent_inode);\n    }\n    /* Step 1: Add new entry in destination directory */\n    uint8_t ft = S_ISDIR(src_inode.mode) ? FT_DIR : FT_REG_FILE;\n    r = dir_add_entry(g_fs.fd, &g_fs.sb,\n                      (uint32_t)new_parent_ino, new_name,\n                      (uint32_t)src_ino, ft);\n    if (r < 0) { fs_unlock(); return r; }\n    /* If moving a directory, update its '..' entry to point to new parent */\n    if (S_ISDIR(src_inode.mode) &&\n        (uint32_t)old_parent_ino != (uint32_t)new_parent_ino) {\n        /* Read src directory's data block, update '..' inode_num */\n        uint8_t dir_buf[BLOCK_SIZE];\n        if (src_inode.blocks[0] != 0 &&\n            read_block(g_fs.fd, src_inode.blocks[0], dir_buf) == 0) {\n            /* '..' is the second entry; find and update it */\n            dirent_t dot;\n            uint16_t dot_len = dirent_read_from_buf(dir_buf, 0, &dot);\n            if (dot_len > 0) {\n                dirent_t dotdot;\n                dirent_read_from_buf(dir_buf, dot_len, &dotdot);\n                dotdot.inode_num = (uint32_t)new_parent_ino;\n                dirent_write_to_buf(dir_buf, dot_len, &dotdot);\n                write_block(g_fs.fd, src_inode.blocks[0], dir_buf);\n            }\n        }\n        /* Old parent loses one '..' reference; new parent gains one */\n        inode_t op_inode, np_inode;\n        read_inode(g_fs.fd, &g_fs.sb, (uint32_t)old_parent_ino, &op_inode);\n        read_inode(g_fs.fd, &g_fs.sb, (uint32_t)new_parent_ino, &np_inode);\n        if (op_inode.nlinks > 0) op_inode.nlinks--;\n        np_inode.nlinks++;\n        op_inode.ctime = np_inode.ctime = (uint32_t)time(NULL);\n        write_inode(g_fs.fd, &g_fs.sb, (uint32_t)old_parent_ino, &op_inode);\n        write_inode(g_fs.fd, &g_fs.sb, (uint32_t)new_parent_ino, &np_inode);\n    }\n    /* Step 2: Remove old entry from source directory */\n    /* Use a lower-level removal that does NOT decrement src_ino's nlinks */\n    /* (we're not deleting the file, just moving the directory entry) */\n    /* Temporarily increment nlinks to prevent free_inode on remove */\n    src_inode.nlinks++;\n    write_inode(g_fs.fd, &g_fs.sb, (uint32_t)src_ino, &src_inode);\n    r = dir_remove_entry(g_fs.fd, &g_fs.sb, (uint32_t)old_parent_ino, old_name);\n    if (r == 0) {\n        /* dir_remove_entry decremented nlinks; restore to correct value */\n        read_inode(g_fs.fd, &g_fs.sb, (uint32_t)src_ino, &src_inode);\n        /* nlinks is correct now: dir_remove_entry decremented by 1, which undoes our +1 */\n        src_inode.ctime = (uint32_t)time(NULL);\n        write_inode(g_fs.fd, &g_fs.sb, (uint32_t)src_ino, &src_inode);\n    }\n    /* Persist superblock */\n    uint8_t sb_buf[BLOCK_SIZE];\n    memset(sb_buf, 0, BLOCK_SIZE);\n    memcpy(sb_buf, &g_fs.sb, sizeof(g_fs.sb));\n    write_block(g_fs.fd, 0, sb_buf);\n    fs_unlock();\n    return r;\n}\n```\n> **Rename Atomicity Without a Journal**: The write ordering above (add new entry â†’ remove old entry) guarantees that if you crash mid-rename, the file is accessible under at least one name. The worst case is the file having two names temporarily â€” a \"hard link\" that `fsck` can detect. Milestone 6's journal will make rename truly atomic: both operations are in one transaction, applied together or not at all.\n---\n## Concurrency: The Locking Model\n\n![FUSE Concurrency â€” Lock Hierarchy and Critical Sections](./diagrams/diag-m5-locking-strategy.svg)\n\nFUSE by default dispatches callbacks on multiple threads simultaneously. The `default_permissions` option handles POSIX permission checking in the kernel before your callback is invoked. You still need to protect your shared state.\n[[EXPLAIN:pthread-mutex-vs-rwlock-â€”-exclusive-vs-shared-locking-tradeoffs|pthread_mutex_t vs. pthread_rwlock_t â€” when to use exclusive locking vs. reader-writer locks]]\nThe three-tier locking model for a production FUSE filesystem:\n| Level | Scope | Mechanism | When to use |\n|-------|-------|-----------|-------------|\n| **Global mutex (chosen âœ“)** | All filesystem state | `pthread_mutex_t` | Correct, simple, sufficient for most workloads |\n| **Per-inode rwlock** | Single inode's data + metadata | `pthread_rwlock_t` | High-concurrency reads; complex to implement correctly |\n| **Lock-free bitmaps** | Block/inode allocation | Atomic bit operations | Highest performance; requires careful memory ordering |\nFor this milestone, the global mutex is correct and appropriate. The single lock serializes all filesystem operations, making your code trivially safe for concurrent access. The performance cost: concurrent `read` calls from two processes must take turns, even though they could theoretically proceed in parallel.\nThe global lock is standard for FUSE implementations. Even the Linux ext4 filesystem uses per-filesystem locks for many operations. The key is that the lock is held only during your callback execution â€” disk I/O inside the callback holds the lock, which means a slow disk blocks other filesystem operations. A future optimization would use asynchronous I/O and release the lock while waiting for disk, but this requires a fundamentally different architecture.\nRegister a single-threaded FUSE with:\n```c\nstatic struct fuse_operations myfs_ops = { ... };\n/* In main(), when calling fuse_main: add \"-s\" to argv to force single-threaded mode */\n/* Or explicitly use fuse_session_loop_mt() vs fuse_session_loop() */\n```\nFor the initial implementation, single-threaded mode is recommended to eliminate concurrency bugs while you get the callbacks right. Enable multi-threading once all callbacks are working:\n```c\n/* Force single-threaded FUSE for initial development */\n/* Add \"-s\" to fuse args to disable multithreading */\n```\n---\n## The Mount/Unmount Lifecycle\n\n![Mount/Unmount Lifecycle â€” State Machine](./diagrams/diag-m5-mount-unmount-lifecycle.svg)\n\nTwo callbacks control the filesystem's lifecycle: `init` (called once when FUSE is ready to serve requests) and `destroy` (called once when the filesystem unmounts). These are your constructors and destructors:\n```c\n/*\n * init â€” Called when FUSE is ready to handle requests.\n * conn: connection info (protocol version, capabilities).\n * cfg:  FUSE configuration options (caching behavior, timeouts).\n *\n * Returns a pointer passed to all subsequent callbacks as userdata.\n * (We use global state instead, so return NULL.)\n */\nstatic void *myfs_init(struct fuse_conn_info *conn,\n                        struct fuse_config *cfg) {\n    (void)conn;\n    /*\n     * entry_timeout: how long the kernel caches \"name â†’ inode\" lookups.\n     * Setting to 0 disables caching â€” correctness first.\n     * Setting to 1.0 (1 second) dramatically speeds up repeated path lookups.\n     * Trade-off: stale cache if another process modifies the filesystem\n     * directly (not through FUSE). For our single-client model, 1.0 is safe.\n     */\n    cfg->entry_timeout = 1.0;\n    cfg->attr_timeout  = 1.0;  /* how long to cache stat results */\n    cfg->negative_timeout = 0.5;  /* how long to cache ENOENT results */\n    cfg->use_ino = 1;   /* use our inode numbers in readdir and getattr */\n    return NULL;\n}\n/*\n * destroy â€” Called when FUSE unmounts.\n * Flush all pending I/O to disk. Release all resources.\n * After this returns, the disk image must be in a consistent state.\n */\nstatic void myfs_destroy(void *private_data) {\n    (void)private_data;\n    fs_lock();\n    /*\n     * Flush all dirty kernel page cache pages for our disk image to disk.\n     * Without fsync here, recently written data may still be in the kernel's\n     * page cache and lost if the system shuts down after unmount.\n     */\n    fsync(g_fs.fd);\n    /* Persist the current superblock (free counts) */\n    uint8_t sb_buf[BLOCK_SIZE];\n    memset(sb_buf, 0, BLOCK_SIZE);\n    memcpy(sb_buf, &g_fs.sb, sizeof(g_fs.sb));\n    write_block(g_fs.fd, 0, sb_buf);\n    /* Final fsync after superblock write */\n    fsync(g_fs.fd);\n    close(g_fs.fd);\n    pthread_mutex_destroy(&g_fs.lock);\n    fs_unlock();\n    /* Note: do not call fs_unlock() after destroying the mutex */\n}\n```\n> **Pitfall â€” Not fsyncing on Unmount**: When you unmount a FUSE filesystem, the kernel calls your `destroy` callback. If you do not call `fsync(g_fs.fd)` before `close`, any data written by your callbacks but not yet flushed by the host kernel's writeback daemon is lost. The sequence is: your `myfs_write` â†’ host kernel page cache (dirty) â†’ eventual writeback â†’ disk. The writeback may not have happened by the time `destroy` is called. `fsync` forces the flush. This is especially important for the superblock â€” always write and fsync the superblock last, after all data blocks.\n---\n## `statfs` â€” Disk Space Reporting\n`df` and `df -h` call `statfs` to report available disk space. Without it, standard tools cannot report how much space your filesystem has:\n```c\nstatic int myfs_statfs(const char *path, struct statvfs *stbuf) {\n    (void)path;\n    fs_lock();\n    memset(stbuf, 0, sizeof(*stbuf));\n    stbuf->f_bsize   = BLOCK_SIZE;               /* filesystem block size */\n    stbuf->f_frsize  = BLOCK_SIZE;               /* fragment size (same) */\n    stbuf->f_blocks  = g_fs.sb.total_blocks - g_fs.sb.data_block_start;\n    stbuf->f_bfree   = g_fs.sb.free_blocks;\n    stbuf->f_bavail  = g_fs.sb.free_blocks;      /* no reserved blocks */\n    stbuf->f_files   = g_fs.sb.total_inodes;\n    stbuf->f_ffree   = g_fs.sb.free_inodes;\n    stbuf->f_favail  = g_fs.sb.free_inodes;\n    stbuf->f_namemax = MAX_FILENAME_LEN;\n    fs_unlock();\n    return 0;\n}\n```\n---\n## Wiring Everything Together: `main` and Registration\n```c\n/*\n * FUSE operations table.\n * Every NULL field uses FUSE's default behavior.\n * Explicitly NULL-ify operations you haven't implemented â€” don't leave\n * function pointers uninitialized (they point to garbage in C).\n */\nstatic struct fuse_operations myfs_ops = {\n    .init       = myfs_init,\n    .destroy    = myfs_destroy,\n    .getattr    = myfs_getattr,\n    .readdir    = myfs_readdir,\n    .open       = myfs_open,\n    .create     = myfs_create,\n    .read       = myfs_read,\n    .write      = myfs_write,\n    .release    = myfs_release,\n    .mkdir      = myfs_mkdir,\n    .rmdir      = myfs_rmdir,\n    .unlink     = myfs_unlink,\n    .rename     = myfs_rename,\n    .truncate   = myfs_truncate,\n    .chmod      = myfs_chmod,\n    .utimens    = myfs_utimens,\n    .statfs     = myfs_statfs,\n    /* Not implemented in this milestone: */\n    .link       = NULL,   /* hard links: call fs_link from Milestone 3 */\n    .symlink    = NULL,   /* symbolic links: future extension */\n    .readlink   = NULL,\n    .mknod      = NULL,   /* we use create instead */\n    .chown      = NULL,   /* future: update uid/gid */\n    .flush      = NULL,\n    .fsync      = NULL,\n};\n/*\n * main â€” Mount the filesystem.\n *\n * Usage: ./myfs <disk_image> <mountpoint> [fuse options]\n * Example: ./myfs disk.img /mnt/myfs -f -d   (-f foreground, -d debug)\n *          ./myfs disk.img /mnt/myfs -s       (-s single-threaded)\n *\n * We consume the first argument (disk_image) ourselves; the rest\n * are passed to fuse_main.\n */\nint main(int argc, char *argv[]) {\n    if (argc < 3) {\n        fprintf(stderr, \"Usage: %s <disk_image> <mountpoint> [fuse options]\\n\",\n                argv[0]);\n        return 1;\n    }\n    const char *image_path = argv[1];\n    /* Remove disk_image from argv so fuse_main sees only its own args */\n    /* argv[0] = program name, argv[1] = image_path, argv[2..] = fuse args */\n    argc--;\n    argv[1] = argv[0];   /* shift: argv[0]=program, argv[1]=mountpoint, ... */\n    argv++;\n    /* Open the disk image */\n    g_fs.fd = open(image_path, O_RDWR);\n    if (g_fs.fd < 0) {\n        perror(\"open disk image\");\n        return 1;\n    }\n    /* Read and validate the superblock */\n    uint8_t sb_buf[BLOCK_SIZE];\n    if (read_block(g_fs.fd, 0, sb_buf) != 0) {\n        fprintf(stderr, \"Failed to read superblock\\n\");\n        close(g_fs.fd);\n        return 1;\n    }\n    memcpy(&g_fs.sb, sb_buf, sizeof(g_fs.sb));\n    if (g_fs.sb.magic != FS_MAGIC) {\n        fprintf(stderr, \"Invalid filesystem magic: 0x%08X (expected 0x%08X)\\n\",\n                g_fs.sb.magic, FS_MAGIC);\n        close(g_fs.fd);\n        return 1;\n    }\n    /* Initialize the global mutex */\n    if (pthread_mutex_init(&g_fs.lock, NULL) != 0) {\n        perror(\"pthread_mutex_init\");\n        close(g_fs.fd);\n        return 1;\n    }\n    strncpy(g_fs.image_path, image_path, sizeof(g_fs.image_path) - 1);\n    printf(\"Mounting %s\\n\", image_path);\n    printf(\"  Total blocks: %u, Free blocks: %u\\n\",\n           g_fs.sb.total_blocks, g_fs.sb.free_blocks);\n    printf(\"  Total inodes: %u, Free inodes: %u\\n\",\n           g_fs.sb.total_inodes, g_fs.sb.free_inodes);\n    /* Hand off to FUSE */\n    return fuse_main(argc, argv, &myfs_ops, NULL);\n}\n```\n---\n## The `ls -la` Trace: What Actually Happens\n\n!['ls -la /mnt/myfs/home' â€” Complete Syscall-to-Block Trace](./diagrams/diag-m5-ls-trace.svg)\n\nLet's trace exactly what happens when you run `ls -la /mnt/myfs/home` against your mounted filesystem. This is the Three-Level View in full operation:\n| Step | POSIX Syscall | FUSE Callback | Your Code |\n|------|--------------|---------------|-----------|\n| 1 | `stat(\"/mnt/myfs/home\")` | `getattr(\"/home\")` | `path_resolve` â†’ dir_lookup in root â†’ read inode 14 â†’ `inode_to_stat` |\n| 2 | `opendir(\"/mnt/myfs/home\")` | `opendir` (handled by libfuse) | â€” |\n| 3 | `readdir(dir)` â†’ first batch | `readdir(\"/home\")` | `dir_readdir` â†’ scan blocks â†’ `filler(\".\", ...), filler(\"user\", ...)` |\n| 4 | For each entry name: `lstat(\"/mnt/myfs/home/user\")` | `getattr(\"/home/user\")` | `path_resolve(\"/home/user\")` â†’ 2 dir lookups â†’ read inode â†’ `inode_to_stat` |\n| 5 | Repeat step 4 for every entry | â€” | â€” |\nThe critical insight: `ls -la` calls `getattr` **once per entry in the directory**, plus once for the directory itself. A directory with 100 entries generates 101 `getattr` calls. Each `getattr` call, cold, costs 3+ disk reads for path resolution. With the `attr_timeout` cache set to 1.0 second, the second `ls` on the same directory costs only ~1Î¼s per entry (all cache hits).\n> **Hardware Soul â€” The Context Switch Cost**\n> Each FUSE callback involves two context switches: kernelâ†’user (FUSE module writes request to /dev/fuse) and userâ†’kernel (your process writes response back). A context switch on modern x86-64 costs ~2,000â€“5,000 CPU cycles, or ~1â€“2.5Î¼s at 2GHz. For a `getattr` that hits the inode cache (100ns disk read from page cache), the context switch dominates: the round-trip is ~3Î¼s, of which 2Î¼s is context-switch overhead and only 0.1Î¼s is actual work. This is why FUSE adds latency per-operation rather than per-byte: the overhead is constant per call, not proportional to data size.\n---\n## Building and Mounting: Your First Real Mount\n```bash\n# Step 1: Format a 16MB disk image with 1024 inodes\n./mkfs disk.img 4096 1024\n# Step 2: Create a mount point\nmkdir -p /tmp/myfs_mount\n# Step 3: Mount (foreground mode with debug output)\n./myfs disk.img /tmp/myfs_mount -f -d -s\n# In another terminal:\n# Step 4: Test with standard Unix tools\nls -la /tmp/myfs_mount/\nmkdir /tmp/myfs_mount/testdir\necho \"Hello, Filesystem!\" > /tmp/myfs_mount/testdir/hello.txt\ncat /tmp/myfs_mount/testdir/hello.txt\ncp /etc/hosts /tmp/myfs_mount/hosts_copy\nls -la /tmp/myfs_mount/\n# Step 5: Unmount\nfusermount3 -u /tmp/myfs_mount\n# Step 6: Verify persistence â€” remount and check data survived\n./myfs disk.img /tmp/myfs_mount -f -s &\ncat /tmp/myfs_mount/testdir/hello.txt  # Must print \"Hello, Filesystem!\"\nfusermount3 -u /tmp/myfs_mount\n```\nThe `-f` flag runs FUSE in the foreground (so you see debug output and can Ctrl+C to unmount). The `-d` flag enables verbose FUSE debugging showing every callback invocation. The `-s` flag enforces single-threaded mode â€” essential while debugging.\nIf anything fails, FUSE's debug output shows exactly which callback returned which error. Common failures and their causes:\n| Symptom | Callback | Likely Cause |\n|---------|----------|-------------|\n| `ls: cannot access '/mnt': Transport endpoint is not connected` | â€” | Previous mount crashed; run `fusermount3 -u /mnt` first |\n| `ls` shows nothing, no error | `readdir` | `filler` not called for `.` and `..`; or `getattr` returning wrong mode |\n| `cat` returns empty | `read` | `fs_read` returning 0 before EOF; check offset clamping |\n| `echo > file` succeeds but data lost on remount | `write`/`destroy` | Not fsyncing disk image in `destroy` |\n| `cp` into mount returns `ENOSPC` | `write`/`create` | `alloc_block` returning -1; check bitmap and free block count |\n| `mkdir` succeeds but `ls` shows wrong permissions | `getattr` | `inode_to_stat` not copying `st_mode` correctly |\n---\n## Integration Test Suite\nWrite a shell script that exercises every FUSE callback through real Unix tool invocations:\n```bash\n#!/bin/bash\n# test_fuse.sh â€” Integration test for FUSE-mounted filesystem\nset -euo pipefail\nDISK=\"./test_disk.img\"\nMOUNT=\"./test_mount\"\nFS=\"./myfs\"\nMKFS=\"./mkfs\"\ncleanup() {\n    fusermount3 -u \"$MOUNT\" 2>/dev/null || true\n    rm -f \"$DISK\"\n    rmdir \"$MOUNT\" 2>/dev/null || true\n}\ntrap cleanup EXIT\n# Setup\nmkdir -p \"$MOUNT\"\n$MKFS \"$DISK\" 4096 1024\n$FS \"$DISK\" \"$MOUNT\" -s &\nFUSE_PID=$!\nsleep 0.5   # Wait for FUSE to be ready\necho \"=== FUSE Integration Tests ===\"\n# Test 1: Root directory accessible\nls \"$MOUNT\" > /dev/null\necho \"OK: root directory accessible\"\n# Test 2: mkdir and ls\nmkdir \"$MOUNT/testdir\"\nls -la \"$MOUNT\" | grep \"testdir\" > /dev/null\necho \"OK: mkdir creates directory visible to ls\"\n# Test 3: File creation and write\necho \"Hello, Filesystem!\" > \"$MOUNT/testdir/hello.txt\"\necho \"OK: echo > file works\"\n# Test 4: File read\nCONTENT=$(cat \"$MOUNT/testdir/hello.txt\")\n[ \"$CONTENT\" = \"Hello, Filesystem!\" ]\necho \"OK: cat reads correct content\"\n# Test 5: File permissions\nchmod 0600 \"$MOUNT/testdir/hello.txt\"\nPERMS=$(stat -c \"%a\" \"$MOUNT/testdir/hello.txt\")\n[ \"$PERMS\" = \"600\" ]\necho \"OK: chmod works\"\n# Test 6: cp into mount\ncp /etc/hostname \"$MOUNT/hostname_copy\"\ndiff /etc/hostname \"$MOUNT/hostname_copy\"\necho \"OK: cp works, content matches\"\n# Test 7: Large file (multi-block)\ndd if=/dev/urandom of=/tmp/test_large bs=4096 count=100 2>/dev/null\ncp /tmp/test_large \"$MOUNT/large_file\"\ndiff /tmp/test_large \"$MOUNT/large_file\"\necho \"OK: large file (400KB) round-trip correct\"\nrm /tmp/test_large\n# Test 8: rename\nmv \"$MOUNT/testdir/hello.txt\" \"$MOUNT/testdir/renamed.txt\"\n[ ! -e \"$MOUNT/testdir/hello.txt\" ]\nCONTENT=$(cat \"$MOUNT/testdir/renamed.txt\")\n[ \"$CONTENT\" = \"Hello, Filesystem!\" ]\necho \"OK: rename works\"\n# Test 9: rmdir\nmkdir \"$MOUNT/emptydir\"\nrmdir \"$MOUNT/emptydir\"\n[ ! -e \"$MOUNT/emptydir\" ]\necho \"OK: rmdir works\"\n# Test 10: unlink\nrm \"$MOUNT/testdir/renamed.txt\"\n[ ! -e \"$MOUNT/testdir/renamed.txt\" ]\necho \"OK: rm (unlink) works\"\n# Test 11: df reports reasonable values\ndf -h \"$MOUNT\" | grep -v Filesystem > /dev/null\necho \"OK: statfs/df works\"\n# Test 12: Unmount and remount â€” data must persist\nfusermount3 -u \"$MOUNT\"\nwait $FUSE_PID 2>/dev/null || true\n$FS \"$DISK\" \"$MOUNT\" -s &\nFUSE_PID=$!\nsleep 0.5\nHOSTNAME_CONTENT=$(cat \"$MOUNT/hostname_copy\")\n[ -n \"$HOSTNAME_CONTENT\" ]\necho \"OK: data persists across unmount/remount\"\nfusermount3 -u \"$MOUNT\"\nwait $FUSE_PID 2>/dev/null || true\necho \"=== All Integration Tests Passed ===\"\n```\n---\n## Three-Level View: One `open()` Syscall\nLet's trace `open(\"/mnt/myfs/home/user/file.txt\", O_RDONLY)` from application through hardware:\n| Level | What Happens |\n|-------|-------------|\n| **Application** | Calls `open(2)` syscall. CPU switches to kernel mode via syscall interrupt. |\n| **OS / Kernel VFS** | `do_sys_open()` â†’ `file_open_name()` â†’ `path_openat()`. VFS walks the mount table: `/mnt/myfs` is a FUSE mount. Hands off to the FUSE kernel module. FUSE module serializes: opcode=`LOOKUP` for each path component, queued to `/dev/fuse`. Blocks waiting. |\n| **Your Process** | libfuse reads from `/dev/fuse`. Dispatches to `getattr(\"/home/user/file.txt\")`. Your `myfs_getattr` calls `path_resolve` â†’ 3 directory block reads â†’ inode read. Returns `struct stat`. libfuse serializes response, writes to `/dev/fuse`. |\n| **Kernel again** | FUSE module receives response. VFS gets the file's inode attributes. Constructs a `struct file` kernel object. Returns the file descriptor integer to the calling process. |\n| **Hardware** | For cold-cache directory reads: 4 Ã— 100Î¼s SSD reads = 400Î¼s. Page cache fill: DMA transfer from SSD to kernel memory. For warm-cache: 4 Ã— 100ns = 400ns. |\nThe total latency for a warm-cache `open` through FUSE: ~3â€“5Î¼s (two context switches) + ~400ns (cache hits) â‰ˆ **4Î¼s**. For comparison, `open` on a native ext4 file: ~1â€“2Î¼s (one kernel-level path walk, no context switch). The FUSE overhead is 2â€“4Ã— for latency-sensitive operations.\n---\n## Knowledge Cascade: One FUSE Mount, Ten Worlds\n### VFS as Universal Contract: ext4, XFS, NFS, Your Filesystem\nThe VFS layer you have just implemented against (via FUSE) is the same interface that every Linux filesystem implements. ext4, XFS, tmpfs, procfs, sysfs, and NFS all register `inode_operations` and `file_operations` function pointers with the VFS. FUSE simply adds a forwarding layer that sends those calls to userspace instead of handling them in-kernel.\nThis means: everything you built in this milestone â€” the callback signatures, the error codes, the `struct stat` semantics, the `rename` atomicity requirement â€” reflects the VFS contract. When you read the ext4 source code (`fs/ext4/file.c`, `fs/ext4/dir.c`), you will see the same function signatures: `ext4_file_read_iter`, `ext4_readdir`, `ext4_create`, `ext4_rename`. The difference is that ext4's implementations directly manipulate kernel data structures while yours calls across a process boundary. The interface is identical.\nThis knowledge unlocks reading kernel filesystem source code with clarity. The VFS is not a mystery; it is a well-defined interface that you have now implemented.\n[[EXPLAIN:linux-vfs-inode-operations-struct-â€”-the-kernel-interface-every-filesystem-implements|Linux VFS inode_operations struct â€” the complete list of function pointers every kernel filesystem must implement]]\n### Microkernel Architecture Inside a Monolithic Kernel\nFUSE is a microkernel pattern embedded inside Linux's monolithic kernel. In a pure microkernel (QNX, Minix, L4), all device drivers, filesystems, and services run as separate userspace processes communicating via message passing. The kernel provides only IPC, scheduling, and memory management. Everything else â€” including the filesystem â€” is a userspace server.\nLinux chose the monolithic design for performance: fewer context switches, shared address space, faster function calls. But FUSE grafts the microkernel pattern onto it for filesystems specifically, trading the 2â€“5Î¼s per-operation overhead for:\n- **Crash safety**: a bug in your filesystem crashes your process, not the kernel. No kernel panic, no system crash, no reboot required.\n- **Language freedom**: FUSE filesystems can be written in Python, Go, Rust, Java â€” anything with a `/dev/fuse` binding. sshfs was originally written in C but go-fuse enables Go implementations.\n- **Development velocity**: modify your filesystem, kill the old process, mount again. No kernel module recompilation, no `insmod`/`rmmod`, no risk of hanging the kernel during development.\nThis is the exact trade-off that separates QNX (used in automotive safety systems â€” a crash cannot take down the OS) from early Linux (maximum performance â€” filesystem bugs can kernel-panic). FUSE gives Linux the microkernel safety property for filesystem development specifically.\n### gRPC and IPC: FUSE is an RPC System\n[[EXPLAIN:rpc-protocol-â€”-remote-procedure-call-serialization-and-dispatch-over-a-channel|RPC protocol â€” serializing a function call with arguments into bytes, sending over a channel, and deserializing the response]]\nThe `/dev/fuse` protocol is an RPC system. When the kernel dispatches `getattr(\"/home/user/file.txt\")`, it serializes the request into a binary message:\n```\n[unique_id: uint64] [opcode: uint32=FUSE_GETATTR] [len: uint32] [nodeid: uint64] [path: bytes]\n```\nYour process reads this message, dispatches based on `opcode`, executes the handler, and serializes the response:\n```\n[unique_id: uint64 (matches request)] [error: int32=0] [attr: struct fuse_attr]\n```\nThis is structurally identical to gRPC: a client (kernel) serializes a request with a unique ID, sends it over a channel (/dev/fuse â†” network socket), a server (your process) deserializes and handles it, returns a response with the matching ID. The FUSE protocol uses binary encoding (like Protocol Buffers in gRPC); the flow control (one outstanding request per \"session\") is simpler than gRPC's multiplexing, but the pattern is identical.\nUnderstanding FUSE as an RPC system means understanding why latency-sensitive FUSE operations have a fixed overhead: two message serializations and two context switches per call, regardless of data size. This is the same overhead that makes gRPC unsuitable for high-frequency, low-payload calls (where Protocol Buffers serialization overhead dominates over per-byte cost).\n### Thread Safety as a First-Class Design Concern\nYour global `pthread_mutex_t` is your first production-grade use of concurrent locking in this project. The patterns you applied here â€” acquire-before-access, release-before-return, covering all code paths including error paths â€” are the same patterns used in every concurrent system.\nThe classic pitfall you avoided: returning early from a callback without releasing the lock:\n```c\n/* BUG: lock never released if path_to_inode returns early */\nstatic int myfs_getattr_BUGGY(const char *path, struct stat *st, ...) {\n    fs_lock();\n    uint32_t ino;\n    inode_t inode;\n    int r = path_to_inode(path, &ino, &inode);\n    if (r < 0) return r;   /* â† DEADLOCK: lock never released */\n    /* ... */\n    fs_unlock();\n    return 0;\n}\n/* CORRECT: always release before return */\nstatic int myfs_getattr_CORRECT(const char *path, struct stat *st, ...) {\n    fs_lock();\n    uint32_t ino;\n    inode_t inode;\n    int r = path_to_inode(path, &ino, &inode);\n    if (r < 0) { fs_unlock(); return r; }   /* â† unlock on error path */\n    /* ... */\n    fs_unlock();\n    return 0;\n}\n```\nThis pattern â€” \"unlock on every exit path\" â€” is what C++ RAII (`std::lock_guard`), Rust's `MutexGuard`, and Go's `defer mu.Unlock()` automate. In C, you must discipline yourself to write `fs_unlock()` before every `return`. This is a real reason why systems programming in C is error-prone: the compiler does not enforce lock pairing.\nThe alternative you should know about for future optimization: **per-inode reader-writer locks**. Reads from different files can proceed concurrently (multiple readers share the rwlock), but a write to any file still needs exclusive access to that file's inode. The global mutex forces all operations to serialize, even two concurrent reads of completely unrelated files. A `pthread_rwlock_t` per inode eliminates this unnecessary serialization. The complexity cost: lock ordering (always acquire parent-directory lock before child-inode lock), deadlock detection, and the overhead of N mutexes instead of 1.\n### Path Resolution as the Performance Bottleneck\nEvery FUSE callback starts with a path-to-inode translation. For a filesystem mounted at `/mnt/myfs`, a 5-component path like `/home/user/projects/src/main.c` requires 5 directory lookups, each requiring:\n1. Read the inode for the current directory (1 block read)\n2. Read the data block(s) of that directory and scan entries (1+ block reads)\nThat is 10+ disk reads per path resolution, cold. With the page cache warm, it drops to 10+ memory reads (~1Î¼s total). With the FUSE `entry_timeout` cache set to 1.0 second, the kernel caches the translation and your callback is not invoked at all for subsequent lookups within the timeout window.\nThis is why profiling always points to `path_resolve` as the hottest function. The optimization path is:\n1. **FUSE entry/attr timeouts** (already implemented above): free, effective for repeated accesses\n2. **In-process path cache**: a hash map `(path_string â†’ inode_number)` in your process memory, consulted before calling `path_resolve`. Invalidate on any write operation.\n3. **Inode-number-based API**: libfuse's \"low-level\" API works with inode numbers directly, similar to how the kernel VFS works internally. This requires implementing `lookup` (returns inode number for a name in a parent) instead of path-based `getattr`. The kernel caches these lookup results in the dcache and passes inode numbers in subsequent calls, eliminating repeated path walks.\nThe low-level FUSE API (`fuse_lowlevel.h`) is the production path for performance-critical filesystems. It mirrors the kernel's VFS interface exactly: every call carries a parent inode number and a name, not a full path. GlusterFS, the Ceph FUSE client, and most high-performance FUSE filesystems use the low-level API. The high-level API (what we implemented) is simpler to write but sacrifices this optimization.\n---\n## Before You Move On: Pitfall Checklist\n- [ ] **`getattr` on root works**: Run `ls /mnt/myfs` with no files. It must work. `getattr(\"/\")` must return the root inode's `struct stat` with `st_mode = S_IFDIR | 0755` and `st_nlink >= 2`. If this fails, nothing else will.\n- [ ] **`create` registered, not `mknod`**: Shell redirection (`echo > file`) calls `open(O_CREAT)` which FUSE dispatches to `create`. Register `myfs_ops.create`. If it's NULL, file creation silently fails.\n- [ ] **`readdir` emits `.` and `..`**: Some tools (Python's `os.listdir`, `find`) depend on `.` and `..` being in the readdir output. Your `dir_readdir` emits them because they are real directory entries â€” verify with `ls -a`.\n- [ ] **`fi->fh` stores inode number in `open`/`create`**: Your `read` and `write` callbacks use `(uint32_t)fi->fh` as the inode number. Verify that `fi->fh` is set correctly in `open` and `create`. A zero value means you forgot to set it and `read`/`write` will operate on inode 0 (invalid).\n- [ ] **`fsync` in `destroy`**: Unmounting without `fsync(g_fs.fd)` can lose recently written data. Test by writing a file, unmounting immediately, and remounting â€” data must be present.\n- [ ] **Lock on every code path**: Every callback that accesses `g_fs` must call `fs_lock()` at entry and `fs_unlock()` before every `return`. Run with `-s` (single-threaded) first to verify correctness, then remove `-s` and stress test with concurrent `cp` commands to verify thread safety.\n- [ ] **Magic number validation in `main`**: Verify `g_fs.sb.magic == FS_MAGIC` before mounting. A typo in the image path that points to a random file would otherwise mount garbage as a filesystem, causing confusing crashes in every callback.\n- [ ] **`rename` handles same-directory rename**: `rename(\"/a\", \"/b\")` has `old_parent == new_parent`. Your implementation must handle this case without double-locking or corrupting the parent directory.\n- [ ] **FUSE options `-f -s` for development**: Always develop with `-f` (foreground) so Ctrl+C unmounts cleanly, and `-s` (single-threaded) to eliminate concurrency issues while debugging. Add `-d` for verbose callback tracing.\n- [ ] **`fusermount3 -u` on crashed mount**: If your process crashes without unmounting, the mount point is left in a broken state. Running `./myfs disk.img /mnt -f` again fails with \"Transport endpoint is not connected.\" Always `fusermount3 -u /mnt` before remounting after a crash.\n---\n## What You've Built and What Comes Next\n\n![Filesystem Atlas â€” Satellite Map (Home Base)](./diagrams/diag-L0-satellite-map.svg)\n\nYou have crossed the final boundary between \"library\" and \"operating system component.\" Your filesystem is now a real mount point. Standard Unix tools â€” `ls`, `cat`, `cp`, `find`, `grep`, `vim` â€” work against it without modification, without knowing your code exists. The VFS contract is satisfied. The FUSE relay is wired. The entire stack from user application through kernel VFS through FUSE through your C code through block-level I/O runs seamlessly.\nBut there is a crack in the foundation, and you have known about it since Milestone 1. Every write to your filesystem is a race condition. Not a concurrency race â€” a **time race** against power failure. Consider: `echo \"critical data\" > /mnt/myfs/important.txt` calls your `create` callback, which writes the block bitmap, the inode, and the directory entry in three separate disk operations. If power fails between the bitmap write and the inode write, you have a leaked block that the bitmap marks as used but no inode references. If power fails between the inode write and the directory entry write, you have an orphaned inode that no path can reach. If power fails during the `rename` you just implemented â€” after adding the new entry but before removing the old one â€” you have a file with two names.\nIn all these cases, after a reboot, your filesystem is in an inconsistent state. The data blocks may be intact, but the metadata â€” bitmaps, inode table, directory entries â€” is incoherent. `fsck` can repair some of these by brute-force scanning all blocks and reconstructing consistent metadata, but that takes minutes on a large filesystem and sometimes loses data.\nMilestone 6 solves this definitively with **write-ahead journaling**. Every multi-step operation is wrapped in a transaction: write all changes to a sequential journal region first, write a commit record atomically, then apply the changes to the primary data structures. On crash: scan the journal, replay all committed transactions, discard incomplete ones. The filesystem is always consistent after recovery â€” not just \"recoverable,\" but **guaranteed consistent** by the structure of the write protocol.\nThe filesystem is almost production-ready. One milestone remains.\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: filesystem-m6 -->\n<!-- MS_ID: filesystem-m6 -->\n# Milestone 6: Write-Ahead Journaling and Crash Recovery\n## The Lie Your Code Has Been Telling\nEvery filesystem operation you have written since Milestone 1 has contained a silent assumption so pervasive you probably never noticed it: that writes to the disk image happen in exactly the order your code issues them.\nYou call `write_block(fd, BLOCK_BITMAP_BLOCK, bitmap)` and then `write_inode(fd, sb, new_ino, &inode)`. You feel safe because the bitmap is written before the inode â€” if you crash between the two, at worst you have a leaked block (bitmap says \"used,\" no inode points to it), and that is recoverable. You have been relying on write ordering as your crash consistency strategy.\nThat assumption is false. And the falseness is not subtle.\nHere is the chain of reordering that can happen between your `write_block` call and the bits reaching magnetic media or NAND cells:\n1. **The host kernel's page cache**: When your process calls `write(fd, buf, 4096)` via `write_block`, the kernel copies the data into a page cache page and marks it dirty. The actual flush happens asynchronously via the kernel's writeback daemon, which decides order and timing based on I/O scheduler heuristics â€” not your call order.\n2. **The disk's write buffer**: Modern HDDs and SSDs have DRAM write buffers of 64MB to 1GB. The disk accepts writes from the OS and reorders them internally to optimize head seek (HDD) or program/erase sequencing (SSD). Unless you issue a barrier or `fsync`, the disk's buffer is unconstrained.\n3. **The disk controller's NCQ (Native Command Queuing)**: HDDs queue up to 32 commands and reorder them by rotational position. Your bitmap write, queued before your inode write, may execute second because the inode block happens to be at a more favorable rotational position when the command is dispatched.\nThe result: you call `write_block(bitmap)` then `write_block(inode)`. The disk writes the inode first. You suffer a power failure. On recovery, the inode exists on disk pointing to a block that the bitmap marks as free â€” potentially double-allocated to a new file. **Data corruption. Not a leaked block. Actual data from two files occupying the same disk block.**\n[[EXPLAIN:write-ahead-logging-â€”-the-principle-of-logging-intent-before-action|Write-ahead logging â€” the principle of logging intent before action]]\nThe only mechanism that actually enforces ordering is `fsync`. When you call `fsync(fd)`, the kernel flushes all dirty pages for that file descriptor to the device and waits for the device to confirm that the data is durable â€” not just in the device's buffer, but confirmed written to stable storage. After `fsync` returns, you have a guarantee: everything written to `fd` before the call is on disk in the order the flushes were issued.\nWrite-ahead logging (WAL) is the design pattern that weaponizes this guarantee. The protocol is simple and absolute:\n1. Write all changes to a **sequential journal region** on disk\n2. Call `fsync` â€” all journal writes are now durable and ordered\n3. Write a **commit record** to the journal indicating this transaction is complete\n4. Call `fsync` again â€” the commit record is now durable\n5. Write the actual changes to their permanent locations (inode table, bitmaps, directory blocks)\n6. Call `fsync` â€” the main data structures now reflect the committed state\nIf power fails at any point before step 4, the commit record does not exist. On recovery, the partial journal entries are discarded. The main data structures are unchanged â€” perfectly consistent, as if the operation never happened.\nIf power fails between step 4 and step 6, the commit record exists. On recovery, the journal entries are replayed against the main data structures. The operation is completed. The filesystem is consistent.\nThe journal is not an optimization. It is the fundamental mechanism that makes crash consistency possible without a full filesystem scan. Without it, the only recovery option is `fsck` â€” which must read every inode, every bitmap, and every directory block on the entire filesystem to reconstruct consistent state. On a 10TB disk at 500MB/s sequential read speed, that is six hours of downtime every time someone trips over a power cable.\n\n![Transaction Lifecycle â€” Begin â†’ Journal â†’ Commit â†’ Apply â†’ End](./diagrams/diag-m6-transaction-lifecycle.svg)\n\n---\n## The Fundamental Tension: Atomicity on Non-Atomic Hardware\nHere is the core hardware constraint you are negotiating with:\n**A filesystem update requires multiple disk writes. Each disk write is independently atomic at the sector level (512 bytes or 4KB). No multi-block operation is atomic at the hardware level.**\nCreating a file requires at minimum: one bitmap write (inode bitmap), one inode table write, one directory block write, and potentially a bitmap write for the data block. Four separate 4KB writes. The hardware can guarantee that each individual 4KB sector write either completes or does not â€” it will not write half a sector. But there is no hardware primitive for \"write these four blocks atomically.\"\nThe software solution â€” WAL â€” synthesizes atomicity from sequential writes plus a commit record. The key insight is that a single 4KB sector write *is* hardware-atomic. If the commit record fits in one sector (and journal commit records are small â€” a few dozen bytes), the commit write is atomic. Either the commit record is present on disk or it is not. There is no half-written commit record. The commit record becomes the single atomic boundary that separates \"committed\" from \"not committed,\" and the journal structure ensures that a missing commit record always means \"safe to discard.\"\n\n![Three Crash Scenarios â€” What Happens and Why](./diagrams/diag-m6-crash-scenarios.svg)\n\nThe numbers that drive the design:\n- Journal write of 4KB: ~100Î¼s on SSD (same as any block write)\n- `fsync` call: ~100Î¼sâ€“1ms on SSD depending on device and host OS\n- Journal entry overhead: 2Ã— `fsync` per transaction minimum (journal flush + commit flush)\n- Benefit: O(journal_size) recovery instead of O(filesystem_size) recovery\n- Typical journal size: 4MBâ€“128MB (1,024â€“32,768 blocks at 4KB)\n- Recovery time from 4MB journal: ~40ms (400 block reads at SSD speed)\n- Recovery time from full fsck on 10TB disk: hours\n---\n## Journal Region: On-Disk Layout\nThe journal occupies a contiguous region of blocks configured in the superblock. From Milestone 1, you already reserved `sb->journal_start` and `sb->journal_blocks` for this purpose. Now you give that region a structure.\n\n![Journal Region â€” On-Disk Layout with Wrap-Around](./diagrams/diag-m6-journal-region-layout.svg)\n\nThe journal region has three kinds of content:\n1. **Journal superblock** (first block of the journal region): stores the journal's head, tail, and sequence number. This is the journal's own metadata â€” distinct from the filesystem superblock.\n2. **Transaction entries** (the body): a circular buffer of journal blocks, each either a metadata block copy or a descriptor block describing what follows.\n3. **Commit blocks**: special single-block entries that mark transaction boundaries.\nWe implement a simplified but correct journal with these on-disk structures:\n```c\n#include <stdint.h>\n#include <string.h>\n#define JOURNAL_MAGIC       0x4A4F5552    /* \"JOUR\" in ASCII */\n#define JOURNAL_BLOCK_SIZE  BLOCK_SIZE    /* 4096 bytes */\n/* Journal block types */\n#define JB_TYPE_SUPER    0x01    /* journal superblock */\n#define JB_TYPE_DESC     0x02    /* descriptor: describes following data blocks */\n#define JB_TYPE_COMMIT   0x03    /* commit record: transaction is complete */\n#define JB_TYPE_REVOKE   0x04    /* revoke: this block should not be replayed */\n/*\n * Journal Superblock â€” lives at journal_start (first block of journal region).\n *\n * BYTE LAYOUT:\n *   Offset  0: j_magic          (4 bytes)\n *   Offset  4: j_block_type     (4 bytes) â€” always JB_TYPE_SUPER\n *   Offset  8: j_sequence       (4 bytes) â€” next transaction sequence number\n *   Offset 12: j_head           (4 bytes) â€” first block with live data\n *   Offset 16: j_tail           (4 bytes) â€” first free block (circular)\n *   Offset 20: j_total_blocks   (4 bytes) â€” total blocks in journal region (excluding superblock)\n *   Offset 24: reserved         (4072 bytes)\n *   Total: 4096 bytes\n */\ntypedef struct __attribute__((packed)) {\n    uint32_t j_magic;           /* JOURNAL_MAGIC */\n    uint32_t j_block_type;      /* JB_TYPE_SUPER */\n    uint32_t j_sequence;        /* monotonically increasing transaction counter */\n    uint32_t j_head;            /* offset of oldest committed, unapplied transaction */\n    uint32_t j_tail;            /* offset where next write goes */\n    uint32_t j_total_blocks;    /* usable journal blocks (journal_blocks - 1) */\n    uint8_t  reserved[BLOCK_SIZE - 24];\n} journal_super_t;\n_Static_assert(sizeof(journal_super_t) == BLOCK_SIZE,\n               \"journal_super_t must be exactly 4096 bytes\");\n/*\n * Journal Descriptor Block â€” precedes a set of data blocks in the journal.\n *\n * A descriptor block describes the next N data blocks in the journal:\n * which filesystem block each one belongs to, and how many blocks follow.\n * After the descriptor block come exactly j_nr_blocks raw copies of metadata.\n *\n * BYTE LAYOUT:\n *   Offset  0: j_magic          (4 bytes)\n *   Offset  4: j_block_type     (4 bytes) â€” JB_TYPE_DESC\n *   Offset  8: j_sequence       (4 bytes) â€” transaction this belongs to\n *   Offset 12: j_nr_blocks      (4 bytes) â€” number of data blocks that follow\n *   Offset 16: j_blocks[0..N]   (8 bytes each) â€” target filesystem block numbers\n *              (max N = (BLOCK_SIZE - 16) / 8 = 510 blocks per descriptor)\n *   Total: 4096 bytes\n */\n#define MAX_BLOCKS_PER_DESC  ((BLOCK_SIZE - 16) / sizeof(uint64_t))\ntypedef struct __attribute__((packed)) {\n    uint32_t j_magic;\n    uint32_t j_block_type;      /* JB_TYPE_DESC */\n    uint32_t j_sequence;\n    uint32_t j_nr_blocks;       /* how many data blocks follow this descriptor */\n    uint64_t j_blocks[MAX_BLOCKS_PER_DESC]; /* target block numbers (0-indexed from j_blocks[0]) */\n} journal_desc_t;\n_Static_assert(sizeof(journal_desc_t) == BLOCK_SIZE,\n               \"journal_desc_t must be exactly 4096 bytes\");\n/*\n * Commit Block â€” marks the end of a transaction.\n *\n * A transaction is committed if and only if a commit block with a matching\n * sequence number exists in the journal after its descriptor and data blocks.\n * The commit block is written LAST, after fsync of the preceding data.\n * It is small enough to fit in a single atomic sector write.\n *\n * BYTE LAYOUT:\n *   Offset  0: j_magic          (4 bytes)\n *   Offset  4: j_block_type     (4 bytes) â€” JB_TYPE_COMMIT\n *   Offset  8: j_sequence       (4 bytes) â€” must match the descriptor\n *   Offset 12: j_checksum       (4 bytes) â€” CRC32 of all journaled block data\n *   Offset 16: reserved         (4080 bytes)\n *   Total: 4096 bytes\n */\ntypedef struct __attribute__((packed)) {\n    uint32_t j_magic;\n    uint32_t j_block_type;      /* JB_TYPE_COMMIT */\n    uint32_t j_sequence;\n    uint32_t j_checksum;        /* simple sum of all journaled bytes */\n    uint8_t  reserved[BLOCK_SIZE - 16];\n} journal_commit_t;\n_Static_assert(sizeof(journal_commit_t) == BLOCK_SIZE,\n               \"journal_commit_t must be exactly 4096 bytes\");\n```\n\n![Journal Entry Structure â€” Byte Layout](./diagrams/diag-m6-journal-entry-format.svg)\n\nThe journal operates as a **circular buffer** of blocks. The `j_head` and `j_tail` pointers â€” offsets into the journal region, not absolute disk block numbers â€” define the live region:\n- `j_tail`: where the next write goes (producer end)\n- `j_head`: the oldest live entry (consumer end, advanced during checkpointing)\n- When `j_tail` wraps around to `j_head`, the journal is full â€” block until checkpoint\nThe absolute disk block number for journal offset `N` is:\n```c\nuint32_t journal_abs_block(const superblock_t *sb, uint32_t journal_offset) {\n    /* Offset 0 is the journal superblock; data starts at offset 1 */\n    return sb->journal_start + 1 + (journal_offset % sb->j_total_blocks);\n}\n```\n---\n## The Transaction API\nEvery filesystem operation that modifies metadata must be wrapped in a transaction. The transaction API has four calls:\n```c\n/*\n * In-memory transaction state.\n * A transaction accumulates block changes before committing them atomically.\n * Maximum transaction size: limited by journal capacity and descriptor block size.\n */\n#define MAX_TXNBLOCKS   64   /* max blocks in one transaction */\ntypedef struct {\n    int          fd;             /* disk image fd */\n    superblock_t *sb;            /* filesystem superblock */\n    journal_super_t *jsuper;     /* journal superblock (in-memory, flushed on commit) */\n    uint32_t     sequence;       /* this transaction's sequence number */\n    /* Accumulated dirty blocks */\n    uint32_t     nr_blocks;      /* count of blocks pending */\n    uint32_t     block_nums[MAX_TXNBLOCKS];     /* filesystem block numbers */\n    uint8_t      block_data[MAX_TXNBLOCKS][BLOCK_SIZE]; /* block contents */\n} txn_t;\n/* Journal superblock in memory â€” loaded at mount, persisted at checkpoint */\nstatic journal_super_t g_jsuper;\n/*\n * Load the journal superblock from disk.\n * Called once during filesystem mount.\n */\nint journal_load(int fd, const superblock_t *sb) {\n    uint8_t buf[BLOCK_SIZE];\n    if (read_block(fd, sb->journal_start, buf) != 0) return -EIO;\n    memcpy(&g_jsuper, buf, sizeof(g_jsuper));\n    if (g_jsuper.j_magic != JOURNAL_MAGIC) {\n        /* First mount after mkfs: initialize the journal superblock */\n        memset(&g_jsuper, 0, sizeof(g_jsuper));\n        g_jsuper.j_magic        = JOURNAL_MAGIC;\n        g_jsuper.j_block_type   = JB_TYPE_SUPER;\n        g_jsuper.j_sequence     = 1;\n        g_jsuper.j_head         = 0;\n        g_jsuper.j_tail         = 0;\n        g_jsuper.j_total_blocks = sb->journal_blocks - 1;\n        return journal_persist_super(fd, sb);\n    }\n    return 0;\n}\n/*\n * Write the journal superblock to disk.\n */\nint journal_persist_super(int fd, const superblock_t *sb) {\n    uint8_t buf[BLOCK_SIZE];\n    memset(buf, 0, BLOCK_SIZE);\n    memcpy(buf, &g_jsuper, sizeof(g_jsuper));\n    return write_block(fd, sb->journal_start, buf);\n}\n```\n### `txn_begin`: Opening a Transaction\n```c\n/*\n * Begin a new transaction.\n *\n * Initializes the in-memory transaction state. No disk I/O yet.\n * The transaction accumulates changes until txn_commit() is called.\n *\n * Every filesystem operation that modifies metadata must begin with this call.\n * NEVER modify inode table, bitmaps, or directory blocks without an active transaction.\n */\nvoid txn_begin(txn_t *txn, int fd, superblock_t *sb) {\n    memset(txn, 0, sizeof(*txn));\n    txn->fd       = fd;\n    txn->sb       = sb;\n    txn->jsuper   = &g_jsuper;\n    txn->sequence = g_jsuper.j_sequence;\n    txn->nr_blocks = 0;\n}\n```\n### `txn_journal_block`: Recording a Change\nInstead of calling `write_block` directly, every metadata write goes through `txn_journal_block`. This records the block's new content in the transaction but does not write to the block's final destination yet:\n```c\n/*\n * Record a block change in the current transaction.\n *\n * block_num: the FILESYSTEM block number that will eventually be updated.\n * data:      the new 4KB content for that block.\n *\n * This does NOT write to block_num on disk yet. The actual write happens\n * in txn_commit() after the journal entry is made durable.\n *\n * Returns 0 on success, -ENOSPC if the transaction is full.\n *\n * NOTE: If block_num is already in the transaction's pending list,\n * we update its entry (this is the \"revoke\" optimization for blocks\n * modified multiple times within one transaction).\n */\nint txn_journal_block(txn_t *txn, uint32_t block_num, const void *data) {\n    /* Check if this block is already in the transaction */\n    for (uint32_t i = 0; i < txn->nr_blocks; i++) {\n        if (txn->block_nums[i] == block_num) {\n            /* Update existing entry â€” no need for duplicate journal writes */\n            memcpy(txn->block_data[i], data, BLOCK_SIZE);\n            return 0;\n        }\n    }\n    if (txn->nr_blocks >= MAX_TXNBLOCKS) return -ENOSPC;\n    txn->block_nums[txn->nr_blocks] = block_num;\n    memcpy(txn->block_data[txn->nr_blocks], data, BLOCK_SIZE);\n    txn->nr_blocks++;\n    return 0;\n}\n```\n### `txn_commit`: The Critical Path\nThis is the most important function in the entire journaling system. Every design decision here traces back to the crash consistency guarantee:\n```c\n/*\n * Commit a transaction.\n *\n * Protocol (each step must complete before the next begins):\n *   1. Write descriptor block to journal (describes which blocks follow)\n *   2. Write all journaled block copies to journal\n *   3. fsync the disk image â†’ journal entries are durable\n *   4. Write commit block to journal\n *   5. fsync again â†’ commit record is durable (POINT OF NO RETURN)\n *   6. Write each block to its actual filesystem location\n *   7. fsync â†’ main data structures updated\n *   8. Advance journal tail; update sequence number\n *\n * After step 5: transaction is committed. Crash recovery WILL replay it.\n * Before step 5: transaction is not committed. Crash recovery WILL NOT replay it.\n *\n * Returns 0 on success, negative errno on failure.\n */\nint txn_commit(txn_t *txn) {\n    if (txn->nr_blocks == 0) return 0;   /* empty transaction â€” nothing to do */\n    superblock_t *sb    = txn->sb;\n    journal_super_t *js = txn->jsuper;\n    int fd              = txn->fd;\n    /* Check journal has enough space for: 1 descriptor + nr_blocks data + 1 commit */\n    uint32_t blocks_needed = 1 + txn->nr_blocks + 1;\n    uint32_t journal_used  = (js->j_tail >= js->j_head)\n                             ? (js->j_tail - js->j_head)\n                             : (js->j_total_blocks - js->j_head + js->j_tail);\n    uint32_t journal_free  = js->j_total_blocks - journal_used;\n    if (blocks_needed > journal_free) {\n        /*\n         * Journal is full. In production: block until checkpoint completes.\n         * For our implementation: force a checkpoint inline.\n         * This is the \"journal full\" condition that can block writers.\n         */\n        int r = journal_checkpoint(fd, sb);\n        if (r != 0) return r;\n        /* Recompute after checkpoint */\n        journal_used  = 0;   /* checkpoint cleared the journal */\n        journal_free  = js->j_total_blocks;\n        if (blocks_needed > journal_free) return -ENOSPC;\n    }\n    /* --- STEP 1: Write descriptor block to journal --- */\n    uint8_t desc_buf[BLOCK_SIZE];\n    memset(desc_buf, 0, BLOCK_SIZE);\n    journal_desc_t *desc = (journal_desc_t *)desc_buf;\n    desc->j_magic      = JOURNAL_MAGIC;\n    desc->j_block_type = JB_TYPE_DESC;\n    desc->j_sequence   = txn->sequence;\n    desc->j_nr_blocks  = txn->nr_blocks;\n    for (uint32_t i = 0; i < txn->nr_blocks; i++) {\n        desc->j_blocks[i] = txn->block_nums[i];\n    }\n    uint32_t journal_pos = js->j_tail;\n    uint32_t desc_abs    = journal_abs_block(sb, journal_pos);\n    if (write_block(fd, desc_abs, desc_buf) != 0) return -EIO;\n    journal_pos = (journal_pos + 1) % js->j_total_blocks;\n    /* --- STEP 2: Write each block's data copy to journal --- */\n    uint32_t checksum = 0;\n    for (uint32_t i = 0; i < txn->nr_blocks; i++) {\n        uint32_t data_abs = journal_abs_block(sb, journal_pos);\n        if (write_block(fd, data_abs, txn->block_data[i]) != 0) return -EIO;\n        /* Accumulate checksum for commit block */\n        const uint32_t *words = (const uint32_t *)txn->block_data[i];\n        for (int j = 0; j < (int)(BLOCK_SIZE / sizeof(uint32_t)); j++) {\n            checksum += words[j];\n        }\n        journal_pos = (journal_pos + 1) % js->j_total_blocks;\n    }\n    /* --- STEP 3: fsync â€” all journal writes durable --- */\n    /*\n     * This fsync is MANDATORY and NON-NEGOTIABLE.\n     *\n     * Without it, the OS may reorder the journal data writes relative to\n     * the commit block write. The commit block could reach disk before the\n     * descriptor or data blocks, creating a committed-but-unreplayable\n     * transaction. The fsync establishes a memory barrier at the hardware level:\n     * everything before this call is on stable storage before anything after\n     * this call begins writing.\n     */\n    if (fsync(fd) != 0) return -EIO;\n    /* --- STEP 4: Write commit block --- */\n    uint8_t commit_buf[BLOCK_SIZE];\n    memset(commit_buf, 0, BLOCK_SIZE);\n    journal_commit_t *commit = (journal_commit_t *)commit_buf;\n    commit->j_magic      = JOURNAL_MAGIC;\n    commit->j_block_type = JB_TYPE_COMMIT;\n    commit->j_sequence   = txn->sequence;\n    commit->j_checksum   = checksum;\n    uint32_t commit_abs  = journal_abs_block(sb, journal_pos);\n    if (write_block(fd, commit_abs, commit_buf) != 0) return -EIO;\n    journal_pos = (journal_pos + 1) % js->j_total_blocks;\n    /* --- STEP 5: fsync â€” commit record is durable (POINT OF NO RETURN) --- */\n    /*\n     * After this fsync returns, the transaction is committed.\n     * If power fails any time after this point, recovery WILL replay this\n     * transaction. The commit block on stable storage is the guarantee.\n     *\n     * If power fails before this fsync completes (including during the fsync),\n     * the commit block is not durable. Recovery will not find it. The\n     * transaction is treated as aborted. The main data structures are unchanged.\n     */\n    if (fsync(fd) != 0) return -EIO;\n    /* --- STEP 6: Write blocks to their actual filesystem locations --- */\n    /*\n     * Only now do we update the actual inode table, bitmaps, and directory blocks.\n     * The order here does not matter for crash consistency â€” if we crash during\n     * step 6, the journal commit record guarantees recovery will complete the writes.\n     * We write in the order they appear in the transaction for simplicity.\n     */\n    for (uint32_t i = 0; i < txn->nr_blocks; i++) {\n        if (write_block(fd, txn->block_nums[i], txn->block_data[i]) != 0) {\n            /*\n             * This write failed, but the journal is committed.\n             * Recovery will re-apply this transaction on next mount.\n             * Safe to return error â€” the filesystem remains consistent.\n             */\n            return -EIO;\n        }\n    }\n    /* --- STEP 7: fsync â€” main data structures updated --- */\n    /*\n     * This fsync is advisory for crash consistency (recovery handles the\n     * case where it doesn't happen), but it improves performance by\n     * allowing the journal to be checkpointed sooner: we know the\n     * in-place writes completed, so the journal entries are redundant.\n     */\n    fsync(fd);   /* best-effort; ignore return value */\n    /* --- STEP 8: Advance journal tail and sequence number --- */\n    js->j_tail     = journal_pos;\n    js->j_sequence = txn->sequence + 1;\n    journal_persist_super(fd, sb);\n    return 0;\n}\n```\n\n![The fsync Ordering Guarantee â€” Why Order Matters](./diagrams/diag-m6-fsync-ordering.svg)\n\n> **Hardware Soul â€” Why Two `fsync` Calls?**\n> The first `fsync` (step 3) flushes the journal data pages from the kernel's page cache to the disk's write buffer, and instructs the disk to flush its write buffer to stable media. On SSDs, this typically takes 100â€“500Î¼s depending on the write buffer state. The second `fsync` (step 5) does the same for the commit block. Why two? Because the commit block's durability is the single binary condition that separates \"committed\" from \"not committed.\" Without the first `fsync`, the disk might write the commit block before the data blocks (internal reordering). With the first `fsync`, we know: the data blocks are on stable media, then the commit block is written. The ordering is established at the hardware level. On an SSD with power-loss protection (enterprise SSDs, NVMe with capacitors), the first `fsync` cost can be eliminated using disk-level barriers â€” but that requires more complex device capability detection. Two `fsync` calls is the conservative, universally correct approach.\n---\n## The `txn_journal_block` Wrapper Idiom\nEvery metadata write in your codebase â€” every call to `write_inode`, `write_block` for bitmaps, every directory entry modification â€” must be converted to use `txn_journal_block`. Here is the pattern:\n```c\n/*\n * Journaled wrapper for write_inode.\n * Instead of writing to the inode table immediately, record the\n * intended change in the active transaction.\n *\n * Caller must have an active txn_t and must call txn_commit() at the\n * end of the operation.\n */\nint txn_write_inode(txn_t *txn, uint32_t inode_num, const inode_t *inode) {\n    superblock_t *sb = txn->sb;\n    if (inode_num == 0 || inode_num > sb->total_inodes) return -EINVAL;\n    uint32_t idx           = inode_num - 1;\n    uint32_t block_num     = sb->inode_table_start + idx / INODES_PER_BLOCK;\n    uint32_t slot_in_block = idx % INODES_PER_BLOCK;\n    /* Read the current inode block content */\n    uint8_t buf[BLOCK_SIZE];\n    int r = read_block(txn->fd, block_num, buf);\n    if (r != 0) return r;\n    /* Apply the change in memory */\n    memcpy(buf + slot_in_block * INODE_SIZE, inode, INODE_SIZE);\n    /* Record in transaction â€” no disk write yet */\n    return txn_journal_block(txn, block_num, buf);\n}\n/*\n * Journaled wrapper for block bitmap update.\n * Records the bitmap change in the transaction.\n */\nint txn_write_block_bitmap(txn_t *txn, uint8_t *bitmap) {\n    return txn_journal_block(txn, BLOCK_BITMAP_BLOCK, bitmap);\n}\n/*\n * Journaled wrapper for inode bitmap update.\n */\nint txn_write_inode_bitmap(txn_t *txn, uint8_t *bitmap) {\n    return txn_journal_block(txn, INODE_BITMAP_BLOCK, bitmap);\n}\n```\nHere is what `fs_create_file` looks like when converted to use journaling:\n```c\n/*\n * Journaled version of fs_create_file.\n * Wraps all metadata changes in a single atomic transaction.\n *\n * If ANY step fails before txn_commit(), the transaction is abandoned.\n * No partial changes will appear in the filesystem.\n * If the process crashes after txn_commit() but before the in-place\n * writes complete, recovery will replay the transaction on next mount.\n */\nint fs_create_file_journaled(int fd, superblock_t *sb,\n                              uint32_t parent_ino, const char *name,\n                              uint16_t mode, uint16_t uid, uint16_t gid) {\n    txn_t txn;\n    txn_begin(&txn, fd, sb);\n    /* --- 1. Validate parent --- */\n    inode_t parent_inode;\n    if (read_inode(fd, sb, parent_ino, &parent_inode) != 0) return -EIO;\n    if (!S_ISDIR(parent_inode.mode)) return -ENOTDIR;\n    if (dir_lookup(fd, sb, &parent_inode, name) > 0) return -EEXIST;\n    /* --- 2. Allocate inode (in-memory only for now) --- */\n    /* Read inode bitmap, find free slot, mark used */\n    uint8_t ibmap[BLOCK_SIZE];\n    if (read_block(fd, INODE_BITMAP_BLOCK, ibmap) != 0) return -EIO;\n    int new_ino = bitmap_find_free(ibmap, sb->total_inodes);\n    if (new_ino < 0) return -ENOSPC;\n    bitmap_set(ibmap, (uint32_t)new_ino);\n    /* Journal the bitmap change â€” not written to disk yet */\n    txn_write_inode_bitmap(&txn, ibmap);\n    uint32_t new_ino_num = (uint32_t)new_ino + 1;  /* 1-based */\n    /* --- 3. Initialize new inode --- */\n    inode_t new_inode;\n    memset(&new_inode, 0, sizeof(new_inode));\n    new_inode.mode   = (uint16_t)(S_IFREG | (mode & 0777));\n    new_inode.uid    = uid;\n    new_inode.gid    = gid;\n    new_inode.nlinks = 1;\n    new_inode.size   = 0;\n    uint32_t now = (uint32_t)time(NULL);\n    new_inode.atime = new_inode.mtime = new_inode.ctime = now;\n    /* Journal the new inode */\n    txn_write_inode(&txn, new_ino_num, &new_inode);\n    /* --- 4. Add directory entry --- */\n    /*\n     * dir_add_entry modifies the parent directory's data blocks.\n     * We need to capture the modified block and journal it.\n     * In a full implementation, dir_add_entry would take a txn_t parameter.\n     * For clarity, we show the pattern inline here.\n     */\n    /* ... (see full implementation with txn-aware dir_add_entry below) ... */\n    /* --- 5. Update parent inode mtime/ctime --- */\n    parent_inode.mtime = parent_inode.ctime = now;\n    txn_write_inode(&txn, parent_ino, &parent_inode);\n    /* --- 6. Update superblock free counts --- */\n    sb->free_inodes--;\n    /* Journal the superblock block (block 0) */\n    uint8_t sb_buf[BLOCK_SIZE];\n    memset(sb_buf, 0, BLOCK_SIZE);\n    memcpy(sb_buf, sb, sizeof(*sb));\n    txn_journal_block(&txn, 0, sb_buf);\n    /* --- 7. COMMIT: write journal + fsync twice + write in place + fsync --- */\n    int r = txn_commit(&txn);\n    if (r != 0) {\n        /* Commit failed. Rollback the in-memory sb free count. */\n        sb->free_inodes++;\n        return r;\n    }\n    return (int)new_ino_num;\n}\n```\nThe key structural change: every operation now builds up a set of block changes in `txn`, then commits them all atomically. If any step fails before `txn_commit`, the transaction is simply abandoned â€” `txn` goes out of scope, nothing was written to disk, the filesystem is unchanged.\n---\n## Journal Recovery: Replaying on Mount\n[[EXPLAIN:write-ahead-log-replay-â€”-scanning-the-log-and-re-applying-committed-operations|Write-ahead log replay â€” scanning committed journal entries and re-applying operations to primary data structures]]\nRecovery happens at mount time, before the filesystem is made available for use. The algorithm:\n\n![Journal Replay Algorithm â€” Recovery Flowchart](./diagrams/diag-m6-replay-algorithm.svg)\n\n```\n1. Read journal superblock â†’ get j_head and j_tail\n2. Scan from j_head toward j_tail:\n   a. Read block at current position\n   b. Check j_magic â€” if invalid, stop (journal is empty past here)\n   c. If JB_TYPE_DESC: remember the descriptor (block list + sequence)\n   d. Read the following data blocks (one per entry in descriptor)\n   e. Look for JB_TYPE_COMMIT with matching j_sequence\n   f. If commit found: REPLAY â€” write each data block to its target\n   g. If commit NOT found before hitting another descriptor or invalid block:\n      DISCARD â€” skip to next descriptor or stop\n3. After all committed transactions replayed: checkpoint (mark journal clean)\n```\n```c\n/*\n * Replay the journal on mount.\n *\n * Scans all journal blocks from j_head to j_tail.\n * Applies committed transactions. Discards incomplete transactions.\n *\n * After this function returns, the filesystem is in a consistent state\n * matching the most recent committed transaction.\n *\n * Returns 0 on success (including \"no recovery needed\"), negative errno on error.\n */\nint journal_recover(int fd, superblock_t *sb) {\n    journal_super_t *js = &g_jsuper;\n    if (js->j_head == js->j_tail) {\n        /* Journal is empty â€” nothing to replay */\n        printf(\"journal_recover: journal is clean, no replay needed\\n\");\n        return 0;\n    }\n    printf(\"journal_recover: replaying journal (head=%u, tail=%u)\\n\",\n           js->j_head, js->j_tail);\n    uint32_t pos = js->j_head;\n    int replayed = 0;\n    while (pos != js->j_tail) {\n        uint32_t abs_block = journal_abs_block(sb, pos);\n        uint8_t buf[BLOCK_SIZE];\n        if (read_block(fd, abs_block, buf) != 0) {\n            fprintf(stderr, \"journal_recover: I/O error at journal offset %u\\n\", pos);\n            return -EIO;\n        }\n        /* Examine the block type */\n        uint32_t *magic = (uint32_t *)buf;\n        uint32_t *btype = (uint32_t *)(buf + 4);\n        if (*magic != JOURNAL_MAGIC) {\n            /* No more valid journal entries */\n            printf(\"journal_recover: end of valid entries at offset %u\\n\", pos);\n            break;\n        }\n        if (*btype != JB_TYPE_DESC) {\n            /* Not a descriptor â€” could be a stale commit or other block; skip */\n            pos = (pos + 1) % js->j_total_blocks;\n            continue;\n        }\n        /* Found a descriptor block */\n        journal_desc_t *desc = (journal_desc_t *)buf;\n        uint32_t seq          = desc->j_sequence;\n        uint32_t nr_blocks    = desc->j_nr_blocks;\n        if (nr_blocks > MAX_BLOCKS_PER_DESC || nr_blocks == 0) {\n            fprintf(stderr, \"journal_recover: corrupt descriptor (nr_blocks=%u)\\n\",\n                    nr_blocks);\n            break;\n        }\n        /* Read the data blocks that follow the descriptor */\n        uint32_t data_pos = (pos + 1) % js->j_total_blocks;\n        uint8_t data_bufs[MAX_TXNBLOCKS][BLOCK_SIZE];\n        uint32_t checksum_computed = 0;\n        for (uint32_t i = 0; i < nr_blocks; i++) {\n            uint32_t data_abs = journal_abs_block(sb, data_pos);\n            if (read_block(fd, data_abs, data_bufs[i]) != 0) {\n                fprintf(stderr, \"journal_recover: I/O error reading data block %u\\n\", i);\n                return -EIO;\n            }\n            const uint32_t *words = (const uint32_t *)data_bufs[i];\n            for (int j = 0; j < (int)(BLOCK_SIZE / sizeof(uint32_t)); j++) {\n                checksum_computed += words[j];\n            }\n            data_pos = (data_pos + 1) % js->j_total_blocks;\n        }\n        /* Look for the commit block at data_pos */\n        uint32_t commit_abs = journal_abs_block(sb, data_pos);\n        uint8_t commit_buf[BLOCK_SIZE];\n        if (read_block(fd, commit_abs, commit_buf) != 0) {\n            fprintf(stderr, \"journal_recover: I/O error reading commit block\\n\");\n            return -EIO;\n        }\n        journal_commit_t *commit = (journal_commit_t *)commit_buf;\n        if (commit->j_magic      != JOURNAL_MAGIC ||\n            commit->j_block_type != JB_TYPE_COMMIT ||\n            commit->j_sequence   != seq) {\n            /*\n             * No valid commit block for this transaction.\n             * The transaction was incomplete at crash time â€” discard it.\n             *\n             * This is the correct behavior: a missing commit record means\n             * the transaction never durably completed. We act as if the\n             * operation never started. The filesystem metadata below is\n             * unchanged from the last committed transaction.\n             */\n            printf(\"journal_recover: incomplete txn seq=%u discarded\\n\", seq);\n            pos = (pos + 1) % js->j_total_blocks;\n            continue;\n        }\n        /*\n         * Validate checksum.\n         * A checksum mismatch means either the data blocks are corrupt\n         * or the commit block belongs to a different transaction (false match).\n         */\n        if (commit->j_checksum != checksum_computed) {\n            fprintf(stderr, \"journal_recover: checksum mismatch in txn seq=%u \"\n                    \"(expected 0x%08X, got 0x%08X) â€” discarding\\n\",\n                    seq, commit->j_checksum, checksum_computed);\n            pos = data_pos + 1;\n            continue;\n        }\n        /*\n         * REPLAY: write each journaled block to its filesystem location.\n         *\n         * Idempotency: if we crash DURING replay and replay is run again,\n         * these writes are safe to apply multiple times. Each write is\n         * exactly the same data written to the same block. Replaying\n         * a transaction twice produces the same result as replaying it once.\n         * This is the idempotency guarantee that makes WAL replay correct.\n         */\n        printf(\"journal_recover: replaying committed txn seq=%u (%u blocks)\\n\",\n               seq, nr_blocks);\n        for (uint32_t i = 0; i < nr_blocks; i++) {\n            uint32_t target_block = (uint32_t)desc->j_blocks[i];\n            if (write_block(fd, target_block, data_bufs[i]) != 0) {\n                fprintf(stderr, \"journal_recover: failed to write block %u\\n\",\n                        target_block);\n                return -EIO;\n            }\n        }\n        replayed++;\n        /* Advance past this transaction's descriptor + data + commit */\n        pos = (data_pos + 1) % js->j_total_blocks;\n    }\n    /* Flush replayed writes to disk */\n    if (replayed > 0) {\n        if (fsync(fd) != 0) return -EIO;\n        printf(\"journal_recover: replayed %d transactions\\n\", replayed);\n    }\n    /* Checkpoint: mark journal as clean */\n    return journal_checkpoint(fd, sb);\n}\n```\n---\n## Metadata-Only Journaling\n[[EXPLAIN:journaling-modes-â€”-metadata-only-vs-full-data-journaling-tradeoff|Journaling modes â€” the tradeoff between metadata-only journaling (ext3 default) and full data journaling (higher safety, higher write amplification)]]\nYour journal records metadata changes: inode table blocks, bitmap blocks, directory data blocks. It does **not** journal file data blocks. This is the **metadata journaling** mode (called \"ordered\" mode in ext3/ext4 terminology). The distinction matters enormously for performance:\n\n![Metadata-Only vs. Full Journaling â€” Write Amplification Comparison](./diagrams/diag-m6-metadata-vs-full-journaling.svg)\n\n| Mode | What's journaled | Write amplification | Crash behavior |\n|------|-----------------|---------------------|----------------|\n| **Metadata only (chosen âœ“)** | Inodes, bitmaps, directories | 2â€“3Ã— for metadata, 1Ã— for data | Data written before crash may be lost; metadata is always consistent |\n| Full journaling | Metadata + file data | 2Ã— for all writes | All committed writes survive crash |\n| Writeback | Metadata only, no ordering | ~2Ã— for metadata | Metadata consistent; data blocks may contain garbage |\nMetadata-only journaling with ordered data writes (the safe default) means: before journaling the inode that points to a data block, ensure the data block has been written to disk. The protocol for a file write operation is:\n1. Write file data blocks to their final locations (no journal)\n2. `fsync(fd)` â€” data blocks are durable\n3. Begin transaction\n4. Journal inode update (new size, new block pointers)\n5. Commit transaction\n6. `fsync(fd)` â€” inode update is durable\nIf you crash between steps 1 and 5: the data exists on disk but the inode does not point to it. From the filesystem's perspective, the write never happened. The file has its old size and old content. Data is lost but the filesystem is consistent.\nIf you crash after step 5: the inode points to the written data. The write is committed. Full durability.\n```c\n/*\n * Journaled file write â€” ordered metadata journaling mode.\n *\n * Protocol:\n *   1. Write data blocks to final locations (not journaled)\n *   2. fsync â€” data is durable\n *   3. Journal inode update (new size + any new block pointer changes)\n *   4. Commit journal transaction\n *\n * This ensures: if crash between 1 and 3, old inode is intact (old file content).\n * If crash after 4, inode reflects new content.\n */\nint fs_write_journaled(int fd, superblock_t *sb,\n                        uint32_t ino, uint64_t offset,\n                        const void *buf, size_t length) {\n    /* Step 1 & 2: Write data blocks directly (not journaled) */\n    ssize_t written = fs_write(fd, sb, ino, offset, buf, length);\n    if (written < 0) return (int)written;\n    /* fsync data before journaling the metadata */\n    if (fsync(fd) != 0) return -EIO;\n    /* Step 3 & 4: Journal the inode metadata update */\n    txn_t txn;\n    txn_begin(&txn, fd, sb);\n    inode_t inode;\n    if (read_inode(fd, sb, ino, &inode) != 0) return -EIO;\n    /* The inode was already updated in-place by fs_write above.\n     * Re-read and journal the current (updated) inode block. */\n    uint32_t idx       = ino - 1;\n    uint32_t block_num = sb->inode_table_start + idx / INODES_PER_BLOCK;\n    uint8_t  iblock[BLOCK_SIZE];\n    if (read_block(fd, block_num, iblock) != 0) return -EIO;\n    txn_journal_block(&txn, block_num, iblock);\n    return txn_commit(&txn);\n}\n```\n> **Why Not Journal Data Too?**\n> Full journaling doubles the write load for all file writes â€” every byte written to a file is written twice: once to the journal, once to the final location. For a filesystem serving a 1Gbps network storage workload, full journaling would halve effective write throughput and double the SSD write endurance consumption. Metadata-only journaling adds overhead only for metadata operations (which are small and infrequent relative to data writes), while keeping data writes on the fast path. ext4's default mode is \"ordered\" â€” metadata journaled, data written to disk before the journal transaction commits. This is what you implemented above.\n---\n## Journal Checkpointing\nA checkpoint marks journal entries as no longer needed â€” their changes have been applied to the main data structures. Without checkpointing, the circular journal buffer fills up and all filesystem operations block.\n\n![Journal Checkpoint â€” Reclaiming Journal Space](./diagrams/diag-m6-checkpoint.svg)\n\n```c\n/*\n * Checkpoint the journal.\n *\n * A checkpoint declares: all committed transactions have been applied\n * to the main data structures. The journal can now be reused from the\n * beginning (j_head reset to j_tail, effectively clearing the journal).\n *\n * When to checkpoint:\n *   - When the journal is getting full (< 20% free)\n *   - On unmount (ensure all changes are in main structures)\n *   - Periodically by a background thread (every N seconds)\n *\n * After checkpoint, recovery from a crash replays no transactions â€”\n * the journal is empty. This is the desired post-checkpoint state.\n *\n * Returns 0 on success, negative errno on failure.\n */\nint journal_checkpoint(int fd, superblock_t *sb) {\n    journal_super_t *js = &g_jsuper;\n    /*\n     * All committed transactions have already been applied to the main\n     * data structures by txn_commit() step 6. The journal entries are\n     * now redundant. We just need to fsync to ensure the in-place writes\n     * are durable, then reset the journal head to the tail.\n     */\n    /* Ensure all in-place writes from prior transactions are on disk */\n    if (fsync(fd) != 0) return -EIO;\n    /*\n     * Reset journal: head catches up to tail.\n     * The journal is now empty â€” no transactions to replay.\n     * On next crash recovery, nothing will be replayed.\n     */\n    js->j_head = js->j_tail;\n    /*\n     * Persist the updated journal superblock.\n     * This write must be durable before we return â€” otherwise a crash\n     * immediately after checkpoint could leave j_head pointing to the\n     * wrong location, causing spurious transaction replay.\n     */\n    int r = journal_persist_super(fd, sb);\n    if (r != 0) return r;\n    if (fsync(fd) != 0) return -EIO;\n    printf(\"journal_checkpoint: journal cleared (sequence=%u)\\n\",\n           js->j_sequence);\n    return 0;\n}\n```\n---\n## Idempotency: The Safety Net for Replay\n[[EXPLAIN:idempotent-operations-â€”-safe-to-apply-multiple-times-without-changing-the-result|Idempotent operations â€” an operation where applying it once or N times produces the same result, required for safe retry and replay semantics]]\nA critical property of WAL replay is that it may apply a transaction multiple times. Consider: the system crashes during replay itself (a \"crash during recovery\"). When the system reboots again, it replays the same journal entries again. Replaying a committed transaction twice must produce the same result as replaying it once.\nYour journal writes are idempotent because each journal entry records the **final state** of a block, not a delta. Writing \"inode 7's block pointer 0 is now block 2500\" twice leaves the inode in exactly the same state as writing it once. This is fundamentally different from a delta log like \"increment free_blocks by 1\" â€” replaying that twice would corrupt the free count.\nThe same idempotency requirement appears throughout distributed systems:\n```c\n/*\n * Verify idempotency in your journaled operations.\n * This test replays a transaction twice and checks that the result\n * is the same as replaying it once.\n */\nvoid test_idempotent_replay(int fd, superblock_t *sb) {\n    /* Create a file, capture the transaction */\n    int ino = fs_create_file_journaled(fd, sb, sb->root_inode,\n                                        \"idempotent_test\", 0644, 0, 0);\n    assert(ino > 0);\n    /* Read the committed inode state */\n    inode_t inode_after_create;\n    read_inode(fd, sb, (uint32_t)ino, &inode_after_create);\n    /* Simulate replay: write the same blocks again (as recovery would) */\n    /* In a real test, we would parse the journal and re-apply the blocks */\n    /* For simplicity: write the inode block to itself twice */\n    uint32_t idx       = (uint32_t)ino - 1;\n    uint32_t block_num = sb->inode_table_start + idx / INODES_PER_BLOCK;\n    uint8_t buf[BLOCK_SIZE];\n    read_block(fd, block_num, buf);\n    /* First replay */\n    write_block(fd, block_num, buf);\n    inode_t after_replay1;\n    read_inode(fd, sb, (uint32_t)ino, &after_replay1);\n    /* Second replay â€” same data, same target */\n    write_block(fd, block_num, buf);\n    inode_t after_replay2;\n    read_inode(fd, sb, (uint32_t)ino, &after_replay2);\n    /* All three must be identical */\n    assert(memcmp(&inode_after_create, &after_replay1, sizeof(inode_t)) == 0);\n    assert(memcmp(&after_replay1, &after_replay2, sizeof(inode_t)) == 0);\n    printf(\"OK: replay is idempotent\\n\");\n}\n```\n---\n## Crash Simulation Test\nThe acceptance criteria require a crash simulation test. You cannot test crash recovery without simulating a crash. The approach: send `SIGKILL` to the filesystem process mid-operation, then remount and verify consistency.\n```bash\n#!/bin/bash\n# crash_test.sh â€” Verify crash recovery correctness\nset -euo pipefail\nDISK=\"./crash_test.img\"\nMOUNT=\"./crash_mount\"\nFS=\"./myfs\"\nMKFS=\"./mkfs\"\ncleanup() {\n    fusermount3 -u \"$MOUNT\" 2>/dev/null || true\n    kill \"$FUSE_PID\" 2>/dev/null || true\n    rm -f \"$DISK\"\n    rmdir \"$MOUNT\" 2>/dev/null || true\n}\ntrap cleanup EXIT\nmkdir -p \"$MOUNT\"\n$MKFS \"$DISK\" 8192 2048\necho \"=== Crash Recovery Test ===\"\n# Phase 1: Mount and create files\n$FS \"$DISK\" \"$MOUNT\" -s &\nFUSE_PID=$!\nsleep 0.5\n# Create a directory and several files\nmkdir \"$MOUNT/important_dir\"\necho \"critical data 1\" > \"$MOUNT/important_dir/file1.txt\"\necho \"critical data 2\" > \"$MOUNT/important_dir/file2.txt\"\n# Start a background operation that will be interrupted\n(\n    for i in $(seq 1 100); do\n        echo \"data $i\" >> \"$MOUNT/important_dir/growing_file.txt\"\n        mkdir -p \"$MOUNT/dir_$i\" 2>/dev/null || true\n    done\n) &\nBG_OP_PID=$!\n# Let the background operation run briefly, then simulate power failure\nsleep 0.1\n# CRASH: send SIGKILL (unclean shutdown â€” no destroy callback)\nkill -9 \"$FUSE_PID\" 2>/dev/null || true\nkill -9 \"$BG_OP_PID\" 2>/dev/null || true\nwait \"$FUSE_PID\" 2>/dev/null || true\nwait \"$BG_OP_PID\" 2>/dev/null || true\n# Unmount the broken FUSE endpoint\nfusermount3 -u \"$MOUNT\" 2>/dev/null || true\necho \"Simulated crash. Remounting for recovery...\"\nsleep 0.5\n# Phase 2: Mount again â€” journal_recover() runs automatically\n$FS \"$DISK\" \"$MOUNT\" -s &\nFUSE_PID=$!\nsleep 1.0\necho \"Recovery complete. Verifying filesystem consistency...\"\n# Check: files that were fully committed before crash must be intact\nCONTENT1=$(cat \"$MOUNT/important_dir/file1.txt\" 2>/dev/null || echo \"MISSING\")\nCONTENT2=$(cat \"$MOUNT/important_dir/file2.txt\" 2>/dev/null || echo \"MISSING\")\n[ \"$CONTENT1\" = \"critical data 1\" ] && echo \"OK: file1.txt intact\" \\\n    || echo \"FAIL: file1.txt content wrong: '$CONTENT1'\"\n[ \"$CONTENT2\" = \"critical data 2\" ] && echo \"OK: file2.txt intact\" \\\n    || echo \"FAIL: file2.txt content wrong: '$CONTENT2'\"\n# Check: no orphaned inodes (all allocated inodes have at least one directory reference)\n# This would require a custom fsck tool; for now, verify basic mount works\nls \"$MOUNT\" > /dev/null && echo \"OK: root directory accessible after recovery\"\nls \"$MOUNT/important_dir\" > /dev/null && echo \"OK: important_dir accessible after recovery\"\n# Check: df reports sane numbers (no negative free block counts)\ndf \"$MOUNT\" | grep -v Filesystem | awk '{\n    if ($4 < 0) { print \"FAIL: negative free blocks\"; exit 1; }\n    else { print \"OK: block counts are sane\"; }\n}'\nfusermount3 -u \"$MOUNT\"\nwait \"$FUSE_PID\" 2>/dev/null || true\necho \"=== Crash Recovery Test Complete ===\"\n```\n---\n## Integrating the Journal Into Mount/Unmount\nThe journal requires two additions to your FUSE lifecycle from Milestone 5:\n```c\n/*\n * Updated myfs_init: run journal recovery before serving requests.\n */\nstatic void *myfs_init(struct fuse_conn_info *conn,\n                        struct fuse_config *cfg) {\n    (void)conn;\n    cfg->entry_timeout    = 1.0;\n    cfg->attr_timeout     = 1.0;\n    cfg->negative_timeout = 0.5;\n    cfg->use_ino          = 1;\n    /* Load journal superblock */\n    if (journal_load(g_fs.fd, &g_fs.sb) != 0) {\n        fprintf(stderr, \"FATAL: failed to load journal superblock\\n\");\n        /* In production: abort mount. For development: continue with warning. */\n    }\n    /* Replay committed transactions from any prior crash */\n    if (journal_recover(g_fs.fd, &g_fs.sb) != 0) {\n        fprintf(stderr, \"WARNING: journal recovery encountered errors\\n\");\n        /* Continue mounting â€” partial recovery is better than no mount */\n    }\n    return NULL;\n}\n/*\n * Updated myfs_destroy: checkpoint journal before unmount.\n */\nstatic void myfs_destroy(void *private_data) {\n    (void)private_data;\n    fs_lock();\n    /* Checkpoint: ensure all committed transactions are in main structures */\n    journal_checkpoint(g_fs.fd, &g_fs.sb);\n    /* Final fsync to ensure checkpoint is durable */\n    fsync(g_fs.fd);\n    close(g_fs.fd);\n    pthread_mutex_destroy(&g_fs.lock);\n    /* Note: fs_unlock() NOT called after mutex destroy */\n}\n```\n---\n## Three-Level View: What Happens During `txn_commit`\nLet's trace `txn_commit(&txn)` for a two-block transaction (one inode update, one bitmap update):\n| Level | What Happens |\n|-------|-------------|\n| **Application (your code)** | Calls `write_block(fd, desc_abs, desc_buf)` â€” writes 4KB descriptor. Calls `write_block(fd, data1_abs, inode_block)` â€” writes 4KB inode copy. Calls `write_block(fd, data2_abs, bitmap_block)` â€” writes 4KB bitmap copy. Calls `fsync(fd)`. Calls `write_block(fd, commit_abs, commit_buf)`. Calls `fsync(fd)`. Then writes inode block and bitmap block to actual locations. Final `fsync`. |\n| **OS / Kernel** | First three `write_block` calls: data goes into kernel page cache (dirty pages). `fsync(fd)`: kernel submits all dirty pages for `fd` to the block layer in order, issues a FLUSH CACHE command to the disk. Waits for disk to confirm. Returns. Second set of `write_block` calls: page cache again. Second `fsync`: same sequence. Total: 5 dirty-page writes to page cache + 2 FLUSH CACHE commands to disk + 2 disk acknowledgments. |\n| **Hardware** | First `fsync`: disk receives write commands for descriptor + data1 + data2 blocks. Disk schedules them (possibly reorders for efficiency within this batch). Disk flushes its write buffer to NAND (SSD) or commits rotational writes to platter (HDD). Disk sends ACK. The FLUSH CACHE command is the barrier: everything before it is durable before anything after it starts. Second `fsync`: same for commit block. The commit block is now on stable media â€” the transaction is committed. |\nThe critical asymmetry: within each `fsync` group, the disk may reorder writes freely. But no write in the second group (commit) can reach stable storage before the first `fsync` completes. That ordering at the `fsync` boundary is the entire mechanism.\n---\n## Knowledge Cascade: One Journal, Ten Domains\n\n![WAL Everywhere â€” Filesystem Journal vs. Database WAL vs. Distributed Log](./diagrams/diag-m6-wal-cross-domain.svg)\n\n### Database WAL: The Identical Pattern\nYou just built the same crash recovery mechanism that every production database uses. The structural identity is exact:\n**PostgreSQL WAL**: PostgreSQL writes changes to WAL segments before applying them to heap pages. Each WAL record has a Log Sequence Number (LSN), analogous to your `j_sequence`. A \"checkpoint\" in PostgreSQL writes all dirty buffer pool pages to disk and records the checkpoint LSN â€” analogous to your `journal_checkpoint`. Recovery after a crash replays WAL from the last checkpoint LSN. The `pg_wal` directory in every PostgreSQL data directory is your journal region.\n**SQLite WAL mode**: SQLite's WAL file contains uncommitted changes. Readers see the database file (clean) plus any committed WAL entries. Writers append to the WAL. A checkpoint copies WAL entries to the main database file. The WAL `shm` (shared memory) file tracks which WAL frames are committed â€” analogous to your journal superblock's head/tail pointers.\n**MySQL InnoDB redo log**: InnoDB's `ib_logfile0` and `ib_logfile1` form a circular log (exactly like your journal region with wrap-around). The \"log sequence number\" is a monotonic 64-bit counter. Crash recovery reads from the last checkpoint LSN to the current write position and replays all redo log entries. The \"fuzzy checkpoint\" mechanism flushes dirty pages asynchronously and advances the checkpoint LSN â€” your `journal_checkpoint` in graduated form.\nThe concepts are identical at every level: transaction, sequence number, commit record, head pointer, tail pointer, replay, checkpoint. You have built the foundation that makes these systems' crash consistency possible.\n### Redis AOF: Durability vs. Performance\nRedis Append-Only File (AOF) is a write-ahead log for an in-memory database. Every write command (`SET`, `LPUSH`, `ZADD`) is appended to the AOF file before the in-memory data structure is modified. On restart, Redis replays the AOF from the beginning to reconstruct state.\nThe AOF has three durability modes: `always` (fsync after every command â€” maximum durability, lowest performance), `everysec` (fsync once per second â€” at most one second of data loss on crash), and `no` (let the OS flush â€” maximum performance, OS controls durability). These map directly to the tradeoff your journal exposes:\n- `always` = your protocol with `fsync` after every transaction\n- `everysec` = batch transactions, fsync once per second (amortize fsync cost across many operations)\n- `no` = skip fsync (fast but loses data on crash)\nThe `everysec` mode trades one second of potential data loss for dramatically higher throughput â€” relevant whenever the cost of the `fsync` dominates transaction latency. For your filesystem, you could implement a similar optimization: buffer multiple transactions in the journal and fsync once per 100ms, accepting that a crash loses at most 100ms of committed transactions.\n### Raft and Distributed WAL\n[[EXPLAIN:raft-consensus-algorithm-â€”-replicated-state-machine-using-a-replicated-log|Raft consensus algorithm â€” achieving crash-consistent agreement across multiple nodes by replicating a write-ahead log]]\nSingle-node WAL is the foundation for understanding distributed consensus. The Raft consensus algorithm â€” used in etcd (Kubernetes' database), CockroachDB, TiKV, and Consul â€” is fundamentally a distributed WAL with the additional constraint that the commit record requires a quorum of nodes to acknowledge receipt.\nIn Raft:\n- Your `txn_begin` = Raft leader receives a client request\n- Your `txn_journal_block` = Raft leader appends the log entry (with index and term)\n- Your first `fsync` = the leader flushes the log to its local disk AND sends AppendEntries RPC to followers\n- The \"majority acknowledgment\" = equivalent to your commit `fsync` â€” the transaction cannot be lost because a majority of nodes have it durably\n- Your `apply` (writing blocks to final locations) = Raft's \"apply to state machine\" (updating key-value store, etc.)\nThe crash recovery protocol in Raft mirrors your journal recovery: a new leader scans committed log entries and re-applies any that may not have reached the state machine. The idempotency requirement is identical: applying the same log entry twice must produce the same state as applying it once.\nUnderstanding your single-node journal makes Raft's log replication intuitive rather than mysterious. The \"distributed\" part adds leader election and quorum logic; the \"WAL\" part is exactly what you built.\n### `fsync` and the Durability API\nUnderstanding the journal explains every `fsync`-related performance complaint you will ever encounter.\n[[EXPLAIN:fsync-vs-fdatasync-â€”-the-difference-between-flushing-metadata-and-data|fsync vs. fdatasync â€” fsync flushes both data and metadata (file size, modification time); fdatasync flushes only data, skipping metadata unless required for correct reads]]\nThe classic complaint: \"why is my database write throughput only 1,000 writes/second on an SSD rated for 100,000 IOPS?\" The answer: the database calls `fsync` (or `fdatasync`) after every committed transaction to ensure durability. Each `fsync` requires a FLUSH CACHE command to the SSD, which takes 100Î¼sâ€“1ms depending on the device and its write buffer state. At 1ms per fsync, maximum throughput is 1,000 fsyncs/second. The SSD's rated IOPS don't matter â€” the bottleneck is the barrier cost, not the raw write speed.\nSolutions used in production:\n- **Group commit**: buffer multiple transactions, fsync once. PostgreSQL's `synchronous_commit = on` with multiple concurrent writers naturally groups their commits into one WAL flush.\n- **Write-ahead log on separate device**: put the WAL on a dedicated SSD with power-loss protection capacitors (enterprise SSDs). These devices guarantee that all data in the write buffer survives a power failure, so `fsync` returns immediately after the buffer accepts the write.\n- **Battery-backed write cache**: RAID controllers with BBU (Battery Backup Unit) can acknowledge `fsync` as soon as data enters the cache â€” the battery ensures the cache survives power loss long enough to flush to disk.\n- **Ordered writes without fsync** (dangerous): some applications skip `fsync` entirely and rely on the OS page cache writeback ordering being \"good enough.\" This works until it doesn't â€” any crash during a multi-block operation can corrupt the data structure. This is what your journal was invented to prevent.\n### Copy-on-Write: Eliminating Journaling's Complexity\nUnderstanding why journaling is complex motivates understanding why ZFS and Btrfs chose a completely different architecture.\nIn a copy-on-write (CoW) filesystem, a write to a block never modifies the existing block. Instead:\n1. Allocate a new block\n2. Write new content to the new block\n3. Update the parent pointer (in the inode or B-tree node) to point to the new block\n4. The old block is now unreferenced â€” free it\nThe atomic operation is step 3: a single pointer update. If the system crashes before the pointer update, the old block is still intact (the old pointer still points to it). If it crashes after, the new pointer is valid. The intermediate state â€” \"new block written but pointer not yet updated\" â€” is always safe: the new block is unreferenced, and the old block is still the live version.\nCoW extends this: updating the inode requires writing a new inode block (step 3 for the parent of the block pointer). Updating the inode block requires updating the inode table block. This cascades all the way to the filesystem's root block â€” called the \"tree root\" or \"uberblock\" in ZFS. The final atomic write is the uberblock update: a single 4KB write that atomically commits the entire set of changes. If the uberblock write succeeds, the entire transaction is committed. If it fails, the old uberblock is still valid.\nThe price: **every write fragments the filesystem**, because writes never go to the same location twice. Over time, a CoW filesystem's data becomes highly fragmented. ZFS handles this with its pool-level allocation, spread across many disks. Btrfs requires periodic `btrfs balance` runs to defragment. The CoW design trades journaling complexity for fragmentation management complexity â€” a different tradeoff, not a free lunch.\nNow you understand WHY both approaches exist: journaling gives you the performance of in-place writes at the cost of maintaining a separate write path (the journal); CoW eliminates the journal at the cost of fragmentation and more complex space management. Neither is universally superior.\n### fsck: The Pre-Journal Alternative\nBefore journaling, the only recovery mechanism was `fsck` (filesystem check). On an unclean mount (power failure, crash), `fsck` would scan every inode in the inode table, every directory block, and every bitmap block to verify consistency. It would detect:\n- Inode with nlinks > 0 but no directory entry referencing it (orphaned inode) â†’ move to `lost+found`\n- Block marked used in bitmap but not referenced by any inode (leaked block) â†’ mark free\n- Block referenced by an inode but marked free in bitmap (double allocation) â†’ dangerous â€” usually requires user intervention\n- Directory entry referencing an invalid inode number â†’ remove the entry\nThe time complexity of `fsck` is O(filesystem size) â€” it must read every metadata block. On a 10TB filesystem at 500MB/s: 20TB of metadata reads Ã· 500MB/s = ~11 hours minimum. In practice, because metadata is scattered (bitmaps are sequential but inode table and directory blocks are random-access), the actual time is much longer on spinning disks due to seek overhead.\nJournaling reduces recovery to O(journal size). The journal is typically 64MBâ€“1GB, readable in under a second on modern SSDs. This is the quantitative argument for journaling: not correctness (fsck achieves correctness eventually), but the difference between 10ms recovery and 10 hours recovery.\nYour `journal_recover` function is the alternative to running `fsck` after every unclean mount. The guarantee: after `journal_recover` completes, the filesystem is in exactly the state it would be in if the committed transactions had been applied cleanly. No scanning, no heuristics, no `lost+found`.\n---\n## Before You Move On: Pitfall Checklist\n- [ ] **Two `fsync` calls per commit, in order**: First `fsync` after journal data writes (before commit block). Second `fsync` after commit block write. Remove either one and the crash consistency guarantee is broken. Verify by adding a `sleep(1)` between the first and second `fsync` and simulating a crash â€” you should see the transaction treated as aborted on recovery.\n- [ ] **Commit record in one atomic write**: The commit block must be written in a single `write_block` call (one 4KB block write). A commit record that spans multiple block writes is not atomic â€” a crash mid-write produces a partial commit record that your recovery code must detect and discard. Your `journal_commit_t` is 4KB and written atomically. Verify: the magic number check at the start of the block is your signal that the block is a valid, complete commit record.\n- [ ] **Idempotent operations â€” no delta records**: Journal entries record the final state of each block, not deltas (\"increment by 1\"). Verify: write two identical `txn_journal_block` calls for the same block with the same data. The second call should update the in-transaction copy (deduplication). Replaying the same transaction twice must produce the same filesystem state. Add a test that calls `journal_recover` twice on the same committed journal and checks that the second recovery produces no changes.\n- [ ] **Circular journal wrap-around**: The `journal_abs_block` function must correctly wrap around. Test: format a filesystem with `journal_blocks = 16` (very small journal). Write 20 transactions. Verify that the journal pointer wraps and older transactions are correctly checkpointed before being overwritten. An off-by-one in the wrap-around calculation causes either early wrap (losing live journal entries) or failure to wrap (writing past journal bounds into data blocks).\n- [ ] **Journal recovery before accepting FUSE requests**: `journal_recover` must complete before `myfs_init` returns. If FUSE starts serving requests while recovery is in progress, operations may observe partially replayed state. The `myfs_init` function is called before FUSE starts the event loop â€” recovery there is safe and correct.\n- [ ] **Checkpoint before journal full**: If the journal fills (no space for a new transaction), your `txn_commit` must either block or force an immediate checkpoint. An undetected full-journal condition causes `txn_commit` to overwrite live journal entries (unrecovered committed transactions) with new transaction data. Add a `blocks_needed > journal_free` check in `txn_commit` and trigger `journal_checkpoint` proactively.\n- [ ] **Metadata-only: `fsync` data before journaling inode**: In ordered metadata journaling mode, always write and fsync the file's data blocks BEFORE journaling the inode that points to them. If the inode is journaled first and you crash before the data write, recovery replays the inode update but the data block contains garbage from a previous file. The ordering: data write â†’ data fsync â†’ journal inode update â†’ journal commit.\n- [ ] **Do not journal data blocks**: Block bitmap updates and inode table blocks are metadata â€” journal them. File data blocks (blocks in the data region pointed to by inodes) are not metadata â€” do not journal them. Journaling data doubles write amplification. Verify: in your transaction's `block_nums` array, no entry should have a value â‰¥ `sb->data_block_start` unless it is a directory data block (which IS metadata).\n- [ ] **Checksum validation in recovery**: Your recovery code validates the commit block's checksum against the data blocks. A corrupted journal entry (partial write of a data block due to torn write) should be detected by checksum mismatch and discarded. Verify: flip a single bit in a journaled data block before writing the commit record, then run recovery and confirm the transaction is discarded rather than replayed with corrupt data.\n- [ ] **Superblock update in transactions**: Any operation that modifies `sb->free_blocks` or `sb->free_inodes` must journal the superblock block (block 0) as part of that transaction. An uncommitted superblock update that survives a crash will show incorrect free counts, causing `ENOSPC` errors when space is actually available or allocating blocks that the free count says don't exist.\n---\n## What You've Built and What It Means\n\n![Filesystem Atlas â€” Satellite Map (Home Base)](./diagrams/diag-L0-satellite-map.svg)\n\nYou have completed the filesystem. Not a toy â€” a crash-consistent, journaled filesystem that can be trusted with real data. The chain is complete: raw block device abstraction, bitmap-based allocation, inode metadata with multi-level indirection, directory entries and path resolution, file read/write with sparse file support, FUSE integration for real OS mounting, and now write-ahead journaling for crash consistency.\nStep back and look at what you understand now that you did not before this milestone.\nYou understand why databases call `fsync`. You understand why skipping `fsync` loses data. You understand why PostgreSQL has WAL segments, why SQLite has a WAL file, why MySQL has redo logs â€” they are all solving the same problem you just solved: making multi-step metadata updates atomic despite non-atomic hardware, despite OS write reordering, despite disk write buffer reordering. The journal is not a database invention. It is a universal pattern for crash consistency.\nYou understand why ZFS never needs `fsck`. You understand why ext4's `dir_index` feature requires a journal-aware implementation (the B-tree restructuring touches multiple blocks that must be atomic). You understand why NTFS has a `$LogFile`. You understand why every serious storage system â€” from SQLite to Kafka to etcd â€” maintains a sequential write-ahead log as its first and most fundamental data structure.\nThe disk does not know you exist. But now you know how to make it remember exactly what you committed â€” and nothing more.\n---\n<!-- END_MS -->\n\n\n## System Overview\n\n![System Overview](./diagrams/system-overview.svg)\n\n\n\n\n# TDD\n\nA ground-up inode-based filesystem built in six layered milestones, each milestone a self-contained module with explicit hardware constraints, byte-level memory layouts, and crash-consistency guarantees. Every module is designed so an engineer can open it, read the diagrams, and begin implementation without ambiguity. The architecture negotiates the fundamental tension between byte-addressable software abstractions and block-addressable hardware reality at every layer.\n\n\n\n<!-- TDD_MOD_ID: filesystem-m1 -->\n# Module Technical Design Specification: Block Layer and mkfs (filesystem-m1)\n\n## 1. Module Charter\n\nThe **Block Layer and mkfs** module serves as the foundational substrate for the entire filesystem. Its primary responsibility is to provide a reliable block-level I/O abstraction over a flat file (disk image) and to establish the physical on-disk layout required for higher-level metadata structures. \n\n**Scope:**\n- Implements `read_block` and `write_block` primitives with strict 4KB alignment.\n- Defines the `superblock_t` structure and its exact byte-level serialization.\n- Implements bit-level allocation tracking (bitmaps) for data blocks and inodes.\n- Provides a formatting tool (`mkfs`) to initialize a disk image with a valid root directory.\n\n**Out of Scope:**\n- Multi-level inode pointer traversal (Milestone 2).\n- Directory entry management beyond the initial root creation (Milestone 3).\n- Write-ahead journaling logic (Milestone 6), though space is reserved.\n- In-memory buffer caching (all I/O is direct to/from the host OS page cache).\n\n**Invariants:**\n- Every disk operation must occur in units of exactly 4096 bytes.\n- Block 0 is always the Superblock; it can never be allocated for data.\n- The block bitmap only tracks blocks in the \"Data Region\"; bit 0 of the bitmap corresponds to the first block of the data region.\n- All on-disk structures must be little-endian and packed (no compiler padding).\n\n---\n\n## 2. File Structure\n\nThe implementation follows a strict creation order to ensure dependencies are met:\n\n1.  `fs_types.h`: Constant definitions (Magic numbers, block sizes, region offsets).\n2.  `block_io.h / block_io.c`: Low-level `lseek/read/write` wrappers.\n3.  `bitmap.h / bitmap.c`: Bit-level manipulation and search logic.\n4.  `superblock.h / superblock.c`: Layout calculation and serialization.\n5.  `mkfs.c`: The standalone CLI tool for image initialization.\n6.  `test_m1.c`: Verification suite for the block layer.\n\n---\n\n## 3. Complete Data Model\n\n### 3.1. Superblock (superblock_t)\nThe Superblock is the \"Birth Certificate\" of the filesystem. It resides at byte offset 0.\n\n| Offset | Field | Type | Description |\n| :--- | :--- | :--- | :--- |\n| 0x00 | `s_magic` | `uint32_t` | Magic Number (0xDEADC0DE). |\n| 0x04 | `s_version` | `uint32_t` | Filesystem version (default 1). |\n| 0x08 | `s_block_size` | `uint32_t` | Always 4096. Used for validation. |\n| 0x0C | `s_total_blocks` | `uint32_t` | Total size of the image in blocks. |\n| 0x10 | `s_total_inodes` | `uint32_t` | Total capacity of the inode table. |\n| 0x14 | `s_free_blocks` | `uint32_t` | Current count of unallocated data blocks. |\n| 0x18 | `s_free_inodes` | `uint32_t` | Current count of unallocated inodes. |\n| 0x1C | `s_inode_bmap_start` | `uint32_t` | Block index for Inode Bitmap (usually 1). |\n| 0x20 | `s_block_bmap_start` | `uint32_t` | Block index for Block Bitmap (usually 2). |\n| 0x24 | `s_inode_table_start` | `uint32_t` | First block of the Inode Table. |\n| 0x28 | `s_inode_table_len` | `uint32_t` | Number of blocks in the Inode Table. |\n| 0x2C | `s_journal_start` | `uint32_t` | First block of the Journal region. |\n| 0x30 | `s_journal_len` | `uint32_t` | Number of blocks reserved for Journal. |\n| 0x34 | `s_data_region_start` | `uint32_t` | First block available for file data. |\n| 0x38 | `s_root_inode` | `uint32_t` | Inode number of the root directory (usually 1). |\n| 0x3C | `s_reserved` | `uint8_t[4036]` | Padding to reach exactly 4096 bytes. |\n\n### 3.2. Inode Stub (inode_t)\nA minimal definition required for `mkfs` to initialize the root directory. Full implementation occurs in M2.\n\n```c\n#define INODE_SIZE 128\n#define N_DIRECT 12\n\ntypedef struct __attribute__((packed)) {\n    uint16_t i_mode;          // 0x00: File type + permissions\n    uint16_t i_nlinks;        // 0x02: Hard link count\n    uint32_t i_size;          // 0x04: File size in bytes\n    uint32_t i_atime;         // 0x08: Access time\n    uint32_t i_mtime;         // 0x0C: Modification time\n    uint32_t i_ctime;         // 0x10: Metadata change time\n    uint32_t i_blocks[N_DIRECT]; // 0x14: Direct block pointers\n    uint32_t i_single_ind;    // 0x44: Single indirect pointer\n    uint32_t i_double_ind;    // 0x48: Double indirect pointer\n    uint8_t  i_pad[52];       // Padding to 128 bytes\n} inode_t;\n```\n\n---\n\n## 4. Interface Contracts\n\n### 4.1. Block I/O Layer\n```c\n/**\n * Reads a 4KB block from the disk image.\n * @param fd Open file descriptor to the image.\n * @param block_num Logical block index (0 to s_total_blocks - 1).\n * @param buf Destination buffer (must be at least 4096 bytes).\n * @return 0 on success, -EIO on short read, -EINVAL on bounds error.\n */\nint read_block(int fd, uint32_t block_num, void *buf);\n\n/**\n * Writes a 4KB block to the disk image.\n * @param fd Open file descriptor.\n * @param block_num Logical block index.\n * @param buf Source buffer.\n * @return 0 on success, -EIO on short write.\n */\nint write_block(int fd, uint32_t block_num, const void *buf);\n```\n\n### 4.2. Bitmap Allocator\n```c\n/**\n * Allocates a data block from the free block bitmap.\n * @return The absolute disk block number, or -ENOSPC if full.\n * @note Triggers a read-modify-write on the bitmap block.\n */\nint alloc_data_block(int fd, superblock_t *sb);\n\n/**\n * Frees a data block and updates the bitmap.\n * @param block_num Absolute disk block address.\n */\nint free_data_block(int fd, superblock_t *sb, uint32_t block_num);\n```\n\n---\n\n## 5. Algorithm Specification\n\n### 5.1. On-Disk Layout Computation\nDuring `mkfs`, the regions must be calculated based on user-provided counts.\n\n1.  **Block 0**: Superblock.\n2.  **Block 1**: Inode Bitmap. Size: 1 block (supports up to 32,768 inodes).\n3.  **Block 2**: Block Bitmap. Size: 1 block (supports up to 32,768 data blocks).\n4.  **Inode Table**: Starts at Block 3. \n    - `table_blocks = (total_inodes * INODE_SIZE + BLOCK_SIZE - 1) / BLOCK_SIZE`.\n5.  **Journal Region**: Starts at `3 + table_blocks`. \n    - Default size: 1024 blocks (4MB).\n6.  **Data Region**: Starts at `journal_start + journal_len`.\n    - Total usable data blocks = `total_blocks - data_region_start`.\n\n### 5.2. Bitmap Search (`bitmap_find_free`)\nTo minimize CPU cycles, the search should be byte-aligned before checking bits.\n\n1.  Iterate through the 4096 bytes of the bitmap buffer.\n2.  If `byte[i] == 0xFF`, skip (all 8 bits in this byte are used).\n3.  If `byte[i] < 0xFF`, find the first zero bit using `__builtin_ctz(~byte[i])` or a manual loop.\n4.  Calculate `index = i * 8 + bit_position`.\n5.  Ensure `index < tracked_items_limit`.\n6.  Return `index`.\n\n### 5.3. Root Directory Initialization\n`mkfs` must create a valid `/` to make the disk mountable.\n\n1.  Allocate Inode 1 (Bit 0 in Inode Bitmap).\n2.  Allocate Data Block 0 (Bit 0 in Block Bitmap).\n3.  Initialize `inode_t` for root: `mode = S_IFDIR | 0755`, `nlinks = 2`, `size = 4096`, `blocks[0] = s_data_region_start`.\n4.  Write two directory entries to the first data block: `.` pointing to Inode 1, `..` pointing to Inode 1.\n5.  Update Superblock `free_blocks` and `free_inodes`.\n\n---\n\n## 6. Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n| :--- | :--- | :--- | :--- |\n| `EINVAL` | `read_block` | Reject operation; do not seek. | Yes (API return) |\n| `EIO` | `write_block` | Image file might be read-only or disk full. | Yes |\n| `ENOSPC` | `alloc_data_block` | Fail file creation or write. | Yes |\n| Magic Mismatch | `main/mount` | Refuse to mount; protect data. | Yes |\n| Short Write | `write_block` | Attempt `fsync`; if still short, return `EIO`. | Yes |\n\n---\n\n## 7. Implementation Sequence with Checkpoints\n\n### Phase 1: Block I/O Bedrock (2 Hours)\nImplement `read_block`, `write_block`, and `validate_block_num`. Create a small test utility that opens a file, writes \"DEADBEEF\" to block 5, and reads it back.\n**Checkpoint:** `block_test disk.img` successfully writes/reads block 5.\n\n### Phase 2: Serialization & Layout (3 Hours)\nDefine `superblock_t` with `__attribute__((packed))`. Implement `compute_layout`. Write a small tool to print where regions would live for a 100MB disk.\n**Checkpoint:** `layout_calc 100MB` prints `Data Region starts at block 1059`.\n\n### Phase 3: The Allocator (3 Hours)\nImplement `bitmap_find_free` and the `alloc/free` wrappers.\n**Checkpoint:** `test_alloc` allocates 10 blocks, verifies bits are set in the bitmap block, frees 5, and verifies bits are cleared.\n\n### Phase 4: mkfs (5 Hours)\nCombine all logic into `mkfs.c`. It must:\n1. Create the file.\n2. Write the Superblock.\n3. Zero out the bitmaps and inode table.\n4. Manually inject the Root Inode and its first Data Block.\n**Checkpoint:** `hexdump -C disk.img` shows `DE AD C0 DE` at offset 0 and the string `.` at the start of the data region.\n\n---\n\n## 8. Test Specification\n\n### 8.1. Happy Path: Formatting\n- **Input**: `mkfs disk.img 4096 1024`\n- **Assertion**: File size is exactly 16,777,216 bytes. Superblock fields match calculated layout. Root inode (Inode 1) has `nlinks == 2`.\n\n### 8.2. Edge Case: Boundary Allocation\n- **Input**: Allocate blocks until `alloc_data_block` returns `-ENOSPC`.\n- **Assertion**: Number of successful allocations must exactly equal `s_total_blocks - s_data_region_start`.\n\n### 8.3. Failure Case: Invalid Mount\n- **Input**: Point a mock mount function to a text file.\n- **Assertion**: Function returns `-EINVAL` because magic number `0xDEADC0DE` is not found at offset 0.\n\n---\n\n## 9. Performance Targets\n\n| Operation | Target | Measurement |\n| :--- | :--- | :--- |\n| Block Write Latency | < 200Î¼s (SSD) | `clock_gettime` around `write_block` |\n| Bitmap Scan | < 500ns | Benchmark `bitmap_find_free` with 32k bits set |\n| mkfs Throughput | > 100 MB/s | Format a 1GB image; time the process |\n\n---\n\n## 10. Hardware Soul (Cache & Alignment)\n\n1.  **Cache Line Alignment**: The `superblock_t` is 4096 bytes. When read into memory, it spans exactly 64 cache lines (assuming 64B lines). The \"hot\" fields (magic, free counts) are at the start of the first cache line.\n2.  **TLB Impact**: Because our block size matches the x86-64 page size (4KB), every `read_block` into a page-aligned buffer minimizes TLB misses during the `memcpy` or syscall transition.\n3.  **Read-Modify-Write**: `alloc_data_block` fetches one 4KB block (the bitmap). This block resides in the host OS Page Cache. Subsequent allocations within the same 32,768-block range will result in Page Cache hits, avoiding physical disk I/O until the kernel flushes dirty pages.\n\n---\n\n### \n![Block Device Abstraction â€” read_block/write_block Data Flow](./diagrams/tdd-diag-1.svg)\n\n**Logical to Physical Mapping in mkfs**\n```text\n[Disk Image File]\n|\n|-- [Block 0: Superblock] (4KB)\n|-- [Block 1: Inode Bitmap] (4KB)\n|-- [Block 2: Block Bitmap] (4KB)\n|-- [Block 3 to N: Inode Table] (Variable)\n|-- [Block N+1 to M: Journal] (Default 4MB)\n|-- [Block M+1 to End: Data Region] (Usable blocks)\n```\n\n### \n![On-Disk Layout â€” Complete Block Map](./diagrams/tdd-diag-2.svg)\n\n**Bitmap Bit Manipulation**\n```text\nByte Index = bit_index / 8\nBit Mask   = 1 << (bit_index % 8)\n\n[00001011]  <- Byte 0\n ^   ^  ^\n |   |  bit 0 (Used)\n |   bit 3 (Used)\n bit 7 (Free)\n```\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: filesystem-m2 -->\n# Module Technical Design Specification: Inode Management (filesystem-m2)\n\n## 1. Module Charter\n\nThe **Inode Management** module is the structural heart of the filesystem. It defines the identity and data-mapping capability of every file and directory in the system. While the Block Layer (M1) provides raw containers, this module provides the hierarchical pointer machinery required to transform those containers into variable-sized, addressable files.\n\n**Scope:**\n- Definition and serialization of the 128-byte `inode_t` structure.\n- Implementation of the multi-level block pointer tree (Direct, Single-Indirect, Double-Indirect).\n- Logic for logical-to-physical block translation (`inode_get_block`).\n- On-demand allocation of indirect blocks during file growth (`inode_set_block`).\n- Atomic-style inode allocation from bitmaps and recursive, bottom-up deallocation of entire pointer trees.\n- Enforcement of sparse file semantics where unallocated regions (holes) are represented by null pointers.\n\n**Out of Scope:**\n- Directory entry parsing or path-to-inode resolution (Milestone 3).\n- Moving actual file data bytes (Milestone 4).\n- Cache management or buffer pooling.\n\n**Invariants:**\n- Inode numbers are 1-based; Inode 0 is strictly reserved as a NULL/Invalid sentinel.\n- A block pointer value of `0` always represents a sparse hole; it must never point to the Superblock (Block 0).\n- Recursive deallocation must free data blocks before freeing the indirect blocks that point to them to avoid orphaning.\n- Any modification to an inode's pointer tree requires an update to the inode's `i_ctime`.\n\n---\n\n## 2. File Structure\n\nImplementation follows the recursive complexity of the pointer tree:\n\n1. `inode.h`: Definition of `inode_t`, constants for limits, and function prototypes.\n2. `inode_io.c`: Serialization logic (`read_inode`, `write_inode`) and table offset math.\n3. `inode_alloc.c`: Bitmap integration for `alloc_inode` and basic `free_inode`.\n4. `inode_tree.c`: The core traversal engine (`inode_get_block`, `inode_set_block`).\n5. `inode_free_recursive.c`: Depth-first traversal for full tree reclamation.\n6. `test_m2.c`: Comprehensive test suite verifying 4GB file addressing and sparse holes.\n\n---\n\n## 3. Complete Data Model\n\n### 3.1. Inode Structure (inode_t)\nEach inode occupies exactly 128 bytes. There are 32 inodes per 4KB block.\n\n| Offset | Field | Type | Description |\n| :--- | :--- | :--- | :--- |\n| 0x00 | `i_mode` | `uint16_t` | File type (High 4 bits) + Permissions (Low 12 bits). |\n| 0x02 | `i_nlinks` | `uint16_t` | Reference count (Hard links). Inode is freed when this is 0. |\n| 0x04 | `i_uid` | `uint16_t` | Owner User ID. |\n| 0x06 | `i_gid` | `uint16_t` | Owner Group ID. |\n| 0x08 | `i_size` | `uint32_t` | Logical file size in bytes (max ~4GB). |\n| 0x0C | `i_atime` | `uint32_t` | Access time (Unix timestamp). |\n| 0x10 | `i_mtime` | `uint32_t` | Data modification time. |\n| 0x14 | `i_ctime` | `uint32_t` | Inode metadata change time. |\n| 0x18 | `i_blocks[12]` | `uint32_t[12]` | Direct block pointers (Addresses first 48KB). |\n| 0x48 | `i_single_ind` | `uint32_t` | Pointer to a block of 1024 pointers (+4MB). |\n| 0x4C | `i_double_ind` | `uint32_t` | Pointer to a block of 1024 single-indirect pointers (+4GB). |\n| 0x50 | `i_reserved` | `uint8_t[48]` | Zero-filled padding to 128 bytes. |\n\n**Hardware Soul (Alignment):**\n- **Packed:** The struct uses `__attribute__((packed))` to ensure field offsets are identical across architectures.\n- **Cache Line:** Two `inode_t` structs (256B) fit exactly into four 64-byte L1 cache lines.\n- **RMW Cycle:** Updating one inode requires reading 4096 bytes (32 inodes), modifying 128, and writing 4096.\n\n### 3.2. Indirect Block Format\nAn indirect block is simply a raw 4KB block treated as an array of block addresses.\n\n```c\n#define PTRS_PER_BLOCK (BLOCK_SIZE / sizeof(uint32_t)) // 1024 pointers\ntypedef uint32_t indirect_block_t[PTRS_PER_BLOCK];\n```\n\n---\n\n## 4. Interface Contracts\n\n### 4.1. Lifecycle Management\n```c\n/**\n * Allocate a new inode from the inode bitmap.\n * @return 1-based inode number, or -ENOSPC.\n */\nint alloc_inode(int fd, superblock_t *sb);\n\n/**\n * Free an inode and recursively reclaim all associated data and indirect blocks.\n * @param inode_num 1-based index.\n */\nint free_inode(int fd, superblock_t *sb, uint32_t inode_num);\n\n/**\n * Initialize an inode struct with default values based on type.\n */\nvoid inode_init(inode_t *inode, uint16_t mode, uint16_t uid, uint16_t gid);\n```\n\n### 4.2. Block Translation Engine\n```c\n/**\n * Translates a logical file offset to an absolute disk block address.\n * @param offset Byte offset in file.\n * @param out_block Absolute disk block number. 0 indicates a sparse hole.\n * @return 0 on success, -EFBIG if offset exceeds 4GB limit.\n */\nint inode_get_block(int fd, const inode_t *inode, uint64_t offset, uint32_t *out_block);\n\n/**\n * Maps a logical file offset to a specific disk block. \n * Allocates indirect blocks if necessary to reach the required depth.\n * @param disk_block Absolute block address to store.\n */\nint inode_set_block(int fd, superblock_t *sb, inode_t *inode, uint64_t offset, uint32_t disk_block);\n```\n\n---\n\n## 5. Algorithm Specification\n\n### 5.1. The Traversal Logic (`inode_get_block`)\nThe translation follows a branching decision based on the logical block index `bi = offset / 4096`.\n\n1.  **Direct (0 <= bi < 12)**:\n    - Return `inode->i_blocks[bi]`.\n2.  **Single Indirect (12 <= bi < 1024 + 12)**:\n    - If `inode->i_single_ind == 0`, return `0` (Hole).\n    - Read block `inode->i_single_ind`.\n    - Return `indirect_block[bi - 12]`.\n3.  **Double Indirect (1024+12 <= bi < 1024^2 + 1024 + 12)**:\n    - If `inode->i_double_ind == 0`, return `0`.\n    - Read `inode->i_double_ind` into `buf_outer`.\n    - `outer_idx = (bi - 1036) / 1024`.\n    - `inner_idx = (bi - 1036) % 1024`.\n    - If `buf_outer[outer_idx] == 0`, return `0`.\n    - Read `buf_outer[outer_idx]` into `buf_inner`.\n    - Return `buf_inner[inner_idx]`.\n\n### 5.2. Recursive Deallocation (`free_inode`)\nTo prevent leaks, deallocation must follow a Post-Order Traversal (Bottom-Up).\n\n1.  **Level 0**: Loop `i_blocks[0..11]`. If non-zero, `free_data_block`.\n2.  **Level 1**: If `i_single_ind != 0`:\n    - Read block. Loop all 1024 pointers. If non-zero, `free_data_block`.\n    - `free_data_block(i_single_ind)`.\n3.  **Level 2**: If `i_double_ind != 0`:\n    - Read `i_double_ind` (Outer).\n    - For each `p_outer` in Outer:\n        - If `p_outer != 0`:\n            - Read `p_outer` (Inner).\n            - For each `p_inner` in Inner: if `p_inner != 0`, `free_data_block`.\n            - `free_data_block(p_outer)`.\n    - `free_data_block(i_double_ind)`.\n4.  Clear bits in Inode Bitmap and decrement `s_free_inodes`.\n\n### 5.3. Sparse Allocation (`inode_set_block`)\nWhen writing to a previously unallocated offset, the filesystem must \"fill\" the path to that block.\n\n1.  Calculate target depth (Direct, Single, or Double).\n2.  If the required indirect block pointer is `0`:\n    - `new_block = alloc_data_block(fd, sb)`.\n    - Zero out `new_block` (crucial to avoid garbage pointers).\n    - Update parent pointer to `new_block`.\n3.  Descend to next level and repeat until the final data pointer slot is reached.\n4.  Write the `disk_block` value into the leaf slot.\n\n---\n\n## 6. Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n| :--- | :--- | :--- | :--- |\n| `EINVAL` | `read_inode` | Validate number range (1 to `total_inodes`). | Yes |\n| `EFBIG` | `inode_get_block` | Prevent seeking/writing beyond ~4GB. | Yes |\n| `ENOSPC` | `inode_set_block` | Allocation of indirect block failed. Fail the write. | Yes |\n| `EIO` | `write_inode` | Device error during RMW cycle. | Yes |\n| Corruption | `inode_get_block` | If a pointer > `total_blocks`, return `EIO` and log. | Yes |\n\n---\n\n## 7. Implementation Sequence with Checkpoints\n\n### Phase 1: Serialization & Inode Table Math (3 Hours)\nImplement `read_inode` and `write_inode`. \n- **Offset Math:** `byte_offset = (sb->s_inode_table_start * 4096) + ((ino-1) * 128)`.\n- **Read-Modify-Write:** Ensure `write_inode` reads the 4KB block, modifies the 128B slot, and writes back.\n**Checkpoint:** Using a hex editor, manually change Inode 5's `i_mode` and verify `read_inode` sees the change.\n\n### Phase 2: Inode Lifecycle (3 Hours)\nImplement `alloc_inode`, `free_inode` (stubbed for direct blocks), and `inode_init`.\n**Checkpoint:** Allocate 100 inodes, verify bitmap bits are set, then free them and verify bits are cleared.\n\n### Phase 3: The Translation Engine (4 Hours)\nImplement `inode_get_block` and `inode_set_block` for Direct and Single-Indirect regions.\n- **Math Check:** 48KB boundary is the transition point.\n**Checkpoint:** Write a block at offset 64KB (Single Indirect), read it back, and verify the physical block address is stored in the indirect block.\n\n### Phase 4: Recursive Reclamation (4 Hours)\nImplement the full depth-first `free_inode` including double-indirection.\n**Checkpoint:** Create a 10MB file (Double Indirect). Record `s_free_blocks`. Delete file. Verify `s_free_blocks` returns exactly to the previous value.\n\n---\n\n## 8. Test Specification\n\n### 8.1. Sparse File Integrity\n1. Create new inode.\n2. Call `inode_get_block` at offset 1GB.\n3. **Assertion:** `out_block == 0`.\n4. Call `inode_set_block` at offset 1GB with block 5000.\n5. **Assertion:** `inode->i_double_ind != 0`. `inode_get_block` at offset 500MB still returns 0.\n\n### 8.2. Address Boundary Transitions\n1. Set block at offset 49,151 (Last byte of Direct 11).\n2. Set block at offset 49,152 (First byte of Single Indirect).\n3. **Assertion:** Block 11 is in `i_blocks[11]`. Block 12 is in the first slot of `i_single_ind`.\n\n### 8.3. Recursive Cleanup (Leak Detection)\n1. Write a file that uses exactly 1 double-indirect block, 2 single-indirect blocks, and 12 direct blocks.\n2. Calculate total metadata blocks: 1 + 2 = 3 blocks.\n3. Total blocks used = 3 + data blocks.\n4. Call `free_inode`.\n5. **Assertion:** Superblock `s_free_blocks` increases by exactly `3 + data_count`.\n\n---\n\n## 9. Performance Targets\n\n| Operation | Target | Measurement |\n| :--- | :--- | :--- |\n| Inode Translation (Direct) | O(1) Memory Access | No `read_block` calls. |\n| Inode Translation (Single) | 1 Disk I/O | Exactly one `read_block`. |\n| Inode Translation (Double)| 2 Disk I/Os | Exactly two `read_block` calls. |\n| Inode Table Density | 32 inodes/block | `_Static_assert(sizeof(inode_t) == 128)`. |\n\n---\n\n## 10. Concurrency Specification\n\nWhile the project is currently single-threaded, the design requires:\n1.  **Serialization:** Inodes must be locked before `inode_set_block` begins, as it modifies internal pointers and may trigger block allocations that update the Superblock.\n2.  **Order of Operations:** To avoid corruption on crash, the **Indirect Block** must be zeroed and written to disk **before** the parent inode pointer is updated and written.\n\n---\n\n### \n![inode_t Structure â€” Byte-Level Memory Layout (128 bytes)](./diagrams/tdd-diag-8.svg)\n\n**Inode Block Pointer Tree**\n```text\ninode_t (128B)\n|\n|-- [0..11] Direct Pointers -------> [Data Block] (4KB)\n|\n|-- [12] Single Indirect ----------> [Pointer Block] (4KB)\n|                                    |-- [0..1023] --------> [Data Block]\n|\n|-- [13] Double Indirect ----------> [Outer Pointer Block] (4KB)\n                                     |-- [0..1023]\n                                         |\n                                         --> [Inner Pointer Block] (4KB)\n                                             |-- [0..1023] --> [Data Block]\n```\n\n### \n![Inode Block Pointer Tree â€” Direct, Single-Indirect, Double-Indirect](./diagrams/tdd-diag-9.svg)\n\n**Memory Layout of Inode Table Block**\n```text\nDisk Block (4096 Bytes)\n+----------------+----------------+----------------+-----+----------------+\n| Inode 1 (128B) | Inode 2 (128B) | Inode 3 (128B) | ... | Inode 32 (128) |\n+----------------+----------------+----------------+-----+----------------+\n^                ^                ^\n0x00             0x80             0x100\n```\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: filesystem-m3 -->\n# Module Technical Design Specification: Directory Operations (filesystem-m3)\n\n## 1. Module Charter\n\nThe **Directory Operations** module transforms the flat, numeric inode space into a human-navigable hierarchical tree. It implements the \"Directory is a special file\" abstraction, where data blocks contain variable-length directory entry records mapping UTF-8 strings to inode numbers.\n\n**Scope:**\n- Definition of the variable-length on-disk `dirent` format and the `rec_len` skip-logic.\n- Implementation of linear directory scanning for name lookups and entry additions.\n- Path resolution engine supporting absolute and relative paths, including `.` and `..` traversal.\n- Atomic-style directory mutations (`mkdir`, `rmdir`, `link`, `unlink`) with strict adherence to POSIX link-count invariants.\n- Support for directory entry merging during deletion to prevent fragmentation within blocks.\n\n**Out of Scope:**\n- Higher-level FUSE callback wrappers (Milestone 5).\n- Directory indexing optimizations like HTrees or B-Trees (linear scan only).\n- Multi-threaded locking (deferred to the global FUSE lock).\n\n**Invariants:**\n- Every directory MUST contain `.` (self) and `..` (parent) as its first two entries.\n- The `rec_len` of the last entry in a directory block MUST extend to the end of the 4KB block.\n- Directory entries must never span across two physical blocks.\n- Hard links to directories are strictly forbidden to prevent filesystem cycles.\n- Root directory's `..` entry points to itself (Inode 1).\n\n---\n\n## 2. File Structure\n\nImplementation follows a dependency-driven sequence:\n\n1. `dir.h`: Structure definitions for on-disk and in-memory directory entries.\n2. `dir_rec.c`: Low-level record manipulation (padding, length calculation, buffer serialization).\n3. `dir_scan.c`: Linear scanning logic (`dir_lookup`, `dir_readdir`).\n4. `dir_path.c`: Recursive path resolution and component splitting using `strtok_r`.\n5. `dir_write.c`: Mutation logic (`dir_add_entry` with splitting, `dir_remove_entry` with merging).\n6. `dir_op.c`: High-level POSIX-style operations (`fs_mkdir`, `fs_rmdir`, `fs_link`, `fs_unlink`).\n7. `test_m3.c`: Integration tests for tree navigation and link-count correctness.\n\n---\n\n## 3. Complete Data Model\n\n### 3.1. On-Disk Directory Entry (Physical Layout)\nEntries are variable-length. The header is exactly 8 bytes. The name is NOT null-terminated on disk to save space; `name_len` provides the boundary.\n\n| Offset | Field | Type | Description |\n| :--- | :--- | :--- | :--- |\n| 0x00 | `d_inode` | `uint32_t` | Target Inode Number. 0 = Deleted/Empty Slot. |\n| 0x04 | `d_rec_len` | `uint16_t` | Distance to the next record header in bytes. |\n| 0x06 | `d_name_len` | `uint8_t` | Actual length of the filename string. |\n| 0x07 | `d_file_type` | `uint8_t` | Hint: 1=Reg, 2=Dir, 7=Symlink. |\n| 0x08 | `d_name[...]` | `char[]` | Filename string (1 to 255 bytes). |\n| Ends | `padding` | `uint8_t[]` | 0-3 bytes to ensure the NEXT record starts on a 4-byte boundary. |\n\n**Hardware Soul (Alignment & Scanning):**\n- **4-Byte Alignment:** Every `d_rec_len` is a multiple of 4. This ensures `uint32_t` fields in the next header are naturally aligned, preventing unaligned access penalties on sensitive architectures.\n- **Skip-Logic:** To find \"FileB\" in a block, the CPU reads the header of \"FileA\", adds `d_rec_len` to the current pointer, and jumps directly to \"FileB\".\n\n### 3.2. In-Memory Representation (dirent_t)\nUsed for passing data between internal functions.\n\n```c\n#define MAX_FILENAME_LEN 255\n#define DIRENT_HEADER_SIZE 8\n\ntypedef struct {\n    uint32_t inode_num;\n    uint16_t rec_len;\n    uint8_t  name_len;\n    uint8_t  file_type;\n    char     name[MAX_FILENAME_LEN + 1]; // Null-terminated for C string compatibility\n} dirent_t;\n```\n\n---\n\n## 4. Interface Contracts\n\n### 4.1. Lookup and Resolution\n```c\n/**\n * Resolves a full path (e.g., \"/usr/bin/gcc\") to an inode number.\n * @param path Null-terminated path string.\n * @return Inode number > 0, or negative errno.\n */\nint path_resolve(int fd, superblock_t *sb, const char *path);\n\n/**\n * Resolves the parent directory of a path.\n * @param path Input path.\n * @param out_parent_ino Set to parent inode number.\n * @param out_name Buffer for the final component name (e.g., \"gcc\").\n * @return 0 on success.\n */\nint path_resolve_parent(int fd, superblock_t *sb, const char *path, uint32_t *out_parent_ino, char *out_name);\n```\n\n### 4.2. Directory Mutation\n```c\n/**\n * Adds a name->inode mapping to a directory.\n * @return 0 or -EEXIST if name found.\n */\nint dir_add_entry(int fd, superblock_t *sb, uint32_t dir_ino, const char *name, uint32_t target_ino, uint8_t type);\n\n/**\n * Removes a name mapping. Merges the record's space into the previous entry.\n * @return 0 or -ENOENT.\n */\nint dir_remove_entry(int fd, superblock_t *sb, uint32_t dir_ino, const char *name);\n```\n\n---\n\n## 5. Algorithm Specification\n\n### 5.1. Directory Entry Packing (`dir_add_entry`)\nWhen adding \"NewFile\" (Needed space = `actual_len(7)` = 12 bytes):\n\n1.  **Iterate** existing directory blocks.\n2.  For each block, **scan** records using `rec_len`.\n3.  For each record, calculate its `min_required_len = align4(8 + name_len)`.\n4.  **Find Free Space:** `available_gap = current_rec_len - min_required_len`.\n5.  If `available_gap >= needed_space`:\n    - **Split:** Set `current_record->rec_len = min_required_len`.\n    - **Insert:** Write new record at `offset + min_required_len` with `rec_len = available_gap`.\n    - Return success.\n6.  If no gap found in any block, allocate a new data block via `alloc_data_block`, initialize it with one record where `rec_len = 4096`.\n\n### 5.2. Path Resolution Engine (`path_resolve`)\n1.  **Start:** `current_ino = sb->s_root_inode` if path starts with `/`, else `cwd`.\n2.  **Tokenize:** Use `strtok_r` with `/` as delimiter.\n3.  **Loop components:**\n    - Call `read_inode(current_ino)`.\n    - Verify `S_ISDIR(mode)`. Return `-ENOTDIR` if not.\n    - Call `dir_lookup(current_ino, component_name)`.\n    - If returns 0, return `-ENOENT`.\n    - `current_ino = result`.\n4.  **End:** Return `current_ino`.\n\n### 5.3. Link Count Invariants (`fs_mkdir` / `fs_rmdir`)\nCreating a directory `D` inside parent `P`:\n1.  `P->i_nlinks` increases by 1 (because `D/..` points to `P`).\n2.  `D->i_nlinks` is initialized to 2 (`D/.` and `P/D`).\n\nRemoving directory `D`:\n1.  Check if `D` is empty (scan data blocks, verify only `.` and `..` exist).\n2.  `P->i_nlinks` decreases by 1.\n3.  `D->i_nlinks` drops to 0; triggers `free_inode`.\n\n---\n\n## 6. Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n| :--- | :--- | :--- | :--- |\n| `ENOTEMPTY` | `fs_rmdir` | Abort removal if entries > 2 found. | Yes |\n| `EEXIST` | `dir_add_entry` | Return error; prevent duplicate names. | Yes |\n| `EPERM` | `fs_link` | If target is `S_IFDIR`, reject to prevent cycles. | Yes |\n| `ENAMETOOLONG`| `path_resolve` | Reject if component > 255 bytes. | Yes |\n| `ELOOP` | `path_resolve` | (Advanced) Count components; reject if > 1024. | Yes |\n| `EIO` | `dir_scan` | If `rec_len == 0` or overlaps, stop and return error. | Yes |\n\n---\n\n## 7. Implementation Sequence with Checkpoints\n\n### Phase 1: Serialization Primitives (3 Hours)\nImplement `dirent_actual_len` and buffer serializers. Ensure 4-byte padding logic is perfect.\n**Checkpoint:** Write a \"FileA\" entry followed by \"FileB\". Verify \"FileB\" starts at an address divisible by 4.\n\n### Phase 2: Scanning (3 Hours)\nImplement `dir_lookup`. It must iterate through `inode->i_blocks` (using M2 logic) and walk the `rec_len` chain.\n**Checkpoint:** Manually create a directory block in `mkfs`. Use `dir_lookup` to find the inode of `..`.\n\n### Phase 3: Path Resolution (4 Hours)\nImplement `path_resolve` and `split_path`.\n**Checkpoint:** Resolve `/` (returns 1). Resolve `/././.` (returns 1). Resolve `/nonexistent` (returns -ENOENT).\n\n### Phase 4: Mutation (5 Hours)\nImplement `dir_add_entry` and `dir_remove_entry`. Focus on the `rec_len` manipulation.\n**Checkpoint:** Add 3 files. Remove the middle file. Verify the first file's `rec_len` now covers the gap where the middle file was.\n\n### Phase 5: POSIX Operations (4 Hours)\nImplement `fs_mkdir`, `fs_rmdir`, `fs_link`.\n**Checkpoint:** `mkdir(\"/test\")`, verify `root->i_nlinks == 3`. `rmdir(\"/test\")`, verify `root->i_nlinks == 2`.\n\n---\n\n## 8. Test Specification\n\n### 8.1. Hierarchical Persistence\n1. `fs_mkdir(root, \"a\")`.\n2. `fs_mkdir(a_ino, \"b\")`.\n3. `path_resolve(\"/a/b\")`.\n4. **Assertion:** Returns `b_ino`. `b_ino->i_blocks[0]` contains `..` pointing to `a_ino`.\n\n### 8.2. Empty Directory Constraint\n1. `fs_mkdir(root, \"dir\")`.\n2. `fs_create_file(dir_ino, \"file\")`.\n3. `fs_rmdir(root, \"dir\")`.\n4. **Assertion:** Returns `-ENOTEMPTY`. File still exists.\n\n### 8.3. Hard Link Integrity\n1. `fs_link(file_ino, root, \"alias\")`.\n2. **Assertion:** `file_ino->i_nlinks == 2`.\n3. `fs_unlink(root, \"file\")`.\n4. **Assertion:** `file_ino->i_nlinks == 1`. Inode is NOT freed. Data is still readable via \"alias\".\n\n---\n\n## 9. Performance Targets\n\n| Operation | Target | Measurement |\n| :--- | :--- | :--- |\n| Name Lookup | O(N) entries | Benchmark 1000 entries in one block. |\n| Path Resolve | O(M) components | Resolve 10-level deep path. |\n| Add Entry | < 2 Disk I/Os | Usually 1 read (find space) + 1 write. |\n| Memory Overhead | 8B per entry | Excludes name string. |\n\n---\n\n### \n![Directory Entry On-Disk Format â€” Byte Layout and rec_len Chain](./diagrams/tdd-diag-15.svg)\n\n**On-Disk Directory Block Layout**\n```text\nBlock Offset: 0\n[ Inode: 1 | RecLen: 12 | NameLen: 1 | Type: 2 | Name: \".\"  | Pad: 3 ]\nBlock Offset: 12\n[ Inode: 1 | RecLen: 12 | NameLen: 2 | Type: 2 | Name: \"..\" | Pad: 2 ]\nBlock Offset: 24\n[ Inode: 5 | RecLen: 4072| NameLen: 4 | Type: 1 | Name: \"file\"| Pad: 0 ]\n                                ^\n                                |--- RecLen of last entry fills the block\n```\n\n### \n![Path Resolution â€” Walking /home/user/file.txt Step by Step](./diagrams/tdd-diag-16.svg)\n\n**Directory Entry Removal (Merging)**\n```text\nBEFORE:\n[ Entry A (RecLen: 12) ] [ Entry B (RecLen: 16) ] [ Entry C (RecLen: 4068) ]\n\nAFTER REMOVE(B):\n[ Entry A (RecLen: 28) ]                          [ Entry C (RecLen: 4068) ]\n           ^------- A's RecLen increased (12 + 16)\n```\n\n### \n![Directory as Inode Graph â€” Tree Structure and Link Counts](./diagrams/tdd-diag-17.svg)\n\n**Path Resolution Flow**\n```text\nPath: \"/home/user/doc.txt\"\n\n1. Lookup \"home\" in Inode 1 (Root) -> Inode 10\n2. Lookup \"user\" in Inode 10       -> Inode 45\n3. Lookup \"doc.txt\" in Inode 45    -> Inode 102\n4. Return 102\n```\n\n<!-- END_TDD_MOD -->\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: filesystem-m4 -->\n# Module Technical Design Specification: File Read/Write Operations (filesystem-m4)\n\n## 1. Module Charter\n\nThe **File Read/Write Operations** module implements the data plane of the filesystem. It bridges the gap between byte-addressable application requests and the block-addressable hardware reality. This module is responsible for the life cycle of regular file data, including creation, sequential and random access, and resizing.\n\n**Scope:**\n- **Creation:** Orchestrating inode allocation and directory entry insertion for new files.\n- **Read Logic:** Implementing byte-to-block mapping, handling sparse \"holes\" via zero-filling, and enforcing End-Of-File (EOF) boundaries.\n- **Write Logic:** Implementing the Read-Modify-Write (RMW) cycle for partial-block updates and on-demand block allocation for file growth.\n- **Truncation:** Reclaiming disk space during shrink operations (including recursive indirect block cleanup) and implementing \"thin\" extension via sparse holes.\n- **Metadata Sync:** Ensuring `i_size`, `i_atime`, `i_mtime`, and `i_ctime` are updated according to POSIX semantics.\n\n**Out of Scope:**\n- FUSE kernel-to-user relay (Milestone 5).\n- Atomic crash consistency via journaling (Milestone 6).\n- Permission/ACL enforcement (deferred to the VFS layer).\n\n**Invariants:**\n- `fs_read` never returns more than `inode.i_size - offset` bytes.\n- A sparse hole (disk block pointer = 0) must return exactly zeroed bytes without performing disk I/O.\n- `fs_write` at an offset > `inode.i_size` automatically creates a sparse hole between the old EOF and the new write start.\n- `fs_truncate` (shrink) must zero-fill the byte range from `new_size` to the next 4KB boundary in the last retained block to prevent data leakage.\n\n---\n\n## 2. File Structure\n\nImplementation proceeds from basic creation to complex mutation:\n\n1. `file_ops.h`: Function prototypes and offset arithmetic macros.\n2. `file_create.c`: High-level file creation logic.\n3. `file_read.c`: The read path and sparse hole handling.\n4. `file_write.c`: The write path, RMW logic, and allocation-on-demand.\n5. `file_truncate.c`: Shrink/Extend logic and recursive block freeing.\n6. `test_m4.c`: Comprehensive I/O suite (Round-trip verification, sparse tests, 4GB boundary tests).\n\n---\n\n## 3. Complete Data Model\n\nThis module relies on the `inode_t` structure defined in Milestone 2. Every operation navigates this structure's block pointer tree.\n\n### 3.1. Inode Metadata (inode_t) Reference Table\n\n| Offset | Field | Type | Description |\n| :--- | :--- | :--- | :--- |\n| 0x00 | `i_mode` | `uint16_t` | Must have `S_IFREG` (0100000) for these ops. |\n| 0x04 | `i_size` | `uint32_t` | Logical size. Clamps `fs_read`; updated by `fs_write`. |\n| 0x18 | `i_blocks[12]` | `uint32_t[12]` | Direct pointers for offsets 0 to 49,151. |\n| 0x48 | `i_single_ind` | `uint32_t` | Pointer to 1024 addresses (49,152 to 4,243,455). |\n| 0x4C | `i_double_ind` | `uint32_t` | Pointer to 1024^2 addresses (up to ~4.29GB). |\n\n### 3.2. Internal Operation Context\nOperations decompose a requested byte range `[offset, offset + length)` into a sequence of block-sized \"chunks\".\n\n| Variable | Definition | Formula |\n| :--- | :--- | :--- |\n| `block_index` | 0-based logical block | `offset / 4096` |\n| `block_off` | Starting byte in block | `offset % 4096` |\n| `chunk` | Bytes to process in this block | `min(4096 - block_off, remaining_len)` |\n\n---\n\n## 4. Interface Contracts\n\n### 4.1. File Lifecycle\n```c\n/**\n * Creates a regular file.\n * @param parent_ino Inode of the directory to hold the file.\n * @param name Filename (max 255 chars).\n * @param mode Permissions (e.g., 0644).\n * @return New 1-based inode number, or negative errno (EEXIST, ENOSPC).\n */\nint fs_create_file(int fd, superblock_t *sb, uint32_t parent_ino, \n                   const char *name, uint16_t mode, uint16_t uid, uint16_t gid);\n```\n\n### 4.2. The Data Plane\n```c\n/**\n * Reads data from a regular file.\n * @param buf Destination buffer.\n * @return Actual bytes read. Returns 0 if offset >= i_size.\n * @note Clamps length to i_size. Zero-fills sparse holes.\n */\nssize_t fs_read(int fd, superblock_t *sb, uint32_t ino, \n                uint64_t offset, void *buf, size_t length);\n\n/**\n * Writes data to a regular file.\n * @return Bytes written (always 'length' on success).\n * @note Triggers RMW for partial blocks. Allocates blocks on growth.\n */\nssize_t fs_write(int fd, superblock_t *sb, uint32_t ino, \n                 uint64_t offset, const void *buf, size_t length);\n\n/**\n * Convenience wrapper for writing at current i_size.\n */\nssize_t fs_append(int fd, superblock_t *sb, uint32_t ino, \n                  const void *buf, size_t length);\n```\n\n### 4.3. Resizing\n```c\n/**\n * Resizes a file to new_size.\n * @note Shrink: frees blocks > new_size and zeroes the last block's tail.\n * @note Extend: updates i_size, creating a sparse hole.\n */\nint fs_truncate(int fd, superblock_t *sb, uint32_t ino, uint64_t new_size);\n```\n\n---\n\n## 5. Algorithm Specification\n\n### 5.1. `fs_read`: The Zero-Fill Loop\n1.  **Read Inode:** Load `inode_t` for `ino`.\n2.  **Validate:** Return `-EINVAL` if not `S_IFREG`.\n3.  **Clamp:** If `offset >= i_size`, return `0`. If `offset + length > i_size`, set `length = i_size - offset`.\n4.  **Loop:** While `remaining > 0`:\n    - Calculate `block_index`, `block_off`, and `chunk`.\n    - Call `inode_get_block(block_index * 4096)` (from M2).\n    - **Case Hole (`disk_block == 0`):** `memset(buf + progress, 0, chunk)`. Skip Disk I/O.\n    - **Case Data (`disk_block != 0`):** `read_block(disk_block, temp_buf)`. `memcpy(buf + progress, temp_buf + block_off, chunk)`.\n    - Update `progress`, `remaining`, `offset`.\n5.  **Metadata:** Update `i_atime = now()`. Write Inode.\n\n### 5.2. `fs_write`: The Read-Modify-Write (RMW) Engine\n1.  **Read Inode:** Load `inode_t`.\n2.  **Capacity Check:** If `offset + length > 4GB`, return `-EFBIG`.\n3.  **Loop:** While `remaining > 0`:\n    - Calculate `block_index`, `block_off`, and `chunk`.\n    - Determine if RMW is needed: `bool partial = (block_off != 0 || chunk < 4096)`.\n    - `inode_get_block` â†’ `disk_block`.\n    - **Case New Block (`disk_block == 0`):**\n        - `disk_block = alloc_data_block()`.\n        - `inode_set_block(..., disk_block)`.\n        - `memset(temp_buf, 0, 4096)`. (Ensures hole-alignment).\n    - **Case Existing Block (`disk_block != 0`):**\n        - If `partial`, `read_block(disk_block, temp_buf)`.\n    - **Modify:** `memcpy(temp_buf + block_off, buf + progress, chunk)`.\n    - **Write:** `write_block(disk_block, temp_buf)`.\n    - Update `progress`, `remaining`, `offset`.\n4.  **Metadata:** If `offset > i_size`, `i_size = offset`. Set `i_mtime = i_ctime = now()`. Write Inode.\n\n### 5.3. `fs_truncate`: Shrink with Data Leak Protection\n1.  **Read Inode.**\n2.  **Extend Case (`new_size > i_size`):** Update `i_size`. Write Inode. Done.\n3.  **Shrink Case (`new_size < i_size`):**\n    - **Zero Tail:** Find the block index containing `new_size`. If `new_size % 4096 != 0`:\n        - `inode_get_block` â†’ `disk_block`.\n        - If `disk_block != 0`, `read_block`, `memset` bytes from `new_size % 4096` to 4095, `write_block`.\n    - **Free Blocks:** Iterate `bi` from `(new_size + 4095) / 4096` to `(old_size + 4095) / 4096`.\n        - Call `inode_get_block(bi * 4096)`.\n        - If `disk_block != 0`, `free_data_block(disk_block)`.\n        - `inode_set_block(..., 0)`. (Null the pointer).\n    - **Cleanup:** Call `truncate_free_indirect_if_empty` (M2 logic) to reclaim indirect pointer blocks.\n4.  **Metadata:** `i_size = new_size`, `i_mtime = i_ctime = now()`.\n\n---\n\n## 6. Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n| :--- | :--- | :--- | :--- |\n| `ENOSPC` | `fs_write` | Stop write; return partial bytes written or error. | Yes |\n| `EFBIG` | `fs_write` | Reject write before allocation. | Yes |\n| `EINVAL` | `fs_read` | Ensure inode is regular file (`S_ISREG`). | Yes |\n| `EIO` | `read_block` | Return I/O error; filesystem may be inconsistent. | Yes |\n| Data Leak | `fs_truncate` | Zeroing the tail of the partial block prevents reading old data. | No (Internal) |\n\n---\n\n## 7. Implementation Sequence with Checkpoints\n\n### Phase 1: Creation & Math (2 Hours)\nImplement `fs_create_file`. Use M2 `alloc_inode` and M3 `dir_add_entry`. Implement internal offset-to-block helpers.\n**Checkpoint:** `mkfs` a disk, call `fs_create_file(\"/test.txt\")`. Verify `ls` shows the file.\n\n### Phase 2: The Read Path (3 Hours)\nImplement `fs_read`. Ensure it handles offsets correctly. Add `memset(0)` logic for sparse holes.\n**Checkpoint:** Manually set a block pointer in an inode to 0. Read 4KB at that offset. Verify buffer is all zeros and `read_block` was never called.\n\n### Phase 3: The Write Path (4 Hours)\nImplement `fs_write`. Implement the RMW cycle logic.\n**Checkpoint:** Write \"Hello\" at offset 0. Read back. Write \"World\" at offset 6. Read back. Verify \"Hello World\" is present (proves RMW preserved the space between them).\n\n### Phase 4: Truncate & Append (4 Hours)\nImplement `fs_truncate` (shrink/extend) and `fs_append`.\n**Checkpoint:** Create 10MB file. Truncate to 1MB. Verify `s_free_blocks` increases by ~2304 blocks.\n\n---\n\n## 8. Test Specification\n\n### 8.1. Partial Block RMW Verification\n- **Test:** Write \"A\" at offset 4095 (end of block 0) and \"B\" at 4096 (start of block 1).\n- **Assertion:** `fs_read` returns \"AB\" across the 4KB boundary. Block 0 and Block 1 must have been allocated.\n\n### 8.2. Sparse Hole Expansion\n- **Test:** Write \"X\" at offset 0. Write \"Y\" at offset 1,000,000.\n- **Assertion:** `fs_read` at offset 500,000 returns 0s. `i_size` is 1,000,001. `s_free_blocks` indicates only 2 data blocks (plus indirects) were used.\n\n### 8.3. Data Leakage (Security)\n- **Test:** Write 4KB of `0xFF` to a file. Truncate to 10 bytes. Truncate back to 4KB (Extend).\n- **Assertion:** Reading bytes 11â€“4095 returns `0x00`, NOT `0xFF`.\n\n---\n\n## 9. Performance Targets\n\n| Operation | Target | Measurement |\n| :--- | :--- | :--- |\n| Sequential Read | > 200 MB/s | DD from mount to /dev/null |\n| Aligned Write | 1 Disk I/O / 4KB | No `read_block` calls in write path |\n| Random 1-byte Write| 2 Disk I/Os | 1 Read + 1 Write (RMW) |\n| Sparse Read | < 50ns / block | `clock_gettime` for 4KB hole |\n\n---\n\n## 10. Hardware Soul (Cache and Alignment)\n\n### 10.1. Write Amplification Analysis\nEvery write that is not 4096-byte aligned and 4096-byte sized triggers a Read-Modify-Write.\n- **Example:** `write(fd, \"a\", 1)`\n- **Cost:**\n    1. `read_block(n)`: 4096 bytes into RAM.\n    2. `memcpy`: 1 byte.\n    3. `write_block(n)`: 4096 bytes to Disk.\n- **Amplification:** 8192 / 1 = 8192x.\n- **Mitigation:** Applications should buffer I/O to 4KB boundaries (e.g., `setvbuf` in C).\n\n### 10.2. TLB and Page Alignment\nOur `block_buf` is 4096 bytes. To optimize performance, the buffer passed to `read(2)/write(2)` of the disk image should be **page-aligned** (using `posix_memalign`). This ensures that the kernel's Direct Memory Access (DMA) can map the buffer directly to physical disk sectors without an intermediate copy (Zero-Copy I/O).\n\n---\n\n### \n![fs_write Read-Modify-Write Cycle â€” Before/After Block State](./diagrams/tdd-diag-21.svg)\n\n**Read-Modify-Write (RMW) Decision Flow**\n```text\nWrite Request (Offset, Length)\n|\n|-- Is Offset % 4096 == 0 AND Length >= 4096?\n|   |-- YES: Full Block Write\n|   |   |-- No existing block? Allocate & Write.\n|   |   |-- Existing block? Overwrite directly.\n|   |\n|   |-- NO: Partial Block Write (RMW)\n|       |-- No existing block? Allocate & Zero-Fill.\n|       |-- Existing block? READ block into buffer.\n|       |-- MODIFY buffer with user data.\n|       |-- WRITE buffer back to disk.\n```\n\n### \n![fs_read(offset=6000, length=5000) â€” Cross-Block Data Walk](./diagrams/tdd-diag-22.svg)\n\n**File Offset Arithmetic**\n```text\nFile Offset: 10,000\nBlock Size:  4,096\n\nBlock Index: 10,000 / 4,096 = 2  (0-indexed)\nBlock Off:   10,000 % 4,096 = 1,808\nRemaining:   10,000 to End\nChunk:       min(4,096 - 1,808, total_len) = 2,288\n```\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: filesystem-m5 -->\n# Module Technical Design Specification: FUSE Integration (filesystem-m5)\n\n## 1. Module Charter\n\nThe **FUSE Integration** module is the definitive bridge between the internal block-and-inode machinery and the Linux Virtual Filesystem (VFS). It provides the high-level interface that allows the operating system to treat a raw disk image as a mountable directory. \n\n**Scope:**\n- **Translation:** Converting VFS path-based requests into internal inode-based operations using the Milestone 3 resolution engine.\n- **State Management:** Maintaining the global filesystem context (`fs_ctx_t`), including the disk image file descriptor, the in-memory superblock, and a coarse-grained serialization lock.\n- **Resource Mapping:** Mapping internal `inode_t` fields to POSIX `struct stat` and `struct statvfs` records for system-wide compatibility.\n- **Lifecycle:** Orchestrating the mount-time initialization (including recovery hooks) and the unmount-time cleanup (ensuring metadata and data durability via `fsync`).\n- **Optimization:** Leveraging FUSE entry and attribute timeouts to mitigate the performance penalties of path resolution over the FUSE kernel-user boundary.\n\n**Out of Scope:**\n- In-kernel filesystem logic (this is strictly a userspace daemon).\n- Low-level FUSE protocol handling (delegated to `libfuse3`).\n- Fine-grained locking or lock-free data structures (single global mutex).\n\n**Invariants:**\n- Every callback must acquire the global `fs_lock` before accessing the `fs_ctx_t` or calling internal FS functions.\n- The `fi->fh` (file handle) must be populated with the inode number during `open`/`create` to bypass path resolution in `read`/`write`.\n- All callbacks must return negative errno values on failure (e.g., `-ENOENT`) as per the FUSE specification.\n- No callback may return to the kernel without releasing the global lock, regardless of the error path.\n\n---\n\n## 2. File Structure\n\nImplementation follows a strict integration sequence, moving from global state to specific VFS operations:\n\n1.  `myfs_main.c`: Entry point, argument parsing, and `fuse_main` invocation.\n2.  `fuse_context.h`: Definition of `FsCtx` and global lock macros.\n3.  `fuse_bridge.c`: Conversion logic (`inode_to_stat`, `path_to_inode`).\n4.  `fuse_ops_meta.c`: Implementation of `getattr`, `statfs`, `chmod`, `utimens`.\n5.  `fuse_ops_dir.c`: Implementation of `readdir`, `mkdir`, `rmdir`, `rename`, `unlink`.\n6.  `fuse_ops_file.c`: Implementation of `open`, `create`, `read`, `write`, `truncate`, `release`.\n7.  `Makefile`: Integration with `pkg-config --cflags --libs fuse3`.\n\n---\n\n## 3. Complete Data Model\n\n### 3.1. Global Filesystem Context (FsCtx)\nThis structure resides in the heap/global segment of the FUSE daemon. It is the single source of truth for the mounted instance.\n\n```c\ntypedef struct {\n    int fd;                    // 0x00: Disk image file descriptor\n    superblock_t sb;           // 0x04: In-memory copy of the superblock (4096 bytes)\n    pthread_mutex_t lock;      // 0x1004: Global coarse-grained lock (usually 40 bytes)\n    uint32_t mount_flags;      // 0x102C: Internal flags (direct_io, etc.)\n    char image_path[256];      // 0x1030: Path to the .img file for persistence\n} FsCtx;                       // Total Size: ~4400 bytes\n```\n\n**Hardware Soul (Cache Line Analysis):**\n- **Superblock Separation:** The `sb` field (4KB) acts as a massive buffer that physically separates the `fd` and the `lock`. On modern CPUs with 64B cache lines, this ensures that frequent lock acquisitions (which dirty the cache line containing the mutex) do not cause false-sharing with the `fd` or other configuration flags.\n- **Alignment:** `FsCtx` should be page-aligned (`posix_memalign`) to ensure the `sb` field is aligned with the host's page cache, facilitating zero-copy reads from the image file into the context.\n\n### 3.2. FUSE File Handle (fi->fh)\nWe utilize the 64-bit `fh` field in `struct fuse_file_info` to cache the inode number. This is critical for performance.\n\n| Field | Value | Why? |\n| :--- | :--- | :--- |\n| `fi->fh` | `uint64_t(inode_num)` | Avoids calling `path_resolve` in every `read()` and `write()` call. |\n| `fi->direct_io` | `1` | Bypasses the FUSE kernel page cache. Ensures correctness for the single-node implementation. |\n| `fi->keep_cache` | `0` | Discard host-side page cache on close to prevent stale data. |\n\n---\n\n## 4. Interface Contracts\n\n### 4.1. The Path-to-Inode Bridge\n```c\n/**\n * Resolves a path to an inode number and fetches the inode.\n * @param path Absolute path from FUSE.\n * @param out_ino Target inode number.\n * @param out_inode Pointer to a stack-allocated inode_t to fill.\n * @return 0 on success, -ENOENT or -EIO on failure.\n * @note MUST be called while holding g_fs.lock.\n */\nstatic int bridge_path_to_inode(const char *path, uint32_t *out_ino, inode_t *out_inode);\n\n/**\n * Maps inode_t fields to struct stat.\n * @param st Pointer to the FUSE-provided stat structure.\n */\nstatic void bridge_inode_to_stat(uint32_t ino_num, const inode_t *inode, struct stat *st);\n```\n\n### 4.2. Core FUSE Callbacks (The VFS Contract)\n```c\n// Metadata\nstatic int myfs_getattr(const char *path, struct stat *st, struct fuse_file_info *fi);\nstatic int myfs_statfs(const char *path, struct statvfs *stbuf);\n\n// Directories\nstatic int myfs_readdir(const char *path, void *buf, fuse_fill_dir_t filler, \n                        off_t offset, struct fuse_file_info *fi, enum fuse_readdir_flags flags);\nstatic int myfs_mkdir(const char *path, mode_t mode);\n\n// Files\nstatic int myfs_create(const char *path, mode_t mode, struct fuse_file_info *fi);\nstatic int myfs_read(const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *fi);\nstatic int myfs_write(const char *path, const char *buf, size_t size, off_t offset, struct fuse_file_info *fi);\nstatic int myfs_truncate(const char *path, off_t size, struct fuse_file_info *fi);\n```\n\n---\n\n## 5. Algorithm Specification\n\n### 5.1. The `getattr` Hot-Path\n`getattr` is called by the kernel for almost every operation. \n\n1.  **Lock:** `pthread_mutex_lock(&g_fs.lock)`.\n2.  **Resolve:** Call `path_resolve(path)`.\n3.  **Handle Error:** If `-ENOENT`, unlock and return `-ENOENT` immediately.\n4.  **Read:** Call `read_inode` for the resolved inode number.\n5.  **Convert:** Call `bridge_inode_to_stat`.\n    - `st->st_blocks` = `(inode->size + 511) / 512` (POSIX expects 512B blocks).\n    - `st->st_blksize` = `4096`.\n6.  **Unlock:** `pthread_mutex_unlock(&g_fs.lock)`.\n7.  **Return:** `0`.\n\n### 5.2. `readdir` Filler Loop\n1.  Resolve `path` to `dir_ino`.\n2.  Read `dir_ino` and verify `S_ISDIR`.\n3.  Define a local context for the readdir callback.\n4.  Invoke `dir_readdir(dir_ino, callback_fn)`.\n5.  Inside `callback_fn`:\n    - Call `filler(buf, name, &st, 0, 0)`.\n    - If `filler` returns non-zero (buffer full), abort the scan and return `0` (FUSE will resume).\n\n### 5.3. Atomic Rename\n1.  Identify `src_parent_path` and `src_name` from `old_path`.\n2.  Identify `dst_parent_path` and `dst_name` from `new_path`.\n3.  **Locking:** Acquire `g_fs.lock`.\n4.  **Validation:**\n    - Resolve `src_ino`.\n    - If `new_path` exists, resolve `dst_ino` and check if `S_ISDIR` match.\n    - If `dst_ino` is a directory, verify it is empty.\n5.  **Mutation:**\n    - `dir_add_entry(dst_parent, dst_name, src_ino)`.\n    - `dir_remove_entry(src_parent, src_name)`.\n    - Update `ctime` for `src_ino` and both parents.\n6.  **Unlock.**\n\n---\n\n## 6. Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n| :--- | :--- | :--- | :--- |\n| `ENOENT` | `path_resolve` | Standard return to VFS; shell prints \"No such file\". | Yes |\n| `ENOTEMPTY`| `fs_rmdir` | Directory has entries; reject removal. | Yes |\n| `EBADF` | `myfs_read` | `fi->fh` is 0 or invalid. | Yes |\n| `EACCES` | FUSE Kernel | Kernel checks `st_mode` returned by `getattr`. | Yes |\n| `ENOMEM` | `filler` | FUSE buffer is full; current readdir batch complete. | No |\n| `EIO` | `read_block` | Disk image corrupted or unreadable. | Yes |\n\n---\n\n## 7. Implementation Sequence with Checkpoints\n\n### Phase 1: The Context and Mount (2 Hours)\nImplement `main` and the FUSE `init`/`destroy` callbacks.\n- **init:** Open the disk image, read the superblock into `g_fs.sb`, initialize the mutex.\n- **destroy:** `fsync(g_fs.fd)`, write the superblock back to block 0, close `fd`.\n**Checkpoint:** `./myfs disk.img /mnt/test` runs and waits. `mount | grep myfs` shows the mount point.\n\n### Phase 2: Metadata and Navigation (3 Hours)\nImplement `bridge_path_to_inode`, `bridge_inode_to_stat`, and `getattr`.\n**Checkpoint:** `ls /mnt/test` does not return \"Permission Denied\" or \"Invalid Argument\" (though it may be empty).\n\n### Phase 3: Directory Contents (3 Hours)\nImplement `readdir` (using Milestone 3 primitives).\n**Checkpoint:** `ls -la /mnt/test` correctly displays `.` and `..` with correct inode numbers (Inode 1).\n\n### Phase 4: File Data (4 Hours)\nImplement `create`, `open`, `read`, and `write`.\n- **Crucial:** In `open`, set `fi->fh = ino_num`.\n- **Crucial:** In `read`, use `(uint32_t)fi->fh`.\n**Checkpoint:** `echo \"hello\" > /mnt/test/file.txt` followed by `cat /mnt/test/file.txt` works.\n\n### Phase 5: The Full POSIX Set (4 Hours)\nImplement `mkdir`, `rmdir`, `unlink`, `truncate`, `rename`.\n**Checkpoint:** `mkdir`, `mv`, `rm` all behave exactly like a native ext4 directory.\n\n---\n\n## 8. Test Specification\n\n### 8.1. Round-Trip Persistence\n1. Mount `disk.img`.\n2. `mkdir /mnt/test/data`.\n3. `echo \"bytes\" > /mnt/test/data/file.bin`.\n4. Unmount (`fusermount3 -u`).\n5. Remount.\n6. **Assertion:** `cat /mnt/test/data/file.bin` returns \"bytes\".\n\n### 8.2. Concurrent Access (Stress)\n1. In terminal A: `while true; do ls -R /mnt/test; done`.\n2. In terminal B: `while true; do dd if=/dev/urandom of=/mnt/test/stress bs=4k count=10; done`.\n3. **Assertion:** No kernel panics, no \"Transport endpoint not connected\", no deadlocks.\n\n### 8.3. Sparse File Verification via Tools\n1. `truncate -s 1G /mnt/test/huge`.\n2. `ls -l /mnt/test/huge` shows 1GB.\n3. `du -h /mnt/test/huge` shows 0.\n4. **Assertion:** Filesystem correctly reports logical vs physical size via `getattr`.\n\n---\n\n## 9. Performance Targets\n\n| Operation | Target | Measurement |\n| :--- | :--- | :--- |\n| `getattr` Latency | < 5ms (Cold) | `time ls /mnt/test` |\n| `read` Throughput | > 80% of Raw Image Read | `dd` from mount vs `dd` from image |\n| Context Switch | < 10Î¼s per call | `strace -c` total time / call count |\n| Unmount Time | < 1s | `time fusermount3 -u` |\n\n---\n\n## 10. Concurrency Specification (Global Lock)\n\nThe global mutex implementation follows a \"Leaf-Only Locking\" strategy:\n\n1.  **Acquisition:** Every callback acquires `g_fs.lock` at the first line of execution.\n2.  **Recursion:** Internal functions (like `path_resolve`) **MUST NOT** acquire the lock themselves, as the mutex is non-recursive.\n3.  **I/O:** The lock is held during `read_block/write_block`. While this serializes I/O, it ensures that the Superblock and Bitmaps remain consistent across threads without complex fine-grained coordination.\n4.  **Release:** The lock is released only at the `return` statement of the FUSE callback.\n\n---\n\n### \n![FUSE Architecture â€” Kernel/Userspace Data Flow](./diagrams/tdd-diag-27.svg)\n\n**FUSE to Internal FS Call Flow**\n```text\nApplication: open(\"/mnt/myfs/doc.txt\")\n      |\n      V (System Call)\nLinux Kernel VFS\n      |\n      V (FUSE Kernel Module)\n/dev/fuse <--- (Writes Request: OPEN, path=\"/doc.txt\")\n      |\n      V (Context Switch)\nlibfuse (Reads /dev/fuse)\n      |\n      V (Calls myfs_open)\n+---------------------------------------+\n| myfs_open(\"/doc.txt\")                 |\n| 1. lock(g_fs.lock)                    |\n| 2. ino = path_resolve(\"/doc.txt\")     |\n| 3. fi->fh = ino                       |\n| 4. unlock(g_fs.lock)                  |\n| 5. return 0                           |\n+---------------------------------------+\n```\n\n### \n![FUSE Callbacks â†’ Internal Operations Mapping Table](./diagrams/tdd-diag-28.svg)\n\n**Stat Bridge Mapping**\n```text\ninode_t (Internal)              struct stat (POSIX)\n+-----------------+             +-------------------+\n| i_mode          | ----------> | st_mode           |\n| i_nlinks        | ----------> | st_nlink          |\n| i_uid / i_gid   | ----------> | st_uid / st_gid   |\n| i_size          | ----------> | st_size           |\n| i_atime         | ----------> | st_atim.tv_sec    |\n| i_mtime         | ----------> | st_mtim.tv_sec    |\n| (ino_num)       | ----------> | st_ino            |\n+-----------------+             +-------------------+\n```\n\n\n<!-- END_TDD_MOD -->\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: filesystem-m6 -->\n# Module Technical Design Specification: Write-Ahead Journaling and Crash Recovery (filesystem-m6)\n\n## 1. Module Charter\n\nThe **Write-Ahead Journaling and Crash Recovery** module is the final and most critical layer of the filesystem, providing a mathematical guarantee of metadata consistency in the event of power failure or system crash. It implements a sequential, circular write-ahead log (WAL) that captures intended metadata changes before they are applied to the primary on-disk structures.\n\n**Scope:**\n- **Atomicity:** Wrapping multi-block metadata updates (e.g., `mkdir` which touches a bitmap, two inodes, and a directory block) into single, atomic transactions.\n- **Durability:** Implementing the double-`fsync` protocol to ensure journal entries and commit records are persisted to physical media in the correct order.\n- **Recovery:** Automated scanning and replaying of the journal at mount-time to restore the filesystem to its last known consistent state.\n- **Checkpointing:** Managing the circular buffer life cycle, including flushing journaled changes to their final locations and advancing the journal head.\n- **Integration:** Converting all existing mutation logic (from M2, M3, and M4) to use a transaction-based API rather than direct block writes.\n\n**Out of Scope:**\n- **Data Journaling:** Only metadata (bitmaps, inodes, directory blocks) is journaled. File data blocks are written using \"ordered\" mode (data-first, then metadata-journal).\n- **Distributed Consensus:** This is a single-node consistency mechanism.\n- **Checksum Offloading:** Checksums are computed in software, not via hardware CRC32 instructions (for portability).\n\n**Invariants:**\n- No metadata block may be written to its permanent location until its corresponding transaction's **Commit Record** is durable on disk.\n- Journal replay must be **idempotent**: replaying the same transaction multiple times must produce the same result as a single replay.\n- The `j_head` must never be overtaken by `j_tail`; the filesystem must block and checkpoint if the journal is full.\n- All journaled blocks must be exactly 4096 bytes and aligned to 4KB boundaries.\n\n---\n\n## 2. File Structure\n\nImplementation follows a transition from data definitions to transaction logic, followed by recovery and integration.\n\n1.  `journal_types.h`: On-disk structure definitions for the journal superblock, descriptors, and commit blocks.\n2.  `journal_io.c`: Low-level journal region addressing and circular buffer math (`journal_abs_block`).\n3.  `txn.h / txn.c`: The Transaction API (`txn_begin`, `txn_journal_block`, `txn_commit`).\n4.  `recovery.c`: The crash recovery engine (`journal_recover`) and idempotency checks.\n5.  `checkpoint.c`: Journal clearing logic (`journal_checkpoint`) and background flush coordination.\n6.  `journal_wrappers.c`: Journaled versions of `write_inode`, `bitmap_set`, etc.\n7.  `test_m6_crash.c`: A simulation suite that kills the process mid-transaction to verify recovery.\n\n---\n\n## 3. Complete Data Model\n\n### 3.1. Journal Superblock (`journal_super_t`)\nResides at absolute block `sb->s_journal_start`. It tracks the live region of the circular log.\n\n| Offset | Field | Type | Description |\n| :--- | :--- | :--- | :--- |\n| 0x00 | `j_magic` | `uint32_t` | `0x4A4F5552` (\"JOUR\"). |\n| 0x04 | `j_block_type` | `uint32_t` | Always `0x01` (Superblock). |\n| 0x08 | `j_sequence` | `uint32_t` | Monotonic ID of the next transaction to be written. |\n| 0x0C | `j_head` | `uint32_t` | Index of the oldest unapplied transaction in the journal. |\n| 0x10 | `j_tail` | `uint32_t` | Index where the next transaction will be written. |\n| 0x14 | `j_total_blocks` | `uint32_t` | Number of usable blocks in the journal (usually `s_journal_len - 1`). |\n| 0x18 | `j_reserved` | `uint8_t[4072]`| Padding to 4096 bytes. |\n\n### 3.2. Descriptor Block (`journal_desc_t`)\nDescribes the \"payload\" of a transaction. It lists which filesystem blocks are being updated.\n\n| Offset | Field | Type | Description |\n| :--- | :--- | :--- | :--- |\n| 0x00 | `j_magic` | `uint32_t` | `0x4A4F5552`. |\n| 0x04 | `j_block_type` | `uint32_t` | Always `0x02` (Descriptor). |\n| 0x08 | `j_sequence` | `uint32_t` | Transaction sequence ID. |\n| 0x0C | `j_nr_blocks` | `uint32_t` | Number of data blocks immediately following this descriptor. |\n| 0x10 | `j_block_map[500]` | `uint64_t[500]` | The target block numbers in the primary FS for each journaled block. |\n\n### 3.3. Commit Block (`journal_commit_t`)\nThe \"Atomic Sentinel\". Its presence on disk signifies a successful transaction.\n\n| Offset | Field | Type | Description |\n| :--- | :--- | :--- | :--- |\n| 0x00 | `j_magic` | `uint32_t` | `0x4A4F5552`. |\n| 0x04 | `j_block_type` | `uint32_t` | Always `0x03` (Commit). |\n| 0x08 | `j_sequence` | `uint32_t` | Must match the corresponding Descriptor sequence. |\n| 0x0C | `j_checksum` | `uint32_t` | Cumulative sum of all bytes in the transaction's data blocks. |\n| 0x10 | `j_reserved` | `uint8_t[4080]`| Padding to 4096 bytes. |\n\n### 3.4. In-Memory Transaction (`txn_t`)\nAccumulates changes before flushing.\n\n```c\n#define MAX_TXN_BLOCKS 64\n\ntypedef struct {\n    uint32_t sequence;                // Sequence number for this txn\n    uint32_t nr_blocks;              // Current count of dirty metadata blocks\n    uint32_t targets[MAX_TXN_BLOCKS]; // Original FS block numbers\n    uint8_t  data[MAX_TXN_BLOCKS][4096]; // New content for these blocks\n} txn_t;\n```\n\n---\n\n## 4. Interface Contracts\n\n### 4.1. Transaction Life Cycle\n```c\n/**\n * Starts a new metadata transaction.\n * @param txn Pointer to stack-allocated txn_t.\n */\nvoid txn_begin(txn_t *txn);\n\n/**\n * Stages a metadata block for journaling. \n * If the block is already in the txn, it is overwritten (deduplication).\n * @return 0 on success, -ENOSPC if txn is full (64 blocks).\n */\nint txn_journal_block(txn_t *txn, uint32_t fs_block_num, const void *data);\n\n/**\n * Executes the 8-step commit protocol.\n * @return 0 on success. If returns < 0, the FS must remain in its PRE-txn state.\n */\nint txn_commit(txn_t *txn);\n```\n\n### 4.2. Recovery & Maintenance\n```c\n/**\n * Scans the journal and replays all committed transactions.\n * MUST be called before FUSE starts.\n */\nint journal_recover(int fd, superblock_t *sb);\n\n/**\n * Flushes the circular buffer and resets j_head to j_tail.\n */\nint journal_checkpoint(int fd, superblock_t *sb);\n```\n\n---\n\n## 5. Algorithm Specification\n\n### 5.1. The `txn_commit` Protocol (8-Step)\nTo ensure durability, the commit follows a strict ordering of writes and barriers:\n\n1.  **Prepare Descriptor:** Populate `journal_desc_t` with `nr_blocks` and `targets`.\n2.  **Write Descriptor:** `write_block(abs_journal_tail++, desc)`.\n3.  **Write Data:** For each block in `txn->data`, `write_block(abs_journal_tail++, data)`.\n4.  **Barrier 1:** `fsync(fd)`. Ensures journal data is on disk before the commit record exists.\n5.  **Write Commit:** `write_block(abs_journal_tail++, commit_record)`.\n6.  **Barrier 2 (The Point of No Return):** `fsync(fd)`. Transaction is now durable.\n7.  **Apply In-Place:** Iterate through `txn->targets` and write `txn->data` to the primary FS region.\n8.  **Update Super:** Update `g_jsuper.j_tail`, `g_jsuper.j_sequence++`, and `write_block(sb->j_start, jsuper)`.\n\n### 5.2. `journal_recover` (Replay Logic)\nOn mount, the system performs a linear scan of the journal region.\n\n1.  Load `journal_super_t`.\n2.  Set `current_pos = j_head`.\n3.  **While** `current_pos != j_tail`:\n    - Read `desc = read_block(current_pos)`.\n    - If `desc->j_type != JB_TYPE_DESC`, advance `current_pos` and continue.\n    - Locate the **Commit Block** at `current_pos + 1 + desc->j_nr_blocks`.\n    - **If** Commit Block exists AND `commit->j_sequence == desc->j_sequence` AND Checksum matches:\n        - **REPLAY:** For `i` in `0..desc->j_nr_blocks`:\n            - `data = read_block(current_pos + 1 + i)`.\n            - `write_block(desc->j_block_map[i], data)`.\n        - Advance `current_pos` past the commit block.\n    - **Else**:\n        - **DISCARD:** The transaction was not committed. Stop recovery.\n4.  Call `journal_checkpoint` to clear the log.\n\n### 5.3. Ordered Data Write (Metadata-Only Mode)\nWhen a file is written (`fs_write`), we must ensure the data blocks land on disk *before* the metadata (inode size/pointers) that references them is journaled.\n\n1.  **Write File Data:** Use `write_block` directly on the data region blocks.\n2.  **Barrier:** `fsync(fd)`.\n3.  **Start Transaction:** `txn_begin`.\n4.  **Journal Inode:** `txn_journal_block(inode_table_block)`.\n5.  **Commit:** `txn_commit`.\n*Why?* If we crash between 2 and 5, the data is on disk but the inode size is old. No corruption. If we crash between 4 and 5, the data is there, but the transaction isn't committed. Still no corruption.\n\n---\n\n## 6. Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n| :--- | :--- | :--- | :--- |\n| `ENOSPC` (Journal) | `txn_commit` | Invoke `journal_checkpoint` immediately to free space. | No (Delayed) |\n| Checksum Fail | `journal_recover`| Discard the transaction; assume it was a partial write during crash. | No |\n| `EIO` (Barrier 1) | `txn_commit` | Fail the transaction. Data has not been applied in-place. | Yes |\n| `EIO` (Barrier 2) | `txn_commit` | FATAL. The filesystem state is now ambiguous. | Yes |\n| Wrap-around | `journal_abs_block`| `index % j_total_blocks`. Ensure block 0 of region is skipped. | No |\n\n---\n\n## 7. Implementation Sequence with Checkpoints\n\n### Phase 1: Journal Basics (3 Hours)\nDefine all `packed` structures. Implement `journal_abs_block` for circular addressing. Implement `journal_load` and `journal_persist_super`.\n**Checkpoint:** `test_journal_layout` formats a journal and verifies the superblock is written correctly at the start of the journal region.\n\n### Phase 2: The Transaction Engine (5 Hours)\nImplement `txn_begin`, `txn_journal_block` (with deduplication logic), and the 8-step `txn_commit`.\n**Checkpoint:** Call `txn_commit` on a 5-block update. Use `hexdump` on the `.img` file to verify the Descriptor, Data, and Commit blocks appear in sequence in the journal region.\n\n### Phase 3: Recovery & Checkpointing (6 Hours)\nImplement `journal_recover` and `journal_checkpoint`. \n- **Idempotency Test:** Write a transaction, call `journal_recover` twice, and verify the filesystem state is identical after both calls.\n**Checkpoint:** Manually write a committed transaction to the journal but do *not* apply it in-place. Run `journal_recover`. Verify the primary FS blocks now match the journaled data.\n\n### Phase 4: Integration (4 Hours)\nConvert `write_inode`, `bitmap_set`, and directory mutations to use `txn_t`.\n**Checkpoint:** `mkdir(\"/test\")` now results in multiple blocks appearing in the journal before the directory is visible in `ls`.\n\n### Phase 5: The Crash Simulation (4 Hours)\nWrite a test that kills the FUSE process using `SIGKILL` during the middle of `txn_commit` (between step 3 and 5). \n**Checkpoint:** Mount the image again. Verify that the \"interrupted\" operation either fully happened or did not happen at all, but the filesystem remains mountable and `fsck` passes.\n\n---\n\n## 8. Test Specification\n\n### 8.1. Atomic `rename` Verification\n1. `rename(\"/A\", \"/B\")`. \n2. Internally, this involves `dir_remove(A)` and `dir_add(B)`.\n3. Inject a crash between these two internal steps.\n4. **Assertion:** After recovery, either the file is at `/A` OR at `/B`. It must NEVER be at both, and it must NEVER be at neither.\n\n### 8.2. Journal Wrap-around\n1. Set journal size to 10 blocks.\n2. Write 5 transactions of 3 blocks each.\n3. **Assertion:** The system correctly triggers checkpoints when `j_tail` approaches `j_head`, and the journal continues to function using circular logic.\n\n### 8.3. Idempotent Replay\n1. Commit a transaction that sets Inode 5's size to 100 bytes.\n2. Manually run `journal_recover` twice.\n3. **Assertion:** Inode 5 size is 100 bytes. The second replay did not \"increment\" or corrupt the value.\n\n---\n\n## 9. Performance Targets\n\n| Operation | Target | Measurement |\n| :--- | :--- | :--- |\n| `txn_commit` (Metadata) | < 2ms (SSD) | Two `fsync` barriers + sequential writes. |\n| Recovery (4MB Journal) | < 50ms | Time from `journal_load` to `journal_checkpoint`. |\n| Write Amplification | ~2.5x | Ratio of (Journal Bytes + FS Bytes) / (User Bytes) for metadata. |\n| Throughput (Ordered) | > 90% of M4 | Data blocks bypass the journal; metadata is small. |\n\n---\n\n## 10. Hardware Soul (Atomic Writes)\n\n### 10.1. The Sector Atomicity Assumption\nOur design relies on the fact that a **single sector write (512B or 4KB)** is atomic at the hardware level. The `journal_commit_t` block is the lynchpin. Because we write it in a single block operation (4KB), the hardware ensures it is either fully written or not written at all. We never have to handle a \"half-written\" commit record.\n\n### 10.2. Barrier Analysis\n- **Barrier 1:** Protects against the disk controller's Out-of-Order execution. It ensures the \"intent\" (data blocks) is physically on the platters/NAND before the \"permission\" (commit record) is granted.\n- **Barrier 2:** Protects against the \"Volatile Write Cache\" (DRAM on the disk). It ensures the commit record is persistent, making the transaction a permanent part of history before we begin the \"messy\" in-place updates.\n\n---\n\n### {{DIAGRAM:tdd-diag-32}}\n**Circular Journal Buffer States**\n```text\n[S][D][B1][B2][C][.][.][.][.][.]\n ^  ^           ^  ^\n |  j_head      |  j_tail (Next write)\n j_super        j_tail - 1 (Last Commit)\n\nWrap-around:\n[.][.][.][S][D][B1][B2][C][D][B1]\n ^        ^                 ^\n j_tail   j_super           j_head\n```\n\n### \n![Journal Entry Structures â€” Byte Layout for DESC, COMMIT, and Journal Superblock](./diagrams/tdd-diag-33.svg)\n\n**The Transaction Write Pipeline**\n```text\n1. txn_journal_block(B5) -> Mem Buffer\n2. txn_journal_block(B10) -> Mem Buffer\n3. txn_commit()\n   |-- Write Desc (B5, B10) to Journal\n   |-- Write Data (B5_new, B10_new) to Journal\n   |-- fsync() <------------------------------- Barrier 1\n   |-- Write Commit to Journal\n   |-- fsync() <------------------------------- Barrier 2 (Durability Point)\n   |-- Write B5_new to Inode Table\n   |-- Write B10_new to Inode Bitmap\n   |-- Update Journal Super (Advance Tail)\n```\n<!-- END_TDD_MOD -->\n\n\n# Project Structure: Filesystem Implementation\n\n## Directory Tree\n\n```text\nfilesystem-root/\nâ”œâ”€â”€ include/                 # Header Definitions\nâ”‚   â”œâ”€â”€ fs_types.h          # Global constants and magic (M1)\nâ”‚   â”œâ”€â”€ block_io.h          # Block read/write prototypes (M1)\nâ”‚   â”œâ”€â”€ bitmap.h            # Bitmap manipulation macros (M1)\nâ”‚   â”œâ”€â”€ superblock.h        # Superblock structure (M1)\nâ”‚   â”œâ”€â”€ inode.h             # Inode structure & limits (M2)\nâ”‚   â”œâ”€â”€ dir.h               # Dirent structures (M3)\nâ”‚   â”œâ”€â”€ file_ops.h          # File I/O prototypes (M4)\nâ”‚   â”œâ”€â”€ fuse_context.h      # Global FsCtx & locking (M5)\nâ”‚   â”œâ”€â”€ journal_types.h     # Journaling block types (M6)\nâ”‚   â””â”€â”€ txn.h               # Transaction API (M6)\nâ”œâ”€â”€ src/                     # Source Implementation\nâ”‚   â”œâ”€â”€ core/               # Layer 1: Block Foundation\nâ”‚   â”‚   â”œâ”€â”€ block_io.c      # lseek/read/write wrappers (M1)\nâ”‚   â”‚   â”œâ”€â”€ bitmap.c        # Bit-level search logic (M1)\nâ”‚   â”‚   â””â”€â”€ superblock.c    # Layout & serialization (M1)\nâ”‚   â”œâ”€â”€ inode/              # Layer 2: Metadata Management\nâ”‚   â”‚   â”œâ”€â”€ inode_io.c      # Inode RMW cycles (M2)\nâ”‚   â”‚   â”œâ”€â”€ inode_alloc.c   # Inode bitmap integration (M2)\nâ”‚   â”‚   â”œâ”€â”€ inode_tree.c    # Indirect pointer traversal (M2)\nâ”‚   â”‚   â””â”€â”€ inode_free_recursive.c # Depth-first reclamation (M2)\nâ”‚   â”œâ”€â”€ dir/                # Layer 3: Directory Hierarchy\nâ”‚   â”‚   â”œâ”€â”€ dir_rec.c       # Record padding/length math (M3)\nâ”‚   â”‚   â”œâ”€â”€ dir_scan.c      # Linear entry scanning (M3)\nâ”‚   â”‚   â”œâ”€â”€ dir_path.c      # Recursive path resolution (M3)\nâ”‚   â”‚   â”œâ”€â”€ dir_write.c     # Entry splitting/merging (M3)\nâ”‚   â”‚   â””â”€â”€ dir_op.c        # mkdir/rmdir/link logic (M3)\nâ”‚   â”œâ”€â”€ file/               # Layer 4: File Data Plane\nâ”‚   â”‚   â”œâ”€â”€ file_create.c   # File-specific allocation (M4)\nâ”‚   â”‚   â”œâ”€â”€ file_read.c     # Sparse hole handling (M4)\nâ”‚   â”‚   â”œâ”€â”€ file_write.c    # RMW data engine (M4)\nâ”‚   â”‚   â””â”€â”€ file_truncate.c # Shrink/Extend space recovery (M4)\nâ”‚   â”œâ”€â”€ fuse/               # Layer 5: OS Integration\nâ”‚   â”‚   â”œâ”€â”€ myfs_main.c     # libfuse entry point (M5)\nâ”‚   â”‚   â”œâ”€â”€ fuse_bridge.c   # path-to-inode translation (M5)\nâ”‚   â”‚   â”œâ”€â”€ fuse_ops_meta.c # getattr/statfs/chmod (M5)\nâ”‚   â”‚   â”œâ”€â”€ fuse_ops_dir.c  # readdir/mkdir/unlink (M5)\nâ”‚   â”‚   â””â”€â”€ fuse_ops_file.c # open/read/write/release (M5)\nâ”‚   â””â”€â”€ journal/            # Layer 6: Consistency\nâ”‚       â”œâ”€â”€ journal_io.c    # Circular buffer math (M6)\nâ”‚       â”œâ”€â”€ txn.c           # 8-step commit protocol (M6)\nâ”‚       â”œâ”€â”€ recovery.c      # Mount-time log replay (M6)\nâ”‚       â”œâ”€â”€ checkpoint.c    # Log flushing/truncation (M6)\nâ”‚       â””â”€â”€ journal_wrappers.c # Transactional metadata APIs (M6)\nâ”œâ”€â”€ tools/                   # Standalone Utilities\nâ”‚   â””â”€â”€ mkfs.c              # Disk image formatter (M1)\nâ”œâ”€â”€ tests/                   # Verification Suites\nâ”‚   â”œâ”€â”€ test_m1.c           # Block layer verification\nâ”‚   â”œâ”€â”€ test_m2.c           # Pointer tree integrity\nâ”‚   â”œâ”€â”€ test_m3.c           # Directory/Link invariants\nâ”‚   â”œâ”€â”€ test_m4.c           # Sparse I/O & RMW tests\nâ”‚   â””â”€â”€ test_m6_crash.c     # SIGKILL consistency tests\nâ”œâ”€â”€ build/                   # Compiled binaries (Artifact)\nâ”œâ”€â”€ Makefile                 # Pkg-config & build system (M5)\nâ”œâ”€â”€ README.md               # Project Documentation\nâ”œâ”€â”€ disk.img                # Generated 4KB-block image (Artifact)\nâ””â”€â”€ mnt/                     # FUSE mount point (Artifact)\n```\n\n## Creation Order\n\n1.  **Block Layer (M1)**: Establish `block_io.c` and `mkfs.c`. Ensure you can format a 16MB file and read the magic number back via `test_m1.c`.\n2.  **Inode Engine (M2)**: Build the pointer tree. Crucial: Test `inode_get_block` with high offsets to verify single/double indirection.\n3.  **Namespace (M3)**: Implement `dir_path.c` and `dir_add_entry`. Verify that `path_resolve` can find the root inode `.` and `..`.\n4.  **Data Plane (M4)**: Implement `file_write.c`. Verify that partial writes trigger the Read-Modify-Write cycle and don't corrupt the rest of the block.\n5.  **FUSE Bridge (M5)**: Connect your C functions to `myfs_main.c`. Use the `-f -d -s` flags to watch calls flow from the OS into your code.\n6.  **Consistency (M6)**: Refactor metadata writes into `txn_commit`. Use `test_m6_crash.c` to verify that interrupted `mkdir` calls don't leak inodes.\n\n## File Count Summary\n- Total files: 35\n- Directories: 9\n- Estimated lines of code: ~4,500 lines of C (excluding tests)\n\n# ðŸ“š Beyond the Atlas: Further Reading\n\n## I. Core Architecture & The Inode\n**Paper**: McKusick, M. K., et al. (1984). *A Fast File System for UNIX*.\n**Code**: [Linux Kernel: fs/ext2/inode.c](https://github.com/torvalds/linux/blob/master/fs/ext2/inode.c) â€” `ext2_get_block` is the classic implementation of the indirection tree.\n**Best Explanation**: [OSTEP: Chapter 40 - File System Implementation](https://pages.cs.wisc.edu/~remzi/OSTEP/file-implementation.pdf).\n**Why**: This chapter provides the clearest visual breakdown of how bitmapped allocation and inode tables interact in a \"Simple File System.\"\n**Pedagogical Timing**: Read **BEFORE Milestone 1**. It establishes the mental model of the disk as an array of blocks that you will spend the rest of the project implementing.\n\n**Code**: [Linux Kernel: fs/ext4/extents.c](https://github.com/torvalds/linux/blob/master/fs/ext4/extents.c) â€” Specifically the `ext4_ext_binsearch` function.\n**Best Explanation**: [Ext4 Disk Layout (Kernel.org Wiki)](https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout#Extents).\n**Why**: This is the industry successor to the indirection tree you build in Milestone 2, essential for understanding modern large-scale storage.\n**Pedagogical Timing**: Read **AFTER Milestone 2**. Once you've struggled with the math of triple-indirection, you will immediately appreciate why \"extents\" are a more efficient way to track contiguous data.\n\n## II. VFS & Path Resolution\n**Paper**: Kleiman, S. R. (1986). *Vnodes: An Architecture for Multiple File System Types in Sun UNIX*.\n**Code**: [Linux Kernel: fs/namei.c](https://github.com/torvalds/linux/blob/master/fs/namei.c) â€” The `link_path_walk` function is the actual engine behind `path_resolve`.\n**Best Explanation**: [The Path Lookup Series (LWN.net)](https://lwn.net/Articles/649115/) â€” Specifically \"Part 2: Components of the path.\"\n**Why**: Neil Brown provides the most exhaustive explanation of the \"walking\" process and the subtle complexity of symlinks and mount points.\n**Pedagogical Timing**: Read **DURING Milestone 3**. Use it to debug your logic for `..` and trailing slashes in your path resolution engine.\n\n## III. Userspace Integration (FUSE)\n**Paper**: Vangoor, B. R., et al. (2017). *To FUSE or Not to FUSE: Performance of User-Level File Systems*.\n**Code**: [libfuse: example/hello.c](https://github.com/libfuse/libfuse/blob/master/example/hello.c).\n**Best Explanation**: [FUSE Kernel Documentation](https://www.kernel.org/doc/html/latest/filesystems/fuse.html).\n**Why**: It explains the protocol that lives inside `/dev/fuse`, clarifying how requests move from the VFS to your C code.\n**Pedagogical Timing**: Read **BEFORE Milestone 5**. You need to understand that FUSE is a message-passing protocol before you try to debug context switches and locking.\n\n## IV. Persistence & Crash Safety\n**Paper**: Prabhakaran, V., et al. (2005). *Analysis and Evolution of Journaling File Systems*.\n**Code**: [Linux Kernel: fs/jbd2/transaction.c](https://github.com/torvalds/linux/blob/master/fs/jbd2/transaction.c) â€” Look for `jbd2_journal_commit_transaction`.\n**Best Explanation**: [OSTEP: Chapter 42 - Crash Consistency: FSCK and Journaling](https://pages.cs.wisc.edu/~remzi/OSTEP/file-journaling.pdf).\n**Why**: It provides a narrative walkthrough of the \"Why\" behind write-ahead logging using the same block-level terminology as this project.\n**Pedagogical Timing**: Read **BEFORE starting Milestone 6**. This is a conceptually heavy module; the OSTEP chapter acts as the necessary map before you write the code.\n\n**Explanation**: [SQLite: Atomic Commit In SQLite](https://www.sqlite.org/atomiccommit.html) â€” Section 3.0 \"The Rollback Journal.\"\n**Why**: This is a perfect example of how a database implements the same \"intent-to-write\" logic at the application level to ensure atomicity.\n**Pedagogical Timing**: Read **AFTER Milestone 6**. It will help you realize that your filesystem's journal and a database's WAL are essentially the same machine built for different purposes.\n\n## V. Hardware Interaction (The Physical Layer)\n**Spec**: [NVMe Express Base Specification, Revision 2.0](https://nvmexpress.org/developers/nvme-specification/) â€” Section 3.1.3 \"Logical Block Address (LBA).\"\n**Best Explanation**: [The LBA is a Lie: An Introduction to SSDs (Cody Littlewood)](https://codingwithcody.com/2018/12/03/the-lba-is-a-lie/).\n**Why**: It shatters the illusion that writing to \"Block 5\" means writing to the 5th physical slot on an SSD, explaining the \"Flash Translation Layer.\"\n**Pedagogical Timing**: Read **AFTER Milestone 4**. You've implemented software-level indirection; now see how the hardware implements its own hidden indirection for wear leveling.\n\n## VI. Memory Management Parallelism\n**Code**: [jemalloc: src/bitmap.c](https://github.com/jemalloc/jemalloc/blob/dev/src/bitmap.c).\n**Best Explanation**: [Understanding the Linux Virtual Memory Manager (Mel Gorman)](https://www.kernel.org/doc/gorman/pdf/understand.pdf) â€” Chapter 6 \"Page Frame Allocation.\"\n**Why**: This shows that the bitmap allocator you built in Milestone 1 is identical to how the Linux kernel manages physical RAM.\n**Pedagogical Timing**: Read **AFTER Milestone 1**. It validates that the patterns you are learning (bitmaps, alignment, metadata) are universal in systems engineering."}