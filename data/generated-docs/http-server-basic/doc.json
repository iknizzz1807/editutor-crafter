{"html":"<h1 id=\"-project-charter-http-server-basic\">ðŸŽ¯ Project Charter: HTTP Server (Basic)</h1>\n<h2 id=\"what-you-are-building\">What You Are Building</h2>\n<p>A production-aware, standalone HTTP/1.1 static file server built from raw TCP sockets. You are creating a systems-level tool that maps URL paths to a local filesystem, detects MIME types, prevents security exploits like directory traversal, and manages multiple simultaneous clients using a bounded thread pool. By the end, you will have a high-performance binary capable of serving a modern website to multiple browsers concurrently.</p>\n<h2 id=\"why-this-project-exists\">Why This Project Exists</h2>\n<p>Modern web development happens behind layers of framework abstractions that treat the network and the OS as &quot;magic.&quot; Building an HTTP server from scratch exposes the &quot;physics&quot; of the web: how TCP byte streams are framed into messages, how the kernel manages file descriptors, and why threading models are the difference between a responsive service and a crashed one.</p>\n<h2 id=\"what-you-will-be-able-to-do-when-done\">What You Will Be Able to Do When Done</h2>\n<ul>\n<li><strong>Master Socket Programming:</strong> Implement the full TCP lifecycle (bind, listen, accept) and handle partial network reads/writes.</li>\n<li><strong>Implement Protocols:</strong> Write a robust, adversarial-safe parser for HTTP/1.1 requests following RFC 7230.</li>\n<li><strong>Enforce Systems Security:</strong> Implement path canonicalization to prevent &quot;Directory Traversal&quot; attacks that leak sensitive system files.</li>\n<li><strong>Architect Concurrency:</strong> Build a work-queue based thread pool from scratch to handle hundreds of parallel connections.</li>\n<li><strong>Manage Resource Lifecycle:</strong> Implement graceful shutdowns and connection &quot;Keep-Alive&quot; to maximize server efficiency.</li>\n</ul>\n<h2 id=\"final-deliverable\">Final Deliverable</h2>\n<p>A single executable (written in C, Go, or Rust) composed of ~1,500 to 2,500 lines of code across modules for networking, parsing, and file I/O. The server will pass a &quot;stress test&quot; of 10,000 requests without leaking file descriptors and will serve a complex directory of HTML, CSS, JS, and binary images to any standard web browser.</p>\n<h2 id=\"is-this-project-for-you\">Is This Project For You?</h2>\n<p><strong>You should start this if you:</strong></p>\n<ul>\n<li>Understand pointers and manual memory management (if using C).</li>\n<li>Are comfortable with basic File I/O (open, read, write).</li>\n<li>Want to know exactly what happens when you type a URL into a browser.</li>\n<li>Are ready to debug low-level network issues using <code>curl</code>, <code>telnet</code>, and <code>netstat</code>.</li>\n</ul>\n<p><strong>Come back after you&#39;ve learned:</strong></p>\n<ul>\n<li><a href=\"https://beej.us/guide/bgnet/\">TCP/IP Basics</a>: Understanding IP addresses and port numbers.</li>\n<li>Basic C/Systems Syntax: If you don&#39;t know the difference between the stack and the heap, this will be frustrating.</li>\n</ul>\n<h2 id=\"estimated-effort\">Estimated Effort</h2>\n<table>\n<thead>\n<tr>\n<th>Phase</th>\n<th>Time</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Phase 1: TCP Server &amp; HTTP Response</strong></td>\n<td>~3 hours</td>\n</tr>\n<tr>\n<td><strong>Phase 2: HTTP Request Parsing</strong></td>\n<td>~4 hours</td>\n</tr>\n<tr>\n<td><strong>Phase 3: Static File Serving &amp; Security</strong></td>\n<td>~6 hours</td>\n</tr>\n<tr>\n<td><strong>Phase 4: Thread Pool &amp; Concurrency</strong></td>\n<td>~7 hours</td>\n</tr>\n<tr>\n<td><strong>Total</strong></td>\n<td><strong>~20 hours</strong></td>\n</tr>\n</tbody></table>\n<h2 id=\"definition-of-done\">Definition of Done</h2>\n<p>The project is complete when:</p>\n<ul>\n<li>The server successfully serves an <code>index.html</code> file and an image to a browser (Chrome/Firefox).</li>\n<li><code>curl -I</code> returns correct headers including <code>Content-Type</code>, <code>Content-Length</code>, and <code>Date</code>.</li>\n<li>A request for <code>../../etc/passwd</code> returns a <code>403 Forbidden</code> or <code>404 Not Found</code>, never the file content.</li>\n<li>The server handles 50 concurrent requests simultaneously without dropping connections.</li>\n<li>The server shuts down gracefully on <code>SIGINT</code> (Ctrl+C), closing all sockets and joining all threads without leaks.</li>\n</ul>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>\n---\n\n# HTTP Server (Basic) â€” Build Your Own Static File Server\n\nThis project builds a fully functional HTTP/1.1 static file server from raw TCP sockets upward. You will implement the complete network stack lifecycle â€” binding, listening, accepting, reading, parsing, responding â€” then layer on HTTP protocol parsing per RFC 7230, secure static file serving with directory traversal prevention, and finally concurrent connection handling via a bounded thread pool with keep-alive and graceful shutdown.\n\nThe project deliberately avoids all frameworks and HTTP libraries, forcing you to negotiate directly with the operating system's socket API, the filesystem, and the threading primitives. Every abstraction that web frameworks hide â€” partial reads, CRLF parsing, MIME detection, path canonicalization, connection lifecycle management â€” becomes visible and tangible.\n\nBy the end, you will have a production-aware mental model of what happens between a browser hitting Enter and pixels appearing on screen, grounded in syscalls, file descriptors, and cache lines rather than framework magic.\n\n\n\n&lt;!-- MS_ID: http-server-basic-m1 --&gt;\n# Milestone 1: TCP Server &amp; HTTP Response\n## Where You Are in the System\nBefore you write a single line of code, orient yourself. You are about to build the absolute foundation of an HTTP server â€” the part that everything else rests on. In the full architecture of this project, you are building the **entry point**: the socket machinery that catches raw network connections before HTTP parsing, file serving, or concurrency concerns exist at all.\n\n![HTTP Server Architecture â€” Satellite Map](./diagrams/diag-satellite-map.svg)\n\nThis milestone has one job: establish the plumbing. By the end, your server will open a network port, wait for a browser or `curl` to connect, receive raw bytes, and send back a hardcoded HTTP response. No routing, no file reading, no concurrency â€” just the essential loop that every production web server on Earth runs underneath its abstractions.\n---\n## The Fundamental Tension: TCP Is a Byte Pipe, Not a Message Pipe\nHere's the misconception that breaks more networking code than any other: **&quot;The client sends a request, so my `read()` call returns a complete request.&quot;**\nIt feels obvious. You type a URL into a browser, it sends one HTTP request, your server should receive one HTTP request. The unit of thinking is a *message*. So naturally, `read()` gives you the message, right?\nWrong. And understanding *why* this is wrong is the most important thing you will learn in this entire milestone.\n**TCP (Transmission Control Protocol) is a byte stream protocol.** The kernel has no concept of &quot;messages.&quot; When the browser sends `GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n` â€” those 38 bytes â€” your kernel might deliver them in one `read()` call. Or three. Or seven. The kernel is working at the level of **receive buffer segments**, not HTTP messages. The factors that determine what each `read()` returns include:\n- **Network packet fragmentation** â€” IP packets have a Maximum Transmission Unit (MTU) of ~1500 bytes on Ethernet. Large HTTP headers might span multiple packets.\n- **TCP Nagle's algorithm** â€” Small writes from the client may be coalesced (batched) before transmission, or may not.\n- **Kernel scheduling** â€” Your `read()` runs when the OS schedules your process. The receive buffer might have accumulated 1 byte or 8KB since your last read.\n- **Localhost vs. real network** â€” On localhost, both processes share the same kernel and network stack, so data often arrives in one call. In production over a real network, partial delivery is the norm.\nThis is the exact trap the Architect flagged. Code that passes every localhost test silently breaks on a production network because the testing environment hides the byte-stream nature of TCP.\n\n![Partial Read Reality â€” TCP Byte Stream vs. HTTP Messages](./diagrams/diag-m1-partial-reads.svg)\n\nThe consequence is concrete: **you must accumulate bytes in a buffer and search for the `\\r\\n\\r\\n` delimiter yourself.** The HTTP specification says headers end with a blank line â€” that's `\\r\\n\\r\\n` in raw bytes. Your job is to keep calling `read()` until you've seen that sequence, appending each result into a growing buffer. Only then do you have a complete HTTP request header section.\nThis one insight â€” TCP is a byte stream, HTTP is a structured message, and you must bridge the gap â€” is the foundation for the next three milestones and for virtually all network programming you will ever do.\n---\n## File Descriptors: Your Handle to the OS\nBefore touching socket code, you need to understand **file descriptors** (FDs), because every socket you create is one.\nIn Unix/Linux, the operating system manages access to hardware and resources on behalf of your program. Your program can't directly manipulate a network port or a disk file â€” it asks the kernel to do it, and the kernel hands back a small non-negative integer called a **file descriptor**. This integer is your process's handle to an open resource.\nThink of file descriptors as numbered slots in a per-process table the kernel maintains. Slot 0 is always `stdin` (keyboard input), slot 1 is `stdout` (terminal output), slot 2 is `stderr` (error output). When you open a file, create a socket, or create a pipe, the kernel allocates the next available slot and returns that number to you.\n```c\nint fd = socket(AF_INET, SOCK_STREAM, 0);\n// fd might be 3, 4, 5... â€” the kernel chose the next available slot</code></pre></div>\n<p>The crucial implication: <strong>when you&#39;re done with a resource, you must call <code>close(fd)</code>.</strong> If you forget, the kernel keeps the slot occupied. A typical Linux process can only have ~1024 file descriptors open at once (the soft limit; configurable with <code>ulimit -n</code>). A server that handles 1000 connections without closing them hits this ceiling and starts failing <code>accept()</code> calls with <code>EMFILE</code> (&quot;too many open files&quot;). This is a real production failure mode, not a theoretical concern.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m1-fd-table.svg\" alt=\"File Descriptor Table â€” What the Kernel Sees\"></p>\n<p>The reason file descriptors matter right now: your server will manage <em>two</em> kinds of file descriptors simultaneously:</p>\n<ul>\n<li>The <strong>listening socket</strong> â€” one FD, open for the server&#39;s lifetime, represents &quot;this port is accepting connections&quot;</li>\n<li><strong>Client connection sockets</strong> â€” one FD <em>per accepted connection</em>, must be <code>close()</code>d after each response</li>\n</ul>\n<hr>\n<h2 id=\"the-seven-step-socket-dance\">The Seven-Step Socket Dance</h2>\n<p>Creating a TCP server requires exactly seven system calls in the right order. Each one transforms the state of your server and its connection to the OS. There&#39;s no skipping steps â€” the kernel enforces the order.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m1-socket-lifecycle.svg\" alt=\"Socket Syscall Lifecycle â€” The 7-Step Dance\"></p>\n<p>Let&#39;s walk through each step with its why.</p>\n<h3 id=\"step-1-socket-create-an-endpoint\">Step 1: <code>socket()</code> â€” Create an Endpoint</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> server_fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> socket</span><span style=\"color:#E1E4E8\">(AF_INET, SOCK_STREAM, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (server_fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"socket\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><code>socket()</code> creates a new socket and returns its file descriptor. The three parameters tell the kernel what kind of socket:</p>\n<ul>\n<li><code>AF_INET</code> â€” Address Family Internet (IPv4). Use <code>AF_INET6</code> for IPv6.</li>\n<li><code>SOCK_STREAM</code> â€” Stream socket, meaning TCP: ordered, reliable byte delivery. The alternative <code>SOCK_DGRAM</code> is UDP.</li>\n<li><code>0</code> â€” Protocol. 0 means &quot;pick the default for this family/type combo,&quot; which is TCP here.\nAt this point, you have a socket, but it&#39;s not associated with any port or address. It&#39;s like having a phone but no phone number.</li>\n</ul>\n<h3 id=\"step-2-setsockopt-enable-port-reuse\">Step 2: <code>setsockopt()</code> â€” Enable Port Reuse</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> opt </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">setsockopt</span><span style=\"color:#E1E4E8\">(server_fd, SOL_SOCKET, SO_REUSEADDR, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">opt</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(opt));</span></span></code></pre></div>\n<p>This step is optional but practically mandatory. Without it, after you stop and restart your server, the OS may reject <code>bind()</code> for 1â€“4 minutes with <code>EADDRINUSE</code>. This happens because TCP has a <strong>TIME_WAIT</strong> state: when a connection closes, the OS keeps the port reserved briefly to catch any delayed packets still in transit. <code>SO_REUSEADDR</code> tells the kernel &quot;let me reuse this address even if there are TIME_WAIT connections on it.&quot; Every production server sets this.\n<code>SOL_SOCKET</code> means &quot;this option applies to the socket layer itself&quot; (as opposed to TCP-level or IP-level options). <code>SO_REUSEADDR</code> is the option name. The <code>&amp;opt</code> is a pointer to the value â€” <code>1</code> means enable.</p>\n<h3 id=\"step-3-bind-claim-a-port\">Step 3: <code>bind()</code> â€” Claim a Port</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> sockaddr_in addr;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">addr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(addr));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">addr.sin_family </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> AF_INET;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">addr.sin_addr.s_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> INADDR_ANY;</span><span style=\"color:#6A737D\">  // Listen on all interfaces</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">addr.sin_port </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> htons</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">8080</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">        // Port 8080, in network byte order</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">bind</span><span style=\"color:#E1E4E8\">(server_fd, (</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> sockaddr</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">addr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(addr)) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"bind\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><code>bind()</code> associates your socket with a specific IP address and port number. After this call, port 8080 on this machine is claimed by your process. The <code>struct sockaddr_in</code> encodes IPv4 address information.\n<strong>Network byte order</strong>: The <code>htons()</code> call is critical. CPUs can store multi-byte numbers in two ways: <strong>big-endian</strong> (most significant byte first, like humans write numbers) or <strong>little-endian</strong> (least significant byte first, which most modern x86 CPUs use). The network protocol standard mandates big-endian, called &quot;network byte order.&quot; <code>htons()</code> â€” &quot;host to network short&quot; â€” converts a 16-bit port number from your CPU&#39;s native order to network byte order. Without it, you&#39;d bind to port 36895 (the byte-flipped version of 8080) instead of 8080. <code>INADDR_ANY</code> (value 0) means &quot;accept connections on any local IP address&quot; â€” useful when your machine has multiple network interfaces.</p>\n<h3 id=\"step-4-listen-start-accepting-connections\">Step 4: <code>listen()</code> â€” Start Accepting Connections</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">listen</span><span style=\"color:#E1E4E8\">(server_fd, SOMAXCONN) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"listen\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><code>listen()</code> marks the socket as passive â€” it will receive incoming connections rather than initiate them. The second argument, the <strong>backlog</strong>, specifies how many pending connections the kernel should queue while your server is busy in <code>accept()</code>. <code>SOMAXCONN</code> is a constant (typically 128 or 4096 depending on OS) that requests the system maximum. For a production server, you&#39;d tune this, but <code>SOMAXCONN</code> is correct for now.\nAfter <code>listen()</code>, your socket is in the <strong>listening state</strong>. The kernel&#39;s TCP state machine handles the three-way handshake (SYN â†’ SYN-ACK â†’ ACK) automatically for incoming clients. By the time <code>accept()</code> returns to you, the connection is already established at the TCP level â€” your code never sees raw TCP handshakes.</p>\n<h3 id=\"step-5-accept-receive-a-connection\">Step 5: <code>accept()</code> â€” Receive a Connection</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> sockaddr_in client_addr;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">socklen_t</span><span style=\"color:#E1E4E8\"> client_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(client_addr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> client_fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> accept</span><span style=\"color:#E1E4E8\">(server_fd, (</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> sockaddr</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">client_addr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">client_len</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (client_fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"accept\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    continue</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Don't exit â€” try next connection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><code>accept()</code> blocks (pauses your program) until a client connects. When a client connects, it returns a <strong>new file descriptor</strong> â€” <code>client_fd</code> â€” that represents the specific connection to that client. Your original <code>server_fd</code> remains untouched, still listening for future connections.\nThis is architecturally important: you always have two distinct roles:</p>\n<ul>\n<li><code>server_fd</code> â€” the <em>listening</em> socket (one, permanent)</li>\n<li><code>client_fd</code> â€” the <em>connection</em> socket (one per client, temporary)\nThe <code>client_addr</code> is filled in by the kernel with the client&#39;s IP and port. You can inspect it to log where connections come from.</li>\n</ul>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m1-three-level-socket.svg\" alt=\"Three-Level View: What Happens on accept()\"></p>\n<h3 id=\"step-6-read-recv-and-write-send-communicate\">Step 6: <code>read()</code> / <code>recv()</code> and <code>write()</code> / <code>send()</code> â€” Communicate</h3>\n<p>Now you have <code>client_fd</code>. This is a bidirectional byte stream. You read from it (bytes the client sent) and write to it (bytes you&#39;re sending back).\nThe partial-read problem lives here. We&#39;ll dedicate a full section to this below.</p>\n<h3 id=\"step-7-close-release-the-connection\">Step 7: <code>close()</code> â€” Release the Connection</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">close</span><span style=\"color:#E1E4E8\">(client_fd);</span><span style=\"color:#6A737D\">  // MANDATORY after each connection</span></span></code></pre></div>\n<h2 id=\"after-your-response-is-sent-close-the-client-socket-this-signals-to-the-client-that-you39re-done-tcp-fin-handshake-and-releases-the-kernel-file-descriptor-never-skip-this\">After your response is sent, close the client socket. This signals to the client that you&#39;re done (TCP FIN handshake), and releases the kernel file descriptor. Never skip this.</h2>\n<h2 id=\"three-level-view-what-happens-when-you-call-accept\">Three-Level View: What Happens When You Call <code>accept()</code></h2>\n<p>To truly understand the socket lifecycle, look at all three levels simultaneously.\n<strong>Level 1 â€” Your Code:</strong>\nYou call <code>accept(server_fd, ...)</code> and your program pauses. Eventually it returns with <code>client_fd = 5</code>.\n<strong>Level 2 â€” OS/Kernel:</strong>\nThe kernel maintains two queues for your listening socket:</p>\n<ul>\n<li><strong>SYN queue</strong> (incomplete connections): TCP handshakes in progress</li>\n<li><strong>Accept queue</strong> (complete connections): fully-established connections waiting for your <code>accept()</code> call\nWhen a client&#39;s SYN arrives, the kernel adds it to the SYN queue, sends SYN-ACK, and waits for ACK. When ACK arrives, the connection moves to the Accept queue. Your <code>accept()</code> call dequeues the next entry from the Accept queue, creates a new socket file descriptor for it, and returns. If the Accept queue is empty, <code>accept()</code> blocks until it&#39;s not.\n<strong>Level 3 â€” Hardware:</strong>\nThe network interface card (NIC) receives an Ethernet frame containing an IP packet containing a TCP segment. The NIC raises a hardware interrupt, the interrupt handler (running in kernel context) processes the TCP segment, updates the connection state machine, and places the data into the socket&#39;s receive buffer in kernel memory. The kernel wakes your <code>accept()</code> call by transitioning your thread from the &quot;sleeping&quot; state to &quot;runnable.&quot;\nThe hardware-to-userspace path: NIC â†’ DMA into kernel buffer â†’ TCP stack processes segment â†’ wakes sleeping process â†’ your code runs. This entire path takes on the order of 10â€“50 microseconds on a local network.</li>\n</ul>\n<hr>\n<h2 id=\"the-partial-read-problem-solved\">The Partial Read Problem â€” Solved</h2>\n<p>Now let&#39;s implement the read loop properly. The design goal: accumulate bytes from <code>client_fd</code> until we&#39;ve seen <code>\\r\\n\\r\\n</code> (the HTTP header terminator), or until we&#39;ve read a maximum safe amount.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BUFFER_SIZE</span><span style=\"color:#79B8FF\"> 8192</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns the number of bytes in the buffer on success, -1 on error/disconnect</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Sets *header_end to the position after \\r\\n\\r\\n if found, -1 if not found</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#B392F0\"> read_http_request</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> client_fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> buf_size</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">header_end</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> total_read </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">header_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (total_read </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> buf_size </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) {</span><span style=\"color:#6A737D\">  // Leave room for null terminator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        ssize_t</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> read</span><span style=\"color:#E1E4E8\">(client_fd, buf </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> total_read, buf_size </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\"> total_read);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (n </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // EAGAIN/EWOULDBLOCK: no data yet (non-blocking mode, not our case here)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Other errors: real problem</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"read\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (n </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Client disconnected before sending complete request</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        total_read </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> n;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        buf</span><span style=\"color:#E1E4E8\">[total_read] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Null-terminate for string searching</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Scan for the end-of-headers delimiter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">end </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strstr</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\r\\n\\r\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (end </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            *</span><span style=\"color:#E1E4E8\">header_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)(end </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> buf) </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Position after the delimiter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#E1E4E8\">)total_read;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Buffer full without finding delimiter â€” request too large</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Walk through this carefully:</p>\n<ul>\n<li><strong><code>read()</code> return values</strong>: positive means &quot;I read this many bytes,&quot; zero means &quot;the client closed the connection,&quot; negative means &quot;an error occurred.&quot; You must handle all three.</li>\n<li><strong><code>buf + total_read</code></strong>: each call reads into the <em>next unused portion</em> of the buffer. This is how accumulation works â€” each call appends to where the last one left off.</li>\n<li><strong><code>buf_size - 1 - total_read</code></strong>: we tell <code>read()</code> the maximum it can give us, shrinking as the buffer fills. The <code>- 1</code> reserves space for the null terminator we add after each read.</li>\n<li><strong><code>strstr(buf, &quot;\\r\\n\\r\\n&quot;)</code></strong>: scan the entire accumulated buffer for the delimiter. We scan from the start each time (slightly inefficient, but correct and simple for now).</li>\n<li><strong>Buffer size limit</strong>: 8KB is the default maximum URI length in many HTTP servers (and the nginx default). Requests larger than this get rejected, which we&#39;ll implement properly in Milestone 2.\nThis is the correct mental model: <strong><code>read()</code> is just &quot;give me whatever bytes the kernel has right now.&quot;</strong> Your code is responsible for interpreting those bytes as a structured protocol.</li>\n</ul>\n<hr>\n<h2 id=\"building-the-complete-server\">Building the Complete Server</h2>\n<p>Now let&#39;s assemble everything into a working server. We&#39;ll structure the code cleanly from the start â€” the habits you form here carry through all four milestones.</p>\n<h3 id=\"data-structures-and-memory-layout\">Data Structures and Memory Layout</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;signal.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;time.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/socket.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;netinet/in.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;arpa/inet.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEFAULT_PORT</span><span style=\"color:#79B8FF\">      8080</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BACKLOG</span><span style=\"color:#E1E4E8\">           SOMAXCONN</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> REQUEST_BUF_SIZE</span><span style=\"color:#79B8FF\">  8192</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_RESPONSE_SIZE</span><span style=\"color:#79B8FF\"> 4096</span></span></code></pre></div>\n\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m1-server-struct-layout.svg\" alt=\"Server Data Structures â€” Memory Layout\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">      port;</span><span style=\"color:#6A737D\">       // TCP port to bind</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">      server_fd;</span><span style=\"color:#6A737D\">  // Listening socket file descriptor</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">server_config_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n<p>Keep the struct minimal for Milestone 1. Later milestones will expand it with document root, thread pool size, and timeout configuration.</p>\n<h3 id=\"the-hardcoded-http-response\">The Hardcoded HTTP Response</h3>\n<p>In Milestone 1, you&#39;re not reading files yet â€” you&#39;re sending a fixed response to prove the plumbing works. But the response must be a <em>valid</em> HTTP/1.1 response. Let&#39;s understand why each header matters.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Build a valid HTTP/1.1 200 OK response with Date header</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns bytes written to `buf`, or -1 on error</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> build_hardcoded_response</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> buf_size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // HTTP Date header format: \"Day, DD Mon YYYY HH:MM:SS GMT\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    time_t</span><span style=\"color:#E1E4E8\"> now </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> tm </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">gmt </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gmtime</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">now);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> date_str</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    strftime</span><span style=\"color:#E1E4E8\">(date_str, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(date_str), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%a</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#FDAEB7;font-style:italic\"> %</span><span style=\"color:#9ECBFF\">b </span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">Y </span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">H:</span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">M:</span><span style=\"color:#79B8FF\">%S</span><span style=\"color:#9ECBFF\"> GMT\"</span><span style=\"color:#E1E4E8\">, gmt);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">body </span><span style=\"color:#F97583\">=</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;html>&#x3C;body>\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;h1>Hello from my HTTP server!&#x3C;/h1>\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;/body>&#x3C;/html>\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> body_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(body);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> snprintf</span><span style=\"color:#E1E4E8\">(buf, buf_size,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"HTTP/1.1 200 OK</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"Content-Type: text/html; charset=utf-8</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"Content-Length: </span><span style=\"color:#79B8FF\">%d\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"Date: </span><span style=\"color:#79B8FF\">%s\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"Connection: close</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        body_len,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        date_str,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        body);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (n </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)n </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> buf_size) </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">:</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Each header serves a specific role:</p>\n<ul>\n<li><strong><code>HTTP/1.1 200 OK</code></strong> â€” The status line. <code>HTTP/1.1</code> is the protocol version. <code>200</code> is the numeric status code. <code>OK</code> is the human-readable reason phrase. The browser uses the numeric code; the phrase is for humans and logs.</li>\n<li><strong><code>Content-Type: text/html; charset=utf-8</code></strong> â€” Without this, browsers guess the content type. Some browsers display HTML as raw text if they guess wrong. <code>charset=utf-8</code> specifies character encoding.</li>\n<li><strong><code>Content-Length: N</code></strong> â€” The exact byte count of the body. The browser needs this to know where the response ends. Without it, the browser has to wait for the connection to close to know if more data is coming.</li>\n<li><strong><code>Date:</code></strong> â€” Required by HTTP/1.1 (RFC 7231, Section 7.1.1.2). Servers should include it. We generate it from the system clock in UTC.</li>\n<li><strong><code>Connection: close</code></strong> â€” Tells the client we&#39;ll close the connection after this response. In Milestone 4, you&#39;ll implement <code>keep-alive</code> to reuse connections. For now, <code>close</code> is correct.</li>\n<li><strong>Blank line (<code>\\r\\n</code>)</strong> â€” Mandatory separator between headers and body. Every HTTP message has this blank line; without it, the body would be treated as another header.</li>\n</ul>\n<h3 id=\"writing-the-response-partial-writes\">Writing the Response â€” Partial Writes</h3>\n<p>Just as <code>read()</code> might give you fewer bytes than requested, <code>write()</code> might send fewer bytes than you asked. This is uncommon on localhost but can happen when the kernel&#39;s send buffer is full (which happens under load). The fix is the same: loop until all bytes are sent.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Write all `len` bytes from `buf` to `fd`.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns 0 on success, -1 on error.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> write_all</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> len</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> total_written </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (total_written </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> len) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        ssize_t</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> write</span><span style=\"color:#E1E4E8\">(fd, buf </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> total_written, len </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> total_written);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (n </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Error or connection closed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        total_written </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> n;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>This pattern â€” the &quot;write-all&quot; or &quot;write loop&quot; â€” is so common it appears in virtually every systems library. Python&#39;s <code>socket.sendall()</code>, Go&#39;s <code>io.WriteString()</code>, and Rust&#39;s <code>write_all()</code> trait method all implement exactly this loop so you don&#39;t have to.</p>\n<h3 id=\"handling-sigpipe-don39t-let-the-client-kill-your-server\">Handling SIGPIPE â€” Don&#39;t Let the Client Kill Your Server</h3>\n<p>Here&#39;s a specific failure mode you must handle before your first test.\n<strong>The scenario</strong>: a client connects, you call <code>write()</code> to send the response, but the client has already disconnected (crashed, closed the tab, hit Ctrl+C). The client&#39;s side of the TCP connection is closed. What happens when you write to a socket whose remote end is closed?\nOn Linux, the first <code>write()</code> succeeds (the kernel doesn&#39;t know yet that the client is gone). The kernel sends the data, the remote TCP stack sends back a RST (reset) packet. On your <em>second</em> <code>write()</code> to that socket, the kernel has now processed the RST and knows the connection is dead. Instead of returning an error from <code>write()</code>, the kernel delivers <strong>SIGPIPE</strong> â€” signal 13 â€” to your process. The default handler for SIGPIPE <strong>terminates your process.</strong>\nThat&#39;s right: a single misbehaving client can kill your server.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m1-sigpipe.svg\" alt=\"SIGPIPE Death Scenario â€” Before & After\"></p>\n<p>The fix is to ignore SIGPIPE:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// At server startup, before any accept() calls:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">signal</span><span style=\"color:#E1E4E8\">(SIGPIPE, SIG_IGN);</span></span></code></pre></div>\n<p>After this, when you try to write to a closed socket, <code>write()</code> returns -1 with <code>errno = EPIPE</code> instead of killing your process. You check the return value (you always check return values in systems code), log it, and close the client socket gracefully.\nAn alternative when using <code>send()</code> instead of <code>write()</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// MSG_NOSIGNAL tells the kernel: don't send SIGPIPE on broken pipe</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> send</span><span style=\"color:#E1E4E8\">(fd, buf </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> total_written, len </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> total_written, MSG_NOSIGNAL);</span></span></code></pre></div>\n<p><code>MSG_NOSIGNAL</code> is Linux-specific. <code>signal(SIGPIPE, SIG_IGN)</code> is portable and works on Linux, macOS, and BSDs. For this project, use <code>signal(SIGPIPE, SIG_IGN)</code> at startup.</p>\n<h3 id=\"the-complete-main-function\">The Complete <code>main()</code> Function</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#F97583\">[]</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> port </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> DEFAULT_PORT;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (argc </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        port </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> atoi</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (port </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> port </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 65535</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Invalid port: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // --- SIGPIPE: must happen before any socket I/O ---</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    signal</span><span style=\"color:#E1E4E8\">(SIGPIPE, SIG_IGN);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // --- Step 1: Create listening socket ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> server_fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> socket</span><span style=\"color:#E1E4E8\">(AF_INET, SOCK_STREAM, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (server_fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"socket\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // --- Step 2: Enable port reuse ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> opt </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">setsockopt</span><span style=\"color:#E1E4E8\">(server_fd, SOL_SOCKET, SO_REUSEADDR, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">opt, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(opt)) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"setsockopt\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(server_fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // --- Step 3: Bind to port ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> sockaddr_in addr;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">addr, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(addr));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    addr.sin_family      </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> AF_INET;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    addr.sin_addr.s_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> INADDR_ANY;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    addr.sin_port        </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> htons</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\">)port);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">bind</span><span style=\"color:#E1E4E8\">(server_fd, (</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> sockaddr</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">addr, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(addr)) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"bind\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(server_fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // --- Step 4: Start listening ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">listen</span><span style=\"color:#E1E4E8\">(server_fd, BACKLOG) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"listen\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(server_fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Server listening on port </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, port);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // --- Step 5: Accept loop ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        struct</span><span style=\"color:#E1E4E8\"> sockaddr_in client_addr;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        socklen_t</span><span style=\"color:#E1E4E8\"> client_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(client_addr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> client_fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> accept</span><span style=\"color:#E1E4E8\">(server_fd, (</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> sockaddr</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">client_addr, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">client_len);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (client_fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> EINTR) </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Interrupted by signal, retry</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"accept\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Log and continue; don't crash the server</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Log the incoming connection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#FFAB70\"> client_ip</span><span style=\"color:#E1E4E8\">[INET_ADDRSTRLEN];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        inet_ntop</span><span style=\"color:#E1E4E8\">(AF_INET, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">client_addr.sin_addr, client_ip, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(client_ip));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Connection from </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (fd=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               client_ip, </span><span style=\"color:#B392F0\">ntohs</span><span style=\"color:#E1E4E8\">(client_addr.sin_port), client_fd);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // --- Step 6a: Read the request ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#FFAB70\"> req_buf</span><span style=\"color:#E1E4E8\">[REQUEST_BUF_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> header_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        ssize_t</span><span style=\"color:#E1E4E8\"> bytes_read </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> read_http_request</span><span style=\"color:#E1E4E8\">(client_fd, req_buf, REQUEST_BUF_SIZE, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">header_end);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (bytes_read </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> header_end </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Log the first line of the request</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">first_line_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strstr</span><span style=\"color:#E1E4E8\">(req_buf, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (first_line_end) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">first_line_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Request: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, req_buf);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (first_line_end) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">first_line_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Restore</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // --- Step 6b: Build and send the response ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#FFAB70\"> resp_buf</span><span style=\"color:#E1E4E8\">[MAX_RESPONSE_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> resp_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> build_hardcoded_response</span><span style=\"color:#E1E4E8\">(resp_buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(resp_buf));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (resp_len </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_all</span><span style=\"color:#E1E4E8\">(client_fd, resp_buf, (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)resp_len) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Client disconnected before we finished â€” EPIPE, not a crash</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Client disconnected during write (fd=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, client_fd);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // --- Step 7: Close the connection ---</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(client_fd);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Connection closed (fd=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, client_fd);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Unreachable in this milestone, but good practice:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(server_fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"compiling-and-testing\">Compiling and Testing</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Compile</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -Wall</span><span style=\"color:#79B8FF\"> -Wextra</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> http_server</span><span style=\"color:#9ECBFF\"> server.c</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run on default port 8080</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./http_server</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run on a different port</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./http_server</span><span style=\"color:#79B8FF\"> 9090</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test with curl (in another terminal)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test with telnet to see raw bytes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">telnet</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Type: GET / HTTP/1.1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Type: Host: localhost</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Press Enter twice</span></span></code></pre></div>\n<p>Expected <code>curl -v</code> output:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>* Connected to localhost port 8080\n&gt; GET / HTTP/1.1\n&gt; Host: localhost\n&gt; User-Agent: curl/7.x.x\n&gt; Accept: */*\n&gt;\n&lt; HTTP/1.1 200 OK\n&lt; Content-Type: text/html; charset=utf-8\n&lt; Content-Length: 53\n&lt; Date: Sat, 28 Feb 2026 12:00:00 GMT\n&lt; Connection: close\n&lt;\n&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello from my HTTP server!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></div>\n<h3 id=\"verifying-no-file-descriptor-leaks\">Verifying No File Descriptor Leaks</h3>\n<p>A critical correctness check: after many connections, your server must return to its baseline FD count. You can verify this on Linux:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Get your server's PID</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ps</span><span style=\"color:#9ECBFF\"> aux</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> http_server</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check open FDs before connections</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#9ECBFF\">PI</span><span style=\"color:#E1E4E8\">D</span><span style=\"color:#F97583\">></span><span style=\"color:#9ECBFF\">/fd</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> wc</span><span style=\"color:#79B8FF\"> -l</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Hammer it with 1000 sequential connections</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">seq</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">do</span><span style=\"color:#B392F0\"> curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> http://localhost:8080/</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/null</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check open FDs after â€” should be the same count as before</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#9ECBFF\">PI</span><span style=\"color:#E1E4E8\">D</span><span style=\"color:#F97583\">></span><span style=\"color:#9ECBFF\">/fd</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> wc</span><span style=\"color:#79B8FF\"> -l</span></span></code></pre></div>\n<h2 id=\"if-the-count-grows-you-have-a-file-descriptor-leak-in-this-milestone39s-sequential-design-the-cause-is-always-a-missing-closeclient_fd-on-an-error-path-every-if-something_failed-block-that-exits-before-the-normal-closeclient_fd-must-also-close-the-fd\">If the count grows, you have a file descriptor leak. In this milestone&#39;s sequential design, the cause is always a missing <code>close(client_fd)</code> on an error path. Every <code>if (something_failed)</code> block that exits before the normal <code>close(client_fd)</code> must also close the FD.</h2>\n<h2 id=\"hardware-soul-what-the-cpu-and-kernel-are-doing\">Hardware Soul: What the CPU and Kernel Are Doing</h2>\n<h2 id=\"let39s-apply-the-domain39s-hardware-perspective-to-the-operations-in-this-milestone-accept-blocking-on-empty-queue-your-thread-is-in-the-task_interruptible-sleep-state-the-cpu-runs-other-processes-when-a-syn-arrives-the-nic-raises-a-hardware-interrupt-the-kernel-interrupt-handler-runs-in-kernel-space-processes-the-tcp-three-way-handshake-moves-the-connection-to-the-accept-queue-and-transitions-your-thread-to-task_running-next-time-the-scheduler-runs-your-thread-wakes-up-and-accept-returns-zero-cpu-cycles-wasted-while-waiting-read-from-socket-memory-access-pattern-the-kernel39s-receive-buffer-is-in-kernel-virtual-memory-when-you-call-read-the-kernel-copies-bytes-from-its-buffer-into-your-userspace-buffer-req_buf-this-is-a-memory-to-memory-copy-with-good-locality-if-the-request-is-small-fits-in-l1l2-cache-for-a-typical-200-byte-http-request-the-entire-operation-kernel-buffer-your-buffer-fits-in-l1-cache-typically-3264kb-latency-100ns-for-in-cache-operations-write-to-socket-send-buffer-the-kernel-has-a-send-buffer-per-socket-default-87kb-on-linux-controlled-by-so_sndbuf-your-write-copies-data-from-your-buffer-into-the-send-buffer-and-returns-the-kernel39s-tcp-stack-asynchronously-handles-segmentation-and-transmission-this-means-write-is-nearly-always-fast-just-a-memory-copy-it-only-blocks-if-the-send-buffer-is-full-which-happens-when-the-network-is-congested-or-the-client-is-reading-slowly-close-fd-table-update-closing-an-fd-is-a-kernel-table-update-decrement-the-reference-count-on-the-socket-structure-release-the-fd-slot-in-the-process39s-file-descriptor-table-if-reference-count-hits-zero-no-other-fd-points-to-this-socket-begin-tcp-fin-sequence-very-fast-no-disk-io-just-memory-writes-branch-prediction-the-accept-loop39s-while1-is-perfectly-predictable-always-taken-the-error-checks-if-client_fd-lt-0-are-almost-never-taken-in-normal-operation-the-branch-predictor-learns-this-quickly-the-partial-read-loop39s-termination-condition-strstr-found-rnrn-is-taken-once-per-request-predictable-after-the-first-connection\">Let&#39;s apply the domain&#39;s hardware perspective to the operations in this milestone.\n<strong><code>accept()</code> â€” blocking on empty queue</strong>: Your thread is in the <code>TASK_INTERRUPTIBLE</code> sleep state. The CPU runs other processes. When a SYN arrives, the NIC raises a hardware interrupt, the kernel interrupt handler runs (in kernel space), processes the TCP three-way handshake, moves the connection to the accept queue, and transitions your thread to <code>TASK_RUNNING</code>. Next time the scheduler runs, your thread wakes up and <code>accept()</code> returns. Zero CPU cycles wasted while waiting.\n<strong><code>read()</code> from socket â€” memory access pattern</strong>: The kernel&#39;s receive buffer is in kernel virtual memory. When you call <code>read()</code>, the kernel copies bytes from its buffer into your userspace buffer (<code>req_buf</code>). This is a <strong>memory-to-memory copy</strong> with good locality if the request is small (fits in L1/L2 cache). For a typical 200-byte HTTP request, the entire operation â€” kernel buffer + your buffer â€” fits in L1 cache (typically 32â€“64KB). Latency: ~100ns for in-cache operations.\n<strong><code>write()</code> to socket â€” send buffer</strong>: The kernel has a send buffer per socket (default ~87KB on Linux, controlled by <code>SO_SNDBUF</code>). Your <code>write()</code> copies data from your buffer into the send buffer and returns. The kernel&#39;s TCP stack asynchronously handles segmentation and transmission. This means <code>write()</code> is nearly always fast (just a memory copy). It only blocks if the send buffer is full â€” which happens when the network is congested or the client is reading slowly.\n<strong><code>close()</code> â€” FD table update</strong>: Closing an FD is a kernel table update: decrement the reference count on the socket structure, release the FD slot in the process&#39;s file descriptor table. If reference count hits zero (no other FD points to this socket), begin TCP FIN sequence. Very fast â€” no disk I/O, just memory writes.\n<strong>Branch prediction</strong>: The accept loop&#39;s <code>while(1)</code> is perfectly predictable (always taken). The error checks (<code>if (client_fd &lt; 0)</code>) are almost never taken in normal operation â€” the branch predictor learns this quickly. The partial read loop&#39;s termination condition (<code>strstr</code> found <code>\\r\\n\\r\\n</code>) is taken once per request â€” predictable after the first connection.</h2>\n<h2 id=\"error-handling-philosophy-for-systems-code\">Error Handling Philosophy for Systems Code</h2>\n<p>Notice that every syscall&#39;s return value is checked. This is not optional ceremony â€” it&#39;s load-bearing structure. Syscalls fail for real reasons:</p>\n<table>\n<thead>\n<tr>\n<th>Error</th>\n<th>Cause</th>\n<th>Correct Response</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>EADDRINUSE</code> on <code>bind()</code></td>\n<td>Port already in use</td>\n<td>Exit with clear error message</td>\n</tr>\n<tr>\n<td><code>EMFILE</code> on <code>accept()</code></td>\n<td>Too many open FDs</td>\n<td>Log error, continue loop, investigate leak</td>\n</tr>\n<tr>\n<td><code>EINTR</code> on <code>accept()</code></td>\n<td>Signal interrupted the call</td>\n<td>Retry immediately (loop <code>continue</code>)</td>\n</tr>\n<tr>\n<td><code>EPIPE</code> on <code>write()</code></td>\n<td>Client disconnected</td>\n<td>Close <code>client_fd</code>, continue to next connection</td>\n</tr>\n<tr>\n<td><code>ECONNRESET</code> on <code>read()</code></td>\n<td>Client forcibly closed</td>\n<td>Close <code>client_fd</code>, continue</td>\n</tr>\n<tr>\n<td>The pattern: <strong>server-fatal errors</strong> (can&#39;t bind, can&#39;t listen) cause <code>exit()</code>. <strong>Per-connection errors</strong> (client misbehaved, disconnected) cause <code>close(client_fd)</code> and <code>continue</code>. Never let a misbehaving client crash the server â€” which is why <code>SIGPIPE</code> must be ignored globally.</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>perror(&quot;context string&quot;)</code> prints your context string followed by the system error string for <code>errno</code>. It&#39;s the fastest way to get diagnostic information. <code>strerror(errno)</code> gives you the string if you need to format it differently.</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"design-decision-sequential-vs-concurrent-connections\">Design Decision: Sequential vs. Concurrent Connections</h2>\n<p>In this milestone, your server handles one connection at a time. While serving client A, client B&#39;s <code>connect()</code> call succeeds (the kernel accepts it into the backlog queue), but B must wait until you finish A before you call <code>accept()</code> again.</p>\n<table>\n<thead>\n<tr>\n<th>Model</th>\n<th>Throughput</th>\n<th>Complexity</th>\n<th>Used By</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Sequential (this milestone) âœ“</strong></td>\n<td>Low</td>\n<td>Very low</td>\n<td>dev tools, test servers</td>\n</tr>\n<tr>\n<td>Thread-per-connection</td>\n<td>Medium</td>\n<td>Medium</td>\n<td>Apache httpd (legacy)</td>\n</tr>\n<tr>\n<td>Thread pool</td>\n<td>High</td>\n<td>Medium</td>\n<td>nginx worker model</td>\n</tr>\n<tr>\n<td>Event loop (epoll)</td>\n<td>Very high</td>\n<td>High</td>\n<td>nginx, Node.js, Redis</td>\n</tr>\n<tr>\n<td>You&#39;re building sequential <em>deliberately</em> to isolate the core socket machinery. Milestone 4 replaces this with a thread pool. Once you understand the sequential model perfectly, the concurrent model is just &quot;run the inner loop in a separate thread&quot; â€” and all the complexity is in the threading, not the I/O.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>The <code>SOMAXCONN</code> backlog helps here: even with sequential handling, the kernel queues up to <code>SOMAXCONN</code> connections, so brief bursts don&#39;t immediately reject connections. For a development and learning server, sequential is exactly right.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"knowledge-cascade-what-this-unlocks\">Knowledge Cascade: What This Unlocks</h2>\n<p>Understanding TCP&#39;s byte-stream nature and the socket lifecycle opens doors in five directions simultaneously.</p>\n<h3 id=\"1-every-language39s-buffered-io-makes-sense-now\">1. Every Language&#39;s Buffered I/O Makes Sense Now</h3>\n<p>Every language runtime wraps raw I/O in a buffered reader for exactly the reason you just discovered. Go&#39;s <code>bufio.Reader</code>, Python&#39;s <code>io.BufferedReader</code>, Java&#39;s <code>BufferedInputStream</code>, and C&#39;s <code>FILE*</code> (via <code>fread</code>) all maintain an internal accumulation buffer and expose &quot;give me a line&quot; or &quot;give me N bytes&quot; interfaces that hide the partial-read reality underneath. Now when you see <code>bufio.NewReader(conn)</code> in Go networking code, you know <em>exactly</em> what problem it solves and what the raw socket calls beneath it are doing.</p>\n<h3 id=\"2-protocol-framing-is-a-universal-problem\">2. Protocol Framing Is a Universal Problem</h3>\n<p>Every protocol that runs over TCP must solve the same framing problem: &quot;where does one message end and the next begin?&quot; The approaches are consistent across the industry:</p>\n<ul>\n<li><strong>HTTP/1.1</strong>: headers end with <code>\\r\\n\\r\\n</code>, body length from <code>Content-Length</code> or chunked encoding</li>\n<li><strong>Redis RESP protocol</strong>: length-prefixed (<code>*3\\r\\n$3\\r\\nSET\\r\\n...</code>)</li>\n<li><strong>PostgreSQL wire protocol</strong>: 5-byte header with message type + 4-byte length</li>\n<li><strong>WebSockets</strong>: 2â€“10 byte binary frame header with payload length</li>\n<li><strong>Protocol Buffers over TCP</strong>: typically length-prefixed with a 4-byte varint\nOnce you understand why HTTP uses <code>\\r\\n\\r\\n</code>, you can read any protocol specification and immediately identify its framing strategy.</li>\n</ul>\n<h3 id=\"3-nagle39s-algorithm-and-tcp_nodelay\">3. Nagle&#39;s Algorithm and TCP_NODELAY</h3>\n<p>Now that you understand TCP as a byte stream, you can understand <strong>Nagle&#39;s algorithm</strong>: a TCP optimization that coalesces small writes before transmitting. If your application sends many small write() calls (say, HTTP headers one line at a time), Nagle&#39;s algorithm batches them into fewer packets, improving network efficiency. The tradeoff: it adds latency for small-packet protocols. This is why latency-sensitive applications (Redis, game servers, financial trading systems) call <code>setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &amp;one, sizeof(one))</code> to disable Nagle&#39;s algorithm. Now that phrase means something concrete to you.</p>\n<h3 id=\"4-non-blocking-io-and-event-loops\">4. Non-Blocking I/O and Event Loops</h3>\n<p>The partial read loop you implemented works because this is <em>blocking</em> I/O: <code>read()</code> blocks until data arrives. The alternative â€” <strong>non-blocking I/O</strong> with <code>O_NONBLOCK</code> â€” makes <code>read()</code> return immediately with <code>EAGAIN</code> if no data is available. Systems like epoll (Linux) and kqueue (macOS) let you monitor thousands of sockets simultaneously and get notified when any of them have data. The partial-read problem doesn&#39;t disappear in non-blocking mode â€” it becomes <em>more</em> explicit. nginx, Node.js, Redis, and Go&#39;s net package all use this model. You&#39;ll understand io_uring (the next generation) when you reach it because you already understand why blocking <code>read()</code> is a bottleneck at scale.</p>\n<h3 id=\"5-the-fd-lifecycle-is-universal\">5. The FD Lifecycle Is Universal</h3>\n<h2 id=\"the-file-descriptor-management-discipline-you39re-building-open-use-close-never-leak-applies-identically-to-files-pipes-sockets-timers-timerfd-event-notifications-eventfd-and-even-gpu-command-buffers-in-vulkan-the-kernel39s-reference-counted-resource-model-is-the-same-everywhere-the-ulimit-n-ceiling-is-the-same-ceiling-the-procltpidgtfd-directory-lets-you-inspect-any-process39s-open-resources-and-now-you-know-what-you39re-looking-at\">The file descriptor management discipline you&#39;re building â€” open, use, close, never leak â€” applies identically to files, pipes, sockets, timers (timerfd), event notifications (eventfd), and even GPU command buffers in Vulkan. The kernel&#39;s reference-counted resource model is the same everywhere. The <code>ulimit -n</code> ceiling is the same ceiling. The <code>/proc/&lt;pid&gt;/fd/</code> directory lets you inspect any process&#39;s open resources, and now you know what you&#39;re looking at.</h2>\n<h2 id=\"common-mistakes-that-will-burn-you\">Common Mistakes That Will Burn You</h2>\n<h2 id=\"keep-these-in-a-mental-checklist-1-forgetting-htons-on-the-port-bind-will-succeed-on-the-wrong-port-you39ll-spend-an-hour-wondering-why-curl-localhost8080-times-out-before-realizing-your-server-is-actually-listening-on-port-36895-2-not-handling-eintr-on-accept-when-a-signal-arrives-including-sigchld-in-milestone-439s-thread-model-accept-returns-1-with-errno-eintr-if-you-exit-the-accept-loop-on-any-negative-return-one-signal-kills-your-server-always-check-errno-eintr-and-retry-3-assuming-read-returns-a-complete-request-works-on-localhost-fails-in-staging-fails-in-production-fails-in-any-test-that-simulates-network-conditions-the-partial-read-loop-is-non-negotiable-4-missing-closeclient_fd-on-error-paths-every-early-return-inside-the-connection-handling-block-must-close-client_fd-before-returning-draw-the-control-flow-on-paper-if-needed-a-leak-here-is-a-server-that-degrades-after-thousands-of-connections-and-becomes-unfixable-without-a-restart-5-ignoring-write-return-values-write-returning-1-with-epipe-is-the-normal-case-when-a-client-disconnects-if-you-don39t-check-return-values-you-don39t-know-whether-your-response-was-delivered-and-you-may-try-to-write-to-a-dead-connection-repeatedly\">Keep these in a mental checklist:\n<strong>1. Forgetting <code>htons()</code> on the port.</strong>\n<code>bind()</code> will succeed â€” on the wrong port. You&#39;ll spend an hour wondering why <code>curl localhost:8080</code> times out before realizing your server is actually listening on port 36895.\n<strong>2. Not handling <code>EINTR</code> on <code>accept()</code>.</strong>\nWhen a signal arrives (including SIGCHLD in Milestone 4&#39;s thread model), <code>accept()</code> returns -1 with <code>errno = EINTR</code>. If you exit the accept loop on any negative return, one signal kills your server. Always check <code>errno == EINTR</code> and retry.\n<strong>3. Assuming <code>read()</code> returns a complete request.</strong>\nWorks on localhost, fails in staging, fails in production, fails in any test that simulates network conditions. The partial-read loop is non-negotiable.\n<strong>4. Missing <code>close(client_fd)</code> on error paths.</strong>\nEvery early return inside the connection-handling block must close <code>client_fd</code> before returning. Draw the control flow on paper if needed. A leak here is a server that degrades after thousands of connections and becomes unfixable without a restart.\n<strong>5. Ignoring <code>write()</code> return values.</strong>\n<code>write()</code> returning -1 with <code>EPIPE</code> is the normal case when a client disconnects. If you don&#39;t check return values, you don&#39;t know whether your response was delivered, and you may try to write to a dead connection repeatedly.</h2>\n<h2 id=\"acceptance-criteria-checklist\">Acceptance Criteria Checklist</h2>\n<p>Before moving to Milestone 2, verify each of these manually:</p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> <code>./http_server 8080</code> starts and prints &quot;Server listening on port 8080&quot;</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>curl http://localhost:8080/</code> receives a valid <code>200 OK</code> response with all four required headers (<code>Content-Type</code>, <code>Content-Length</code>, <code>Date</code>, <code>Connection</code>)</li>\n<li><input disabled=\"\" type=\"checkbox\"> The HTML body is correct and <code>Content-Length</code> matches the actual body byte count</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>curl http://localhost:8081/</code> fails with &quot;Connection refused&quot; (confirms port is configurable)</li>\n<li><input disabled=\"\" type=\"checkbox\"> Server does not crash when you kill <code>curl</code> mid-request (SIGPIPE handled)</li>\n<li><input disabled=\"\" type=\"checkbox\"> After 1000 sequential <code>curl</code> requests, FD count in <code>/proc/&lt;pid&gt;/fd/</code> matches the count at startup</li>\n<li><input disabled=\"\" type=\"checkbox\"> Telnet test works: <code>telnet localhost 8080</code>, type <code>GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n</code>, receive full response</li>\n<li><input disabled=\"\" type=\"checkbox\"> Server logs the client IP and request line for each connection</li>\n</ul>\n<hr>\n<!-- END_MS -->\n\n\n<!-- MS_ID: http-server-basic-m2 -->\n<!-- MS_ID: http-server-basic-m2 -->\n<h1 id=\"milestone-2-http-request-parsing\">Milestone 2: HTTP Request Parsing</h1>\n<h2 id=\"where-you-are-in-the-system\">Where You Are in the System</h2>\n<p>In Milestone 1, you built the socket plumbing: the server binds a port, accepts a TCP connection, reads raw bytes into a buffer, and sends a hardcoded response. You proved the plumbing works. Now those raw bytes need to mean something.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-satellite-map.svg\" alt=\"HTTP Server Architecture â€” Satellite Map\"></p>\n<p>Right now, your server is holding a buffer that looks like this:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>GET /index.html HTTP/1.1\\r\\nHost: localhost:8080\\r\\nUser-Agent: curl/7.88\\r\\nAccept: */*\\r\\n\\r\\n</code></pre></div>\n<h2 id=\"that39s-just-a-char-your-server-doesn39t-know-the-method-doesn39t-know-the-path-doesn39t-know-whether-to-read-a-body-before-you-can-serve-files-milestone-3-or-handle-multiple-connections-properly-milestone-4-you-need-a-parser-code-that-transforms-those-raw-bytes-into-structured-data-your-program-can-reason-about-this-milestone39s-job-turn-the-byte-buffer-into-a-struct-after-this-milestone-the-rest-of-your-server-speaks-in-terms-of-requestmethod-requestpath-and-requestheadersquotcontent-typequot-not-raw-offsets-and-strstr-calls-scattered-across-the-codebase\">That&#39;s just a <code>char[]</code>. Your server doesn&#39;t know the method, doesn&#39;t know the path, doesn&#39;t know whether to read a body. Before you can serve files (Milestone 3) or handle multiple connections properly (Milestone 4), you need a <strong>parser</strong> â€” code that transforms those raw bytes into structured data your program can reason about.\nThis milestone&#39;s job: turn the byte buffer into a struct. After this milestone, the rest of your server speaks in terms of <code>request.method</code>, <code>request.path</code>, and <code>request.headers[&quot;content-type&quot;]</code> â€” not raw offsets and <code>strstr()</code> calls scattered across the codebase.</h2>\n<h2 id=\"the-revelation-http-parsing-is-adversarial\">The Revelation: HTTP Parsing Is Adversarial</h2>\n<p>Here&#39;s what most developers think HTTP parsing is:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Seems obvious, right?</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">method </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strtok</span><span style=\"color:#E1E4E8\">(request_line, </span><span style=\"color:#9ECBFF\">\" \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">path   </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strtok</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\" \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">version </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strtok</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<p>Three calls to <code>strtok()</code>, done. The method, path, and version are extracted. Ship it.\nThis code works perfectly â€” in your tests, on your machine, with your browser. And then, in production, it silently fails or, worse, opens a security hole. Let&#39;s understand exactly why.</p>\n<h3 id=\"the-input-you-won39t-see-in-testing\">The Input You Won&#39;t See in Testing</h3>\n<p>Real HTTP clients are not all Chrome on macOS sending perfectly formatted requests. They include:</p>\n<ul>\n<li><strong><code>telnet</code> and <code>netcat</code></strong> â€” send bare LF (<code>\\n</code>) instead of CRLF (<code>\\r\\n</code>) because a human typed the request manually</li>\n<li><strong>Old HTTP/1.0 clients</strong> â€” may send <code>GET /\\n\\n</code> with no headers at all</li>\n<li><strong>Malicious scanners</strong> â€” deliberately send malformed requests to probe for vulnerabilities: <code>GET </code> (no path), <code>GET /</code> (no version), requests with 100MB URIs</li>\n<li><strong>Proxies</strong> â€” add extra headers, fold multi-line header values across lines (an HTTP/1.1 feature called &quot;header folding,&quot; now deprecated but still encountered)</li>\n<li><strong>HTTP fuzzers</strong> â€” systematically mutate every field looking for crashes\nYour <code>strtok()</code> parser treats all of these as undefined behavior. <code>strtok()</code> with <code>&quot; &quot;</code> as the delimiter will happily return whatever&#39;s between spaces â€” including a URI that&#39;s a gigabyte long â€” and your server will <code>malloc()</code> or buffer-overflow trying to hold it.</li>\n</ul>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m2-http-message-anatomy.svg\" alt=\"HTTP/1.1 Request Message â€” Byte-Level Anatomy\"></p>\n<h3 id=\"why-quotsplit-on-spacesquot-is-a-security-vulnerability\">Why &quot;Split on Spaces&quot; Is a Security Vulnerability</h3>\n<p>Consider this request:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>GET /../../../etc/passwd HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n</code></pre></div>\n<p>Your <code>strtok()</code> parser extracts <code>/../../etc/passwd</code> as the path. If Milestone 3&#39;s file server doesn&#39;t also validate this, you&#39;ve just served <code>/etc/passwd</code>. But even before that â€” your parser should apply length limits, method validation, and version checking. Every check your parser skips is a check that Milestone 3 has to retroactively add, and you will miss some.\nNow consider:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>GET /valid-path HTTP/1.1\\r\\ncontent-type: application/json\\r\\nContent-Type: text/html\\r\\n\\r\\n</code></pre></div>\n<h2 id=\"the-same-header-name-appears-twice-in-different-cases-which-one-is-the-quotrealquot-content-type-a-naive-parser-that-uses-case-sensitive-string-comparison-won39t-even-recognize-content-type-as-the-same-header-rfc-7230-says-header-names-are-case-insensitive-your-parser-must-implement-that-the-real-mental-model-http-parsing-is-adversarial-string-processing-every-field-in-an-http-request-is-input-from-a-potentially-hostile-source-your-parser39s-job-is-not-just-extraction-it39s-validation-normalization-and-rejection\">The same header name appears twice, in different cases. Which one is the &quot;real&quot; <code>Content-Type</code>? A naive parser that uses case-sensitive string comparison won&#39;t even recognize <code>content-type</code> as the same header. RFC 7230 says header names are case-insensitive. Your parser must implement that.\nThe real mental model: <strong>HTTP parsing is adversarial string processing.</strong> Every field in an HTTP request is input from a potentially hostile source. Your parser&#39;s job is not just extraction â€” it&#39;s <strong>validation, normalization, and rejection</strong>.</h2>\n<h2 id=\"the-http11-message-format\">The HTTP/1.1 Message Format</h2>\n<p>Before writing a parser, you need to know what you&#39;re parsing. Let&#39;s establish the exact byte-level structure of an HTTP/1.1 request, per RFC 7230.\nAn HTTP/1.1 request has this structure:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>{method} SP {request-target} SP {HTTP-version} CRLF\n{header-name} &quot;:&quot; OWS {header-value} OWS CRLF\n{header-name} &quot;:&quot; OWS {header-value} OWS CRLF\n...\nCRLF\n[ message-body ]</code></pre></div>\n<p>Where:</p>\n<ul>\n<li><strong>SP</strong> = a single space character (0x20). The spec says exactly one space between these three tokens.</li>\n<li><strong>CRLF</strong> = <code>\\r\\n</code> (0x0D 0x0A). Each line, including the blank line that terminates headers, ends with CRLF.</li>\n<li><strong>OWS</strong> = Optional WhiteSpace â€” zero or more spaces or tabs that may appear before or after a header value.\nLet&#39;s look at a complete example at the byte level:</li>\n</ul>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>G E T   /   H T T P / 1 . 1  \\r \\n\nH o s t :   l o c a l h o s t  \\r \\n\nU s e r - A g e n t :   c u r l  \\r \\n\n\\r \\n</code></pre></div>\n<p>In hex, the first two bytes of the body separator are <code>0D 0A 0D 0A</code> â€” two CRLF sequences back-to-back. The first ends the last header line; the second is the blank line that terminates the header section.\nThree structural rules are critical to parse correctly:</p>\n<ol>\n<li><strong>The request line is the first line.</strong> Everything before the first CRLF is the request line.</li>\n<li><strong>Each header is <code>name: value\\r\\n</code>.</strong> The colon is the separator. Everything after the colon (minus OWS) is the value.</li>\n<li><strong>A blank line (<code>\\r\\n</code> on its own) signals end-of-headers.</strong> In raw bytes, that&#39;s <code>\\r\\n\\r\\n</code> following the last header.\nThere is one important leniency the RFC recommends: <strong>accept bare LF as a line terminator.</strong> The spec says servers &quot;SHOULD&quot; accept bare LF in place of CRLF for historical reasons. When <code>telnet</code> users type a request manually, they often send bare LF. A robust parser strips any <code>\\r</code> before checking for <code>\\n</code>.</li>\n</ol>\n<hr>\n<h2 id=\"designing-the-parsed-request-structure\">Designing the Parsed Request Structure</h2>\n<p>Before writing a single parsing function, design the data structure that will hold the result. Good structure design makes everything downstream simpler.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_HEADERS</span><span style=\"color:#79B8FF\">    32</span><span style=\"color:#6A737D\">     // Maximum number of HTTP headers we'll accept</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_PATH_LEN</span><span style=\"color:#79B8FF\">   8192</span><span style=\"color:#6A737D\">   // 8KB max URI length (matches nginx default)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_HEADER_LEN</span><span style=\"color:#79B8FF\"> 8192</span><span style=\"color:#6A737D\">   // 8KB max per-header value length</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> METHOD_GET</span><span style=\"color:#79B8FF\">     0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> METHOD_HEAD</span><span style=\"color:#79B8FF\">    1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> METHOD_POST</span><span style=\"color:#79B8FF\">    2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> METHOD_UNKNOWN</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\">  name</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">               // Header name (lowercase, normalized)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\">  value</span><span style=\"color:#E1E4E8\">[MAX_HEADER_LEN];</span><span style=\"color:#6A737D\">   // Header value (OWS stripped)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">http_header_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">          method;</span><span style=\"color:#6A737D\">                   // METHOD_GET, METHOD_HEAD, METHOD_POST, METHOD_UNKNOWN</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\">         path</span><span style=\"color:#E1E4E8\">[MAX_PATH_LEN];</span><span style=\"color:#6A737D\">       // Requested path, e.g. \"/index.html\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">          http_minor;</span><span style=\"color:#6A737D\">               // HTTP version minor (0 = HTTP/1.0, 1 = HTTP/1.1)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    http_header_t</span><span style=\"color:#FFAB70\"> headers</span><span style=\"color:#E1E4E8\">[MAX_HEADERS];</span><span style=\"color:#6A737D\">    // Parsed headers array</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">          header_count;</span><span style=\"color:#6A737D\">             // Number of valid headers in array</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">          content_length;</span><span style=\"color:#6A737D\">           // -1 if no Content-Length header</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">          keep_alive;</span><span style=\"color:#6A737D\">               // 1 if connection should persist, 0 if close</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Pointer into the original buffer â€” body starts here, length = content_length</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\">  *</span><span style=\"color:#E1E4E8\">body;</span><span style=\"color:#6A737D\">                     // NULL if no body</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">http_request_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m2-request-struct.svg\" alt=\"Parsed Request Structure â€” http_request_t Memory Layout\"></p>\n<h2 id=\"several-design-decisions-worth-examining-fixed-size-arrays-instead-of-dynamic-allocation-http_header_t-headersmax_headers-uses-32-statically-allocated-header-slots-an-alternative-is-mallocing-a-linked-list-or-growing-array-the-fixed-array-approach-has-two-advantages-no-allocation-failures-and-cache-locality-all-headers-are-contiguous-in-memory-the-downside-we-reject-requests-with-more-than-32-headers-in-practice-real-http-requests-have-515-headers-so-32-is-generous-nginx39s-default-is-100-but-http2-hpack-compression-means-that-limit-is-rarely-approached-lowercase-header-names-we39ll-normalize-all-header-names-to-lowercase-during-parsing-this-is-the-quotrightquot-approach-for-case-insensitive-comparison-normalize-once-at-parse-time-compare-cheaply-everywhere-else-the-alternative-compare-case-insensitively-every-time-you-look-up-a-header-means-writing-a-strcasecmp-comparison-for-every-header-lookup-scattered-across-your-codebase-content_length-as-1-sentinel-1-means-quotno-content-length-header-was-presentquot-0-means-the-header-was-present-and-specified-a-zero-length-body-this-distinction-matters-a-response-with-content-length-0-and-no-body-is-valid-and-different-from-a-response-with-no-content-length-at-all-body-as-pointer-into-the-original-buffer-the-body-isn39t-copied-we-point-into-the-buffer-we-already-read-this-is-the-beginning-of-zero-copy-parsing-instead-of-mallocing-memory-and-copying-the-body-we-just-record-where-in-the-existing-buffer-the-body-starts-for-large-request-bodies-file-uploads-post-data-this-avoids-a-potentially-multi-megabyte-copy\">Several design decisions worth examining:\n<strong>Fixed-size arrays instead of dynamic allocation.</strong> <code>http_header_t headers[MAX_HEADERS]</code> uses 32 statically-allocated header slots. An alternative is <code>malloc()</code>ing a linked list or growing array. The fixed-array approach has two advantages: no allocation failures, and cache locality (all headers are contiguous in memory). The downside: we reject requests with more than 32 headers. In practice, real HTTP requests have 5â€“15 headers, so 32 is generous. nginx&#39;s default is 100, but HTTP/2 HPACK compression means that limit is rarely approached.\n<strong>Lowercase header names.</strong> We&#39;ll normalize all header names to lowercase during parsing. This is the &quot;right&quot; approach for case-insensitive comparison â€” normalize once at parse time, compare cheaply everywhere else. The alternative (compare case-insensitively every time you look up a header) means writing a <code>strcasecmp()</code> comparison for every header lookup, scattered across your codebase.\n<strong><code>content_length</code> as -1 sentinel.</strong> <code>-1</code> means &quot;no Content-Length header was present.&quot; <code>0</code> means the header was present and specified a zero-length body. This distinction matters: a response with <code>Content-Length: 0</code> and no body is valid and different from a response with no <code>Content-Length</code> at all.\n<strong><code>body</code> as pointer into the original buffer.</strong> The body isn&#39;t copied â€” we point into the buffer we already read. This is the beginning of <strong>zero-copy parsing</strong>: instead of <code>malloc()</code>ing memory and copying the body, we just record where in the existing buffer the body starts. For large request bodies (file uploads, POST data), this avoids a potentially multi-megabyte copy.</h2>\n<h2 id=\"building-the-state-machine\">Building the State Machine</h2>\n<p>Now the core of this milestone: the parser itself. The right mental model for parsing HTTP is a <strong>state machine</strong> â€” a system that reads one byte (or token) at a time and transitions between well-defined states based on what it sees.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m2-parser-state-machine.svg\" alt=\"HTTP Parser State Machine\"></p>\n<p>Why a state machine and not just <code>strtok()</code> and <code>sscanf()</code>? Three reasons:</p>\n<ol>\n<li><strong>Partial input handling.</strong> A state machine can be paused mid-parse (when a partial read arrives) and resumed when more bytes arrive. <code>strtok()</code> can&#39;t â€” it requires the complete string upfront.</li>\n<li><strong>Error localization.</strong> Each state enforces its own invariants. When you receive an invalid character, you know exactly which state you&#39;re in, which tells you exactly what&#39;s wrong with the request.</li>\n<li><strong>Security through structure.</strong> A state machine naturally imposes length limits (check at every transition) and rejects malformed input (illegal characters in the wrong state trigger immediate error).\nOur parser will work at the <strong>line level</strong> rather than the byte level, since HTTP is line-structured. We&#39;ll split the buffer into lines, parse the first line as the request line, and parse remaining lines (until the blank line) as headers.</li>\n</ol>\n<h3 id=\"step-1-parse-the-request-line\">Step 1: Parse the Request Line</h3>\n<p>The request line has exactly three fields separated by single spaces:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>METHOD SP request-target SP HTTP-version CRLF</code></pre></div>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Parse an HTTP method string into our enum.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns METHOD_GET, METHOD_HEAD, METHOD_POST, or METHOD_UNKNOWN.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> parse_method</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">s</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> len</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (len </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#B392F0\"> memcmp</span><span style=\"color:#E1E4E8\">(s, </span><span style=\"color:#9ECBFF\">\"GET\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> METHOD_GET;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (len </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#B392F0\"> memcmp</span><span style=\"color:#E1E4E8\">(s, </span><span style=\"color:#9ECBFF\">\"HEAD\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> METHOD_HEAD;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (len </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#B392F0\"> memcmp</span><span style=\"color:#E1E4E8\">(s, </span><span style=\"color:#9ECBFF\">\"POST\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> METHOD_POST;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> METHOD_UNKNOWN;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parse \"HTTP/1.X\" version string.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns HTTP minor version (0 or 1), or -1 on invalid format.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> parse_http_version</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">s</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> len</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Must be exactly \"HTTP/1.X\" â€” 8 characters</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (len </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">memcmp</span><span style=\"color:#E1E4E8\">(s, </span><span style=\"color:#9ECBFF\">\"HTTP/1.\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '0'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '1'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parse the HTTP request line into the request struct.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// `line` is a null-terminated string with the trailing CRLF already stripped.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns 0 on success, an HTTP status code on failure (400, 414, 501).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> parse_request_line</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">line</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">http_request_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">req</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find first space (separates method from path)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">path_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strchr</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#9ECBFF\">' '</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (path_start </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 400</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // No space found: malformed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> method_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)(path_start </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> line);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    path_start</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Skip the space</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find second space (separates path from version)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">version_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strchr</span><span style=\"color:#E1E4E8\">(path_start, </span><span style=\"color:#9ECBFF\">' '</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (version_start </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 400</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // No version: malformed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> path_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)(version_start </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> path_start);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    version_start</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Skip the space</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check for extra spaces (method SP path SP version â€” exactly one space each)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">memchr</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#9ECBFF\">' '</span><span style=\"color:#E1E4E8\">, method_len) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 400</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Validate and store method</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    req->method </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> parse_method</span><span style=\"color:#E1E4E8\">(line, method_len);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (req->method </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> METHOD_UNKNOWN) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 501</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // 501 Not Implemented</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Validate path length before copying</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (path_len </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)              </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 400</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Empty path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (path_len </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> MAX_PATH_LEN)   </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 414</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // URI Too Long</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Copy path and null-terminate</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(req->path, path_start, path_len);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    req->path[path_len] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Validate HTTP version</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> version_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strlen</span><span style=\"color:#E1E4E8\">(version_start);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    req->http_minor </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> parse_http_version</span><span style=\"color:#E1E4E8\">(version_start, version_len);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (req->http_minor </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 400</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Unknown version</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Success</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Walk through the design choices:\n<strong><code>memcmp()</code> for method comparison, not <code>strcmp()</code>.</strong> <code>strcmp()</code> works on null-terminated strings, which means it keeps reading until it hits <code>&#39;\\0&#39;</code>. <code>memcmp()</code> with an explicit length is both safer (bounded) and faster (the compiler can often reduce it to a 3-byte or 4-byte integer comparison).\n<strong><code>strchr()</code> to find delimiters.</strong> We use <code>strchr()</code> to find the first space (method/path boundary) and second space (path/version boundary). This is cleaner than <code>strtok()</code>, which has the critical flaw of modifying its input â€” <code>strtok()</code> replaces each delimiter with <code>&#39;\\0&#39;</code>, which would corrupt our original buffer.\n<strong>Method not in our list â†’ 501, not 400.</strong> RFC 7231 specifies: &quot;The server SHOULD respond with a 501 (Not Implemented) status code&quot; for methods it doesn&#39;t implement, and &quot;400 (Bad Request)&quot; for malformed requests. The distinction matters for HTTP compliance. A <code>PATCH</code> request is a valid method â€” just not one we implement. A <code>   </code> (spaces only) &quot;method&quot; is not valid at all.\n<strong>414 for oversized URI.</strong> The 414 status code means &quot;URI Too Long.&quot; RFC 7230 recommends that servers respond with 414 when the request-target is longer than any URI the server is willing to process. Our limit of 8KB (8192 bytes) matches nginx&#39;s default and is a reasonable bound.</p>\n<h3 id=\"step-2-parse-headers\">Step 2: Parse Headers</h3>\n<p>Headers are more complex than the request line because there are many of them, they have optional whitespace, their names are case-insensitive, and we need to extract specific ones (Host, Content-Length, Connection) while storing the rest for later use.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m2-case-insensitive-headers.svg\" alt=\"Header Name Case Insensitivity â€” The Trap\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Convert a string to lowercase in-place.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This is how we normalize header names for case-insensitive comparison.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> str_to_lower</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">s</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (; </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">s; </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">s) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">s </span><span style=\"color:#F97583\">>=</span><span style=\"color:#9ECBFF\"> 'A'</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">s </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#9ECBFF\"> 'Z'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            *</span><span style=\"color:#E1E4E8\">s </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">s </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Strip leading and trailing OWS (Optional WhiteSpace: space and tab)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// from `s`, writing null-terminated result into `out` (max `out_size` bytes).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns 0 on success, -1 if result doesn't fit.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> strip_ows</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">s</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">out</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> out_size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Skip leading whitespace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">s </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> ' '</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">s </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\t</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) s</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find end of string</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> len </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strlen</span><span style=\"color:#E1E4E8\">(s);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Strip trailing whitespace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (len </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s</span><span style=\"color:#E1E4E8\">[len</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> ' '</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#FFAB70\"> s</span><span style=\"color:#E1E4E8\">[len</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\t</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)) len</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check it fits</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (len </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> out_size) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(out, s, len);</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    out</span><span style=\"color:#E1E4E8\">[len] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parse a single header line \"Name: Value\" (CRLF already stripped).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Stores the result in req->headers[req->header_count] and increments header_count.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns 0 on success, -1 on malformed header (skip it), -2 on too many headers.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> parse_header_line</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">line</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">http_request_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">req</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (req->header_count </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> MAX_HEADERS) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find the colon separating name from value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">colon </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strchr</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#9ECBFF\">':'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (colon </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // No colon: malformed, skip</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> name_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)(colon </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> line);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (name_len </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Empty header name: malformed, skip</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (name_len </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(req->headers[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].name)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Name too long</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    http_header_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">h </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">req->headers[req->header_count];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Copy header name and lowercase it for case-insensitive storage</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(h->name, line, name_len);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    h->name[name_len] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    str_to_lower</span><span style=\"color:#E1E4E8\">(h->name);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Strip OWS from value (everything after the colon)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">value_raw </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> colon </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strip_ows</span><span style=\"color:#E1E4E8\">(value_raw, h->value, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(h->value)) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Value too long</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    req->header_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Look up a header by name (already lowercase).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns pointer to header value string, or NULL if not found.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">request_get_header</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> http_request_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">req</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> req->header_count; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strcmp</span><span style=\"color:#E1E4E8\">(req->headers[i].name, name) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> req->headers[i].value;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>The <code>str_to_lower()</code> function deserves attention. We&#39;re converting only ASCII letters (<code>A</code>â€“<code>Z</code> â†’ <code>a</code>â€“<code>z</code>). The conversion is <code>c + 32</code> because in ASCII, uppercase letters are exactly 32 positions before their lowercase equivalents (e.g., <code>&#39;A&#39;</code> is 65, <code>&#39;a&#39;</code> is 97). This is faster than <code>tolower()</code> from <code>&lt;ctype.h&gt;</code> because <code>tolower()</code> checks locale settings at runtime. HTTP header names are defined as ASCII-only in RFC 7230, so locale-independence isn&#39;t a concern here.\nThe <code>request_get_header()</code> function performs a linear search through the headers array. With at most 32 headers, this is O(32) â€” effectively O(1). We&#39;re calling this function a handful of times per request for specific headers (Host, Content-Length, Connection). A hash table would be faster asymptotically but adds significant complexity for negligible real-world benefit at this scale.</p>\n<h3 id=\"step-3-post-processing-extract-semantic-headers\">Step 3: Post-Processing â€” Extract Semantic Headers</h3>\n<p>After parsing all header lines, we need to extract the ones that control connection behavior and body reading:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// After parsing all headers, extract semantic fields into the request struct.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Call this once after the header loop completes.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> extract_semantic_headers</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">http_request_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">req</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Content-Length: controls body reading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">cl </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> request_get_header</span><span style=\"color:#E1E4E8\">(req, </span><span style=\"color:#9ECBFF\">\"content-length\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (cl </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">end;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        long</span><span style=\"color:#E1E4E8\"> val </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strtol</span><span style=\"color:#E1E4E8\">(cl, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">end, </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Valid if: all characters consumed, non-negative, not astronomically large</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">end </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> val </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> val </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            req->content_length </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)val;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            req->content_length </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Invalid Content-Length: treat as absent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        req->content_length </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Connection: keep-alive semantics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // HTTP/1.1 default is keep-alive; HTTP/1.0 default is close</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">conn </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> request_get_header</span><span style=\"color:#E1E4E8\">(req, </span><span style=\"color:#9ECBFF\">\"connection\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (req->http_minor </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // HTTP/1.1: default keep-alive, unless \"Connection: close\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        req->keep_alive </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (conn </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#B392F0\"> strcasecmp</span><span style=\"color:#E1E4E8\">(conn, </span><span style=\"color:#9ECBFF\">\"close\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> :</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // HTTP/1.0: default close, unless \"Connection: keep-alive\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        req->keep_alive </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (conn </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#B392F0\"> strcasecmp</span><span style=\"color:#E1E4E8\">(conn, </span><span style=\"color:#9ECBFF\">\"keep-alive\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> :</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"strtol-for-content-length-not-atoi-atoi-has-no-error-detection-if-the-input-is-quotabcquot-or-quotquot-it-returns-0-without-any-indication-of-failure-strtol-sets-an-end-pointer-if-end-39039-after-the-call-there-were-non-numeric-characters-we-also-cap-at-64mb-a-server-serving-static-html-and-css-files-has-no-business-reading-a-4gb-request-body-this-limit-prevents-a-slow-client-from-sending-content-length-9999999999-and-holding-your-connection-open-while-trickling-bytes-strcasecmp-for-connection-values-header-names-we-normalize-to-lowercase-ourselves-header-values-may-be-any-case-the-spec-says-method-tokens-and-header-values-are-case-insensitive-where-defined-connection-close-connection-close-and-connection-close-are-all-valid-strcasecmp-posix-handles-this-on-windows-you39d-use-_stricmp-worth-knowing-if-you-ever-port-this-code\"><strong><code>strtol()</code> for Content-Length, not <code>atoi()</code>.</strong> <code>atoi()</code> has no error detection â€” if the input is <code>&quot;abc&quot;</code> or <code>&quot;&quot;</code>, it returns 0 without any indication of failure. <code>strtol()</code> sets an end pointer: if <code>*end != &#39;\\0&#39;</code> after the call, there were non-numeric characters. We also cap at 64MB â€” a server serving static HTML and CSS files has no business reading a 4GB request body. This limit prevents a slow client from sending <code>Content-Length: 9999999999</code> and holding your connection open while trickling bytes.\n<strong><code>strcasecmp()</code> for <code>Connection</code> values.</strong> Header <em>names</em> we normalize to lowercase ourselves. Header <em>values</em> may be any case â€” the spec says method tokens and header values are case-insensitive where defined. <code>Connection: Close</code>, <code>Connection: CLOSE</code>, and <code>Connection: close</code> are all valid. <code>strcasecmp()</code> (POSIX) handles this. On Windows you&#39;d use <code>_stricmp()</code> â€” worth knowing if you ever port this code.</h2>\n<h2 id=\"assembling-the-full-parser\">Assembling the Full Parser</h2>\n<p>Now put the pieces together into a single function that takes the raw buffer from Milestone 1 and returns a populated <code>http_request_t</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Parse a complete HTTP request from `buf` (null-terminated, total `buf_len` bytes).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// `header_end` is the offset just past the \\r\\n\\r\\n delimiter (from Milestone 1's reader).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Fills `req` on success.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns 0 on success, HTTP status code on failure (400, 414, 501).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> parse_http_request</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> buf_len</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> header_end</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                       http_request_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">req</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(req, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">req));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    req->content_length </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // --- Line iterator ---</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // We'll walk through the buffer line by line.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // A line ends with \\n (we'll strip any preceding \\r).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">cursor </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> buf;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">buf_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> buf </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> header_end;</span><span style=\"color:#6A737D\">  // Don't go past headers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> line_number </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> line_buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">8192</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">  // Scratch buffer for one line</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (cursor </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> buf_end) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Find end of this line</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">line_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> memchr</span><span style=\"color:#E1E4E8\">(cursor, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)(buf_end </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> cursor));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (line_end </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // No newline found, stop</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> line_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)(line_end </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> cursor);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Strip trailing \\r if present (handle both CRLF and LF)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (line_len </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#FFAB70\"> cursor</span><span style=\"color:#E1E4E8\">[line_len </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            line_len</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Blank line = end of headers (shouldn't happen since we stop at header_end,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // but guard anyway)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (line_len </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cursor </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> line_end </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Copy line into scratch buffer for safe manipulation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (line_len </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(line_buf)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 400</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Line too long</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memcpy</span><span style=\"color:#E1E4E8\">(line_buf, cursor, line_len);</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        line_buf</span><span style=\"color:#E1E4E8\">[line_len] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (line_number </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // First line: request line</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            int</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> parse_request_line</span><span style=\"color:#E1E4E8\">(line_buf, req);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> err;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Subsequent lines: header fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Silently skip malformed headers (RFC 7230 permits this)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            parse_header_line</span><span style=\"color:#E1E4E8\">(line_buf, req);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        line_number</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cursor </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> line_end </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (line_number </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 400</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // No request line at all</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Validate required HTTP/1.1 headers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (req->http_minor </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">host </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> request_get_header</span><span style=\"color:#E1E4E8\">(req, </span><span style=\"color:#9ECBFF\">\"host\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (host </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 400</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Host header required in HTTP/1.1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Extract semantic fields from headers</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    extract_semantic_headers</span><span style=\"color:#E1E4E8\">(req);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set body pointer if Content-Length present</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (req->content_length </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        req->body </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> buf </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> header_end;</span><span style=\"color:#6A737D\">  // Body starts right after headers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Note: we don't read the body here â€” it may not be in the buffer yet.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Body reading is handled by the caller with a separate read loop.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Success</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"several-design-decisions-here-line-copying-into-line_buf-we-copy-each-line-into-a-temporary-scratch-buffer-before-parsing-it-this-protects-the-original-buffer-from-modification-and-gives-parse_request_line-and-parse_header_line-a-null-terminated-string-to-work-with-it-costs-one-memcpy-per-line-100500-bytes-for-an-http-server-handling-thousands-of-short-requests-this-is-negligible-for-a-system-parsing-gigabytes-of-http-traffic-an-api-gateway-or-load-balancer-you39d-investigate-zero-copy-approaches-but-that39s-the-optimization-ladder-for-later-silently-skip-malformed-headers-rfc-7230-says-quota-server-that-receives-an-obs-fold-in-a-request-message-that-is-not-within-a-messagehttp-container-must-either-reject-the-message-or-replace-each-received-obs-fold-with-one-or-more-sp-octetsquot-the-general-principle-is-that-a-receiver-may-choose-to-be-lenient-with-headers-it-doesn39t-understand-while-being-strict-with-the-request-line-and-host-header-we-silently-skip-malformed-header-lines-with-a-negative-return-from-parse_header_line-they-don39t-cause-a-400-host-header-is-required-in-http11-rfc-7230-section-54-quota-client-must-send-a-host-header-field-in-all-http11-request-messagesquot-a-server-quotmust-respond-with-a-400-bad-request-status-code-to-any-http11-request-message-that-lacks-a-host-header-fieldquot-we-enforce-this-http10-requests-don39t-require-host-which-is-why-we-only-check-it-when-http_minor-1\">Several design decisions here:\n<strong>Line copying into <code>line_buf</code>.</strong> We copy each line into a temporary scratch buffer before parsing it. This protects the original buffer from modification and gives <code>parse_request_line()</code> and <code>parse_header_line()</code> a null-terminated string to work with. It costs one <code>memcpy()</code> per line (~100â€“500 bytes). For an HTTP server handling thousands of short requests, this is negligible. For a system parsing gigabytes of HTTP traffic (an API gateway or load balancer), you&#39;d investigate zero-copy approaches â€” but that&#39;s the optimization ladder for later.\n<strong>Silently skip malformed headers.</strong> RFC 7230 says: &quot;A server that receives an obs-fold in a request message that is not within a <code>message/http</code> container MUST either reject the message [...] or replace each received obs-fold with one or more SP octets.&quot; The general principle is that a receiver may choose to be lenient with headers it doesn&#39;t understand while being strict with the request line and Host header. We silently skip malformed header lines with a negative return from <code>parse_header_line()</code> â€” they don&#39;t cause a 400.\n<strong>Host header is required in HTTP/1.1.</strong> RFC 7230 Section 5.4: &quot;A client MUST send a Host header field in all HTTP/1.1 request messages.&quot; A server &quot;MUST respond with a 400 (Bad Request) status code to any HTTP/1.1 request message that lacks a Host header field.&quot; We enforce this. HTTP/1.0 requests don&#39;t require Host, which is why we only check it when <code>http_minor == 1</code>.</h2>\n<h2 id=\"error-responses\">Error Responses</h2>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m2-error-response-flow.svg\" alt=\"Error Response Decision Tree\"></p>\n<p>Sending the right error response is part of the HTTP contract. Clients â€” especially automated ones â€” use status codes to decide what to do next. A browser receiving 400 won&#39;t retry; a proxy receiving 503 will retry with exponential backoff. Get the codes right.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Send a simple HTTP error response with status code and HTML body.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// `client_fd` is the connection socket.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// `status_code` is e.g. 400, 404, 501.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// `reason` is the reason phrase, e.g. \"Bad Request\".</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// `body` is a short HTML message body.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> send_error_response</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> client_fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> status_code</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">reason</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">body</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2048</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> body_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(body);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    time_t</span><span style=\"color:#E1E4E8\"> now </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> tm </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">gmt </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gmtime</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">now);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> date_str</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    strftime</span><span style=\"color:#E1E4E8\">(date_str, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(date_str), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%a</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#FDAEB7;font-style:italic\"> %</span><span style=\"color:#9ECBFF\">b </span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">Y </span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">H:</span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">M:</span><span style=\"color:#79B8FF\">%S</span><span style=\"color:#9ECBFF\"> GMT\"</span><span style=\"color:#E1E4E8\">, gmt);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> snprintf</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(buf),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"HTTP/1.1 </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#79B8FF\"> %s\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"Content-Type: text/html; charset=utf-8</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"Content-Length: </span><span style=\"color:#79B8FF\">%d\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"Date: </span><span style=\"color:#79B8FF\">%s\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"Connection: close</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        status_code, reason, body_len, date_str, body);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (n </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)n </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(buf)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        write_all</span><span style=\"color:#E1E4E8\">(client_fd, buf, (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)n);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Even if write fails, we close the fd in the caller â€” no resource leak</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Convenience function: send a 400 Bad Request</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> send_400</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> client_fd</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    send_error_response</span><span style=\"color:#E1E4E8\">(client_fd, </span><span style=\"color:#79B8FF\">400</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Bad Request\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;html>&#x3C;body>&#x3C;h1>400 Bad Request&#x3C;/h1>\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;p>The server could not understand the request.&#x3C;/p>\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;/body>&#x3C;/html>\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Convenience function: send a 501 Not Implemented</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> send_501</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> client_fd</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    send_error_response</span><span style=\"color:#E1E4E8\">(client_fd, </span><span style=\"color:#79B8FF\">501</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Not Implemented\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;html>&#x3C;body>&#x3C;h1>501 Not Implemented&#x3C;/h1>\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;p>The server does not support this HTTP method.&#x3C;/p>\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;/body>&#x3C;/html>\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Convenience function: send a 414 URI Too Long</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> send_414</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> client_fd</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    send_error_response</span><span style=\"color:#E1E4E8\">(client_fd, </span><span style=\"color:#79B8FF\">414</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"URI Too Long\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;html>&#x3C;body>&#x3C;h1>414 URI Too Long&#x3C;/h1>\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;p>The requested URI exceeds the server's limit.&#x3C;/p>\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;/body>&#x3C;/html>\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Map the error codes to their triggers:</p>\n<table>\n<thead>\n<tr>\n<th>Status Code</th>\n<th>Trigger</th>\n<th>RFC Reference</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>400 Bad Request</code></td>\n<td>Malformed request line, missing Host header in HTTP/1.1, invalid Content-Length</td>\n<td>RFC 7230 Â§3.1.1</td>\n</tr>\n<tr>\n<td><code>414 URI Too Long</code></td>\n<td>Request-target exceeds 8192 bytes</td>\n<td>RFC 7231 Â§6.5.12</td>\n</tr>\n<tr>\n<td><code>501 Not Implemented</code></td>\n<td>HTTP method is syntactically valid but unrecognized</td>\n<td>RFC 7231 Â§6.6.2</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"head-requests-same-headers-no-body\">HEAD Requests: Same Headers, No Body</h2>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m2-head-vs-get.svg\" alt=\"GET vs HEAD â€” Same Headers, No Body\"></p>\n<p>The HEAD method is semantically identical to GET except the server returns all the same headers but omits the response body. This is defined in RFC 7231 Section 4.3.2: &quot;The HEAD method is identical to GET except that the server MUST NOT send a message body in the response.&quot;\nWhy does HEAD exist? Two primary use cases:</p>\n<ul>\n<li><strong>Cache validation</strong>: a client that cached a file can send HEAD to check if the <code>Last-Modified</code> or <code>ETag</code> changed, without downloading the full file.</li>\n<li><strong>Resource existence checks</strong>: check if a URL returns 200 or 404 without paying for the transfer bandwidth.\nThe implementation consequence for your server: in Milestone 3, where you actually serve files, the file-serving logic will look like this:</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In your file-serving handler (preview â€” implemented in Milestone 3):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Build the response headers the same way for both GET and HEAD.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Then:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (req</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">method </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> METHOD_HEAD) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Only send the body for GET requests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    send_file_body</span><span style=\"color:#E1E4E8\">(client_fd, file_fd, file_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// For HEAD, we fall through â€” headers were already sent, no body.</span></span></code></pre></div>\n<h2 id=\"right-now-in-milestone-239s-parser-all-you-need-to-do-is-correctly-identify-head-and-store-it-as-method_head-the-body-suppression-logic-lives-in-the-response-path-not-the-parser-the-parser39s-job-is-faithfully-representing-what-the-client-asked-for-the-responder-decides-what-to-send-back\">Right now, in Milestone 2&#39;s parser, all you need to do is correctly identify HEAD and store it as <code>METHOD_HEAD</code>. The body-suppression logic lives in the response path, not the parser. The parser&#39;s job is faithfully representing what the client asked for; the responder decides what to send back.</h2>\n<h2 id=\"reading-the-request-body\">Reading the Request Body</h2>\n<p>For POST requests (and future methods like PUT and PATCH), the body appears after the blank line, and its length is specified by <code>Content-Length</code>. Reading the body is a separate step from reading the headers, because:</p>\n<ol>\n<li>The body may not have arrived by the time you parse the headers</li>\n<li>The body can be large â€” potentially megabytes â€” requiring its own loop</li>\n<li>For GET and HEAD, there is no body to read\nHere&#39;s the body reading function:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Read exactly `content_length` bytes of request body from `client_fd`</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// into `body_buf` (which must be at least content_length+1 bytes).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// `already_read` is any body bytes that arrived in the header read (rare but possible).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns 0 on success, -1 on error or client disconnect.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> read_request_body</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> client_fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">body_buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> content_length</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                      const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">overflow</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> overflow_len</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (content_length </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Some body bytes may have arrived in the initial read, after the \\r\\n\\r\\n</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Copy those first if present</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> already </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> overflow_len </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> content_length </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> content_length </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> overflow_len;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (already </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memcpy</span><span style=\"color:#E1E4E8\">(body_buf, overflow, (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)already);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> remaining </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> content_length </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> already;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> total </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> already;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (remaining </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        ssize_t</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> read</span><span style=\"color:#E1E4E8\">(client_fd, body_buf </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> total, (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)remaining);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (n </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Disconnect or error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        total </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)n;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        remaining </span><span style=\"color:#F97583\">-=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)n;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    body_buf</span><span style=\"color:#E1E4E8\">[content_length] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"the-overflow-parameter-handles-a-subtle-case-if-the-client-sent-a-small-request-body-and-it-arrived-in-the-same-recv-call-as-the-headers-common-on-localhost-your-milestone-1-read-loop-may-have-already-read-part-or-all-of-the-body-into-the-header-buffer-the-bytes-after-the-rnrn-offset-are-quotoverflowquot-body-bytes-we-copy-them-first-then-read-the-remainder-from-the-socket-for-this-milestone-you39ll-likely-only-implement-get-and-head-so-body-reading-is-forward-looking-infrastructure-but-building-the-function-now-means-milestone-3-can-simply-call-it-without-revisiting-the-parsing-layer\">The <code>overflow</code> parameter handles a subtle case: if the client sent a small request body and it arrived in the same <code>recv()</code> call as the headers (common on localhost), your Milestone 1 read loop may have already read part or all of the body into the header buffer. The bytes after the <code>\\r\\n\\r\\n</code> offset are &quot;overflow&quot; body bytes. We copy them first, then read the remainder from the socket.\nFor this milestone, you&#39;ll likely only implement GET and HEAD, so body reading is forward-looking infrastructure. But building the function now means Milestone 3 can simply call it without revisiting the parsing layer.</h2>\n<h2 id=\"integration-wiring-the-parser-into-the-accept-loop\">Integration: Wiring the Parser into the Accept Loop</h2>\n<p>Here&#39;s how the parser integrates with the accept loop from Milestone 1. Replace the minimal handling in <code>main()</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Updated connection handler â€” replaces the inner block of the accept loop</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> handle_connection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> client_fd</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> req_buf</span><span style=\"color:#E1E4E8\">[REQUEST_BUF_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> header_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Phase 1: Read raw bytes until \\r\\n\\r\\n (from Milestone 1)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> bytes_read </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> read_http_request</span><span style=\"color:#E1E4E8\">(client_fd, req_buf,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                           REQUEST_BUF_SIZE, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">header_end);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (bytes_read </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> header_end </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Client disconnected or request too large</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(client_fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Phase 2: Parse the raw buffer</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    http_request_t</span><span style=\"color:#E1E4E8\"> req;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> parse_err </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> parse_http_request</span><span style=\"color:#E1E4E8\">(req_buf, (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)bytes_read,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                       header_end, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">req);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (parse_err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Parser returned an HTTP error code</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        switch</span><span style=\"color:#E1E4E8\"> (parse_err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#79B8FF\"> 400</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#B392F0\">send_400</span><span style=\"color:#E1E4E8\">(client_fd); </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#79B8FF\"> 414</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#B392F0\">send_414</span><span style=\"color:#E1E4E8\">(client_fd); </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#79B8FF\"> 501</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#B392F0\">send_501</span><span style=\"color:#E1E4E8\">(client_fd); </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            default</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#B392F0\">send_400</span><span style=\"color:#E1E4E8\">(client_fd); </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(client_fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Phase 3: Log the parsed request</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">method_names</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">\"GET\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"HEAD\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"POST\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"UNKNOWN\"</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">] </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> (HTTP/1.</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">           method_names</span><span style=\"color:#E1E4E8\">[req.method], req.path, req.http_minor);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">host </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> request_get_header</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">req, </span><span style=\"color:#9ECBFF\">\"host\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (host) </span><span style=\"color:#B392F0\">printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Host: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, host);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Phase 4: Dispatch (Milestone 3 will add real file serving here)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For now, send the same hardcoded response as Milestone 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> resp_buf</span><span style=\"color:#E1E4E8\">[MAX_RESPONSE_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> resp_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> build_hardcoded_response</span><span style=\"color:#E1E4E8\">(resp_buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(resp_buf));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (resp_len </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // For HEAD requests: send only headers, no body</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Temporarily: we send the whole thing and fix it in Milestone 3</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        write_all</span><span style=\"color:#E1E4E8\">(client_fd, resp_buf, (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)resp_len);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(client_fd);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"the-three-phase-structure-read-parse-dispatch-is-the-architecture-you39ll-carry-through-milestones-3-and-4-each-phase-has-a-clear-responsibility-and-returns-a-clear-signal-phase-1-gives-you-bytes-phase-2-gives-you-structure-phase-3-gives-you-behavior\">The three-phase structure â€” read, parse, dispatch â€” is the architecture you&#39;ll carry through Milestones 3 and 4. Each phase has a clear responsibility and returns a clear signal. Phase 1 gives you bytes; phase 2 gives you structure; phase 3 gives you behavior.</h2>\n<h2 id=\"testing-the-parser\">Testing the Parser</h2>\n<p>Manual testing with curl and telnet verifies the happy path. For a parser that handles adversarial input, you need to test the error paths too.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test 1: Valid GET request (should succeed)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/index.html</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 2: HEAD request (should receive headers only, no body)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> HEAD</span><span style=\"color:#9ECBFF\"> http://localhost:8080/index.html</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 3: Unsupported method â†’ 501</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> DELETE</span><span style=\"color:#9ECBFF\"> http://localhost:8080/index.html</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 4: Missing HTTP version â†’ 400</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># (telnet lets you type raw HTTP manually)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">telnet</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">GET</span><span style=\"color:#9ECBFF\"> /</span><span style=\"color:#6A737D\">                    # â† just press Enter (no HTTP version)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Host:</span><span style=\"color:#9ECBFF\"> localhost</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 5: No Host header in HTTP/1.1 â†’ 400</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">printf</span><span style=\"color:#9ECBFF\"> \"GET / HTTP/1.1\\r\\n\\r\\n\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> nc</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 6: Very long URI â†’ 414</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Generate an 8KB+ URI and send it</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python3</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"print('GET /' + 'a'*8200 + ' HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n', end='')\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> nc</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 7: Bare LF instead of CRLF (should still work)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">printf</span><span style=\"color:#9ECBFF\"> \"GET / HTTP/1.1\\nHost: localhost\\n\\n\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> nc</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 8: Case-insensitive headers (should work)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#79B8FF\"> -H</span><span style=\"color:#9ECBFF\"> \"CONTENT-TYPE: text/plain\"</span><span style=\"color:#9ECBFF\"> http://localhost:8080/</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Server should log \"content-type: text/plain\" (normalized lowercase)</span></span></code></pre></div>\n<p>For Test 5 (<code>printf</code> with no Host header): you&#39;ll see the <code>printf</code> output piped to <code>nc</code> (netcat), which sends the raw bytes to your server. The <code>\\r\\n</code> in the <code>printf</code> format string is interpreted by the shell, so you get actual CRLF bytes. This is a reliable way to send hand-crafted HTTP requests without a browser normalizing them.\nVerify FD leak behavior remains clean after error-path connections:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Send 100 malformed requests and check FD count doesn't grow</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">seq</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    printf</span><span style=\"color:#9ECBFF\"> \"INVALID\\r\\n\\r\\n\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> nc</span><span style=\"color:#79B8FF\"> -q1</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\">/dev/null</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">pgrep</span><span style=\"color:#9ECBFF\"> http_server</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#9ECBFF\">/fd</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> wc</span><span style=\"color:#79B8FF\"> -l</span></span></code></pre></div>\n<hr>\n<h2 id=\"hardware-soul-what-the-cpu-does-during-parsing\">Hardware Soul: What the CPU Does During Parsing</h2>\n<h2 id=\"the-http-parser-is-the-most-cpu-intensive-component-of-a-simple-http-server-let39s-look-at-what-the-hardware-is-actually-doing-memory-access-pattern-buffer-locality-your-entire-http-request-typically-2002000-bytes-fits-in-l1-cache-3264kb-on-modern-cpus-every-call-to-strchr-memcmp-and-memcpy-within-the-parse-is-operating-on-l1-resident-data-l1-access-latency-is-1ns-the-entire-parse-of-a-typical-request-takes-a-few-microseconds-fast-enough-that-parsing-is-never-the-bottleneck-in-a-well-implemented-server-branch-prediction-during-str_to_lower-the-character-by-character-lowercase-conversion-in-str_to_lower-has-a-branch-if-s-gt-39a39-ampamp-s-lt-39z39-in-http-header-names-like-content-type-the-characters-alternate-between-uppercase-first-letter-of-each-word-and-lowercase-the-branch-predictor-has-a-hard-time-here-the-pattern-is-irregular-modern-cpus-handle-this-with-a-trick-the-compiler-often-generates-simd-instructions-for-short-string-operations-processing-16-bytes-at-once-with-sseavx-the-trick-_mm_sub_epi8-to-subtract-39a39-compare-against-26-the-range-of-uppercase-letters-and-conditionally-add-32-all-in-one-instruction-on-16-bytes-simultaneously-if-you-enable-o2-optimization-in-gcc-the-compiler-may-do-this-automatically-strchr-implementation-the-strchr-call-to-find-the-colon-in-a-header-line-like-content-type-texthtml-scans-up-to-15-bytes-the-glibc-implementation-uses-simd-to-scan-16-or-32-bytes-at-a-time-for-a-15-byte-scan-the-simd-overhead-isn39t-worth-it-and-glibc-falls-back-to-a-byte-loop-but-for-longer-strings-long-header-values-simd-strchr-is-measurably-faster-cache-line-granularity-of-the-struct-your-http_request_t-struct-is-large-with-max_headers-32-entries-of-256-8192-bytes-each-the-struct-approaches-270kb-that-won39t-fit-in-l1-or-l2-cache-however-you-only-access-a-handful-of-headers-in-practice-host-content-length-connection-and-those-are-the-first-few-entries-in-the-array-the-parser-should-fill-headers-in-order-of-appearance-so-the-most-accessed-headers-which-tend-to-appear-early-in-real-requests-are-in-the-earliest-array-slots-resident-in-the-quothotquot-part-of-the-cache-this-is-why-the-earlier-design-note-about-fixed-arrays-matters-a-linked-list-of-dynamically-allocated-header-nodes-would-scatter-them-across-the-heap-causing-cache-misses-when-iterating-the-contiguous-array-keeps-all-headers-in-a-predictable-prefetch-friendly-layout\">The HTTP parser is the most CPU-intensive component of a simple HTTP server. Let&#39;s look at what the hardware is actually doing.\n<strong>Memory access pattern â€” buffer locality.</strong> Your entire HTTP request (typically 200â€“2000 bytes) fits in L1 cache (32â€“64KB on modern CPUs). Every call to <code>strchr()</code>, <code>memcmp()</code>, and <code>memcpy()</code> within the parse is operating on L1-resident data. L1 access latency is ~1ns. The entire parse of a typical request takes a few microseconds â€” fast enough that parsing is never the bottleneck in a well-implemented server.\n<strong>Branch prediction during <code>str_to_lower()</code>.</strong> The character-by-character lowercase conversion in <code>str_to_lower()</code> has a branch: <code>if (*s &gt;= &#39;A&#39; &amp;&amp; *s &lt;= &#39;Z&#39;)</code>. In HTTP header names like <code>Content-Type</code>, the characters alternate between uppercase (first letter of each word) and lowercase. The branch predictor has a hard time here â€” the pattern is irregular. Modern CPUs handle this with a trick: the compiler often generates <strong>SIMD instructions</strong> for short string operations, processing 16 bytes at once with SSE/AVX. The trick: <code>_mm_sub_epi8</code> to subtract &#39;A&#39;, compare against 26 (the range of uppercase letters), and conditionally add 32 â€” all in one instruction on 16 bytes simultaneously. If you enable <code>-O2</code> optimization in GCC, the compiler may do this automatically.\n<strong><code>strchr()</code> implementation.</strong> The <code>strchr()</code> call to find the colon in a header line like <code>Content-Type: text/html</code> scans up to ~15 bytes. The glibc implementation uses SIMD to scan 16 or 32 bytes at a time. For a 15-byte scan, the SIMD overhead isn&#39;t worth it, and glibc falls back to a byte loop. But for longer strings (long header values), SIMD <code>strchr()</code> is measurably faster.\n<strong>Cache line granularity of the struct.</strong> Your <code>http_request_t</code> struct is large â€” with <code>MAX_HEADERS = 32</code> entries of <code>(256 + 8192)</code> bytes each, the struct approaches 270KB. That won&#39;t fit in L1 or L2 cache. However, you only access a handful of headers in practice (Host, Content-Length, Connection), and those are the first few entries in the array. <strong>The parser should fill headers in order of appearance</strong>, so the most-accessed headers (which tend to appear early in real requests) are in the earliest array slots â€” resident in the &quot;hot&quot; part of the cache.\nThis is why the earlier design note about fixed arrays matters: a linked list of dynamically-allocated header nodes would scatter them across the heap, causing cache misses when iterating. The contiguous array keeps all headers in a predictable, prefetch-friendly layout.</h2>\n<h2 id=\"three-level-view-parsing-a-header-line\">Three-Level View: Parsing a Header Line</h2>\n<h2 id=\"take-quotcontent-type-texthtmlquot-and-trace-it-through-all-three-levels-level-1-your-code-parse_header_linequotcontent-type-texthtmlquot-ampreq-runs-strchr-finds-the-colon-at-offset-12-memcpy-copies-quotcontent-typequot-into-h-gtname-str_to_lower-converts-it-to-quotcontent-typequot-strip_ows-copies-quottexthtmlquot-into-h-gtvalue-req-gtheader_count-increments-level-2-oskernel-no-syscalls-during-parsing-the-bytes-are-already-in-your-process39s-user-space-buffer-the-kernel-handed-them-to-you-when-read-returned-the-os-scheduler-may-preempt-your-process-during-the-parse-if-a-higher-priority-process-needs-to-run-but-this-is-transparent-from-the-kernel39s-perspective-you39re-just-a-user-space-process-doing-arithmetic-on-memory-level-3-hardware-the-cpu-is-executing-integer-instructions-on-cache-resident-data-strchr-may-be-vectorized-by-the-compilerglibc-to-use-sse4239s-pcmpeqb-instruction-which-compares-16-bytes-against-the-colon-character-in-a-single-clock-cycle-memcpy-for-12-bytes-compiles-to-a-few-register-moves-no-separate-loop-str_to_lower-for-12-characters-executes-12-iterations-of-the-loop-each-testing-two-conditions-and-conditionally-adding-32-with-branch-prediction-warm-the-alternating-upperlower-pattern-is-learnable-after-a-few-iterations-mispredictions-are-rare-total-hardware-cost-50100-clock-cycles-25ns-at-2ghz\">Take <code>&quot;Content-Type: text/html&quot;</code> and trace it through all three levels.\n<strong>Level 1 â€” Your code:</strong>\n<code>parse_header_line(&quot;Content-Type: text/html&quot;, &amp;req)</code> runs. <code>strchr()</code> finds the colon at offset 12. <code>memcpy()</code> copies &quot;Content-Type&quot; into <code>h-&gt;name</code>. <code>str_to_lower()</code> converts it to &quot;content-type&quot;. <code>strip_ows()</code> copies &quot;text/html&quot; into <code>h-&gt;value</code>. <code>req-&gt;header_count</code> increments.\n<strong>Level 2 â€” OS/Kernel:</strong>\nNo syscalls during parsing. The bytes are already in your process&#39;s user-space buffer â€” the kernel handed them to you when <code>read()</code> returned. The OS scheduler may preempt your process during the parse if a higher-priority process needs to run, but this is transparent. From the kernel&#39;s perspective, you&#39;re just a user-space process doing arithmetic on memory.\n<strong>Level 3 â€” Hardware:</strong>\nThe CPU is executing integer instructions on cache-resident data. <code>strchr()</code> may be vectorized by the compiler/glibc to use SSE4.2&#39;s <code>PCMPEQB</code> instruction, which compares 16 bytes against the colon character in a single clock cycle. <code>memcpy()</code> for 12 bytes compiles to a few register moves â€” no separate loop. <code>str_to_lower()</code> for 12 characters executes 12 iterations of the loop, each testing two conditions and conditionally adding 32. With branch prediction warm (the alternating upper/lower pattern is learnable after a few iterations), mispredictions are rare. Total hardware cost: ~50â€“100 clock cycles, ~25ns at 2GHz.</h2>\n<h2 id=\"design-decisions-parser-architecture\">Design Decisions: Parser Architecture</h2>\n<table>\n<thead>\n<tr>\n<th>Approach</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Used By</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Line-at-a-time (this project) âœ“</strong></td>\n<td>Simple, correct, debuggable</td>\n<td>Two passes (find newlines, then parse)</td>\n<td>Many simple HTTP servers</td>\n</tr>\n<tr>\n<td>Byte-state-machine</td>\n<td>Single pass, handles partial reads elegantly, easily pausable</td>\n<td>Complex to write and debug</td>\n<td>nginx, h2o, Hyper (Rust)</td>\n</tr>\n<tr>\n<td>Regex-based</td>\n<td>Very concise, declarative</td>\n<td>Slow, security-sensitive regex edge cases</td>\n<td>Python&#39;s <code>http.server</code></td>\n</tr>\n<tr>\n<td><code>sscanf()</code>-based</td>\n<td>Simple to write</td>\n<td>No error recovery, buffer overflow risk</td>\n<td>Student projects</td>\n</tr>\n<tr>\n<td>nginx uses a hand-written byte-level state machine â€” every byte transitions a <code>state</code> enum. This lets nginx parse across partial reads without accumulating a complete buffer first: you can call the parser with 50 bytes, pause, receive 50 more bytes, and resume. For our server, the line-at-a-time approach is correct because we accumulate the complete headers in Milestone 1&#39;s read loop before parsing. The state machine approach would be the next optimization if we needed to support very large headers or streaming HTTP/2 frames.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"knowledge-cascade-what-this-unlocks\">Knowledge Cascade: What This Unlocks</h2>\n<p>Understanding HTTP request parsing at this level opens five doors.</p>\n<h3 id=\"1-state-machines-for-protocol-parsing-universal-pattern\">1. State Machines for Protocol Parsing â€” Universal Pattern</h3>\n<p>The state-machine mental model you&#39;re building here is the same one used in every protocol parser ever written. JSON parsers (the JSON spec is a state machine over Unicode characters). SQL lexers (keywords, identifiers, string literals, operators â€” each a state). Compiler front-ends (tokenization is a state machine over source characters; parsing is a state machine over tokens). TLS record layer parsing. DNS wire format parsing. The moment you internalize &quot;a protocol is a grammar, a parser is a state machine over that grammar, and every input byte drives a transition,&quot; you can read any protocol RFC and design a parser for it.</p>\n<h3 id=\"2-case-insensitive-comparison-appearances-across-domains\">2. Case-Insensitive Comparison â€” Appearances Across Domains</h3>\n<p>The case-insensitivity problem you just solved in HTTP header names appears everywhere:</p>\n<ul>\n<li><strong>SQL</strong>: column names and keywords (<code>SELECT</code> = <code>select</code> = <code>SeLeCt</code>). Database engines normalize identifiers on parse, exactly as you did with <code>str_to_lower()</code>.</li>\n<li><strong>DNS</strong>: domain names are case-insensitive (<code>Example.COM</code> = <code>example.com</code>). DNS resolvers canonicalize to lowercase before lookup.</li>\n<li><strong>Windows/macOS filesystems</strong>: paths are case-insensitive but case-preserving (<code>README.md</code> and <code>readme.md</code> refer to the same file). This is why your Milestone 3 path security code must be careful about case normalization.</li>\n<li><strong>Email headers</strong> (MIME): <code>From:</code>, <code>To:</code>, <code>Subject:</code> are case-insensitive, just like HTTP.\nThe general principle: <strong>normalize at ingestion, compare at the canonical form</strong>. One conversion, many cheap comparisons â€” that&#39;s the right tradeoff.</li>\n</ul>\n<h3 id=\"3-security-through-input-validation-transfer-to-injection-prevention\">3. Security Through Input Validation â€” Transfer to Injection Prevention</h3>\n<p>Every security vulnerability begins with trusting input format. The disciplines you&#39;re building here â€” check length before copying, validate charset before using the value, reject on unexpected characters, apply allow-lists rather than block-lists â€” transfer directly to:</p>\n<ul>\n<li><strong>SQL injection prevention</strong>: validating query parameters before interpolation into SQL strings</li>\n<li><strong>XSS prevention</strong>: validating and escaping HTML-context strings before rendering</li>\n<li><strong>Path traversal prevention</strong> (which you&#39;ll build in Milestone 3): validating paths against a root before passing to <code>open()</code></li>\n<li><strong>Format string vulnerabilities</strong>: never passing user-controlled input as the format string to <code>printf()</code>\nThe mental model: <strong>treat all input as adversarial until proven safe</strong>. Your parser proves safety by checking length, checking charset, checking structure, and rejecting anything that doesn&#39;t match the spec. Code that assumes &quot;the client will send valid input&quot; is code that will eventually run in a security incident postmortem.</li>\n</ul>\n<h3 id=\"4-zero-copy-parsing-nginx39s-secret-weapon\">4. Zero-Copy Parsing â€” nginx&#39;s Secret Weapon</h3>\n<p>You noticed that <code>body</code> in <code>http_request_t</code> is a <code>const char*</code> pointer into the original buffer, not a copy. This is the beginning of <strong>zero-copy parsing</strong>. nginx takes this much further: it never copies header names or values at all â€” it stores pairs of <code>{pointer, length}</code> (called <code>ngx_str_t</code>) that point directly into the receive buffer. Header name &quot;Content-Type&quot; in nginx is represented as a 12-byte pointer into the network buffer, not a separate 12-byte allocation.\nThe performance implication: parsing a 500-byte HTTP request in nginx involves zero <code>malloc()</code> calls for the headers themselves. Every <code>malloc()</code> call acquires a lock (in glibc&#39;s default allocator) and is unpredictable in latency. Eliminating them during parsing removes a major source of latency variance. This is why nginx can handle hundreds of thousands of requests per second on a single core.\nOnce you see why copying is expensive, you&#39;ll recognize <code>string_view</code> in C++, <code>&amp;str</code> vs <code>String</code> in Rust, <code>bytes.Buffer</code> in Go, and Python&#39;s <code>memoryview</code> â€” all are language-level tools for &quot;refer to existing bytes without copying.&quot;</p>\n<h3 id=\"5-the-rfc-as-primary-source-reading-specifications\">5. The RFC As Primary Source â€” Reading Specifications</h3>\n<h2 id=\"you39ve-now-implemented-something-directly-against-an-rfc-rfc-7230-this-skill-reading-a-standards-document-and-translating-its-mustshouldmay-language-into-code-is-one-of-the-most-valuable-engineering-skills-that-textbooks-rarely-teach-the-rfc-tells-you-exactly-when-to-return-400-vs-501-exactly-what-ows-means-exactly-which-headers-are-required-now-that-you39ve-done-this-once-you-can-read-rfc-7231-http-semantics-rfc-7232-conditional-requests-which-milestone-3-needs-rfc-7234-caching-and-rfc-7235-authentication-and-know-how-to-implement-them-the-same-reading-skill-applies-to-the-posix-socket-spec-the-tls-13-spec-rfc-8446-the-json-spec-rfc-8259-and-any-other-protocol-you-encounter\">You&#39;ve now implemented something directly against an RFC (RFC 7230). This skill â€” reading a standards document and translating its MUST/SHOULD/MAY language into code â€” is one of the most valuable engineering skills that textbooks rarely teach. The RFC tells you exactly when to return 400 vs. 501, exactly what OWS means, exactly which headers are required. Now that you&#39;ve done this once, you can read RFC 7231 (HTTP semantics), RFC 7232 (conditional requests, which Milestone 3 needs), RFC 7234 (caching), and RFC 7235 (authentication) and know how to implement them. The same reading skill applies to the POSIX socket spec, the TLS 1.3 spec (RFC 8446), the JSON spec (RFC 8259), and any other protocol you encounter.</h2>\n<h2 id=\"common-mistakes-that-will-burn-you\">Common Mistakes That Will Burn You</h2>\n<h2 id=\"1-using-strtok-for-anything-in-your-parser-strtok-modifies-its-input-by-replacing-delimiters-with-39039-it-also-uses-global-state-making-it-unsafe-in-any-context-where-parsing-might-be-interrupted-or-called-from-multiple-threads-use-strchr-memchr-and-explicit-pointer-arithmetic-instead-2-case-sensitive-header-lookup-the-single-most-common-conformance-bug-request_get_headerampreq-quotcontent-lengthquot-fails-to-find-a-header-stored-as-content-length-store-lowercase-at-parse-time-look-up-lowercase-always-when-in-doubt-add-a-debug-assert-that-the-name-you39re-looking-up-is-already-lowercase-3-off-by-one-in-the-crlf-check-when-stripping-the-trailing-r-before-parsing-a-line-check-line_len-gt-0-before-accessing-cursorline_len-1-accessing-cursor-1-on-an-empty-line-is-undefined-behavior-and-on-a-buffer-that-started-at-buf0-it-reads-the-byte-before-your-buffer-4-not-validating-content-length-before-reading-body-if-you-accept-content-length-9999999999-and-try-to-malloc-that-many-bytes-you-crash-if-you-try-to-read-that-many-bytes-you-hold-the-connection-open-indefinitely-apply-a-reasonable-maximum-64mb-for-this-server-and-reject-the-request-with-400-if-the-value-exceeds-it-5-forgetting-bare-lf-handling-telnet-sends-bare-lf-curl-with-http10-on-some-platforms-sends-bare-lf-test-7-in-the-section-above-will-fail-on-your-server-if-you-only-strip-rn-your-line-splitting-code-must-handle-both-rn-and-n-6-not-handling-the-quotno-request-linequot-case-an-empty-connection-client-connects-and-immediately-disconnects-results-in-zero-bytes-read-your-parser-receives-an-empty-buffer-parse_request_line-on-an-empty-string-should-return-400-not-segfault-chasing-a-null-return-from-strchr\"><strong>1. Using <code>strtok()</code> for anything in your parser.</strong>\n<code>strtok()</code> modifies its input by replacing delimiters with <code>&#39;\\0&#39;</code>. It also uses global state, making it unsafe in any context where parsing might be interrupted or called from multiple threads. Use <code>strchr()</code>, <code>memchr()</code>, and explicit pointer arithmetic instead.\n<strong>2. Case-sensitive header lookup.</strong>\nThe single most common conformance bug: <code>request_get_header(&amp;req, &quot;Content-Length&quot;)</code> fails to find a header stored as <code>content-length</code>. Store lowercase at parse time, look up lowercase always. When in doubt, add a <code>DEBUG</code> assert that the name you&#39;re looking up is already lowercase.\n<strong>3. Off-by-one in the CRLF check.</strong>\nWhen stripping the trailing <code>\\r</code> before parsing a line: check <code>line_len &gt; 0</code> <em>before</em> accessing <code>cursor[line_len - 1]</code>. Accessing <code>cursor[-1]</code> on an empty line is undefined behavior â€” and on a buffer that started at <code>buf[0]</code>, it reads the byte before your buffer.\n<strong>4. Not validating Content-Length before reading body.</strong>\nIf you accept <code>Content-Length: 9999999999</code> and try to <code>malloc()</code> that many bytes, you crash. If you try to <code>read()</code> that many bytes, you hold the connection open indefinitely. Apply a reasonable maximum (64MB for this server) and reject the request with 400 if the value exceeds it.\n<strong>5. Forgetting bare LF handling.</strong>\n<code>telnet</code> sends bare LF. <code>curl</code> with <code>--http1.0</code> on some platforms sends bare LF. Test 7 in the section above will fail on your server if you only strip <code>\\r\\n</code>. Your line-splitting code must handle both <code>\\r\\n</code> and <code>\\n</code>.\n<strong>6. Not handling the &quot;no request line&quot; case.</strong>\nAn empty connection â€” client connects and immediately disconnects â€” results in zero bytes read. Your parser receives an empty buffer. <code>parse_request_line()</code> on an empty string should return 400, not segfault chasing a <code>NULL</code> return from <code>strchr()</code>.</h2>\n<h2 id=\"acceptance-criteria-checklist\">Acceptance Criteria Checklist</h2>\n<p>Verify each of these before moving to Milestone 3:</p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> <code>curl http://localhost:8080/</code> logs <code>[GET] / (HTTP/1.1)</code> and <code>Host: localhost</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>curl -X HEAD http://localhost:8080/</code> is parsed as <code>METHOD_HEAD</code> (verify with log output)</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>curl -X DELETE http://localhost:8080/</code> returns <code>HTTP/1.1 501 Not Implemented</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> Malformed request <code>printf &quot;NOTHTTP\\r\\n\\r\\n&quot; | nc localhost 8080</code> returns <code>400 Bad Request</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> Request with 8201-byte URI returns <code>414 URI Too Long</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> HTTP/1.1 request missing <code>Host</code> header returns <code>400 Bad Request</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> Bare-LF request (no <code>\\r</code>) is parsed correctly and returns <code>200 OK</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> Header <code>CONTENT-TYPE: text/plain</code> is stored as <code>content-type: text/plain</code> (case-normalized)</li>\n<li><input disabled=\"\" type=\"checkbox\"> Header value <code>Content-Type:  text/html  </code> (extra spaces) has OWS stripped to <code>text/html</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> FD count after 100 malformed requests equals FD count before (no leaks on error paths)</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>request_get_header(&amp;req, &quot;host&quot;)</code> finds the Host header regardless of client&#39;s capitalization</li>\n</ul>\n<hr>\n<!-- END_MS -->\n\n\n<!-- MS_ID: http-server-basic-m3 -->\n<h1 id=\"milestone-3-static-file-serving\">Milestone 3: Static File Serving</h1>\n<h2 id=\"where-you-are-in-the-system\">Where You Are in the System</h2>\n<p>Your server can now accept TCP connections, read raw bytes off the socket, and parse those bytes into structured <code>http_request_t</code> data. You know the method, the path, the headers. Now for the first time, your server will do something <em>real</em> with that path: go to the filesystem, find a file, and send its contents back across the network.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-satellite-map.svg\" alt=\"HTTP Server Architecture â€” Satellite Map\"></p>\n<h2 id=\"this-is-the-milestone-where-your-http-server-earns-the-label-quotweb-serverquot-when-this-is-done-you-can-point-a-browser-at-your-server-and-see-actual-html-css-images-and-javascript-render-correctly-every-file-serving-feature-a-browser-expects-correct-content-types-conditional-caching-security-boundaries-gets-implemented-here-there-is-one-challenge-in-this-milestone-that-towers-above-all-others-in-importance-it-is-not-mime-type-detection-not-304-not-modified-handling-not-directory-index-serving-it-is-path-security-get-this-wrong-and-your-server-is-not-a-web-server-it39s-a-file-exfiltration-tool-waiting-to-be-exploited\">This is the milestone where your HTTP server earns the label &quot;web server.&quot; When this is done, you can point a browser at your server and see actual HTML, CSS, images, and JavaScript render correctly. Every file-serving feature a browser expects â€” correct content types, conditional caching, security boundaries â€” gets implemented here.\nThere is one challenge in this milestone that towers above all others in importance. It is not MIME type detection, not <code>304 Not Modified</code> handling, not directory index serving. It is <strong>path security</strong>. Get this wrong and your server is not a web server â€” it&#39;s a file exfiltration tool waiting to be exploited.</h2>\n<h2 id=\"the-revelation-string-prefix-checking-is-not-security\">The Revelation: String Prefix Checking Is Not Security</h2>\n<p>Here is the mental model that almost every developer reaches for when they first think about directory traversal prevention:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// \"Surely this is enough?\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strncmp</span><span style=\"color:#E1E4E8\">(resolved_path, document_root, </span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(document_root)) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Path starts with the root, so it must be inside the root. Right?</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    serve_file</span><span style=\"color:#E1E4E8\">(resolved_path);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>This feels airtight. If the path starts with <code>/var/www/html</code>, it must be <em>inside</em> <code>/var/www/html</code>. The logic seems inescapable. Let&#39;s watch it get bypassed in five different ways.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m3-traversal-attacks.svg\" alt=\"Directory Traversal Attack Vectors â€” 5 Bypass Methods\"></p>\n<h3 id=\"attack-1-the-classic-traversal\">Attack 1: The Classic <code>../</code> Traversal</h3>\n<p>A browser requests: <code>GET /../../etc/passwd HTTP/1.1</code>\nYour Milestone 2 parser stores this in <code>req.path</code> as <code>/../../etc/passwd</code>. You prepend the document root:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>/var/www/html + /../../etc/passwd = /var/www/html/../../etc/passwd</code></pre></div>\n<p>Your <code>strncmp</code> check runs: does <code>/var/www/html/../../etc/passwd</code> start with <code>/var/www/html</code>? <strong>Yes, it does.</strong> The string prefix check passes. You call <code>open(&quot;/var/www/html/../../etc/passwd&quot;, O_RDONLY)</code> â€” which the kernel resolves as <code>/etc/passwd</code>. The contents of the system password file stream out across the network.</p>\n<h3 id=\"attack-2-url-encoded-traversal\">Attack 2: URL-Encoded Traversal</h3>\n<p>HTTP allows percent-encoding in URIs. The character <code>.</code> is ASCII 0x2E, which can be encoded as <code>%2e</code>. The character <code>/</code> is ASCII 0x2F, which can be encoded as <code>%2f</code>. So <code>../</code> becomes <code>%2e%2e%2f</code>.\nA browser requests: <code>GET /%2e%2e%2fetc%2fpasswd HTTP/1.1</code>\nIf your parser stores the path without URL-decoding it, <code>strncmp</code> against the root might fail (the path doesn&#39;t look like it traverses). But when you concatenate and open, the kernel doesn&#39;t know about percent-encoding â€” it just opens the literal filename <code>%2e%2e%2fetc%2fpasswd</code>. Your server returns 404 (no such file). So percent-encoding actually harms the attacker here... unless your parser URL-decodes the path first. And a correct HTTP implementation <em>must</em> URL-decode the path before filesystem operations, because <code>%20</code> (space) is a legitimate encoding and <code>GET /my%20files/photo.jpg</code> must work. So the scenario is: your parser correctly URL-decodes <code>%2e%2e%2f</code> to <code>../</code>, and now you&#39;re back to Attack 1.</p>\n<h3 id=\"attack-3-symlink-bypass\">Attack 3: Symlink Bypass</h3>\n<p>Even if the path looks clean â€” <code>/var/www/html/images/photo.jpg</code>, no dots, no traversal â€” a symlink can redirect you. If an attacker (or even a careless administrator) created a symbolic link:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">ln</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> /etc</span><span style=\"color:#9ECBFF\"> /var/www/html/secret</span></span></code></pre></div>\n<p>Then <code>GET /secret/passwd HTTP/1.1</code> resolves as follows: your string prefix check sees <code>/var/www/html/secret/passwd</code>, which starts with <code>/var/www/html</code>. Check passes. You open it. The kernel follows the symlink: <code>/var/www/html/secret</code> points to <code>/etc</code>, so you open <code>/etc/passwd</code>.</p>\n<h3 id=\"attack-4-double-encoding\">Attack 4: Double Encoding</h3>\n<p>Some buggy URL processors decode <code>%25</code> to <code>%</code> in a first pass, then decode <code>%2e</code> to <code>.</code> in a second pass. So <code>%252e%252e%252f</code> (where <code>%25</code> encodes a literal <code>%</code>) decodes to <code>../</code> after two passes. If your URL decoder makes multiple passes or if there&#39;s a secondary layer of decoding (e.g., in a proxy), this attack works.</p>\n<h3 id=\"attack-5-unicode-normalization\">Attack 5: Unicode Normalization</h3>\n<h2 id=\"on-case-insensitive-filesystems-macos-hfs-windows-ntfs-the-path-varwwwhtmletcpasswd-might-resolve-correctly-even-if-your-check-is-case-sensitive-your-prefix-check-fails-different-case-you-reject-it-but-had-you-been-on-a-case-insensitive-system-and-not-normalized-case-this-would-be-an-inconsistency-to-exploit\">On case-insensitive filesystems (macOS HFS+, Windows NTFS), the path <code>/VAR/WWW/HTML/../../ETC/PASSWD</code> might resolve correctly even if your check is case-sensitive. Your prefix check fails (different case), you reject it â€” but had you been on a case-insensitive system and not normalized case, this would be an inconsistency to exploit.</h2>\n<h3 id=\"the-only-safe-approach-canonicalize-first-check-second\">The Only Safe Approach: Canonicalize First, Check Second</h3>\n<p>The lesson from all five attacks is identical: <strong>you cannot reason about path security by looking at the path string.</strong> The path string is attacker-controlled input. The only trustworthy entity is the operating system&#39;s path resolver, which accounts for <code>..</code>, <code>.</code>, symlinks, and all other filesystem indirections.\nThe safe algorithm has exactly three steps, in exactly this order:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>1. URL-decode the request path\n2. Canonicalize via realpath() â†’ get the true absolute filesystem path\n3. Check if the canonicalized path starts with the canonicalized document root</code></pre></div>\n\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m3-path-resolution-flow.svg\" alt=\"URL Path â†’ Filesystem Path â€” The Resolution Pipeline\"></p>\n<p><code>realpath()</code> is the POSIX function that does everything the kernel does when resolving a path: it follows all symlinks, resolves all <code>.</code> and <code>..</code> components, and returns the absolute, canonical path. No matter how many layers of trickery an attacker stacks, <code>realpath()</code> returns what the kernel would actually open.\nHere is the critical constraint: <code>realpath()</code> requires the file to <strong>exist</strong>. If the file doesn&#39;t exist, <code>realpath()</code> returns <code>NULL</code> with <code>errno = ENOENT</code>. This means your path security check and your &quot;file exists&quot; check happen simultaneously â€” which is actually a feature, not a limitation.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// URL-decode a percent-encoded string.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Writes decoded result into `out` (max `out_size` bytes including null terminator).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns 0 on success, -1 if `out` is too small or encoding is invalid.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> url_decode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">src</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">out</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> out_size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">src</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (j </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> >=</span><span style=\"color:#E1E4E8\"> out_size) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Output buffer full</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">src</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '%'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Expect exactly two hex digits following %</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">src</span><span style=\"color:#E1E4E8\">[i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#FFAB70\"> src</span><span style=\"color:#E1E4E8\">[i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            char</span><span style=\"color:#FFAB70\"> hex</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#FFAB70\">src</span><span style=\"color:#E1E4E8\">[i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#FFAB70\">src</span><span style=\"color:#E1E4E8\">[i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">end;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            long</span><span style=\"color:#E1E4E8\"> val </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strtol</span><span style=\"color:#E1E4E8\">(hex, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">end, </span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">end </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Non-hex characters</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (val </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">      // Null byte injection: %00 is a classic attack</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            out</span><span style=\"color:#E1E4E8\">[j</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char</span><span style=\"color:#E1E4E8\">)val;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            i </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">src</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '+'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // '+' means space in application/x-www-form-urlencoded, but NOT in URI paths.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // In URI paths, '+' is a literal plus sign.</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            out</span><span style=\"color:#E1E4E8\">[j</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '+'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            out</span><span style=\"color:#E1E4E8\">[j</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> src</span><span style=\"color:#E1E4E8\">[i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    out</span><span style=\"color:#E1E4E8\">[j] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Note the null byte check: <code>%00</code> decodes to ASCII 0, the null byte. In C, strings are null-terminated, so a path like <code>/etc/passwd%00.html</code> would pass extension-based MIME checking (looks like <code>.html</code>) but when the null byte is decoded, the resulting C string <code>&quot;/etc/passwd\\0.html&quot;</code> passes to <code>open()</code> as <code>&quot;/etc/passwd&quot;</code>. This attack has been used in real vulnerabilities. Rejecting <code>%00</code> is essential.\nNow the complete path resolution and security check:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_PATH_SIZE</span><span style=\"color:#79B8FF\"> 4096</span><span style=\"color:#6A737D\">  // PATH_MAX on Linux</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Resolve a URL path to an absolute filesystem path, verifying it</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// stays within the document root.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// `url_path`      â€” the request path from http_request_t.path (e.g. \"/images/logo.png\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// `document_root` â€” canonicalized document root (from realpath() at startup)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// `resolved_out`  â€” output buffer for the safe filesystem path (PATH_MAX bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns 0 on success (safe path in resolved_out).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns 403 if path escapes document root.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns 404 if path does not exist on the filesystem.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns 400 if path is malformed (URL decode failure, etc.).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> resolve_safe_path</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">url_path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">document_root</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                      char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">resolved_out</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 1: URL-decode the path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> decoded</span><span style=\"color:#E1E4E8\">[MAX_PATH_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">url_decode</span><span style=\"color:#E1E4E8\">(url_path, decoded, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(decoded)) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 400</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Malformed percent-encoding</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 2: Build the raw filesystem path by joining document_root + decoded_path.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // We're not checking security yet â€” this is just string concatenation.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> raw</span><span style=\"color:#E1E4E8\">[MAX_PATH_SIZE </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> snprintf</span><span style=\"color:#E1E4E8\">(raw, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(raw), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, document_root, decoded);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (n </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)n </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(raw)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 400</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Path too long</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 3: Canonicalize via realpath().</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This resolves all symlinks, .., ., and relative components.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Returns NULL if the path does not exist on the filesystem.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">canon </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> realpath</span><span style=\"color:#E1E4E8\">(raw, resolved_out);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (canon </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // ENOENT = path doesn't exist â†’ 404</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // EACCES = permission denied â†’ 403</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Other errors â†’ treat as 404 (don't leak internal details)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ENOENT) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 404</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> EACCES) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 403</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 404</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 4: AFTER canonicalization, verify the resolved path is still</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // inside the document root. This is the security check.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> root_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strlen</span><span style=\"color:#E1E4E8\">(document_root);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strncmp</span><span style=\"color:#E1E4E8\">(resolved_out, document_root, root_len) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Path escaped the document root</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 403</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Ensure it's either exactly the root or the next char is '/'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // (prevents matching /var/www-secret when root is /var/www)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#E1E4E8\"> next </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> resolved_out</span><span style=\"color:#E1E4E8\">[root_len];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (next </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> next </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> '/'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 403</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Safe path is in resolved_out</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>The final check â€” <code>next != &#39;\\0&#39; &amp;&amp; next != &#39;/&#39;</code> â€” prevents a subtle bypass. If your document root is <code>/var/www</code> and the resolved path is <code>/var/www-backup/passwords.txt</code>, a naive prefix check (<code>strncmp(resolved, root, root_len)</code>) would pass. Adding the check that the character after the root prefix must be <code>/</code> or end of string prevents this.\n<strong>Initialize the document root at server startup</strong>, not per-request:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In server initialization â€” run once when the server starts.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Pass this canonical_root to resolve_safe_path() for every request.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> canonical_root</span><span style=\"color:#E1E4E8\">[MAX_PATH_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">realpath</span><span style=\"color:#E1E4E8\">(document_root_arg, canonical_root) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"realpath (document root)\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Can't serve files without a valid document root</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Document root: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, canonical_root);</span></span></code></pre></div>\n<h2 id=\"running-realpath-on-the-document-root-at-startup-canonicalizes-it-once-if-the-document-root-contains-a-symlink-eg-varwwwhtml-datawww-canonical_root-will-contain-datawww-the-true-path-every-per-request-check-then-compares-against-this-true-path\">Running <code>realpath()</code> on the document root at startup canonicalizes it once. If the document root contains a symlink (e.g., <code>/var/www/html</code> â†’ <code>/data/www</code>), <code>canonical_root</code> will contain <code>/data/www</code> â€” the true path. Every per-request check then compares against this true path.</h2>\n<h2 id=\"three-level-view-what-happens-when-you-open-a-file\">Three-Level View: What Happens When You Open a File</h2>\n<p>Take a request for <code>/images/photo.jpg</code> (100KB PNG image) and trace it through all three levels.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m3-file-serving-three-level.svg\" alt=\"Three-Level View: Serving a 100KB PNG File\"></p>\n<h2 id=\"level-1-your-code-you-call-resolve_safe_pathquotimagesphotojpgquot-canonical_root-resolved-which-calls-realpath-and-returns-0-with-resolved-quotvarwwwhtmlimagesphotojpgquot-you-call-statresolved-ampst-to-get-the-file-size-and-modification-time-you-call-openresolved-o_rdonly-to-get-a-file-descriptor-you-call-readfile_fd-buf-buf_size-in-a-loop-to-fill-your-buffer-you-call-writeclient_fd-to-send-the-data-you-call-closefile_fd-level-2-oskernel-realpath-is-implemented-in-user-space-glibc-but-calls-multiple-lstat-syscalls-one-per-path-component-to-check-each-component-for-symlinks-for-varwwwhtmlimagesphotojpg-that39s-approximately-five-lstat-calls-open-triggers-the-kernel39s-vfs-virtual-file-system-layer-the-kernel-looks-up-the-file-in-the-directory-entry-cache-dcache-if-varwwwhtmlimages-has-been-recently-accessed-the-directory-entry-is-already-in-kernel-memory-hot-the-kernel-also-checks-the-inode-cache-icache-the-inode-stores-the-file39s-metadata-size-permissions-timestamps-on-a-busy-server-both-caches-are-hot-and-open-returns-in-microseconds-without-touching-disk-read-triggers-the-kernel39s-page-cache-lookup-the-page-cache-is-a-portion-of-ram-that-holds-recently-read-disk-blocks-if-photojpg-was-read-recently-its-pages-are-in-the-page-cache-and-read-is-just-a-memcpy-from-kernel-memory-to-your-user-space-buffer-if-the-file-is-cold-not-cached-the-kernel-issues-disk-io-an-asynchronous-read-from-the-block-device-and-your-process-blocks-until-the-data-arrives-level-3-hardware-for-a-cache-hot-file-your-read-triggers-a-context-switch-from-user-mode-to-kernel-mode-the-read-syscall-the-kernel-finds-the-page-cache-entries-for-photojpg-copies-them-into-your-buffer-via-memory-to-memory-copy-for-a-100kb-file-this-is-copying-25-4kb-pages-at-memory-bandwidth-of-20-gbs-ddr4-100kb-copies-in-5-microseconds-context-switch-overhead-is-12-microseconds-total-7-microseconds-for-a-cached-read-for-a-cold-file-the-kernel-submits-an-io-request-to-the-storage-controller-an-nvme-ssd-responds-in-100-microseconds-a-spinning-hdd-in-5-milliseconds-your-process-is-moved-off-the-cpu-runqueue-into-a-quotwaiting-for-ioquot-state-the-cpu-runs-other-processes-when-the-storage-interrupt-fires-the-kernel-moves-your-process-back-to-runnable-this-is-the-10ms-vs-100ns-gap-100000-difference-between-memory-and-disk-that-the-page-cache-exists-to-bridge\"><strong>Level 1 â€” Your code:</strong>\nYou call <code>resolve_safe_path(&quot;/images/photo.jpg&quot;, canonical_root, resolved)</code>, which calls <code>realpath()</code> and returns 0 with <code>resolved = &quot;/var/www/html/images/photo.jpg&quot;</code>. You call <code>stat(resolved, &amp;st)</code> to get the file size and modification time. You call <code>open(resolved, O_RDONLY)</code> to get a file descriptor. You call <code>read(file_fd, buf, buf_size)</code> in a loop to fill your buffer. You call <code>write(client_fd, ...)</code> to send the data. You call <code>close(file_fd)</code>.\n<strong>Level 2 â€” OS/Kernel:</strong>\n<code>realpath()</code> is implemented in user-space (glibc) but calls multiple <code>lstat()</code> syscalls â€” one per path component â€” to check each component for symlinks. For <code>/var/www/html/images/photo.jpg</code>, that&#39;s approximately five <code>lstat()</code> calls.\n<code>open()</code> triggers the kernel&#39;s VFS (Virtual File System) layer. The kernel looks up the file in the directory entry cache (<strong>dcache</strong>) â€” if <code>/var/www/html/images</code> has been recently accessed, the directory entry is already in kernel memory (hot). The kernel also checks the <strong>inode cache</strong> (icache): the inode stores the file&#39;s metadata (size, permissions, timestamps). On a busy server, both caches are hot and <code>open()</code> returns in microseconds without touching disk.\n<code>read()</code> triggers the kernel&#39;s <strong>page cache</strong> lookup. The page cache is a portion of RAM that holds recently-read disk blocks. If <code>photo.jpg</code> was read recently, its pages are in the page cache and <code>read()</code> is just a <code>memcpy()</code> from kernel memory to your user-space buffer. If the file is cold (not cached), the kernel issues disk I/O â€” an asynchronous read from the block device â€” and your process blocks until the data arrives.\n<strong>Level 3 â€” Hardware:</strong>\nFor a cache-hot file: your <code>read()</code> triggers a context switch from user mode to kernel mode (the <code>read</code> syscall). The kernel finds the page cache entries for <code>photo.jpg</code>, copies them into your buffer via memory-to-memory copy. For a 100KB file, this is copying ~25 4KB pages. At memory bandwidth of ~20 GB/s (DDR4), 100KB copies in ~5 microseconds. Context switch overhead is ~1â€“2 microseconds. Total: ~7 microseconds for a cached read.\nFor a cold file: the kernel submits an I/O request to the storage controller. An NVMe SSD responds in ~100 microseconds; a spinning HDD in ~5 milliseconds. Your process is moved off the CPU runqueue into a &quot;waiting for I/O&quot; state. The CPU runs other processes. When the storage interrupt fires, the kernel moves your process back to runnable. This is the 10ms vs 100ns gap â€” 100,000Ã— difference between memory and disk â€” that the page cache exists to bridge.</h2>\n<h2 id=\"mime-types-telling-browsers-how-to-interpret-bytes\">MIME Types: Telling Browsers How to Interpret Bytes</h2>\n<p>Raw bytes have no intrinsic meaning. A sequence of bytes could be a UTF-8 HTML document, a JPEG image, a JavaScript program, or binary executable code. The browser has no way to tell which kind of content it received unless the server tells it. The <strong>Content-Type header</strong> carries this information.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m3-mime-type-map.svg\" alt=\"File Extension â†’ MIME Type Mapping\"></p>\n<p>MIME (<strong>Multipurpose Internet Mail Extensions</strong>) is a system originally designed for email attachments that HTTP adopted. A MIME type has the form <code>type/subtype</code>, optionally with parameters. <code>text/html; charset=utf-8</code> means &quot;the type is text, the subtype is HTML, and the character encoding is UTF-8.&quot; The browser uses this to decide whether to render HTML, display an image, execute JavaScript, or prompt a download dialog.\nGetting MIME types wrong causes real user-visible failures:</p>\n<ul>\n<li>Serving <code>.js</code> files as <code>text/plain</code> causes browsers to refuse to execute the script (modern browsers block cross-origin scripts with wrong MIME types â€” <strong>MIME-sniffing</strong> protection)</li>\n<li>Serving <code>.css</code> as <code>text/plain</code> causes browsers to ignore the stylesheet</li>\n<li>Serving images as <code>application/octet-stream</code> causes download prompts instead of display\nThe cleanest implementation is a sorted array of <code>{extension, mime_type}</code> pairs that you search with binary search or a simple linear scan. With only ~15 extensions to support, linear scan is fast enough (15 comparisons, all L1-resident):</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">extension;</span><span style=\"color:#6A737D\">   // e.g. \".html\" (with leading dot, lowercase)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">mime_type;</span><span style=\"color:#6A737D\">   // e.g. \"text/html; charset=utf-8\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">mime_entry_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MIME type table â€” searched linearly, so order doesn't matter.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Extensions must be lowercase (we normalize before lookup).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#79B8FF\"> mime_entry_t</span><span style=\"color:#E1E4E8\"> MIME_TABLE</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { </span><span style=\"color:#9ECBFF\">\".html\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"text/html; charset=utf-8\"</span><span style=\"color:#E1E4E8\">       },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { </span><span style=\"color:#9ECBFF\">\".htm\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#9ECBFF\">\"text/html; charset=utf-8\"</span><span style=\"color:#E1E4E8\">       },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { </span><span style=\"color:#9ECBFF\">\".css\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#9ECBFF\">\"text/css\"</span><span style=\"color:#E1E4E8\">                        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { </span><span style=\"color:#9ECBFF\">\".js\"</span><span style=\"color:#E1E4E8\">,   </span><span style=\"color:#9ECBFF\">\"application/javascript\"</span><span style=\"color:#E1E4E8\">          },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { </span><span style=\"color:#9ECBFF\">\".json\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"application/json\"</span><span style=\"color:#E1E4E8\">                },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { </span><span style=\"color:#9ECBFF\">\".png\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#9ECBFF\">\"image/png\"</span><span style=\"color:#E1E4E8\">                       },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { </span><span style=\"color:#9ECBFF\">\".jpg\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#9ECBFF\">\"image/jpeg\"</span><span style=\"color:#E1E4E8\">                      },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { </span><span style=\"color:#9ECBFF\">\".jpeg\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"image/jpeg\"</span><span style=\"color:#E1E4E8\">                      },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { </span><span style=\"color:#9ECBFF\">\".gif\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#9ECBFF\">\"image/gif\"</span><span style=\"color:#E1E4E8\">                       },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { </span><span style=\"color:#9ECBFF\">\".svg\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#9ECBFF\">\"image/svg+xml\"</span><span style=\"color:#E1E4E8\">                   },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { </span><span style=\"color:#9ECBFF\">\".txt\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#9ECBFF\">\"text/plain; charset=utf-8\"</span><span style=\"color:#E1E4E8\">       },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { </span><span style=\"color:#9ECBFF\">\".pdf\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#9ECBFF\">\"application/pdf\"</span><span style=\"color:#E1E4E8\">                 },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { </span><span style=\"color:#9ECBFF\">\".ico\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#9ECBFF\">\"image/x-icon\"</span><span style=\"color:#E1E4E8\">                    },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { </span><span style=\"color:#9ECBFF\">\".xml\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#9ECBFF\">\"application/xml\"</span><span style=\"color:#E1E4E8\">                 },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { </span><span style=\"color:#9ECBFF\">\".webp\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"image/webp\"</span><span style=\"color:#E1E4E8\">                      },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> MIME_TABLE_LEN </span><span style=\"color:#F97583\">=</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(MIME_TABLE) </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">MIME_TABLE</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Look up the MIME type for a filesystem path.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns a MIME type string, or \"application/octet-stream\" as the fallback.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">mime_type_for_path</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find the last '.' in the filename component</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">last_dot </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strrchr</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#9ECBFF\">'.'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (last_dot </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"application/octet-stream\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Normalize extension to lowercase for comparison</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> ext_lower</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> ext_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strlen</span><span style=\"color:#E1E4E8\">(last_dot);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ext_len </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ext_lower)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"application/octet-stream\"</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Absurdly long extension</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> ext_len; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> last_dot</span><span style=\"color:#E1E4E8\">[i];</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        ext_lower</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (c </span><span style=\"color:#F97583\">>=</span><span style=\"color:#9ECBFF\"> 'A'</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#9ECBFF\"> 'Z'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char</span><span style=\"color:#E1E4E8\">)(c </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> c;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    ext_lower</span><span style=\"color:#E1E4E8\">[ext_len] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Linear search â€” only ~15 entries, all in L1 cache</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> MIME_TABLE_LEN; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strcmp</span><span style=\"color:#E1E4E8\">(ext_lower, </span><span style=\"color:#FFAB70\">MIME_TABLE</span><span style=\"color:#E1E4E8\">[i].extension) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#FFAB70\"> MIME_TABLE</span><span style=\"color:#E1E4E8\">[i].mime_type;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#9ECBFF\"> \"application/octet-stream\"</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Unknown extension: trigger download</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"strrchr-string-reverse-character-find-finds-the-last-occurrence-of-a-character-in-a-string-for-a-path-like-varwwwhtmlstylesmainmincss-there-are-two-dots-we-want-the-last-one-to-get-css-not-min-using-strrchr-instead-of-strchr-handles-this-correctly-applicationoctet-stream-is-the-correct-mime-type-for-quoti-don39t-know-what-this-isquot-browsers-respond-by-presenting-a-download-dialog-which-is-safer-than-trying-to-execute-or-display-unknown-binary-content\"><code>strrchr()</code> (string reverse character-find) finds the <em>last</em> occurrence of a character in a string. For a path like <code>/var/www/html/styles/main.min.css</code>, there are two dots. We want the <em>last</em> one to get <code>.css</code>, not <code>.min</code>. Using <code>strrchr()</code> instead of <code>strchr()</code> handles this correctly.\n<code>application/octet-stream</code> is the correct MIME type for &quot;I don&#39;t know what this is.&quot; Browsers respond by presenting a download dialog, which is safer than trying to execute or display unknown binary content.</h2>\n<h2 id=\"conditional-requests-if-modified-since-and-304-not-modified\">Conditional Requests: If-Modified-Since and 304 Not Modified</h2>\n<p>Once you understand that browsers and CDNs cache files, a new problem emerges: how does a browser know if the cached copy is still fresh? It could send <code>GET /logo.png</code> every time a user visits the page â€” but that&#39;s wasteful if the image hasn&#39;t changed in months.\nHTTP solves this with <strong>conditional requests</strong>. The protocol defines a handshake:</p>\n<ol>\n<li>First request: server sends the file with a <code>Last-Modified</code> header indicating when the file was last changed</li>\n<li>Subsequent requests: client sends <code>If-Modified-Since: &lt;timestamp&gt;</code> asking &quot;has this changed since this time?&quot;</li>\n<li>If unchanged: server returns <code>304 Not Modified</code> with no body (just headers), saving bandwidth</li>\n<li>If changed: server returns <code>200 OK</code> with the new file\n{{DIAGRAM:diag-m3-conditional-request-flow}}\nThis optimization is significant in practice. For a page with 20 cacheable assets (CSS, JS, images), a returning visitor&#39;s browser might send 20 conditional requests. If none of the assets changed, all 20 get <code>304</code> responses. The browser loads the page entirely from cache â€” the responses contain no body bytes. Total bandwidth: a few kilobytes of headers vs. potentially megabytes of assets.\nThe filesystem gives you the modification time of every file through <code>stat()</code>. The <code>struct stat</code> field <code>st_mtim</code> (or <code>st_mtime</code> on some platforms) contains the last modification time as a Unix timestamp (seconds since January 1, 1970 UTC).\nThe HTTP <code>Last-Modified</code> and <code>If-Modified-Since</code> header format is <strong>RFC 7231 HTTP-date format</strong>: <code>&quot;Day, DD Mon YYYY HH:MM:SS GMT&quot;</code>. This is the same format we used for the <code>Date</code> header in Milestone 1.</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Format a time_t as an HTTP-date string.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Writes into `buf` (at least 64 bytes).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns 0 on success, -1 on failure.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> format_http_date</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">time_t</span><span style=\"color:#FFAB70\"> t</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> buf_size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> tm </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">gmt </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gmtime</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">t);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (gmt </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strftime</span><span style=\"color:#E1E4E8\">(buf, buf_size, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%a</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#FDAEB7;font-style:italic\"> %</span><span style=\"color:#9ECBFF\">b </span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">Y </span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">H:</span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">M:</span><span style=\"color:#79B8FF\">%S</span><span style=\"color:#9ECBFF\"> GMT\"</span><span style=\"color:#E1E4E8\">, gmt);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (n </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> :</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parse an HTTP-date string back to time_t.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns the parsed time on success, (time_t)-1 on failure.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">time_t</span><span style=\"color:#B392F0\"> parse_http_date</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">date_str</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> tm tm;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tm, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(tm));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // strptime parses a date string according to a format, inverse of strftime.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // The %a (weekday), %d (day), %b (month name), %Y (year), %H:%M:%S (time)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // format matches the standard HTTP-date format.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strptime</span><span style=\"color:#E1E4E8\">(date_str, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%a</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#FDAEB7;font-style:italic\"> %</span><span style=\"color:#9ECBFF\">b </span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">Y </span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">H:</span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">M:</span><span style=\"color:#79B8FF\">%S</span><span style=\"color:#9ECBFF\"> GMT\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tm);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (result </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">result </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">time_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Parse failed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // timegm() converts struct tm (in UTC/GMT) to time_t.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // mktime() assumes local time â€” WRONG for HTTP dates which are always UTC.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> timegm</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tm);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><code>timegm()</code> is the inverse of <code>gmtime()</code>: it converts a <code>struct tm</code> interpreted as UTC into a <code>time_t</code>. <strong>Do not use <code>mktime()</code> here.</strong> <code>mktime()</code> interprets <code>struct tm</code> as local time â€” if your server is in a non-UTC timezone, <code>mktime()</code> will give you the wrong result, causing incorrect cache validation. HTTP dates are always UTC. <code>timegm()</code> is available on Linux and macOS (as a BSD extension); if you need full POSIX portability, set the <code>TZ</code> environment variable temporarily or use a manual calculation.\nNow the conditional request check:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Check whether a conditional GET/HEAD should return 304 Not Modified.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// `file_mtime` is the file's last modification time (from stat).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// `req` is the parsed HTTP request.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns 1 if 304 should be sent, 0 if the full response should be sent.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> should_send_304</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> http_request_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">req</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">time_t</span><span style=\"color:#FFAB70\"> file_mtime</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">ims </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> request_get_header</span><span style=\"color:#E1E4E8\">(req, </span><span style=\"color:#9ECBFF\">\"if-modified-since\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ims </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // No conditional header: send full response</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    time_t</span><span style=\"color:#E1E4E8\"> client_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> parse_http_date</span><span style=\"color:#E1E4E8\">(ims);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (client_time </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">time_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Can't parse: send full response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // The file has not been modified if its mtime &#x3C;= the time the client</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // says it last received the file. Use &#x3C;= not &#x3C;, because HTTP-date</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // resolution is one second â€” a file modified in the same second as</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // the If-Modified-Since timestamp is considered unchanged.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (file_mtime </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> client_time) </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> :</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"the-lt-comparison-handles-the-one-second-granularity-of-http-date-format-if-a-file-was-modified-at-timestamp-t-the-server-sends-last-modified-ltt-formatted-to-second-precisiongt-on-the-next-request-the-client-sends-if-modified-since-lttgt-if-you-used-lt-instead-of-lt-you39d-send-a-full-200-response-for-a-file-modified-at-exactly-the-cached-timestamp-wasting-bandwidth-and-incorrectly-indicating-the-file-changed\">The <code>&lt;=</code> comparison handles the one-second granularity of HTTP-date format. If a file was modified at timestamp T, the server sends <code>Last-Modified: &lt;T formatted to second precision&gt;</code>. On the next request, the client sends <code>If-Modified-Since: &lt;T&gt;</code>. If you used <code>&lt;</code> instead of <code>&lt;=</code>, you&#39;d send a full <code>200</code> response for a file modified at exactly the cached timestamp â€” wasting bandwidth and incorrectly indicating the file changed.</h2>\n<h2 id=\"directory-requests-and-index-files\">Directory Requests and Index Files</h2>\n<p>When a browser requests a URL ending in <code>/</code> â€” or a URL that maps to a directory â€” your server has a choice: list the directory contents (a <strong>directory listing</strong>), serve a default file, or refuse. Modern practice avoids directory listings in production (they expose file structure to attackers). The conventional behavior is:</p>\n<ol>\n<li>If the path maps to a directory and <code>index.html</code> exists inside it â†’ serve <code>index.html</code></li>\n<li>If the path maps to a directory and <code>index.html</code> does not exist â†’ return 403 Forbidden</li>\n<li>If the path maps to a regular file â†’ serve it normally</li>\n</ol>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m3-directory-index-logic.svg\" alt=\"Directory Request Handling â€” Decision Flowchart\"></p>\n<p>The detection uses <code>stat()</code> and the <code>S_ISDIR()</code> macro:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Detect if a path is a directory and append \"/index.html\" if so.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Modifies `resolved_path` in-place (must have room for appending \"/index.html\").</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   0 = regular file, serve it</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   1 = was a directory, index.html appended, re-stat needed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//  -1 = directory with no index.html â†’ send 403</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//  -2 = stat() failed â†’ send 404</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> handle_directory_path</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">resolved_path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> path_buf_size</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                          struct</span><span style=\"color:#E1E4E8\"> stat </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">st</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">S_ISDIR</span><span style=\"color:#E1E4E8\">(st->st_mode)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Regular file â€” serve directly</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // It's a directory â€” try to append /index.html</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> current_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strlen</span><span style=\"color:#E1E4E8\">(resolved_path);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">index_suffix </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"/index.html\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> suffix_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strlen</span><span style=\"color:#E1E4E8\">(index_suffix);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (current_len </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> suffix_len </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> ></span><span style=\"color:#E1E4E8\"> path_buf_size) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // No room to append â€” refuse</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Ensure path doesn't already end with '/'</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">resolved_path</span><span style=\"color:#E1E4E8\">[current_len </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '/'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Overwrite the trailing slash</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        strncat</span><span style=\"color:#E1E4E8\">(resolved_path </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> current_len </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                index_suffix, path_buf_size </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> current_len);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        strncat</span><span style=\"color:#E1E4E8\">(resolved_path </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> current_len,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                index_suffix, path_buf_size </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> current_len </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Re-stat the index.html path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">stat</span><span style=\"color:#E1E4E8\">(resolved_path, st) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ENOENT) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // No index.html â†’ 403</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Other error â†’ 404</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">S_ISDIR</span><span style=\"color:#E1E4E8\">(st->st_mode)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // index.html is itself a directory? â†’ 403</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // index.html found and stat'd â€” proceed to serve</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"s_isdirst-gtst_mode-the-stat-syscall-fills-a-struct-stat-with-file-metadata-the-st_mode-field-is-a-bitmask-encoding-both-the-file-type-and-permission-bits-s_isdir-is-a-posix-macro-that-extracts-the-file-type-bits-and-checks-if-they-indicate-a-directory-similarly-s_isreg-checks-for-regular-files-s_islnk-for-symbolic-links-though-stat-follows-symlinks-automatically-use-lstat-to-detect-symlinks-without-following-them\"><code>S_ISDIR(st-&gt;st_mode)</code> â€” the <code>stat()</code> syscall fills a <code>struct stat</code> with file metadata. The <code>st_mode</code> field is a bitmask encoding both the file type and permission bits. <code>S_ISDIR()</code> is a POSIX macro that extracts the file-type bits and checks if they indicate a directory. Similarly, <code>S_ISREG()</code> checks for regular files, <code>S_ISLNK()</code> for symbolic links (though <code>stat()</code> follows symlinks automatically â€” use <code>lstat()</code> to detect symlinks without following them).</h2>\n<h2 id=\"the-complete-file-serving-function\">The Complete File Serving Function</h2>\n<p>Now assemble all the pieces into the function that handles an HTTP request end-to-end: path resolution â†’ security check â†’ directory handling â†’ conditional request check â†’ response assembly â†’ file transfer.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m3-response-assembly.svg\" alt=\"Complete HTTP Response Assembly â€” Byte by Byte\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Send a complete HTTP error response (reused from Milestone 2)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// â€” defined in your existing codebase.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> send_error_response</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> client_fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> status_code</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">reason</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">body</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Send the complete HTTP response for a file request.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Handles GET and HEAD methods, conditional requests, all error cases.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// `req`           â€” the parsed HTTP request (from Milestone 2)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// `client_fd`     â€” the connection socket to write the response to</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// `canonical_root`â€” the server's canonicalized document root</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> serve_static_file</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> http_request_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">req</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> client_fd</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">canonical_root</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // â”€â”€ Phase 1: Resolve and validate the filesystem path â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> resolved</span><span style=\"color:#E1E4E8\">[MAX_PATH_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> resolve_status </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> resolve_safe_path</span><span style=\"color:#E1E4E8\">(req->path, canonical_root, resolved);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (resolve_status </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 400</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        send_error_response</span><span style=\"color:#E1E4E8\">(client_fd, </span><span style=\"color:#79B8FF\">400</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Bad Request\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"&#x3C;html>&#x3C;body>&#x3C;h1>400 Bad Request&#x3C;/h1>\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"&#x3C;p>Malformed request path.&#x3C;/p>&#x3C;/body>&#x3C;/html>\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (resolve_status </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 403</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        send_error_response</span><span style=\"color:#E1E4E8\">(client_fd, </span><span style=\"color:#79B8FF\">403</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Forbidden\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"&#x3C;html>&#x3C;body>&#x3C;h1>403 Forbidden&#x3C;/h1>\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"&#x3C;p>Access to the requested resource is not permitted.&#x3C;/p>\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"&#x3C;/body>&#x3C;/html>\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (resolve_status </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 404</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        send_error_response</span><span style=\"color:#E1E4E8\">(client_fd, </span><span style=\"color:#79B8FF\">404</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Not Found\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"&#x3C;html>&#x3C;body>&#x3C;h1>404 Not Found&#x3C;/h1>\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"&#x3C;p>The requested resource could not be found.&#x3C;/p>\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"&#x3C;/body>&#x3C;/html>\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // â”€â”€ Phase 2: Stat the file â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> stat st;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">stat</span><span style=\"color:#E1E4E8\">(resolved, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">st) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ENOENT) </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> 404</span><span style=\"color:#F97583\"> :</span><span style=\"color:#79B8FF\"> 403</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">reason </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (status </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 404</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"Not Found\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"Forbidden\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">body </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (status </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 404</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            ?</span><span style=\"color:#9ECBFF\"> \"&#x3C;html>&#x3C;body>&#x3C;h1>404 Not Found&#x3C;/h1>&#x3C;/body>&#x3C;/html>\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            :</span><span style=\"color:#9ECBFF\"> \"&#x3C;html>&#x3C;body>&#x3C;h1>403 Forbidden&#x3C;/h1>&#x3C;/body>&#x3C;/html>\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        send_error_response</span><span style=\"color:#E1E4E8\">(client_fd, status, reason, body);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // â”€â”€ Phase 3: Handle directory paths â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> dir_result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> handle_directory_path</span><span style=\"color:#E1E4E8\">(resolved, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(resolved), </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">st);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (dir_result </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // -1: directory with no index.html</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // -2: stat failed</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        send_error_response</span><span style=\"color:#E1E4E8\">(client_fd, </span><span style=\"color:#79B8FF\">403</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Forbidden\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"&#x3C;html>&#x3C;body>&#x3C;h1>403 Forbidden&#x3C;/h1>\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"&#x3C;p>Directory listing is not permitted.&#x3C;/p>&#x3C;/body>&#x3C;/html>\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If dir_result == 1, resolved now points to index.html and st is re-stat'd.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify it's a regular file (not a special file like /dev/random)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">S_ISREG</span><span style=\"color:#E1E4E8\">(st.st_mode)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        send_error_response</span><span style=\"color:#E1E4E8\">(client_fd, </span><span style=\"color:#79B8FF\">403</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Forbidden\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"&#x3C;html>&#x3C;body>&#x3C;h1>403 Forbidden&#x3C;/h1>&#x3C;/body>&#x3C;/html>\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // â”€â”€ Phase 4: Determine MIME type â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">mime_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> mime_type_for_path</span><span style=\"color:#E1E4E8\">(resolved);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // â”€â”€ Phase 5: Check conditional request (If-Modified-Since) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    time_t</span><span style=\"color:#E1E4E8\"> file_mtime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> st.st_mtime;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">should_send_304</span><span style=\"color:#E1E4E8\">(req, file_mtime)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Build 304 response â€” headers only, no body</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#FFAB70\"> date_str</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#FFAB70\"> lm_str</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        format_http_date</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">), date_str, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(date_str));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        format_http_date</span><span style=\"color:#E1E4E8\">(file_mtime, lm_str, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(lm_str));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#FFAB70\"> resp</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> snprintf</span><span style=\"color:#E1E4E8\">(resp, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(resp),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"HTTP/1.1 304 Not Modified</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Last-Modified: </span><span style=\"color:#79B8FF\">%s\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Date: </span><span style=\"color:#79B8FF\">%s\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Connection: </span><span style=\"color:#79B8FF\">%s\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            lm_str, date_str,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            req->keep_alive </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"keep-alive\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"close\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (n </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">write_all</span><span style=\"color:#E1E4E8\">(client_fd, resp, (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)n);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // â”€â”€ Phase 6: Open the file â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> file_fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(resolved, O_RDONLY);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (file_fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ENOENT) </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> 404</span><span style=\"color:#F97583\"> :</span><span style=\"color:#79B8FF\"> 403</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">reason </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (status </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 404</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"Not Found\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"Forbidden\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">body </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (status </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 404</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            ?</span><span style=\"color:#9ECBFF\"> \"&#x3C;html>&#x3C;body>&#x3C;h1>404 Not Found&#x3C;/h1>&#x3C;/body>&#x3C;/html>\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            :</span><span style=\"color:#9ECBFF\"> \"&#x3C;html>&#x3C;body>&#x3C;h1>403 Forbidden&#x3C;/h1>&#x3C;/body>&#x3C;/html>\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        send_error_response</span><span style=\"color:#E1E4E8\">(client_fd, status, reason, body);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // â”€â”€ Phase 7: Build and send response headers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> date_str</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> lm_str</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    format_http_date</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">), date_str, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(date_str));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    format_http_date</span><span style=\"color:#E1E4E8\">(file_mtime, lm_str, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(lm_str));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#E1E4E8\"> file_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)st.st_size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> header_buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2048</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> header_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> snprintf</span><span style=\"color:#E1E4E8\">(header_buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(header_buf),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"HTTP/1.1 200 OK</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"Content-Type: </span><span style=\"color:#79B8FF\">%s\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"Content-Length: </span><span style=\"color:#79B8FF\">%ld\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"Last-Modified: </span><span style=\"color:#79B8FF\">%s\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"Date: </span><span style=\"color:#79B8FF\">%s\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"Connection: </span><span style=\"color:#79B8FF\">%s\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        mime_type,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        file_size,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lm_str,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        date_str,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        req->keep_alive </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"keep-alive\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"close\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (header_len </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)header_len </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(header_buf)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(file_fd);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        send_error_response</span><span style=\"color:#E1E4E8\">(client_fd, </span><span style=\"color:#79B8FF\">500</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Internal Server Error\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"&#x3C;html>&#x3C;body>&#x3C;h1>500 Internal Server Error&#x3C;/h1>&#x3C;/body>&#x3C;/html>\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_all</span><span style=\"color:#E1E4E8\">(client_fd, header_buf, (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)header_len) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(file_fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Client disconnected</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // â”€â”€ Phase 8: Send the file body (skip for HEAD requests) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (req->method </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> METHOD_HEAD) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(file_fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // HEAD: headers sent, no body</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Transfer file contents in chunks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> io_buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">65536</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">  // 64KB I/O buffer â€” matches typical page cache read size</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> bytes_read;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> ((bytes_read </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> read</span><span style=\"color:#E1E4E8\">(file_fd, io_buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(io_buf))) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_all</span><span style=\"color:#E1E4E8\">(client_fd, io_buf, (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)bytes_read) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Client disconnected mid-transfer â€” just stop</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(file_fd);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"the-64kb-buffer-choice\">The 64KB Buffer Choice</h3>\n<p>The I/O buffer size of 65536 bytes (64KB) is not arbitrary. Several hardware and OS factors converge at this size:</p>\n<ul>\n<li><strong>Page cache granularity</strong>: The kernel reads files in units of its memory pages (4KB on x86). The <code>read()</code> syscall, when serving from the page cache, can transfer up to the buffer size in one call. 64KB = 16 pages â€” a good batch size.</li>\n<li><strong>TCP send buffer</strong>: The kernel&#39;s TCP send buffer default is typically 87KB. Sending 64KB at a time keeps the pipeline full without overflowing.</li>\n<li><strong>L1 cache pressure</strong>: 64KB fits in L2 cache (typically 256KBâ€“512KB) without evicting the rest of your working set from L1. Larger buffers start competing with other hot data.\nAt smaller buffer sizes (4KB, 8KB), the overhead of the readâ†’write loop â€” two syscalls per iteration, with their associated mode switches between user space and kernel space â€” becomes a bottleneck. At larger buffer sizes (256KB+), the buffer itself starts evicting hot data from cache.</li>\n</ul>\n<hr>\n<h2 id=\"toctou-the-security-race-you-can39t-fully-win\">TOCTOU: The Security Race You Can&#39;t Fully Win</h2>\n<p>Even with perfect <code>realpath()</code> usage, there is a theoretical security vulnerability worth understanding: the <strong>Time-Of-Check-Time-Of-Use (TOCTOU)</strong> race condition.\nHere&#39;s the scenario:</p>\n<ol>\n<li>Your code calls <code>realpath(&quot;/var/www/html/safe.txt&quot;)</code> â†’ verifies path is inside root âœ“</li>\n<li>An attacker (with filesystem access) replaces <code>/var/www/html/safe.txt</code> with a symlink to <code>/etc/passwd</code></li>\n<li>Your code calls <code>open(&quot;/var/www/html/safe.txt&quot;)</code> â†’ now opens <code>/etc/passwd</code>\nThe check (<code>realpath</code>) and the use (<code>open</code>) are two separate operations. Between them, the filesystem can change. This is the time-of-check-time-of-use problem.\nIn practice, exploiting this requires the attacker to already have filesystem write access to your web root â€” if they do, they&#39;ve already won (they can just read the file directly, or plant malicious content). So TOCTOU in this specific scenario is not a meaningful threat model for a static file server. However, the TOCTOU concept itself is one of the most important patterns in systems security, appearing in:</li>\n</ol>\n<ul>\n<li><strong>setuid programs</strong>: check permissions as real user, use resources as root user</li>\n<li><strong>Database isolation levels</strong>: read-then-write transactions with intervening modifications (phantom reads)</li>\n<li><strong>Container escape vulnerabilities</strong>: checking container identity before acting on it</li>\n<li><strong>File upload handlers</strong>: validate file type, then move â€” attacker replaces file between steps\nYou cannot eliminate TOCTOU without atomic operations. The Linux kernel provides <code>openat()</code> with directory file descriptors, which reduces (but doesn&#39;t eliminate) the window. For our static file server, the threat model doesn&#39;t require solving TOCTOU â€” but knowing it exists makes you a more careful systems programmer.</li>\n</ul>\n<hr>\n<h2 id=\"hardware-soul-cache-lines-and-file-transfer\">Hardware Soul: Cache Lines and File Transfer</h2>\n<p><strong><code>realpath()</code> â€” multiple syscalls</strong>: Each <code>lstat()</code> call inside <code>realpath()</code> crosses the user/kernel boundary (~1â€“2 microseconds for the context switch) and performs a dcache lookup. For a path with N components, this is N Ã— 2Âµs. For <code>/var/www/html/images/photo.jpg</code> (5 components), <code>realpath()</code> costs approximately 10 microseconds â€” dominated by system call overhead, not computation.\n<strong><code>stat()</code> memory access pattern</strong>: <code>struct stat</code> is 144 bytes on Linux x86-64. It fits entirely in L1 cache. You call <code>stat()</code> once per request; the kernel fills it in during the syscall. There&#39;s no cache-line bouncing concern here â€” it&#39;s a small, write-once, read-several-times structure.\n<strong>File read loop â€” cache line efficiency</strong>: Your 64KB read buffer crosses 1024 cache lines (64 bytes each). The CPU&#39;s hardware prefetcher recognizes the sequential access pattern â€” you read from offset 0, 64, 128, ... in order â€” and prefetches the next cache line before you need it. This is a <strong>stream access pattern</strong>: the most cache-friendly access pattern possible, achieving near-peak memory bandwidth. The prefetcher would fail on random access (serving random bytes from different files), which is why file serving is faster than you might expect even when the data isn&#39;t already in L1.\n<strong><code>write()</code> and socket buffers</strong>: When you call <code>write(client_fd, io_buf, 65536)</code>, the kernel copies your buffer into the socket&#39;s send buffer (in kernel memory), then returns. The TCP stack asynchronously segments and transmits from the send buffer. If the send buffer is full (the client is reading slowly), <code>write()</code> blocks. For a local loopback connection, the kernel&#39;s loopback interface operates at memory bandwidth speeds â€” easily 10+ GB/s. The bottleneck for local file serving is never the network.\n<strong>The case for <code>sendfile()</code></strong>: In the serve loop above, you perform two copies for each chunk of file data:</p>\n<ol>\n<li><code>read()</code>: disk/page-cache â†’ your userspace buffer (kernel mode â†’ user mode copy)  </li>\n<li><code>write()</code>: your userspace buffer â†’ socket send buffer (user mode â†’ kernel mode copy)\nThe <code>sendfile()</code> syscall (Linux-specific) eliminates both copies. It tells the kernel: &quot;copy from this file FD directly to this socket FD without touching userspace.&quot; The kernel can use DMA (Direct Memory Access) to copy from the page cache to the NIC&#39;s DMA buffer directly, bypassing the CPU entirely for the data movement. For large files on high-bandwidth connections, <code>sendfile()</code> doubles throughput and halves CPU usage. Your current implementation is educationally valuable because it shows you exactly where the copies happen. After this milestone, <code>sendfile()</code> is the natural next optimization.</li>\n</ol>\n<hr>\n<h2 id=\"integrating-file-serving-into-the-accept-loop\">Integrating File Serving into the Accept Loop</h2>\n<p>Update <code>handle_connection()</code> from Milestone 2 to dispatch to <code>serve_static_file()</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Updated handle_connection â€” replaces the dispatch section from Milestone 2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> handle_connection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> client_fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">canonical_root</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> req_buf</span><span style=\"color:#E1E4E8\">[REQUEST_BUF_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> header_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> bytes_read </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> read_http_request</span><span style=\"color:#E1E4E8\">(client_fd, req_buf,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                           REQUEST_BUF_SIZE, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">header_end);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (bytes_read </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> header_end </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(client_fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    http_request_t</span><span style=\"color:#E1E4E8\"> req;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> parse_err </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> parse_http_request</span><span style=\"color:#E1E4E8\">(req_buf, (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)bytes_read,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                       header_end, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">req);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (parse_err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        switch</span><span style=\"color:#E1E4E8\"> (parse_err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#79B8FF\"> 400</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#B392F0\">send_error_response</span><span style=\"color:#E1E4E8\">(client_fd, </span><span style=\"color:#79B8FF\">400</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Bad Request\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                          \"&#x3C;html>&#x3C;body>&#x3C;h1>400 Bad Request&#x3C;/h1>&#x3C;/body>&#x3C;/html>\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                      break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#79B8FF\"> 414</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#B392F0\">send_error_response</span><span style=\"color:#E1E4E8\">(client_fd, </span><span style=\"color:#79B8FF\">414</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"URI Too Long\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                          \"&#x3C;html>&#x3C;body>&#x3C;h1>414 URI Too Long&#x3C;/h1>&#x3C;/body>&#x3C;/html>\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                      break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#79B8FF\"> 501</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#B392F0\">send_error_response</span><span style=\"color:#E1E4E8\">(client_fd, </span><span style=\"color:#79B8FF\">501</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Not Implemented\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                          \"&#x3C;html>&#x3C;body>&#x3C;h1>501 Not Implemented&#x3C;/h1>&#x3C;/body>&#x3C;/html>\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                      break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            default</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#B392F0\">send_error_response</span><span style=\"color:#E1E4E8\">(client_fd, </span><span style=\"color:#79B8FF\">400</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Bad Request\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                          \"&#x3C;html>&#x3C;body>&#x3C;h1>400 Bad Request&#x3C;/h1>&#x3C;/body>&#x3C;/html>\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(client_fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Only serve GET and HEAD â€” POST and others get 501 (parser sets METHOD_UNKNOWN)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (req.method </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> METHOD_GET </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> req.method </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> METHOD_HEAD) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        send_error_response</span><span style=\"color:#E1E4E8\">(client_fd, </span><span style=\"color:#79B8FF\">501</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Not Implemented\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"&#x3C;html>&#x3C;body>&#x3C;h1>501 Not Implemented&#x3C;/h1>&#x3C;/body>&#x3C;/html>\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(client_fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    serve_static_file</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">req, client_fd, canonical_root);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(client_fd);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"pass-canonical_root-from-your-server-initialization-where-you-called-realpath-on-the-document-root-at-startup-into-every-connection-handler-in-milestone-4-this-will-move-into-a-shared-server-configuration-struct-accessible-to-all-worker-threads\">Pass <code>canonical_root</code> from your server initialization (where you called <code>realpath()</code> on the document root at startup) into every connection handler. In Milestone 4, this will move into a shared server configuration struct accessible to all worker threads.</h2>\n<h2 id=\"testing-static-file-serving\">Testing Static File Serving</h2>\n<p>Create a test document root with a representative set of files:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#9ECBFF\"> /tmp/www/images</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> '&#x3C;html>&#x3C;body>&#x3C;h1>Home&#x3C;/h1>&#x3C;/body>&#x3C;/html>'</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /tmp/www/index.html</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> 'body { color: red; }'</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /tmp/www/style.css</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> 'console.log(\"hello\");'</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /tmp/www/app.js</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cp</span><span style=\"color:#9ECBFF\"> /usr/share/pixmaps/some-icon.png</span><span style=\"color:#9ECBFF\"> /tmp/www/images/logo.png</span><span style=\"color:#6A737D\">  # or any PNG</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> '{\"status\": \"ok\"}'</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /tmp/www/api.json</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run server</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./http_server</span><span style=\"color:#79B8FF\"> 8080</span><span style=\"color:#9ECBFF\"> /tmp/www</span></span></code></pre></div>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test 1: Serve HTML with correct Content-Type</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expect: HTTP/1.1 200 OK, Content-Type: text/html; charset=utf-8</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 2: Serve CSS</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/style.css</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expect: Content-Type: text/css</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 3: Last-Modified header present</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/index.html</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -i</span><span style=\"color:#9ECBFF\"> last-modified</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expect: Last-Modified: &#x3C;some valid HTTP date></span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 4: Conditional request â€” first fetch, then conditional</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">LMOD</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -sI</span><span style=\"color:#9ECBFF\"> http://localhost:8080/index.html</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -i</span><span style=\"color:#9ECBFF\"> last-modified</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> cut</span><span style=\"color:#79B8FF\"> -d</span><span style=\"color:#9ECBFF\">' '</span><span style=\"color:#79B8FF\"> -f2-</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#79B8FF\"> -H</span><span style=\"color:#9ECBFF\"> \"If-Modified-Since: </span><span style=\"color:#E1E4E8\">$LMOD</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\"> http://localhost:8080/index.html</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expect: HTTP/1.1 304 Not Modified, no body</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 5: 404 for missing file</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/does-not-exist.html</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expect: HTTP/1.1 404 Not Found</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 6: Directory traversal â€” MUST return 403</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/../../../etc/passwd</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expect: HTTP/1.1 403 Forbidden (curl may normalize the path â€” use nc)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">printf</span><span style=\"color:#9ECBFF\"> \"GET /../../../etc/passwd HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> nc</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expect: 403 Forbidden, no file content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 7: URL-encoded traversal</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">printf</span><span style=\"color:#9ECBFF\"> \"GET /%2e%2e%2f%2e%2e%2fetc%2fpasswd HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> nc</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expect: 403 Forbidden</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 8: Directory without index.html</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#9ECBFF\"> /tmp/www/empty-dir</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/empty-dir/</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expect: 403 Forbidden</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 9: Directory with index.html</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expect: 200 OK with the content of /tmp/www/index.html</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 10: HEAD request returns headers, no body</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> HEAD</span><span style=\"color:#9ECBFF\"> http://localhost:8080/index.html</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expect: 200 OK with Content-Length header, zero bytes of body</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 11: Binary file (PNG) served correctly</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> http://localhost:8080/images/logo.png</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> file</span><span style=\"color:#9ECBFF\"> -</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expect: PNG image data â€” not corrupted binary</span></span></code></pre></div>\n<p>Test 11 is important: verify that binary files are transmitted intact. A naive server that tries to process binary content as text can corrupt images. Ensure your read/write loop treats the data as raw bytes â€” which it does, since you&#39;re using <code>read()</code> and <code>write()</code> with <code>char</code> buffers, where every byte value 0â€“255 is valid.</p>\n<h3 id=\"verifying-security-properties\">Verifying Security Properties</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Verify realpath() is actually being called â€” strace on Linux</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">strace</span><span style=\"color:#79B8FF\"> -e</span><span style=\"color:#9ECBFF\"> trace=lstat,open,read</span><span style=\"color:#9ECBFF\"> ./http_server</span><span style=\"color:#79B8FF\"> 8080</span><span style=\"color:#9ECBFF\"> /tmp/www</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">printf</span><span style=\"color:#9ECBFF\"> \"GET /../../../etc/passwd HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> nc</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Look for lstat() calls on path components in strace output</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should NOT see open(\"/etc/passwd\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify symlink traversal is blocked</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ln</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> /etc</span><span style=\"color:#9ECBFF\"> /tmp/www/secret-link</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/secret-link/passwd</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expect: 403 Forbidden</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># realpath() resolves the symlink to /etc/passwd, which is outside /tmp/www</span></span></code></pre></div>\n<hr>\n<h2 id=\"design-decisions-path-security-approaches\">Design Decisions: Path Security Approaches</h2>\n<table>\n<thead>\n<tr>\n<th>Approach</th>\n<th>Security Level</th>\n<th>Complexity</th>\n<th>Used By</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>String prefix check only</strong></td>\n<td>None (bypassable)</td>\n<td>Trivial</td>\n<td>Buggy student servers</td>\n</tr>\n<tr>\n<td><strong>Manual <code>..</code> stripping</strong></td>\n<td>Weak (URL encoding bypasses)</td>\n<td>Medium</td>\n<td>Some legacy CGI servers</td>\n</tr>\n<tr>\n<td><strong><code>realpath()</code> + prefix check (this project) âœ“</strong></td>\n<td>Strong for file server</td>\n<td>Low</td>\n<td>nginx, Apache httpd</td>\n</tr>\n<tr>\n<td><strong><code>chroot()</code> jail</strong></td>\n<td>Very strong (OS-enforced)</td>\n<td>High</td>\n<td>High-security file servers</td>\n</tr>\n<tr>\n<td><strong><code>openat()</code> with O_NOFOLLOW</strong></td>\n<td>Strong (no TOCTOU)</td>\n<td>Medium</td>\n<td>Modern security-conscious servers</td>\n</tr>\n<tr>\n<td><code>chroot()</code> changes a process&#39;s view of the root filesystem â€” inside a chroot jail, the process cannot navigate above its &quot;root.&quot; This is OS-enforced containment: even a compromised <code>realpath()</code> implementation can&#39;t escape a chroot. The downside is that it requires the server to be set up carefully (all needed libraries and files must be inside the jail) and typically requires root privileges to call <code>chroot()</code>. nginx and Apache can use <code>chroot</code> in production configurations.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>openat()</code> with <code>O_NOFOLLOW</code> (don&#39;t follow symlinks on the final component) combined with <code>O_PATH</code> fd-based path traversal is the most modern approach â€” it eliminates TOCTOU by holding directory fds across the traversal. This is how container runtimes like <code>runc</code> handle their filesystem operations.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>For this milestone, <code>realpath()</code> + prefix check is the right choice: correct, auditable, and teachable.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"knowledge-cascade-what-this-unlocks\">Knowledge Cascade: What This Unlocks</h2>\n<h3 id=\"1-defense-in-depth-the-resolve-then-check-pattern-everywhere\">1. Defense in Depth â€” The Resolve-Then-Check Pattern Everywhere</h3>\n<p>The principle you just applied â€” canonicalize first, check second â€” is the foundation of every defense-in-depth filesystem security mechanism:\n<strong><code>chroot()</code> jails</strong>: The kernel&#39;s <code>chroot()</code> syscall changes what &quot;/&quot; means for a process. Every path lookup inside a chroot is automatically constrained to the jail directory. The implementation is: when resolving a path, if the process&#39;s root is <code>/jail</code>, every absolute path lookup starts at <code>/jail</code>. <code>realpath()</code> inside the jail cannot escape because the kernel won&#39;t let it. Same principle: resolve identity through the system, then trust the result.\n<strong>Linux namespaces and container filesystems</strong>: Docker and container runtimes use mount namespaces to create a private filesystem view per container. When a process inside a container opens <code>/etc/passwd</code>, the kernel resolves that path in the container&#39;s namespace, which maps to a container-specific overlay filesystem layer. The security model is: trust the kernel&#39;s path resolution, not the string.\n<strong><code>seccomp</code> sandboxes</strong>: Instead of path-level security, seccomp operates on syscall level â€” but the principle is the same. Don&#39;t trust the syscall arguments (the string passed to <code>open()</code>); instead, constrain which syscalls are permitted at all, forcing the program to operate within a defined safety envelope.\nWherever you see security through containment â€” browser sandboxes (Chrome&#39;s site isolation uses process separation and IPC), database privilege levels (EXECUTE permission on stored procedures without SELECT access to underlying tables), AWS IAM policies â€” the pattern is: don&#39;t trust the name or the request, verify the resolved identity.</p>\n<h3 id=\"2-sendfile-and-zero-copy-io\">2. <code>sendfile()</code> and Zero-Copy I/O</h3>\n<p>Your current file transfer code has two copies per chunk: page cache â†’ user buffer (<code>read()</code>), user buffer â†’ socket send buffer (<code>write()</code>). Visualize those two copies as two context switches and two memcpy calls per 64KB chunk.\n<code>sendfile(output_fd, input_fd, offset, count)</code> is a Linux syscall that performs the transfer inside the kernel â€” no userspace buffer needed. The kernel can use DMA to move data directly from the disk controller&#39;s memory to the NIC&#39;s DMA buffer, bypassing the CPU for the data path entirely. For a 1MB file served over a fast connection:</p>\n<ul>\n<li><strong>With read/write</strong>: 16 read() calls + 16 write() calls + 2MB of memcpy = ~30Âµs of CPU time</li>\n<li><strong>With sendfile()</strong>: 1 syscall, kernel handles DMA = ~5Âµs of CPU time\nThis is the technique behind nginx&#39;s legendary efficiency. nginx&#39;s inner loop for static file serving is essentially: open the file, <code>sendfile()</code> to the socket, close the file. No userspace buffer, no memcpy. The kernel does everything.\nThe concept extends: <code>splice()</code> transfers data between two file descriptors (not necessarily a file and a socket), <code>tee()</code> duplicates pipe data, and <code>copy_file_range()</code> copies between two regular files â€” all in kernel space, all avoiding the userspace round-trip. Go&#39;s <code>net/http</code> server uses <code>sendfile()</code> automatically when serving files via <code>http.ServeFile()</code>. Rust&#39;s <code>tokio</code> async runtime exposes it through <code>tokio::fs::File</code>. Understanding why it exists â€” because the double-copy in read+write is wasteful physics â€” lets you recognize when to reach for it.</li>\n</ul>\n<h3 id=\"3-browser-caching-architecture\">3. Browser Caching Architecture</h3>\n<p>The <code>If-Modified-Since</code> / <code>Last-Modified</code> / <code>304</code> flow you just implemented is the oldest layer of the web&#39;s caching stack. Understanding it bottom-up unlocks the entire architecture:</p>\n<ul>\n<li><strong><code>Last-Modified</code> + <code>If-Modified-Since</code></strong>: Time-based validation. Granularity: one second. Weakness: if a file changes and reverts within one second, the cache won&#39;t invalidate. What you just built.</li>\n<li><strong><code>ETag</code> + <code>If-None-Match</code></strong>: Hash-based validation. The server sends a hash of the file content as the <code>ETag</code>. Clients send <code>If-None-Match: &lt;etag&gt;</code> on subsequent requests. Hash comparison is unambiguous â€” any change, regardless of timestamp granularity, produces a different ETag. nginx computes ETags as <code>mtime-size</code> (modification time XOR file size).</li>\n<li><strong><code>Cache-Control</code></strong>: Proactive caching directives. <code>Cache-Control: max-age=3600</code> tells the browser &quot;don&#39;t even ask for 1 hour â€” assume it&#39;s fresh.&quot; No request is sent at all. <code>Cache-Control: no-cache</code> means &quot;always validate but reuse if 304.&quot; <code>Cache-Control: no-store</code> means &quot;never cache this.&quot;</li>\n<li><strong>CDN invalidation</strong>: CDNs (Cloudflare, Fastly, AWS CloudFront) cache your responses at edge nodes globally. When you update a file, you send a &quot;purge&quot; API call to invalidate the CDN cache. The CDN then uses <code>If-Modified-Since</code> or <code>ETag</code> to revalidate with your origin server. The mechanics are exactly what you built â€” just distributed.</li>\n<li><strong>Service Workers</strong>: A JavaScript-controlled cache layer in the browser that intercepts fetch requests. Service workers can implement arbitrary caching logic â€” but they use the same <code>Response</code> objects with the same <code>Last-Modified</code> and <code>ETag</code> semantics. Understanding the HTTP layer means understanding what service workers are working with.</li>\n</ul>\n<h3 id=\"4-mime-types-as-content-negotiation-the-simple-case-of-a-deep-concept\">4. MIME Types as Content Negotiation â€” The Simple Case of a Deep Concept</h3>\n<p>The <code>Content-Type</code> header you&#39;re setting per file extension is the simplest form of HTTP <strong>content negotiation</strong>. The general principle: the client and server negotiate what representation of a resource to use. MIME types for static files require no negotiation â€” the server picks the type based on the file. But the same infrastructure supports richer negotiation:</p>\n<ul>\n<li><strong><code>Accept-Language: en-US, fr;q=0.9</code></strong>: Client prefers US English, accepts French at 90% quality. Server picks the best available language version of the resource.</li>\n<li><strong><code>Accept-Encoding: gzip, deflate, br</code></strong>: Client can decompress these encodings. Server sends a gzip-compressed response with <code>Content-Encoding: gzip</code>, saving 70â€“80% of bandwidth for text files.</li>\n<li><strong><code>Accept: application/json, text/html</code></strong>: REST APIs use this to serve JSON to API clients and HTML to browsers from the same URL.</li>\n<li><strong>API versioning via <code>Accept</code></strong>: <code>Accept: application/vnd.myapi.v2+json</code> â€” the client requests a specific API version through the Accept header. GitHub&#39;s API works this way.\nEvery one of these is a generalization of the same concept you implemented: use metadata about the resource and the client&#39;s capabilities to pick the right representation.</li>\n</ul>\n<h3 id=\"5-stat-and-the-unix-inode-model\">5. <code>stat()</code> and the Unix Inode Model</h3>\n<p><code>stat()</code> is a window into the Unix inode model. An <strong>inode</strong> (index node) is the kernel data structure that stores file metadata: size, permissions (<code>st_mode</code>), owner (<code>st_uid</code>), group (<code>st_gid</code>), timestamps (<code>st_atime</code>, <code>st_mtime</code>, <code>st_ctime</code>), and the block pointers that tell the kernel where the file&#39;s data lives on disk. Notably, the inode does <em>not</em> store the filename â€” that lives in the directory entry, which is a separate structure that maps names to inode numbers.\nThis separation explains seemingly strange behaviors:</p>\n<ul>\n<li>You can have two filenames that point to the same inode (<code>hard links</code>). Both names share the same metadata, the same content, the same modification time.</li>\n<li>A file can be &quot;deleted&quot; (the directory entry removed) but its inode persists until all file descriptors to it are closed. This is why <code>unlink()</code> doesn&#39;t immediately free disk space if a process has the file open â€” the inode stays alive.</li>\n<li><code>stat()</code> and <code>lstat()</code> differ: <code>stat()</code> follows symlinks to the target&#39;s inode; <code>lstat()</code> returns the symlink&#39;s own inode (with <code>st_mode</code> indicating it&#39;s a symlink).\nUnderstanding inodes is the foundation for understanding filesystem implementation (how SQLite manages its database file, how PostgreSQL manages tablespace files), for understanding why <code>mv</code> within a filesystem is instantaneous (renames the directory entry, doesn&#39;t move inode data), and for understanding why cross-filesystem <code>mv</code> is slow (must copy all data, create new inode, delete old entry).</li>\n</ul>\n<hr>\n<h2 id=\"common-mistakes-that-will-burn-you\">Common Mistakes That Will Burn You</h2>\n<h2 id=\"1-calling-realpath-on-the-document-root-per-request-not-at-startup-realpath-on-the-document-root-doesn39t-change-between-requests-it39s-your-configuration-calling-it-per-request-adds-510-lstat-syscalls-on-every-single-request-call-it-once-at-startup-store-the-result-pass-it-to-every-connection-handler-2-checking-the-prefix-before-calling-realpath-the-entire-point-of-realpath-is-that-the-raw-path-string-cannot-be-trusted-any-check-before-realpath-is-checking-attacker-controlled-data-and-provides-no-security-guarantee-canonicalize-first-always-3-text-mode-reading-for-binary-files-on-linux-open-with-o_rdonly-gives-you-raw-bytes-there39s-no-quottext-modequot-vs-quotbinary-modequot-distinction-at-the-syscall-level-however-if-you-ever-use-fopen-with-quotrquot-instead-of-quotrbquot-some-platforms-windows-translate-rn-sequences-to-n-in-text-mode-corrupting-binary-files-use-open-read-directly-as-in-the-code-above-or-use-fopen-quotrbquot-if-you-use-stdio-never-use-quotrquot-for-files-that-might-be-binary-4-using-st_mtime-without-understanding-its-granularity-on-some-filesystems-fat32-older-hfs-file-modification-times-have-2-second-or-1-second-granularity-on-ext4-and-modern-filesystems-st_mtimtv_nsec-gives-nanosecond-precision-but-http-date-format-only-has-1-second-resolution-when-comparing-st_mtime-against-an-if-modified-since-timestamp-use-only-the-second-precision-st_mtime-not-st_mtimtv_nsec-and-use-lt-comparison-as-shown-above-5-not-closing-file_fd-on-all-error-paths-every-early-return-after-file_fd-open-must-include-closefile_fd-draw-the-control-flow-if-write_all-of-the-headers-fails-client-disconnected-you-break-out-of-the-function-have-you-closed-file_fd-check-every-branch-6-forgetting-to-handle-the-path-prefix-edge-case-the-check-strncmpresolved-root-root_len-0-passes-for-both-varwww-the-root-itself-and-varwww-backup-a-different-directory-always-verify-that-the-character-at-resolvedroot_len-is-either-3939-or-39039-7-using-atoi-for-content-length-in-milestone-2-carry-forward-you-already-handle-this-but-if-you-missed-it-atoiquot-1quot-returns-1-and-atoiquot9999999999999quot-overflows-silently-on-32-bit-int-strtol-with-bounds-checking-is-the-only-safe-approach\"><strong>1. Calling <code>realpath()</code> on the document root per request, not at startup.</strong>\n<code>realpath()</code> on the document root doesn&#39;t change between requests (it&#39;s your configuration). Calling it per request adds 5â€“10 <code>lstat()</code> syscalls on every single request. Call it once at startup, store the result, pass it to every connection handler.\n<strong>2. Checking the prefix before calling <code>realpath()</code>.</strong>\nThe entire point of <code>realpath()</code> is that the raw path string cannot be trusted. Any check before <code>realpath()</code> is checking attacker-controlled data and provides no security guarantee. <strong>Canonicalize first. Always.</strong>\n<strong>3. Text-mode reading for binary files.</strong>\nOn Linux, <code>open()</code> with <code>O_RDONLY</code> gives you raw bytes â€” there&#39;s no &quot;text mode&quot; vs &quot;binary mode&quot; distinction at the syscall level. However, if you ever use <code>fopen()</code> with <code>&quot;r&quot;</code> instead of <code>&quot;rb&quot;</code>, some platforms (Windows) translate <code>\\r\\n</code> sequences to <code>\\n</code> in text mode, corrupting binary files. Use <code>open()</code> + <code>read()</code> directly (as in the code above), or use <code>fopen(..., &quot;rb&quot;)</code> if you use stdio. Never use <code>&quot;r&quot;</code> for files that might be binary.\n<strong>4. Using <code>st_mtime</code> without understanding its granularity.</strong>\nOn some filesystems (FAT32, older HFS+), file modification times have 2-second or 1-second granularity. On ext4 and modern filesystems, <code>st_mtim.tv_nsec</code> gives nanosecond precision. But HTTP-date format only has 1-second resolution. When comparing <code>st_mtime</code> against an <code>If-Modified-Since</code> timestamp, use only the second-precision <code>st_mtime</code> (not <code>st_mtim.tv_nsec</code>), and use <code>&lt;=</code> comparison as shown above.\n<strong>5. Not closing <code>file_fd</code> on all error paths.</strong>\nEvery early return after <code>file_fd = open(...)</code> must include <code>close(file_fd)</code>. Draw the control flow. If <code>write_all()</code> of the headers fails (client disconnected), you break out of the function â€” have you closed <code>file_fd</code>? Check every branch.\n<strong>6. Forgetting to handle the path prefix edge case.</strong>\nThe check <code>strncmp(resolved, root, root_len) == 0</code> passes for both <code>/var/www</code> (the root itself) and <code>/var/www-backup</code> (a different directory). Always verify that the character at <code>resolved[root_len]</code> is either <code>&#39;/&#39;</code> or <code>&#39;\\0&#39;</code>.\n<strong>7. Using <code>atoi()</code> for Content-Length in Milestone 2 (carry-forward)</strong>\nYou already handle this, but if you missed it: <code>atoi(&quot;-1&quot;)</code> returns <code>-1</code>, and <code>atoi(&quot;9999999999999&quot;)</code> overflows silently on 32-bit <code>int</code>. <code>strtol()</code> with bounds checking is the only safe approach.</h2>\n<h2 id=\"acceptance-criteria-checklist\">Acceptance Criteria Checklist</h2>\n<p>Before proceeding to Milestone 4, verify each item:</p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> <code>./http_server 8080 /tmp/www</code> starts, prints the canonical document root path</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>curl http://localhost:8080/</code> returns <code>200 OK</code> with <code>Content-Type: text/html; charset=utf-8</code> and the content of <code>index.html</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>curl http://localhost:8080/style.css</code> returns <code>Content-Type: text/css</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>curl http://localhost:8080/app.js</code> returns <code>Content-Type: application/javascript</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>curl http://localhost:8080/images/logo.png</code> returns <code>Content-Type: image/png</code> and binary-intact PNG data</li>\n<li><input disabled=\"\" type=\"checkbox\"> All responses include a correctly formatted <code>Last-Modified</code> header (day-of-week, day, mon, year, time, &quot;GMT&quot;)</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>curl -H &quot;If-Modified-Since: &lt;valid future date&gt;&quot; http://localhost:8080/index.html</code> returns <code>304 Not Modified</code> with no body</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>curl http://localhost:8080/missing.html</code> returns <code>404 Not Found</code> with an HTML error body</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>printf &quot;GET /../../../etc/passwd HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n&quot; | nc localhost 8080</code> returns <code>403 Forbidden</code>, never file contents</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>printf &quot;GET /%2e%2e%2f%2e%2e%2fetc%2fpasswd HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n&quot; | nc localhost 8080</code> returns <code>403 Forbidden</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> A symlink inside the document root pointing outside it returns <code>403 Forbidden</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>curl http://localhost:8080/empty-dir/</code> (directory without <code>index.html</code>) returns <code>403 Forbidden</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>curl -X HEAD http://localhost:8080/index.html</code> returns <code>200 OK</code> with correct <code>Content-Length</code> and zero bytes of body</li>\n<li><input disabled=\"\" type=\"checkbox\"> FD count after 1000 requests (mix of 200, 304, 404, 403) returns to baseline â€” no leaks</li>\n</ul>\n<!-- END_MS -->\n\n\n<!-- MS_ID: http-server-basic-m4 -->\n<!-- MS_ID: http-server-basic-m4 -->\n<h1 id=\"milestone-4-concurrent-connections\">Milestone 4: Concurrent Connections</h1>\n<h2 id=\"where-you-are-in-the-system\">Where You Are in the System</h2>\n<p>You have built three-quarters of a real HTTP server. Your server binds a port, reads raw bytes off TCP connections, parses them into structured HTTP requests, and serves files with proper security validation. What you have right now is a fully correct sequential server â€” one that would serve a single developer testing a local site with zero problems.\nWhat you do not have yet is a server that could survive contact with reality.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-satellite-map.svg\" alt=\"HTTP Server Architecture â€” Satellite Map\"></p>\n<h2 id=\"reality-looks-like-this-a-user-opens-a-browser-and-loads-a-page-with-20-assets-html-css-javascript-files-images-the-browser-opens-multiple-connections-simultaneously-to-fetch-those-assets-in-parallel-a-second-user-hits-the-site-at-the-same-moment-your-sequential-accept-loop-which-finishes-one-connection-completely-before-calling-accept-again-makes-everyone-wait-in-line-the-second-user39s-browser-times-out-before-it-gets-a-response-your-server-from-the-outside-appears-broken-this-milestone-fixes-that-by-introducing-concurrency-the-ability-to-handle-multiple-connections-at-the-same-time-you-will-build-two-models-thread-per-connection-first-simple-reveals-the-problem-and-then-a-bounded-thread-pool-the-real-solution-and-layer-on-top-the-three-features-that-make-concurrent-connection-management-work-in-production-http11-keep-alive-per-connection-idle-timeouts-and-graceful-shutdown\">Reality looks like this: a user opens a browser and loads a page with 20 assets (HTML, CSS, JavaScript files, images). The browser opens multiple connections simultaneously to fetch those assets in parallel. A second user hits the site at the same moment. Your sequential accept loop â€” which finishes one connection completely before calling <code>accept()</code> again â€” makes everyone wait in line. The second user&#39;s browser times out before it gets a response. Your server, from the outside, appears broken.\nThis milestone fixes that by introducing <strong>concurrency</strong>: the ability to handle multiple connections at the same time. You will build two models â€” thread-per-connection first (simple, reveals the problem) and then a bounded thread pool (the real solution) â€” and layer on top the three features that make concurrent connection management work in production: HTTP/1.1 keep-alive, per-connection idle timeouts, and graceful shutdown.</h2>\n<h2 id=\"the-revelation-quotjust-spawn-a-threadquot-is-not-a-solution\">The Revelation: &quot;Just Spawn a Thread&quot; Is Not a Solution</h2>\n<p>Before writing any threading code, you need to understand why the obvious approach is dangerous.\nThe obvious approach is: when a new connection arrives, spawn a thread to handle it. Done. Each client gets a thread. Threads can run concurrently. Problem solved.\nThis works perfectly in testing. You connect with curl, it gets a thread, the thread handles the request, everything is fine. You connect with ten curls in parallel, ten threads handle them simultaneously. Still fine.\nNow an attacker runs this:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Slowloris: open 10,000 connections and send HTTP headers one byte every 20 seconds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Never complete the request â€” hold the connections open indefinitely</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python3</span><span style=\"color:#9ECBFF\"> slowloris.py</span><span style=\"color:#79B8FF\"> --port</span><span style=\"color:#79B8FF\"> 8080</span><span style=\"color:#79B8FF\"> --connections</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#79B8FF\"> --sleep</span><span style=\"color:#79B8FF\"> 20</span></span></code></pre></div>\n<p>The Slowloris attack, discovered in 2009 by Robert &quot;RSnake&quot; Hansen, exploits exactly the &quot;just spawn a thread&quot; model. Each connection gets a thread. The thread blocks in <code>read()</code> waiting for the complete HTTP headers. The attacker sends one byte every 20 seconds â€” just enough to keep the connection alive and prevent your timeout (if you have one). With 10,000 connections, you have 10,000 threads.\nHere is what 10,000 threads cost on Linux:\nEach thread, by default, gets an <strong>8MB stack</strong>. This is the kernel&#39;s default (<code>ulimit -s</code> reports it). The stack is virtual memory â€” it doesn&#39;t all map to physical RAM immediately â€” but the kernel still reserves the virtual address space. On a 64-bit system with 256GB of virtual address space, you might think this is fine. But:</p>\n<ul>\n<li>10,000 threads Ã— 8MB stack = <strong>80GB of virtual address space</strong> reserved</li>\n<li>Kernel overhead per thread: ~64KB for the task_struct and related kernel data structures = <strong>640MB of kernel memory</strong></li>\n<li>Context switches between 10,000 threads: the scheduler now has 10,000 runnable (or blocked) threads to manage â€” scheduling overhead becomes visible</li>\n<li>The Linux default maximum number of threads (<code>/proc/sys/kernel/threads-max</code>) is often around 32,000. With 10,000 connections, you&#39;re already at 31% of the system limit. A real attack can push past it entirely, causing <code>pthread_create()</code> to fail with <code>EAGAIN</code> â€” your server can no longer handle even legitimate connections</li>\n</ul>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m4-thread-per-connection.svg\" alt=\"Thread-Per-Connection Model â€” How It Works and How It Breaks\"></p>\n<h2 id=\"the-resource-exhaustion-is-not-hypothetical-it39s-the-exact-failure-mode-that-took-down-apache-web-servers-in-2009-before-patches-were-deployed-apache39s-default-model-was-thread-per-connection-actually-process-per-connection-which-is-worse-slowloris-exploited-the-os-limit-on-concurrent-processes-not-the-attack39s-bandwidth-requirements-the-attacking-machine-needed-almost-no-resources-the-defending-server-was-overwhelmed-the-insight-thread-creation-is-not-free-and-thread-count-must-be-bounded-a-bounded-thread-pool-eliminates-this-entire-attack-surface-if-your-pool-has-16-threads-the-17th-connection-waits-in-a-queue-queued-connections-consume-no-threads-no-kernel-task_structs-no-8mb-stacks-the-10000th-slowloris-connection-just-adds-to-the-queue-which-you-can-also-bound-more-on-that-shortly-your-server-continues-serving-legitimate-requests-normally-but-there-is-a-second-revelation-hiding-inside-the-first-even-with-a-bounded-pool-keep-alive-connections-without-idle-timeouts-create-a-slow-leak-if-your-16-threads-are-all-handling-keep-alive-connections-from-browsers-that-opened-them-10-minutes-ago-and-haven39t-sent-a-second-request-all-16-threads-are-blocked-in-read-new-legitimate-connections-sit-in-the-queue-forever-the-pool-is-full-of-zombie-connections-technically-alive-sending-no-data-consuming-a-thread-each-the-complete-solution-requires-three-interlocking-pieces-a-bounded-thread-pool-per-connection-idle-timeouts-and-a-keep-alive-loop-that-correctly-reuses-connections-when-appropriate-and-closes-them-when-not\">The resource exhaustion is not hypothetical. It&#39;s the exact failure mode that took down Apache web servers in 2009 before patches were deployed. Apache&#39;s default model was thread-per-connection (actually process-per-connection, which is worse). Slowloris exploited the OS limit on concurrent processes, not the attack&#39;s bandwidth requirements. The attacking machine needed almost no resources; the defending server was overwhelmed.\n<strong>The insight: thread creation is not free, and thread count must be bounded.</strong>\nA bounded thread pool eliminates this entire attack surface. If your pool has 16 threads, the 17th connection waits in a queue. Queued connections consume no threads, no kernel task_structs, no 8MB stacks. The 10,000th Slowloris connection just adds to the queue (which you can also bound â€” more on that shortly). Your server continues serving legitimate requests normally.\nBut there is a second revelation hiding inside the first. Even with a bounded pool, keep-alive connections without idle timeouts create a slow leak. If your 16 threads are all handling keep-alive connections from browsers that opened them 10 minutes ago and haven&#39;t sent a second request, all 16 threads are blocked in <code>read()</code>. New legitimate connections sit in the queue forever. The pool is full of zombie connections â€” technically alive, sending no data, consuming a thread each.\nThe complete solution requires three interlocking pieces: a bounded thread pool, per-connection idle timeouts, and a keep-alive loop that correctly reuses connections when appropriate and closes them when not.</h2>\n<h2 id=\"posix-threads-the-api-you-will-use\">POSIX Threads: The API You Will Use</h2>\n<p>[[EXPLAIN:pthread-api|POSIX Threads (pthreads) â€” creation, mutexes, and condition variables]]\nThe pthreads API is POSIX&#39;s standardized interface for multi-threading in C. Linux implements it via the <code>&lt;pthread.h&gt;</code> header and the <code>libpthread</code> library (link with <code>-lpthread</code>). You need four concepts from it.\n<strong>Thread creation: <code>pthread_create()</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;pthread.h></span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Signature:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> pthread_create</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">thread</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">        // OUTPUT: handle to the new thread</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> pthread_attr_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">attr</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\"> // Thread attributes (NULL for defaults)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">start_fn)(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">),</span><span style=\"color:#6A737D\"> // Function the thread will run</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">arg</span><span style=\"color:#6A737D\">                 // Argument passed to start_fn</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns 0 on success, error code on failure (EAGAIN = too many threads, ENOMEM = out of memory)</span></span></code></pre></div>\n<p>The new thread starts executing <code>start_fn(arg)</code> immediately, concurrently with your calling thread. Both threads run in the same process, sharing the same heap memory, global variables, and file descriptors. That shared access is what makes synchronization necessary.\n<strong>Mutexes: <code>pthread_mutex_t</code></strong>\nA mutex (<strong>mut</strong>ual <strong>ex</strong>clusion lock) is a synchronization primitive that ensures only one thread accesses a shared resource at a time. Imagine a bathroom key on a hook â€” only the person holding the key can enter; everyone else waits.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">pthread_mutex_t</span><span style=\"color:#E1E4E8\"> lock </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PTHREAD_MUTEX_INITIALIZER;</span><span style=\"color:#6A737D\">  // Static initialization</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">lock</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // Acquire lock â€” blocks if another thread holds it</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ... access shared data here ...</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">lock</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\"> // Release lock â€” wakes one waiting thread</span></span></code></pre></div>\n<p>Any code that reads or writes shared state (a counter, a log file, a work queue) must hold the mutex while doing so. Code that doesn&#39;t hold the mutex and accesses shared data has a <strong>data race</strong> â€” the result is undefined behavior in C, meaning anything can happen: corrupted data, crashes, or apparently correct behavior that breaks under load.\n<strong>Condition variables: <code>pthread_cond_t</code></strong>\nA condition variable lets a thread sleep until some condition becomes true. Used together with a mutex, it allows &quot;wait until there is work to do&quot; â€” essential for thread pool worker loops.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">pthread_cond_t</span><span style=\"color:#E1E4E8\"> cond </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PTHREAD_COND_INITIALIZER;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// In a producer thread: signal that work is available</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">lock</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ... add work to shared queue ...</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pthread_cond_signal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">cond</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Wake one sleeping consumer</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">lock</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// In a consumer thread: wait for work</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">lock</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">queue_is_empty</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">queue</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_cond_wait</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">cond, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">lock);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // pthread_cond_wait atomically: releases lock AND sleeps</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // When signaled: reacquires lock AND returns</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // The while loop (not if) handles spurious wakeups</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ... take work from queue ...</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">lock</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<p>The <code>while</code> loop around <code>pthread_cond_wait()</code> is not optional ceremony. POSIX permits <strong>spurious wakeups</strong> â€” a thread can wake from <code>pthread_cond_wait()</code> even without being signaled. Always re-check the condition after waking.\n<strong>Thread joining and detaching</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">pthread_join</span><span style=\"color:#E1E4E8\">(thread, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // Block until thread exits, then clean up its resources</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pthread_detach</span><span style=\"color:#E1E4E8\">(thread);</span><span style=\"color:#6A737D\">       // Thread cleans up its own resources when it exits</span></span></code></pre></div>\n<h2 id=\"you-must-either-join-or-detach-every-thread-a-thread-that-is-neither-joined-nor-detached-is-a-resource-leak-its-kernel-task_struct-remains-allocated-until-the-process-exits\">You must either join or detach every thread. A thread that is neither joined nor detached is a resource leak â€” its kernel task_struct remains allocated until the process exits.</h2>\n<h2 id=\"the-thread-pool-architecture\">The Thread Pool Architecture</h2>\n<p>Now build the actual solution. A thread pool consists of:</p>\n<ol>\n<li><strong>A fixed array of worker threads</strong> â€” created at startup, they run a loop waiting for work</li>\n<li><strong>A shared work queue</strong> â€” a bounded queue of file descriptors waiting to be handled</li>\n<li><strong>A mutex protecting the queue</strong> â€” ensures threads don&#39;t corrupt the queue by accessing it simultaneously</li>\n<li><strong>A condition variable</strong> â€” lets workers sleep efficiently when the queue is empty</li>\n<li><strong>A shutdown flag</strong> â€” signals workers to exit cleanly</li>\n</ol>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m4-thread-pool-architecture.svg\" alt=\"Thread Pool Internal Architecture\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;pthread.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;signal.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;time.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/socket.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;netinet/in.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> POOL_SIZE_DEFAULT</span><span style=\"color:#79B8FF\">    16</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> QUEUE_SIZE_DEFAULT</span><span style=\"color:#79B8FF\">   256</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> IDLE_TIMEOUT_SECS</span><span style=\"color:#79B8FF\">    30</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// A single item in the work queue: a client file descriptor to serve</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> client_fd;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">work_item_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The thread pool and its shared state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // --- Work queue (circular buffer) ---</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    work_item_t</span><span style=\"color:#F97583\">  *</span><span style=\"color:#E1E4E8\">queue;</span><span style=\"color:#6A737D\">          // Fixed-size circular buffer of work items</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">           queue_capacity;</span><span style=\"color:#6A737D\"> // Maximum items in queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">           queue_head;</span><span style=\"color:#6A737D\">     // Index of next item to consume</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">           queue_tail;</span><span style=\"color:#6A737D\">     // Index of next slot to produce into</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">           queue_size;</span><span style=\"color:#6A737D\">     // Current number of items in queue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // --- Synchronization ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_mutex_t</span><span style=\"color:#E1E4E8\"> lock;</span><span style=\"color:#6A737D\">         // Protects all queue fields and shutdown flag</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_cond_t</span><span style=\"color:#E1E4E8\">  not_empty;</span><span style=\"color:#6A737D\">    // Signaled when an item is added to empty queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_cond_t</span><span style=\"color:#E1E4E8\">  not_full;</span><span style=\"color:#6A737D\">     // Signaled when an item is removed from full queue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // --- Worker threads ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_t</span><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">threads;</span><span style=\"color:#6A737D\">        // Array of worker thread handles</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">           num_threads;</span><span style=\"color:#6A737D\">    // Number of worker threads</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // --- Lifecycle ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">           shutdown;</span><span style=\"color:#6A737D\">       // 1 = workers should exit after draining queue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // --- Shared statistics (protected by lock) ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">           active_connections;</span><span style=\"color:#6A737D\">  // Number of connections currently being served</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#E1E4E8\">          total_requests;</span><span style=\"color:#6A737D\">      // Cumulative request count for access log</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // --- Server configuration (read-only after init, no lock needed) ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\">   *</span><span style=\"color:#E1E4E8\">document_root;</span><span style=\"color:#6A737D\">  // Canonical document root path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">           idle_timeout;</span><span style=\"color:#6A737D\">   // Per-connection idle timeout in seconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">thread_pool_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n<h3 id=\"memory-layout\">Memory Layout</h3>\n<p>The work queue is a <strong>circular buffer</strong> â€” a fixed-size array where the head and tail pointers wrap around. When the tail reaches the end, it wraps back to index 0. This gives O(1) enqueue and dequeue without any allocation.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Queue capacity = 8, current state: head=2, tail=5, size=3\nIndex: 0     1     2     3     4     5     6     7\n       [  ] [  ] [fd=9][fd=12][fd=15][    ][    ][  ]\n                  â†‘head                â†‘tail\nItems waiting: fd=9, fd=12, fd=15</code></pre></div>\n<p>When <code>queue_size == queue_capacity</code>, the queue is full. A new connection arriving while the queue is full gets rejected with 503.</p>\n<h3 id=\"initialization\">Initialization</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> thread_pool_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">thread_pool_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> num_threads</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> queue_capacity</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                     const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">document_root</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> idle_timeout</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(pool, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pool));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pool->queue </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> calloc</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)queue_capacity, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">work_item_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">pool->queue) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pool->queue_capacity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> queue_capacity;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pool->num_threads    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> num_threads;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pool->document_root  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> document_root;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pool->idle_timeout   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> idle_timeout;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->lock, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_cond_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->not_empty, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_cond_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->not_full, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pool->threads </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> calloc</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)num_threads, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pthread_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">pool->threads) { </span><span style=\"color:#B392F0\">free</span><span style=\"color:#E1E4E8\">(pool->queue); </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> num_threads; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> rc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pthread_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->threads[i], </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, worker_thread_fn, pool);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (rc </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Failed to create thread â€” initiate shutdown of already-created threads</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pool->shutdown </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            pthread_cond_broadcast</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->not_empty);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; j </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> i; j</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">pthread_join</span><span style=\"color:#E1E4E8\">(pool->threads[j], </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            free</span><span style=\"color:#E1E4E8\">(pool->threads);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            free</span><span style=\"color:#E1E4E8\">(pool->queue);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><code>pthread_cond_broadcast()</code> wakes <em>all</em> sleeping threads (unlike <code>signal()</code> which wakes one). Used during shutdown to ensure all workers wake up and check the shutdown flag.</p>\n<h3 id=\"the-worker-thread-loop\">The Worker Thread Loop</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">worker_thread_fn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">arg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    thread_pool_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pool </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">thread_pool_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)arg;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (;;) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // --- Wait for work ---</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->lock);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (pool->queue_size </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">pool->shutdown) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            pthread_cond_wait</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->not_empty, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->lock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (pool->shutdown </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> pool->queue_size </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Shutdown: no work left â€” this worker exits</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->lock);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // --- Dequeue one item ---</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        work_item_t</span><span style=\"color:#E1E4E8\"> item </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pool->queue[pool->queue_head];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pool->queue_head </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (pool->queue_head </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> pool->queue_capacity;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pool->queue_size</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pool->active_connections</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Signal that queue has space (for the accept loop, if it was blocked)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pthread_cond_signal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->not_full);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->lock);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // --- Handle the connection (OUTSIDE the lock) ---</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        handle_connection</span><span style=\"color:#E1E4E8\">(item.client_fd, pool);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // --- Update stats ---</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->lock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pool->active_connections</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->lock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>The critical discipline: <strong>hold the lock only while touching shared data, never while doing I/O or long computation.</strong> The actual connection handling â€” which involves network reads, file opens, and potentially seconds of waiting â€” happens completely outside the mutex. If you held the mutex during connection handling, all other threads would be blocked waiting for it. You&#39;d have effectively serialized your &quot;concurrent&quot; server.</p>\n<h3 id=\"enqueue-submitting-work\">Enqueue: Submitting Work</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Submit a client connection to the thread pool for handling.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns 0 on success, -1 if pool is full (caller should send 503 and close fd).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> thread_pool_submit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">thread_pool_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> client_fd</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->lock);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (pool->shutdown) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->lock);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Server is shutting down</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (pool->queue_size </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> pool->queue_capacity) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Queue is full â€” reject this connection</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->lock);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pool->queue[pool->queue_tail] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">work_item_t</span><span style=\"color:#E1E4E8\">){ .client_fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> client_fd };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pool->queue_tail </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (pool->queue_tail </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> pool->queue_capacity;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pool->queue_size</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Wake one sleeping worker</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_cond_signal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->not_empty);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->lock);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>When <code>thread_pool_submit()</code> returns -1, the accept loop must send a <code>503 Service Unavailable</code> response and close the file descriptor. This is the graceful overload response: tell the client the server is temporarily busy, rather than silently dropping the connection or crashing.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Send a minimal 503 response â€” used when the pool is full.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// We send the smallest valid HTTP response to minimize time holding the fd.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> send_503</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> client_fd</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">resp </span><span style=\"color:#F97583\">=</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"HTTP/1.1 503 Service Unavailable</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"Content-Type: text/html</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"Content-Length: 63</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"Connection: close</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;html>&#x3C;body>&#x3C;h1>503 Service Unavailable&#x3C;/h1>&#x3C;/body>&#x3C;/html>\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Best-effort write â€” if client already disconnected, EPIPE is ignored</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    write</span><span style=\"color:#E1E4E8\">(client_fd, resp, </span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(resp));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(client_fd);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"http11-keep-alive-the-connection-reuse-loop\">HTTP/1.1 Keep-Alive: The Connection Reuse Loop</h2>\n<p>HTTP/1.0 opened a new TCP connection for every single request/response cycle â€” a three-way handshake for each asset, before sending anything. For a page with 50 assets, that&#39;s 50 TCP handshakes. On a cross-continental connection with 100ms RTT, that&#39;s 5 seconds of pure handshake overhead before any real data transfers.\nHTTP/1.1 introduced <strong>persistent connections</strong> (keep-alive): by default, the connection stays open after a response, and the client sends the next request on the same socket. The overhead of TCP connection establishment â€” one handshake for the entire session â€” is paid once.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m4-keep-alive-timeline.svg\" alt=\"HTTP/1.1 Keep-Alive â€” Connection Reuse Timeline\"></p>\n<p>From your Milestone 2 parser, you already track <code>req.keep_alive</code> and set the <code>Connection: keep-alive</code> or <code>Connection: close</code> response header. Now you need to make the connection actually persist when keep-alive is requested.\nThe keep-alive loop wraps the request-read â†’ parse â†’ serve cycle inside a <code>while</code> loop on the same <code>client_fd</code>. Here is the complete connection handler that replaces the simple sequential handler:</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m4-connection-handling-flowchart.svg\" alt=\"Complete Connection Handler â€” Full Request Loop with Keep-Alive\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> handle_connection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> client_fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">thread_pool_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pool</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set the receive timeout on the socket.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If no data arrives within idle_timeout seconds, read() returns EAGAIN/EWOULDBLOCK.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> timeval tv;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tv.tv_sec  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pool->idle_timeout;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tv.tv_usec </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    setsockopt</span><span style=\"color:#E1E4E8\">(client_fd, SOL_SOCKET, SO_RCVTIMEO, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tv, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(tv));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Keep-alive loop: serve multiple requests on one connection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (;;) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // --- Phase 1: Read the request ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#FFAB70\"> req_buf</span><span style=\"color:#E1E4E8\">[REQUEST_BUF_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> header_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        ssize_t</span><span style=\"color:#E1E4E8\"> bytes_read </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> read_http_request</span><span style=\"color:#E1E4E8\">(client_fd, req_buf,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                               REQUEST_BUF_SIZE, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">header_end);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (bytes_read </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> header_end </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Timeout (EAGAIN), client disconnect (0 bytes), or read error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // In all cases: close the connection, return thread to pool</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // --- Phase 2: Parse ---</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        http_request_t</span><span style=\"color:#E1E4E8\"> req;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> parse_err </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> parse_http_request</span><span style=\"color:#E1E4E8\">(req_buf, (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)bytes_read,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                           header_end, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">req);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (parse_err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            send_error_by_code</span><span style=\"color:#E1E4E8\">(client_fd, parse_err);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Close after error response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // --- Phase 3: Update shared stats (briefly hold lock) ---</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->lock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pool->total_requests</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        long</span><span style=\"color:#E1E4E8\"> req_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pool->total_requests;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->lock);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // --- Phase 4: Serve the request ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (req.method </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> METHOD_GET </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> req.method </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> METHOD_HEAD) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            serve_static_file</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">req, client_fd, pool->document_root);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            send_error_response</span><span style=\"color:#E1E4E8\">(client_fd, </span><span style=\"color:#79B8FF\">501</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Not Implemented\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"&#x3C;html>&#x3C;body>&#x3C;h1>501 Not Implemented&#x3C;/h1>&#x3C;/body>&#x3C;/html>\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Don't keep-alive after 501</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // --- Phase 5: Decide whether to continue ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">req.keep_alive) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Connection: close â€” done</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Otherwise: loop back, wait for the next request on this connection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(client_fd);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>The <code>SO_RCVTIMEO</code> socket option is the idle timeout mechanism. When you set it, <code>recv()</code> and <code>read()</code> will return -1 with <code>errno = EAGAIN</code> (or <code>EWOULDBLOCK</code>) if no data arrives within the specified time. Your <code>read_http_request()</code> function from Milestone 1 already returns -1 on any error, so the timeout causes it to return -1, breaking the keep-alive loop and closing the connection. The worker thread is now free to handle a new connection.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m4-timeout-and-idle.svg\" alt=\"Idle Timeout â€” The Slowloris Defense\"></p>\n<h3 id=\"why-break-after-non-200-responses\">Why Break After Non-200 Responses?</h3>\n<h2 id=\"notice-the-break-after-sending-a-501-response-this-is-deliberate-if-a-client-sends-a-malformed-or-unsupported-request-and-receives-a-4xx-or-5xx-response-the-right-behavior-is-usually-to-close-the-connection-the-client-clearly-has-a-problem-letting-it-keep-the-connection-alive-and-send-more-broken-requests-wastes-server-resources-and-potentially-enables-abuse-the-exceptions-are-404-and-304-where-the-client-is-well-behaved-but-just-requesting-something-that-doesn39t-exist-or-hasn39t-changed-for-those-keep-alive-is-fine\">Notice the <code>break</code> after sending a 501 response. This is deliberate. If a client sends a malformed or unsupported request and receives a 4xx or 5xx response, the right behavior is usually to close the connection. The client clearly has a problem â€” letting it keep the connection alive and send more broken requests wastes server resources and potentially enables abuse. The exceptions are 404 and 304, where the client is well-behaved but just requesting something that doesn&#39;t exist or hasn&#39;t changed. For those, keep-alive is fine.</h2>\n<h2 id=\"signal-handling-in-multi-threaded-programs\">Signal Handling in Multi-Threaded Programs</h2>\n<p>When your server was single-threaded, signal handling was straightforward: <code>signal(SIGPIPE, SIG_IGN)</code> at startup, and you&#39;re done. Multi-threaded programs have a complication: <strong>POSIX delivers signals to an unpredictable thread.</strong></p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m4-signal-handling-threads.svg\" alt=\"Signal Handling in Multi-Threaded Programs â€” The Pitfall\"></p>\n<p>The POSIX specification says: when a signal is delivered to a process (as opposed to a specific thread via <code>pthread_kill()</code>), the kernel picks one of the threads that doesn&#39;t have the signal blocked. It may pick any thread â€” the accept loop thread, a worker thread, any of them.\nThis creates a subtle problem for SIGTERM and SIGINT (your graceful shutdown signals). If a worker thread receives SIGTERM, it might be in the middle of writing a file to the network. The signal handler runs asynchronously. If your signal handler calls <code>shutdown_server()</code> which modifies shared state while the worker thread isn&#39;t holding any lock, you have a data race inside the signal handler.\nThe safe solution for multi-threaded programs is the <strong>dedicated signal thread</strong> pattern:</p>\n<ol>\n<li>In <code>main()</code>, before creating any threads, <strong>block all signals</strong> using <code>pthread_sigmask()</code></li>\n<li>Create the thread pool â€” worker threads inherit the blocked signal mask</li>\n<li>Create a dedicated signal thread that uses <code>sigwait()</code> to wait for signals synchronously</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Block all signals in the main thread before spawning workers.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// All threads created after this inherit the blocked mask.</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">sigset_t</span><span style=\"color:#E1E4E8\"> all_signals;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sigfillset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">all_signals</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pthread_sigmask</span><span style=\"color:#E1E4E8\">(SIG_BLOCK, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">all_signals</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create the thread pool (workers inherit blocked signal mask)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">thread_pool_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">pool</span><span style=\"color:#E1E4E8\">, POOL_SIZE_DEFAULT, QUEUE_SIZE_DEFAULT, root, IDLE_TIMEOUT_SECS);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create the dedicated signal-handling thread</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">pthread_t</span><span style=\"color:#E1E4E8\"> signal_thread;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pthread_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">signal_thread</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, signal_handler_thread, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">pool</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Now run the accept loop in main thread</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">accept_loop</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">server_fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">pool</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<p>The signal-handling thread uses <code>sigwait()</code> â€” a blocking call that waits for a signal from the specified set and returns it synchronously, without running any asynchronous signal handler:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">signal_handler_thread</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">arg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    thread_pool_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pool </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">thread_pool_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)arg;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Wait for termination signals</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    sigset_t</span><span style=\"color:#E1E4E8\"> waitset;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sigemptyset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">waitset);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sigaddset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">waitset, SIGTERM);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sigaddset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">waitset, SIGINT);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Still ignore SIGPIPE globally to avoid broken-pipe kills</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    signal</span><span style=\"color:#E1E4E8\">(SIGPIPE, SIG_IGN);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> sig;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sigwait</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">waitset, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sig);</span><span style=\"color:#6A737D\">  // Blocks until SIGTERM or SIGINT arrives</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">[</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> received] Initiating graceful shutdown...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           sig </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> SIGTERM </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"SIGTERM\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"SIGINT\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initiate graceful shutdown</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    thread_pool_shutdown</span><span style=\"color:#E1E4E8\">(pool);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"sigwait-is-safe-to-call-from-a-regular-thread-context-no-async-signal-safety-concerns-no-restriction-on-what-you-can-do-before-or-after-it-the-signal-is-consumed-by-sigwait-and-delivered-synchronously-to-this-thread-no-other-thread-is-interrupted\"><code>sigwait()</code> is safe to call from a regular thread context â€” no async-signal-safety concerns, no restriction on what you can do before or after it. The signal is consumed by <code>sigwait()</code> and delivered synchronously to this thread. No other thread is interrupted.</h2>\n<h2 id=\"graceful-shutdown-the-four-phase-dance\">Graceful Shutdown: The Four-Phase Dance</h2>\n<p>Graceful shutdown means: stop accepting new work, finish all in-flight work, then exit cleanly. It is not <code>kill -9</code> and it is not <code>exit(0)</code> in the signal handler.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m4-graceful-shutdown-sequence.svg\" alt=\"Graceful Shutdown â€” The 4-Phase Dance\"></p>\n<p>The four phases:\n<strong>Phase 1: Stop accepting new connections.</strong> The accept loop must notice the shutdown signal and stop calling <code>accept()</code>. Use an <code>atomic_int</code> or mutex-protected flag that the accept loop checks between iterations.\n<strong>Phase 2: Close the listening socket.</strong> This causes any pending <code>accept()</code> call (if the accept loop is sleeping in it) to return with <code>EBADF</code>. New clients attempting to connect now get &quot;connection refused&quot; â€” a clear signal that the server is down, not hanging.\n<strong>Phase 3: Set the pool shutdown flag and wake all workers.</strong> Workers that are sleeping in <code>pthread_cond_wait()</code> need to wake up and check the shutdown flag.\n<strong>Phase 4: Join all workers.</strong> Wait for every worker thread to finish its current connection and exit. Only after all workers have joined can you safely free resources and call <code>exit(0)</code>.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Global flag for the accept loop to check â€” written by signal thread,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// read by accept loop. Using volatile int is NOT sufficient for thread safety</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// but using atomic_int or a mutex-protected int is.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// We use a mutex-protected int to keep the pattern consistent with the pool.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> thread_pool_shutdown</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">thread_pool_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pool</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->lock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pool->shutdown </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_cond_broadcast</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->not_empty);</span><span style=\"color:#6A737D\">  // Wake all sleeping workers</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->lock);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Workers will drain the queue then exit when they see shutdown=1 and queue is empty</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> thread_pool_join</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">thread_pool_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pool</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> pool->num_threads; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pthread_join</span><span style=\"color:#E1E4E8\">(pool->threads[i], </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"All worker threads exited cleanly.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free</span><span style=\"color:#E1E4E8\">(pool->threads);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free</span><span style=\"color:#E1E4E8\">(pool->queue);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_destroy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->lock);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_cond_destroy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->not_empty);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_cond_destroy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->not_full);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"the-accept-loop-with-shutdown-awareness\">The Accept Loop with Shutdown Awareness</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// A global server_fd â€” needed by signal handler to close the listening socket</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> g_server_fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> accept_loop</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">server_fd_ptr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">thread_pool_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pool</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    g_server_fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">server_fd_ptr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (;;) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check shutdown flag BEFORE calling accept</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->lock);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> shutting_down </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pool->shutdown;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->lock);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (shutting_down) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        struct</span><span style=\"color:#E1E4E8\"> sockaddr_in client_addr;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        socklen_t</span><span style=\"color:#E1E4E8\"> client_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(client_addr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> client_fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> accept</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">server_fd_ptr,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                               (</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> sockaddr</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">client_addr, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">client_len);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (client_fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> EINTR </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> EBADF) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Signal or fd closed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> EMFILE </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ENFILE) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Out of file descriptors â€” log and briefly yield</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"accept: out of file descriptors!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                usleep</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100000</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // 100ms back-off</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"accept\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Try to submit to pool</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">thread_pool_submit</span><span style=\"color:#E1E4E8\">(pool, client_fd) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            send_503</span><span style=\"color:#E1E4E8\">(client_fd);</span><span style=\"color:#6A737D\">  // Pool full or shutting down</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">server_fd_ptr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">server_fd_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    g_server_fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Accept loop exited.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"the-emfile-case-errno-emfile-means-quottoo-many-open-filesquot-the-process-hit-its-file-descriptor-limit-is-important-and-often-missed-when-this-happens-accept-fails-but-the-os-has-already-completed-the-tcp-handshake-for-the-waiting-client-repeatedly-calling-accept-to-get-this-error-doesn39t-drain-the-accept-queue-the-client-remains-waiting-the-usleep100000-back-off-gives-the-server-a-moment-to-close-other-file-descriptors-connections-finishing-in-the-worker-pool-before-trying-again\">The <code>EMFILE</code> case â€” <code>errno = EMFILE</code> means &quot;too many open files&quot; (the process hit its file descriptor limit) â€” is important and often missed. When this happens, <code>accept()</code> fails, but the OS has already completed the TCP handshake for the waiting client. Repeatedly calling <code>accept()</code> to get this error doesn&#39;t drain the accept queue â€” the client remains waiting. The <code>usleep(100000)</code> back-off gives the server a moment to close other file descriptors (connections finishing in the worker pool) before trying again.</h2>\n<h2 id=\"shared-state-and-mutex-protection\">Shared State and Mutex Protection</h2>\n<p>Your server now has state shared between multiple threads: the request counter, the connection counter, and any shared output (like an access log). Every shared write creates a potential data race.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m4-mutex-shared-state.svg\" alt=\"Shared State Under Concurrency â€” Data Race Example\"></p>\n<p>A <strong>data race</strong> in C is not just &quot;sometimes wrong results.&quot; The C11 standard (and the POSIX threading specification) defines any concurrent access to the same memory location where at least one access is a write, without synchronization, as <strong>undefined behavior</strong> â€” the most severe category in C. The compiler is permitted to assume data races don&#39;t exist, which means it can reorder instructions, cache values in registers, and produce behavior that makes no sense from a sequential reasoning perspective.\nThe most common manifestation: a 64-bit counter incremented by two threads. Even though the increment seems atomic, it compiles to <code>load â†’ add â†’ store</code>. Two threads can both load the old value, both add 1, and both store back â€” net result: the counter only incremented by 1 instead of 2. With the compiler free to reorder, the actual behavior can be even stranger.\nHere is the shared state in the pool struct, with protection analysis:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Things protected by pool->lock:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   pool->queue_*         â€” modified by accept loop and workers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   pool->shutdown        â€” written by signal thread, read by workers and accept loop</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   pool->active_connections â€” incremented/decremented by workers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   pool->total_requests  â€” incremented by workers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Things that DO NOT need the lock (read-only after initialization):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   pool->document_root   â€” set once at startup, never modified</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   pool->idle_timeout    â€” set once at startup, never modified</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   pool->num_threads     â€” set once at startup, never modified</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   pool->threads[]       â€” array set at startup; individual elements not modified</span></span></code></pre></div>\n<p>Accessing <code>pool-&gt;document_root</code> from multiple worker threads without a lock is safe because it&#39;s read-only: the workers only read it, they never write it. The mutex only needs to protect data that is both written and read concurrently.\nFor the access log (writing to a file or stdout), mutex protection is essential:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> pthread_mutex_t</span><span style=\"color:#E1E4E8\"> log_mutex </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PTHREAD_MUTEX_INITIALIZER;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> log_request</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">client_ip</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> http_request_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">req</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                 int</span><span style=\"color:#FFAB70\"> status_code</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">long</span><span style=\"color:#FFAB70\"> bytes_sent</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    time_t</span><span style=\"color:#E1E4E8\"> now </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> tm </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">gmt </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gmtime</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">now);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> time_buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    strftime</span><span style=\"color:#E1E4E8\">(time_buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(time_buf), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">b/</span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">Y:</span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">H:</span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">M:</span><span style=\"color:#79B8FF\">%S</span><span style=\"color:#9ECBFF\"> +0000\"</span><span style=\"color:#E1E4E8\">, gmt);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Without this lock, output from two threads interleaves in the same line</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">log_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> - - [</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">] </span><span style=\"color:#79B8FF\">\\\"%s</span><span style=\"color:#79B8FF\"> %s</span><span style=\"color:#9ECBFF\"> HTTP/1.</span><span style=\"color:#79B8FF\">%d\\\"</span><span style=\"color:#79B8FF\"> %d</span><span style=\"color:#79B8FF\"> %ld\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           client_ip, time_buf,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">           method_name</span><span style=\"color:#E1E4E8\">(req->method), req->path, req->http_minor,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           status_code, bytes_sent);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fflush</span><span style=\"color:#E1E4E8\">(stdout);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">log_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"without-the-log_mutex-two-threads-writing-to-stdout-simultaneously-produce-interleaved-garbage-half-of-thread-a39s-line-half-of-thread-b39s-all-on-the-same-output-line-this-looks-harmless-but-signals-sloppy-concurrency-discipline-if-the-log-is-wrong-you-can39t-trust-your-own-server39s-behavior-reports\">Without the <code>log_mutex</code>, two threads writing to stdout simultaneously produce interleaved garbage â€” half of thread A&#39;s line, half of thread B&#39;s, all on the same output line. This looks harmless but signals sloppy concurrency discipline. If the log is wrong, you can&#39;t trust your own server&#39;s behavior reports.</h2>\n<h2 id=\"pool-sizing-the-math-that-governs-everything\">Pool Sizing: The Math That Governs Everything</h2>\n<p>The pool size is not a guess. For an I/O-bound workload like file serving, there is a formula from <strong>Little&#39;s Law</strong> and <strong>Amdahl&#39;s Law</strong> that gives you a principled starting point.\nFor a CPU-bound workload (cryptography, compression, rendering), the optimal thread count is:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>pool_size = num_cpu_cores</code></pre></div>\n<p>Adding more threads than cores causes context-switch overhead without improving throughput â€” the CPU is already fully utilized.\nFor an I/O-bound workload (file serving, database queries), threads spend most of their time waiting. The formula is:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>pool_size = num_cores Ã— (1 + wait_time / compute_time)</code></pre></div>\n<p>Where <code>wait_time</code> is the time a request spends blocked on I/O (file reads from disk, network reads from client) and <code>compute_time</code> is the time spent actually executing CPU instructions (parsing, path resolution, MIME lookup).\nFor a static file server serving files from an NVMe SSD:</p>\n<ul>\n<li>Compute time per request: ~10â€“50Âµs (mostly parsing and path operations)</li>\n<li>Wait time per request: ~100Âµs for an SSD read, or ~5ms for a spinning disk, or ~0Âµs for page-cached files\nFor page-cached files (common for popular content):</li>\n<li><code>pool_size = num_cores Ã— (1 + ~1Âµs / ~30Âµs) â‰ˆ num_cores Ã— 1.03 â‰ˆ num_cores</code>\nFor SSD-served cold files:</li>\n<li><code>pool_size = num_cores Ã— (1 + 100Âµs / 30Âµs) â‰ˆ num_cores Ã— 4.3</code>\nThe default of 16 is a reasonable production starting point for a 4-core machine serving SSD-backed files with some cache warming. Monitor your active connection count and adjust: if <code>active_connections</code> is consistently near <code>pool_size</code> under load, increase the pool.</li>\n</ul>\n<hr>\n<h2 id=\"fd-leak-detection-under-load\">FD Leak Detection Under Load</h2>\n<p>The acceptance criterion requires that after 10,000 sequential connections, the open FD count returns to baseline. This check is your comprehensive correctness test for all four milestones combined.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdiag-m4-fd-leak-detection.svg\" alt=\"FD Leak Detection â€” Before and After 10,000 Connections\"></p>\n<p>FD leaks in a concurrent server are more insidious than in a sequential one because the leaky code path might only execute under specific race conditions:</p>\n<ul>\n<li>A worker thread gets a client_fd, starts serving, the client disconnects mid-response â†’ the error path exits without <code>close(client_fd)</code></li>\n<li>A <code>pthread_create()</code> fails while client_fd is already assigned â†’ cleanup path skips the close</li>\n<li>A keep-alive loop exits due to timeout but closes only once when it should be fine (this is OK â€” one close per fd)\nThe test script:</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">#!/bin/bash</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SERVER_PID</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">pgrep</span><span style=\"color:#9ECBFF\"> http_server</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ROOT_PATH</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">/tmp/www</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Starting FD baseline...\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">BASE_FDS</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#E1E4E8\">$SERVER_PID</span><span style=\"color:#9ECBFF\">/fd</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> wc</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Baseline: </span><span style=\"color:#E1E4E8\">$BASE_FDS</span><span style=\"color:#9ECBFF\"> open FDs\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Sending 10,000 connections...\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">seq</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> http://localhost:8080/</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/null</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Give server time to close any in-flight FDs</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sleep</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">FINAL_FDS</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#E1E4E8\">$SERVER_PID</span><span style=\"color:#9ECBFF\">/fd</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> wc</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Final: </span><span style=\"color:#E1E4E8\">$FINAL_FDS</span><span style=\"color:#9ECBFF\"> open FDs\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> [ </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">$FINAL_FDS</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> -le</span><span style=\"color:#9ECBFF\"> \"$((</span><span style=\"color:#B392F0\">BASE_FDS</span><span style=\"color:#9ECBFF\"> + </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#9ECBFF\">))\"</span><span style=\"color:#E1E4E8\"> ]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"PASS: No FD leak detected (within tolerance of 2)\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"FAIL: Leaked $((</span><span style=\"color:#B392F0\">FINAL_FDS</span><span style=\"color:#9ECBFF\"> - BASE_FDS)) FDs\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"Current open FDs:\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#E1E4E8\">$SERVER_PID</span><span style=\"color:#9ECBFF\">/fd/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">fi</span></span></code></pre></div>\n<p>A tolerance of 2 accounts for FDs that might be mid-close at the moment you sample â€” perfectly normal timing variation. Growth of 3+ is a real leak.\nOn Linux, you can identify what types of FDs are leaking:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Show the types of all open FDs for your server</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">pgrep</span><span style=\"color:#9ECBFF\"> http_server</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#9ECBFF\">/fd/</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># symlinks point to: socket:[inode] (sockets), /path/to/file (files), pipe:[inode] (pipes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># If you see many socket:[...] entries that should have been closed, you have a socket leak</span></span></code></pre></div>\n<hr>\n<h2 id=\"complete-main-wiring-it-all-together\">Complete Main: Wiring It All Together</h2>\n<p>Here is the complete <code>main()</code> that integrates all four milestones:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;signal.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/socket.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;netinet/in.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;arpa/inet.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;pthread.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEFAULT_PORT</span><span style=\"color:#79B8FF\">       8080</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEFAULT_POOL_SIZE</span><span style=\"color:#79B8FF\">  16</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEFAULT_QUEUE_SIZE</span><span style=\"color:#79B8FF\"> 256</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEFAULT_TIMEOUT</span><span style=\"color:#79B8FF\">    30</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_PATH_SIZE</span><span style=\"color:#79B8FF\">      4096</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> accept_loop</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">server_fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">thread_pool_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pool</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\">  thread_pool_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">thread_pool_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> thread_pool_join</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">thread_pool_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> thread_pool_t</span><span style=\"color:#E1E4E8\"> g_pool;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#F97583\">[]</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> port </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> DEFAULT_PORT;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">doc_root </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \".\"</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Default: current directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (argc </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) port      </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> atoi</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (argc </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">) doc_root  </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // --- Canonicalize document root (once, at startup) ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> canonical_root</span><span style=\"color:#E1E4E8\">[MAX_PATH_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">realpath</span><span style=\"color:#E1E4E8\">(doc_root, canonical_root) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"realpath (document root)\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Document root: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, canonical_root);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // --- Block all signals before creating any threads ---</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Workers inherit this blocked mask, so signals go to the signal thread only</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    sigset_t</span><span style=\"color:#E1E4E8\"> all_sigs;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sigfillset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">all_sigs);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_sigmask</span><span style=\"color:#E1E4E8\">(SIG_BLOCK, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">all_sigs, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // SIGPIPE: ignore globally (must be done via sigaction, not masked)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> sigaction sa_ignore </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { .sa_handler </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> SIG_IGN };</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sigaction</span><span style=\"color:#E1E4E8\">(SIGPIPE, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sa_ignore, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // --- Initialize thread pool ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">thread_pool_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_pool, DEFAULT_POOL_SIZE, DEFAULT_QUEUE_SIZE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                         canonical_root, DEFAULT_TIMEOUT) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Failed to initialize thread pool</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Thread pool: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> workers, queue capacity </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           DEFAULT_POOL_SIZE, DEFAULT_QUEUE_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // --- Create signal handler thread ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_t</span><span style=\"color:#E1E4E8\"> sig_thread;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sig_thread, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, signal_handler_thread, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_pool);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_detach</span><span style=\"color:#E1E4E8\">(sig_thread);</span><span style=\"color:#6A737D\">  // Will exit after handling one signal</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // --- Create the listening socket ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> server_fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> socket</span><span style=\"color:#E1E4E8\">(AF_INET, SOCK_STREAM, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (server_fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"socket\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> opt </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    setsockopt</span><span style=\"color:#E1E4E8\">(server_fd, SOL_SOCKET, SO_REUSEADDR, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">opt, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(opt));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> sockaddr_in addr;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">addr, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(addr));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    addr.sin_family      </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> AF_INET;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    addr.sin_addr.s_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> INADDR_ANY;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    addr.sin_port        </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> htons</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\">)port);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">bind</span><span style=\"color:#E1E4E8\">(server_fd, (</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> sockaddr</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">addr, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(addr)) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"bind\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#B392F0\">close</span><span style=\"color:#E1E4E8\">(server_fd); </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">listen</span><span style=\"color:#E1E4E8\">(server_fd, SOMAXCONN) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"listen\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#B392F0\">close</span><span style=\"color:#E1E4E8\">(server_fd); </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Server listening on port </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, port);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // --- Run the accept loop (blocks until shutdown) ---</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    accept_loop</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">server_fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_pool);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // --- Wait for all workers to finish ---</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    thread_pool_join</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g_pool);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Server shutdown complete.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"compiling-the-multi-threaded-server\">Compiling the Multi-Threaded Server</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># -lpthread links the POSIX threads library</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># -pthread is preferred on modern GCC: sets linker flags AND compiler flags</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># (-D_REENTRANT makes some library functions thread-safe)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -Wall</span><span style=\"color:#79B8FF\"> -Wextra</span><span style=\"color:#79B8FF\"> -pthread</span><span style=\"color:#79B8FF\"> -O2</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    -o</span><span style=\"color:#9ECBFF\"> http_server</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    main.c</span><span style=\"color:#9ECBFF\"> socket.c</span><span style=\"color:#9ECBFF\"> parser.c</span><span style=\"color:#9ECBFF\"> file_server.c</span><span style=\"color:#9ECBFF\"> thread_pool.c</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test graceful shutdown</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./http_server</span><span style=\"color:#79B8FF\"> 8080</span><span style=\"color:#9ECBFF\"> /tmp/www</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SERVER_PID</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">$!</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sleep</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Send 20 concurrent requests</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">seq</span><span style=\"color:#79B8FF\"> 20</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">do</span><span style=\"color:#B392F0\"> curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> http://localhost:8080/</span><span style=\"color:#E1E4E8\"> &#x26; </span><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Immediately send SIGTERM â€” server should finish in-flight requests then exit</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">kill</span><span style=\"color:#79B8FF\"> -SIGTERM</span><span style=\"color:#E1E4E8\"> $SERVER_PID</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">wait</span><span style=\"color:#E1E4E8\"> $SERVER_PID</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Exit code: </span><span style=\"color:#79B8FF\">$?</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\">  # Should be 0</span></span></code></pre></div>\n<hr>\n<h2 id=\"three-level-view-a-request-under-concurrency\">Three-Level View: A Request Under Concurrency</h2>\n<h2 id=\"take-a-get-request-that-arrives-while-5-other-requests-are-in-flight-and-trace-it-through-all-three-levels-level-1-your-code-the-main-thread39s-accept_loop-calls-accept-and-gets-client_fd-12-it-calls-thread_pool_submitamppool-12-which-acquires-the-pool-mutex-adds-fd-12-to-the-circular-queue-increments-queue_size-and-signals-not_empty-worker-thread-3-which-was-sleeping-in-pthread_cond_wait-wakes-up-dequeues-client_fd-12-increments-active_connections-releases-the-lock-and-calls-handle_connection12-amppool-meanwhile-the-main-thread-is-already-back-in-accept-accepting-the-next-connection-level-2-oskernel-pthread_cond_signal-doesn39t-run-the-sleeping-thread-immediately-it-marks-thread-3-as-runnable-and-adds-it-to-the-kernel-scheduler39s-run-queue-the-kernel39s-scheduler-will-run-it-when-it-gets-a-cpu-timeslice-typically-within-1ms-on-a-lightly-loaded-system-or-immediately-if-a-cpu-is-idle-the-two-threads-main-thread-in-accept-and-worker-3-in-handle_connection-run-on-separate-cpu-cores-simultaneously-true-parallelism-on-a-multi-core-machine-when-worker-3-calls-readclient_fd-the-kernel-checks-the-socket39s-receive-buffer-if-the-http-request-data-is-already-there-common-for-localhost-it-copies-it-to-user-space-immediately-if-not-the-kernel-moves-thread-3-to-the-quotwaiting-for-ioquot-state-and-puts-another-runnable-thread-on-that-cpu-core-zero-cpu-cycles-wasted-while-waiting-for-network-data-level-3-hardware-pthread_mutex_lock-compiles-to-a-lock-cmpxchg-instruction-on-x86-or-ldxrstxr-on-arm-these-are-atomic-compare-and-swap-instructions-hardware-enforced-operations-that-compare-and-modify-memory-in-a-single-uninterruptible-cycle-the-cpu39s-cache-coherence-protocol-mesi-ensures-that-all-cores-see-the-same-value-for-the-mutex-when-core-1-acquires-the-mutex-sets-it-from-0-to-1-with-cmpxchg-the-cache-coherence-protocol-invalidates-the-l1l2-cache-lines-holding-the-mutex-on-all-other-cores-forcing-them-to-reload-from-l3-or-main-memory-this-cross-core-coordination-costs-40100-clock-cycles-2050ns-at-2ghz-the-true-cost-of-one-mutex-lockunlock-cycle-this-is-why-the-law-quothold-the-lock-only-as-long-as-necessaryquot-matters-at-the-hardware-level-every-cycle-you-hold-the-mutex-is-a-cycle-another-core-spends-stalled-waiting-for-the-cache-line\">Take a GET request that arrives while 5 other requests are in flight and trace it through all three levels.\n<strong>Level 1 â€” Your code:</strong>\nThe main thread&#39;s <code>accept_loop()</code> calls <code>accept()</code> and gets <code>client_fd = 12</code>. It calls <code>thread_pool_submit(&amp;pool, 12)</code>, which acquires the pool mutex, adds fd 12 to the circular queue, increments <code>queue_size</code>, and signals <code>not_empty</code>. Worker thread 3 (which was sleeping in <code>pthread_cond_wait()</code>) wakes up, dequeues <code>client_fd = 12</code>, increments <code>active_connections</code>, releases the lock, and calls <code>handle_connection(12, &amp;pool)</code>. Meanwhile, the main thread is already back in <code>accept()</code>, accepting the next connection.\n<strong>Level 2 â€” OS/Kernel:</strong>\n<code>pthread_cond_signal()</code> doesn&#39;t run the sleeping thread immediately â€” it marks thread 3 as runnable and adds it to the kernel scheduler&#39;s run queue. The kernel&#39;s scheduler will run it when it gets a CPU timeslice (typically within ~1ms on a lightly loaded system, or immediately if a CPU is idle). The two threads â€” main thread in <code>accept()</code> and worker 3 in <code>handle_connection()</code> â€” run on separate CPU cores simultaneously: true parallelism on a multi-core machine.\nWhen worker 3 calls <code>read(client_fd, ...)</code>, the kernel checks the socket&#39;s receive buffer. If the HTTP request data is already there (common for localhost), it copies it to user space immediately. If not, the kernel moves thread 3 to the &quot;waiting for I/O&quot; state and puts another runnable thread on that CPU core. Zero CPU cycles wasted while waiting for network data.\n<strong>Level 3 â€” Hardware:</strong>\n<code>pthread_mutex_lock()</code> compiles to a <code>LOCK CMPXCHG</code> instruction (on x86) or <code>LDXR</code>/<code>STXR</code> (on ARM). These are <strong>atomic compare-and-swap</strong> instructions â€” hardware-enforced operations that compare and modify memory in a single, uninterruptible cycle. The CPU&#39;s cache coherence protocol (MESI) ensures that all cores see the same value for the mutex: when core 1 acquires the mutex (sets it from 0 to 1 with <code>CMPXCHG</code>), the cache coherence protocol invalidates the L1/L2 cache lines holding the mutex on all other cores, forcing them to reload from L3 or main memory. This cross-core coordination costs ~40â€“100 clock cycles (20â€“50ns at 2GHz) â€” the true cost of one mutex lock/unlock cycle.\nThis is why the law &quot;hold the lock only as long as necessary&quot; matters at the hardware level: every cycle you hold the mutex is a cycle another core spends stalled waiting for the cache line.</h2>\n<h2 id=\"hardware-soul-concurrency-costs\">Hardware Soul: Concurrency Costs</h2>\n<h2 id=\"thread-creation-overhead-pthread_create-involves-a-system-call-clone-on-linux-that-creates-a-new-kernel-task_struct-allocates-a-kernel-stack-8kb-and-maps-the-user-space-stack-8mb-virtual-but-initially-only-one-4kb-page-is-actually-mapped-the-rest-page-faults-in-as-needed-total-cost-1050s-the-thread-pool-amortizes-this-by-creating-threads-at-startup-not-per-request-context-switch-cost-when-the-scheduler-switches-between-threads-which-happens-every-14ms-on-a-standard-linux-configuration-config_hz-250-or-1000-it-must-save-all-cpu-registers-16-general-purpose-registers-sseavx-state-etc-for-the-outgoing-thread-and-restore-them-for-the-incoming-thread-on-x86-64-this-is-80-cache-lines-of-state-cost-15s-per-context-switch-with-16-threads-context-switching-is-infrequent-and-well-within-budget-with-1000-threads-it-becomes-the-dominant-cost-false-sharing-the-pool-gtactive_connections-and-pool-gttotal_requests-counters-are-adjacent-in-memory-likely-sharing-a-64-byte-cache-line-when-worker-thread-a-increments-active_connections-and-worker-thread-b-increments-total_requests-simultaneously-both-cache-lines-get-invalidated-on-both-cores-even-though-they39re-touching-different-variables-this-false-sharing-causes-unnecessary-cache-coherence-traffic-production-thread-pools-go39s-runtime-jemalloc39s-arena-structure-use-__attribute__aligned64-or-padding-to-place-each-frequently-written-field-on-its-own-cache-line-for-this-server-at-16-threads-it39s-not-a-measurable-issue-but-understanding-it-prepares-you-for-high-performance-work-socket-option-so_rcvtimeo-the-implementation-setting-so_rcvtimeo-stores-a-struct-timeval-in-the-socket39s-kernel-data-structure-when-read-is-called-on-the-socket-the-kernel39s-netsocket-layer-starts-a-timer-if-data-doesn39t-arrive-within-the-timeout-the-timer-fires-via-the-kernel39s-timer-interrupt-and-wakes-the-blocked-thread-with-eagain-the-cost-is-zero-unless-the-timeout-actually-fires-it39s-a-passive-kernel-structure-not-a-polling-loop\"><strong>Thread creation overhead.</strong> <code>pthread_create()</code> involves a system call (<code>clone()</code> on Linux) that creates a new kernel task_struct, allocates a kernel stack (8KB), and maps the user-space stack (8MB virtual, but initially only one 4KB page is actually mapped â€” the rest page-faults in as needed). Total cost: ~10â€“50Âµs. The thread pool amortizes this by creating threads at startup, not per-request.\n<strong>Context switch cost.</strong> When the scheduler switches between threads â€” which happens every ~1â€“4ms on a standard Linux configuration (<code>CONFIG_HZ = 250</code> or <code>1000</code>) â€” it must save all CPU registers (16 general-purpose registers, SSE/AVX state, etc.) for the outgoing thread and restore them for the incoming thread. On x86-64, this is ~80 cache lines of state. Cost: ~1â€“5Âµs per context switch. With 16 threads, context switching is infrequent and well within budget. With 1000 threads, it becomes the dominant cost.\n<strong>False sharing.</strong> The <code>pool-&gt;active_connections</code> and <code>pool-&gt;total_requests</code> counters are adjacent in memory, likely sharing a 64-byte cache line. When worker thread A increments <code>active_connections</code> and worker thread B increments <code>total_requests</code> simultaneously â€” both cache lines get invalidated on both cores even though they&#39;re touching different variables. This <strong>false sharing</strong> causes unnecessary cache coherence traffic. Production thread pools (Go&#39;s runtime, jemalloc&#39;s arena structure) use <code>__attribute__((aligned(64)))</code> or padding to place each frequently-written field on its own cache line. For this server at 16 threads, it&#39;s not a measurable issue â€” but understanding it prepares you for high-performance work.\n<strong>Socket option <code>SO_RCVTIMEO</code> â€” the implementation.</strong> Setting <code>SO_RCVTIMEO</code> stores a <code>struct timeval</code> in the socket&#39;s kernel data structure. When <code>read()</code> is called on the socket, the kernel&#39;s net/socket layer starts a timer. If data doesn&#39;t arrive within the timeout, the timer fires (via the kernel&#39;s timer interrupt) and wakes the blocked thread with <code>EAGAIN</code>. The cost is zero unless the timeout actually fires â€” it&#39;s a passive kernel structure, not a polling loop.</h2>\n<h2 id=\"design-decisions-concurrency-models\">Design Decisions: Concurrency Models</h2>\n<table>\n<thead>\n<tr>\n<th>Model</th>\n<th>Max Connections</th>\n<th>Complexity</th>\n<th>Latency</th>\n<th>Used By</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Sequential (Milestone 1)</strong></td>\n<td>1</td>\n<td>Minimal</td>\n<td>Serialized</td>\n<td>Dev tools</td>\n</tr>\n<tr>\n<td><strong>Thread-per-connection</strong></td>\n<td>OS thread limit (~32K)</td>\n<td>Low</td>\n<td>Low</td>\n<td>Apache (legacy)</td>\n</tr>\n<tr>\n<td><strong>Bounded thread pool (this milestone) âœ“</strong></td>\n<td>pool_size active, unlimited queued</td>\n<td>Medium</td>\n<td>Low</td>\n<td>nginx workers, Java Servlet</td>\n</tr>\n<tr>\n<td><strong>epoll event loop (single thread)</strong></td>\n<td>100K+</td>\n<td>High</td>\n<td>Very low</td>\n<td>nginx master loop, Redis, Node.js</td>\n</tr>\n<tr>\n<td><strong>io_uring + async</strong></td>\n<td>100K+</td>\n<td>Very high</td>\n<td>Minimal</td>\n<td>Modern high-performance servers</td>\n</tr>\n<tr>\n<td>The thread pool is the right choice for this project: it handles the real concurrency challenges (bounded resources, keep-alive, graceful shutdown) while remaining understandable. The epoll model â€” where a single thread monitors thousands of sockets and handles I/O events without blocking â€” is the next step on the optimization ladder, but it requires rearchitecting how you think about connection state. Understanding the thread pool model first makes the epoll model&#39;s tradeoffs legible.</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"testing-concurrent-behavior\">Testing Concurrent Behavior</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Build with thread sanitizer to catch data races:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -Wall</span><span style=\"color:#79B8FF\"> -Wextra</span><span style=\"color:#79B8FF\"> -pthread</span><span style=\"color:#79B8FF\"> -fsanitize=thread</span><span style=\"color:#79B8FF\"> -g</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    -o</span><span style=\"color:#9ECBFF\"> http_server_tsan</span><span style=\"color:#79B8FF\"> *</span><span style=\"color:#9ECBFF\">.c</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># --- Test 1: Parallel connections work correctly ---</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./http_server</span><span style=\"color:#79B8FF\"> 8080</span><span style=\"color:#9ECBFF\"> /tmp/www</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">seq</span><span style=\"color:#79B8FF\"> 50</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> http://localhost:8080/index.html</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /tmp/response_</span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\">.html</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">wait</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># All responses should be identical</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">md5sum</span><span style=\"color:#9ECBFF\"> /tmp/response_</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#9ECBFF\">.html</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> awk</span><span style=\"color:#9ECBFF\"> '{print $1}'</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> sort</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> uniq</span><span style=\"color:#79B8FF\"> -c</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: one unique md5 with count 50</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># --- Test 2: Pool exhaustion returns 503 ---</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Send 300 slow connections (pool default is 16)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Use a client that keeps connection open without completing request</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python3</span><span style=\"color:#9ECBFF\"> -</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#9ECBFF\">'EOF'</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">import socket, time, threading</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">def slow_connection(n):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    s = socket.socket()</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    s.connect(('localhost', 8080))</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    s.send(b'GET / HTTP/1.1\\r\\nHost: localhost\\r\\n')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    # Don't send the final \\r\\n â€” connection stays open</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    time.sleep(5)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    s.close()</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">threads = [threading.Thread(target=slow_connection, args=(i,)) for i in range(300)]</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">for t in threads: t.start()</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">time.sleep(1)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\"># Now try a normal request â€” should get 503</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">import urllib.request</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">try:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    resp = urllib.request.urlopen('http://localhost:8080/')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    print(f'Got {resp.status} (expected 503)')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">except urllib.error.HTTPError as e:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    print(f'Got {e.code} (correct: 503)' if e.code == 503 else f'Wrong code: {e.code}')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">EOF</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># --- Test 3: Keep-alive reuse ---</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># HTTP/1.1 with keep-alive uses one TCP connection for multiple requests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#79B8FF\"> --http1.1</span><span style=\"color:#9ECBFF\"> http://localhost:8080/index.html</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">         http://localhost:8080/style.css</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">         http://localhost:8080/app.js</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># In verbose output, look for:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># \"Re-using existing connection\" â€” curl reused the TCP connection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># --- Test 4: Idle timeout closes lingering connections ---</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Connect but don't send anything â€” should be closed after IDLE_TIMEOUT seconds</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">nc</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Just wait. After 30 seconds, the server should close the connection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># You'll see nc print \"Connection closed by foreign host\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># --- Test 5: Graceful shutdown ---</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./http_server</span><span style=\"color:#79B8FF\"> 8080</span><span style=\"color:#9ECBFF\"> /tmp/www</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SERVER_PID</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">$!</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Start a slow download (10MB file) that takes several seconds</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dd</span><span style=\"color:#9ECBFF\"> if=/dev/urandom</span><span style=\"color:#9ECBFF\"> of=/tmp/www/bigfile.bin</span><span style=\"color:#9ECBFF\"> bs=1M</span><span style=\"color:#9ECBFF\"> count=</span><span style=\"color:#79B8FF\">10</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> http://localhost:8080/bigfile.bin</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/null</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">CURL_PID</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">$!</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sleep</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Send SIGTERM while curl is downloading</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">kill</span><span style=\"color:#79B8FF\"> -SIGTERM</span><span style=\"color:#E1E4E8\"> $SERVER_PID</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">wait</span><span style=\"color:#E1E4E8\"> $CURL_PID</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"curl exit code: </span><span style=\"color:#79B8FF\">$?</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\">  # Should be 0 â€” download completed before server exit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># --- Test 6: Thread sanitizer for data races ---</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./http_server_tsan</span><span style=\"color:#79B8FF\"> 8080</span><span style=\"color:#9ECBFF\"> /tmp/www</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">seq</span><span style=\"color:#79B8FF\"> 200</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">do</span><span style=\"color:#B392F0\"> curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> http://localhost:8080/</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/null</span><span style=\"color:#E1E4E8\"> &#x26; </span><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">wait</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">kill</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">pgrep</span><span style=\"color:#9ECBFF\"> http_server_tsan</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check stderr for \"DATA RACE\" reports â€” there should be none</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># --- Test 7: FD leak under sustained load ---</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SERVER_PID</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">pgrep</span><span style=\"color:#9ECBFF\"> http_server</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">BASE</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#E1E4E8\">$SERVER_PID</span><span style=\"color:#9ECBFF\">/fd</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> wc</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">seq</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">do</span><span style=\"color:#B392F0\"> curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> http://localhost:8080/</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/null</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sleep</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">FINAL</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#E1E4E8\">$SERVER_PID</span><span style=\"color:#9ECBFF\">/fd</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> wc</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Base: </span><span style=\"color:#E1E4E8\">$BASE</span><span style=\"color:#9ECBFF\">, Final: </span><span style=\"color:#E1E4E8\">$FINAL</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">[ $((</span><span style=\"color:#B392F0\">FINAL</span><span style=\"color:#9ECBFF\"> -</span><span style=\"color:#9ECBFF\"> BASE</span><span style=\"color:#E1E4E8\">)) </span><span style=\"color:#F97583\">-le</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\"> ] &#x26;&#x26; </span><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"PASS\"</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> echo</span><span style=\"color:#9ECBFF\"> \"FAIL: leaked $((</span><span style=\"color:#B392F0\">FINAL</span><span style=\"color:#9ECBFF\"> - BASE)) FDs\"</span></span></code></pre></div>\n<h2 id=\"the-thread-sanitizer-fsanitizethread-is-a-compiler-level-instrumentation-tool-that-detects-data-races-at-runtime-it-instruments-every-memory-access-and-records-which-thread-last-wrote-each-memory-location-when-two-threads-access-the-same-memory-without-synchronization-it-reports-the-race-with-a-complete-stack-trace-showing-both-threads-running-the-tsan-build-under-load-is-the-definitive-check-that-your-mutex-discipline-is-correct\">The Thread Sanitizer (<code>-fsanitize=thread</code>) is a compiler-level instrumentation tool that detects data races at runtime. It instruments every memory access and records which thread last wrote each memory location. When two threads access the same memory without synchronization, it reports the race with a complete stack trace showing both threads. Running the TSan build under load is the definitive check that your mutex discipline is correct.</h2>\n<h2 id=\"knowledge-cascade-what-this-unlocks\">Knowledge Cascade: What This Unlocks</h2>\n<h3 id=\"1-connection-pool-sizing-the-universal-pattern\">1. Connection Pool Sizing â€” The Universal Pattern</h3>\n<p>The bounded thread pool you just built is the same pattern used everywhere resources are finite and must be shared:\n<strong>Database connection pools</strong> (HikariCP, PgBouncer, pgpool-II): A PostgreSQL database can handle ~100â€“500 concurrent connections before performance degrades. An application server with 1,000 threads would saturate the database with 1,000 simultaneous connections. A connection pool (typically 10â€“50 connections) multiplexes the 1,000 application threads over the available database connections â€” exactly the same queue-and-wait model you built, with the same 503-equivalent (connection acquisition timeout).\n<strong>HTTP client pools</strong> (Go&#39;s <code>http.DefaultTransport</code>, Python&#39;s <code>requests.Session</code>, Java&#39;s <code>HttpClient</code>): Outgoing HTTP requests to external APIs go through a connection pool. <code>MaxIdleConnsPerHost</code> in Go limits how many idle connections to keep warm per target host. The idle timeout that you implemented per-connection is the same as <code>IdleConnTimeout</code> in Go&#39;s transport.\n<strong>Goroutine limiting in Go</strong> (<code>golang.org/x/sync/semaphore</code>, <code>errgroup</code>): Go goroutines are cheap (2KB stack), but unbounded goroutine creation is still a Slowloris-style attack surface. Production Go services use <code>semaphore.Weighted</code> or worker pool patterns â€” exactly what you built, with goroutines instead of pthreads.\n<strong>Kubernetes pod autoscaling</strong> (Horizontal Pod Autoscaler): The HPA watches CPU/memory utilization and adjusts the pod count. The underlying math is the same I/O-bound formula: <code>replicas = ceil(current_utilization / target_utilization)</code>. More replicas = bigger &quot;pool&quot; of workers. The HPA is Little&#39;s Law applied to a distributed system.\nThe math that governs all of these â€” <strong>Little&#39;s Law</strong> (<code>L = Î»W</code>, where <code>L</code> is average queue length, <code>Î»</code> is arrival rate, and <code>W</code> is average time in system) â€” was established by John Little in 1961. Understanding it as you&#39;ve just implemented it makes every discussion of &quot;pool size tuning&quot; and &quot;capacity planning&quot; concrete rather than abstract.</p>\n<h3 id=\"2-why-nginx-uses-event-loops-instead-of-thread-pools\">2. Why nginx Uses Event Loops Instead of Thread Pools</h3>\n<p>Your thread pool model handles concurrency by giving each connection a thread. nginx&#39;s &quot;worker&quot; model handles concurrency differently: each worker process runs a single event loop using <strong>epoll</strong> (Linux&#39;s scalable I/O multiplexing interface), monitoring hundreds of thousands of sockets simultaneously with one thread.\nThe thread pool model hits a wall at roughly 1,000â€“10,000 concurrent connections â€” not because threads are expensive per se, but because:</p>\n<ul>\n<li>Each blocked thread consumes a kernel task_struct whether it&#39;s actively processing or waiting for I/O</li>\n<li>Context switching between thousands of threads adds scheduler overhead</li>\n<li>Memory pressure from many stacks can cause TLB churn\nThe epoll model breaks this wall by reversing the model: instead of &quot;give each connection a thread,&quot; you &quot;have one thread handle all connections, switching between them when I/O is ready.&quot; epoll watches a set of file descriptors and tells you which ones have data available â€” so your one thread only wakes up when there is actual work to do, never burning CPU waiting.\nThe C10K problem (handling 10,000 concurrent connections) was the precise point where thread-per-connection broke and event loops became necessary. Dan Kegel&#39;s 1999 paper &quot;The C10K Problem&quot; documented this breakdown and catalyzed the design of epoll (Linux 2.5.44, 2002). Since then, the C10M problem (10 million connections) has been solved by io_uring (Linux 5.1, 2019), which takes event loops further by allowing truly asynchronous I/O submission â€” no context switches even to check if I/O is ready.\nEvery async/await keyword in Python, Rust, JavaScript, Go, and Kotlin traces back to this same insight that you&#39;ve just hit the wall of: blocking-per-connection doesn&#39;t scale. Your thread pool is the last viable step before the event-loop revolution.</li>\n</ul>\n<h3 id=\"3-lock-granularity-why-databases-use-row-locks-not-table-locks\">3. Lock Granularity â€” Why Databases Use Row Locks, Not Table Locks</h3>\n<p>You protected your shared queue with a single mutex. This is a <strong>coarse-grained lock</strong> â€” one lock for all shared state. It&#39;s correct, simple to reason about, and fast enough for your server&#39;s concurrency level.\nAs concurrency scales, coarse-grained locks become bottlenecks. Every thread that wants to enqueue or dequeue must wait for the one global lock. If the critical section (the time between lock and unlock) is short, lock contention is low and it doesn&#39;t matter. If the critical section is long â€” or many threads contend simultaneously â€” the lock becomes a serialization point that eliminates the benefit of concurrency.\nPostgreSQL uses <strong>row-level locking</strong> instead of table-level locking: <code>UPDATE table SET x=1 WHERE id=5</code> locks only the row with <code>id=5</code>, allowing concurrent <code>UPDATE table SET x=2 WHERE id=7</code> on a different row. The lock granularity matches the actual contention scope.\njemalloc, the memory allocator used by Firefox and FreeBSD, uses <strong>per-CPU arena locking</strong>: instead of one global lock for all allocations, each CPU core has its own arena with its own lock. Threads allocating memory on the same core share a lock; threads on different cores never contend. This reduces lock contention roughly proportionally to the number of CPU cores.\nThe general lesson: choose your lock granularity by mapping it to the actual contention scope. A global mutex is correct. A per-connection mutex (protecting that connection&#39;s state only) allows full parallelism. A per-shard mutex (protecting 1/N of the shared data) is in between. Understanding the tradeoffs starts here, with your single-mutex thread pool.</p>\n<h3 id=\"4-graceful-shutdown-as-a-distributed-systems-primitive\">4. Graceful Shutdown as a Distributed Systems Primitive</h3>\n<p>The four-phase shutdown sequence â€” stop accepting â†’ drain in-flight â†’ notify workers â†’ wait for completion â€” is not just a multi-threading pattern. It is the fundamental primitive for any system that must handle state-changing operations without data loss.\n<strong>Kubernetes pod termination</strong> (<code>terminationGracePeriodSeconds</code>): When Kubernetes sends SIGTERM to a pod, it starts a grace period timer (default 30 seconds). The application should stop accepting new requests, complete in-flight requests, and exit cleanly. If it doesn&#39;t exit within <code>terminationGracePeriodSeconds</code>, Kubernetes sends SIGKILL. This is exactly your four-phase pattern with a deadline.\n<strong>Rolling deployments</strong>: When deploying a new version of a service, you stop traffic to old pods (stop accepting), wait for in-flight requests to complete (drain), then replace the old pod with the new one. The deployment controller implements your four-phase pattern at the infrastructure level.\n<strong>Blue-green deployments</strong>: Route traffic to the new (&quot;green&quot;) environment. The old (&quot;blue&quot;) environment stops accepting new traffic but finishes serving its in-flight requests. Once drained, blue is terminated. Same pattern, distributed across environments.\n<strong>Database connection draining</strong> (PostgreSQL <code>pg_terminate_backend()</code>): When a DBA needs to take a database offline for maintenance, they call <code>pg_terminate_backend()</code> on sessions and then wait for active transactions to commit or roll back. Forcibly killing a transaction mid-way leaves the database in an inconsistent state â€” exactly why graceful shutdown (let transactions complete) matters.\nEvery time you see &quot;draining,&quot; &quot;quiescing,&quot; or &quot;graceful termination&quot; in a distributed systems discussion, it&#39;s your four-phase pattern scaled up.</p>\n<h3 id=\"5-the-c10kc10m-problem-and-the-asyncawait-revolution\">5. The C10K/C10M Problem and the async/await Revolution</h3>\n<h2 id=\"dan-kegel39s-1999-quotc10k-problemquot-paper-described-the-failure-mode-you-just-implemented-a-defense-against-a-server-that-spawns-one-thread-or-process-per-connection-breaks-at-roughly-10000-concurrent-connections-on-typical-hardware-the-paper-asked-can-we-handle-10000-connections-simultaneously-on-a-single-machine-the-answer-required-rethinking-the-programming-model-epoll-2002-kqueue-bsd-2000-iocp-windows-nt-35-all-emerged-as-kernel-interfaces-that-let-a-single-thread-efficiently-monitor-thousands-of-connections-but-writing-epoll-based-code-in-c-is-famously-difficult-you-manage-connection-state-explicitly-across-non-blocking-callbacks-fighting-what39s-called-quotcallback-hellquot-the-solution-to-callback-hell-is-asyncawait-syntactic-sugar-that-makes-non-blocking-io-look-like-sequential-code-python39s-asyncio-javascript39s-promiseasync-rust39s-tokio-go39s-goroutines-which-hide-the-event-loop-behind-a-scheduler-that-looks-like-threads-all-of-them-are-the-language-ecosystem39s-answer-to-quothow-do-we-get-the-performance-of-epoll-without-the-programmer-experience-of-raw-epollquot-understanding-why-your-thread-pool-hits-a-wall-at-scale-and-why-the-alternative-one-thread-watching-thousands-of-fds-via-epoll-is-both-faster-and-harder-to-code-is-the-historical-context-that-makes-asyncawait-meaningful-you-haven39t-just-built-a-thread-pool-you39ve-built-the-exact-system-that-motivated-the-most-significant-paradigm-shift-in-server-side-programming-of-the-past-25-years\">Dan Kegel&#39;s 1999 &quot;C10K Problem&quot; paper described the failure mode you just implemented a defense against: a server that spawns one thread or process per connection breaks at roughly 10,000 concurrent connections on typical hardware. The paper asked: can we handle 10,000 connections simultaneously on a single machine? \nThe answer required rethinking the programming model. epoll (2002), kqueue (BSD, 2000), IOCP (Windows NT 3.5) all emerged as kernel interfaces that let a single thread efficiently monitor thousands of connections. But writing epoll-based code in C is famously difficult â€” you manage connection state explicitly across non-blocking callbacks, fighting what&#39;s called &quot;callback hell.&quot;\nThe solution to callback hell is async/await â€” syntactic sugar that makes non-blocking I/O look like sequential code. Python&#39;s <code>asyncio</code>, JavaScript&#39;s Promise/async, Rust&#39;s <code>tokio</code>, Go&#39;s goroutines (which hide the event loop behind a scheduler that looks like threads) â€” all of them are the language ecosystem&#39;s answer to &quot;how do we get the performance of epoll without the programmer experience of raw epoll?&quot;\nUnderstanding why your thread pool hits a wall at scale â€” and why the alternative (one thread watching thousands of fds via epoll) is both faster and harder to code â€” is the historical context that makes async/await meaningful. You haven&#39;t just built a thread pool: you&#39;ve built the exact system that motivated the most significant paradigm shift in server-side programming of the past 25 years.</h2>\n<h2 id=\"common-mistakes-that-will-burn-you\">Common Mistakes That Will Burn You</h2>\n<p><strong>1. Holding the mutex while doing network I/O.</strong>\nThis is the most common threading mistake in server code. If you call <code>read()</code>, <code>write()</code>, or <code>serve_static_file()</code> while holding <code>pool-&gt;lock</code>, all other threads are blocked waiting for the lock for the entire duration of the I/O operation. Your &quot;16-thread concurrent server&quot; behaves like a sequential server. The rule: acquire the lock, modify the queue (a few pointer updates), release the lock, then do the I/O.\n<strong>2. Checking the shutdown flag without the lock.</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG â€” data race:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (pool</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">shutdown) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CORRECT:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">lock</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> s </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pool</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">shutdown;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">lock</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (s) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n<p>Reading <code>pool-&gt;shutdown</code> without the mutex is a data race â€” undefined behavior per the C11 standard. The compiler may optimize away the repeated read, caching it in a register and never re-reading from memory (&quot;the value can&#39;t change, it&#39;s not volatile&quot;). An alternative is <code>atomic_int</code> with <code>atomic_load_explicit()</code> using the appropriate memory ordering â€” but using the mutex you already have is simpler and equally correct.\n<strong>3. Forgetting <code>pthread_detach()</code> or <code>pthread_join()</code> for every thread.</strong>\nThe signal handler thread in our design is <code>pthread_detach()</code>&#39;d â€” it runs once, handles one signal, and exits. Every <code>pthread_create()</code> must be matched by either <code>pthread_join()</code> (to collect exit status and free resources) or <code>pthread_detach()</code> (to let the thread clean up itself). An unjoined, undetached thread is a zombie: its task_struct stays in the kernel until the process exits.\n<strong>4. Using <code>signal()</code> instead of <code>pthread_sigmask()</code> for multi-threaded signal masking.</strong>\n<code>signal()</code> sets the disposition (what happens when a signal arrives) but does not control which thread receives it. Only <code>pthread_sigmask()</code> controls the signal mask per-thread. Setting <code>signal(SIGTERM, handler)</code> in a multi-threaded program means SIGTERM calls <code>handler</code> in whichever thread the kernel picks â€” which might be a worker thread in the middle of <code>write()</code>. Use <code>pthread_sigmask()</code> to block signals in all threads, then use <code>sigwait()</code> in a dedicated signal thread.\n<strong>5. The <code>while</code> loop, not <code>if</code>, around <code>pthread_cond_wait()</code>.</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG â€” spurious wakeup causes incorrect behavior:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (pool</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">queue_size </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_cond_wait</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->not_empty, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->lock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// here we assume queue is non-empty â€” WRONG if it was a spurious wakeup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CORRECT:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (pool</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">queue_size </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">pool</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">shutdown) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_cond_wait</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->not_empty, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->lock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"posix-permits-spurious-wakeups-from-pthread_cond_wait-a-thread-can-return-from-the-wait-even-if-no-signal-was-sent-always-re-check-the-condition-in-a-while-loop-6-not-setting-so_rcvtimeo-before-the-keep-alive-loop-if-you-set-the-timeout-option-inside-the-loop-on-each-iteration-you-incur-an-extra-syscall-per-request-set-it-once-per-connection-before-the-for-loop-the-timeout-applies-to-all-subsequent-reads-on-that-socket-7-not-sending-503-when-the-pool-queue-is-full-just-closing-the-fd-silently-closing-a-tcp-connection-without-sending-an-http-response-leaves-the-client-hanging-waiting-for-data-that-never-arrives-the-client39s-browser-shows-a-quotconnection-resetquot-error-with-no-explanation-sending-a-503-response-takes-milliseconds-and-gives-the-client-actionable-information-quotserver-busy-try-laterquot-always-send-a-response-before-closing\">POSIX permits spurious wakeups from <code>pthread_cond_wait()</code>. A thread can return from the wait even if no signal was sent. Always re-check the condition in a <code>while</code> loop.\n<strong>6. Not setting <code>SO_RCVTIMEO</code> before the keep-alive loop.</strong>\nIf you set the timeout option inside the loop on each iteration, you incur an extra syscall per request. Set it once per connection, before the <code>for(;;)</code> loop. The timeout applies to all subsequent reads on that socket.\n<strong>7. Not sending 503 when the pool queue is full â€” just closing the FD.</strong>\nSilently closing a TCP connection (without sending an HTTP response) leaves the client hanging, waiting for data that never arrives. The client&#39;s browser shows a &quot;connection reset&quot; error with no explanation. Sending a 503 response takes milliseconds and gives the client actionable information (&quot;server busy, try later&quot;). Always send a response before closing.</h2>\n<h2 id=\"acceptance-criteria-checklist\">Acceptance Criteria Checklist</h2>\n<p>Before calling this project complete, verify each of these:</p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> <code>./http_server 8080 /tmp/www</code> starts with &quot;Thread pool: 16 workers, queue capacity 256&quot; (or configured values)</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>for i in $(seq 50); do curl -s http://localhost:8080/ &amp; done; wait</code> â€” all 50 responses are <code>200 OK</code> with correct content</li>\n<li><input disabled=\"\" type=\"checkbox\"> Under Slowloris-style load (300 slow connections), the 301st connection receives <code>503 Service Unavailable</code> rather than timing out silently</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>curl -v --http1.1 http://localhost:8080/index.html http://localhost:8080/style.css</code> shows &quot;Re-using existing connection&quot; in verbose output</li>\n<li><input disabled=\"\" type=\"checkbox\"> An idle connection is closed after <code>idle_timeout</code> seconds (default 30) â€” verified with <code>nc localhost 8080</code> (no request sent)</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>Connection: close</code> in a request causes the server to close after responding â€” verified with <code>curl -H &quot;Connection: close&quot; -v http://localhost:8080/</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> SIGTERM causes graceful shutdown: in-flight downloads complete, server then exits with code 0</li>\n<li><input disabled=\"\" type=\"checkbox\"> SIGINT (Ctrl+C) causes the same graceful shutdown behavior as SIGTERM</li>\n<li><input disabled=\"\" type=\"checkbox\"> The thread sanitizer build (<code>-fsanitize=thread</code>) reports zero data races under parallel load</li>\n<li><input disabled=\"\" type=\"checkbox\"> FD count after 10,000 sequential connections matches baseline (within tolerance of 2)</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>pool-&gt;total_requests</code> counter accurately reflects total served requests (verify via server stats output or log)</li>\n<li><input disabled=\"\" type=\"checkbox\"> Server logs show correct client IP and request line from each worker thread, without interleaving (log mutex prevents garbling)</li>\n<li><input disabled=\"\" type=\"checkbox\"> After all workers are joined on shutdown, <code>valgrind --leak-check=full</code> reports no memory leaks</li>\n<li><input disabled=\"\" type=\"checkbox\"> Thread pool size and queue capacity are configurable (compile-time constants at minimum, runtime arguments preferred)</li>\n</ul>\n<hr>\n<!-- END_MS -->\n\n\n\n\n<h1 id=\"tdd\">TDD</h1>\n<p>A socket-level HTTP/1.1 server built from first principles: raw TCP socket lifecycle, adversarial HTTP parsing per RFC 7230, security-hardened static file serving with path canonicalization, and concurrent connection handling via a bounded thread pool with keep-alive and graceful shutdown. Every abstraction that frameworks hide â€” partial reads, CRLF parsing, MIME detection, realpath security, mutex-protected shared state â€” is made explicit and implementation-grade.</p>\n<!-- TDD_MOD_ID: http-server-basic-m1 -->\n<h1 id=\"module-specification-tcp-server-amp-http-response-http-server-basic-m1\">MODULE SPECIFICATION: TCP Server &amp; HTTP Response (http-server-basic-m1)</h1>\n<h2 id=\"1-module-charter\">1. Module Charter</h2>\n<p>This module establishes the foundational network &quot;Entry Point&quot; for the HTTP server. It is responsible for the complete lifecycle of a TCP listening socket and the sequential handling of incoming client connections.</p>\n<p><strong>Core Responsibilities:</strong></p>\n<ul>\n<li>Initialize a passive TCP socket (the &quot;Listening Socket&quot;) bound to a configurable port.</li>\n<li>Implement the &quot;Seven-Step Socket Dance&quot;: <code>socket</code>, <code>setsockopt</code>, <code>bind</code>, <code>listen</code>, <code>accept</code>, <code>read/write</code>, <code>close</code>.</li>\n<li>Solve the &quot;Partial Read Problem&quot; by accumulating raw bytes into a fixed-size buffer until the HTTP header delimiter (<code>\\r\\n\\r\\n</code>) is detected.</li>\n<li>Construct a standards-compliant (RFC 7230) hardcoded HTTP/1.1 200 OK response.</li>\n<li>Ensure robust resource management by preventing file descriptor (FD) leaks and handling broken pipe signals (SIGPIPE).</li>\n</ul>\n<p><strong>What this module does NOT do:</strong></p>\n<ul>\n<li>It does <strong>not</strong> parse the HTTP request (it treats it as raw bytes).</li>\n<li>It does <strong>not</strong> handle concurrent connections (it is strictly sequential).</li>\n<li>It does <strong>not</strong> serve files from disk (the response is hardcoded in memory).</li>\n</ul>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>Every successfully <code>accept()</code>&#39;ed file descriptor MUST be <code>close()</code>&#39;d before the next <code>accept()</code> call.</li>\n<li>The server must never crash due to a client disconnecting mid-write (SIGPIPE).</li>\n</ul>\n<hr>\n<h2 id=\"2-file-structure\">2. File Structure</h2>\n<p>The implementation shall follow this numbered creation order:</p>\n<ol>\n<li><code>server.h</code>: Data structures and function prototypes.</li>\n<li><code>utils.c</code>: Helper functions for robust I/O (<code>write_all</code>, <code>read_http_request</code>).</li>\n<li><code>http.c</code>: HTTP response construction logic.</li>\n<li><code>server.c</code>: The core socket lifecycle and accept loop.</li>\n<li><code>main.c</code>: CLI entry point and signal initialization.</li>\n</ol>\n<hr>\n<h2 id=\"3-complete-data-model\">3. Complete Data Model</h2>\n<h3 id=\"31-server-configuration-struct\">3.1 Server Configuration Struct</h3>\n<p>This struct persists for the lifetime of the server process.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Offset (64-bit)</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>port</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">0x00</td>\n<td align=\"left\">The TCP port to bind (default 8080).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>server_fd</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">0x04</td>\n<td align=\"left\">The listening socket file descriptor.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>is_running</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">0x08</td>\n<td align=\"left\">Boolean flag for the accept loop.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>padding</code></td>\n<td align=\"left\"><code>char[4]</code></td>\n<td align=\"left\">0x0C</td>\n<td align=\"left\">Alignment padding to 16-byte boundary.</td>\n</tr>\n</tbody></table>\n<p><strong>Total Size:</strong> 16 bytes.</p>\n<h3 id=\"32-constants\">3.2 Constants</h3>\n<ul>\n<li><code>REQUEST_BUF_SIZE</code>: 8192 (8KB). Caps memory usage per request. Matches standard URI/header limits.</li>\n<li><code>BACKLOG</code>: <code>SOMAXCONN</code>. The kernel-level queue for pending connections.</li>\n<li><code>MAX_RESPONSE_SIZE</code>: 4096 (4KB). Sufficient for hardcoded headers and small HTML body.</li>\n</ul>\n<hr>\n<h2 id=\"4-interface-contracts\">4. Interface Contracts</h2>\n<h3 id=\"41-ssize_t-read_http_requestint-client_fd-char-buf-size_t-buf_size-int-header_end\">4.1 <code>ssize_t read_http_request(int client_fd, char *buf, size_t buf_size, int *header_end)</code></h3>\n<ul>\n<li><strong>Purpose</strong>: Accumulate bytes until <code>\\r\\n\\r\\n</code> is found.</li>\n<li><strong>Parameters</strong>: <ul>\n<li><code>client_fd</code>: The socket to read from.</li>\n<li><code>buf</code>: The destination buffer.</li>\n<li><code>buf_size</code>: Maximum capacity.</li>\n<li><code>header_end</code>: [OUT] Offset in <code>buf</code> where headers end (start of body).</li>\n</ul>\n</li>\n<li><strong>Return</strong>: Total bytes read on success, <code>0</code> on client disconnect, <code>-1</code> on error or buffer overflow.</li>\n</ul>\n<h3 id=\"42-int-write_allint-fd-const-char-buf-size_t-len\">4.2 <code>int write_all(int fd, const char *buf, size_t len)</code></h3>\n<ul>\n<li><strong>Purpose</strong>: Ensure all bytes are written despite partial writes or interrupts.</li>\n<li><strong>Return</strong>: <code>0</code> on success, <code>-1</code> on error.</li>\n</ul>\n<h3 id=\"43-int-build_hardcoded_responsechar-buf-size_t-buf_size\">4.3 <code>int build_hardcoded_response(char *buf, size_t buf_size)</code></h3>\n<ul>\n<li><strong>Purpose</strong>: Populate <code>buf</code> with a valid HTTP response string.</li>\n<li><strong>Includes</strong>: <code>Date</code> (RFC 1123 format), <code>Content-Type</code>, <code>Content-Length</code>, <code>Connection: close</code>.</li>\n<li><strong>Return</strong>: Length of response string or <code>-1</code> on overflow.</li>\n</ul>\n<hr>\n<h2 id=\"5-algorithm-specification\">5. Algorithm Specification</h2>\n<h3 id=\"51-the-socket-dance-phase-1-2\">5.1 The Socket Dance (Phase 1-2)</h3>\n<ol>\n<li><strong>socket()</strong>: Call <code>socket(AF_INET, SOCK_STREAM, 0)</code>.</li>\n<li><strong>setsockopt()</strong>: Set <code>SO_REUSEADDR</code> to <code>1</code> on <code>SOL_SOCKET</code>. This is mandatory for rapid server restarts.</li>\n<li><strong>bind()</strong>: <ul>\n<li>Initialize <code>struct sockaddr_in</code>.</li>\n<li>Use <code>htons(port)</code> for the port (Network Byte Order).</li>\n<li>Use <code>INADDR_ANY</code> for the IP.</li>\n</ul>\n</li>\n<li><strong>listen()</strong>: Set backlog to <code>SOMAXCONN</code>.</li>\n</ol>\n<h3 id=\"52-the-accumulation-loop-phase-3\">5.2 The Accumulation Loop (Phase 3)</h3>\n<p>{{DIAGRAM:tdd-diag-1|HTTP Accumulation Flow|Flowchart of read() calls searching for delimiter}}</p>\n<ol>\n<li>Initialize <code>total_read = 0</code>.</li>\n<li>While <code>total_read &lt; buf_size - 1</code>:<ul>\n<li><code>n = read(client_fd, buf + total_read, buf_size - 1 - total_read)</code>.</li>\n<li>If <code>n &lt;= 0</code>: Return <code>n</code> (Error or Disconnect).</li>\n<li><code>total_read += n</code>.</li>\n<li><code>buf[total_read] = &#39;\\0&#39;</code> (Null-terminate for <code>strstr</code>).</li>\n<li><code>found = strstr(buf, &quot;\\r\\n\\r\\n&quot;)</code>.</li>\n<li>If <code>found</code>:<ul>\n<li>Calculate <code>*header_end = (found - buf) + 4</code>.</li>\n<li>Return <code>total_read</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>If loop exits without <code>found</code>: Return <code>-1</code> (Request too large).</li>\n</ol>\n<h3 id=\"53-the-sequential-accept-loop\">5.3 The Sequential Accept Loop</h3>\n<ol>\n<li>Call <code>accept(server_fd, ...)</code> which blocks.</li>\n<li>Log client IP/Port via <code>inet_ntop</code> and <code>ntohs</code>.</li>\n<li>Invoke <code>read_http_request</code>.</li>\n<li>If success: Invoke <code>build_hardcoded_response</code> and <code>write_all</code>.</li>\n<li><strong>CRITICAL</strong>: Call <code>close(client_fd)</code> in all branches (success or failure) before looping.</li>\n</ol>\n<hr>\n<h2 id=\"6-error-handling-matrix\">6. Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error</th>\n<th align=\"left\">Detected By</th>\n<th align=\"left\">Recovery</th>\n<th align=\"left\">User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>EADDRINUSE</code></td>\n<td align=\"left\"><code>bind()</code></td>\n<td align=\"left\">Exit process with code 1.</td>\n<td align=\"left\">Yes (Console)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EINTR</code></td>\n<td align=\"left\"><code>accept()</code></td>\n<td align=\"left\"><code>continue</code> the loop immediately.</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EMFILE</code></td>\n<td align=\"left\"><code>accept()</code></td>\n<td align=\"left\"><code>sleep(1)</code>, log error, <code>continue</code>.</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EPIPE</code></td>\n<td align=\"left\"><code>write()</code></td>\n<td align=\"left\">Stop writing, <code>close(client_fd)</code>, log disconnect.</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\">Buffer Overflow</td>\n<td align=\"left\"><code>read_http_request</code></td>\n<td align=\"left\"><code>close(client_fd)</code>, do not respond.</td>\n<td align=\"left\">No (Server logs only)</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"7-implementation-sequence-with-checkpoints\">7. Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-socket-setup-1-hour\">Phase 1: Socket Setup (1 hour)</h3>\n<ul>\n<li>Implement <code>socket_init(int port)</code>.</li>\n<li><strong>Checkpoint</strong>: Run <code>netstat -tulpn | grep :8080</code>. You should see the process in <code>LISTEN</code> state.</li>\n</ul>\n<h3 id=\"phase-2-accept-loop-amp-logging-05-hours\">Phase 2: Accept Loop &amp; Logging (0.5 hours)</h3>\n<ul>\n<li>Implement the infinite loop calling <code>accept()</code>.</li>\n<li><strong>Checkpoint</strong>: Connect via <code>nc localhost 8080</code>. Server should print &quot;Connection from 127.0.0.1&quot;.</li>\n</ul>\n<h3 id=\"phase-3-the-accumulator-1-hour\">Phase 3: The Accumulator (1 hour)</h3>\n<ul>\n<li>Implement <code>read_http_request</code>.</li>\n<li><strong>Checkpoint</strong>: Use <code>telnet localhost 8080</code>. Type <code>GET /</code> and press Enter once. Server should NOT respond. Type <code>\\r\\n\\r\\n</code>. Server should now acknowledge receipt.</li>\n</ul>\n<h3 id=\"phase-4-response-amp-write_all-1-hour\">Phase 4: Response &amp; write_all (1 hour)</h3>\n<ul>\n<li>Implement <code>write_all</code> and <code>build_hardcoded_response</code>.</li>\n<li>Handle <code>SIGPIPE</code> using <code>signal(SIGPIPE, SIG_IGN)</code>.</li>\n<li><strong>Checkpoint</strong>: <code>curl -v http://localhost:8080</code>. You should see full headers, the HTML body, and <code>* Connection #0 to host localhost left intact</code>.</li>\n</ul>\n<hr>\n<h2 id=\"8-test-specification\">8. Test Specification</h2>\n<h3 id=\"81-happy-path-curl\">8.1 Happy Path: curl</h3>\n<ul>\n<li><strong>Command</strong>: <code>curl -v http://localhost:8080/</code></li>\n<li><strong>Requirement</strong>: HTTP 200 OK, <code>Content-Length</code> matches body size, <code>Date</code> matches current UTC time.</li>\n</ul>\n<h3 id=\"82-failure-delimiter-search\">8.2 Failure: Delimiter Search</h3>\n<ul>\n<li><strong>Command</strong>: <code>printf &quot;GET / HTTP/1.1\\r\\n&quot; | nc -q 2 localhost 8080</code></li>\n<li><strong>Requirement</strong>: Server should hang waiting for the final <code>\\r\\n</code>, then close connection (timeout or client quit). It must NOT send a 200 OK for a partial header.</li>\n</ul>\n<h3 id=\"83-resource-leak-test\">8.3 Resource Leak Test</h3>\n<ul>\n<li><strong>Command</strong>: <code>for i in {1..1000}; do curl -s http://localhost:8080/ &gt; /dev/null; done</code></li>\n<li><strong>Requirement</strong>: Check <code>ls /proc/$(pgrep http_server)/fd | wc -l</code>. The count must be identical before and after the loop.</li>\n</ul>\n<hr>\n<h2 id=\"9-performance-targets\">9. Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target</th>\n<th align=\"left\">How to Measure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Request Latency</strong></td>\n<td align=\"left\">&lt; 2ms</td>\n<td align=\"left\"><code>curl -w &quot;%{time_total}\\n&quot; -o /dev/null -s http://localhost:8080/</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>FD Baseline</strong></td>\n<td align=\"left\">&lt; 5</td>\n<td align=\"left\"><code>ls /proc/self/fd | wc -l</code> (stdin, out, err, server_fd + 1)</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Throughput</strong></td>\n<td align=\"left\">&gt; 2000 req/sec</td>\n<td align=\"left\"><code>wrk -t1 -c1 -d10s http://localhost:8080/</code> (Sequential)</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"10-hardware-soul-amp-memory-layout\">10. Hardware Soul &amp; Memory Layout</h2>\n<h3 id=\"cache-line-optimization\">Cache Line Optimization</h3>\n<p>The <code>char req_buf[8192]</code> is the most &quot;touched&quot; memory area. </p>\n<ul>\n<li><strong>Alignment</strong>: The buffer should be 64-byte aligned to prevent &quot;false sharing&quot; and ensure efficient cache line fills (though less critical in single-threaded mode, it&#39;s good practice).</li>\n<li><strong>Access Pattern</strong>: <code>strstr</code> scans sequentially. Modern CPUs (x86_64) will prefetch the next cache lines (64B segments) automatically during the scan.</li>\n</ul>\n<h3 id=\"memory-layout-table\">Memory Layout Table</h3>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Memory Segment</th>\n<th align=\"left\">Object</th>\n<th align=\"left\">Size</th>\n<th align=\"left\">Life Span</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Stack</strong></td>\n<td align=\"left\"><code>req_buf</code></td>\n<td align=\"left\">8192 B</td>\n<td align=\"left\">Connection Duration</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Stack</strong></td>\n<td align=\"left\"><code>resp_buf</code></td>\n<td align=\"left\">4096 B</td>\n<td align=\"left\">Response Generation</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Static</strong></td>\n<td align=\"left\"><code>server_config</code></td>\n<td align=\"left\">16 B</td>\n<td align=\"left\">Process Lifetime</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Kernel</strong></td>\n<td align=\"left\"><code>socket_buffer</code></td>\n<td align=\"left\">~87 KB</td>\n<td align=\"left\">Socket Lifetime</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"11-concurrency-specification-the-barrier\">11. Concurrency Specification: The Barrier</h2>\n<p>This module uses a <strong>Blocked Sequential Model</strong>.</p>\n<p>{{DIAGRAM:tdd-diag-2|Sequential Blocking|Timeline showing Accept -&gt; Read -&gt; Write -&gt; Close}}</p>\n<ol>\n<li>The <code>accept()</code> call blocks the main thread.</li>\n<li>While processing, any other clients are held in the <strong>Kernel TCP Backlog</strong>.</li>\n<li>If the backlog (e.g., 128) fills up, new clients will receive &quot;Connection Refused&quot; (ECONNREFUSED).</li>\n<li><strong>Benefit</strong>: No race conditions, no mutexes, trivial to debug.</li>\n<li><strong>Constraint</strong>: A slow client (Slowloris) can hang the server by connecting and sending nothing. This will be solved in Milestone 4.</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* interface contract signatures */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> server_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">server_config_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> port</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#B392F0\"> read_http_request</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> client_fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> buf_size</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">header_end</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> write_all</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> len</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> build_hardcoded_response</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> buf_size</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> handle_client</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> client_fd</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: http-server-basic-m2 -->\n<h1 id=\"module-specification-http-request-parsing-http-server-basic-m2\">MODULE SPECIFICATION: HTTP Request Parsing (http-server-basic-m2)</h1>\n<h2 id=\"1-module-charter\">1. Module Charter</h2>\n<p>This module serves as the semantic gateway of the server, transforming raw, untrusted byte streams from the network (Milestone 1) into a structured, validated <code>http_request_t</code> object. It acts as the primary defense against protocol-level attacks and malformed inputs.</p>\n<p><strong>Core Responsibilities:</strong></p>\n<ul>\n<li>Implement an adversarial-safe parser for HTTP/1.1 request lines and headers.</li>\n<li>Enforce strict RFC 7230 structural constraints (CRLF line endings, single space delimiters).</li>\n<li>Normalize header names to lowercase for case-insensitive lookup.</li>\n<li>Extract semantic control fields: <code>Content-Length</code> (for body framing), <code>Connection</code> (for keep-alive), and <code>Host</code> (mandatory in HTTP/1.1).</li>\n<li>Prevent buffer overruns and resource exhaustion via hard URI and header length limits.</li>\n<li>Generate and transmit standards-compliant HTTP error responses (400, 414, 501) for invalid inputs.</li>\n</ul>\n<p><strong>Downstream Dependencies:</strong></p>\n<ul>\n<li>Milestone 3 (Static File Serving) relies on the <code>path</code> and <code>method</code> fields for resource location.</li>\n<li>Milestone 4 (Concurrency) relies on the <code>keep_alive</code> flag to manage connection persistence.</li>\n</ul>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>The parser MUST NOT modify the original request buffer (except for temporary null-termination during line-at-a-time processing).</li>\n<li>The parser MUST perform zero dynamic memory allocations (<code>malloc</code>) to ensure predictable latency and prevent heap fragmentation.</li>\n<li>All extracted strings (path, header values) MUST be null-terminated within the <code>http_request_t</code> structure.</li>\n</ul>\n<hr>\n<h2 id=\"2-file-structure\">2. File Structure</h2>\n<p>The implementation is realized in the following sequence:</p>\n<ol>\n<li><code>http_types.h</code>: Definition of enums, constants, and the monolithic <code>http_request_t</code> struct.</li>\n<li><code>http_parser.h</code>: Prototypes for parsing and header lookup functions.</li>\n<li><code>http_parser.c</code>: Implementation of the state-machine/line-iterator parsing logic.</li>\n<li><code>http_errors.h</code>: Error response templates and constants.</li>\n<li><code>http_errors.c</code>: Implementation of <code>send_error_response</code> and convenience wrappers.</li>\n</ol>\n<hr>\n<h2 id=\"3-complete-data-model\">3. Complete Data Model</h2>\n<h3 id=\"31-enumerations\">3.1 Enumerations</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    METHOD_GET,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    METHOD_HEAD,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    METHOD_POST,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    METHOD_UNKNOWN</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">http_method_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<h3 id=\"32-header-entry-struct\">3.2 Header Entry Struct</h3>\n<p>Each header is stored in a fixed-size slot.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Size</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>name</code></td>\n<td align=\"left\"><code>char[256]</code></td>\n<td align=\"left\">256 B</td>\n<td align=\"left\">Lowercase normalized header name.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>value</code></td>\n<td align=\"left\"><code>char[8192]</code></td>\n<td align=\"left\">8192 B</td>\n<td align=\"left\">OWS-stripped header value.</td>\n</tr>\n</tbody></table>\n<h3 id=\"33-the-http-request-struct-http_request_t\">3.3 The HTTP Request Struct (<code>http_request_t</code>)</h3>\n<p>This structure is designed for stack allocation within the connection handler. Note the significant size due to fixed-buffer constraints (approx 270KB).</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Offset</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>method</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">0x00</td>\n<td align=\"left\"><code>http_method_t</code> enum value.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>path</code></td>\n<td align=\"left\"><code>char[8192]</code></td>\n<td align=\"left\">0x04</td>\n<td align=\"left\">Parsed URI path (null-terminated).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>http_minor</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">0x2004</td>\n<td align=\"left\">0 for 1.0, 1 for 1.1.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>headers</code></td>\n<td align=\"left\"><code>http_header_t[32]</code></td>\n<td align=\"left\">0x2008</td>\n<td align=\"left\">Contiguous array of header pairs.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>header_count</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">0x44008</td>\n<td align=\"left\">Current valid entries in <code>headers</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>content_length</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">0x4400C</td>\n<td align=\"left\">-1 if absent, else byte count.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>keep_alive</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">0x44010</td>\n<td align=\"left\">1 if persistent, 0 if close.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>body</code></td>\n<td align=\"left\"><code>const char*</code></td>\n<td align=\"left\">0x44018</td>\n<td align=\"left\">Pointer into the original M1 buffer.</td>\n</tr>\n</tbody></table>\n<p><strong>Total Size:</strong> ~278,560 Bytes. \n<em>Note: Ensure the server&#39;s thread stack size (default 8MB on Linux) is respected. If spawning many threads in M4, use <code>pthread_attr_setstacksize</code> if 270KB per thread is problematic.</em></p>\n<p>{{DIAGRAM:tdd-diag-7|Request Struct Memory Layout|Visualization of the 270KB stack-allocated struct and its alignment}}</p>\n<hr>\n<h2 id=\"4-interface-contracts\">4. Interface Contracts</h2>\n<h3 id=\"41-int-parse_http_requestconst-char-buf-size_t-buf_len-int-header_end-http_request_t-req\">4.1 <code>int parse_http_request(const char *buf, size_t buf_len, int header_end, http_request_t *req)</code></h3>\n<ul>\n<li><strong>Inputs</strong>: Raw buffer, total bytes read, and the offset of <code>\\r\\n\\r\\n</code>.</li>\n<li><strong>Outputs</strong>: 0 on success, or an HTTP error code (400, 414, 501) on failure.</li>\n<li><strong>Contract</strong>: Rejects any request with more than 32 headers or lines exceeding 8KB.</li>\n</ul>\n<h3 id=\"42-const-char-request_get_headerconst-http_request_t-req-const-char-name\">4.2 <code>const char* request_get_header(const http_request_t *req, const char *name)</code></h3>\n<ul>\n<li><strong>Inputs</strong>: Request struct and a <strong>lowercase</strong> name to search for.</li>\n<li><strong>Return</strong>: Pointer to the value string, or <code>NULL</code> if not found.</li>\n<li><strong>Complexity</strong>: O(N) where N is <code>header_count</code>.</li>\n</ul>\n<h3 id=\"43-void-send_error_responseint-client_fd-int-status-const-char-reason-const-char-body\">4.3 <code>void send_error_response(int client_fd, int status, const char *reason, const char *body)</code></h3>\n<ul>\n<li><strong>Inputs</strong>: Socket FD, status code (e.g., 414), phrase (e.g., &quot;URI Too Long&quot;), and HTML body.</li>\n<li><strong>Invariants</strong>: Must include <code>Date</code>, <code>Content-Length</code>, and <code>Connection: close</code>.</li>\n</ul>\n<hr>\n<h2 id=\"5-algorithm-specification\">5. Algorithm Specification</h2>\n<h3 id=\"51-request-line-parsing-parse_request_line\">5.1 Request Line Parsing (<code>parse_request_line</code>)</h3>\n<p>The request line is the first line of the buffer. It must follow the format <code>METHOD SP URI SP VERSION</code>.</p>\n<ol>\n<li><strong>Token 1 (Method)</strong>: <ul>\n<li>Locate the first <code> </code> (space) using <code>memchr</code>.</li>\n<li>Length check: Must be between 3 and 4 characters for supported methods.</li>\n<li>Use <code>memcmp</code> to map <code>GET</code>, <code>HEAD</code>, <code>POST</code> to enums. If valid but unsupported, return <code>501</code>.</li>\n</ul>\n</li>\n<li><strong>Token 2 (URI)</strong>:<ul>\n<li>Locate the second <code> </code> (space).</li>\n<li>Distance between spaces is the <code>path_len</code>. </li>\n<li><strong>Boundary Check</strong>: If <code>path_len &gt;= 8192</code>, return <code>414</code>.</li>\n<li>Copy to <code>req-&gt;path</code> and null-terminate.</li>\n</ul>\n</li>\n<li><strong>Token 3 (Version)</strong>:<ul>\n<li>Must be exactly <code>HTTP/1.0</code> or <code>HTTP/1.1</code>.</li>\n<li>Verify prefix <code>HTTP/1.</code>.</li>\n<li>Set <code>req-&gt;http_minor</code> based on the final digit. If not &#39;0&#39; or &#39;1&#39;, return <code>400</code>.</li>\n</ul>\n</li>\n</ol>\n<p>{{DIAGRAM:tdd-diag-8|Request Line Tokenization|Step-by-step pointers moving through the first line}}</p>\n<h3 id=\"52-header-normalization-and-storage-parse_header_line\">5.2 Header Normalization and Storage (<code>parse_header_line</code>)</h3>\n<p>Executed for every line after the first until a blank line is hit.</p>\n<ol>\n<li><strong>Split</strong>: Locate first <code>:</code> using <code>strchr</code>. If no colon, skip line (robustness).</li>\n<li><strong>Name Processing</strong>: <ul>\n<li>Copy prefix (name) to <code>headers[i].name</code>.</li>\n<li>Invoke <code>str_to_lower</code> on the field name. This facilitates O(1) case-insensitive comparisons later.</li>\n</ul>\n</li>\n<li><strong>Value Processing (OWS Strip)</strong>:<ul>\n<li>Pointer <code>p</code> starts at <code>colon + 1</code>.</li>\n<li>While <code>*p == &#39; &#39; || *p == &#39;\\t&#39;</code>, increment <code>p</code>.</li>\n<li>Locate end of string; backtrack to remove trailing spaces.</li>\n<li>Copy to <code>headers[i].value</code>.</li>\n</ul>\n</li>\n<li><strong>Counter</strong>: Increment <code>req-&gt;header_count</code>. If <code>&gt; 32</code>, stop parsing further headers.</li>\n</ol>\n<h3 id=\"53-semantic-extraction-extract_semantic_headers\">5.3 Semantic Extraction (<code>extract_semantic_headers</code>)</h3>\n<p>Post-parse logic to set control flags.</p>\n<ol>\n<li><strong>Host</strong>: <ul>\n<li><code>request_get_header(req, &quot;host&quot;)</code>.</li>\n<li>If <code>http_minor == 1</code> and <code>host == NULL</code>, return <code>400</code> (Required in HTTP/1.1).</li>\n</ul>\n</li>\n<li><strong>Content-Length</strong>:<ul>\n<li><code>val_str = request_get_header(req, &quot;content-length&quot;)</code>.</li>\n<li>Use <code>strtol(val_str, &amp;end, 10)</code>. If <code>*end != &#39;\\0&#39;</code> or value <code>&lt; 0</code>, set <code>content_length = -1</code>.</li>\n</ul>\n</li>\n<li><strong>Keep-Alive</strong>:<ul>\n<li>If <code>http_minor == 1</code>: Default <code>1</code>, set <code>0</code> only if <code>Connection: close</code>.</li>\n<li>If <code>http_minor == 0</code>: Default <code>0</code>, set <code>1</code> only if <code>Connection: keep-alive</code>.</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"6-error-handling-matrix\">6. Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error Condition</th>\n<th align=\"left\">Status Code</th>\n<th align=\"left\">Detection Point</th>\n<th align=\"left\">Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Path &gt; 8191 chars</td>\n<td align=\"left\">414</td>\n<td align=\"left\"><code>parse_request_line</code></td>\n<td align=\"left\">Call <code>send_414()</code>, close socket</td>\n</tr>\n<tr>\n<td align=\"left\">Method is <code>DELETE</code></td>\n<td align=\"left\">501</td>\n<td align=\"left\"><code>parse_request_line</code></td>\n<td align=\"left\">Call <code>send_501()</code>, close socket</td>\n</tr>\n<tr>\n<td align=\"left\">Missing <code>Host</code> (1.1)</td>\n<td align=\"left\">400</td>\n<td align=\"left\"><code>extract_semantic_headers</code></td>\n<td align=\"left\">Call <code>send_400()</code>, close socket</td>\n</tr>\n<tr>\n<td align=\"left\">Space in URI</td>\n<td align=\"left\">400</td>\n<td align=\"left\"><code>parse_request_line</code></td>\n<td align=\"left\">RFC violation, 400</td>\n</tr>\n<tr>\n<td align=\"left\">Invalid <code>Content-Length</code></td>\n<td align=\"left\">400</td>\n<td align=\"left\"><code>extract_semantic_headers</code></td>\n<td align=\"left\">Reject request</td>\n</tr>\n<tr>\n<td align=\"left\">Header too long</td>\n<td align=\"left\">Skip</td>\n<td align=\"left\"><code>parse_header_line</code></td>\n<td align=\"left\">Skip specific header, continue</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"7-implementation-sequence-with-checkpoints\">7. Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-structs-amp-constants-05-hours\">Phase 1: Structs &amp; Constants (0.5 hours)</h3>\n<ul>\n<li>Define <code>http_request_t</code> and <code>http_header_t</code> in <code>http_types.h</code>.</li>\n<li>Set <code>MAX_PATH_LEN 8192</code> and <code>MAX_HEADERS 32</code>.</li>\n<li><strong>Checkpoint</strong>: Compile a test file that <code>sizeof(http_request_t)</code> and prints it. Ensure it is ~270KB.</li>\n</ul>\n<h3 id=\"phase-2-string-helpers-1-hour\">Phase 2: String Helpers (1 hour)</h3>\n<ul>\n<li>Implement <code>str_to_lower</code> and <code>strip_ows</code>.</li>\n<li>Implement <code>url_decode</code> (basic version: convert <code>%XX</code> to char).</li>\n<li><strong>Checkpoint</strong>: Test <code>strip_ows(&quot;  value  &quot;)</code> returns <code>&quot;value&quot;</code>.</li>\n</ul>\n<h3 id=\"phase-3-the-parser-2-hours\">Phase 3: The Parser (2 hours)</h3>\n<ul>\n<li>Implement <code>parse_request_line</code>.</li>\n<li>Implement <code>parse_header_line</code>.</li>\n<li>Implement the main loop in <code>parse_http_request</code>.</li>\n<li><strong>Checkpoint</strong>: Pass a raw buffer of a valid GET request. Verify <code>req.method</code> is <code>METHOD_GET</code> and <code>req.path</code> is correct.</li>\n</ul>\n<h3 id=\"phase-4-error-dispatch-1-hour\">Phase 4: Error Dispatch (1 hour)</h3>\n<ul>\n<li>Implement <code>send_error_response</code> and convenience wrappers (<code>send_400</code>, etc.).</li>\n<li>Integrate into the main server loop from M1.</li>\n<li><strong>Checkpoint</strong>: Use <code>curl -X DELETE http://localhost:8080</code>. Server should return 501.</li>\n</ul>\n<hr>\n<h2 id=\"8-test-specification\">8. Test Specification</h2>\n<h3 id=\"81-happy-path-header-normalization\">8.1 Happy Path: Header Normalization</h3>\n<ul>\n<li><strong>Input</strong>: <code>GET / HTTP/1.1\\r\\nHOST: localhost\\r\\nUser-Agent: test\\r\\n\\r\\n</code></li>\n<li><strong>Assertion</strong>: <code>request_get_header(req, &quot;host&quot;)</code> returns <code>&quot;localhost&quot;</code>. <code>req-&gt;http_minor == 1</code>.</li>\n</ul>\n<h3 id=\"82-edge-case-bare-lf\">8.2 Edge Case: Bare LF</h3>\n<ul>\n<li><strong>Input</strong>: <code>GET /index.html HTTP/1.1\\nHost: localhost\\n\\n</code></li>\n<li><strong>Assertion</strong>: Parser treats <code>\\n</code> as line terminator, correctly extracts path <code>/index.html</code>.</li>\n</ul>\n<h3 id=\"83-attack-uri-too-long\">8.3 Attack: URI Too Long</h3>\n<ul>\n<li><strong>Input</strong>: <code>GET /</code> + (&#39;A&#39; * 9000) + <code> HTTP/1.1\\r\\n...</code></li>\n<li><strong>Assertion</strong>: <code>parse_http_request</code> returns <code>414</code>. <code>send_error_response</code> is called with 414.</li>\n</ul>\n<h3 id=\"84-attack-null-byte-injection\">8.4 Attack: Null Byte Injection</h3>\n<ul>\n<li><strong>Input</strong>: <code>GET /index.html%00.php HTTP/1.1\\r\\n...</code></li>\n<li><strong>Assertion</strong>: <code>url_decode</code> detects <code>%00</code> and returns an error (400), or the resulting string is correctly terminated and handled as <code>/index.html</code>.</li>\n</ul>\n<hr>\n<h2 id=\"9-performance-targets\">9. Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target</th>\n<th align=\"left\">Measurement Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Request Parsing</strong></td>\n<td align=\"left\">&lt; 5Âµs</td>\n<td align=\"left\"><code>clock_gettime(CLOCK_MONOTONIC)</code> around <code>parse_http_request</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Normalization</strong></td>\n<td align=\"left\">&lt; 1ns / char</td>\n<td align=\"left\">Microbenchmark of <code>str_to_lower</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Memory Allocation</strong></td>\n<td align=\"left\">0 bytes</td>\n<td align=\"left\"><code>valgrind --tool=massif</code> or manual audit (No <code>malloc</code> in scope)</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"10-hardware-soul-cache-and-pipeline\">10. Hardware Soul: Cache and Pipeline</h2>\n<h3 id=\"101-cache-locality\">10.1 Cache Locality</h3>\n<p>Because <code>http_request_t</code> is contiguous, the first few headers (usually the most important like <code>Host</code> and <code>Content-Length</code>) will likely share cache lines. When <code>request_get_header</code> iterates, the CPU&#39;s <strong>L1 Data Cache Prefetcher</strong> will pull the next header entries into the cache before the loop even reaches them. </p>\n<h3 id=\"102-branch-prediction\">10.2 Branch Prediction</h3>\n<p>In <code>str_to_lower</code>, the check <code>if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;)</code> is a branch. In standard HTTP headers, most characters are lowercase. The <strong>Branch Predictor</strong> in modern CPUs (like Intel&#39;s TAGE predictor) will learn this and &quot;speculate&quot; that the character is already lowercase, executing the add-32 path only when necessary.</p>\n<p>{{DIAGRAM:tdd-diag-9|Header Search Pipeline|Visualizing L1 cache hits during the linear search of the headers array}}</p>\n<hr>\n<h2 id=\"11-state-machine-specification\">11. State Machine Specification</h2>\n<p>The parser moves through the following states per connection:</p>\n<ol>\n<li><strong>STATE_REQ_LINE</strong>: Expecting Method, Path, and Version. Transition to <code>STATE_HEADERS</code> on first CRLF.</li>\n<li><strong>STATE_HEADERS</strong>: Extracting key-value pairs. Transition to <code>STATE_SEMANTIC</code> on <code>\\r\\n\\r\\n</code>.</li>\n<li><strong>STATE_SEMANTIC</strong>: Post-parse validation (Host check, etc.).</li>\n<li><strong>STATE_COMPLETE</strong>: Parsed successfully.</li>\n<li><strong>STATE_ERROR</strong>: Invalid input detected. Send 4xx/5xx and terminate.</li>\n</ol>\n<p>{{DIAGRAM:tdd-diag-10|Parser States|State machine showing transitions and error exits}}</p>\n<hr>\n<h2 id=\"12-implementation-path-c-details\">12. Implementation Path (C Details)</h2>\n<p><strong>Warning: <code>strtok</code> is Forbidden.</strong>\nUse <code>memchr</code> and pointer arithmetic. <code>strtok</code> is not thread-safe (uses internal static state) and modifies the source string. While M1 creates a copy, using <code>memchr</code> is a better systems-programming habit for immutable buffers.</p>\n<p><strong>Handling CRLF vs LF:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Implementation snippet for line splitting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">line_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cursor;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">line_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> memchr</span><span style=\"color:#E1E4E8\">(cursor, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, remaining_len);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (line_end) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> actual_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> line_end </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> line_start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (actual_len </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#FFAB70\"> line_start</span><span style=\"color:#E1E4E8\">[actual_len </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        actual_len</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Strip \\r</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // process line_start with actual_len...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Normalization Snippet:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> str_to_lower</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">s</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (; </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">s; </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">s) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Bitwise trick: 'A' | 0x20 == 'a'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Only applies if it is actually an uppercase letter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">s </span><span style=\"color:#F97583\">>=</span><span style=\"color:#9ECBFF\"> 'A'</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">s </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#9ECBFF\"> 'Z'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">s </span><span style=\"color:#F97583\">|=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: http-server-basic-m3 -->\n<h1 id=\"module-specification-static-file-serving-http-server-basic-m3\">MODULE SPECIFICATION: Static File Serving (http-server-basic-m3)</h1>\n<h2 id=\"1-module-charter\">1. Module Charter</h2>\n<p>This module implements the core &quot;Payload Delivery&quot; logic of the HTTP server. It is responsible for mapping abstract URL paths to concrete filesystem resources while enforcing strict security boundaries. </p>\n<p><strong>Core Responsibilities:</strong></p>\n<ul>\n<li><strong>Path Sanitization</strong>: URL-decode incoming paths and reject malicious payloads (e.g., null-byte injections).</li>\n<li><strong>Security Enforcement</strong>: Use <code>realpath()</code> canonicalization to prevent directory traversal attacks by ensuring resolved paths reside strictly within the configured <code>document_root</code>.</li>\n<li><strong>Resource Resolution</strong>: Handle directory-to-index mapping (auto-serving <code>index.html</code>) and detect file metadata via <code>stat()</code>.</li>\n<li><strong>Protocol Compliance</strong>: Implement conditional GETs using <code>If-Modified-Since</code> and <code>Last-Modified</code> headers to support browser caching (304 Not Modified).</li>\n<li><strong>Content Negotiation</strong>: Map file extensions to MIME types using a static lookup table.</li>\n<li><strong>Efficient I/O</strong>: Stream file data from the kernel page cache to the network socket using a performance-tuned 64KB buffer loop.</li>\n</ul>\n<p><strong>What this module does NOT do:</strong></p>\n<ul>\n<li>It does <strong>not</strong> manage connection persistence (Keep-Alive), which is handled by the M4 orchestrator.</li>\n<li>It does <strong>not</strong> handle directory listings (it returns 403 if <code>index.html</code> is missing).</li>\n<li>It does <strong>not</strong> perform compression (gzip/brotli).</li>\n</ul>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>Every file opened via <code>open()</code> MUST be <code>close()</code>&#39;d regardless of whether the <code>write()</code> to the socket succeeds or fails.</li>\n<li>The server MUST NOT follow symbolic links that point outside the <code>document_root</code>.</li>\n<li>All timestamps in HTTP headers MUST be in GMT/UTC per RFC 7231.</li>\n</ul>\n<hr>\n<h2 id=\"2-file-structure\">2. File Structure</h2>\n<p>The implementation follows this numbered creation order:</p>\n<ol>\n<li><code>mime_types.h</code>: Static MIME type mapping table and lookup logic.</li>\n<li><code>path_utils.h / .c</code>: <code>url_decode</code> and <code>resolve_safe_path</code> logic.</li>\n<li><code>date_utils.h / .c</code>: RFC 1123 date formatting/parsing using <code>timegm</code>.</li>\n<li><code>file_handler.h</code>: Prototypes for the main serving entry point.</li>\n<li><code>file_handler.c</code>: Implementation of the 8-phase serving orchestration.</li>\n</ol>\n<hr>\n<h2 id=\"3-complete-data-model\">3. Complete Data Model</h2>\n<h3 id=\"31-mime-entry-struct\">3.1 MIME Entry Struct</h3>\n<p>Used in a static array to map extensions to types.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Offset</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>extension</code></td>\n<td align=\"left\"><code>const char*</code></td>\n<td align=\"left\">0x00</td>\n<td align=\"left\">e.g., &quot;.html&quot;, &quot;.png&quot; (includes dot).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>mime_type</code></td>\n<td align=\"left\"><code>const char*</code></td>\n<td align=\"left\">0x08</td>\n<td align=\"left\">e.g., &quot;text/html; charset=utf-8&quot;.</td>\n</tr>\n</tbody></table>\n<p><strong>Total Size</strong>: 16 bytes.</p>\n<h3 id=\"32-internal-constants\">3.2 Internal Constants</h3>\n<ul>\n<li><code>MAX_PATH_SIZE</code>: 4096 (Defined by <code>PATH_MAX</code> in <code>limits.h</code>).</li>\n<li><code>IO_BUFFER_SIZE</code>: 65536 (64KB). Aligned with modern page cache/TCP window scaling.</li>\n<li><code>HTTP_DATE_SIZE</code>: 64. Buffer size for &quot;Wed, 21 Oct 2015 07:28:00 GMT&quot;.</li>\n</ul>\n<p>{{DIAGRAM:tdd-diag-13|MIME Table Layout|Memory representation of the static MIME_TABLE array}}</p>\n<hr>\n<h2 id=\"4-interface-contracts\">4. Interface Contracts</h2>\n<h3 id=\"41-int-url_decodeconst-char-src-char-out-size_t-out_size\">4.1 <code>int url_decode(const char *src, char *out, size_t out_size)</code></h3>\n<ul>\n<li><strong>Purpose</strong>: Convert <code>%XX</code> hex sequences to raw bytes and reject <code>%00</code>.</li>\n<li><strong>Input</strong>: <code>src</code> (untrusted URL path), <code>out</code> (destination), <code>out_size</code> (max capacity).</li>\n<li><strong>Return</strong>: <code>0</code> on success, <code>-1</code> on malformed hex or null-byte detection.</li>\n<li><strong>Security</strong>: If <code>%00</code> is detected, return <code>-1</code> immediately to prevent filename truncation attacks.</li>\n</ul>\n<h3 id=\"42-int-resolve_safe_pathconst-char-url_path-const-char-canonical_root-char-resolved_out\">4.2 <code>int resolve_safe_path(const char *url_path, const char *canonical_root, char *resolved_out)</code></h3>\n<ul>\n<li><strong>Purpose</strong>: The &quot;Security Firewall.&quot; Converts URL to absolute path and checks boundaries.</li>\n<li><strong>Input</strong>: Raw URL path, canonicalized document root.</li>\n<li><strong>Output</strong>: Writes absolute filesystem path to <code>resolved_out</code>.</li>\n<li><strong>Return Codes</strong>: <ul>\n<li><code>0</code>: Success.</li>\n<li><code>400</code>: Malformed encoding.</li>\n<li><code>403</code>: Traversal attempt (escaped root).</li>\n<li><code>404</code>: Resource does not exist (via <code>realpath</code> failure).</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"43-void-serve_static_fileconst-http_request_t-req-int-client_fd-const-char-canonical_root\">4.3 <code>void serve_static_file(const http_request_t *req, int client_fd, const char *canonical_root)</code></h3>\n<ul>\n<li><strong>Purpose</strong>: Main entry point. Orchestrates the 8 phases of file delivery.</li>\n<li><strong>Contract</strong>: Rejects non-regular files (pipes, sockets, devices) with 403.</li>\n<li><strong>Performance</strong>: Uses a stack-allocated 64KB buffer for the I/O loop.</li>\n</ul>\n<hr>\n<h2 id=\"5-algorithm-specification\">5. Algorithm Specification</h2>\n<h3 id=\"51-the-resolve-then-check-algorithm\">5.1 The Resolve-Then-Check Algorithm</h3>\n<p>{{DIAGRAM:tdd-diag-14|Path Resolution Sequence|Flow from raw URL to canonical path validation}}</p>\n<ol>\n<li><strong>Decode</strong>: Invoke <code>url_decode()</code> on <code>req-&gt;path</code>.</li>\n<li><strong>Concatenate</strong>: <code>snprintf</code> the <code>canonical_root</code> and <code>decoded_path</code> into a temporary <code>raw_path</code> buffer.</li>\n<li><strong>Canonicalize</strong>: Call <code>realpath(raw_path, resolved_out)</code>.<ul>\n<li>If <code>NULL</code>:<ul>\n<li>If <code>errno == ENOENT</code>, return <code>404</code>.</li>\n<li>If <code>errno == EACCES</code>, return <code>403</code>.</li>\n<li>Else, return <code>404</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Boundary Check</strong>: <ul>\n<li><code>root_len = strlen(canonical_root)</code>.</li>\n<li>Perform <code>strncmp(resolved_out, canonical_root, root_len)</code>.</li>\n<li>If no match, return <code>403</code>.</li>\n</ul>\n</li>\n<li><strong>Character Boundary Check</strong>:<ul>\n<li>If <code>resolved_out[root_len]</code> is not <code>\\0</code> AND not <code>/</code>, return <code>403</code>. (Prevents matching <code>/var/www-secret</code> against <code>/var/www</code>).</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"52-directory-index-logic-handle_directory_path\">5.2 Directory Index Logic (<code>handle_directory_path</code>)</h3>\n<ol>\n<li>Call <code>stat(resolved_path, &amp;st)</code>.</li>\n<li>If <code>S_ISDIR(st.st_mode)</code>:<ul>\n<li>Check if <code>resolved_path</code> + <code>/index.html</code> exceeds <code>MAX_PATH_SIZE</code>.</li>\n<li>Append <code>/index.html</code>.</li>\n<li>Call <code>stat()</code> again on the new path.</li>\n<li>If second <code>stat()</code> fails, return <code>-1</code> (triggers 403 Forbidden).</li>\n</ul>\n</li>\n<li>Return <code>0</code> (Success, serving index).</li>\n</ol>\n<h3 id=\"53-64kb-io-stream-loop\">5.3 64KB I/O Stream Loop</h3>\n<p>{{DIAGRAM:tdd-diag-15|Zero-Allocation I/O Loop|Relationship between Kernel Page Cache and userspace buffer}}</p>\n<ol>\n<li><code>int file_fd = open(resolved, O_RDONLY)</code>.</li>\n<li>While <code>(bytes_read = read(file_fd, io_buf, 65536)) &gt; 0</code>:<ul>\n<li>Invoke <code>write_all(client_fd, io_buf, bytes_read)</code>.</li>\n<li>If <code>write_all</code> fails (client disconnected), break loop.</li>\n</ul>\n</li>\n<li><code>close(file_fd)</code>.\n<em>Note: This utilizes the &quot;Stream Pattern&quot;. For sequential reads, the CPU prefetcher will pull subsequent 64B cache lines into L1 while the current 64B is being written to the socket.</em></li>\n</ol>\n<hr>\n<h2 id=\"6-error-handling-matrix\">6. Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error Condition</th>\n<th align=\"left\">Detected By</th>\n<th align=\"left\">Recovery</th>\n<th align=\"left\">User-Visible Response</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>%00</code> in URL</td>\n<td align=\"left\"><code>url_decode</code></td>\n<td align=\"left\">Stop processing.</td>\n<td align=\"left\"><code>400 Bad Request</code></td>\n</tr>\n<tr>\n<td align=\"left\">Symlink to <code>/etc</code></td>\n<td align=\"left\"><code>resolve_safe_path</code></td>\n<td align=\"left\"><code>realpath</code> resolves to <code>/etc</code>, <code>strncmp</code> fails.</td>\n<td align=\"left\"><code>403 Forbidden</code></td>\n</tr>\n<tr>\n<td align=\"left\">File does not exist</td>\n<td align=\"left\"><code>realpath</code></td>\n<td align=\"left\">Check <code>errno == ENOENT</code>.</td>\n<td align=\"left\"><code>404 Not Found</code></td>\n</tr>\n<tr>\n<td align=\"left\">Missing <code>index.html</code></td>\n<td align=\"left\"><code>stat</code> (2nd call)</td>\n<td align=\"left\">Fail directory resolution.</td>\n<td align=\"left\"><code>403 Forbidden</code></td>\n</tr>\n<tr>\n<td align=\"left\">Client quit mid-file</td>\n<td align=\"left\"><code>write_all</code></td>\n<td align=\"left\">Close <code>file_fd</code>, return thread to pool.</td>\n<td align=\"left\">N/A (Socket closed)</td>\n</tr>\n<tr>\n<td align=\"left\">Header buffer overflow</td>\n<td align=\"left\"><code>snprintf</code></td>\n<td align=\"left\">Return code check on <code>snprintf</code>.</td>\n<td align=\"left\"><code>500 Internal Server Error</code></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"7-implementation-sequence-with-checkpoints\">7. Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-url-amp-path-security-15-hours\">Phase 1: URL &amp; Path Security (1.5 hours)</h3>\n<ul>\n<li>Implement <code>url_decode</code> with hex-to-char logic.</li>\n<li>Implement <code>resolve_safe_path</code> using <code>realpath()</code>.</li>\n<li><strong>Checkpoint</strong>: Test <code>resolve_safe_path(&quot;/../../etc/passwd&quot;, &quot;/var/www&quot;, out)</code>. It must return <code>403</code> or <code>404</code>, never <code>0</code>.</li>\n</ul>\n<h3 id=\"phase-2-metadata-amp-mime-1-hour\">Phase 2: Metadata &amp; MIME (1 hour)</h3>\n<ul>\n<li>Define <code>MIME_TABLE</code> in <code>mime_types.h</code>.</li>\n<li>Implement <code>mime_type_for_path</code> with <code>strrchr</code> extension extraction.</li>\n<li><strong>Checkpoint</strong>: <code>mime_type_for_path(&quot;test.PNG&quot;)</code> must return <code>image/png</code>.</li>\n</ul>\n<h3 id=\"phase-3-conditional-gets-15-hours\">Phase 3: Conditional GETs (1.5 hours)</h3>\n<ul>\n<li>Implement <code>format_http_date</code> and <code>parse_http_date</code>.</li>\n<li>Implement <code>should_send_304</code> comparing <code>st_mtime</code> and <code>If-Modified-Since</code>.</li>\n<li><strong>Checkpoint</strong>: Set a file&#39;s mtime to 1 hour ago. Send an <code>If-Modified-Since</code> header with that timestamp. Server must return <code>304</code>.</li>\n</ul>\n<h3 id=\"phase-4-the-orchestrator-2-hours\">Phase 4: The Orchestrator (2 hours)</h3>\n<ul>\n<li>Implement <code>serve_static_file</code> linking all previous phases.</li>\n<li>Implement the 64KB <code>read/write</code> loop.</li>\n<li><strong>Checkpoint</strong>: <code>curl http://localhost:8080/index.html</code>. Verify headers and body are fully delivered.</li>\n</ul>\n<hr>\n<h2 id=\"8-test-specification\">8. Test Specification</h2>\n<h3 id=\"81-security-traversal-prevention\">8.1 Security: Traversal Prevention</h3>\n<ul>\n<li><strong>Input</strong>: <code>GET /%2e%2e%2f%2e%2e%2fetc%2fshadow</code></li>\n<li><strong>Requirement</strong>: HTTP 403 or 404. Audit <code>strace</code> to ensure <code>open(&quot;/etc/shadow&quot;)</code> was never called.</li>\n</ul>\n<h3 id=\"82-logic-directory-indexing\">8.2 Logic: Directory Indexing</h3>\n<ul>\n<li><strong>Structure</strong>: <code>/www/images/index.html</code> exists.</li>\n<li><strong>Input</strong>: <code>GET /images/</code></li>\n<li><strong>Requirement</strong>: Returns content of <code>/www/images/index.html</code>. <code>Content-Type: text/html</code>.</li>\n</ul>\n<h3 id=\"83-efficiency-64kb-alignment\">8.3 Efficiency: 64KB Alignment</h3>\n<ul>\n<li><strong>Input</strong>: Request a 10MB binary file.</li>\n<li><strong>Requirement</strong>: Monitor memory usage. Peak RSS must not grow significantly (staying within the 64KB buffer limit).</li>\n</ul>\n<hr>\n<h2 id=\"9-performance-targets\">9. Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target</th>\n<th align=\"left\">Measurement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Path Resolution</strong></td>\n<td align=\"left\">&lt; 15Âµs</td>\n<td align=\"left\"><code>CLOCK_MONOTONIC</code> across <code>resolve_safe_path</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Throughput (L1 Cached)</strong></td>\n<td align=\"left\">&gt; 800 MB/s</td>\n<td align=\"left\"><code>wget</code> on localhost for 1GB file.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>MIME Lookup</strong></td>\n<td align=\"left\">&lt; 500ns</td>\n<td align=\"left\">Micro-benchmark of <code>mime_type_for_path</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Allocations</strong></td>\n<td align=\"left\">0 malloc/req</td>\n<td align=\"left\"><code>valgrind --tool=memcheck</code> check.</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"10-hardware-soul-amp-systems-view\">10. Hardware Soul &amp; Systems View</h2>\n<h3 id=\"101-the-three-level-view\">10.1 The Three-Level View</h3>\n<ul>\n<li><strong>Application</strong>: Your C code calls <code>serve_static_file</code>.</li>\n<li><strong>OS/Kernel</strong>: <ul>\n<li><code>realpath()</code> performs <code>lstat()</code> on every directory component. This is a metadata-heavy operation.</li>\n<li><code>read()</code> triggers the kernel to check the <strong>Page Cache</strong>. If found, the kernel uses its own memory-to-memory copy.</li>\n<li><code>write()</code> fills the <strong>TCP Send Buffer</strong>. If the window is full, the thread blocks in the kernel, yielding the CPU.</li>\n</ul>\n</li>\n<li><strong>Hardware</strong>:<ul>\n<li><strong>DMA (Direct Memory Access)</strong>: When the file is cold, the Disk Controller moves data to RAM without CPU involvement.</li>\n<li><strong>Cache Line Locality</strong>: The <code>io_buf[65536]</code> is accessed sequentially. The CPU&#39;s L2 prefetcher fetches the next cache line (64B) while the current line is being processed by the <code>write()</code> syscall.</li>\n</ul>\n</li>\n</ul>\n<p>{{DIAGRAM:tdd-diag-16|Three-Level View: File Serving|Interaction between NIC, CPU Cache, and Page Cache}}</p>\n<h3 id=\"102-cache-line-alignment\">10.2 Cache Line Alignment</h3>\n<p>The <code>io_buf</code> should ideally be aligned to a 64-byte boundary.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// System-level alignment for optimal cache line fills</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> io_buf</span><span style=\"color:#E1E4E8\">[IO_BUFFER_SIZE] </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#B392F0\">aligned</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">)));</span></span></code></pre></div>\n<p>This ensures that every <code>read()</code> call fills exactly 1024 complete cache lines, preventing &quot;partial cache line&quot; updates which can trigger unnecessary cache coherence traffic on multi-core systems (even though M3 is single-request, the hardware still performs these checks).</p>\n<h3 id=\"103-syscall-overhead-realpath\">10.3 Syscall Overhead: realpath()</h3>\n<p><code>realpath()</code> is expensive because it involves multiple <code>lstat()</code> calls. For a path like <code>/a/b/c/d.txt</code>, there are 4 <code>lstat()</code> calls. At ~2Âµs per syscall, <code>realpath()</code> is the primary latency contributor for small requests.\n<strong>Optimization Note</strong>: The <code>canonical_root</code> is resolved once at startup to avoid re-calculating the base directory&#39;s components on every request.</p>\n<hr>\n<h2 id=\"11-implementation-path-c-details\">11. Implementation Path (C Details)</h2>\n<h3 id=\"111-date-handling-utc\">11.1 Date Handling (UTC)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// MUST use timegm for UTC, as mktime assumes local timezone</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">time_t</span><span style=\"color:#B392F0\"> parse_http_date</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">date_str</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> tm tm;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tm, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(tm));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strptime</span><span style=\"color:#E1E4E8\">(date_str, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%a</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#FDAEB7;font-style:italic\"> %</span><span style=\"color:#9ECBFF\">b </span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">Y </span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">H:</span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">M:</span><span style=\"color:#79B8FF\">%S</span><span style=\"color:#9ECBFF\"> GMT\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tm) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> timegm</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tm); </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"112-file-descriptor-safety\">11.2 File Descriptor Safety</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> file_fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(path, O_RDONLY);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (file_fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span><span style=\"color:#6A737D\"> /* handle error */</span><span style=\"color:#E1E4E8\"> }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ... send headers ...</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#E1E4E8\"> n;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> ((n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> read</span><span style=\"color:#E1E4E8\">(file_fd, buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(buf))) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_all</span><span style=\"color:#E1E4E8\">(client_fd, buf, n) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Invariant: Close is guaranteed</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">close</span><span style=\"color:#E1E4E8\">(file_fd);</span></span></code></pre></div>\n\n<h3 id=\"113-mime-lookup-with-strrchr\">11.3 MIME Lookup with strrchr</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">ext </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strrchr</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#9ECBFF\">'.'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">ext) </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"application/octet-stream\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Note: strrchr finds the LAST dot, handling \"archive.tar.gz\" correctly by finding \".gz\"</span></span></code></pre></div>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: http-server-basic-m4 -->\n<h1 id=\"module-specification-concurrent-connections-http-server-basic-m4\">MODULE SPECIFICATION: Concurrent Connections (http-server-basic-m4)</h1>\n<h2 id=\"1-module-charter\">1. Module Charter</h2>\n<p>This module transforms the server from a sequential, single-request processor into a high-concurrency production-grade engine. It implements a bounded thread pool architecture to manage system resources predictably while serving multiple clients in parallel. The module is responsible for the transition from one-shot connections to HTTP/1.1 persistent (keep-alive) sessions, enforced by kernel-level idle timeouts (<code>SO_RCVTIMEO</code>). It establishes a robust &quot;Signal Handling&quot; architecture using a dedicated thread to ensure that <code>SIGTERM</code> and <code>SIGINT</code> trigger a graceful four-phase shutdown rather than immediate process termination. Crucially, it manages all shared state (request counters, connection slots) through strict mutex synchronization to prevent data races.</p>\n<p><strong>Core Responsibilities:</strong></p>\n<ul>\n<li>Manage a fixed-size pool of worker threads and a circular FIFO work queue.</li>\n<li>Implement the HTTP/1.1 Keep-Alive loop allowing multiple requests per TCP session.</li>\n<li>Protect shared server statistics and the access log using mutexes.</li>\n<li>Defend against resource exhaustion (Slowloris) via idle timeouts.</li>\n<li>Orchestrate graceful shutdown: stop accepting, drain queue, join threads.</li>\n<li>Handle <code>EMFILE</code> (file descriptor exhaustion) with exponential backoff.</li>\n</ul>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>No shared variable (e.g., <code>active_connections</code>) shall be modified without holding the pool mutex.</li>\n<li>The <code>pool-&gt;lock</code> MUST NEVER be held during any blocking I/O operation (<code>read</code>, <code>write</code>, <code>open</code>).</li>\n<li>Every <code>pthread_create</code> must be balanced by a <code>pthread_join</code> or <code>pthread_detach</code>.</li>\n</ul>\n<hr>\n<h2 id=\"2-file-structure\">2. File Structure</h2>\n<p>The implementation follows this numbered creation order:</p>\n<ol>\n<li><code>concurrency_types.h</code>: Definition of <code>thread_pool_t</code> and <code>work_item_t</code>.</li>\n<li><code>thread_pool.c</code>: Core logic for initialization, worker loops, and submission.</li>\n<li><code>connection_handler.c</code>: Revised <code>handle_connection</code> with Keep-Alive loop and <code>SO_RCVTIMEO</code>.</li>\n<li><code>signals.c</code>: Dedicated signal handling thread logic.</li>\n<li><code>main.c</code>: Final integration of signal masking and pool orchestration.</li>\n</ol>\n<hr>\n<h2 id=\"3-complete-data-model\">3. Complete Data Model</h2>\n<h3 id=\"31-work-item-struct\">3.1 Work Item Struct</h3>\n<p>A minimal descriptor for tasks in the queue.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Offset</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>client_fd</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">0x00</td>\n<td align=\"left\">The file descriptor of the accepted connection.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>padding</code></td>\n<td align=\"left\"><code>char[4]</code></td>\n<td align=\"left\">0x04</td>\n<td align=\"left\">Alignment to 8-byte boundary.</td>\n</tr>\n</tbody></table>\n<h3 id=\"32-thread-pool-struct-thread_pool_t\">3.2 Thread Pool Struct (<code>thread_pool_t</code>)</h3>\n<p>This struct contains the entire concurrency state. It is 64-byte aligned to optimize cache line utilization.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Offset (64-bit)</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Queue Management</strong></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>queue</code></td>\n<td align=\"left\"><code>work_item_t*</code></td>\n<td align=\"left\">0x00</td>\n<td align=\"left\">Pointer to heap-allocated circular buffer.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>queue_capacity</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">0x08</td>\n<td align=\"left\">Max items the queue can hold.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>queue_size</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">0x0C</td>\n<td align=\"left\">Current number of items in queue.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>queue_head</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">0x10</td>\n<td align=\"left\">Next item to dequeue.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>queue_tail</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">0x14</td>\n<td align=\"left\">Next slot for enqueue.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Synchronization</strong></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>lock</code></td>\n<td align=\"left\"><code>pthread_mutex_t</code></td>\n<td align=\"left\">0x18</td>\n<td align=\"left\">Global pool lock (approx 40 bytes).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>not_empty</code></td>\n<td align=\"left\"><code>pthread_cond_t</code></td>\n<td align=\"left\">0x40</td>\n<td align=\"left\">Signaled when work is added.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>not_full</code></td>\n<td align=\"left\"><code>pthread_cond_t</code></td>\n<td align=\"left\">0x70</td>\n<td align=\"left\">Signaled when space is cleared.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Workers &amp; Life</strong></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>threads</code></td>\n<td align=\"left\"><code>pthread_t*</code></td>\n<td align=\"left\">0xA0</td>\n<td align=\"left\">Array of thread handles.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>num_threads</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">0xA8</td>\n<td align=\"left\">Number of worker threads.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>shutdown</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">0xAC</td>\n<td align=\"left\">Shutdown flag (0 or 1).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Config &amp; Stats</strong></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>doc_root</code></td>\n<td align=\"left\"><code>char*</code></td>\n<td align=\"left\">0xB0</td>\n<td align=\"left\">Document root (read-only).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>idle_timeout</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">0xB8</td>\n<td align=\"left\">Seconds until idle close.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>active_conns</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">0xBC</td>\n<td align=\"left\">Count of threads currently serving.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>total_reqs</code></td>\n<td align=\"left\"><code>long</code></td>\n<td align=\"left\">0xC0</td>\n<td align=\"left\">Cumulative request counter.</td>\n</tr>\n</tbody></table>\n<p><strong>Cache Note</strong>: <code>active_conns</code> and <code>total_reqs</code> are placed at the end to minimize &quot;False Sharing&quot; contention with the queue pointers which are modified at much higher frequency.</p>\n<p>{{DIAGRAM:tdd-diag-21|Memory Layout of thread_pool_t|Visualizing offsets and 64-byte alignment boundaries}}</p>\n<hr>\n<h2 id=\"4-interface-contracts\">4. Interface Contracts</h2>\n<h3 id=\"41-int-thread_pool_initthread_pool_t-pool-int-threads-int-queue_size-const-char-root-int-timeout\">4.1 <code>int thread_pool_init(thread_pool_t *pool, int threads, int queue_size, const char *root, int timeout)</code></h3>\n<ul>\n<li><strong>Purpose</strong>: Initialize all sync primitives and spawn worker threads.</li>\n<li><strong>Return</strong>: <code>0</code> on success, <code>-1</code> on any failure (e.g., <code>pthread_create</code> error). </li>\n<li><strong>Invariants</strong>: If thread creation fails midway, it must cleanup all previously created threads before returning.</li>\n</ul>\n<h3 id=\"42-int-thread_pool_submitthread_pool_t-pool-int-client_fd\">4.2 <code>int thread_pool_submit(thread_pool_t *pool, int client_fd)</code></h3>\n<ul>\n<li><strong>Purpose</strong>: Push a new FD into the circular queue.</li>\n<li><strong>Return</strong>: <code>0</code> on success, <code>-1</code> if queue is full or pool is shutting down.</li>\n<li><strong>Locking</strong>: Must acquire <code>pool-&gt;lock</code>. Must signal <code>not_empty</code>.</li>\n</ul>\n<h3 id=\"43-void-thread_pool_shutdownthread_pool_t-pool\">4.3 <code>void thread_pool_shutdown(thread_pool_t *pool)</code></h3>\n<ul>\n<li><strong>Purpose</strong>: Set shutdown flag and broadcast to all workers.</li>\n<li><strong>Contract</strong>: Does not join threads; merely signals intent.</li>\n</ul>\n<h3 id=\"44-void-handle_connectionint-client_fd-thread_pool_t-pool\">4.4 <code>void handle_connection(int client_fd, thread_pool_t *pool)</code></h3>\n<ul>\n<li><strong>Purpose</strong>: Revised request handler with Keep-Alive for-loop.</li>\n<li><strong>Contract</strong>: Must set <code>SO_RCVTIMEO</code> before entering the loop. Must check <code>req.keep_alive</code> after each response.</li>\n</ul>\n<hr>\n<h2 id=\"5-algorithm-specification\">5. Algorithm Specification</h2>\n<h3 id=\"51-the-worker-loop-worker_thread_fn\">5.1 The Worker Loop (<code>worker_thread_fn</code>)</h3>\n<ol>\n<li><strong>Wait</strong>: <ul>\n<li>Lock <code>pool-&gt;lock</code>.</li>\n<li>While <code>pool-&gt;queue_size == 0</code> AND <code>pool-&gt;shutdown == 0</code>:<ul>\n<li><code>pthread_cond_wait(&amp;pool-&gt;not_empty, &amp;pool-&gt;lock)</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Shutdown Check</strong>:<ul>\n<li>If <code>pool-&gt;shutdown == 1</code> AND <code>pool-&gt;queue_size == 0</code>, unlock and <code>pthread_exit</code>.</li>\n</ul>\n</li>\n<li><strong>Dequeue</strong>:<ul>\n<li>Copy <code>pool-&gt;queue[pool-&gt;queue_head]</code> to local variable.</li>\n<li><code>pool-&gt;queue_head = (pool-&gt;queue_head + 1) % pool-&gt;queue_capacity</code>.</li>\n<li><code>pool-&gt;queue_size--</code>.</li>\n<li><code>pool-&gt;active_conns++</code>.</li>\n<li><code>pthread_cond_signal(&amp;pool-&gt;not_full)</code>.</li>\n<li>Unlock <code>pool-&gt;lock</code>.</li>\n</ul>\n</li>\n<li><strong>Execute</strong>:<ul>\n<li>Call <code>handle_connection(local_fd, pool)</code>.</li>\n</ul>\n</li>\n<li><strong>Cleanup</strong>:<ul>\n<li>Lock <code>pool-&gt;lock</code>.</li>\n<li><code>pool-&gt;active_conns--</code>.</li>\n<li>Unlock <code>pool-&gt;lock</code>.</li>\n</ul>\n</li>\n</ol>\n<p>{{DIAGRAM:tdd-diag-22|Worker Thread State Machine|Transitions between Idle, Waiting, and Serving}}</p>\n<h3 id=\"52-http11-keep-alive-loop\">5.2 HTTP/1.1 Keep-Alive Loop</h3>\n<p>Within <code>handle_connection</code>:</p>\n<ol>\n<li><strong>Timeout Setup</strong>: <code>setsockopt(client_fd, SOL_SOCKET, SO_RCVTIMEO, &amp;tv, sizeof(tv))</code>.</li>\n<li><strong>Loop</strong>:<ul>\n<li>Call <code>read_http_request</code>.</li>\n<li>If <code>read</code> returns <code>-1</code> (including <code>EAGAIN</code> from timeout), <code>break</code> loop.</li>\n<li>Call <code>parse_http_request</code>.</li>\n<li>If success, call <code>serve_static_file</code>.</li>\n<li>If <code>req.keep_alive == 0</code>, <code>break</code> loop.</li>\n<li>Else, update stats and continue to next <code>read</code>.</li>\n</ul>\n</li>\n<li><strong>Exit</strong>: <code>close(client_fd)</code>.</li>\n</ol>\n<h3 id=\"53-dedicated-signal-thread-signal_handler_thread\">5.3 Dedicated Signal Thread (<code>signal_handler_thread</code>)</h3>\n<ol>\n<li>Clear and populate <code>sigset_t</code> with <code>SIGINT</code> and <code>SIGTERM</code>.</li>\n<li>Call <code>sigwait(&amp;set, &amp;sig)</code>.</li>\n<li>On signal:<ul>\n<li>Call <code>thread_pool_shutdown()</code>.</li>\n<li><code>close(listening_socket_fd)</code> to break the main accept loop.</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"6-error-handling-matrix\">6. Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error</th>\n<th align=\"left\">Detected By</th>\n<th align=\"left\">Recovery</th>\n<th align=\"left\">User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>EAGAIN</code> / <code>EWOULDBLOCK</code></td>\n<td align=\"left\"><code>read()</code></td>\n<td align=\"left\">Idle timeout. Break keep-alive loop, <code>close(fd)</code>.</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EMFILE</code></td>\n<td align=\"left\"><code>accept()</code></td>\n<td align=\"left\">Log error. <code>usleep(100000)</code> (100ms backoff) and <code>continue</code>.</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\">Queue Full</td>\n<td align=\"left\"><code>thread_pool_submit</code></td>\n<td align=\"left\">Invoke <code>send_503(fd)</code> then <code>close(fd)</code>.</td>\n<td align=\"left\">Yes (503 Error)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>pthread_create</code> fail</td>\n<td align=\"left\"><code>thread_pool_init</code></td>\n<td align=\"left\">Set <code>shutdown=1</code>, broadcast, join created threads, return -1.</td>\n<td align=\"left\">No (Server fails start)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EINTR</code></td>\n<td align=\"left\"><code>accept()</code></td>\n<td align=\"left\">Common if debugger attached. <code>continue</code>.</td>\n<td align=\"left\">No</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"7-implementation-sequence-with-checkpoints\">7. Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-shared-state-amp-initialization-2-hours\">Phase 1: Shared State &amp; Initialization (2 hours)</h3>\n<ul>\n<li>Define <code>thread_pool_t</code>. Implement <code>thread_pool_init</code> and the circular queue logic.</li>\n<li><strong>Checkpoint</strong>: Run test that initializes a pool of 4 threads and verifies that 4 threads are visible in <code>htop</code> for the process.</li>\n</ul>\n<h3 id=\"phase-2-worker-logic-2-hours\">Phase 2: Worker Logic (2 hours)</h3>\n<ul>\n<li>Implement <code>worker_thread_fn</code> with <code>pthread_cond_wait</code>. Implement <code>thread_pool_submit</code>.</li>\n<li><strong>Checkpoint</strong>: Submit 10 dummy tasks (print sleep) to a pool of 2. Verify tasks are processed concurrently and the queue drains correctly.</li>\n</ul>\n<h3 id=\"phase-3-keep-alive-amp-timeouts-2-hours\">Phase 3: Keep-Alive &amp; Timeouts (2 hours)</h3>\n<ul>\n<li>Refactor <code>handle_connection</code> to include the <code>SO_RCVTIMEO</code> and the <code>for(;;)</code> loop.</li>\n<li><strong>Checkpoint</strong>: <code>telnet localhost 8080</code>. Send one request. Wait 30 seconds. Verify the server closes the connection automatically.</li>\n</ul>\n<h3 id=\"phase-4-graceful-shutdown-1-hour\">Phase 4: Graceful Shutdown (1 hour)</h3>\n<ul>\n<li>Implement <code>sigwait</code> thread and <code>thread_pool_join</code>.</li>\n<li><strong>Checkpoint</strong>: Start server, hammer it with <code>wrk</code>, then hit <code>Ctrl+C</code>. Verify &quot;All worker threads exited cleanly&quot; is printed and process exits with code 0.</li>\n</ul>\n<hr>\n<h2 id=\"8-test-specification\">8. Test Specification</h2>\n<h3 id=\"81-load-test-concurrency\">8.1 Load Test (Concurrency)</h3>\n<ul>\n<li><strong>Tool</strong>: <code>wrk -t12 -c400 -d30s http://localhost:8080/index.html</code></li>\n<li><strong>Assertion</strong>: No 500 errors. Success rate 100%. Throughput &gt; 5000 req/sec (on standard hardware).</li>\n</ul>\n<h3 id=\"82-slowloris-defense\">8.2 Slowloris Defense</h3>\n<ul>\n<li><strong>Action</strong>: Open 50 connections with <code>nc</code>, send <code>GET /</code>, then do nothing.</li>\n<li><strong>Assertion</strong>: After 30s, server must close all 50 connections. Server remains responsive to new <code>curl</code> requests during this time.</li>\n</ul>\n<h3 id=\"83-data-race-check\">8.3 Data Race Check</h3>\n<ul>\n<li><strong>Tool</strong>: <code>gcc -fsanitize=thread</code></li>\n<li><strong>Action</strong>: Run the server under load with thread sanitizer.</li>\n<li><strong>Assertion</strong>: Zero reports of &quot;Data race&quot; or &quot;Unlock of unheld mutex&quot;.</li>\n</ul>\n<hr>\n<h2 id=\"9-performance-targets\">9. Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target</th>\n<th align=\"left\">Measurement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Lock Contention</strong></td>\n<td align=\"left\">&lt; 5% CPU</td>\n<td align=\"left\"><code>perf record</code> monitoring <code>pthread_mutex_lock</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Keep-Alive Handshake Savings</strong></td>\n<td align=\"left\">~1.2ms / req</td>\n<td align=\"left\">Comparison of 100 seq reqs with vs without Keep-Alive.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Context Switch Overhead</strong></td>\n<td align=\"left\">&lt; 2Âµs / task</td>\n<td align=\"left\"><code>latency-top</code> or <code>perf stat</code> (cs).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>FD Leakage</strong></td>\n<td align=\"left\">0.00%</td>\n<td align=\"left\">Baseline FD count after 100k requests.</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"10-hardware-soul-concurrency-amp-physics\">10. Hardware Soul: Concurrency &amp; Physics</h2>\n<h3 id=\"101-cache-line-bouncing-mesi-protocol\">10.1 Cache Line Bouncing (MESI Protocol)</h3>\n<p>When thread A modifies <code>pool-&gt;queue_size</code>, the CPU core invalidates that cache line in the L1/L2 caches of all other cores. When thread B tries to read <code>pool-&gt;queue_size</code>, it experiences a cache miss and must fetch the line from L3. This is the &quot;cost of synchronization.&quot; By holding the lock only for the few nanoseconds required to increment a pointer, we minimize the window where cores are fighting over the same cache lines.</p>\n<h3 id=\"102-atomic-instructions\">10.2 Atomic Instructions</h3>\n<p>The <code>pthread_mutex_lock</code> is implemented using hardware atomic instructions (e.g., <code>LOCK CMPXCHG</code> on x86). This is a &quot;bus lock&quot; or &quot;cache lock&quot; that ensures no other processor can modify the memory address during the operation. This takes <del>20-50ns. If the lock is already held, the kernel puts the thread to sleep (<code>futex</code> syscall), which is much more expensive (</del>2-5Âµs).</p>\n<p>{{DIAGRAM:tdd-diag-23|The Futex Path|Sequence: Lock Attempt -&gt; Fail -&gt; Kernel Sleep -&gt; Signal -&gt; Wakeup}}</p>\n<hr>\n<h2 id=\"11-concurrency-specification-lock-ordering\">11. Concurrency Specification: Lock Ordering</h2>\n<p>To prevent <strong>Deadlock</strong>, the following hierarchy is enforced:</p>\n<ol>\n<li><code>pool-&gt;lock</code> (The primary gatekeeper).</li>\n<li><code>log_mutex</code> (The access log lock).</li>\n</ol>\n<p><strong>Illegal Pattern</strong>: Holding <code>log_mutex</code> and then attempting to acquire <code>pool-&gt;lock</code>.\n<strong>Mandatory Pattern</strong>: Always acquire <code>pool-&gt;lock</code> first, then <code>log_mutex</code>. </p>\n<p>Note: Worker threads currently do not need to hold both simultaneously. They acquire <code>pool-&gt;lock</code> to update request stats, release it, then acquire <code>log_mutex</code> to write the access log line.</p>\n<hr>\n<h2 id=\"12-implementation-path-c-details\">12. Implementation Path (C Details)</h2>\n<h3 id=\"121-the-503-overload-response\">12.1 The 503 Overload Response</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> send_503</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> client_fd</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">msg </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"HTTP/1.1 503 Service Unavailable</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                      \"Content-Type: text/html</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                      \"Content-Length: 42</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                      \"Connection: close</span><span style=\"color:#79B8FF\">\\r\\n\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                      \"&#x3C;h1>503&#x3C;/h1>&#x3C;p>Server Queue Full&#x3C;/p>\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    write_all</span><span style=\"color:#E1E4E8\">(client_fd, msg, </span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(msg));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"122-signal-masking-snippet\">12.2 Signal Masking Snippet</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// MUST do this before spawning ANY threads</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">sigset_t</span><span style=\"color:#E1E4E8\"> set;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sigfillset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">set</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pthread_sigmask</span><span style=\"color:#E1E4E8\">(SIG_BLOCK, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">set</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Worker threads will inherit this mask and ignore SIGINT/SIGTERM,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// allowing our dedicated thread to catch them via sigwait().</span></span></code></pre></div>\n\n<h3 id=\"123-robust-dequeue\">12.3 Robust Dequeue</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Inside worker loop</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">lock</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\">(pool</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">queue_size </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">pool</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">shutdown) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_cond_wait</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->not_empty, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->lock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Re-check after waking (Spurious Wakeup handling)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (pool</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">shutdown </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> pool</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">queue_size </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pool->lock);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<!-- END_TDD_MOD -->\n\n\n<h1 id=\"project-structure-http-server-basic\">Project Structure: HTTP Server (Basic)</h1>\n<h2 id=\"directory-tree\">Directory Tree</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">markdown</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">http-server/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”œâ”€â”€ include/                 # Header files (Definitions &#x26; Interfaces)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”‚   â”œâ”€â”€ concurrency_types.h # M4: Thread pool &#x26; work structs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”‚   â”œâ”€â”€ date_utils.h        # M3: RFC 1123 date formatting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”‚   â”œâ”€â”€ file_handler.h      # M3: Static file serving logic</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”‚   â”œâ”€â”€ http_errors.h       # M2: Error response templates</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”‚   â”œâ”€â”€ http_parser.h       # M2: Request parsing prototypes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”‚   â”œâ”€â”€ http_types.h        # M2: HTTP enums and request struct</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”‚   â”œâ”€â”€ mime_types.h        # M3: Extension-to-MIME mapping table</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”‚   â”œâ”€â”€ path_utils.h        # M3: URL decoding &#x26; path safety</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”‚   â”œâ”€â”€ server.h            # M1: Core socket structures</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”‚   â”œâ”€â”€ thread_pool.h       # M4: Pool management functions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”‚   â”œâ”€â”€ connection_handler.h # M4: Connection lifecycle orchestration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”‚   â””â”€â”€ signals.h           # M4: Signal handling thread interface</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”œâ”€â”€ src/                     # Source files (Implementations)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”‚   â”œâ”€â”€ connection_handler.c # M4: Keep-alive loop &#x26; timeout logic</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”‚   â”œâ”€â”€ date_utils.c        # M3: timegm and strftime helpers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”‚   â”œâ”€â”€ file_handler.c      # M3: 64KB stream I/O loop</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”‚   â”œâ”€â”€ http.c              # M1: Hardcoded response builder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”‚   â”œâ”€â”€ http_errors.c       # M2: send_error_response implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”‚   â”œâ”€â”€ http_parser.c       # M2: Line-based state machine</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”‚   â”œâ”€â”€ main.c              # M1/M4: Entry point &#x26; orchestrator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”‚   â”œâ”€â”€ path_utils.c        # M3: realpath() &#x26; traversal checks</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”‚   â”œâ”€â”€ server.c            # M1: Socket dance (bind/listen)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”‚   â”œâ”€â”€ signals.c           # M4: Synchronous sigwait() thread</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”‚   â”œâ”€â”€ thread_pool.c       # M4: Worker loops &#x26; sync primitives</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”‚   â””â”€â”€ utils.c             # M1: write_all &#x26; partial read logic</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”œâ”€â”€ build/                   # Compiled binaries (Build Artifact)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”œâ”€â”€ Makefile                 # Build system (Build Artifact)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â”œâ”€â”€ .gitignore               # Version control exclusions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">â””â”€â”€ README.md               # Project overview and testing guide</span></span></code></pre></div>\n\n<h2 id=\"creation-order\">Creation Order</h2>\n<ol>\n<li><p><strong>Project Scaffolding</strong> (30 min)</p>\n<ul>\n<li>Create <code>include/</code>, <code>src/</code>, and <code>build/</code> directories.</li>\n<li>Set up <code>Makefile</code> with <code>-pthread</code> and <code>-Wall -Wextra</code> flags.</li>\n<li>Initialize <code>server.h</code> with <code>server_config_t</code>.</li>\n</ul>\n</li>\n<li><p><strong>Milestone 1: The Socket Foundation</strong> (2 hours)</p>\n<ul>\n<li>Implement <code>src/utils.c</code> (<code>read_http_request</code>, <code>write_all</code>).</li>\n<li>Implement <code>src/server.c</code> (<code>socket_init</code>, <code>bind</code>, <code>listen</code>).</li>\n<li>Implement <code>src/http.c</code> (hardcoded response).</li>\n<li>Create basic <code>src/main.c</code> accept loop.</li>\n</ul>\n</li>\n<li><p><strong>Milestone 2: Protocol Parsing</strong> (3 hours)</p>\n<ul>\n<li>Define <code>include/http_types.h</code> (<code>http_request_t</code>).</li>\n<li>Implement <code>src/http_parser.c</code> (<code>parse_request_line</code>, <code>parse_header_line</code>).</li>\n<li>Implement <code>src/http_errors.c</code> (<code>send_400</code>, <code>send_414</code>, <code>send_501</code>).</li>\n<li>Integrate parser into the connection handler.</li>\n</ul>\n</li>\n<li><p><strong>Milestone 3: Payload Delivery &amp; Security</strong> (4 hours)</p>\n<ul>\n<li>Implement <code>src/path_utils.c</code> (<code>url_decode</code>, <code>resolve_safe_path</code>).</li>\n<li>Implement <code>src/date_utils.c</code> (RFC 1123 UTC formatting).</li>\n<li>Define <code>include/mime_types.h</code> table.</li>\n<li>Implement <code>src/file_handler.c</code> (The 8-phase serving orchestrator).</li>\n</ul>\n</li>\n<li><p><strong>Milestone 4: High Concurrency &amp; Hardening</strong> (4 hours)</p>\n<ul>\n<li>Implement <code>src/thread_pool.c</code> (Mutex/CondVar work queue).</li>\n<li>Implement <code>src/signals.c</code> (Dedicated signal thread logic).</li>\n<li>Refactor <code>src/connection_handler.c</code> to include the Keep-Alive loop.</li>\n<li>Update <code>src/main.c</code> to initialize pool and mask signals.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"file-count-summary\">File Count Summary</h2>\n<ul>\n<li><strong>Total Header Files</strong>: 12</li>\n<li><strong>Total Source Files</strong>: 12</li>\n<li><strong>Build/Config Files</strong>: 3</li>\n<li><strong>Total Directories</strong>: 3 (root, include, src)</li>\n<li><strong>Estimated Lines of Code</strong>: ~1,450 LOC (Implementation logic + Comments)</li>\n</ul>\n","toc":[{"level":1,"text":"ðŸŽ¯ Project Charter: HTTP Server (Basic)","id":"-project-charter-http-server-basic"},{"level":2,"text":"What You Are Building","id":"what-you-are-building"},{"level":2,"text":"Why This Project Exists","id":"why-this-project-exists"},{"level":2,"text":"What You Will Be Able to Do When Done","id":"what-you-will-be-able-to-do-when-done"},{"level":2,"text":"Final Deliverable","id":"final-deliverable"},{"level":2,"text":"Is This Project For You?","id":"is-this-project-for-you"},{"level":2,"text":"Estimated Effort","id":"estimated-effort"},{"level":2,"text":"Definition of Done","id":"definition-of-done"},{"level":2,"text":"The Seven-Step Socket Dance","id":"the-seven-step-socket-dance"},{"level":3,"text":"Step 1: socket() â€” Create an Endpoint","id":"step-1-socket-create-an-endpoint"},{"level":3,"text":"Step 2: setsockopt() â€” Enable Port Reuse","id":"step-2-setsockopt-enable-port-reuse"},{"level":3,"text":"Step 3: bind() â€” Claim a Port","id":"step-3-bind-claim-a-port"},{"level":3,"text":"Step 4: listen() â€” Start Accepting Connections","id":"step-4-listen-start-accepting-connections"},{"level":3,"text":"Step 5: accept() â€” Receive a Connection","id":"step-5-accept-receive-a-connection"},{"level":3,"text":"Step 6: read() / recv() and write() / send() â€” Communicate","id":"step-6-read-recv-and-write-send-communicate"},{"level":3,"text":"Step 7: close() â€” Release the Connection","id":"step-7-close-release-the-connection"},{"level":2,"text":"After your response is sent, close the client socket. This signals to the client that you&#39;re done (TCP FIN handshake), and releases the kernel file descriptor. Never skip this.","id":"after-your-response-is-sent-close-the-client-socket-this-signals-to-the-client-that-you39re-done-tcp-fin-handshake-and-releases-the-kernel-file-descriptor-never-skip-this"},{"level":2,"text":"Three-Level View: What Happens When You Call accept()","id":"three-level-view-what-happens-when-you-call-accept"},{"level":2,"text":"The Partial Read Problem â€” Solved","id":"the-partial-read-problem-solved"},{"level":2,"text":"Building the Complete Server","id":"building-the-complete-server"},{"level":3,"text":"Data Structures and Memory Layout","id":"data-structures-and-memory-layout"},{"level":3,"text":"The Hardcoded HTTP Response","id":"the-hardcoded-http-response"},{"level":3,"text":"Writing the Response â€” Partial Writes","id":"writing-the-response-partial-writes"},{"level":3,"text":"Handling SIGPIPE â€” Don&#39;t Let the Client Kill Your Server","id":"handling-sigpipe-don39t-let-the-client-kill-your-server"},{"level":3,"text":"The Complete main() Function","id":"the-complete-main-function"},{"level":3,"text":"Compiling and Testing","id":"compiling-and-testing"},{"level":3,"text":"Verifying No File Descriptor Leaks","id":"verifying-no-file-descriptor-leaks"},{"level":2,"text":"If the count grows, you have a file descriptor leak. In this milestone&#39;s sequential design, the cause is always a missing close(client_fd) on an error path. Every if (something_failed) block that exits before the normal close(client_fd) must also close the FD.","id":"if-the-count-grows-you-have-a-file-descriptor-leak-in-this-milestone39s-sequential-design-the-cause-is-always-a-missing-closeclient_fd-on-an-error-path-every-if-something_failed-block-that-exits-before-the-normal-closeclient_fd-must-also-close-the-fd"},{"level":2,"text":"Hardware Soul: What the CPU and Kernel Are Doing","id":"hardware-soul-what-the-cpu-and-kernel-are-doing"},{"level":2,"text":"Let&#39;s apply the domain&#39;s hardware perspective to the operations in this milestone.\naccept() â€” blocking on empty queue: Your thread is in the TASK_INTERRUPTIBLE sleep state. The CPU runs other processes. When a SYN arrives, the NIC raises a hardware interrupt, the kernel interrupt handler runs (in kernel space), processes the TCP three-way handshake, moves the connection to the accept queue, and transitions your thread to TASK_RUNNING. Next time the scheduler runs, your thread wakes up and accept() returns. Zero CPU cycles wasted while waiting.\nread() from socket â€” memory access pattern: The kernel&#39;s receive buffer is in kernel virtual memory. When you call read(), the kernel copies bytes from its buffer into your userspace buffer (req_buf). This is a memory-to-memory copy with good locality if the request is small (fits in L1/L2 cache). For a typical 200-byte HTTP request, the entire operation â€” kernel buffer + your buffer â€” fits in L1 cache (typically 32â€“64KB). Latency: ~100ns for in-cache operations.\nwrite() to socket â€” send buffer: The kernel has a send buffer per socket (default ~87KB on Linux, controlled by SO_SNDBUF). Your write() copies data from your buffer into the send buffer and returns. The kernel&#39;s TCP stack asynchronously handles segmentation and transmission. This means write() is nearly always fast (just a memory copy). It only blocks if the send buffer is full â€” which happens when the network is congested or the client is reading slowly.\nclose() â€” FD table update: Closing an FD is a kernel table update: decrement the reference count on the socket structure, release the FD slot in the process&#39;s file descriptor table. If reference count hits zero (no other FD points to this socket), begin TCP FIN sequence. Very fast â€” no disk I/O, just memory writes.\nBranch prediction: The accept loop&#39;s while(1) is perfectly predictable (always taken). The error checks (if (client_fd &lt; 0)) are almost never taken in normal operation â€” the branch predictor learns this quickly. The partial read loop&#39;s termination condition (strstr found \\r\\n\\r\\n) is taken once per request â€” predictable after the first connection.","id":"let39s-apply-the-domain39s-hardware-perspective-to-the-operations-in-this-milestone-accept-blocking-on-empty-queue-your-thread-is-in-the-task_interruptible-sleep-state-the-cpu-runs-other-processes-when-a-syn-arrives-the-nic-raises-a-hardware-interrupt-the-kernel-interrupt-handler-runs-in-kernel-space-processes-the-tcp-three-way-handshake-moves-the-connection-to-the-accept-queue-and-transitions-your-thread-to-task_running-next-time-the-scheduler-runs-your-thread-wakes-up-and-accept-returns-zero-cpu-cycles-wasted-while-waiting-read-from-socket-memory-access-pattern-the-kernel39s-receive-buffer-is-in-kernel-virtual-memory-when-you-call-read-the-kernel-copies-bytes-from-its-buffer-into-your-userspace-buffer-req_buf-this-is-a-memory-to-memory-copy-with-good-locality-if-the-request-is-small-fits-in-l1l2-cache-for-a-typical-200-byte-http-request-the-entire-operation-kernel-buffer-your-buffer-fits-in-l1-cache-typically-3264kb-latency-100ns-for-in-cache-operations-write-to-socket-send-buffer-the-kernel-has-a-send-buffer-per-socket-default-87kb-on-linux-controlled-by-so_sndbuf-your-write-copies-data-from-your-buffer-into-the-send-buffer-and-returns-the-kernel39s-tcp-stack-asynchronously-handles-segmentation-and-transmission-this-means-write-is-nearly-always-fast-just-a-memory-copy-it-only-blocks-if-the-send-buffer-is-full-which-happens-when-the-network-is-congested-or-the-client-is-reading-slowly-close-fd-table-update-closing-an-fd-is-a-kernel-table-update-decrement-the-reference-count-on-the-socket-structure-release-the-fd-slot-in-the-process39s-file-descriptor-table-if-reference-count-hits-zero-no-other-fd-points-to-this-socket-begin-tcp-fin-sequence-very-fast-no-disk-io-just-memory-writes-branch-prediction-the-accept-loop39s-while1-is-perfectly-predictable-always-taken-the-error-checks-if-client_fd-lt-0-are-almost-never-taken-in-normal-operation-the-branch-predictor-learns-this-quickly-the-partial-read-loop39s-termination-condition-strstr-found-rnrn-is-taken-once-per-request-predictable-after-the-first-connection"},{"level":2,"text":"Error Handling Philosophy for Systems Code","id":"error-handling-philosophy-for-systems-code"},{"level":2,"text":"Design Decision: Sequential vs. Concurrent Connections","id":"design-decision-sequential-vs-concurrent-connections"},{"level":2,"text":"Knowledge Cascade: What This Unlocks","id":"knowledge-cascade-what-this-unlocks"},{"level":3,"text":"1. Every Language&#39;s Buffered I/O Makes Sense Now","id":"1-every-language39s-buffered-io-makes-sense-now"},{"level":3,"text":"2. Protocol Framing Is a Universal Problem","id":"2-protocol-framing-is-a-universal-problem"},{"level":3,"text":"3. Nagle&#39;s Algorithm and TCP_NODELAY","id":"3-nagle39s-algorithm-and-tcp_nodelay"},{"level":3,"text":"4. Non-Blocking I/O and Event Loops","id":"4-non-blocking-io-and-event-loops"},{"level":3,"text":"5. The FD Lifecycle Is Universal","id":"5-the-fd-lifecycle-is-universal"},{"level":2,"text":"The file descriptor management discipline you&#39;re building â€” open, use, close, never leak â€” applies identically to files, pipes, sockets, timers (timerfd), event notifications (eventfd), and even GPU command buffers in Vulkan. The kernel&#39;s reference-counted resource model is the same everywhere. The ulimit -n ceiling is the same ceiling. The /proc/&lt;pid&gt;/fd/ directory lets you inspect any process&#39;s open resources, and now you know what you&#39;re looking at.","id":"the-file-descriptor-management-discipline-you39re-building-open-use-close-never-leak-applies-identically-to-files-pipes-sockets-timers-timerfd-event-notifications-eventfd-and-even-gpu-command-buffers-in-vulkan-the-kernel39s-reference-counted-resource-model-is-the-same-everywhere-the-ulimit-n-ceiling-is-the-same-ceiling-the-procltpidgtfd-directory-lets-you-inspect-any-process39s-open-resources-and-now-you-know-what-you39re-looking-at"},{"level":2,"text":"Common Mistakes That Will Burn You","id":"common-mistakes-that-will-burn-you"},{"level":2,"text":"Keep these in a mental checklist:\n1. Forgetting htons() on the port.\nbind() will succeed â€” on the wrong port. You&#39;ll spend an hour wondering why curl localhost:8080 times out before realizing your server is actually listening on port 36895.\n2. Not handling EINTR on accept().\nWhen a signal arrives (including SIGCHLD in Milestone 4&#39;s thread model), accept() returns -1 with errno = EINTR. If you exit the accept loop on any negative return, one signal kills your server. Always check errno == EINTR and retry.\n3. Assuming read() returns a complete request.\nWorks on localhost, fails in staging, fails in production, fails in any test that simulates network conditions. The partial-read loop is non-negotiable.\n4. Missing close(client_fd) on error paths.\nEvery early return inside the connection-handling block must close client_fd before returning. Draw the control flow on paper if needed. A leak here is a server that degrades after thousands of connections and becomes unfixable without a restart.\n5. Ignoring write() return values.\nwrite() returning -1 with EPIPE is the normal case when a client disconnects. If you don&#39;t check return values, you don&#39;t know whether your response was delivered, and you may try to write to a dead connection repeatedly.","id":"keep-these-in-a-mental-checklist-1-forgetting-htons-on-the-port-bind-will-succeed-on-the-wrong-port-you39ll-spend-an-hour-wondering-why-curl-localhost8080-times-out-before-realizing-your-server-is-actually-listening-on-port-36895-2-not-handling-eintr-on-accept-when-a-signal-arrives-including-sigchld-in-milestone-439s-thread-model-accept-returns-1-with-errno-eintr-if-you-exit-the-accept-loop-on-any-negative-return-one-signal-kills-your-server-always-check-errno-eintr-and-retry-3-assuming-read-returns-a-complete-request-works-on-localhost-fails-in-staging-fails-in-production-fails-in-any-test-that-simulates-network-conditions-the-partial-read-loop-is-non-negotiable-4-missing-closeclient_fd-on-error-paths-every-early-return-inside-the-connection-handling-block-must-close-client_fd-before-returning-draw-the-control-flow-on-paper-if-needed-a-leak-here-is-a-server-that-degrades-after-thousands-of-connections-and-becomes-unfixable-without-a-restart-5-ignoring-write-return-values-write-returning-1-with-epipe-is-the-normal-case-when-a-client-disconnects-if-you-don39t-check-return-values-you-don39t-know-whether-your-response-was-delivered-and-you-may-try-to-write-to-a-dead-connection-repeatedly"},{"level":2,"text":"Acceptance Criteria Checklist","id":"acceptance-criteria-checklist"},{"level":1,"text":"Milestone 2: HTTP Request Parsing","id":"milestone-2-http-request-parsing"},{"level":2,"text":"Where You Are in the System","id":"where-you-are-in-the-system"},{"level":2,"text":"That&#39;s just a char[]. Your server doesn&#39;t know the method, doesn&#39;t know the path, doesn&#39;t know whether to read a body. Before you can serve files (Milestone 3) or handle multiple connections properly (Milestone 4), you need a parser â€” code that transforms those raw bytes into structured data your program can reason about.\nThis milestone&#39;s job: turn the byte buffer into a struct. After this milestone, the rest of your server speaks in terms of request.method, request.path, and request.headers[&quot;content-type&quot;] â€” not raw offsets and strstr() calls scattered across the codebase.","id":"that39s-just-a-char-your-server-doesn39t-know-the-method-doesn39t-know-the-path-doesn39t-know-whether-to-read-a-body-before-you-can-serve-files-milestone-3-or-handle-multiple-connections-properly-milestone-4-you-need-a-parser-code-that-transforms-those-raw-bytes-into-structured-data-your-program-can-reason-about-this-milestone39s-job-turn-the-byte-buffer-into-a-struct-after-this-milestone-the-rest-of-your-server-speaks-in-terms-of-requestmethod-requestpath-and-requestheadersquotcontent-typequot-not-raw-offsets-and-strstr-calls-scattered-across-the-codebase"},{"level":2,"text":"The Revelation: HTTP Parsing Is Adversarial","id":"the-revelation-http-parsing-is-adversarial"},{"level":3,"text":"The Input You Won&#39;t See in Testing","id":"the-input-you-won39t-see-in-testing"},{"level":3,"text":"Why &quot;Split on Spaces&quot; Is a Security Vulnerability","id":"why-quotsplit-on-spacesquot-is-a-security-vulnerability"},{"level":2,"text":"The same header name appears twice, in different cases. Which one is the &quot;real&quot; Content-Type? A naive parser that uses case-sensitive string comparison won&#39;t even recognize content-type as the same header. RFC 7230 says header names are case-insensitive. Your parser must implement that.\nThe real mental model: HTTP parsing is adversarial string processing. Every field in an HTTP request is input from a potentially hostile source. Your parser&#39;s job is not just extraction â€” it&#39;s validation, normalization, and rejection.","id":"the-same-header-name-appears-twice-in-different-cases-which-one-is-the-quotrealquot-content-type-a-naive-parser-that-uses-case-sensitive-string-comparison-won39t-even-recognize-content-type-as-the-same-header-rfc-7230-says-header-names-are-case-insensitive-your-parser-must-implement-that-the-real-mental-model-http-parsing-is-adversarial-string-processing-every-field-in-an-http-request-is-input-from-a-potentially-hostile-source-your-parser39s-job-is-not-just-extraction-it39s-validation-normalization-and-rejection"},{"level":2,"text":"The HTTP/1.1 Message Format","id":"the-http11-message-format"},{"level":2,"text":"Designing the Parsed Request Structure","id":"designing-the-parsed-request-structure"},{"level":2,"text":"Several design decisions worth examining:\nFixed-size arrays instead of dynamic allocation. http_header_t headers[MAX_HEADERS] uses 32 statically-allocated header slots. An alternative is malloc()ing a linked list or growing array. The fixed-array approach has two advantages: no allocation failures, and cache locality (all headers are contiguous in memory). The downside: we reject requests with more than 32 headers. In practice, real HTTP requests have 5â€“15 headers, so 32 is generous. nginx&#39;s default is 100, but HTTP/2 HPACK compression means that limit is rarely approached.\nLowercase header names. We&#39;ll normalize all header names to lowercase during parsing. This is the &quot;right&quot; approach for case-insensitive comparison â€” normalize once at parse time, compare cheaply everywhere else. The alternative (compare case-insensitively every time you look up a header) means writing a strcasecmp() comparison for every header lookup, scattered across your codebase.\ncontent_length as -1 sentinel. -1 means &quot;no Content-Length header was present.&quot; 0 means the header was present and specified a zero-length body. This distinction matters: a response with Content-Length: 0 and no body is valid and different from a response with no Content-Length at all.\nbody as pointer into the original buffer. The body isn&#39;t copied â€” we point into the buffer we already read. This is the beginning of zero-copy parsing: instead of malloc()ing memory and copying the body, we just record where in the existing buffer the body starts. For large request bodies (file uploads, POST data), this avoids a potentially multi-megabyte copy.","id":"several-design-decisions-worth-examining-fixed-size-arrays-instead-of-dynamic-allocation-http_header_t-headersmax_headers-uses-32-statically-allocated-header-slots-an-alternative-is-mallocing-a-linked-list-or-growing-array-the-fixed-array-approach-has-two-advantages-no-allocation-failures-and-cache-locality-all-headers-are-contiguous-in-memory-the-downside-we-reject-requests-with-more-than-32-headers-in-practice-real-http-requests-have-515-headers-so-32-is-generous-nginx39s-default-is-100-but-http2-hpack-compression-means-that-limit-is-rarely-approached-lowercase-header-names-we39ll-normalize-all-header-names-to-lowercase-during-parsing-this-is-the-quotrightquot-approach-for-case-insensitive-comparison-normalize-once-at-parse-time-compare-cheaply-everywhere-else-the-alternative-compare-case-insensitively-every-time-you-look-up-a-header-means-writing-a-strcasecmp-comparison-for-every-header-lookup-scattered-across-your-codebase-content_length-as-1-sentinel-1-means-quotno-content-length-header-was-presentquot-0-means-the-header-was-present-and-specified-a-zero-length-body-this-distinction-matters-a-response-with-content-length-0-and-no-body-is-valid-and-different-from-a-response-with-no-content-length-at-all-body-as-pointer-into-the-original-buffer-the-body-isn39t-copied-we-point-into-the-buffer-we-already-read-this-is-the-beginning-of-zero-copy-parsing-instead-of-mallocing-memory-and-copying-the-body-we-just-record-where-in-the-existing-buffer-the-body-starts-for-large-request-bodies-file-uploads-post-data-this-avoids-a-potentially-multi-megabyte-copy"},{"level":2,"text":"Building the State Machine","id":"building-the-state-machine"},{"level":3,"text":"Step 1: Parse the Request Line","id":"step-1-parse-the-request-line"},{"level":3,"text":"Step 2: Parse Headers","id":"step-2-parse-headers"},{"level":3,"text":"Step 3: Post-Processing â€” Extract Semantic Headers","id":"step-3-post-processing-extract-semantic-headers"},{"level":2,"text":"strtol() for Content-Length, not atoi(). atoi() has no error detection â€” if the input is &quot;abc&quot; or &quot;&quot;, it returns 0 without any indication of failure. strtol() sets an end pointer: if *end != &#39;\\0&#39; after the call, there were non-numeric characters. We also cap at 64MB â€” a server serving static HTML and CSS files has no business reading a 4GB request body. This limit prevents a slow client from sending Content-Length: 9999999999 and holding your connection open while trickling bytes.\nstrcasecmp() for Connection values. Header names we normalize to lowercase ourselves. Header values may be any case â€” the spec says method tokens and header values are case-insensitive where defined. Connection: Close, Connection: CLOSE, and Connection: close are all valid. strcasecmp() (POSIX) handles this. On Windows you&#39;d use _stricmp() â€” worth knowing if you ever port this code.","id":"strtol-for-content-length-not-atoi-atoi-has-no-error-detection-if-the-input-is-quotabcquot-or-quotquot-it-returns-0-without-any-indication-of-failure-strtol-sets-an-end-pointer-if-end-39039-after-the-call-there-were-non-numeric-characters-we-also-cap-at-64mb-a-server-serving-static-html-and-css-files-has-no-business-reading-a-4gb-request-body-this-limit-prevents-a-slow-client-from-sending-content-length-9999999999-and-holding-your-connection-open-while-trickling-bytes-strcasecmp-for-connection-values-header-names-we-normalize-to-lowercase-ourselves-header-values-may-be-any-case-the-spec-says-method-tokens-and-header-values-are-case-insensitive-where-defined-connection-close-connection-close-and-connection-close-are-all-valid-strcasecmp-posix-handles-this-on-windows-you39d-use-_stricmp-worth-knowing-if-you-ever-port-this-code"},{"level":2,"text":"Assembling the Full Parser","id":"assembling-the-full-parser"},{"level":2,"text":"Several design decisions here:\nLine copying into line_buf. We copy each line into a temporary scratch buffer before parsing it. This protects the original buffer from modification and gives parse_request_line() and parse_header_line() a null-terminated string to work with. It costs one memcpy() per line (~100â€“500 bytes). For an HTTP server handling thousands of short requests, this is negligible. For a system parsing gigabytes of HTTP traffic (an API gateway or load balancer), you&#39;d investigate zero-copy approaches â€” but that&#39;s the optimization ladder for later.\nSilently skip malformed headers. RFC 7230 says: &quot;A server that receives an obs-fold in a request message that is not within a message/http container MUST either reject the message [...] or replace each received obs-fold with one or more SP octets.&quot; The general principle is that a receiver may choose to be lenient with headers it doesn&#39;t understand while being strict with the request line and Host header. We silently skip malformed header lines with a negative return from parse_header_line() â€” they don&#39;t cause a 400.\nHost header is required in HTTP/1.1. RFC 7230 Section 5.4: &quot;A client MUST send a Host header field in all HTTP/1.1 request messages.&quot; A server &quot;MUST respond with a 400 (Bad Request) status code to any HTTP/1.1 request message that lacks a Host header field.&quot; We enforce this. HTTP/1.0 requests don&#39;t require Host, which is why we only check it when http_minor == 1.","id":"several-design-decisions-here-line-copying-into-line_buf-we-copy-each-line-into-a-temporary-scratch-buffer-before-parsing-it-this-protects-the-original-buffer-from-modification-and-gives-parse_request_line-and-parse_header_line-a-null-terminated-string-to-work-with-it-costs-one-memcpy-per-line-100500-bytes-for-an-http-server-handling-thousands-of-short-requests-this-is-negligible-for-a-system-parsing-gigabytes-of-http-traffic-an-api-gateway-or-load-balancer-you39d-investigate-zero-copy-approaches-but-that39s-the-optimization-ladder-for-later-silently-skip-malformed-headers-rfc-7230-says-quota-server-that-receives-an-obs-fold-in-a-request-message-that-is-not-within-a-messagehttp-container-must-either-reject-the-message-or-replace-each-received-obs-fold-with-one-or-more-sp-octetsquot-the-general-principle-is-that-a-receiver-may-choose-to-be-lenient-with-headers-it-doesn39t-understand-while-being-strict-with-the-request-line-and-host-header-we-silently-skip-malformed-header-lines-with-a-negative-return-from-parse_header_line-they-don39t-cause-a-400-host-header-is-required-in-http11-rfc-7230-section-54-quota-client-must-send-a-host-header-field-in-all-http11-request-messagesquot-a-server-quotmust-respond-with-a-400-bad-request-status-code-to-any-http11-request-message-that-lacks-a-host-header-fieldquot-we-enforce-this-http10-requests-don39t-require-host-which-is-why-we-only-check-it-when-http_minor-1"},{"level":2,"text":"Error Responses","id":"error-responses"},{"level":2,"text":"HEAD Requests: Same Headers, No Body","id":"head-requests-same-headers-no-body"},{"level":2,"text":"Right now, in Milestone 2&#39;s parser, all you need to do is correctly identify HEAD and store it as METHOD_HEAD. The body-suppression logic lives in the response path, not the parser. The parser&#39;s job is faithfully representing what the client asked for; the responder decides what to send back.","id":"right-now-in-milestone-239s-parser-all-you-need-to-do-is-correctly-identify-head-and-store-it-as-method_head-the-body-suppression-logic-lives-in-the-response-path-not-the-parser-the-parser39s-job-is-faithfully-representing-what-the-client-asked-for-the-responder-decides-what-to-send-back"},{"level":2,"text":"Reading the Request Body","id":"reading-the-request-body"},{"level":2,"text":"The overflow parameter handles a subtle case: if the client sent a small request body and it arrived in the same recv() call as the headers (common on localhost), your Milestone 1 read loop may have already read part or all of the body into the header buffer. The bytes after the \\r\\n\\r\\n offset are &quot;overflow&quot; body bytes. We copy them first, then read the remainder from the socket.\nFor this milestone, you&#39;ll likely only implement GET and HEAD, so body reading is forward-looking infrastructure. But building the function now means Milestone 3 can simply call it without revisiting the parsing layer.","id":"the-overflow-parameter-handles-a-subtle-case-if-the-client-sent-a-small-request-body-and-it-arrived-in-the-same-recv-call-as-the-headers-common-on-localhost-your-milestone-1-read-loop-may-have-already-read-part-or-all-of-the-body-into-the-header-buffer-the-bytes-after-the-rnrn-offset-are-quotoverflowquot-body-bytes-we-copy-them-first-then-read-the-remainder-from-the-socket-for-this-milestone-you39ll-likely-only-implement-get-and-head-so-body-reading-is-forward-looking-infrastructure-but-building-the-function-now-means-milestone-3-can-simply-call-it-without-revisiting-the-parsing-layer"},{"level":2,"text":"Integration: Wiring the Parser into the Accept Loop","id":"integration-wiring-the-parser-into-the-accept-loop"},{"level":2,"text":"The three-phase structure â€” read, parse, dispatch â€” is the architecture you&#39;ll carry through Milestones 3 and 4. Each phase has a clear responsibility and returns a clear signal. Phase 1 gives you bytes; phase 2 gives you structure; phase 3 gives you behavior.","id":"the-three-phase-structure-read-parse-dispatch-is-the-architecture-you39ll-carry-through-milestones-3-and-4-each-phase-has-a-clear-responsibility-and-returns-a-clear-signal-phase-1-gives-you-bytes-phase-2-gives-you-structure-phase-3-gives-you-behavior"},{"level":2,"text":"Testing the Parser","id":"testing-the-parser"},{"level":2,"text":"Hardware Soul: What the CPU Does During Parsing","id":"hardware-soul-what-the-cpu-does-during-parsing"},{"level":2,"text":"The HTTP parser is the most CPU-intensive component of a simple HTTP server. Let&#39;s look at what the hardware is actually doing.\nMemory access pattern â€” buffer locality. Your entire HTTP request (typically 200â€“2000 bytes) fits in L1 cache (32â€“64KB on modern CPUs). Every call to strchr(), memcmp(), and memcpy() within the parse is operating on L1-resident data. L1 access latency is ~1ns. The entire parse of a typical request takes a few microseconds â€” fast enough that parsing is never the bottleneck in a well-implemented server.\nBranch prediction during str_to_lower(). The character-by-character lowercase conversion in str_to_lower() has a branch: if (*s &gt;= &#39;A&#39; &amp;&amp; *s &lt;= &#39;Z&#39;). In HTTP header names like Content-Type, the characters alternate between uppercase (first letter of each word) and lowercase. The branch predictor has a hard time here â€” the pattern is irregular. Modern CPUs handle this with a trick: the compiler often generates SIMD instructions for short string operations, processing 16 bytes at once with SSE/AVX. The trick: _mm_sub_epi8 to subtract &#39;A&#39;, compare against 26 (the range of uppercase letters), and conditionally add 32 â€” all in one instruction on 16 bytes simultaneously. If you enable -O2 optimization in GCC, the compiler may do this automatically.\nstrchr() implementation. The strchr() call to find the colon in a header line like Content-Type: text/html scans up to ~15 bytes. The glibc implementation uses SIMD to scan 16 or 32 bytes at a time. For a 15-byte scan, the SIMD overhead isn&#39;t worth it, and glibc falls back to a byte loop. But for longer strings (long header values), SIMD strchr() is measurably faster.\nCache line granularity of the struct. Your http_request_t struct is large â€” with MAX_HEADERS = 32 entries of (256 + 8192) bytes each, the struct approaches 270KB. That won&#39;t fit in L1 or L2 cache. However, you only access a handful of headers in practice (Host, Content-Length, Connection), and those are the first few entries in the array. The parser should fill headers in order of appearance, so the most-accessed headers (which tend to appear early in real requests) are in the earliest array slots â€” resident in the &quot;hot&quot; part of the cache.\nThis is why the earlier design note about fixed arrays matters: a linked list of dynamically-allocated header nodes would scatter them across the heap, causing cache misses when iterating. The contiguous array keeps all headers in a predictable, prefetch-friendly layout.","id":"the-http-parser-is-the-most-cpu-intensive-component-of-a-simple-http-server-let39s-look-at-what-the-hardware-is-actually-doing-memory-access-pattern-buffer-locality-your-entire-http-request-typically-2002000-bytes-fits-in-l1-cache-3264kb-on-modern-cpus-every-call-to-strchr-memcmp-and-memcpy-within-the-parse-is-operating-on-l1-resident-data-l1-access-latency-is-1ns-the-entire-parse-of-a-typical-request-takes-a-few-microseconds-fast-enough-that-parsing-is-never-the-bottleneck-in-a-well-implemented-server-branch-prediction-during-str_to_lower-the-character-by-character-lowercase-conversion-in-str_to_lower-has-a-branch-if-s-gt-39a39-ampamp-s-lt-39z39-in-http-header-names-like-content-type-the-characters-alternate-between-uppercase-first-letter-of-each-word-and-lowercase-the-branch-predictor-has-a-hard-time-here-the-pattern-is-irregular-modern-cpus-handle-this-with-a-trick-the-compiler-often-generates-simd-instructions-for-short-string-operations-processing-16-bytes-at-once-with-sseavx-the-trick-_mm_sub_epi8-to-subtract-39a39-compare-against-26-the-range-of-uppercase-letters-and-conditionally-add-32-all-in-one-instruction-on-16-bytes-simultaneously-if-you-enable-o2-optimization-in-gcc-the-compiler-may-do-this-automatically-strchr-implementation-the-strchr-call-to-find-the-colon-in-a-header-line-like-content-type-texthtml-scans-up-to-15-bytes-the-glibc-implementation-uses-simd-to-scan-16-or-32-bytes-at-a-time-for-a-15-byte-scan-the-simd-overhead-isn39t-worth-it-and-glibc-falls-back-to-a-byte-loop-but-for-longer-strings-long-header-values-simd-strchr-is-measurably-faster-cache-line-granularity-of-the-struct-your-http_request_t-struct-is-large-with-max_headers-32-entries-of-256-8192-bytes-each-the-struct-approaches-270kb-that-won39t-fit-in-l1-or-l2-cache-however-you-only-access-a-handful-of-headers-in-practice-host-content-length-connection-and-those-are-the-first-few-entries-in-the-array-the-parser-should-fill-headers-in-order-of-appearance-so-the-most-accessed-headers-which-tend-to-appear-early-in-real-requests-are-in-the-earliest-array-slots-resident-in-the-quothotquot-part-of-the-cache-this-is-why-the-earlier-design-note-about-fixed-arrays-matters-a-linked-list-of-dynamically-allocated-header-nodes-would-scatter-them-across-the-heap-causing-cache-misses-when-iterating-the-contiguous-array-keeps-all-headers-in-a-predictable-prefetch-friendly-layout"},{"level":2,"text":"Three-Level View: Parsing a Header Line","id":"three-level-view-parsing-a-header-line"},{"level":2,"text":"Take &quot;Content-Type: text/html&quot; and trace it through all three levels.\nLevel 1 â€” Your code:\nparse_header_line(&quot;Content-Type: text/html&quot;, &amp;req) runs. strchr() finds the colon at offset 12. memcpy() copies &quot;Content-Type&quot; into h-&gt;name. str_to_lower() converts it to &quot;content-type&quot;. strip_ows() copies &quot;text/html&quot; into h-&gt;value. req-&gt;header_count increments.\nLevel 2 â€” OS/Kernel:\nNo syscalls during parsing. The bytes are already in your process&#39;s user-space buffer â€” the kernel handed them to you when read() returned. The OS scheduler may preempt your process during the parse if a higher-priority process needs to run, but this is transparent. From the kernel&#39;s perspective, you&#39;re just a user-space process doing arithmetic on memory.\nLevel 3 â€” Hardware:\nThe CPU is executing integer instructions on cache-resident data. strchr() may be vectorized by the compiler/glibc to use SSE4.2&#39;s PCMPEQB instruction, which compares 16 bytes against the colon character in a single clock cycle. memcpy() for 12 bytes compiles to a few register moves â€” no separate loop. str_to_lower() for 12 characters executes 12 iterations of the loop, each testing two conditions and conditionally adding 32. With branch prediction warm (the alternating upper/lower pattern is learnable after a few iterations), mispredictions are rare. Total hardware cost: ~50â€“100 clock cycles, ~25ns at 2GHz.","id":"take-quotcontent-type-texthtmlquot-and-trace-it-through-all-three-levels-level-1-your-code-parse_header_linequotcontent-type-texthtmlquot-ampreq-runs-strchr-finds-the-colon-at-offset-12-memcpy-copies-quotcontent-typequot-into-h-gtname-str_to_lower-converts-it-to-quotcontent-typequot-strip_ows-copies-quottexthtmlquot-into-h-gtvalue-req-gtheader_count-increments-level-2-oskernel-no-syscalls-during-parsing-the-bytes-are-already-in-your-process39s-user-space-buffer-the-kernel-handed-them-to-you-when-read-returned-the-os-scheduler-may-preempt-your-process-during-the-parse-if-a-higher-priority-process-needs-to-run-but-this-is-transparent-from-the-kernel39s-perspective-you39re-just-a-user-space-process-doing-arithmetic-on-memory-level-3-hardware-the-cpu-is-executing-integer-instructions-on-cache-resident-data-strchr-may-be-vectorized-by-the-compilerglibc-to-use-sse4239s-pcmpeqb-instruction-which-compares-16-bytes-against-the-colon-character-in-a-single-clock-cycle-memcpy-for-12-bytes-compiles-to-a-few-register-moves-no-separate-loop-str_to_lower-for-12-characters-executes-12-iterations-of-the-loop-each-testing-two-conditions-and-conditionally-adding-32-with-branch-prediction-warm-the-alternating-upperlower-pattern-is-learnable-after-a-few-iterations-mispredictions-are-rare-total-hardware-cost-50100-clock-cycles-25ns-at-2ghz"},{"level":2,"text":"Design Decisions: Parser Architecture","id":"design-decisions-parser-architecture"},{"level":2,"text":"Knowledge Cascade: What This Unlocks","id":"knowledge-cascade-what-this-unlocks"},{"level":3,"text":"1. State Machines for Protocol Parsing â€” Universal Pattern","id":"1-state-machines-for-protocol-parsing-universal-pattern"},{"level":3,"text":"2. Case-Insensitive Comparison â€” Appearances Across Domains","id":"2-case-insensitive-comparison-appearances-across-domains"},{"level":3,"text":"3. Security Through Input Validation â€” Transfer to Injection Prevention","id":"3-security-through-input-validation-transfer-to-injection-prevention"},{"level":3,"text":"4. Zero-Copy Parsing â€” nginx&#39;s Secret Weapon","id":"4-zero-copy-parsing-nginx39s-secret-weapon"},{"level":3,"text":"5. The RFC As Primary Source â€” Reading Specifications","id":"5-the-rfc-as-primary-source-reading-specifications"},{"level":2,"text":"You&#39;ve now implemented something directly against an RFC (RFC 7230). This skill â€” reading a standards document and translating its MUST/SHOULD/MAY language into code â€” is one of the most valuable engineering skills that textbooks rarely teach. The RFC tells you exactly when to return 400 vs. 501, exactly what OWS means, exactly which headers are required. Now that you&#39;ve done this once, you can read RFC 7231 (HTTP semantics), RFC 7232 (conditional requests, which Milestone 3 needs), RFC 7234 (caching), and RFC 7235 (authentication) and know how to implement them. The same reading skill applies to the POSIX socket spec, the TLS 1.3 spec (RFC 8446), the JSON spec (RFC 8259), and any other protocol you encounter.","id":"you39ve-now-implemented-something-directly-against-an-rfc-rfc-7230-this-skill-reading-a-standards-document-and-translating-its-mustshouldmay-language-into-code-is-one-of-the-most-valuable-engineering-skills-that-textbooks-rarely-teach-the-rfc-tells-you-exactly-when-to-return-400-vs-501-exactly-what-ows-means-exactly-which-headers-are-required-now-that-you39ve-done-this-once-you-can-read-rfc-7231-http-semantics-rfc-7232-conditional-requests-which-milestone-3-needs-rfc-7234-caching-and-rfc-7235-authentication-and-know-how-to-implement-them-the-same-reading-skill-applies-to-the-posix-socket-spec-the-tls-13-spec-rfc-8446-the-json-spec-rfc-8259-and-any-other-protocol-you-encounter"},{"level":2,"text":"Common Mistakes That Will Burn You","id":"common-mistakes-that-will-burn-you"},{"level":2,"text":"1. Using strtok() for anything in your parser.\nstrtok() modifies its input by replacing delimiters with &#39;\\0&#39;. It also uses global state, making it unsafe in any context where parsing might be interrupted or called from multiple threads. Use strchr(), memchr(), and explicit pointer arithmetic instead.\n2. Case-sensitive header lookup.\nThe single most common conformance bug: request_get_header(&amp;req, &quot;Content-Length&quot;) fails to find a header stored as content-length. Store lowercase at parse time, look up lowercase always. When in doubt, add a DEBUG assert that the name you&#39;re looking up is already lowercase.\n3. Off-by-one in the CRLF check.\nWhen stripping the trailing \\r before parsing a line: check line_len &gt; 0 before accessing cursor[line_len - 1]. Accessing cursor[-1] on an empty line is undefined behavior â€” and on a buffer that started at buf[0], it reads the byte before your buffer.\n4. Not validating Content-Length before reading body.\nIf you accept Content-Length: 9999999999 and try to malloc() that many bytes, you crash. If you try to read() that many bytes, you hold the connection open indefinitely. Apply a reasonable maximum (64MB for this server) and reject the request with 400 if the value exceeds it.\n5. Forgetting bare LF handling.\ntelnet sends bare LF. curl with --http1.0 on some platforms sends bare LF. Test 7 in the section above will fail on your server if you only strip \\r\\n. Your line-splitting code must handle both \\r\\n and \\n.\n6. Not handling the &quot;no request line&quot; case.\nAn empty connection â€” client connects and immediately disconnects â€” results in zero bytes read. Your parser receives an empty buffer. parse_request_line() on an empty string should return 400, not segfault chasing a NULL return from strchr().","id":"1-using-strtok-for-anything-in-your-parser-strtok-modifies-its-input-by-replacing-delimiters-with-39039-it-also-uses-global-state-making-it-unsafe-in-any-context-where-parsing-might-be-interrupted-or-called-from-multiple-threads-use-strchr-memchr-and-explicit-pointer-arithmetic-instead-2-case-sensitive-header-lookup-the-single-most-common-conformance-bug-request_get_headerampreq-quotcontent-lengthquot-fails-to-find-a-header-stored-as-content-length-store-lowercase-at-parse-time-look-up-lowercase-always-when-in-doubt-add-a-debug-assert-that-the-name-you39re-looking-up-is-already-lowercase-3-off-by-one-in-the-crlf-check-when-stripping-the-trailing-r-before-parsing-a-line-check-line_len-gt-0-before-accessing-cursorline_len-1-accessing-cursor-1-on-an-empty-line-is-undefined-behavior-and-on-a-buffer-that-started-at-buf0-it-reads-the-byte-before-your-buffer-4-not-validating-content-length-before-reading-body-if-you-accept-content-length-9999999999-and-try-to-malloc-that-many-bytes-you-crash-if-you-try-to-read-that-many-bytes-you-hold-the-connection-open-indefinitely-apply-a-reasonable-maximum-64mb-for-this-server-and-reject-the-request-with-400-if-the-value-exceeds-it-5-forgetting-bare-lf-handling-telnet-sends-bare-lf-curl-with-http10-on-some-platforms-sends-bare-lf-test-7-in-the-section-above-will-fail-on-your-server-if-you-only-strip-rn-your-line-splitting-code-must-handle-both-rn-and-n-6-not-handling-the-quotno-request-linequot-case-an-empty-connection-client-connects-and-immediately-disconnects-results-in-zero-bytes-read-your-parser-receives-an-empty-buffer-parse_request_line-on-an-empty-string-should-return-400-not-segfault-chasing-a-null-return-from-strchr"},{"level":2,"text":"Acceptance Criteria Checklist","id":"acceptance-criteria-checklist"},{"level":1,"text":"Milestone 3: Static File Serving","id":"milestone-3-static-file-serving"},{"level":2,"text":"Where You Are in the System","id":"where-you-are-in-the-system"},{"level":2,"text":"This is the milestone where your HTTP server earns the label &quot;web server.&quot; When this is done, you can point a browser at your server and see actual HTML, CSS, images, and JavaScript render correctly. Every file-serving feature a browser expects â€” correct content types, conditional caching, security boundaries â€” gets implemented here.\nThere is one challenge in this milestone that towers above all others in importance. It is not MIME type detection, not 304 Not Modified handling, not directory index serving. It is path security. Get this wrong and your server is not a web server â€” it&#39;s a file exfiltration tool waiting to be exploited.","id":"this-is-the-milestone-where-your-http-server-earns-the-label-quotweb-serverquot-when-this-is-done-you-can-point-a-browser-at-your-server-and-see-actual-html-css-images-and-javascript-render-correctly-every-file-serving-feature-a-browser-expects-correct-content-types-conditional-caching-security-boundaries-gets-implemented-here-there-is-one-challenge-in-this-milestone-that-towers-above-all-others-in-importance-it-is-not-mime-type-detection-not-304-not-modified-handling-not-directory-index-serving-it-is-path-security-get-this-wrong-and-your-server-is-not-a-web-server-it39s-a-file-exfiltration-tool-waiting-to-be-exploited"},{"level":2,"text":"The Revelation: String Prefix Checking Is Not Security","id":"the-revelation-string-prefix-checking-is-not-security"},{"level":3,"text":"Attack 1: The Classic ../ Traversal","id":"attack-1-the-classic-traversal"},{"level":3,"text":"Attack 2: URL-Encoded Traversal","id":"attack-2-url-encoded-traversal"},{"level":3,"text":"Attack 3: Symlink Bypass","id":"attack-3-symlink-bypass"},{"level":3,"text":"Attack 4: Double Encoding","id":"attack-4-double-encoding"},{"level":3,"text":"Attack 5: Unicode Normalization","id":"attack-5-unicode-normalization"},{"level":2,"text":"On case-insensitive filesystems (macOS HFS+, Windows NTFS), the path /VAR/WWW/HTML/../../ETC/PASSWD might resolve correctly even if your check is case-sensitive. Your prefix check fails (different case), you reject it â€” but had you been on a case-insensitive system and not normalized case, this would be an inconsistency to exploit.","id":"on-case-insensitive-filesystems-macos-hfs-windows-ntfs-the-path-varwwwhtmletcpasswd-might-resolve-correctly-even-if-your-check-is-case-sensitive-your-prefix-check-fails-different-case-you-reject-it-but-had-you-been-on-a-case-insensitive-system-and-not-normalized-case-this-would-be-an-inconsistency-to-exploit"},{"level":3,"text":"The Only Safe Approach: Canonicalize First, Check Second","id":"the-only-safe-approach-canonicalize-first-check-second"},{"level":2,"text":"Running realpath() on the document root at startup canonicalizes it once. If the document root contains a symlink (e.g., /var/www/html â†’ /data/www), canonical_root will contain /data/www â€” the true path. Every per-request check then compares against this true path.","id":"running-realpath-on-the-document-root-at-startup-canonicalizes-it-once-if-the-document-root-contains-a-symlink-eg-varwwwhtml-datawww-canonical_root-will-contain-datawww-the-true-path-every-per-request-check-then-compares-against-this-true-path"},{"level":2,"text":"Three-Level View: What Happens When You Open a File","id":"three-level-view-what-happens-when-you-open-a-file"},{"level":2,"text":"Level 1 â€” Your code:\nYou call resolve_safe_path(&quot;/images/photo.jpg&quot;, canonical_root, resolved), which calls realpath() and returns 0 with resolved = &quot;/var/www/html/images/photo.jpg&quot;. You call stat(resolved, &amp;st) to get the file size and modification time. You call open(resolved, O_RDONLY) to get a file descriptor. You call read(file_fd, buf, buf_size) in a loop to fill your buffer. You call write(client_fd, ...) to send the data. You call close(file_fd).\nLevel 2 â€” OS/Kernel:\nrealpath() is implemented in user-space (glibc) but calls multiple lstat() syscalls â€” one per path component â€” to check each component for symlinks. For /var/www/html/images/photo.jpg, that&#39;s approximately five lstat() calls.\nopen() triggers the kernel&#39;s VFS (Virtual File System) layer. The kernel looks up the file in the directory entry cache (dcache) â€” if /var/www/html/images has been recently accessed, the directory entry is already in kernel memory (hot). The kernel also checks the inode cache (icache): the inode stores the file&#39;s metadata (size, permissions, timestamps). On a busy server, both caches are hot and open() returns in microseconds without touching disk.\nread() triggers the kernel&#39;s page cache lookup. The page cache is a portion of RAM that holds recently-read disk blocks. If photo.jpg was read recently, its pages are in the page cache and read() is just a memcpy() from kernel memory to your user-space buffer. If the file is cold (not cached), the kernel issues disk I/O â€” an asynchronous read from the block device â€” and your process blocks until the data arrives.\nLevel 3 â€” Hardware:\nFor a cache-hot file: your read() triggers a context switch from user mode to kernel mode (the read syscall). The kernel finds the page cache entries for photo.jpg, copies them into your buffer via memory-to-memory copy. For a 100KB file, this is copying ~25 4KB pages. At memory bandwidth of ~20 GB/s (DDR4), 100KB copies in ~5 microseconds. Context switch overhead is ~1â€“2 microseconds. Total: ~7 microseconds for a cached read.\nFor a cold file: the kernel submits an I/O request to the storage controller. An NVMe SSD responds in ~100 microseconds; a spinning HDD in ~5 milliseconds. Your process is moved off the CPU runqueue into a &quot;waiting for I/O&quot; state. The CPU runs other processes. When the storage interrupt fires, the kernel moves your process back to runnable. This is the 10ms vs 100ns gap â€” 100,000Ã— difference between memory and disk â€” that the page cache exists to bridge.","id":"level-1-your-code-you-call-resolve_safe_pathquotimagesphotojpgquot-canonical_root-resolved-which-calls-realpath-and-returns-0-with-resolved-quotvarwwwhtmlimagesphotojpgquot-you-call-statresolved-ampst-to-get-the-file-size-and-modification-time-you-call-openresolved-o_rdonly-to-get-a-file-descriptor-you-call-readfile_fd-buf-buf_size-in-a-loop-to-fill-your-buffer-you-call-writeclient_fd-to-send-the-data-you-call-closefile_fd-level-2-oskernel-realpath-is-implemented-in-user-space-glibc-but-calls-multiple-lstat-syscalls-one-per-path-component-to-check-each-component-for-symlinks-for-varwwwhtmlimagesphotojpg-that39s-approximately-five-lstat-calls-open-triggers-the-kernel39s-vfs-virtual-file-system-layer-the-kernel-looks-up-the-file-in-the-directory-entry-cache-dcache-if-varwwwhtmlimages-has-been-recently-accessed-the-directory-entry-is-already-in-kernel-memory-hot-the-kernel-also-checks-the-inode-cache-icache-the-inode-stores-the-file39s-metadata-size-permissions-timestamps-on-a-busy-server-both-caches-are-hot-and-open-returns-in-microseconds-without-touching-disk-read-triggers-the-kernel39s-page-cache-lookup-the-page-cache-is-a-portion-of-ram-that-holds-recently-read-disk-blocks-if-photojpg-was-read-recently-its-pages-are-in-the-page-cache-and-read-is-just-a-memcpy-from-kernel-memory-to-your-user-space-buffer-if-the-file-is-cold-not-cached-the-kernel-issues-disk-io-an-asynchronous-read-from-the-block-device-and-your-process-blocks-until-the-data-arrives-level-3-hardware-for-a-cache-hot-file-your-read-triggers-a-context-switch-from-user-mode-to-kernel-mode-the-read-syscall-the-kernel-finds-the-page-cache-entries-for-photojpg-copies-them-into-your-buffer-via-memory-to-memory-copy-for-a-100kb-file-this-is-copying-25-4kb-pages-at-memory-bandwidth-of-20-gbs-ddr4-100kb-copies-in-5-microseconds-context-switch-overhead-is-12-microseconds-total-7-microseconds-for-a-cached-read-for-a-cold-file-the-kernel-submits-an-io-request-to-the-storage-controller-an-nvme-ssd-responds-in-100-microseconds-a-spinning-hdd-in-5-milliseconds-your-process-is-moved-off-the-cpu-runqueue-into-a-quotwaiting-for-ioquot-state-the-cpu-runs-other-processes-when-the-storage-interrupt-fires-the-kernel-moves-your-process-back-to-runnable-this-is-the-10ms-vs-100ns-gap-100000-difference-between-memory-and-disk-that-the-page-cache-exists-to-bridge"},{"level":2,"text":"MIME Types: Telling Browsers How to Interpret Bytes","id":"mime-types-telling-browsers-how-to-interpret-bytes"},{"level":2,"text":"strrchr() (string reverse character-find) finds the last occurrence of a character in a string. For a path like /var/www/html/styles/main.min.css, there are two dots. We want the last one to get .css, not .min. Using strrchr() instead of strchr() handles this correctly.\napplication/octet-stream is the correct MIME type for &quot;I don&#39;t know what this is.&quot; Browsers respond by presenting a download dialog, which is safer than trying to execute or display unknown binary content.","id":"strrchr-string-reverse-character-find-finds-the-last-occurrence-of-a-character-in-a-string-for-a-path-like-varwwwhtmlstylesmainmincss-there-are-two-dots-we-want-the-last-one-to-get-css-not-min-using-strrchr-instead-of-strchr-handles-this-correctly-applicationoctet-stream-is-the-correct-mime-type-for-quoti-don39t-know-what-this-isquot-browsers-respond-by-presenting-a-download-dialog-which-is-safer-than-trying-to-execute-or-display-unknown-binary-content"},{"level":2,"text":"Conditional Requests: If-Modified-Since and 304 Not Modified","id":"conditional-requests-if-modified-since-and-304-not-modified"},{"level":2,"text":"The &lt;= comparison handles the one-second granularity of HTTP-date format. If a file was modified at timestamp T, the server sends Last-Modified: &lt;T formatted to second precision&gt;. On the next request, the client sends If-Modified-Since: &lt;T&gt;. If you used &lt; instead of &lt;=, you&#39;d send a full 200 response for a file modified at exactly the cached timestamp â€” wasting bandwidth and incorrectly indicating the file changed.","id":"the-lt-comparison-handles-the-one-second-granularity-of-http-date-format-if-a-file-was-modified-at-timestamp-t-the-server-sends-last-modified-ltt-formatted-to-second-precisiongt-on-the-next-request-the-client-sends-if-modified-since-lttgt-if-you-used-lt-instead-of-lt-you39d-send-a-full-200-response-for-a-file-modified-at-exactly-the-cached-timestamp-wasting-bandwidth-and-incorrectly-indicating-the-file-changed"},{"level":2,"text":"Directory Requests and Index Files","id":"directory-requests-and-index-files"},{"level":2,"text":"S_ISDIR(st-&gt;st_mode) â€” the stat() syscall fills a struct stat with file metadata. The st_mode field is a bitmask encoding both the file type and permission bits. S_ISDIR() is a POSIX macro that extracts the file-type bits and checks if they indicate a directory. Similarly, S_ISREG() checks for regular files, S_ISLNK() for symbolic links (though stat() follows symlinks automatically â€” use lstat() to detect symlinks without following them).","id":"s_isdirst-gtst_mode-the-stat-syscall-fills-a-struct-stat-with-file-metadata-the-st_mode-field-is-a-bitmask-encoding-both-the-file-type-and-permission-bits-s_isdir-is-a-posix-macro-that-extracts-the-file-type-bits-and-checks-if-they-indicate-a-directory-similarly-s_isreg-checks-for-regular-files-s_islnk-for-symbolic-links-though-stat-follows-symlinks-automatically-use-lstat-to-detect-symlinks-without-following-them"},{"level":2,"text":"The Complete File Serving Function","id":"the-complete-file-serving-function"},{"level":3,"text":"The 64KB Buffer Choice","id":"the-64kb-buffer-choice"},{"level":2,"text":"TOCTOU: The Security Race You Can&#39;t Fully Win","id":"toctou-the-security-race-you-can39t-fully-win"},{"level":2,"text":"Hardware Soul: Cache Lines and File Transfer","id":"hardware-soul-cache-lines-and-file-transfer"},{"level":2,"text":"Integrating File Serving into the Accept Loop","id":"integrating-file-serving-into-the-accept-loop"},{"level":2,"text":"Pass canonical_root from your server initialization (where you called realpath() on the document root at startup) into every connection handler. In Milestone 4, this will move into a shared server configuration struct accessible to all worker threads.","id":"pass-canonical_root-from-your-server-initialization-where-you-called-realpath-on-the-document-root-at-startup-into-every-connection-handler-in-milestone-4-this-will-move-into-a-shared-server-configuration-struct-accessible-to-all-worker-threads"},{"level":2,"text":"Testing Static File Serving","id":"testing-static-file-serving"},{"level":3,"text":"Verifying Security Properties","id":"verifying-security-properties"},{"level":2,"text":"Design Decisions: Path Security Approaches","id":"design-decisions-path-security-approaches"},{"level":2,"text":"Knowledge Cascade: What This Unlocks","id":"knowledge-cascade-what-this-unlocks"},{"level":3,"text":"1. Defense in Depth â€” The Resolve-Then-Check Pattern Everywhere","id":"1-defense-in-depth-the-resolve-then-check-pattern-everywhere"},{"level":3,"text":"2. sendfile() and Zero-Copy I/O","id":"2-sendfile-and-zero-copy-io"},{"level":3,"text":"3. Browser Caching Architecture","id":"3-browser-caching-architecture"},{"level":3,"text":"4. MIME Types as Content Negotiation â€” The Simple Case of a Deep Concept","id":"4-mime-types-as-content-negotiation-the-simple-case-of-a-deep-concept"},{"level":3,"text":"5. stat() and the Unix Inode Model","id":"5-stat-and-the-unix-inode-model"},{"level":2,"text":"Common Mistakes That Will Burn You","id":"common-mistakes-that-will-burn-you"},{"level":2,"text":"1. Calling realpath() on the document root per request, not at startup.\nrealpath() on the document root doesn&#39;t change between requests (it&#39;s your configuration). Calling it per request adds 5â€“10 lstat() syscalls on every single request. Call it once at startup, store the result, pass it to every connection handler.\n2. Checking the prefix before calling realpath().\nThe entire point of realpath() is that the raw path string cannot be trusted. Any check before realpath() is checking attacker-controlled data and provides no security guarantee. Canonicalize first. Always.\n3. Text-mode reading for binary files.\nOn Linux, open() with O_RDONLY gives you raw bytes â€” there&#39;s no &quot;text mode&quot; vs &quot;binary mode&quot; distinction at the syscall level. However, if you ever use fopen() with &quot;r&quot; instead of &quot;rb&quot;, some platforms (Windows) translate \\r\\n sequences to \\n in text mode, corrupting binary files. Use open() + read() directly (as in the code above), or use fopen(..., &quot;rb&quot;) if you use stdio. Never use &quot;r&quot; for files that might be binary.\n4. Using st_mtime without understanding its granularity.\nOn some filesystems (FAT32, older HFS+), file modification times have 2-second or 1-second granularity. On ext4 and modern filesystems, st_mtim.tv_nsec gives nanosecond precision. But HTTP-date format only has 1-second resolution. When comparing st_mtime against an If-Modified-Since timestamp, use only the second-precision st_mtime (not st_mtim.tv_nsec), and use &lt;= comparison as shown above.\n5. Not closing file_fd on all error paths.\nEvery early return after file_fd = open(...) must include close(file_fd). Draw the control flow. If write_all() of the headers fails (client disconnected), you break out of the function â€” have you closed file_fd? Check every branch.\n6. Forgetting to handle the path prefix edge case.\nThe check strncmp(resolved, root, root_len) == 0 passes for both /var/www (the root itself) and /var/www-backup (a different directory). Always verify that the character at resolved[root_len] is either &#39;/&#39; or &#39;\\0&#39;.\n7. Using atoi() for Content-Length in Milestone 2 (carry-forward)\nYou already handle this, but if you missed it: atoi(&quot;-1&quot;) returns -1, and atoi(&quot;9999999999999&quot;) overflows silently on 32-bit int. strtol() with bounds checking is the only safe approach.","id":"1-calling-realpath-on-the-document-root-per-request-not-at-startup-realpath-on-the-document-root-doesn39t-change-between-requests-it39s-your-configuration-calling-it-per-request-adds-510-lstat-syscalls-on-every-single-request-call-it-once-at-startup-store-the-result-pass-it-to-every-connection-handler-2-checking-the-prefix-before-calling-realpath-the-entire-point-of-realpath-is-that-the-raw-path-string-cannot-be-trusted-any-check-before-realpath-is-checking-attacker-controlled-data-and-provides-no-security-guarantee-canonicalize-first-always-3-text-mode-reading-for-binary-files-on-linux-open-with-o_rdonly-gives-you-raw-bytes-there39s-no-quottext-modequot-vs-quotbinary-modequot-distinction-at-the-syscall-level-however-if-you-ever-use-fopen-with-quotrquot-instead-of-quotrbquot-some-platforms-windows-translate-rn-sequences-to-n-in-text-mode-corrupting-binary-files-use-open-read-directly-as-in-the-code-above-or-use-fopen-quotrbquot-if-you-use-stdio-never-use-quotrquot-for-files-that-might-be-binary-4-using-st_mtime-without-understanding-its-granularity-on-some-filesystems-fat32-older-hfs-file-modification-times-have-2-second-or-1-second-granularity-on-ext4-and-modern-filesystems-st_mtimtv_nsec-gives-nanosecond-precision-but-http-date-format-only-has-1-second-resolution-when-comparing-st_mtime-against-an-if-modified-since-timestamp-use-only-the-second-precision-st_mtime-not-st_mtimtv_nsec-and-use-lt-comparison-as-shown-above-5-not-closing-file_fd-on-all-error-paths-every-early-return-after-file_fd-open-must-include-closefile_fd-draw-the-control-flow-if-write_all-of-the-headers-fails-client-disconnected-you-break-out-of-the-function-have-you-closed-file_fd-check-every-branch-6-forgetting-to-handle-the-path-prefix-edge-case-the-check-strncmpresolved-root-root_len-0-passes-for-both-varwww-the-root-itself-and-varwww-backup-a-different-directory-always-verify-that-the-character-at-resolvedroot_len-is-either-3939-or-39039-7-using-atoi-for-content-length-in-milestone-2-carry-forward-you-already-handle-this-but-if-you-missed-it-atoiquot-1quot-returns-1-and-atoiquot9999999999999quot-overflows-silently-on-32-bit-int-strtol-with-bounds-checking-is-the-only-safe-approach"},{"level":2,"text":"Acceptance Criteria Checklist","id":"acceptance-criteria-checklist"},{"level":1,"text":"Milestone 4: Concurrent Connections","id":"milestone-4-concurrent-connections"},{"level":2,"text":"Where You Are in the System","id":"where-you-are-in-the-system"},{"level":2,"text":"Reality looks like this: a user opens a browser and loads a page with 20 assets (HTML, CSS, JavaScript files, images). The browser opens multiple connections simultaneously to fetch those assets in parallel. A second user hits the site at the same moment. Your sequential accept loop â€” which finishes one connection completely before calling accept() again â€” makes everyone wait in line. The second user&#39;s browser times out before it gets a response. Your server, from the outside, appears broken.\nThis milestone fixes that by introducing concurrency: the ability to handle multiple connections at the same time. You will build two models â€” thread-per-connection first (simple, reveals the problem) and then a bounded thread pool (the real solution) â€” and layer on top the three features that make concurrent connection management work in production: HTTP/1.1 keep-alive, per-connection idle timeouts, and graceful shutdown.","id":"reality-looks-like-this-a-user-opens-a-browser-and-loads-a-page-with-20-assets-html-css-javascript-files-images-the-browser-opens-multiple-connections-simultaneously-to-fetch-those-assets-in-parallel-a-second-user-hits-the-site-at-the-same-moment-your-sequential-accept-loop-which-finishes-one-connection-completely-before-calling-accept-again-makes-everyone-wait-in-line-the-second-user39s-browser-times-out-before-it-gets-a-response-your-server-from-the-outside-appears-broken-this-milestone-fixes-that-by-introducing-concurrency-the-ability-to-handle-multiple-connections-at-the-same-time-you-will-build-two-models-thread-per-connection-first-simple-reveals-the-problem-and-then-a-bounded-thread-pool-the-real-solution-and-layer-on-top-the-three-features-that-make-concurrent-connection-management-work-in-production-http11-keep-alive-per-connection-idle-timeouts-and-graceful-shutdown"},{"level":2,"text":"The Revelation: &quot;Just Spawn a Thread&quot; Is Not a Solution","id":"the-revelation-quotjust-spawn-a-threadquot-is-not-a-solution"},{"level":2,"text":"The resource exhaustion is not hypothetical. It&#39;s the exact failure mode that took down Apache web servers in 2009 before patches were deployed. Apache&#39;s default model was thread-per-connection (actually process-per-connection, which is worse). Slowloris exploited the OS limit on concurrent processes, not the attack&#39;s bandwidth requirements. The attacking machine needed almost no resources; the defending server was overwhelmed.\nThe insight: thread creation is not free, and thread count must be bounded.\nA bounded thread pool eliminates this entire attack surface. If your pool has 16 threads, the 17th connection waits in a queue. Queued connections consume no threads, no kernel task_structs, no 8MB stacks. The 10,000th Slowloris connection just adds to the queue (which you can also bound â€” more on that shortly). Your server continues serving legitimate requests normally.\nBut there is a second revelation hiding inside the first. Even with a bounded pool, keep-alive connections without idle timeouts create a slow leak. If your 16 threads are all handling keep-alive connections from browsers that opened them 10 minutes ago and haven&#39;t sent a second request, all 16 threads are blocked in read(). New legitimate connections sit in the queue forever. The pool is full of zombie connections â€” technically alive, sending no data, consuming a thread each.\nThe complete solution requires three interlocking pieces: a bounded thread pool, per-connection idle timeouts, and a keep-alive loop that correctly reuses connections when appropriate and closes them when not.","id":"the-resource-exhaustion-is-not-hypothetical-it39s-the-exact-failure-mode-that-took-down-apache-web-servers-in-2009-before-patches-were-deployed-apache39s-default-model-was-thread-per-connection-actually-process-per-connection-which-is-worse-slowloris-exploited-the-os-limit-on-concurrent-processes-not-the-attack39s-bandwidth-requirements-the-attacking-machine-needed-almost-no-resources-the-defending-server-was-overwhelmed-the-insight-thread-creation-is-not-free-and-thread-count-must-be-bounded-a-bounded-thread-pool-eliminates-this-entire-attack-surface-if-your-pool-has-16-threads-the-17th-connection-waits-in-a-queue-queued-connections-consume-no-threads-no-kernel-task_structs-no-8mb-stacks-the-10000th-slowloris-connection-just-adds-to-the-queue-which-you-can-also-bound-more-on-that-shortly-your-server-continues-serving-legitimate-requests-normally-but-there-is-a-second-revelation-hiding-inside-the-first-even-with-a-bounded-pool-keep-alive-connections-without-idle-timeouts-create-a-slow-leak-if-your-16-threads-are-all-handling-keep-alive-connections-from-browsers-that-opened-them-10-minutes-ago-and-haven39t-sent-a-second-request-all-16-threads-are-blocked-in-read-new-legitimate-connections-sit-in-the-queue-forever-the-pool-is-full-of-zombie-connections-technically-alive-sending-no-data-consuming-a-thread-each-the-complete-solution-requires-three-interlocking-pieces-a-bounded-thread-pool-per-connection-idle-timeouts-and-a-keep-alive-loop-that-correctly-reuses-connections-when-appropriate-and-closes-them-when-not"},{"level":2,"text":"POSIX Threads: The API You Will Use","id":"posix-threads-the-api-you-will-use"},{"level":2,"text":"You must either join or detach every thread. A thread that is neither joined nor detached is a resource leak â€” its kernel task_struct remains allocated until the process exits.","id":"you-must-either-join-or-detach-every-thread-a-thread-that-is-neither-joined-nor-detached-is-a-resource-leak-its-kernel-task_struct-remains-allocated-until-the-process-exits"},{"level":2,"text":"The Thread Pool Architecture","id":"the-thread-pool-architecture"},{"level":3,"text":"Memory Layout","id":"memory-layout"},{"level":3,"text":"Initialization","id":"initialization"},{"level":3,"text":"The Worker Thread Loop","id":"the-worker-thread-loop"},{"level":3,"text":"Enqueue: Submitting Work","id":"enqueue-submitting-work"},{"level":2,"text":"HTTP/1.1 Keep-Alive: The Connection Reuse Loop","id":"http11-keep-alive-the-connection-reuse-loop"},{"level":3,"text":"Why Break After Non-200 Responses?","id":"why-break-after-non-200-responses"},{"level":2,"text":"Notice the break after sending a 501 response. This is deliberate. If a client sends a malformed or unsupported request and receives a 4xx or 5xx response, the right behavior is usually to close the connection. The client clearly has a problem â€” letting it keep the connection alive and send more broken requests wastes server resources and potentially enables abuse. The exceptions are 404 and 304, where the client is well-behaved but just requesting something that doesn&#39;t exist or hasn&#39;t changed. For those, keep-alive is fine.","id":"notice-the-break-after-sending-a-501-response-this-is-deliberate-if-a-client-sends-a-malformed-or-unsupported-request-and-receives-a-4xx-or-5xx-response-the-right-behavior-is-usually-to-close-the-connection-the-client-clearly-has-a-problem-letting-it-keep-the-connection-alive-and-send-more-broken-requests-wastes-server-resources-and-potentially-enables-abuse-the-exceptions-are-404-and-304-where-the-client-is-well-behaved-but-just-requesting-something-that-doesn39t-exist-or-hasn39t-changed-for-those-keep-alive-is-fine"},{"level":2,"text":"Signal Handling in Multi-Threaded Programs","id":"signal-handling-in-multi-threaded-programs"},{"level":2,"text":"sigwait() is safe to call from a regular thread context â€” no async-signal-safety concerns, no restriction on what you can do before or after it. The signal is consumed by sigwait() and delivered synchronously to this thread. No other thread is interrupted.","id":"sigwait-is-safe-to-call-from-a-regular-thread-context-no-async-signal-safety-concerns-no-restriction-on-what-you-can-do-before-or-after-it-the-signal-is-consumed-by-sigwait-and-delivered-synchronously-to-this-thread-no-other-thread-is-interrupted"},{"level":2,"text":"Graceful Shutdown: The Four-Phase Dance","id":"graceful-shutdown-the-four-phase-dance"},{"level":3,"text":"The Accept Loop with Shutdown Awareness","id":"the-accept-loop-with-shutdown-awareness"},{"level":2,"text":"The EMFILE case â€” errno = EMFILE means &quot;too many open files&quot; (the process hit its file descriptor limit) â€” is important and often missed. When this happens, accept() fails, but the OS has already completed the TCP handshake for the waiting client. Repeatedly calling accept() to get this error doesn&#39;t drain the accept queue â€” the client remains waiting. The usleep(100000) back-off gives the server a moment to close other file descriptors (connections finishing in the worker pool) before trying again.","id":"the-emfile-case-errno-emfile-means-quottoo-many-open-filesquot-the-process-hit-its-file-descriptor-limit-is-important-and-often-missed-when-this-happens-accept-fails-but-the-os-has-already-completed-the-tcp-handshake-for-the-waiting-client-repeatedly-calling-accept-to-get-this-error-doesn39t-drain-the-accept-queue-the-client-remains-waiting-the-usleep100000-back-off-gives-the-server-a-moment-to-close-other-file-descriptors-connections-finishing-in-the-worker-pool-before-trying-again"},{"level":2,"text":"Shared State and Mutex Protection","id":"shared-state-and-mutex-protection"},{"level":2,"text":"Without the log_mutex, two threads writing to stdout simultaneously produce interleaved garbage â€” half of thread A&#39;s line, half of thread B&#39;s, all on the same output line. This looks harmless but signals sloppy concurrency discipline. If the log is wrong, you can&#39;t trust your own server&#39;s behavior reports.","id":"without-the-log_mutex-two-threads-writing-to-stdout-simultaneously-produce-interleaved-garbage-half-of-thread-a39s-line-half-of-thread-b39s-all-on-the-same-output-line-this-looks-harmless-but-signals-sloppy-concurrency-discipline-if-the-log-is-wrong-you-can39t-trust-your-own-server39s-behavior-reports"},{"level":2,"text":"Pool Sizing: The Math That Governs Everything","id":"pool-sizing-the-math-that-governs-everything"},{"level":2,"text":"FD Leak Detection Under Load","id":"fd-leak-detection-under-load"},{"level":2,"text":"Complete Main: Wiring It All Together","id":"complete-main-wiring-it-all-together"},{"level":3,"text":"Compiling the Multi-Threaded Server","id":"compiling-the-multi-threaded-server"},{"level":2,"text":"Three-Level View: A Request Under Concurrency","id":"three-level-view-a-request-under-concurrency"},{"level":2,"text":"Take a GET request that arrives while 5 other requests are in flight and trace it through all three levels.\nLevel 1 â€” Your code:\nThe main thread&#39;s accept_loop() calls accept() and gets client_fd = 12. It calls thread_pool_submit(&amp;pool, 12), which acquires the pool mutex, adds fd 12 to the circular queue, increments queue_size, and signals not_empty. Worker thread 3 (which was sleeping in pthread_cond_wait()) wakes up, dequeues client_fd = 12, increments active_connections, releases the lock, and calls handle_connection(12, &amp;pool). Meanwhile, the main thread is already back in accept(), accepting the next connection.\nLevel 2 â€” OS/Kernel:\npthread_cond_signal() doesn&#39;t run the sleeping thread immediately â€” it marks thread 3 as runnable and adds it to the kernel scheduler&#39;s run queue. The kernel&#39;s scheduler will run it when it gets a CPU timeslice (typically within ~1ms on a lightly loaded system, or immediately if a CPU is idle). The two threads â€” main thread in accept() and worker 3 in handle_connection() â€” run on separate CPU cores simultaneously: true parallelism on a multi-core machine.\nWhen worker 3 calls read(client_fd, ...), the kernel checks the socket&#39;s receive buffer. If the HTTP request data is already there (common for localhost), it copies it to user space immediately. If not, the kernel moves thread 3 to the &quot;waiting for I/O&quot; state and puts another runnable thread on that CPU core. Zero CPU cycles wasted while waiting for network data.\nLevel 3 â€” Hardware:\npthread_mutex_lock() compiles to a LOCK CMPXCHG instruction (on x86) or LDXR/STXR (on ARM). These are atomic compare-and-swap instructions â€” hardware-enforced operations that compare and modify memory in a single, uninterruptible cycle. The CPU&#39;s cache coherence protocol (MESI) ensures that all cores see the same value for the mutex: when core 1 acquires the mutex (sets it from 0 to 1 with CMPXCHG), the cache coherence protocol invalidates the L1/L2 cache lines holding the mutex on all other cores, forcing them to reload from L3 or main memory. This cross-core coordination costs ~40â€“100 clock cycles (20â€“50ns at 2GHz) â€” the true cost of one mutex lock/unlock cycle.\nThis is why the law &quot;hold the lock only as long as necessary&quot; matters at the hardware level: every cycle you hold the mutex is a cycle another core spends stalled waiting for the cache line.","id":"take-a-get-request-that-arrives-while-5-other-requests-are-in-flight-and-trace-it-through-all-three-levels-level-1-your-code-the-main-thread39s-accept_loop-calls-accept-and-gets-client_fd-12-it-calls-thread_pool_submitamppool-12-which-acquires-the-pool-mutex-adds-fd-12-to-the-circular-queue-increments-queue_size-and-signals-not_empty-worker-thread-3-which-was-sleeping-in-pthread_cond_wait-wakes-up-dequeues-client_fd-12-increments-active_connections-releases-the-lock-and-calls-handle_connection12-amppool-meanwhile-the-main-thread-is-already-back-in-accept-accepting-the-next-connection-level-2-oskernel-pthread_cond_signal-doesn39t-run-the-sleeping-thread-immediately-it-marks-thread-3-as-runnable-and-adds-it-to-the-kernel-scheduler39s-run-queue-the-kernel39s-scheduler-will-run-it-when-it-gets-a-cpu-timeslice-typically-within-1ms-on-a-lightly-loaded-system-or-immediately-if-a-cpu-is-idle-the-two-threads-main-thread-in-accept-and-worker-3-in-handle_connection-run-on-separate-cpu-cores-simultaneously-true-parallelism-on-a-multi-core-machine-when-worker-3-calls-readclient_fd-the-kernel-checks-the-socket39s-receive-buffer-if-the-http-request-data-is-already-there-common-for-localhost-it-copies-it-to-user-space-immediately-if-not-the-kernel-moves-thread-3-to-the-quotwaiting-for-ioquot-state-and-puts-another-runnable-thread-on-that-cpu-core-zero-cpu-cycles-wasted-while-waiting-for-network-data-level-3-hardware-pthread_mutex_lock-compiles-to-a-lock-cmpxchg-instruction-on-x86-or-ldxrstxr-on-arm-these-are-atomic-compare-and-swap-instructions-hardware-enforced-operations-that-compare-and-modify-memory-in-a-single-uninterruptible-cycle-the-cpu39s-cache-coherence-protocol-mesi-ensures-that-all-cores-see-the-same-value-for-the-mutex-when-core-1-acquires-the-mutex-sets-it-from-0-to-1-with-cmpxchg-the-cache-coherence-protocol-invalidates-the-l1l2-cache-lines-holding-the-mutex-on-all-other-cores-forcing-them-to-reload-from-l3-or-main-memory-this-cross-core-coordination-costs-40100-clock-cycles-2050ns-at-2ghz-the-true-cost-of-one-mutex-lockunlock-cycle-this-is-why-the-law-quothold-the-lock-only-as-long-as-necessaryquot-matters-at-the-hardware-level-every-cycle-you-hold-the-mutex-is-a-cycle-another-core-spends-stalled-waiting-for-the-cache-line"},{"level":2,"text":"Hardware Soul: Concurrency Costs","id":"hardware-soul-concurrency-costs"},{"level":2,"text":"Thread creation overhead. pthread_create() involves a system call (clone() on Linux) that creates a new kernel task_struct, allocates a kernel stack (8KB), and maps the user-space stack (8MB virtual, but initially only one 4KB page is actually mapped â€” the rest page-faults in as needed). Total cost: ~10â€“50Âµs. The thread pool amortizes this by creating threads at startup, not per-request.\nContext switch cost. When the scheduler switches between threads â€” which happens every ~1â€“4ms on a standard Linux configuration (CONFIG_HZ = 250 or 1000) â€” it must save all CPU registers (16 general-purpose registers, SSE/AVX state, etc.) for the outgoing thread and restore them for the incoming thread. On x86-64, this is ~80 cache lines of state. Cost: ~1â€“5Âµs per context switch. With 16 threads, context switching is infrequent and well within budget. With 1000 threads, it becomes the dominant cost.\nFalse sharing. The pool-&gt;active_connections and pool-&gt;total_requests counters are adjacent in memory, likely sharing a 64-byte cache line. When worker thread A increments active_connections and worker thread B increments total_requests simultaneously â€” both cache lines get invalidated on both cores even though they&#39;re touching different variables. This false sharing causes unnecessary cache coherence traffic. Production thread pools (Go&#39;s runtime, jemalloc&#39;s arena structure) use __attribute__((aligned(64))) or padding to place each frequently-written field on its own cache line. For this server at 16 threads, it&#39;s not a measurable issue â€” but understanding it prepares you for high-performance work.\nSocket option SO_RCVTIMEO â€” the implementation. Setting SO_RCVTIMEO stores a struct timeval in the socket&#39;s kernel data structure. When read() is called on the socket, the kernel&#39;s net/socket layer starts a timer. If data doesn&#39;t arrive within the timeout, the timer fires (via the kernel&#39;s timer interrupt) and wakes the blocked thread with EAGAIN. The cost is zero unless the timeout actually fires â€” it&#39;s a passive kernel structure, not a polling loop.","id":"thread-creation-overhead-pthread_create-involves-a-system-call-clone-on-linux-that-creates-a-new-kernel-task_struct-allocates-a-kernel-stack-8kb-and-maps-the-user-space-stack-8mb-virtual-but-initially-only-one-4kb-page-is-actually-mapped-the-rest-page-faults-in-as-needed-total-cost-1050s-the-thread-pool-amortizes-this-by-creating-threads-at-startup-not-per-request-context-switch-cost-when-the-scheduler-switches-between-threads-which-happens-every-14ms-on-a-standard-linux-configuration-config_hz-250-or-1000-it-must-save-all-cpu-registers-16-general-purpose-registers-sseavx-state-etc-for-the-outgoing-thread-and-restore-them-for-the-incoming-thread-on-x86-64-this-is-80-cache-lines-of-state-cost-15s-per-context-switch-with-16-threads-context-switching-is-infrequent-and-well-within-budget-with-1000-threads-it-becomes-the-dominant-cost-false-sharing-the-pool-gtactive_connections-and-pool-gttotal_requests-counters-are-adjacent-in-memory-likely-sharing-a-64-byte-cache-line-when-worker-thread-a-increments-active_connections-and-worker-thread-b-increments-total_requests-simultaneously-both-cache-lines-get-invalidated-on-both-cores-even-though-they39re-touching-different-variables-this-false-sharing-causes-unnecessary-cache-coherence-traffic-production-thread-pools-go39s-runtime-jemalloc39s-arena-structure-use-__attribute__aligned64-or-padding-to-place-each-frequently-written-field-on-its-own-cache-line-for-this-server-at-16-threads-it39s-not-a-measurable-issue-but-understanding-it-prepares-you-for-high-performance-work-socket-option-so_rcvtimeo-the-implementation-setting-so_rcvtimeo-stores-a-struct-timeval-in-the-socket39s-kernel-data-structure-when-read-is-called-on-the-socket-the-kernel39s-netsocket-layer-starts-a-timer-if-data-doesn39t-arrive-within-the-timeout-the-timer-fires-via-the-kernel39s-timer-interrupt-and-wakes-the-blocked-thread-with-eagain-the-cost-is-zero-unless-the-timeout-actually-fires-it39s-a-passive-kernel-structure-not-a-polling-loop"},{"level":2,"text":"Design Decisions: Concurrency Models","id":"design-decisions-concurrency-models"},{"level":2,"text":"Testing Concurrent Behavior","id":"testing-concurrent-behavior"},{"level":2,"text":"The Thread Sanitizer (-fsanitize=thread) is a compiler-level instrumentation tool that detects data races at runtime. It instruments every memory access and records which thread last wrote each memory location. When two threads access the same memory without synchronization, it reports the race with a complete stack trace showing both threads. Running the TSan build under load is the definitive check that your mutex discipline is correct.","id":"the-thread-sanitizer-fsanitizethread-is-a-compiler-level-instrumentation-tool-that-detects-data-races-at-runtime-it-instruments-every-memory-access-and-records-which-thread-last-wrote-each-memory-location-when-two-threads-access-the-same-memory-without-synchronization-it-reports-the-race-with-a-complete-stack-trace-showing-both-threads-running-the-tsan-build-under-load-is-the-definitive-check-that-your-mutex-discipline-is-correct"},{"level":2,"text":"Knowledge Cascade: What This Unlocks","id":"knowledge-cascade-what-this-unlocks"},{"level":3,"text":"1. Connection Pool Sizing â€” The Universal Pattern","id":"1-connection-pool-sizing-the-universal-pattern"},{"level":3,"text":"2. Why nginx Uses Event Loops Instead of Thread Pools","id":"2-why-nginx-uses-event-loops-instead-of-thread-pools"},{"level":3,"text":"3. Lock Granularity â€” Why Databases Use Row Locks, Not Table Locks","id":"3-lock-granularity-why-databases-use-row-locks-not-table-locks"},{"level":3,"text":"4. Graceful Shutdown as a Distributed Systems Primitive","id":"4-graceful-shutdown-as-a-distributed-systems-primitive"},{"level":3,"text":"5. The C10K/C10M Problem and the async/await Revolution","id":"5-the-c10kc10m-problem-and-the-asyncawait-revolution"},{"level":2,"text":"Dan Kegel&#39;s 1999 &quot;C10K Problem&quot; paper described the failure mode you just implemented a defense against: a server that spawns one thread or process per connection breaks at roughly 10,000 concurrent connections on typical hardware. The paper asked: can we handle 10,000 connections simultaneously on a single machine? \nThe answer required rethinking the programming model. epoll (2002), kqueue (BSD, 2000), IOCP (Windows NT 3.5) all emerged as kernel interfaces that let a single thread efficiently monitor thousands of connections. But writing epoll-based code in C is famously difficult â€” you manage connection state explicitly across non-blocking callbacks, fighting what&#39;s called &quot;callback hell.&quot;\nThe solution to callback hell is async/await â€” syntactic sugar that makes non-blocking I/O look like sequential code. Python&#39;s asyncio, JavaScript&#39;s Promise/async, Rust&#39;s tokio, Go&#39;s goroutines (which hide the event loop behind a scheduler that looks like threads) â€” all of them are the language ecosystem&#39;s answer to &quot;how do we get the performance of epoll without the programmer experience of raw epoll?&quot;\nUnderstanding why your thread pool hits a wall at scale â€” and why the alternative (one thread watching thousands of fds via epoll) is both faster and harder to code â€” is the historical context that makes async/await meaningful. You haven&#39;t just built a thread pool: you&#39;ve built the exact system that motivated the most significant paradigm shift in server-side programming of the past 25 years.","id":"dan-kegel39s-1999-quotc10k-problemquot-paper-described-the-failure-mode-you-just-implemented-a-defense-against-a-server-that-spawns-one-thread-or-process-per-connection-breaks-at-roughly-10000-concurrent-connections-on-typical-hardware-the-paper-asked-can-we-handle-10000-connections-simultaneously-on-a-single-machine-the-answer-required-rethinking-the-programming-model-epoll-2002-kqueue-bsd-2000-iocp-windows-nt-35-all-emerged-as-kernel-interfaces-that-let-a-single-thread-efficiently-monitor-thousands-of-connections-but-writing-epoll-based-code-in-c-is-famously-difficult-you-manage-connection-state-explicitly-across-non-blocking-callbacks-fighting-what39s-called-quotcallback-hellquot-the-solution-to-callback-hell-is-asyncawait-syntactic-sugar-that-makes-non-blocking-io-look-like-sequential-code-python39s-asyncio-javascript39s-promiseasync-rust39s-tokio-go39s-goroutines-which-hide-the-event-loop-behind-a-scheduler-that-looks-like-threads-all-of-them-are-the-language-ecosystem39s-answer-to-quothow-do-we-get-the-performance-of-epoll-without-the-programmer-experience-of-raw-epollquot-understanding-why-your-thread-pool-hits-a-wall-at-scale-and-why-the-alternative-one-thread-watching-thousands-of-fds-via-epoll-is-both-faster-and-harder-to-code-is-the-historical-context-that-makes-asyncawait-meaningful-you-haven39t-just-built-a-thread-pool-you39ve-built-the-exact-system-that-motivated-the-most-significant-paradigm-shift-in-server-side-programming-of-the-past-25-years"},{"level":2,"text":"Common Mistakes That Will Burn You","id":"common-mistakes-that-will-burn-you"},{"level":2,"text":"POSIX permits spurious wakeups from pthread_cond_wait(). A thread can return from the wait even if no signal was sent. Always re-check the condition in a while loop.\n6. Not setting SO_RCVTIMEO before the keep-alive loop.\nIf you set the timeout option inside the loop on each iteration, you incur an extra syscall per request. Set it once per connection, before the for(;;) loop. The timeout applies to all subsequent reads on that socket.\n7. Not sending 503 when the pool queue is full â€” just closing the FD.\nSilently closing a TCP connection (without sending an HTTP response) leaves the client hanging, waiting for data that never arrives. The client&#39;s browser shows a &quot;connection reset&quot; error with no explanation. Sending a 503 response takes milliseconds and gives the client actionable information (&quot;server busy, try later&quot;). Always send a response before closing.","id":"posix-permits-spurious-wakeups-from-pthread_cond_wait-a-thread-can-return-from-the-wait-even-if-no-signal-was-sent-always-re-check-the-condition-in-a-while-loop-6-not-setting-so_rcvtimeo-before-the-keep-alive-loop-if-you-set-the-timeout-option-inside-the-loop-on-each-iteration-you-incur-an-extra-syscall-per-request-set-it-once-per-connection-before-the-for-loop-the-timeout-applies-to-all-subsequent-reads-on-that-socket-7-not-sending-503-when-the-pool-queue-is-full-just-closing-the-fd-silently-closing-a-tcp-connection-without-sending-an-http-response-leaves-the-client-hanging-waiting-for-data-that-never-arrives-the-client39s-browser-shows-a-quotconnection-resetquot-error-with-no-explanation-sending-a-503-response-takes-milliseconds-and-gives-the-client-actionable-information-quotserver-busy-try-laterquot-always-send-a-response-before-closing"},{"level":2,"text":"Acceptance Criteria Checklist","id":"acceptance-criteria-checklist"},{"level":1,"text":"TDD","id":"tdd"},{"level":1,"text":"MODULE SPECIFICATION: TCP Server &amp; HTTP Response (http-server-basic-m1)","id":"module-specification-tcp-server-amp-http-response-http-server-basic-m1"},{"level":2,"text":"1. Module Charter","id":"1-module-charter"},{"level":2,"text":"2. File Structure","id":"2-file-structure"},{"level":2,"text":"3. Complete Data Model","id":"3-complete-data-model"},{"level":3,"text":"3.1 Server Configuration Struct","id":"31-server-configuration-struct"},{"level":3,"text":"3.2 Constants","id":"32-constants"},{"level":2,"text":"4. Interface Contracts","id":"4-interface-contracts"},{"level":3,"text":"4.1 ssize_t read_http_request(int client_fd, char *buf, size_t buf_size, int *header_end)","id":"41-ssize_t-read_http_requestint-client_fd-char-buf-size_t-buf_size-int-header_end"},{"level":3,"text":"4.2 int write_all(int fd, const char *buf, size_t len)","id":"42-int-write_allint-fd-const-char-buf-size_t-len"},{"level":3,"text":"4.3 int build_hardcoded_response(char *buf, size_t buf_size)","id":"43-int-build_hardcoded_responsechar-buf-size_t-buf_size"},{"level":2,"text":"5. Algorithm Specification","id":"5-algorithm-specification"},{"level":3,"text":"5.1 The Socket Dance (Phase 1-2)","id":"51-the-socket-dance-phase-1-2"},{"level":3,"text":"5.2 The Accumulation Loop (Phase 3)","id":"52-the-accumulation-loop-phase-3"},{"level":3,"text":"5.3 The Sequential Accept Loop","id":"53-the-sequential-accept-loop"},{"level":2,"text":"6. Error Handling Matrix","id":"6-error-handling-matrix"},{"level":2,"text":"7. Implementation Sequence with Checkpoints","id":"7-implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Socket Setup (1 hour)","id":"phase-1-socket-setup-1-hour"},{"level":3,"text":"Phase 2: Accept Loop &amp; Logging (0.5 hours)","id":"phase-2-accept-loop-amp-logging-05-hours"},{"level":3,"text":"Phase 3: The Accumulator (1 hour)","id":"phase-3-the-accumulator-1-hour"},{"level":3,"text":"Phase 4: Response &amp; write_all (1 hour)","id":"phase-4-response-amp-write_all-1-hour"},{"level":2,"text":"8. Test Specification","id":"8-test-specification"},{"level":3,"text":"8.1 Happy Path: curl","id":"81-happy-path-curl"},{"level":3,"text":"8.2 Failure: Delimiter Search","id":"82-failure-delimiter-search"},{"level":3,"text":"8.3 Resource Leak Test","id":"83-resource-leak-test"},{"level":2,"text":"9. Performance Targets","id":"9-performance-targets"},{"level":2,"text":"10. Hardware Soul &amp; Memory Layout","id":"10-hardware-soul-amp-memory-layout"},{"level":3,"text":"Cache Line Optimization","id":"cache-line-optimization"},{"level":3,"text":"Memory Layout Table","id":"memory-layout-table"},{"level":2,"text":"11. Concurrency Specification: The Barrier","id":"11-concurrency-specification-the-barrier"},{"level":1,"text":"MODULE SPECIFICATION: HTTP Request Parsing (http-server-basic-m2)","id":"module-specification-http-request-parsing-http-server-basic-m2"},{"level":2,"text":"1. Module Charter","id":"1-module-charter"},{"level":2,"text":"2. File Structure","id":"2-file-structure"},{"level":2,"text":"3. Complete Data Model","id":"3-complete-data-model"},{"level":3,"text":"3.1 Enumerations","id":"31-enumerations"},{"level":3,"text":"3.2 Header Entry Struct","id":"32-header-entry-struct"},{"level":3,"text":"3.3 The HTTP Request Struct (http_request_t)","id":"33-the-http-request-struct-http_request_t"},{"level":2,"text":"4. Interface Contracts","id":"4-interface-contracts"},{"level":3,"text":"4.1 int parse_http_request(const char *buf, size_t buf_len, int header_end, http_request_t *req)","id":"41-int-parse_http_requestconst-char-buf-size_t-buf_len-int-header_end-http_request_t-req"},{"level":3,"text":"4.2 const char* request_get_header(const http_request_t *req, const char *name)","id":"42-const-char-request_get_headerconst-http_request_t-req-const-char-name"},{"level":3,"text":"4.3 void send_error_response(int client_fd, int status, const char *reason, const char *body)","id":"43-void-send_error_responseint-client_fd-int-status-const-char-reason-const-char-body"},{"level":2,"text":"5. Algorithm Specification","id":"5-algorithm-specification"},{"level":3,"text":"5.1 Request Line Parsing (parse_request_line)","id":"51-request-line-parsing-parse_request_line"},{"level":3,"text":"5.2 Header Normalization and Storage (parse_header_line)","id":"52-header-normalization-and-storage-parse_header_line"},{"level":3,"text":"5.3 Semantic Extraction (extract_semantic_headers)","id":"53-semantic-extraction-extract_semantic_headers"},{"level":2,"text":"6. Error Handling Matrix","id":"6-error-handling-matrix"},{"level":2,"text":"7. Implementation Sequence with Checkpoints","id":"7-implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Structs &amp; Constants (0.5 hours)","id":"phase-1-structs-amp-constants-05-hours"},{"level":3,"text":"Phase 2: String Helpers (1 hour)","id":"phase-2-string-helpers-1-hour"},{"level":3,"text":"Phase 3: The Parser (2 hours)","id":"phase-3-the-parser-2-hours"},{"level":3,"text":"Phase 4: Error Dispatch (1 hour)","id":"phase-4-error-dispatch-1-hour"},{"level":2,"text":"8. Test Specification","id":"8-test-specification"},{"level":3,"text":"8.1 Happy Path: Header Normalization","id":"81-happy-path-header-normalization"},{"level":3,"text":"8.2 Edge Case: Bare LF","id":"82-edge-case-bare-lf"},{"level":3,"text":"8.3 Attack: URI Too Long","id":"83-attack-uri-too-long"},{"level":3,"text":"8.4 Attack: Null Byte Injection","id":"84-attack-null-byte-injection"},{"level":2,"text":"9. Performance Targets","id":"9-performance-targets"},{"level":2,"text":"10. Hardware Soul: Cache and Pipeline","id":"10-hardware-soul-cache-and-pipeline"},{"level":3,"text":"10.1 Cache Locality","id":"101-cache-locality"},{"level":3,"text":"10.2 Branch Prediction","id":"102-branch-prediction"},{"level":2,"text":"11. State Machine Specification","id":"11-state-machine-specification"},{"level":2,"text":"12. Implementation Path (C Details)","id":"12-implementation-path-c-details"},{"level":1,"text":"MODULE SPECIFICATION: Static File Serving (http-server-basic-m3)","id":"module-specification-static-file-serving-http-server-basic-m3"},{"level":2,"text":"1. Module Charter","id":"1-module-charter"},{"level":2,"text":"2. File Structure","id":"2-file-structure"},{"level":2,"text":"3. Complete Data Model","id":"3-complete-data-model"},{"level":3,"text":"3.1 MIME Entry Struct","id":"31-mime-entry-struct"},{"level":3,"text":"3.2 Internal Constants","id":"32-internal-constants"},{"level":2,"text":"4. Interface Contracts","id":"4-interface-contracts"},{"level":3,"text":"4.1 int url_decode(const char *src, char *out, size_t out_size)","id":"41-int-url_decodeconst-char-src-char-out-size_t-out_size"},{"level":3,"text":"4.2 int resolve_safe_path(const char *url_path, const char *canonical_root, char *resolved_out)","id":"42-int-resolve_safe_pathconst-char-url_path-const-char-canonical_root-char-resolved_out"},{"level":3,"text":"4.3 void serve_static_file(const http_request_t *req, int client_fd, const char *canonical_root)","id":"43-void-serve_static_fileconst-http_request_t-req-int-client_fd-const-char-canonical_root"},{"level":2,"text":"5. Algorithm Specification","id":"5-algorithm-specification"},{"level":3,"text":"5.1 The Resolve-Then-Check Algorithm","id":"51-the-resolve-then-check-algorithm"},{"level":3,"text":"5.2 Directory Index Logic (handle_directory_path)","id":"52-directory-index-logic-handle_directory_path"},{"level":3,"text":"5.3 64KB I/O Stream Loop","id":"53-64kb-io-stream-loop"},{"level":2,"text":"6. Error Handling Matrix","id":"6-error-handling-matrix"},{"level":2,"text":"7. Implementation Sequence with Checkpoints","id":"7-implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: URL &amp; Path Security (1.5 hours)","id":"phase-1-url-amp-path-security-15-hours"},{"level":3,"text":"Phase 2: Metadata &amp; MIME (1 hour)","id":"phase-2-metadata-amp-mime-1-hour"},{"level":3,"text":"Phase 3: Conditional GETs (1.5 hours)","id":"phase-3-conditional-gets-15-hours"},{"level":3,"text":"Phase 4: The Orchestrator (2 hours)","id":"phase-4-the-orchestrator-2-hours"},{"level":2,"text":"8. Test Specification","id":"8-test-specification"},{"level":3,"text":"8.1 Security: Traversal Prevention","id":"81-security-traversal-prevention"},{"level":3,"text":"8.2 Logic: Directory Indexing","id":"82-logic-directory-indexing"},{"level":3,"text":"8.3 Efficiency: 64KB Alignment","id":"83-efficiency-64kb-alignment"},{"level":2,"text":"9. Performance Targets","id":"9-performance-targets"},{"level":2,"text":"10. Hardware Soul &amp; Systems View","id":"10-hardware-soul-amp-systems-view"},{"level":3,"text":"10.1 The Three-Level View","id":"101-the-three-level-view"},{"level":3,"text":"10.2 Cache Line Alignment","id":"102-cache-line-alignment"},{"level":3,"text":"10.3 Syscall Overhead: realpath()","id":"103-syscall-overhead-realpath"},{"level":2,"text":"11. Implementation Path (C Details)","id":"11-implementation-path-c-details"},{"level":3,"text":"11.1 Date Handling (UTC)","id":"111-date-handling-utc"},{"level":3,"text":"11.2 File Descriptor Safety","id":"112-file-descriptor-safety"},{"level":3,"text":"11.3 MIME Lookup with strrchr","id":"113-mime-lookup-with-strrchr"},{"level":1,"text":"MODULE SPECIFICATION: Concurrent Connections (http-server-basic-m4)","id":"module-specification-concurrent-connections-http-server-basic-m4"},{"level":2,"text":"1. Module Charter","id":"1-module-charter"},{"level":2,"text":"2. File Structure","id":"2-file-structure"},{"level":2,"text":"3. Complete Data Model","id":"3-complete-data-model"},{"level":3,"text":"3.1 Work Item Struct","id":"31-work-item-struct"},{"level":3,"text":"3.2 Thread Pool Struct (thread_pool_t)","id":"32-thread-pool-struct-thread_pool_t"},{"level":2,"text":"4. Interface Contracts","id":"4-interface-contracts"},{"level":3,"text":"4.1 int thread_pool_init(thread_pool_t *pool, int threads, int queue_size, const char *root, int timeout)","id":"41-int-thread_pool_initthread_pool_t-pool-int-threads-int-queue_size-const-char-root-int-timeout"},{"level":3,"text":"4.2 int thread_pool_submit(thread_pool_t *pool, int client_fd)","id":"42-int-thread_pool_submitthread_pool_t-pool-int-client_fd"},{"level":3,"text":"4.3 void thread_pool_shutdown(thread_pool_t *pool)","id":"43-void-thread_pool_shutdownthread_pool_t-pool"},{"level":3,"text":"4.4 void handle_connection(int client_fd, thread_pool_t *pool)","id":"44-void-handle_connectionint-client_fd-thread_pool_t-pool"},{"level":2,"text":"5. Algorithm Specification","id":"5-algorithm-specification"},{"level":3,"text":"5.1 The Worker Loop (worker_thread_fn)","id":"51-the-worker-loop-worker_thread_fn"},{"level":3,"text":"5.2 HTTP/1.1 Keep-Alive Loop","id":"52-http11-keep-alive-loop"},{"level":3,"text":"5.3 Dedicated Signal Thread (signal_handler_thread)","id":"53-dedicated-signal-thread-signal_handler_thread"},{"level":2,"text":"6. Error Handling Matrix","id":"6-error-handling-matrix"},{"level":2,"text":"7. Implementation Sequence with Checkpoints","id":"7-implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Shared State &amp; Initialization (2 hours)","id":"phase-1-shared-state-amp-initialization-2-hours"},{"level":3,"text":"Phase 2: Worker Logic (2 hours)","id":"phase-2-worker-logic-2-hours"},{"level":3,"text":"Phase 3: Keep-Alive &amp; Timeouts (2 hours)","id":"phase-3-keep-alive-amp-timeouts-2-hours"},{"level":3,"text":"Phase 4: Graceful Shutdown (1 hour)","id":"phase-4-graceful-shutdown-1-hour"},{"level":2,"text":"8. Test Specification","id":"8-test-specification"},{"level":3,"text":"8.1 Load Test (Concurrency)","id":"81-load-test-concurrency"},{"level":3,"text":"8.2 Slowloris Defense","id":"82-slowloris-defense"},{"level":3,"text":"8.3 Data Race Check","id":"83-data-race-check"},{"level":2,"text":"9. Performance Targets","id":"9-performance-targets"},{"level":2,"text":"10. Hardware Soul: Concurrency &amp; Physics","id":"10-hardware-soul-concurrency-amp-physics"},{"level":3,"text":"10.1 Cache Line Bouncing (MESI Protocol)","id":"101-cache-line-bouncing-mesi-protocol"},{"level":3,"text":"10.2 Atomic Instructions","id":"102-atomic-instructions"},{"level":2,"text":"11. Concurrency Specification: Lock Ordering","id":"11-concurrency-specification-lock-ordering"},{"level":2,"text":"12. Implementation Path (C Details)","id":"12-implementation-path-c-details"},{"level":3,"text":"12.1 The 503 Overload Response","id":"121-the-503-overload-response"},{"level":3,"text":"12.2 Signal Masking Snippet","id":"122-signal-masking-snippet"},{"level":3,"text":"12.3 Robust Dequeue","id":"123-robust-dequeue"},{"level":1,"text":"Project Structure: HTTP Server (Basic)","id":"project-structure-http-server-basic"},{"level":2,"text":"Directory Tree","id":"directory-tree"},{"level":2,"text":"Creation Order","id":"creation-order"},{"level":2,"text":"File Count Summary","id":"file-count-summary"}],"title":"ðŸŽ¯ Project Charter: HTTP Server (Basic)","markdown":"# ðŸŽ¯ Project Charter: HTTP Server (Basic)\n\n## What You Are Building\nA production-aware, standalone HTTP/1.1 static file server built from raw TCP sockets. You are creating a systems-level tool that maps URL paths to a local filesystem, detects MIME types, prevents security exploits like directory traversal, and manages multiple simultaneous clients using a bounded thread pool. By the end, you will have a high-performance binary capable of serving a modern website to multiple browsers concurrently.\n\n## Why This Project Exists\nModern web development happens behind layers of framework abstractions that treat the network and the OS as \"magic.\" Building an HTTP server from scratch exposes the \"physics\" of the web: how TCP byte streams are framed into messages, how the kernel manages file descriptors, and why threading models are the difference between a responsive service and a crashed one.\n\n## What You Will Be Able to Do When Done\n- **Master Socket Programming:** Implement the full TCP lifecycle (bind, listen, accept) and handle partial network reads/writes.\n- **Implement Protocols:** Write a robust, adversarial-safe parser for HTTP/1.1 requests following RFC 7230.\n- **Enforce Systems Security:** Implement path canonicalization to prevent \"Directory Traversal\" attacks that leak sensitive system files.\n- **Architect Concurrency:** Build a work-queue based thread pool from scratch to handle hundreds of parallel connections.\n- **Manage Resource Lifecycle:** Implement graceful shutdowns and connection \"Keep-Alive\" to maximize server efficiency.\n\n## Final Deliverable\nA single executable (written in C, Go, or Rust) composed of ~1,500 to 2,500 lines of code across modules for networking, parsing, and file I/O. The server will pass a \"stress test\" of 10,000 requests without leaking file descriptors and will serve a complex directory of HTML, CSS, JS, and binary images to any standard web browser.\n\n## Is This Project For You?\n**You should start this if you:**\n- Understand pointers and manual memory management (if using C).\n- Are comfortable with basic File I/O (open, read, write).\n- Want to know exactly what happens when you type a URL into a browser.\n- Are ready to debug low-level network issues using `curl`, `telnet`, and `netstat`.\n\n**Come back after you've learned:**\n- [TCP/IP Basics](https://beej.us/guide/bgnet/): Understanding IP addresses and port numbers.\n- Basic C/Systems Syntax: If you don't know the difference between the stack and the heap, this will be frustrating.\n\n## Estimated Effort\n| Phase | Time |\n|-------|------|\n| **Phase 1: TCP Server & HTTP Response** | ~3 hours |\n| **Phase 2: HTTP Request Parsing** | ~4 hours |\n| **Phase 3: Static File Serving & Security** | ~6 hours |\n| **Phase 4: Thread Pool & Concurrency** | ~7 hours |\n| **Total** | **~20 hours** |\n\n## Definition of Done\nThe project is complete when:\n- The server successfully serves an `index.html` file and an image to a browser (Chrome/Firefox).\n- `curl -I` returns correct headers including `Content-Type`, `Content-Length`, and `Date`.\n- A request for `../../etc/passwd` returns a `403 Forbidden` or `404 Not Found`, never the file content.\n- The server handles 50 concurrent requests simultaneously without dropping connections.\n- The server shuts down gracefully on `SIGINT` (Ctrl+C), closing all sockets and joining all threads without leaks.\n```\n\n---\n\n# HTTP Server (Basic) â€” Build Your Own Static File Server\n\nThis project builds a fully functional HTTP/1.1 static file server from raw TCP sockets upward. You will implement the complete network stack lifecycle â€” binding, listening, accepting, reading, parsing, responding â€” then layer on HTTP protocol parsing per RFC 7230, secure static file serving with directory traversal prevention, and finally concurrent connection handling via a bounded thread pool with keep-alive and graceful shutdown.\n\nThe project deliberately avoids all frameworks and HTTP libraries, forcing you to negotiate directly with the operating system's socket API, the filesystem, and the threading primitives. Every abstraction that web frameworks hide â€” partial reads, CRLF parsing, MIME detection, path canonicalization, connection lifecycle management â€” becomes visible and tangible.\n\nBy the end, you will have a production-aware mental model of what happens between a browser hitting Enter and pixels appearing on screen, grounded in syscalls, file descriptors, and cache lines rather than framework magic.\n\n\n\n<!-- MS_ID: http-server-basic-m1 -->\n# Milestone 1: TCP Server & HTTP Response\n## Where You Are in the System\nBefore you write a single line of code, orient yourself. You are about to build the absolute foundation of an HTTP server â€” the part that everything else rests on. In the full architecture of this project, you are building the **entry point**: the socket machinery that catches raw network connections before HTTP parsing, file serving, or concurrency concerns exist at all.\n\n![HTTP Server Architecture â€” Satellite Map](./diagrams/diag-satellite-map.svg)\n\nThis milestone has one job: establish the plumbing. By the end, your server will open a network port, wait for a browser or `curl` to connect, receive raw bytes, and send back a hardcoded HTTP response. No routing, no file reading, no concurrency â€” just the essential loop that every production web server on Earth runs underneath its abstractions.\n---\n## The Fundamental Tension: TCP Is a Byte Pipe, Not a Message Pipe\nHere's the misconception that breaks more networking code than any other: **\"The client sends a request, so my `read()` call returns a complete request.\"**\nIt feels obvious. You type a URL into a browser, it sends one HTTP request, your server should receive one HTTP request. The unit of thinking is a *message*. So naturally, `read()` gives you the message, right?\nWrong. And understanding *why* this is wrong is the most important thing you will learn in this entire milestone.\n**TCP (Transmission Control Protocol) is a byte stream protocol.** The kernel has no concept of \"messages.\" When the browser sends `GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n` â€” those 38 bytes â€” your kernel might deliver them in one `read()` call. Or three. Or seven. The kernel is working at the level of **receive buffer segments**, not HTTP messages. The factors that determine what each `read()` returns include:\n- **Network packet fragmentation** â€” IP packets have a Maximum Transmission Unit (MTU) of ~1500 bytes on Ethernet. Large HTTP headers might span multiple packets.\n- **TCP Nagle's algorithm** â€” Small writes from the client may be coalesced (batched) before transmission, or may not.\n- **Kernel scheduling** â€” Your `read()` runs when the OS schedules your process. The receive buffer might have accumulated 1 byte or 8KB since your last read.\n- **Localhost vs. real network** â€” On localhost, both processes share the same kernel and network stack, so data often arrives in one call. In production over a real network, partial delivery is the norm.\nThis is the exact trap the Architect flagged. Code that passes every localhost test silently breaks on a production network because the testing environment hides the byte-stream nature of TCP.\n\n![Partial Read Reality â€” TCP Byte Stream vs. HTTP Messages](./diagrams/diag-m1-partial-reads.svg)\n\nThe consequence is concrete: **you must accumulate bytes in a buffer and search for the `\\r\\n\\r\\n` delimiter yourself.** The HTTP specification says headers end with a blank line â€” that's `\\r\\n\\r\\n` in raw bytes. Your job is to keep calling `read()` until you've seen that sequence, appending each result into a growing buffer. Only then do you have a complete HTTP request header section.\nThis one insight â€” TCP is a byte stream, HTTP is a structured message, and you must bridge the gap â€” is the foundation for the next three milestones and for virtually all network programming you will ever do.\n---\n## File Descriptors: Your Handle to the OS\nBefore touching socket code, you need to understand **file descriptors** (FDs), because every socket you create is one.\nIn Unix/Linux, the operating system manages access to hardware and resources on behalf of your program. Your program can't directly manipulate a network port or a disk file â€” it asks the kernel to do it, and the kernel hands back a small non-negative integer called a **file descriptor**. This integer is your process's handle to an open resource.\nThink of file descriptors as numbered slots in a per-process table the kernel maintains. Slot 0 is always `stdin` (keyboard input), slot 1 is `stdout` (terminal output), slot 2 is `stderr` (error output). When you open a file, create a socket, or create a pipe, the kernel allocates the next available slot and returns that number to you.\n```c\nint fd = socket(AF_INET, SOCK_STREAM, 0);\n// fd might be 3, 4, 5... â€” the kernel chose the next available slot\n```\nThe crucial implication: **when you're done with a resource, you must call `close(fd)`.** If you forget, the kernel keeps the slot occupied. A typical Linux process can only have ~1024 file descriptors open at once (the soft limit; configurable with `ulimit -n`). A server that handles 1000 connections without closing them hits this ceiling and starts failing `accept()` calls with `EMFILE` (\"too many open files\"). This is a real production failure mode, not a theoretical concern.\n\n![File Descriptor Table â€” What the Kernel Sees](./diagrams/diag-m1-fd-table.svg)\n\nThe reason file descriptors matter right now: your server will manage *two* kinds of file descriptors simultaneously:\n- The **listening socket** â€” one FD, open for the server's lifetime, represents \"this port is accepting connections\"\n- **Client connection sockets** â€” one FD *per accepted connection*, must be `close()`d after each response\n---\n## The Seven-Step Socket Dance\nCreating a TCP server requires exactly seven system calls in the right order. Each one transforms the state of your server and its connection to the OS. There's no skipping steps â€” the kernel enforces the order.\n\n![Socket Syscall Lifecycle â€” The 7-Step Dance](./diagrams/diag-m1-socket-lifecycle.svg)\n\nLet's walk through each step with its why.\n### Step 1: `socket()` â€” Create an Endpoint\n```c\nint server_fd = socket(AF_INET, SOCK_STREAM, 0);\nif (server_fd < 0) {\n    perror(\"socket\");\n    exit(1);\n}\n```\n`socket()` creates a new socket and returns its file descriptor. The three parameters tell the kernel what kind of socket:\n- `AF_INET` â€” Address Family Internet (IPv4). Use `AF_INET6` for IPv6.\n- `SOCK_STREAM` â€” Stream socket, meaning TCP: ordered, reliable byte delivery. The alternative `SOCK_DGRAM` is UDP.\n- `0` â€” Protocol. 0 means \"pick the default for this family/type combo,\" which is TCP here.\nAt this point, you have a socket, but it's not associated with any port or address. It's like having a phone but no phone number.\n### Step 2: `setsockopt()` â€” Enable Port Reuse\n```c\nint opt = 1;\nsetsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n```\nThis step is optional but practically mandatory. Without it, after you stop and restart your server, the OS may reject `bind()` for 1â€“4 minutes with `EADDRINUSE`. This happens because TCP has a **TIME_WAIT** state: when a connection closes, the OS keeps the port reserved briefly to catch any delayed packets still in transit. `SO_REUSEADDR` tells the kernel \"let me reuse this address even if there are TIME_WAIT connections on it.\" Every production server sets this.\n`SOL_SOCKET` means \"this option applies to the socket layer itself\" (as opposed to TCP-level or IP-level options). `SO_REUSEADDR` is the option name. The `&opt` is a pointer to the value â€” `1` means enable.\n### Step 3: `bind()` â€” Claim a Port\n```c\nstruct sockaddr_in addr;\nmemset(&addr, 0, sizeof(addr));\naddr.sin_family = AF_INET;\naddr.sin_addr.s_addr = INADDR_ANY;  // Listen on all interfaces\naddr.sin_port = htons(8080);        // Port 8080, in network byte order\nif (bind(server_fd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {\n    perror(\"bind\");\n    exit(1);\n}\n```\n`bind()` associates your socket with a specific IP address and port number. After this call, port 8080 on this machine is claimed by your process. The `struct sockaddr_in` encodes IPv4 address information.\n**Network byte order**: The `htons()` call is critical. CPUs can store multi-byte numbers in two ways: **big-endian** (most significant byte first, like humans write numbers) or **little-endian** (least significant byte first, which most modern x86 CPUs use). The network protocol standard mandates big-endian, called \"network byte order.\" `htons()` â€” \"host to network short\" â€” converts a 16-bit port number from your CPU's native order to network byte order. Without it, you'd bind to port 36895 (the byte-flipped version of 8080) instead of 8080. `INADDR_ANY` (value 0) means \"accept connections on any local IP address\" â€” useful when your machine has multiple network interfaces.\n### Step 4: `listen()` â€” Start Accepting Connections\n```c\nif (listen(server_fd, SOMAXCONN) < 0) {\n    perror(\"listen\");\n    exit(1);\n}\n```\n`listen()` marks the socket as passive â€” it will receive incoming connections rather than initiate them. The second argument, the **backlog**, specifies how many pending connections the kernel should queue while your server is busy in `accept()`. `SOMAXCONN` is a constant (typically 128 or 4096 depending on OS) that requests the system maximum. For a production server, you'd tune this, but `SOMAXCONN` is correct for now.\nAfter `listen()`, your socket is in the **listening state**. The kernel's TCP state machine handles the three-way handshake (SYN â†’ SYN-ACK â†’ ACK) automatically for incoming clients. By the time `accept()` returns to you, the connection is already established at the TCP level â€” your code never sees raw TCP handshakes.\n### Step 5: `accept()` â€” Receive a Connection\n```c\nstruct sockaddr_in client_addr;\nsocklen_t client_len = sizeof(client_addr);\nint client_fd = accept(server_fd, (struct sockaddr*)&client_addr, &client_len);\nif (client_fd < 0) {\n    perror(\"accept\");\n    continue;  // Don't exit â€” try next connection\n}\n```\n`accept()` blocks (pauses your program) until a client connects. When a client connects, it returns a **new file descriptor** â€” `client_fd` â€” that represents the specific connection to that client. Your original `server_fd` remains untouched, still listening for future connections.\nThis is architecturally important: you always have two distinct roles:\n- `server_fd` â€” the *listening* socket (one, permanent)\n- `client_fd` â€” the *connection* socket (one per client, temporary)\nThe `client_addr` is filled in by the kernel with the client's IP and port. You can inspect it to log where connections come from.\n\n![Three-Level View: What Happens on accept()](./diagrams/diag-m1-three-level-socket.svg)\n\n### Step 6: `read()` / `recv()` and `write()` / `send()` â€” Communicate\nNow you have `client_fd`. This is a bidirectional byte stream. You read from it (bytes the client sent) and write to it (bytes you're sending back).\nThe partial-read problem lives here. We'll dedicate a full section to this below.\n### Step 7: `close()` â€” Release the Connection\n```c\nclose(client_fd);  // MANDATORY after each connection\n```\nAfter your response is sent, close the client socket. This signals to the client that you're done (TCP FIN handshake), and releases the kernel file descriptor. Never skip this.\n---\n## Three-Level View: What Happens When You Call `accept()`\nTo truly understand the socket lifecycle, look at all three levels simultaneously.\n**Level 1 â€” Your Code:**\nYou call `accept(server_fd, ...)` and your program pauses. Eventually it returns with `client_fd = 5`.\n**Level 2 â€” OS/Kernel:**\nThe kernel maintains two queues for your listening socket:\n- **SYN queue** (incomplete connections): TCP handshakes in progress\n- **Accept queue** (complete connections): fully-established connections waiting for your `accept()` call\nWhen a client's SYN arrives, the kernel adds it to the SYN queue, sends SYN-ACK, and waits for ACK. When ACK arrives, the connection moves to the Accept queue. Your `accept()` call dequeues the next entry from the Accept queue, creates a new socket file descriptor for it, and returns. If the Accept queue is empty, `accept()` blocks until it's not.\n**Level 3 â€” Hardware:**\nThe network interface card (NIC) receives an Ethernet frame containing an IP packet containing a TCP segment. The NIC raises a hardware interrupt, the interrupt handler (running in kernel context) processes the TCP segment, updates the connection state machine, and places the data into the socket's receive buffer in kernel memory. The kernel wakes your `accept()` call by transitioning your thread from the \"sleeping\" state to \"runnable.\"\nThe hardware-to-userspace path: NIC â†’ DMA into kernel buffer â†’ TCP stack processes segment â†’ wakes sleeping process â†’ your code runs. This entire path takes on the order of 10â€“50 microseconds on a local network.\n---\n## The Partial Read Problem â€” Solved\nNow let's implement the read loop properly. The design goal: accumulate bytes from `client_fd` until we've seen `\\r\\n\\r\\n` (the HTTP header terminator), or until we've read a maximum safe amount.\n```c\n#define BUFFER_SIZE 8192\n// Returns the number of bytes in the buffer on success, -1 on error/disconnect\n// Sets *header_end to the position after \\r\\n\\r\\n if found, -1 if not found\nssize_t read_http_request(int client_fd, char *buf, size_t buf_size, int *header_end) {\n    size_t total_read = 0;\n    *header_end = -1;\n    while (total_read < buf_size - 1) {  // Leave room for null terminator\n        ssize_t n = read(client_fd, buf + total_read, buf_size - 1 - total_read);\n        if (n < 0) {\n            // EAGAIN/EWOULDBLOCK: no data yet (non-blocking mode, not our case here)\n            // Other errors: real problem\n            perror(\"read\");\n            return -1;\n        }\n        if (n == 0) {\n            // Client disconnected before sending complete request\n            return -1;\n        }\n        total_read += n;\n        buf[total_read] = '\\0';  // Null-terminate for string searching\n        // Scan for the end-of-headers delimiter\n        char *end = strstr(buf, \"\\r\\n\\r\\n\");\n        if (end != NULL) {\n            *header_end = (int)(end - buf) + 4;  // Position after the delimiter\n            return (ssize_t)total_read;\n        }\n    }\n    // Buffer full without finding delimiter â€” request too large\n    return -1;\n}\n```\nWalk through this carefully:\n- **`read()` return values**: positive means \"I read this many bytes,\" zero means \"the client closed the connection,\" negative means \"an error occurred.\" You must handle all three.\n- **`buf + total_read`**: each call reads into the *next unused portion* of the buffer. This is how accumulation works â€” each call appends to where the last one left off.\n- **`buf_size - 1 - total_read`**: we tell `read()` the maximum it can give us, shrinking as the buffer fills. The `- 1` reserves space for the null terminator we add after each read.\n- **`strstr(buf, \"\\r\\n\\r\\n\")`**: scan the entire accumulated buffer for the delimiter. We scan from the start each time (slightly inefficient, but correct and simple for now).\n- **Buffer size limit**: 8KB is the default maximum URI length in many HTTP servers (and the nginx default). Requests larger than this get rejected, which we'll implement properly in Milestone 2.\nThis is the correct mental model: **`read()` is just \"give me whatever bytes the kernel has right now.\"** Your code is responsible for interpreting those bytes as a structured protocol.\n---\n## Building the Complete Server\nNow let's assemble everything into a working server. We'll structure the code cleanly from the start â€” the habits you form here carry through all four milestones.\n### Data Structures and Memory Layout\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n#include <time.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define DEFAULT_PORT      8080\n#define BACKLOG           SOMAXCONN\n#define REQUEST_BUF_SIZE  8192\n#define MAX_RESPONSE_SIZE 4096\n```\n\n![Server Data Structures â€” Memory Layout](./diagrams/diag-m1-server-struct-layout.svg)\n\n```c\ntypedef struct {\n    int      port;       // TCP port to bind\n    int      server_fd;  // Listening socket file descriptor\n} server_config_t;\n```\nKeep the struct minimal for Milestone 1. Later milestones will expand it with document root, thread pool size, and timeout configuration.\n### The Hardcoded HTTP Response\nIn Milestone 1, you're not reading files yet â€” you're sending a fixed response to prove the plumbing works. But the response must be a *valid* HTTP/1.1 response. Let's understand why each header matters.\n```c\n// Build a valid HTTP/1.1 200 OK response with Date header\n// Returns bytes written to `buf`, or -1 on error\nint build_hardcoded_response(char *buf, size_t buf_size) {\n    // HTTP Date header format: \"Day, DD Mon YYYY HH:MM:SS GMT\"\n    time_t now = time(NULL);\n    struct tm *gmt = gmtime(&now);\n    char date_str[64];\n    strftime(date_str, sizeof(date_str), \"%a, %d %b %Y %H:%M:%S GMT\", gmt);\n    const char *body =\n        \"<html><body>\"\n        \"<h1>Hello from my HTTP server!</h1>\"\n        \"</body></html>\";\n    int body_len = (int)strlen(body);\n    int n = snprintf(buf, buf_size,\n        \"HTTP/1.1 200 OK\\r\\n\"\n        \"Content-Type: text/html; charset=utf-8\\r\\n\"\n        \"Content-Length: %d\\r\\n\"\n        \"Date: %s\\r\\n\"\n        \"Connection: close\\r\\n\"\n        \"\\r\\n\"\n        \"%s\",\n        body_len,\n        date_str,\n        body);\n    return (n > 0 && (size_t)n < buf_size) ? n : -1;\n}\n```\nEach header serves a specific role:\n- **`HTTP/1.1 200 OK`** â€” The status line. `HTTP/1.1` is the protocol version. `200` is the numeric status code. `OK` is the human-readable reason phrase. The browser uses the numeric code; the phrase is for humans and logs.\n- **`Content-Type: text/html; charset=utf-8`** â€” Without this, browsers guess the content type. Some browsers display HTML as raw text if they guess wrong. `charset=utf-8` specifies character encoding.\n- **`Content-Length: N`** â€” The exact byte count of the body. The browser needs this to know where the response ends. Without it, the browser has to wait for the connection to close to know if more data is coming.\n- **`Date:`** â€” Required by HTTP/1.1 (RFC 7231, Section 7.1.1.2). Servers should include it. We generate it from the system clock in UTC.\n- **`Connection: close`** â€” Tells the client we'll close the connection after this response. In Milestone 4, you'll implement `keep-alive` to reuse connections. For now, `close` is correct.\n- **Blank line (`\\r\\n`)** â€” Mandatory separator between headers and body. Every HTTP message has this blank line; without it, the body would be treated as another header.\n### Writing the Response â€” Partial Writes\nJust as `read()` might give you fewer bytes than requested, `write()` might send fewer bytes than you asked. This is uncommon on localhost but can happen when the kernel's send buffer is full (which happens under load). The fix is the same: loop until all bytes are sent.\n```c\n// Write all `len` bytes from `buf` to `fd`.\n// Returns 0 on success, -1 on error.\nint write_all(int fd, const char *buf, size_t len) {\n    size_t total_written = 0;\n    while (total_written < len) {\n        ssize_t n = write(fd, buf + total_written, len - total_written);\n        if (n <= 0) {\n            return -1;  // Error or connection closed\n        }\n        total_written += n;\n    }\n    return 0;\n}\n```\nThis pattern â€” the \"write-all\" or \"write loop\" â€” is so common it appears in virtually every systems library. Python's `socket.sendall()`, Go's `io.WriteString()`, and Rust's `write_all()` trait method all implement exactly this loop so you don't have to.\n### Handling SIGPIPE â€” Don't Let the Client Kill Your Server\nHere's a specific failure mode you must handle before your first test.\n**The scenario**: a client connects, you call `write()` to send the response, but the client has already disconnected (crashed, closed the tab, hit Ctrl+C). The client's side of the TCP connection is closed. What happens when you write to a socket whose remote end is closed?\nOn Linux, the first `write()` succeeds (the kernel doesn't know yet that the client is gone). The kernel sends the data, the remote TCP stack sends back a RST (reset) packet. On your *second* `write()` to that socket, the kernel has now processed the RST and knows the connection is dead. Instead of returning an error from `write()`, the kernel delivers **SIGPIPE** â€” signal 13 â€” to your process. The default handler for SIGPIPE **terminates your process.**\nThat's right: a single misbehaving client can kill your server.\n\n![SIGPIPE Death Scenario â€” Before & After](./diagrams/diag-m1-sigpipe.svg)\n\nThe fix is to ignore SIGPIPE:\n```c\n// At server startup, before any accept() calls:\nsignal(SIGPIPE, SIG_IGN);\n```\nAfter this, when you try to write to a closed socket, `write()` returns -1 with `errno = EPIPE` instead of killing your process. You check the return value (you always check return values in systems code), log it, and close the client socket gracefully.\nAn alternative when using `send()` instead of `write()`:\n```c\n// MSG_NOSIGNAL tells the kernel: don't send SIGPIPE on broken pipe\nssize_t n = send(fd, buf + total_written, len - total_written, MSG_NOSIGNAL);\n```\n`MSG_NOSIGNAL` is Linux-specific. `signal(SIGPIPE, SIG_IGN)` is portable and works on Linux, macOS, and BSDs. For this project, use `signal(SIGPIPE, SIG_IGN)` at startup.\n### The Complete `main()` Function\n```c\nint main(int argc, char *argv[]) {\n    int port = DEFAULT_PORT;\n    if (argc == 2) {\n        port = atoi(argv[1]);\n        if (port <= 0 || port > 65535) {\n            fprintf(stderr, \"Invalid port: %s\\n\", argv[1]);\n            return 1;\n        }\n    }\n    // --- SIGPIPE: must happen before any socket I/O ---\n    signal(SIGPIPE, SIG_IGN);\n    // --- Step 1: Create listening socket ---\n    int server_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_fd < 0) {\n        perror(\"socket\");\n        return 1;\n    }\n    // --- Step 2: Enable port reuse ---\n    int opt = 1;\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0) {\n        perror(\"setsockopt\");\n        close(server_fd);\n        return 1;\n    }\n    // --- Step 3: Bind to port ---\n    struct sockaddr_in addr;\n    memset(&addr, 0, sizeof(addr));\n    addr.sin_family      = AF_INET;\n    addr.sin_addr.s_addr = INADDR_ANY;\n    addr.sin_port        = htons((uint16_t)port);\n    if (bind(server_fd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {\n        perror(\"bind\");\n        close(server_fd);\n        return 1;\n    }\n    // --- Step 4: Start listening ---\n    if (listen(server_fd, BACKLOG) < 0) {\n        perror(\"listen\");\n        close(server_fd);\n        return 1;\n    }\n    printf(\"Server listening on port %d\\n\", port);\n    // --- Step 5: Accept loop ---\n    while (1) {\n        struct sockaddr_in client_addr;\n        socklen_t client_len = sizeof(client_addr);\n        int client_fd = accept(server_fd, (struct sockaddr*)&client_addr, &client_len);\n        if (client_fd < 0) {\n            if (errno == EINTR) continue;  // Interrupted by signal, retry\n            perror(\"accept\");\n            continue;  // Log and continue; don't crash the server\n        }\n        // Log the incoming connection\n        char client_ip[INET_ADDRSTRLEN];\n        inet_ntop(AF_INET, &client_addr.sin_addr, client_ip, sizeof(client_ip));\n        printf(\"Connection from %s:%d (fd=%d)\\n\",\n               client_ip, ntohs(client_addr.sin_port), client_fd);\n        // --- Step 6a: Read the request ---\n        char req_buf[REQUEST_BUF_SIZE];\n        int header_end = -1;\n        ssize_t bytes_read = read_http_request(client_fd, req_buf, REQUEST_BUF_SIZE, &header_end);\n        if (bytes_read > 0 && header_end > 0) {\n            // Log the first line of the request\n            char *first_line_end = strstr(req_buf, \"\\r\\n\");\n            if (first_line_end) *first_line_end = '\\0';\n            printf(\"Request: %s\\n\", req_buf);\n            if (first_line_end) *first_line_end = '\\r';  // Restore\n        }\n        // --- Step 6b: Build and send the response ---\n        char resp_buf[MAX_RESPONSE_SIZE];\n        int resp_len = build_hardcoded_response(resp_buf, sizeof(resp_buf));\n        if (resp_len > 0) {\n            if (write_all(client_fd, resp_buf, (size_t)resp_len) < 0) {\n                // Client disconnected before we finished â€” EPIPE, not a crash\n                printf(\"Client disconnected during write (fd=%d)\\n\", client_fd);\n            }\n        }\n        // --- Step 7: Close the connection ---\n        close(client_fd);\n        printf(\"Connection closed (fd=%d)\\n\", client_fd);\n    }\n    // Unreachable in this milestone, but good practice:\n    close(server_fd);\n    return 0;\n}\n```\n### Compiling and Testing\n```bash\n# Compile\ngcc -Wall -Wextra -o http_server server.c\n# Run on default port 8080\n./http_server\n# Run on a different port\n./http_server 9090\n# Test with curl (in another terminal)\ncurl -v http://localhost:8080/\n# Test with telnet to see raw bytes\ntelnet localhost 8080\n# Type: GET / HTTP/1.1\n# Type: Host: localhost\n# Press Enter twice\n```\nExpected `curl -v` output:\n```\n* Connected to localhost port 8080\n> GET / HTTP/1.1\n> Host: localhost\n> User-Agent: curl/7.x.x\n> Accept: */*\n>\n< HTTP/1.1 200 OK\n< Content-Type: text/html; charset=utf-8\n< Content-Length: 53\n< Date: Sat, 28 Feb 2026 12:00:00 GMT\n< Connection: close\n<\n<html><body><h1>Hello from my HTTP server!</h1></body></html>\n```\n### Verifying No File Descriptor Leaks\nA critical correctness check: after many connections, your server must return to its baseline FD count. You can verify this on Linux:\n```bash\n# Get your server's PID\nps aux | grep http_server\n# Check open FDs before connections\nls /proc/<PID>/fd | wc -l\n# Hammer it with 1000 sequential connections\nfor i in $(seq 1000); do curl -s http://localhost:8080/ > /dev/null; done\n# Check open FDs after â€” should be the same count as before\nls /proc/<PID>/fd | wc -l\n```\nIf the count grows, you have a file descriptor leak. In this milestone's sequential design, the cause is always a missing `close(client_fd)` on an error path. Every `if (something_failed)` block that exits before the normal `close(client_fd)` must also close the FD.\n---\n## Hardware Soul: What the CPU and Kernel Are Doing\nLet's apply the domain's hardware perspective to the operations in this milestone.\n**`accept()` â€” blocking on empty queue**: Your thread is in the `TASK_INTERRUPTIBLE` sleep state. The CPU runs other processes. When a SYN arrives, the NIC raises a hardware interrupt, the kernel interrupt handler runs (in kernel space), processes the TCP three-way handshake, moves the connection to the accept queue, and transitions your thread to `TASK_RUNNING`. Next time the scheduler runs, your thread wakes up and `accept()` returns. Zero CPU cycles wasted while waiting.\n**`read()` from socket â€” memory access pattern**: The kernel's receive buffer is in kernel virtual memory. When you call `read()`, the kernel copies bytes from its buffer into your userspace buffer (`req_buf`). This is a **memory-to-memory copy** with good locality if the request is small (fits in L1/L2 cache). For a typical 200-byte HTTP request, the entire operation â€” kernel buffer + your buffer â€” fits in L1 cache (typically 32â€“64KB). Latency: ~100ns for in-cache operations.\n**`write()` to socket â€” send buffer**: The kernel has a send buffer per socket (default ~87KB on Linux, controlled by `SO_SNDBUF`). Your `write()` copies data from your buffer into the send buffer and returns. The kernel's TCP stack asynchronously handles segmentation and transmission. This means `write()` is nearly always fast (just a memory copy). It only blocks if the send buffer is full â€” which happens when the network is congested or the client is reading slowly.\n**`close()` â€” FD table update**: Closing an FD is a kernel table update: decrement the reference count on the socket structure, release the FD slot in the process's file descriptor table. If reference count hits zero (no other FD points to this socket), begin TCP FIN sequence. Very fast â€” no disk I/O, just memory writes.\n**Branch prediction**: The accept loop's `while(1)` is perfectly predictable (always taken). The error checks (`if (client_fd < 0)`) are almost never taken in normal operation â€” the branch predictor learns this quickly. The partial read loop's termination condition (`strstr` found `\\r\\n\\r\\n`) is taken once per request â€” predictable after the first connection.\n---\n## Error Handling Philosophy for Systems Code\nNotice that every syscall's return value is checked. This is not optional ceremony â€” it's load-bearing structure. Syscalls fail for real reasons:\n| Error | Cause | Correct Response |\n|-------|-------|-----------------|\n| `EADDRINUSE` on `bind()` | Port already in use | Exit with clear error message |\n| `EMFILE` on `accept()` | Too many open FDs | Log error, continue loop, investigate leak |\n| `EINTR` on `accept()` | Signal interrupted the call | Retry immediately (loop `continue`) |\n| `EPIPE` on `write()` | Client disconnected | Close `client_fd`, continue to next connection |\n| `ECONNRESET` on `read()` | Client forcibly closed | Close `client_fd`, continue |\nThe pattern: **server-fatal errors** (can't bind, can't listen) cause `exit()`. **Per-connection errors** (client misbehaved, disconnected) cause `close(client_fd)` and `continue`. Never let a misbehaving client crash the server â€” which is why `SIGPIPE` must be ignored globally.\n`perror(\"context string\")` prints your context string followed by the system error string for `errno`. It's the fastest way to get diagnostic information. `strerror(errno)` gives you the string if you need to format it differently.\n---\n## Design Decision: Sequential vs. Concurrent Connections\nIn this milestone, your server handles one connection at a time. While serving client A, client B's `connect()` call succeeds (the kernel accepts it into the backlog queue), but B must wait until you finish A before you call `accept()` again.\n| Model | Throughput | Complexity | Used By |\n|-------|-----------|------------|---------|\n| **Sequential (this milestone) âœ“** | Low | Very low | dev tools, test servers |\n| Thread-per-connection | Medium | Medium | Apache httpd (legacy) |\n| Thread pool | High | Medium | nginx worker model |\n| Event loop (epoll) | Very high | High | nginx, Node.js, Redis |\nYou're building sequential *deliberately* to isolate the core socket machinery. Milestone 4 replaces this with a thread pool. Once you understand the sequential model perfectly, the concurrent model is just \"run the inner loop in a separate thread\" â€” and all the complexity is in the threading, not the I/O.\nThe `SOMAXCONN` backlog helps here: even with sequential handling, the kernel queues up to `SOMAXCONN` connections, so brief bursts don't immediately reject connections. For a development and learning server, sequential is exactly right.\n---\n## Knowledge Cascade: What This Unlocks\nUnderstanding TCP's byte-stream nature and the socket lifecycle opens doors in five directions simultaneously.\n### 1. Every Language's Buffered I/O Makes Sense Now\nEvery language runtime wraps raw I/O in a buffered reader for exactly the reason you just discovered. Go's `bufio.Reader`, Python's `io.BufferedReader`, Java's `BufferedInputStream`, and C's `FILE*` (via `fread`) all maintain an internal accumulation buffer and expose \"give me a line\" or \"give me N bytes\" interfaces that hide the partial-read reality underneath. Now when you see `bufio.NewReader(conn)` in Go networking code, you know *exactly* what problem it solves and what the raw socket calls beneath it are doing.\n### 2. Protocol Framing Is a Universal Problem\nEvery protocol that runs over TCP must solve the same framing problem: \"where does one message end and the next begin?\" The approaches are consistent across the industry:\n- **HTTP/1.1**: headers end with `\\r\\n\\r\\n`, body length from `Content-Length` or chunked encoding\n- **Redis RESP protocol**: length-prefixed (`*3\\r\\n$3\\r\\nSET\\r\\n...`)\n- **PostgreSQL wire protocol**: 5-byte header with message type + 4-byte length\n- **WebSockets**: 2â€“10 byte binary frame header with payload length\n- **Protocol Buffers over TCP**: typically length-prefixed with a 4-byte varint\nOnce you understand why HTTP uses `\\r\\n\\r\\n`, you can read any protocol specification and immediately identify its framing strategy.\n### 3. Nagle's Algorithm and TCP_NODELAY\nNow that you understand TCP as a byte stream, you can understand **Nagle's algorithm**: a TCP optimization that coalesces small writes before transmitting. If your application sends many small write() calls (say, HTTP headers one line at a time), Nagle's algorithm batches them into fewer packets, improving network efficiency. The tradeoff: it adds latency for small-packet protocols. This is why latency-sensitive applications (Redis, game servers, financial trading systems) call `setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &one, sizeof(one))` to disable Nagle's algorithm. Now that phrase means something concrete to you.\n### 4. Non-Blocking I/O and Event Loops\nThe partial read loop you implemented works because this is *blocking* I/O: `read()` blocks until data arrives. The alternative â€” **non-blocking I/O** with `O_NONBLOCK` â€” makes `read()` return immediately with `EAGAIN` if no data is available. Systems like epoll (Linux) and kqueue (macOS) let you monitor thousands of sockets simultaneously and get notified when any of them have data. The partial-read problem doesn't disappear in non-blocking mode â€” it becomes *more* explicit. nginx, Node.js, Redis, and Go's net package all use this model. You'll understand io_uring (the next generation) when you reach it because you already understand why blocking `read()` is a bottleneck at scale.\n### 5. The FD Lifecycle Is Universal\nThe file descriptor management discipline you're building â€” open, use, close, never leak â€” applies identically to files, pipes, sockets, timers (timerfd), event notifications (eventfd), and even GPU command buffers in Vulkan. The kernel's reference-counted resource model is the same everywhere. The `ulimit -n` ceiling is the same ceiling. The `/proc/<pid>/fd/` directory lets you inspect any process's open resources, and now you know what you're looking at.\n---\n## Common Mistakes That Will Burn You\nKeep these in a mental checklist:\n**1. Forgetting `htons()` on the port.**\n`bind()` will succeed â€” on the wrong port. You'll spend an hour wondering why `curl localhost:8080` times out before realizing your server is actually listening on port 36895.\n**2. Not handling `EINTR` on `accept()`.**\nWhen a signal arrives (including SIGCHLD in Milestone 4's thread model), `accept()` returns -1 with `errno = EINTR`. If you exit the accept loop on any negative return, one signal kills your server. Always check `errno == EINTR` and retry.\n**3. Assuming `read()` returns a complete request.**\nWorks on localhost, fails in staging, fails in production, fails in any test that simulates network conditions. The partial-read loop is non-negotiable.\n**4. Missing `close(client_fd)` on error paths.**\nEvery early return inside the connection-handling block must close `client_fd` before returning. Draw the control flow on paper if needed. A leak here is a server that degrades after thousands of connections and becomes unfixable without a restart.\n**5. Ignoring `write()` return values.**\n`write()` returning -1 with `EPIPE` is the normal case when a client disconnects. If you don't check return values, you don't know whether your response was delivered, and you may try to write to a dead connection repeatedly.\n---\n## Acceptance Criteria Checklist\nBefore moving to Milestone 2, verify each of these manually:\n- [ ] `./http_server 8080` starts and prints \"Server listening on port 8080\"\n- [ ] `curl http://localhost:8080/` receives a valid `200 OK` response with all four required headers (`Content-Type`, `Content-Length`, `Date`, `Connection`)\n- [ ] The HTML body is correct and `Content-Length` matches the actual body byte count\n- [ ] `curl http://localhost:8081/` fails with \"Connection refused\" (confirms port is configurable)\n- [ ] Server does not crash when you kill `curl` mid-request (SIGPIPE handled)\n- [ ] After 1000 sequential `curl` requests, FD count in `/proc/<pid>/fd/` matches the count at startup\n- [ ] Telnet test works: `telnet localhost 8080`, type `GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n`, receive full response\n- [ ] Server logs the client IP and request line for each connection\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: http-server-basic-m2 -->\n<!-- MS_ID: http-server-basic-m2 -->\n# Milestone 2: HTTP Request Parsing\n## Where You Are in the System\nIn Milestone 1, you built the socket plumbing: the server binds a port, accepts a TCP connection, reads raw bytes into a buffer, and sends a hardcoded response. You proved the plumbing works. Now those raw bytes need to mean something.\n\n![HTTP Server Architecture â€” Satellite Map](./diagrams/diag-satellite-map.svg)\n\nRight now, your server is holding a buffer that looks like this:\n```\nGET /index.html HTTP/1.1\\r\\nHost: localhost:8080\\r\\nUser-Agent: curl/7.88\\r\\nAccept: */*\\r\\n\\r\\n\n```\nThat's just a `char[]`. Your server doesn't know the method, doesn't know the path, doesn't know whether to read a body. Before you can serve files (Milestone 3) or handle multiple connections properly (Milestone 4), you need a **parser** â€” code that transforms those raw bytes into structured data your program can reason about.\nThis milestone's job: turn the byte buffer into a struct. After this milestone, the rest of your server speaks in terms of `request.method`, `request.path`, and `request.headers[\"content-type\"]` â€” not raw offsets and `strstr()` calls scattered across the codebase.\n---\n## The Revelation: HTTP Parsing Is Adversarial\nHere's what most developers think HTTP parsing is:\n```c\n// Seems obvious, right?\nchar *method = strtok(request_line, \" \");\nchar *path   = strtok(NULL, \" \");\nchar *version = strtok(NULL, \"\\r\\n\");\n```\nThree calls to `strtok()`, done. The method, path, and version are extracted. Ship it.\nThis code works perfectly â€” in your tests, on your machine, with your browser. And then, in production, it silently fails or, worse, opens a security hole. Let's understand exactly why.\n### The Input You Won't See in Testing\nReal HTTP clients are not all Chrome on macOS sending perfectly formatted requests. They include:\n- **`telnet` and `netcat`** â€” send bare LF (`\\n`) instead of CRLF (`\\r\\n`) because a human typed the request manually\n- **Old HTTP/1.0 clients** â€” may send `GET /\\n\\n` with no headers at all\n- **Malicious scanners** â€” deliberately send malformed requests to probe for vulnerabilities: `GET ` (no path), `GET /` (no version), requests with 100MB URIs\n- **Proxies** â€” add extra headers, fold multi-line header values across lines (an HTTP/1.1 feature called \"header folding,\" now deprecated but still encountered)\n- **HTTP fuzzers** â€” systematically mutate every field looking for crashes\nYour `strtok()` parser treats all of these as undefined behavior. `strtok()` with `\" \"` as the delimiter will happily return whatever's between spaces â€” including a URI that's a gigabyte long â€” and your server will `malloc()` or buffer-overflow trying to hold it.\n\n![HTTP/1.1 Request Message â€” Byte-Level Anatomy](./diagrams/diag-m2-http-message-anatomy.svg)\n\n### Why \"Split on Spaces\" Is a Security Vulnerability\nConsider this request:\n```\nGET /../../../etc/passwd HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\n```\nYour `strtok()` parser extracts `/../../etc/passwd` as the path. If Milestone 3's file server doesn't also validate this, you've just served `/etc/passwd`. But even before that â€” your parser should apply length limits, method validation, and version checking. Every check your parser skips is a check that Milestone 3 has to retroactively add, and you will miss some.\nNow consider:\n```\nGET /valid-path HTTP/1.1\\r\\ncontent-type: application/json\\r\\nContent-Type: text/html\\r\\n\\r\\n\n```\nThe same header name appears twice, in different cases. Which one is the \"real\" `Content-Type`? A naive parser that uses case-sensitive string comparison won't even recognize `content-type` as the same header. RFC 7230 says header names are case-insensitive. Your parser must implement that.\nThe real mental model: **HTTP parsing is adversarial string processing.** Every field in an HTTP request is input from a potentially hostile source. Your parser's job is not just extraction â€” it's **validation, normalization, and rejection**.\n---\n## The HTTP/1.1 Message Format\nBefore writing a parser, you need to know what you're parsing. Let's establish the exact byte-level structure of an HTTP/1.1 request, per RFC 7230.\nAn HTTP/1.1 request has this structure:\n```\n{method} SP {request-target} SP {HTTP-version} CRLF\n{header-name} \":\" OWS {header-value} OWS CRLF\n{header-name} \":\" OWS {header-value} OWS CRLF\n...\nCRLF\n[ message-body ]\n```\nWhere:\n- **SP** = a single space character (0x20). The spec says exactly one space between these three tokens.\n- **CRLF** = `\\r\\n` (0x0D 0x0A). Each line, including the blank line that terminates headers, ends with CRLF.\n- **OWS** = Optional WhiteSpace â€” zero or more spaces or tabs that may appear before or after a header value.\nLet's look at a complete example at the byte level:\n```\nG E T   /   H T T P / 1 . 1  \\r \\n\nH o s t :   l o c a l h o s t  \\r \\n\nU s e r - A g e n t :   c u r l  \\r \\n\n\\r \\n\n```\nIn hex, the first two bytes of the body separator are `0D 0A 0D 0A` â€” two CRLF sequences back-to-back. The first ends the last header line; the second is the blank line that terminates the header section.\nThree structural rules are critical to parse correctly:\n1. **The request line is the first line.** Everything before the first CRLF is the request line.\n2. **Each header is `name: value\\r\\n`.** The colon is the separator. Everything after the colon (minus OWS) is the value.\n3. **A blank line (`\\r\\n` on its own) signals end-of-headers.** In raw bytes, that's `\\r\\n\\r\\n` following the last header.\nThere is one important leniency the RFC recommends: **accept bare LF as a line terminator.** The spec says servers \"SHOULD\" accept bare LF in place of CRLF for historical reasons. When `telnet` users type a request manually, they often send bare LF. A robust parser strips any `\\r` before checking for `\\n`.\n---\n## Designing the Parsed Request Structure\nBefore writing a single parsing function, design the data structure that will hold the result. Good structure design makes everything downstream simpler.\n```c\n#define MAX_HEADERS    32     // Maximum number of HTTP headers we'll accept\n#define MAX_PATH_LEN   8192   // 8KB max URI length (matches nginx default)\n#define MAX_HEADER_LEN 8192   // 8KB max per-header value length\n#define METHOD_GET     0\n#define METHOD_HEAD    1\n#define METHOD_POST    2\n#define METHOD_UNKNOWN 3\ntypedef struct {\n    char  name[256];               // Header name (lowercase, normalized)\n    char  value[MAX_HEADER_LEN];   // Header value (OWS stripped)\n} http_header_t;\ntypedef struct {\n    int          method;                   // METHOD_GET, METHOD_HEAD, METHOD_POST, METHOD_UNKNOWN\n    char         path[MAX_PATH_LEN];       // Requested path, e.g. \"/index.html\"\n    int          http_minor;               // HTTP version minor (0 = HTTP/1.0, 1 = HTTP/1.1)\n    http_header_t headers[MAX_HEADERS];    // Parsed headers array\n    int          header_count;             // Number of valid headers in array\n    int          content_length;           // -1 if no Content-Length header\n    int          keep_alive;               // 1 if connection should persist, 0 if close\n    // Pointer into the original buffer â€” body starts here, length = content_length\n    const char  *body;                     // NULL if no body\n} http_request_t;\n```\n\n![Parsed Request Structure â€” http_request_t Memory Layout](./diagrams/diag-m2-request-struct.svg)\n\nSeveral design decisions worth examining:\n**Fixed-size arrays instead of dynamic allocation.** `http_header_t headers[MAX_HEADERS]` uses 32 statically-allocated header slots. An alternative is `malloc()`ing a linked list or growing array. The fixed-array approach has two advantages: no allocation failures, and cache locality (all headers are contiguous in memory). The downside: we reject requests with more than 32 headers. In practice, real HTTP requests have 5â€“15 headers, so 32 is generous. nginx's default is 100, but HTTP/2 HPACK compression means that limit is rarely approached.\n**Lowercase header names.** We'll normalize all header names to lowercase during parsing. This is the \"right\" approach for case-insensitive comparison â€” normalize once at parse time, compare cheaply everywhere else. The alternative (compare case-insensitively every time you look up a header) means writing a `strcasecmp()` comparison for every header lookup, scattered across your codebase.\n**`content_length` as -1 sentinel.** `-1` means \"no Content-Length header was present.\" `0` means the header was present and specified a zero-length body. This distinction matters: a response with `Content-Length: 0` and no body is valid and different from a response with no `Content-Length` at all.\n**`body` as pointer into the original buffer.** The body isn't copied â€” we point into the buffer we already read. This is the beginning of **zero-copy parsing**: instead of `malloc()`ing memory and copying the body, we just record where in the existing buffer the body starts. For large request bodies (file uploads, POST data), this avoids a potentially multi-megabyte copy.\n---\n## Building the State Machine\nNow the core of this milestone: the parser itself. The right mental model for parsing HTTP is a **state machine** â€” a system that reads one byte (or token) at a time and transitions between well-defined states based on what it sees.\n\n![HTTP Parser State Machine](./diagrams/diag-m2-parser-state-machine.svg)\n\nWhy a state machine and not just `strtok()` and `sscanf()`? Three reasons:\n1. **Partial input handling.** A state machine can be paused mid-parse (when a partial read arrives) and resumed when more bytes arrive. `strtok()` can't â€” it requires the complete string upfront.\n2. **Error localization.** Each state enforces its own invariants. When you receive an invalid character, you know exactly which state you're in, which tells you exactly what's wrong with the request.\n3. **Security through structure.** A state machine naturally imposes length limits (check at every transition) and rejects malformed input (illegal characters in the wrong state trigger immediate error).\nOur parser will work at the **line level** rather than the byte level, since HTTP is line-structured. We'll split the buffer into lines, parse the first line as the request line, and parse remaining lines (until the blank line) as headers.\n### Step 1: Parse the Request Line\nThe request line has exactly three fields separated by single spaces:\n```\nMETHOD SP request-target SP HTTP-version CRLF\n```\n```c\n// Parse an HTTP method string into our enum.\n// Returns METHOD_GET, METHOD_HEAD, METHOD_POST, or METHOD_UNKNOWN.\nstatic int parse_method(const char *s, size_t len) {\n    if (len == 3 && memcmp(s, \"GET\",  3) == 0) return METHOD_GET;\n    if (len == 4 && memcmp(s, \"HEAD\", 4) == 0) return METHOD_HEAD;\n    if (len == 4 && memcmp(s, \"POST\", 4) == 0) return METHOD_POST;\n    return METHOD_UNKNOWN;\n}\n// Parse \"HTTP/1.X\" version string.\n// Returns HTTP minor version (0 or 1), or -1 on invalid format.\nstatic int parse_http_version(const char *s, size_t len) {\n    // Must be exactly \"HTTP/1.X\" â€” 8 characters\n    if (len != 8) return -1;\n    if (memcmp(s, \"HTTP/1.\", 7) != 0) return -1;\n    if (s[7] == '0') return 0;\n    if (s[7] == '1') return 1;\n    return -1;\n}\n// Parse the HTTP request line into the request struct.\n// `line` is a null-terminated string with the trailing CRLF already stripped.\n// Returns 0 on success, an HTTP status code on failure (400, 414, 501).\nint parse_request_line(const char *line, http_request_t *req) {\n    // Find first space (separates method from path)\n    const char *path_start = strchr(line, ' ');\n    if (path_start == NULL) return 400;  // No space found: malformed\n    size_t method_len = (size_t)(path_start - line);\n    path_start++;  // Skip the space\n    // Find second space (separates path from version)\n    const char *version_start = strchr(path_start, ' ');\n    if (version_start == NULL) return 400;  // No version: malformed\n    size_t path_len = (size_t)(version_start - path_start);\n    version_start++;  // Skip the space\n    // Check for extra spaces (method SP path SP version â€” exactly one space each)\n    if (memchr(line, ' ', method_len) != NULL) return 400;\n    // Validate and store method\n    req->method = parse_method(line, method_len);\n    if (req->method == METHOD_UNKNOWN) return 501;  // 501 Not Implemented\n    // Validate path length before copying\n    if (path_len == 0)              return 400;  // Empty path\n    if (path_len >= MAX_PATH_LEN)   return 414;  // URI Too Long\n    // Copy path and null-terminate\n    memcpy(req->path, path_start, path_len);\n    req->path[path_len] = '\\0';\n    // Validate HTTP version\n    size_t version_len = strlen(version_start);\n    req->http_minor = parse_http_version(version_start, version_len);\n    if (req->http_minor < 0) return 400;  // Unknown version\n    return 0;  // Success\n}\n```\nWalk through the design choices:\n**`memcmp()` for method comparison, not `strcmp()`.** `strcmp()` works on null-terminated strings, which means it keeps reading until it hits `'\\0'`. `memcmp()` with an explicit length is both safer (bounded) and faster (the compiler can often reduce it to a 3-byte or 4-byte integer comparison).\n**`strchr()` to find delimiters.** We use `strchr()` to find the first space (method/path boundary) and second space (path/version boundary). This is cleaner than `strtok()`, which has the critical flaw of modifying its input â€” `strtok()` replaces each delimiter with `'\\0'`, which would corrupt our original buffer.\n**Method not in our list â†’ 501, not 400.** RFC 7231 specifies: \"The server SHOULD respond with a 501 (Not Implemented) status code\" for methods it doesn't implement, and \"400 (Bad Request)\" for malformed requests. The distinction matters for HTTP compliance. A `PATCH` request is a valid method â€” just not one we implement. A `   ` (spaces only) \"method\" is not valid at all.\n**414 for oversized URI.** The 414 status code means \"URI Too Long.\" RFC 7230 recommends that servers respond with 414 when the request-target is longer than any URI the server is willing to process. Our limit of 8KB (8192 bytes) matches nginx's default and is a reasonable bound.\n### Step 2: Parse Headers\nHeaders are more complex than the request line because there are many of them, they have optional whitespace, their names are case-insensitive, and we need to extract specific ones (Host, Content-Length, Connection) while storing the rest for later use.\n\n![Header Name Case Insensitivity â€” The Trap](./diagrams/diag-m2-case-insensitive-headers.svg)\n\n```c\n// Convert a string to lowercase in-place.\n// This is how we normalize header names for case-insensitive comparison.\nstatic void str_to_lower(char *s) {\n    for (; *s; ++s) {\n        if (*s >= 'A' && *s <= 'Z') {\n            *s = (char)(*s + 32);\n        }\n    }\n}\n// Strip leading and trailing OWS (Optional WhiteSpace: space and tab)\n// from `s`, writing null-terminated result into `out` (max `out_size` bytes).\n// Returns 0 on success, -1 if result doesn't fit.\nstatic int strip_ows(const char *s, char *out, size_t out_size) {\n    // Skip leading whitespace\n    while (*s == ' ' || *s == '\\t') s++;\n    // Find end of string\n    size_t len = strlen(s);\n    // Strip trailing whitespace\n    while (len > 0 && (s[len-1] == ' ' || s[len-1] == '\\t')) len--;\n    // Check it fits\n    if (len >= out_size) return -1;\n    memcpy(out, s, len);\n    out[len] = '\\0';\n    return 0;\n}\n// Parse a single header line \"Name: Value\" (CRLF already stripped).\n// Stores the result in req->headers[req->header_count] and increments header_count.\n// Returns 0 on success, -1 on malformed header (skip it), -2 on too many headers.\nint parse_header_line(const char *line, http_request_t *req) {\n    if (req->header_count >= MAX_HEADERS) return -2;\n    // Find the colon separating name from value\n    const char *colon = strchr(line, ':');\n    if (colon == NULL) return -1;  // No colon: malformed, skip\n    size_t name_len = (size_t)(colon - line);\n    if (name_len == 0) return -1;  // Empty header name: malformed, skip\n    if (name_len >= sizeof(req->headers[0].name)) return -1;  // Name too long\n    http_header_t *h = &req->headers[req->header_count];\n    // Copy header name and lowercase it for case-insensitive storage\n    memcpy(h->name, line, name_len);\n    h->name[name_len] = '\\0';\n    str_to_lower(h->name);\n    // Strip OWS from value (everything after the colon)\n    const char *value_raw = colon + 1;\n    if (strip_ows(value_raw, h->value, sizeof(h->value)) < 0) {\n        return -1;  // Value too long\n    }\n    req->header_count++;\n    return 0;\n}\n// Look up a header by name (already lowercase).\n// Returns pointer to header value string, or NULL if not found.\nconst char *request_get_header(const http_request_t *req, const char *name) {\n    for (int i = 0; i < req->header_count; i++) {\n        if (strcmp(req->headers[i].name, name) == 0) {\n            return req->headers[i].value;\n        }\n    }\n    return NULL;\n}\n```\nThe `str_to_lower()` function deserves attention. We're converting only ASCII letters (`A`â€“`Z` â†’ `a`â€“`z`). The conversion is `c + 32` because in ASCII, uppercase letters are exactly 32 positions before their lowercase equivalents (e.g., `'A'` is 65, `'a'` is 97). This is faster than `tolower()` from `<ctype.h>` because `tolower()` checks locale settings at runtime. HTTP header names are defined as ASCII-only in RFC 7230, so locale-independence isn't a concern here.\nThe `request_get_header()` function performs a linear search through the headers array. With at most 32 headers, this is O(32) â€” effectively O(1). We're calling this function a handful of times per request for specific headers (Host, Content-Length, Connection). A hash table would be faster asymptotically but adds significant complexity for negligible real-world benefit at this scale.\n### Step 3: Post-Processing â€” Extract Semantic Headers\nAfter parsing all header lines, we need to extract the ones that control connection behavior and body reading:\n```c\n// After parsing all headers, extract semantic fields into the request struct.\n// Call this once after the header loop completes.\nvoid extract_semantic_headers(http_request_t *req) {\n    // Content-Length: controls body reading\n    const char *cl = request_get_header(req, \"content-length\");\n    if (cl != NULL) {\n        char *end;\n        long val = strtol(cl, &end, 10);\n        // Valid if: all characters consumed, non-negative, not astronomically large\n        if (*end == '\\0' && val >= 0 && val <= (64 * 1024 * 1024)) {\n            req->content_length = (int)val;\n        } else {\n            req->content_length = -1;  // Invalid Content-Length: treat as absent\n        }\n    } else {\n        req->content_length = -1;\n    }\n    // Connection: keep-alive semantics\n    // HTTP/1.1 default is keep-alive; HTTP/1.0 default is close\n    const char *conn = request_get_header(req, \"connection\");\n    if (req->http_minor == 1) {\n        // HTTP/1.1: default keep-alive, unless \"Connection: close\"\n        req->keep_alive = (conn == NULL || strcasecmp(conn, \"close\") != 0) ? 1 : 0;\n    } else {\n        // HTTP/1.0: default close, unless \"Connection: keep-alive\"\n        req->keep_alive = (conn != NULL && strcasecmp(conn, \"keep-alive\") == 0) ? 1 : 0;\n    }\n}\n```\n**`strtol()` for Content-Length, not `atoi()`.** `atoi()` has no error detection â€” if the input is `\"abc\"` or `\"\"`, it returns 0 without any indication of failure. `strtol()` sets an end pointer: if `*end != '\\0'` after the call, there were non-numeric characters. We also cap at 64MB â€” a server serving static HTML and CSS files has no business reading a 4GB request body. This limit prevents a slow client from sending `Content-Length: 9999999999` and holding your connection open while trickling bytes.\n**`strcasecmp()` for `Connection` values.** Header *names* we normalize to lowercase ourselves. Header *values* may be any case â€” the spec says method tokens and header values are case-insensitive where defined. `Connection: Close`, `Connection: CLOSE`, and `Connection: close` are all valid. `strcasecmp()` (POSIX) handles this. On Windows you'd use `_stricmp()` â€” worth knowing if you ever port this code.\n---\n## Assembling the Full Parser\nNow put the pieces together into a single function that takes the raw buffer from Milestone 1 and returns a populated `http_request_t`:\n```c\n// Parse a complete HTTP request from `buf` (null-terminated, total `buf_len` bytes).\n// `header_end` is the offset just past the \\r\\n\\r\\n delimiter (from Milestone 1's reader).\n// Fills `req` on success.\n// Returns 0 on success, HTTP status code on failure (400, 414, 501).\nint parse_http_request(const char *buf, size_t buf_len, int header_end,\n                       http_request_t *req) {\n    memset(req, 0, sizeof(*req));\n    req->content_length = -1;\n    // --- Line iterator ---\n    // We'll walk through the buffer line by line.\n    // A line ends with \\n (we'll strip any preceding \\r).\n    const char *cursor = buf;\n    const char *buf_end = buf + header_end;  // Don't go past headers\n    int line_number = 0;\n    char line_buf[8192];  // Scratch buffer for one line\n    while (cursor < buf_end) {\n        // Find end of this line\n        const char *line_end = memchr(cursor, '\\n', (size_t)(buf_end - cursor));\n        if (line_end == NULL) break;  // No newline found, stop\n        size_t line_len = (size_t)(line_end - cursor);\n        // Strip trailing \\r if present (handle both CRLF and LF)\n        if (line_len > 0 && cursor[line_len - 1] == '\\r') {\n            line_len--;\n        }\n        // Blank line = end of headers (shouldn't happen since we stop at header_end,\n        // but guard anyway)\n        if (line_len == 0) {\n            cursor = line_end + 1;\n            continue;\n        }\n        // Copy line into scratch buffer for safe manipulation\n        if (line_len >= sizeof(line_buf)) return 400;  // Line too long\n        memcpy(line_buf, cursor, line_len);\n        line_buf[line_len] = '\\0';\n        if (line_number == 0) {\n            // First line: request line\n            int err = parse_request_line(line_buf, req);\n            if (err != 0) return err;\n        } else {\n            // Subsequent lines: header fields\n            // Silently skip malformed headers (RFC 7230 permits this)\n            parse_header_line(line_buf, req);\n        }\n        line_number++;\n        cursor = line_end + 1;\n    }\n    if (line_number == 0) return 400;  // No request line at all\n    // Validate required HTTP/1.1 headers\n    if (req->http_minor == 1) {\n        const char *host = request_get_header(req, \"host\");\n        if (host == NULL) return 400;  // Host header required in HTTP/1.1\n    }\n    // Extract semantic fields from headers\n    extract_semantic_headers(req);\n    // Set body pointer if Content-Length present\n    if (req->content_length > 0) {\n        req->body = buf + header_end;  // Body starts right after headers\n        // Note: we don't read the body here â€” it may not be in the buffer yet.\n        // Body reading is handled by the caller with a separate read loop.\n    }\n    return 0;  // Success\n}\n```\nSeveral design decisions here:\n**Line copying into `line_buf`.** We copy each line into a temporary scratch buffer before parsing it. This protects the original buffer from modification and gives `parse_request_line()` and `parse_header_line()` a null-terminated string to work with. It costs one `memcpy()` per line (~100â€“500 bytes). For an HTTP server handling thousands of short requests, this is negligible. For a system parsing gigabytes of HTTP traffic (an API gateway or load balancer), you'd investigate zero-copy approaches â€” but that's the optimization ladder for later.\n**Silently skip malformed headers.** RFC 7230 says: \"A server that receives an obs-fold in a request message that is not within a `message/http` container MUST either reject the message [...] or replace each received obs-fold with one or more SP octets.\" The general principle is that a receiver may choose to be lenient with headers it doesn't understand while being strict with the request line and Host header. We silently skip malformed header lines with a negative return from `parse_header_line()` â€” they don't cause a 400.\n**Host header is required in HTTP/1.1.** RFC 7230 Section 5.4: \"A client MUST send a Host header field in all HTTP/1.1 request messages.\" A server \"MUST respond with a 400 (Bad Request) status code to any HTTP/1.1 request message that lacks a Host header field.\" We enforce this. HTTP/1.0 requests don't require Host, which is why we only check it when `http_minor == 1`.\n---\n## Error Responses\n\n![Error Response Decision Tree](./diagrams/diag-m2-error-response-flow.svg)\n\nSending the right error response is part of the HTTP contract. Clients â€” especially automated ones â€” use status codes to decide what to do next. A browser receiving 400 won't retry; a proxy receiving 503 will retry with exponential backoff. Get the codes right.\n```c\n// Send a simple HTTP error response with status code and HTML body.\n// `client_fd` is the connection socket.\n// `status_code` is e.g. 400, 404, 501.\n// `reason` is the reason phrase, e.g. \"Bad Request\".\n// `body` is a short HTML message body.\nvoid send_error_response(int client_fd, int status_code,\n                         const char *reason, const char *body) {\n    char buf[2048];\n    int body_len = (int)strlen(body);\n    time_t now = time(NULL);\n    struct tm *gmt = gmtime(&now);\n    char date_str[64];\n    strftime(date_str, sizeof(date_str), \"%a, %d %b %Y %H:%M:%S GMT\", gmt);\n    int n = snprintf(buf, sizeof(buf),\n        \"HTTP/1.1 %d %s\\r\\n\"\n        \"Content-Type: text/html; charset=utf-8\\r\\n\"\n        \"Content-Length: %d\\r\\n\"\n        \"Date: %s\\r\\n\"\n        \"Connection: close\\r\\n\"\n        \"\\r\\n\"\n        \"%s\",\n        status_code, reason, body_len, date_str, body);\n    if (n > 0 && (size_t)n < sizeof(buf)) {\n        write_all(client_fd, buf, (size_t)n);\n    }\n    // Even if write fails, we close the fd in the caller â€” no resource leak\n}\n// Convenience function: send a 400 Bad Request\nvoid send_400(int client_fd) {\n    send_error_response(client_fd, 400, \"Bad Request\",\n        \"<html><body><h1>400 Bad Request</h1>\"\n        \"<p>The server could not understand the request.</p>\"\n        \"</body></html>\");\n}\n// Convenience function: send a 501 Not Implemented\nvoid send_501(int client_fd) {\n    send_error_response(client_fd, 501, \"Not Implemented\",\n        \"<html><body><h1>501 Not Implemented</h1>\"\n        \"<p>The server does not support this HTTP method.</p>\"\n        \"</body></html>\");\n}\n// Convenience function: send a 414 URI Too Long\nvoid send_414(int client_fd) {\n    send_error_response(client_fd, 414, \"URI Too Long\",\n        \"<html><body><h1>414 URI Too Long</h1>\"\n        \"<p>The requested URI exceeds the server's limit.</p>\"\n        \"</body></html>\");\n}\n```\nMap the error codes to their triggers:\n| Status Code | Trigger | RFC Reference |\n|-------------|---------|---------------|\n| `400 Bad Request` | Malformed request line, missing Host header in HTTP/1.1, invalid Content-Length | RFC 7230 Â§3.1.1 |\n| `414 URI Too Long` | Request-target exceeds 8192 bytes | RFC 7231 Â§6.5.12 |\n| `501 Not Implemented` | HTTP method is syntactically valid but unrecognized | RFC 7231 Â§6.6.2 |\n---\n## HEAD Requests: Same Headers, No Body\n\n![GET vs HEAD â€” Same Headers, No Body](./diagrams/diag-m2-head-vs-get.svg)\n\nThe HEAD method is semantically identical to GET except the server returns all the same headers but omits the response body. This is defined in RFC 7231 Section 4.3.2: \"The HEAD method is identical to GET except that the server MUST NOT send a message body in the response.\"\nWhy does HEAD exist? Two primary use cases:\n- **Cache validation**: a client that cached a file can send HEAD to check if the `Last-Modified` or `ETag` changed, without downloading the full file.\n- **Resource existence checks**: check if a URL returns 200 or 404 without paying for the transfer bandwidth.\nThe implementation consequence for your server: in Milestone 3, where you actually serve files, the file-serving logic will look like this:\n```c\n// In your file-serving handler (preview â€” implemented in Milestone 3):\n// Build the response headers the same way for both GET and HEAD.\n// Then:\nif (req->method != METHOD_HEAD) {\n    // Only send the body for GET requests\n    send_file_body(client_fd, file_fd, file_size);\n}\n// For HEAD, we fall through â€” headers were already sent, no body.\n```\nRight now, in Milestone 2's parser, all you need to do is correctly identify HEAD and store it as `METHOD_HEAD`. The body-suppression logic lives in the response path, not the parser. The parser's job is faithfully representing what the client asked for; the responder decides what to send back.\n---\n## Reading the Request Body\nFor POST requests (and future methods like PUT and PATCH), the body appears after the blank line, and its length is specified by `Content-Length`. Reading the body is a separate step from reading the headers, because:\n1. The body may not have arrived by the time you parse the headers\n2. The body can be large â€” potentially megabytes â€” requiring its own loop\n3. For GET and HEAD, there is no body to read\nHere's the body reading function:\n```c\n// Read exactly `content_length` bytes of request body from `client_fd`\n// into `body_buf` (which must be at least content_length+1 bytes).\n// `already_read` is any body bytes that arrived in the header read (rare but possible).\n// Returns 0 on success, -1 on error or client disconnect.\nint read_request_body(int client_fd, char *body_buf, int content_length,\n                      const char *overflow, int overflow_len) {\n    if (content_length <= 0) return 0;\n    // Some body bytes may have arrived in the initial read, after the \\r\\n\\r\\n\n    // Copy those first if present\n    int already = overflow_len > content_length ? content_length : overflow_len;\n    if (already > 0) {\n        memcpy(body_buf, overflow, (size_t)already);\n    }\n    int remaining = content_length - already;\n    int total = already;\n    while (remaining > 0) {\n        ssize_t n = read(client_fd, body_buf + total, (size_t)remaining);\n        if (n <= 0) return -1;  // Disconnect or error\n        total += (int)n;\n        remaining -= (int)n;\n    }\n    body_buf[content_length] = '\\0';\n    return 0;\n}\n```\nThe `overflow` parameter handles a subtle case: if the client sent a small request body and it arrived in the same `recv()` call as the headers (common on localhost), your Milestone 1 read loop may have already read part or all of the body into the header buffer. The bytes after the `\\r\\n\\r\\n` offset are \"overflow\" body bytes. We copy them first, then read the remainder from the socket.\nFor this milestone, you'll likely only implement GET and HEAD, so body reading is forward-looking infrastructure. But building the function now means Milestone 3 can simply call it without revisiting the parsing layer.\n---\n## Integration: Wiring the Parser into the Accept Loop\nHere's how the parser integrates with the accept loop from Milestone 1. Replace the minimal handling in `main()`:\n```c\n// Updated connection handler â€” replaces the inner block of the accept loop\nvoid handle_connection(int client_fd) {\n    char req_buf[REQUEST_BUF_SIZE];\n    int header_end = -1;\n    // Phase 1: Read raw bytes until \\r\\n\\r\\n (from Milestone 1)\n    ssize_t bytes_read = read_http_request(client_fd, req_buf,\n                                           REQUEST_BUF_SIZE, &header_end);\n    if (bytes_read < 0 || header_end < 0) {\n        // Client disconnected or request too large\n        close(client_fd);\n        return;\n    }\n    // Phase 2: Parse the raw buffer\n    http_request_t req;\n    int parse_err = parse_http_request(req_buf, (size_t)bytes_read,\n                                       header_end, &req);\n    if (parse_err != 0) {\n        // Parser returned an HTTP error code\n        switch (parse_err) {\n            case 400: send_400(client_fd); break;\n            case 414: send_414(client_fd); break;\n            case 501: send_501(client_fd); break;\n            default:  send_400(client_fd); break;\n        }\n        close(client_fd);\n        return;\n    }\n    // Phase 3: Log the parsed request\n    const char *method_names[] = {\"GET\", \"HEAD\", \"POST\", \"UNKNOWN\"};\n    printf(\"[%s] %s (HTTP/1.%d)\\n\",\n           method_names[req.method], req.path, req.http_minor);\n    const char *host = request_get_header(&req, \"host\");\n    if (host) printf(\"  Host: %s\\n\", host);\n    // Phase 4: Dispatch (Milestone 3 will add real file serving here)\n    // For now, send the same hardcoded response as Milestone 1\n    char resp_buf[MAX_RESPONSE_SIZE];\n    int resp_len = build_hardcoded_response(resp_buf, sizeof(resp_buf));\n    if (resp_len > 0) {\n        // For HEAD requests: send only headers, no body\n        // Temporarily: we send the whole thing and fix it in Milestone 3\n        write_all(client_fd, resp_buf, (size_t)resp_len);\n    }\n    close(client_fd);\n}\n```\nThe three-phase structure â€” read, parse, dispatch â€” is the architecture you'll carry through Milestones 3 and 4. Each phase has a clear responsibility and returns a clear signal. Phase 1 gives you bytes; phase 2 gives you structure; phase 3 gives you behavior.\n---\n## Testing the Parser\nManual testing with curl and telnet verifies the happy path. For a parser that handles adversarial input, you need to test the error paths too.\n```bash\n# Test 1: Valid GET request (should succeed)\ncurl -v http://localhost:8080/index.html\n# Test 2: HEAD request (should receive headers only, no body)\ncurl -v -X HEAD http://localhost:8080/index.html\n# Test 3: Unsupported method â†’ 501\ncurl -v -X DELETE http://localhost:8080/index.html\n# Test 4: Missing HTTP version â†’ 400\n# (telnet lets you type raw HTTP manually)\ntelnet localhost 8080\nGET /                    # â† just press Enter (no HTTP version)\nHost: localhost\n# Test 5: No Host header in HTTP/1.1 â†’ 400\nprintf \"GET / HTTP/1.1\\r\\n\\r\\n\" | nc localhost 8080\n# Test 6: Very long URI â†’ 414\n# Generate an 8KB+ URI and send it\npython3 -c \"print('GET /' + 'a'*8200 + ' HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n', end='')\" | nc localhost 8080\n# Test 7: Bare LF instead of CRLF (should still work)\nprintf \"GET / HTTP/1.1\\nHost: localhost\\n\\n\" | nc localhost 8080\n# Test 8: Case-insensitive headers (should work)\ncurl -v -H \"CONTENT-TYPE: text/plain\" http://localhost:8080/\n# Server should log \"content-type: text/plain\" (normalized lowercase)\n```\nFor Test 5 (`printf` with no Host header): you'll see the `printf` output piped to `nc` (netcat), which sends the raw bytes to your server. The `\\r\\n` in the `printf` format string is interpreted by the shell, so you get actual CRLF bytes. This is a reliable way to send hand-crafted HTTP requests without a browser normalizing them.\nVerify FD leak behavior remains clean after error-path connections:\n```bash\n# Send 100 malformed requests and check FD count doesn't grow\nfor i in $(seq 100); do\n    printf \"INVALID\\r\\n\\r\\n\" | nc -q1 localhost 8080 2>/dev/null\ndone\nls /proc/$(pgrep http_server)/fd | wc -l\n```\n---\n## Hardware Soul: What the CPU Does During Parsing\nThe HTTP parser is the most CPU-intensive component of a simple HTTP server. Let's look at what the hardware is actually doing.\n**Memory access pattern â€” buffer locality.** Your entire HTTP request (typically 200â€“2000 bytes) fits in L1 cache (32â€“64KB on modern CPUs). Every call to `strchr()`, `memcmp()`, and `memcpy()` within the parse is operating on L1-resident data. L1 access latency is ~1ns. The entire parse of a typical request takes a few microseconds â€” fast enough that parsing is never the bottleneck in a well-implemented server.\n**Branch prediction during `str_to_lower()`.** The character-by-character lowercase conversion in `str_to_lower()` has a branch: `if (*s >= 'A' && *s <= 'Z')`. In HTTP header names like `Content-Type`, the characters alternate between uppercase (first letter of each word) and lowercase. The branch predictor has a hard time here â€” the pattern is irregular. Modern CPUs handle this with a trick: the compiler often generates **SIMD instructions** for short string operations, processing 16 bytes at once with SSE/AVX. The trick: `_mm_sub_epi8` to subtract 'A', compare against 26 (the range of uppercase letters), and conditionally add 32 â€” all in one instruction on 16 bytes simultaneously. If you enable `-O2` optimization in GCC, the compiler may do this automatically.\n**`strchr()` implementation.** The `strchr()` call to find the colon in a header line like `Content-Type: text/html` scans up to ~15 bytes. The glibc implementation uses SIMD to scan 16 or 32 bytes at a time. For a 15-byte scan, the SIMD overhead isn't worth it, and glibc falls back to a byte loop. But for longer strings (long header values), SIMD `strchr()` is measurably faster.\n**Cache line granularity of the struct.** Your `http_request_t` struct is large â€” with `MAX_HEADERS = 32` entries of `(256 + 8192)` bytes each, the struct approaches 270KB. That won't fit in L1 or L2 cache. However, you only access a handful of headers in practice (Host, Content-Length, Connection), and those are the first few entries in the array. **The parser should fill headers in order of appearance**, so the most-accessed headers (which tend to appear early in real requests) are in the earliest array slots â€” resident in the \"hot\" part of the cache.\nThis is why the earlier design note about fixed arrays matters: a linked list of dynamically-allocated header nodes would scatter them across the heap, causing cache misses when iterating. The contiguous array keeps all headers in a predictable, prefetch-friendly layout.\n---\n## Three-Level View: Parsing a Header Line\nTake `\"Content-Type: text/html\"` and trace it through all three levels.\n**Level 1 â€” Your code:**\n`parse_header_line(\"Content-Type: text/html\", &req)` runs. `strchr()` finds the colon at offset 12. `memcpy()` copies \"Content-Type\" into `h->name`. `str_to_lower()` converts it to \"content-type\". `strip_ows()` copies \"text/html\" into `h->value`. `req->header_count` increments.\n**Level 2 â€” OS/Kernel:**\nNo syscalls during parsing. The bytes are already in your process's user-space buffer â€” the kernel handed them to you when `read()` returned. The OS scheduler may preempt your process during the parse if a higher-priority process needs to run, but this is transparent. From the kernel's perspective, you're just a user-space process doing arithmetic on memory.\n**Level 3 â€” Hardware:**\nThe CPU is executing integer instructions on cache-resident data. `strchr()` may be vectorized by the compiler/glibc to use SSE4.2's `PCMPEQB` instruction, which compares 16 bytes against the colon character in a single clock cycle. `memcpy()` for 12 bytes compiles to a few register moves â€” no separate loop. `str_to_lower()` for 12 characters executes 12 iterations of the loop, each testing two conditions and conditionally adding 32. With branch prediction warm (the alternating upper/lower pattern is learnable after a few iterations), mispredictions are rare. Total hardware cost: ~50â€“100 clock cycles, ~25ns at 2GHz.\n---\n## Design Decisions: Parser Architecture\n| Approach | Pros | Cons | Used By |\n|----------|------|------|---------|\n| **Line-at-a-time (this project) âœ“** | Simple, correct, debuggable | Two passes (find newlines, then parse) | Many simple HTTP servers |\n| Byte-state-machine | Single pass, handles partial reads elegantly, easily pausable | Complex to write and debug | nginx, h2o, Hyper (Rust) |\n| Regex-based | Very concise, declarative | Slow, security-sensitive regex edge cases | Python's `http.server` |\n| `sscanf()`-based | Simple to write | No error recovery, buffer overflow risk | Student projects |\nnginx uses a hand-written byte-level state machine â€” every byte transitions a `state` enum. This lets nginx parse across partial reads without accumulating a complete buffer first: you can call the parser with 50 bytes, pause, receive 50 more bytes, and resume. For our server, the line-at-a-time approach is correct because we accumulate the complete headers in Milestone 1's read loop before parsing. The state machine approach would be the next optimization if we needed to support very large headers or streaming HTTP/2 frames.\n---\n## Knowledge Cascade: What This Unlocks\nUnderstanding HTTP request parsing at this level opens five doors.\n### 1. State Machines for Protocol Parsing â€” Universal Pattern\nThe state-machine mental model you're building here is the same one used in every protocol parser ever written. JSON parsers (the JSON spec is a state machine over Unicode characters). SQL lexers (keywords, identifiers, string literals, operators â€” each a state). Compiler front-ends (tokenization is a state machine over source characters; parsing is a state machine over tokens). TLS record layer parsing. DNS wire format parsing. The moment you internalize \"a protocol is a grammar, a parser is a state machine over that grammar, and every input byte drives a transition,\" you can read any protocol RFC and design a parser for it.\n### 2. Case-Insensitive Comparison â€” Appearances Across Domains\nThe case-insensitivity problem you just solved in HTTP header names appears everywhere:\n- **SQL**: column names and keywords (`SELECT` = `select` = `SeLeCt`). Database engines normalize identifiers on parse, exactly as you did with `str_to_lower()`.\n- **DNS**: domain names are case-insensitive (`Example.COM` = `example.com`). DNS resolvers canonicalize to lowercase before lookup.\n- **Windows/macOS filesystems**: paths are case-insensitive but case-preserving (`README.md` and `readme.md` refer to the same file). This is why your Milestone 3 path security code must be careful about case normalization.\n- **Email headers** (MIME): `From:`, `To:`, `Subject:` are case-insensitive, just like HTTP.\nThe general principle: **normalize at ingestion, compare at the canonical form**. One conversion, many cheap comparisons â€” that's the right tradeoff.\n### 3. Security Through Input Validation â€” Transfer to Injection Prevention\nEvery security vulnerability begins with trusting input format. The disciplines you're building here â€” check length before copying, validate charset before using the value, reject on unexpected characters, apply allow-lists rather than block-lists â€” transfer directly to:\n- **SQL injection prevention**: validating query parameters before interpolation into SQL strings\n- **XSS prevention**: validating and escaping HTML-context strings before rendering\n- **Path traversal prevention** (which you'll build in Milestone 3): validating paths against a root before passing to `open()`\n- **Format string vulnerabilities**: never passing user-controlled input as the format string to `printf()`\nThe mental model: **treat all input as adversarial until proven safe**. Your parser proves safety by checking length, checking charset, checking structure, and rejecting anything that doesn't match the spec. Code that assumes \"the client will send valid input\" is code that will eventually run in a security incident postmortem.\n### 4. Zero-Copy Parsing â€” nginx's Secret Weapon\nYou noticed that `body` in `http_request_t` is a `const char*` pointer into the original buffer, not a copy. This is the beginning of **zero-copy parsing**. nginx takes this much further: it never copies header names or values at all â€” it stores pairs of `{pointer, length}` (called `ngx_str_t`) that point directly into the receive buffer. Header name \"Content-Type\" in nginx is represented as a 12-byte pointer into the network buffer, not a separate 12-byte allocation.\nThe performance implication: parsing a 500-byte HTTP request in nginx involves zero `malloc()` calls for the headers themselves. Every `malloc()` call acquires a lock (in glibc's default allocator) and is unpredictable in latency. Eliminating them during parsing removes a major source of latency variance. This is why nginx can handle hundreds of thousands of requests per second on a single core.\nOnce you see why copying is expensive, you'll recognize `string_view` in C++, `&str` vs `String` in Rust, `bytes.Buffer` in Go, and Python's `memoryview` â€” all are language-level tools for \"refer to existing bytes without copying.\"\n### 5. The RFC As Primary Source â€” Reading Specifications\nYou've now implemented something directly against an RFC (RFC 7230). This skill â€” reading a standards document and translating its MUST/SHOULD/MAY language into code â€” is one of the most valuable engineering skills that textbooks rarely teach. The RFC tells you exactly when to return 400 vs. 501, exactly what OWS means, exactly which headers are required. Now that you've done this once, you can read RFC 7231 (HTTP semantics), RFC 7232 (conditional requests, which Milestone 3 needs), RFC 7234 (caching), and RFC 7235 (authentication) and know how to implement them. The same reading skill applies to the POSIX socket spec, the TLS 1.3 spec (RFC 8446), the JSON spec (RFC 8259), and any other protocol you encounter.\n---\n## Common Mistakes That Will Burn You\n**1. Using `strtok()` for anything in your parser.**\n`strtok()` modifies its input by replacing delimiters with `'\\0'`. It also uses global state, making it unsafe in any context where parsing might be interrupted or called from multiple threads. Use `strchr()`, `memchr()`, and explicit pointer arithmetic instead.\n**2. Case-sensitive header lookup.**\nThe single most common conformance bug: `request_get_header(&req, \"Content-Length\")` fails to find a header stored as `content-length`. Store lowercase at parse time, look up lowercase always. When in doubt, add a `DEBUG` assert that the name you're looking up is already lowercase.\n**3. Off-by-one in the CRLF check.**\nWhen stripping the trailing `\\r` before parsing a line: check `line_len > 0` *before* accessing `cursor[line_len - 1]`. Accessing `cursor[-1]` on an empty line is undefined behavior â€” and on a buffer that started at `buf[0]`, it reads the byte before your buffer.\n**4. Not validating Content-Length before reading body.**\nIf you accept `Content-Length: 9999999999` and try to `malloc()` that many bytes, you crash. If you try to `read()` that many bytes, you hold the connection open indefinitely. Apply a reasonable maximum (64MB for this server) and reject the request with 400 if the value exceeds it.\n**5. Forgetting bare LF handling.**\n`telnet` sends bare LF. `curl` with `--http1.0` on some platforms sends bare LF. Test 7 in the section above will fail on your server if you only strip `\\r\\n`. Your line-splitting code must handle both `\\r\\n` and `\\n`.\n**6. Not handling the \"no request line\" case.**\nAn empty connection â€” client connects and immediately disconnects â€” results in zero bytes read. Your parser receives an empty buffer. `parse_request_line()` on an empty string should return 400, not segfault chasing a `NULL` return from `strchr()`.\n---\n## Acceptance Criteria Checklist\nVerify each of these before moving to Milestone 3:\n- [ ] `curl http://localhost:8080/` logs `[GET] / (HTTP/1.1)` and `Host: localhost`\n- [ ] `curl -X HEAD http://localhost:8080/` is parsed as `METHOD_HEAD` (verify with log output)\n- [ ] `curl -X DELETE http://localhost:8080/` returns `HTTP/1.1 501 Not Implemented`\n- [ ] Malformed request `printf \"NOTHTTP\\r\\n\\r\\n\" | nc localhost 8080` returns `400 Bad Request`\n- [ ] Request with 8201-byte URI returns `414 URI Too Long`\n- [ ] HTTP/1.1 request missing `Host` header returns `400 Bad Request`\n- [ ] Bare-LF request (no `\\r`) is parsed correctly and returns `200 OK`\n- [ ] Header `CONTENT-TYPE: text/plain` is stored as `content-type: text/plain` (case-normalized)\n- [ ] Header value `Content-Type:  text/html  ` (extra spaces) has OWS stripped to `text/html`\n- [ ] FD count after 100 malformed requests equals FD count before (no leaks on error paths)\n- [ ] `request_get_header(&req, \"host\")` finds the Host header regardless of client's capitalization\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: http-server-basic-m3 -->\n# Milestone 3: Static File Serving\n## Where You Are in the System\nYour server can now accept TCP connections, read raw bytes off the socket, and parse those bytes into structured `http_request_t` data. You know the method, the path, the headers. Now for the first time, your server will do something *real* with that path: go to the filesystem, find a file, and send its contents back across the network.\n\n![HTTP Server Architecture â€” Satellite Map](./diagrams/diag-satellite-map.svg)\n\nThis is the milestone where your HTTP server earns the label \"web server.\" When this is done, you can point a browser at your server and see actual HTML, CSS, images, and JavaScript render correctly. Every file-serving feature a browser expects â€” correct content types, conditional caching, security boundaries â€” gets implemented here.\nThere is one challenge in this milestone that towers above all others in importance. It is not MIME type detection, not `304 Not Modified` handling, not directory index serving. It is **path security**. Get this wrong and your server is not a web server â€” it's a file exfiltration tool waiting to be exploited.\n---\n## The Revelation: String Prefix Checking Is Not Security\nHere is the mental model that almost every developer reaches for when they first think about directory traversal prevention:\n```c\n// \"Surely this is enough?\"\nif (strncmp(resolved_path, document_root, strlen(document_root)) == 0) {\n    // Path starts with the root, so it must be inside the root. Right?\n    serve_file(resolved_path);\n}\n```\nThis feels airtight. If the path starts with `/var/www/html`, it must be *inside* `/var/www/html`. The logic seems inescapable. Let's watch it get bypassed in five different ways.\n\n![Directory Traversal Attack Vectors â€” 5 Bypass Methods](./diagrams/diag-m3-traversal-attacks.svg)\n\n### Attack 1: The Classic `../` Traversal\nA browser requests: `GET /../../etc/passwd HTTP/1.1`\nYour Milestone 2 parser stores this in `req.path` as `/../../etc/passwd`. You prepend the document root:\n```\n/var/www/html + /../../etc/passwd = /var/www/html/../../etc/passwd\n```\nYour `strncmp` check runs: does `/var/www/html/../../etc/passwd` start with `/var/www/html`? **Yes, it does.** The string prefix check passes. You call `open(\"/var/www/html/../../etc/passwd\", O_RDONLY)` â€” which the kernel resolves as `/etc/passwd`. The contents of the system password file stream out across the network.\n### Attack 2: URL-Encoded Traversal\nHTTP allows percent-encoding in URIs. The character `.` is ASCII 0x2E, which can be encoded as `%2e`. The character `/` is ASCII 0x2F, which can be encoded as `%2f`. So `../` becomes `%2e%2e%2f`.\nA browser requests: `GET /%2e%2e%2fetc%2fpasswd HTTP/1.1`\nIf your parser stores the path without URL-decoding it, `strncmp` against the root might fail (the path doesn't look like it traverses). But when you concatenate and open, the kernel doesn't know about percent-encoding â€” it just opens the literal filename `%2e%2e%2fetc%2fpasswd`. Your server returns 404 (no such file). So percent-encoding actually harms the attacker here... unless your parser URL-decodes the path first. And a correct HTTP implementation *must* URL-decode the path before filesystem operations, because `%20` (space) is a legitimate encoding and `GET /my%20files/photo.jpg` must work. So the scenario is: your parser correctly URL-decodes `%2e%2e%2f` to `../`, and now you're back to Attack 1.\n### Attack 3: Symlink Bypass\nEven if the path looks clean â€” `/var/www/html/images/photo.jpg`, no dots, no traversal â€” a symlink can redirect you. If an attacker (or even a careless administrator) created a symbolic link:\n```bash\nln -s /etc /var/www/html/secret\n```\nThen `GET /secret/passwd HTTP/1.1` resolves as follows: your string prefix check sees `/var/www/html/secret/passwd`, which starts with `/var/www/html`. Check passes. You open it. The kernel follows the symlink: `/var/www/html/secret` points to `/etc`, so you open `/etc/passwd`.\n### Attack 4: Double Encoding\nSome buggy URL processors decode `%25` to `%` in a first pass, then decode `%2e` to `.` in a second pass. So `%252e%252e%252f` (where `%25` encodes a literal `%`) decodes to `../` after two passes. If your URL decoder makes multiple passes or if there's a secondary layer of decoding (e.g., in a proxy), this attack works.\n### Attack 5: Unicode Normalization\nOn case-insensitive filesystems (macOS HFS+, Windows NTFS), the path `/VAR/WWW/HTML/../../ETC/PASSWD` might resolve correctly even if your check is case-sensitive. Your prefix check fails (different case), you reject it â€” but had you been on a case-insensitive system and not normalized case, this would be an inconsistency to exploit.\n---\n### The Only Safe Approach: Canonicalize First, Check Second\nThe lesson from all five attacks is identical: **you cannot reason about path security by looking at the path string.** The path string is attacker-controlled input. The only trustworthy entity is the operating system's path resolver, which accounts for `..`, `.`, symlinks, and all other filesystem indirections.\nThe safe algorithm has exactly three steps, in exactly this order:\n```\n1. URL-decode the request path\n2. Canonicalize via realpath() â†’ get the true absolute filesystem path\n3. Check if the canonicalized path starts with the canonicalized document root\n```\n\n![URL Path â†’ Filesystem Path â€” The Resolution Pipeline](./diagrams/diag-m3-path-resolution-flow.svg)\n\n`realpath()` is the POSIX function that does everything the kernel does when resolving a path: it follows all symlinks, resolves all `.` and `..` components, and returns the absolute, canonical path. No matter how many layers of trickery an attacker stacks, `realpath()` returns what the kernel would actually open.\nHere is the critical constraint: `realpath()` requires the file to **exist**. If the file doesn't exist, `realpath()` returns `NULL` with `errno = ENOENT`. This means your path security check and your \"file exists\" check happen simultaneously â€” which is actually a feature, not a limitation.\n```c\n// URL-decode a percent-encoded string.\n// Writes decoded result into `out` (max `out_size` bytes including null terminator).\n// Returns 0 on success, -1 if `out` is too small or encoding is invalid.\nint url_decode(const char *src, char *out, size_t out_size) {\n    size_t i = 0;\n    size_t j = 0;\n    while (src[i] != '\\0') {\n        if (j + 1 >= out_size) return -1;  // Output buffer full\n        if (src[i] == '%') {\n            // Expect exactly two hex digits following %\n            if (src[i+1] == '\\0' || src[i+2] == '\\0') return -1;\n            char hex[3] = { src[i+1], src[i+2], '\\0' };\n            char *end;\n            long val = strtol(hex, &end, 16);\n            if (*end != '\\0') return -1;  // Non-hex characters\n            if (val == 0) return -1;      // Null byte injection: %00 is a classic attack\n            out[j++] = (char)val;\n            i += 3;\n        } else if (src[i] == '+') {\n            // '+' means space in application/x-www-form-urlencoded, but NOT in URI paths.\n            // In URI paths, '+' is a literal plus sign.\n            out[j++] = '+';\n            i++;\n        } else {\n            out[j++] = src[i++];\n        }\n    }\n    out[j] = '\\0';\n    return 0;\n}\n```\nNote the null byte check: `%00` decodes to ASCII 0, the null byte. In C, strings are null-terminated, so a path like `/etc/passwd%00.html` would pass extension-based MIME checking (looks like `.html`) but when the null byte is decoded, the resulting C string `\"/etc/passwd\\0.html\"` passes to `open()` as `\"/etc/passwd\"`. This attack has been used in real vulnerabilities. Rejecting `%00` is essential.\nNow the complete path resolution and security check:\n```c\n#define MAX_PATH_SIZE 4096  // PATH_MAX on Linux\n// Resolve a URL path to an absolute filesystem path, verifying it\n// stays within the document root.\n//\n// `url_path`      â€” the request path from http_request_t.path (e.g. \"/images/logo.png\")\n// `document_root` â€” canonicalized document root (from realpath() at startup)\n// `resolved_out`  â€” output buffer for the safe filesystem path (PATH_MAX bytes)\n//\n// Returns 0 on success (safe path in resolved_out).\n// Returns 403 if path escapes document root.\n// Returns 404 if path does not exist on the filesystem.\n// Returns 400 if path is malformed (URL decode failure, etc.).\nint resolve_safe_path(const char *url_path, const char *document_root,\n                      char *resolved_out) {\n    // Step 1: URL-decode the path\n    char decoded[MAX_PATH_SIZE];\n    if (url_decode(url_path, decoded, sizeof(decoded)) < 0) {\n        return 400;  // Malformed percent-encoding\n    }\n    // Step 2: Build the raw filesystem path by joining document_root + decoded_path.\n    // We're not checking security yet â€” this is just string concatenation.\n    char raw[MAX_PATH_SIZE * 2];\n    int n = snprintf(raw, sizeof(raw), \"%s%s\", document_root, decoded);\n    if (n < 0 || (size_t)n >= sizeof(raw)) {\n        return 400;  // Path too long\n    }\n    // Step 3: Canonicalize via realpath().\n    // This resolves all symlinks, .., ., and relative components.\n    // Returns NULL if the path does not exist on the filesystem.\n    char *canon = realpath(raw, resolved_out);\n    if (canon == NULL) {\n        // ENOENT = path doesn't exist â†’ 404\n        // EACCES = permission denied â†’ 403\n        // Other errors â†’ treat as 404 (don't leak internal details)\n        if (errno == ENOENT) return 404;\n        if (errno == EACCES) return 403;\n        return 404;\n    }\n    // Step 4: AFTER canonicalization, verify the resolved path is still\n    // inside the document root. This is the security check.\n    size_t root_len = strlen(document_root);\n    if (strncmp(resolved_out, document_root, root_len) != 0) {\n        // Path escaped the document root\n        return 403;\n    }\n    // Ensure it's either exactly the root or the next char is '/'\n    // (prevents matching /var/www-secret when root is /var/www)\n    char next = resolved_out[root_len];\n    if (next != '\\0' && next != '/') {\n        return 403;\n    }\n    return 0;  // Safe path is in resolved_out\n}\n```\nThe final check â€” `next != '\\0' && next != '/'` â€” prevents a subtle bypass. If your document root is `/var/www` and the resolved path is `/var/www-backup/passwords.txt`, a naive prefix check (`strncmp(resolved, root, root_len)`) would pass. Adding the check that the character after the root prefix must be `/` or end of string prevents this.\n**Initialize the document root at server startup**, not per-request:\n```c\n// In server initialization â€” run once when the server starts.\n// Pass this canonical_root to resolve_safe_path() for every request.\nchar canonical_root[MAX_PATH_SIZE];\nif (realpath(document_root_arg, canonical_root) == NULL) {\n    perror(\"realpath (document root)\");\n    exit(1);  // Can't serve files without a valid document root\n}\nprintf(\"Document root: %s\\n\", canonical_root);\n```\nRunning `realpath()` on the document root at startup canonicalizes it once. If the document root contains a symlink (e.g., `/var/www/html` â†’ `/data/www`), `canonical_root` will contain `/data/www` â€” the true path. Every per-request check then compares against this true path.\n---\n## Three-Level View: What Happens When You Open a File\nTake a request for `/images/photo.jpg` (100KB PNG image) and trace it through all three levels.\n\n![Three-Level View: Serving a 100KB PNG File](./diagrams/diag-m3-file-serving-three-level.svg)\n\n**Level 1 â€” Your code:**\nYou call `resolve_safe_path(\"/images/photo.jpg\", canonical_root, resolved)`, which calls `realpath()` and returns 0 with `resolved = \"/var/www/html/images/photo.jpg\"`. You call `stat(resolved, &st)` to get the file size and modification time. You call `open(resolved, O_RDONLY)` to get a file descriptor. You call `read(file_fd, buf, buf_size)` in a loop to fill your buffer. You call `write(client_fd, ...)` to send the data. You call `close(file_fd)`.\n**Level 2 â€” OS/Kernel:**\n`realpath()` is implemented in user-space (glibc) but calls multiple `lstat()` syscalls â€” one per path component â€” to check each component for symlinks. For `/var/www/html/images/photo.jpg`, that's approximately five `lstat()` calls.\n`open()` triggers the kernel's VFS (Virtual File System) layer. The kernel looks up the file in the directory entry cache (**dcache**) â€” if `/var/www/html/images` has been recently accessed, the directory entry is already in kernel memory (hot). The kernel also checks the **inode cache** (icache): the inode stores the file's metadata (size, permissions, timestamps). On a busy server, both caches are hot and `open()` returns in microseconds without touching disk.\n`read()` triggers the kernel's **page cache** lookup. The page cache is a portion of RAM that holds recently-read disk blocks. If `photo.jpg` was read recently, its pages are in the page cache and `read()` is just a `memcpy()` from kernel memory to your user-space buffer. If the file is cold (not cached), the kernel issues disk I/O â€” an asynchronous read from the block device â€” and your process blocks until the data arrives.\n**Level 3 â€” Hardware:**\nFor a cache-hot file: your `read()` triggers a context switch from user mode to kernel mode (the `read` syscall). The kernel finds the page cache entries for `photo.jpg`, copies them into your buffer via memory-to-memory copy. For a 100KB file, this is copying ~25 4KB pages. At memory bandwidth of ~20 GB/s (DDR4), 100KB copies in ~5 microseconds. Context switch overhead is ~1â€“2 microseconds. Total: ~7 microseconds for a cached read.\nFor a cold file: the kernel submits an I/O request to the storage controller. An NVMe SSD responds in ~100 microseconds; a spinning HDD in ~5 milliseconds. Your process is moved off the CPU runqueue into a \"waiting for I/O\" state. The CPU runs other processes. When the storage interrupt fires, the kernel moves your process back to runnable. This is the 10ms vs 100ns gap â€” 100,000Ã— difference between memory and disk â€” that the page cache exists to bridge.\n---\n## MIME Types: Telling Browsers How to Interpret Bytes\nRaw bytes have no intrinsic meaning. A sequence of bytes could be a UTF-8 HTML document, a JPEG image, a JavaScript program, or binary executable code. The browser has no way to tell which kind of content it received unless the server tells it. The **Content-Type header** carries this information.\n\n![File Extension â†’ MIME Type Mapping](./diagrams/diag-m3-mime-type-map.svg)\n\nMIME (**Multipurpose Internet Mail Extensions**) is a system originally designed for email attachments that HTTP adopted. A MIME type has the form `type/subtype`, optionally with parameters. `text/html; charset=utf-8` means \"the type is text, the subtype is HTML, and the character encoding is UTF-8.\" The browser uses this to decide whether to render HTML, display an image, execute JavaScript, or prompt a download dialog.\nGetting MIME types wrong causes real user-visible failures:\n- Serving `.js` files as `text/plain` causes browsers to refuse to execute the script (modern browsers block cross-origin scripts with wrong MIME types â€” **MIME-sniffing** protection)\n- Serving `.css` as `text/plain` causes browsers to ignore the stylesheet\n- Serving images as `application/octet-stream` causes download prompts instead of display\nThe cleanest implementation is a sorted array of `{extension, mime_type}` pairs that you search with binary search or a simple linear scan. With only ~15 extensions to support, linear scan is fast enough (15 comparisons, all L1-resident):\n```c\ntypedef struct {\n    const char *extension;   // e.g. \".html\" (with leading dot, lowercase)\n    const char *mime_type;   // e.g. \"text/html; charset=utf-8\"\n} mime_entry_t;\n// MIME type table â€” searched linearly, so order doesn't matter.\n// Extensions must be lowercase (we normalize before lookup).\nstatic const mime_entry_t MIME_TABLE[] = {\n    { \".html\", \"text/html; charset=utf-8\"       },\n    { \".htm\",  \"text/html; charset=utf-8\"       },\n    { \".css\",  \"text/css\"                        },\n    { \".js\",   \"application/javascript\"          },\n    { \".json\", \"application/json\"                },\n    { \".png\",  \"image/png\"                       },\n    { \".jpg\",  \"image/jpeg\"                      },\n    { \".jpeg\", \"image/jpeg\"                      },\n    { \".gif\",  \"image/gif\"                       },\n    { \".svg\",  \"image/svg+xml\"                   },\n    { \".txt\",  \"text/plain; charset=utf-8\"       },\n    { \".pdf\",  \"application/pdf\"                 },\n    { \".ico\",  \"image/x-icon\"                    },\n    { \".xml\",  \"application/xml\"                 },\n    { \".webp\", \"image/webp\"                      },\n};\nstatic const int MIME_TABLE_LEN =\n    (int)(sizeof(MIME_TABLE) / sizeof(MIME_TABLE[0]));\n// Look up the MIME type for a filesystem path.\n// Returns a MIME type string, or \"application/octet-stream\" as the fallback.\nconst char *mime_type_for_path(const char *path) {\n    // Find the last '.' in the filename component\n    const char *last_dot = strrchr(path, '.');\n    if (last_dot == NULL) {\n        return \"application/octet-stream\";\n    }\n    // Normalize extension to lowercase for comparison\n    char ext_lower[32];\n    size_t ext_len = strlen(last_dot);\n    if (ext_len >= sizeof(ext_lower)) {\n        return \"application/octet-stream\";  // Absurdly long extension\n    }\n    for (size_t i = 0; i < ext_len; i++) {\n        char c = last_dot[i];\n        ext_lower[i] = (c >= 'A' && c <= 'Z') ? (char)(c + 32) : c;\n    }\n    ext_lower[ext_len] = '\\0';\n    // Linear search â€” only ~15 entries, all in L1 cache\n    for (int i = 0; i < MIME_TABLE_LEN; i++) {\n        if (strcmp(ext_lower, MIME_TABLE[i].extension) == 0) {\n            return MIME_TABLE[i].mime_type;\n        }\n    }\n    return \"application/octet-stream\";  // Unknown extension: trigger download\n}\n```\n`strrchr()` (string reverse character-find) finds the *last* occurrence of a character in a string. For a path like `/var/www/html/styles/main.min.css`, there are two dots. We want the *last* one to get `.css`, not `.min`. Using `strrchr()` instead of `strchr()` handles this correctly.\n`application/octet-stream` is the correct MIME type for \"I don't know what this is.\" Browsers respond by presenting a download dialog, which is safer than trying to execute or display unknown binary content.\n---\n## Conditional Requests: If-Modified-Since and 304 Not Modified\nOnce you understand that browsers and CDNs cache files, a new problem emerges: how does a browser know if the cached copy is still fresh? It could send `GET /logo.png` every time a user visits the page â€” but that's wasteful if the image hasn't changed in months.\nHTTP solves this with **conditional requests**. The protocol defines a handshake:\n1. First request: server sends the file with a `Last-Modified` header indicating when the file was last changed\n2. Subsequent requests: client sends `If-Modified-Since: <timestamp>` asking \"has this changed since this time?\"\n3. If unchanged: server returns `304 Not Modified` with no body (just headers), saving bandwidth\n4. If changed: server returns `200 OK` with the new file\n{{DIAGRAM:diag-m3-conditional-request-flow}}\nThis optimization is significant in practice. For a page with 20 cacheable assets (CSS, JS, images), a returning visitor's browser might send 20 conditional requests. If none of the assets changed, all 20 get `304` responses. The browser loads the page entirely from cache â€” the responses contain no body bytes. Total bandwidth: a few kilobytes of headers vs. potentially megabytes of assets.\nThe filesystem gives you the modification time of every file through `stat()`. The `struct stat` field `st_mtim` (or `st_mtime` on some platforms) contains the last modification time as a Unix timestamp (seconds since January 1, 1970 UTC).\nThe HTTP `Last-Modified` and `If-Modified-Since` header format is **RFC 7231 HTTP-date format**: `\"Day, DD Mon YYYY HH:MM:SS GMT\"`. This is the same format we used for the `Date` header in Milestone 1.\n```c\n// Format a time_t as an HTTP-date string.\n// Writes into `buf` (at least 64 bytes).\n// Returns 0 on success, -1 on failure.\nint format_http_date(time_t t, char *buf, size_t buf_size) {\n    struct tm *gmt = gmtime(&t);\n    if (gmt == NULL) return -1;\n    size_t n = strftime(buf, buf_size, \"%a, %d %b %Y %H:%M:%S GMT\", gmt);\n    return (n > 0) ? 0 : -1;\n}\n// Parse an HTTP-date string back to time_t.\n// Returns the parsed time on success, (time_t)-1 on failure.\ntime_t parse_http_date(const char *date_str) {\n    struct tm tm;\n    memset(&tm, 0, sizeof(tm));\n    // strptime parses a date string according to a format, inverse of strftime.\n    // The %a (weekday), %d (day), %b (month name), %Y (year), %H:%M:%S (time)\n    // format matches the standard HTTP-date format.\n    const char *result = strptime(date_str, \"%a, %d %b %Y %H:%M:%S GMT\", &tm);\n    if (result == NULL || *result != '\\0') {\n        return (time_t)-1;  // Parse failed\n    }\n    // timegm() converts struct tm (in UTC/GMT) to time_t.\n    // mktime() assumes local time â€” WRONG for HTTP dates which are always UTC.\n    return timegm(&tm);\n}\n```\n`timegm()` is the inverse of `gmtime()`: it converts a `struct tm` interpreted as UTC into a `time_t`. **Do not use `mktime()` here.** `mktime()` interprets `struct tm` as local time â€” if your server is in a non-UTC timezone, `mktime()` will give you the wrong result, causing incorrect cache validation. HTTP dates are always UTC. `timegm()` is available on Linux and macOS (as a BSD extension); if you need full POSIX portability, set the `TZ` environment variable temporarily or use a manual calculation.\nNow the conditional request check:\n```c\n// Check whether a conditional GET/HEAD should return 304 Not Modified.\n// `file_mtime` is the file's last modification time (from stat).\n// `req` is the parsed HTTP request.\n// Returns 1 if 304 should be sent, 0 if the full response should be sent.\nint should_send_304(const http_request_t *req, time_t file_mtime) {\n    const char *ims = request_get_header(req, \"if-modified-since\");\n    if (ims == NULL) return 0;  // No conditional header: send full response\n    time_t client_time = parse_http_date(ims);\n    if (client_time == (time_t)-1) return 0;  // Can't parse: send full response\n    // The file has not been modified if its mtime <= the time the client\n    // says it last received the file. Use <= not <, because HTTP-date\n    // resolution is one second â€” a file modified in the same second as\n    // the If-Modified-Since timestamp is considered unchanged.\n    return (file_mtime <= client_time) ? 1 : 0;\n}\n```\nThe `<=` comparison handles the one-second granularity of HTTP-date format. If a file was modified at timestamp T, the server sends `Last-Modified: <T formatted to second precision>`. On the next request, the client sends `If-Modified-Since: <T>`. If you used `<` instead of `<=`, you'd send a full `200` response for a file modified at exactly the cached timestamp â€” wasting bandwidth and incorrectly indicating the file changed.\n---\n## Directory Requests and Index Files\nWhen a browser requests a URL ending in `/` â€” or a URL that maps to a directory â€” your server has a choice: list the directory contents (a **directory listing**), serve a default file, or refuse. Modern practice avoids directory listings in production (they expose file structure to attackers). The conventional behavior is:\n1. If the path maps to a directory and `index.html` exists inside it â†’ serve `index.html`\n2. If the path maps to a directory and `index.html` does not exist â†’ return 403 Forbidden\n3. If the path maps to a regular file â†’ serve it normally\n\n![Directory Request Handling â€” Decision Flowchart](./diagrams/diag-m3-directory-index-logic.svg)\n\nThe detection uses `stat()` and the `S_ISDIR()` macro:\n```c\n// Detect if a path is a directory and append \"/index.html\" if so.\n// Modifies `resolved_path` in-place (must have room for appending \"/index.html\").\n// Returns:\n//   0 = regular file, serve it\n//   1 = was a directory, index.html appended, re-stat needed\n//  -1 = directory with no index.html â†’ send 403\n//  -2 = stat() failed â†’ send 404\nint handle_directory_path(char *resolved_path, size_t path_buf_size,\n                          struct stat *st) {\n    if (!S_ISDIR(st->st_mode)) {\n        return 0;  // Regular file â€” serve directly\n    }\n    // It's a directory â€” try to append /index.html\n    size_t current_len = strlen(resolved_path);\n    const char *index_suffix = \"/index.html\";\n    size_t suffix_len = strlen(index_suffix);\n    if (current_len + suffix_len + 1 > path_buf_size) {\n        return -1;  // No room to append â€” refuse\n    }\n    // Ensure path doesn't already end with '/'\n    if (resolved_path[current_len - 1] == '/') {\n        // Overwrite the trailing slash\n        strncat(resolved_path + current_len - 1,\n                index_suffix, path_buf_size - current_len);\n    } else {\n        strncat(resolved_path + current_len,\n                index_suffix, path_buf_size - current_len - 1);\n    }\n    // Re-stat the index.html path\n    if (stat(resolved_path, st) < 0) {\n        if (errno == ENOENT) return -1;  // No index.html â†’ 403\n        return -2;  // Other error â†’ 404\n    }\n    if (S_ISDIR(st->st_mode)) {\n        return -1;  // index.html is itself a directory? â†’ 403\n    }\n    return 1;  // index.html found and stat'd â€” proceed to serve\n}\n```\n`S_ISDIR(st->st_mode)` â€” the `stat()` syscall fills a `struct stat` with file metadata. The `st_mode` field is a bitmask encoding both the file type and permission bits. `S_ISDIR()` is a POSIX macro that extracts the file-type bits and checks if they indicate a directory. Similarly, `S_ISREG()` checks for regular files, `S_ISLNK()` for symbolic links (though `stat()` follows symlinks automatically â€” use `lstat()` to detect symlinks without following them).\n---\n## The Complete File Serving Function\nNow assemble all the pieces into the function that handles an HTTP request end-to-end: path resolution â†’ security check â†’ directory handling â†’ conditional request check â†’ response assembly â†’ file transfer.\n\n![Complete HTTP Response Assembly â€” Byte by Byte](./diagrams/diag-m3-response-assembly.svg)\n\n```c\n// Send a complete HTTP error response (reused from Milestone 2)\n// â€” defined in your existing codebase.\nvoid send_error_response(int client_fd, int status_code,\n                         const char *reason, const char *body);\n// Send the complete HTTP response for a file request.\n// Handles GET and HEAD methods, conditional requests, all error cases.\n// `req`           â€” the parsed HTTP request (from Milestone 2)\n// `client_fd`     â€” the connection socket to write the response to\n// `canonical_root`â€” the server's canonicalized document root\nvoid serve_static_file(const http_request_t *req, int client_fd,\n                        const char *canonical_root) {\n    // â”€â”€ Phase 1: Resolve and validate the filesystem path â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    char resolved[MAX_PATH_SIZE];\n    int resolve_status = resolve_safe_path(req->path, canonical_root, resolved);\n    if (resolve_status == 400) {\n        send_error_response(client_fd, 400, \"Bad Request\",\n            \"<html><body><h1>400 Bad Request</h1>\"\n            \"<p>Malformed request path.</p></body></html>\");\n        return;\n    }\n    if (resolve_status == 403) {\n        send_error_response(client_fd, 403, \"Forbidden\",\n            \"<html><body><h1>403 Forbidden</h1>\"\n            \"<p>Access to the requested resource is not permitted.</p>\"\n            \"</body></html>\");\n        return;\n    }\n    if (resolve_status == 404) {\n        send_error_response(client_fd, 404, \"Not Found\",\n            \"<html><body><h1>404 Not Found</h1>\"\n            \"<p>The requested resource could not be found.</p>\"\n            \"</body></html>\");\n        return;\n    }\n    // â”€â”€ Phase 2: Stat the file â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    struct stat st;\n    if (stat(resolved, &st) < 0) {\n        int status = (errno == ENOENT) ? 404 : 403;\n        const char *reason = (status == 404) ? \"Not Found\" : \"Forbidden\";\n        const char *body = (status == 404)\n            ? \"<html><body><h1>404 Not Found</h1></body></html>\"\n            : \"<html><body><h1>403 Forbidden</h1></body></html>\";\n        send_error_response(client_fd, status, reason, body);\n        return;\n    }\n    // â”€â”€ Phase 3: Handle directory paths â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    int dir_result = handle_directory_path(resolved, sizeof(resolved), &st);\n    if (dir_result < 0) {\n        // -1: directory with no index.html\n        // -2: stat failed\n        send_error_response(client_fd, 403, \"Forbidden\",\n            \"<html><body><h1>403 Forbidden</h1>\"\n            \"<p>Directory listing is not permitted.</p></body></html>\");\n        return;\n    }\n    // If dir_result == 1, resolved now points to index.html and st is re-stat'd.\n    // Verify it's a regular file (not a special file like /dev/random)\n    if (!S_ISREG(st.st_mode)) {\n        send_error_response(client_fd, 403, \"Forbidden\",\n            \"<html><body><h1>403 Forbidden</h1></body></html>\");\n        return;\n    }\n    // â”€â”€ Phase 4: Determine MIME type â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    const char *mime_type = mime_type_for_path(resolved);\n    // â”€â”€ Phase 5: Check conditional request (If-Modified-Since) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    time_t file_mtime = st.st_mtime;\n    if (should_send_304(req, file_mtime)) {\n        // Build 304 response â€” headers only, no body\n        char date_str[64];\n        char lm_str[64];\n        format_http_date(time(NULL), date_str, sizeof(date_str));\n        format_http_date(file_mtime, lm_str, sizeof(lm_str));\n        char resp[1024];\n        int n = snprintf(resp, sizeof(resp),\n            \"HTTP/1.1 304 Not Modified\\r\\n\"\n            \"Last-Modified: %s\\r\\n\"\n            \"Date: %s\\r\\n\"\n            \"Connection: %s\\r\\n\"\n            \"\\r\\n\",\n            lm_str, date_str,\n            req->keep_alive ? \"keep-alive\" : \"close\");\n        if (n > 0) write_all(client_fd, resp, (size_t)n);\n        return;\n    }\n    // â”€â”€ Phase 6: Open the file â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    int file_fd = open(resolved, O_RDONLY);\n    if (file_fd < 0) {\n        int status = (errno == ENOENT) ? 404 : 403;\n        const char *reason = (status == 404) ? \"Not Found\" : \"Forbidden\";\n        const char *body = (status == 404)\n            ? \"<html><body><h1>404 Not Found</h1></body></html>\"\n            : \"<html><body><h1>403 Forbidden</h1></body></html>\";\n        send_error_response(client_fd, status, reason, body);\n        return;\n    }\n    // â”€â”€ Phase 7: Build and send response headers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    char date_str[64];\n    char lm_str[64];\n    format_http_date(time(NULL), date_str, sizeof(date_str));\n    format_http_date(file_mtime, lm_str, sizeof(lm_str));\n    long file_size = (long)st.st_size;\n    char header_buf[2048];\n    int header_len = snprintf(header_buf, sizeof(header_buf),\n        \"HTTP/1.1 200 OK\\r\\n\"\n        \"Content-Type: %s\\r\\n\"\n        \"Content-Length: %ld\\r\\n\"\n        \"Last-Modified: %s\\r\\n\"\n        \"Date: %s\\r\\n\"\n        \"Connection: %s\\r\\n\"\n        \"\\r\\n\",\n        mime_type,\n        file_size,\n        lm_str,\n        date_str,\n        req->keep_alive ? \"keep-alive\" : \"close\");\n    if (header_len <= 0 || (size_t)header_len >= sizeof(header_buf)) {\n        close(file_fd);\n        send_error_response(client_fd, 500, \"Internal Server Error\",\n            \"<html><body><h1>500 Internal Server Error</h1></body></html>\");\n        return;\n    }\n    if (write_all(client_fd, header_buf, (size_t)header_len) < 0) {\n        close(file_fd);\n        return;  // Client disconnected\n    }\n    // â”€â”€ Phase 8: Send the file body (skip for HEAD requests) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    if (req->method == METHOD_HEAD) {\n        close(file_fd);\n        return;  // HEAD: headers sent, no body\n    }\n    // Transfer file contents in chunks\n    char io_buf[65536];  // 64KB I/O buffer â€” matches typical page cache read size\n    ssize_t bytes_read;\n    while ((bytes_read = read(file_fd, io_buf, sizeof(io_buf))) > 0) {\n        if (write_all(client_fd, io_buf, (size_t)bytes_read) < 0) {\n            break;  // Client disconnected mid-transfer â€” just stop\n        }\n    }\n    close(file_fd);\n}\n```\n### The 64KB Buffer Choice\nThe I/O buffer size of 65536 bytes (64KB) is not arbitrary. Several hardware and OS factors converge at this size:\n- **Page cache granularity**: The kernel reads files in units of its memory pages (4KB on x86). The `read()` syscall, when serving from the page cache, can transfer up to the buffer size in one call. 64KB = 16 pages â€” a good batch size.\n- **TCP send buffer**: The kernel's TCP send buffer default is typically 87KB. Sending 64KB at a time keeps the pipeline full without overflowing.\n- **L1 cache pressure**: 64KB fits in L2 cache (typically 256KBâ€“512KB) without evicting the rest of your working set from L1. Larger buffers start competing with other hot data.\nAt smaller buffer sizes (4KB, 8KB), the overhead of the readâ†’write loop â€” two syscalls per iteration, with their associated mode switches between user space and kernel space â€” becomes a bottleneck. At larger buffer sizes (256KB+), the buffer itself starts evicting hot data from cache.\n---\n## TOCTOU: The Security Race You Can't Fully Win\nEven with perfect `realpath()` usage, there is a theoretical security vulnerability worth understanding: the **Time-Of-Check-Time-Of-Use (TOCTOU)** race condition.\nHere's the scenario:\n1. Your code calls `realpath(\"/var/www/html/safe.txt\")` â†’ verifies path is inside root âœ“\n2. An attacker (with filesystem access) replaces `/var/www/html/safe.txt` with a symlink to `/etc/passwd`\n3. Your code calls `open(\"/var/www/html/safe.txt\")` â†’ now opens `/etc/passwd`\nThe check (`realpath`) and the use (`open`) are two separate operations. Between them, the filesystem can change. This is the time-of-check-time-of-use problem.\nIn practice, exploiting this requires the attacker to already have filesystem write access to your web root â€” if they do, they've already won (they can just read the file directly, or plant malicious content). So TOCTOU in this specific scenario is not a meaningful threat model for a static file server. However, the TOCTOU concept itself is one of the most important patterns in systems security, appearing in:\n- **setuid programs**: check permissions as real user, use resources as root user\n- **Database isolation levels**: read-then-write transactions with intervening modifications (phantom reads)\n- **Container escape vulnerabilities**: checking container identity before acting on it\n- **File upload handlers**: validate file type, then move â€” attacker replaces file between steps\nYou cannot eliminate TOCTOU without atomic operations. The Linux kernel provides `openat()` with directory file descriptors, which reduces (but doesn't eliminate) the window. For our static file server, the threat model doesn't require solving TOCTOU â€” but knowing it exists makes you a more careful systems programmer.\n---\n## Hardware Soul: Cache Lines and File Transfer\n**`realpath()` â€” multiple syscalls**: Each `lstat()` call inside `realpath()` crosses the user/kernel boundary (~1â€“2 microseconds for the context switch) and performs a dcache lookup. For a path with N components, this is N Ã— 2Âµs. For `/var/www/html/images/photo.jpg` (5 components), `realpath()` costs approximately 10 microseconds â€” dominated by system call overhead, not computation.\n**`stat()` memory access pattern**: `struct stat` is 144 bytes on Linux x86-64. It fits entirely in L1 cache. You call `stat()` once per request; the kernel fills it in during the syscall. There's no cache-line bouncing concern here â€” it's a small, write-once, read-several-times structure.\n**File read loop â€” cache line efficiency**: Your 64KB read buffer crosses 1024 cache lines (64 bytes each). The CPU's hardware prefetcher recognizes the sequential access pattern â€” you read from offset 0, 64, 128, ... in order â€” and prefetches the next cache line before you need it. This is a **stream access pattern**: the most cache-friendly access pattern possible, achieving near-peak memory bandwidth. The prefetcher would fail on random access (serving random bytes from different files), which is why file serving is faster than you might expect even when the data isn't already in L1.\n**`write()` and socket buffers**: When you call `write(client_fd, io_buf, 65536)`, the kernel copies your buffer into the socket's send buffer (in kernel memory), then returns. The TCP stack asynchronously segments and transmits from the send buffer. If the send buffer is full (the client is reading slowly), `write()` blocks. For a local loopback connection, the kernel's loopback interface operates at memory bandwidth speeds â€” easily 10+ GB/s. The bottleneck for local file serving is never the network.\n**The case for `sendfile()`**: In the serve loop above, you perform two copies for each chunk of file data:\n1. `read()`: disk/page-cache â†’ your userspace buffer (kernel mode â†’ user mode copy)  \n2. `write()`: your userspace buffer â†’ socket send buffer (user mode â†’ kernel mode copy)\nThe `sendfile()` syscall (Linux-specific) eliminates both copies. It tells the kernel: \"copy from this file FD directly to this socket FD without touching userspace.\" The kernel can use DMA (Direct Memory Access) to copy from the page cache to the NIC's DMA buffer directly, bypassing the CPU entirely for the data movement. For large files on high-bandwidth connections, `sendfile()` doubles throughput and halves CPU usage. Your current implementation is educationally valuable because it shows you exactly where the copies happen. After this milestone, `sendfile()` is the natural next optimization.\n---\n## Integrating File Serving into the Accept Loop\nUpdate `handle_connection()` from Milestone 2 to dispatch to `serve_static_file()`:\n```c\n// Updated handle_connection â€” replaces the dispatch section from Milestone 2\nvoid handle_connection(int client_fd, const char *canonical_root) {\n    char req_buf[REQUEST_BUF_SIZE];\n    int header_end = -1;\n    ssize_t bytes_read = read_http_request(client_fd, req_buf,\n                                           REQUEST_BUF_SIZE, &header_end);\n    if (bytes_read < 0 || header_end < 0) {\n        close(client_fd);\n        return;\n    }\n    http_request_t req;\n    int parse_err = parse_http_request(req_buf, (size_t)bytes_read,\n                                       header_end, &req);\n    if (parse_err != 0) {\n        switch (parse_err) {\n            case 400: send_error_response(client_fd, 400, \"Bad Request\",\n                          \"<html><body><h1>400 Bad Request</h1></body></html>\");\n                      break;\n            case 414: send_error_response(client_fd, 414, \"URI Too Long\",\n                          \"<html><body><h1>414 URI Too Long</h1></body></html>\");\n                      break;\n            case 501: send_error_response(client_fd, 501, \"Not Implemented\",\n                          \"<html><body><h1>501 Not Implemented</h1></body></html>\");\n                      break;\n            default:  send_error_response(client_fd, 400, \"Bad Request\",\n                          \"<html><body><h1>400 Bad Request</h1></body></html>\");\n        }\n        close(client_fd);\n        return;\n    }\n    // Only serve GET and HEAD â€” POST and others get 501 (parser sets METHOD_UNKNOWN)\n    if (req.method != METHOD_GET && req.method != METHOD_HEAD) {\n        send_error_response(client_fd, 501, \"Not Implemented\",\n            \"<html><body><h1>501 Not Implemented</h1></body></html>\");\n        close(client_fd);\n        return;\n    }\n    serve_static_file(&req, client_fd, canonical_root);\n    close(client_fd);\n}\n```\nPass `canonical_root` from your server initialization (where you called `realpath()` on the document root at startup) into every connection handler. In Milestone 4, this will move into a shared server configuration struct accessible to all worker threads.\n---\n## Testing Static File Serving\nCreate a test document root with a representative set of files:\n```bash\nmkdir -p /tmp/www/images\necho '<html><body><h1>Home</h1></body></html>' > /tmp/www/index.html\necho 'body { color: red; }' > /tmp/www/style.css\necho 'console.log(\"hello\");' > /tmp/www/app.js\ncp /usr/share/pixmaps/some-icon.png /tmp/www/images/logo.png  # or any PNG\necho '{\"status\": \"ok\"}' > /tmp/www/api.json\n# Run server\n./http_server 8080 /tmp/www\n```\n```bash\n# Test 1: Serve HTML with correct Content-Type\ncurl -v http://localhost:8080/\n# Expect: HTTP/1.1 200 OK, Content-Type: text/html; charset=utf-8\n# Test 2: Serve CSS\ncurl -v http://localhost:8080/style.css\n# Expect: Content-Type: text/css\n# Test 3: Last-Modified header present\ncurl -v http://localhost:8080/index.html | grep -i last-modified\n# Expect: Last-Modified: <some valid HTTP date>\n# Test 4: Conditional request â€” first fetch, then conditional\nLMOD=$(curl -sI http://localhost:8080/index.html | grep -i last-modified | cut -d' ' -f2-)\ncurl -v -H \"If-Modified-Since: $LMOD\" http://localhost:8080/index.html\n# Expect: HTTP/1.1 304 Not Modified, no body\n# Test 5: 404 for missing file\ncurl -v http://localhost:8080/does-not-exist.html\n# Expect: HTTP/1.1 404 Not Found\n# Test 6: Directory traversal â€” MUST return 403\ncurl -v http://localhost:8080/../../../etc/passwd\n# Expect: HTTP/1.1 403 Forbidden (curl may normalize the path â€” use nc)\nprintf \"GET /../../../etc/passwd HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\" | nc localhost 8080\n# Expect: 403 Forbidden, no file content\n# Test 7: URL-encoded traversal\nprintf \"GET /%2e%2e%2f%2e%2e%2fetc%2fpasswd HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\" | nc localhost 8080\n# Expect: 403 Forbidden\n# Test 8: Directory without index.html\nmkdir /tmp/www/empty-dir\ncurl -v http://localhost:8080/empty-dir/\n# Expect: 403 Forbidden\n# Test 9: Directory with index.html\ncurl -v http://localhost:8080/\n# Expect: 200 OK with the content of /tmp/www/index.html\n# Test 10: HEAD request returns headers, no body\ncurl -v -X HEAD http://localhost:8080/index.html\n# Expect: 200 OK with Content-Length header, zero bytes of body\n# Test 11: Binary file (PNG) served correctly\ncurl -s http://localhost:8080/images/logo.png | file -\n# Expect: PNG image data â€” not corrupted binary\n```\nTest 11 is important: verify that binary files are transmitted intact. A naive server that tries to process binary content as text can corrupt images. Ensure your read/write loop treats the data as raw bytes â€” which it does, since you're using `read()` and `write()` with `char` buffers, where every byte value 0â€“255 is valid.\n### Verifying Security Properties\n```bash\n# Verify realpath() is actually being called â€” strace on Linux\nstrace -e trace=lstat,open,read ./http_server 8080 /tmp/www &\nprintf \"GET /../../../etc/passwd HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\" | nc localhost 8080\n# Look for lstat() calls on path components in strace output\n# Should NOT see open(\"/etc/passwd\")\n# Verify symlink traversal is blocked\nln -s /etc /tmp/www/secret-link\ncurl -v http://localhost:8080/secret-link/passwd\n# Expect: 403 Forbidden\n# realpath() resolves the symlink to /etc/passwd, which is outside /tmp/www\n```\n---\n## Design Decisions: Path Security Approaches\n| Approach | Security Level | Complexity | Used By |\n|----------|---------------|------------|---------|\n| **String prefix check only** | None (bypassable) | Trivial | Buggy student servers |\n| **Manual `..` stripping** | Weak (URL encoding bypasses) | Medium | Some legacy CGI servers |\n| **`realpath()` + prefix check (this project) âœ“** | Strong for file server | Low | nginx, Apache httpd |\n| **`chroot()` jail** | Very strong (OS-enforced) | High | High-security file servers |\n| **`openat()` with O_NOFOLLOW** | Strong (no TOCTOU) | Medium | Modern security-conscious servers |\n`chroot()` changes a process's view of the root filesystem â€” inside a chroot jail, the process cannot navigate above its \"root.\" This is OS-enforced containment: even a compromised `realpath()` implementation can't escape a chroot. The downside is that it requires the server to be set up carefully (all needed libraries and files must be inside the jail) and typically requires root privileges to call `chroot()`. nginx and Apache can use `chroot` in production configurations.\n`openat()` with `O_NOFOLLOW` (don't follow symlinks on the final component) combined with `O_PATH` fd-based path traversal is the most modern approach â€” it eliminates TOCTOU by holding directory fds across the traversal. This is how container runtimes like `runc` handle their filesystem operations.\nFor this milestone, `realpath()` + prefix check is the right choice: correct, auditable, and teachable.\n---\n## Knowledge Cascade: What This Unlocks\n### 1. Defense in Depth â€” The Resolve-Then-Check Pattern Everywhere\nThe principle you just applied â€” canonicalize first, check second â€” is the foundation of every defense-in-depth filesystem security mechanism:\n**`chroot()` jails**: The kernel's `chroot()` syscall changes what \"/\" means for a process. Every path lookup inside a chroot is automatically constrained to the jail directory. The implementation is: when resolving a path, if the process's root is `/jail`, every absolute path lookup starts at `/jail`. `realpath()` inside the jail cannot escape because the kernel won't let it. Same principle: resolve identity through the system, then trust the result.\n**Linux namespaces and container filesystems**: Docker and container runtimes use mount namespaces to create a private filesystem view per container. When a process inside a container opens `/etc/passwd`, the kernel resolves that path in the container's namespace, which maps to a container-specific overlay filesystem layer. The security model is: trust the kernel's path resolution, not the string.\n**`seccomp` sandboxes**: Instead of path-level security, seccomp operates on syscall level â€” but the principle is the same. Don't trust the syscall arguments (the string passed to `open()`); instead, constrain which syscalls are permitted at all, forcing the program to operate within a defined safety envelope.\nWherever you see security through containment â€” browser sandboxes (Chrome's site isolation uses process separation and IPC), database privilege levels (EXECUTE permission on stored procedures without SELECT access to underlying tables), AWS IAM policies â€” the pattern is: don't trust the name or the request, verify the resolved identity.\n### 2. `sendfile()` and Zero-Copy I/O\nYour current file transfer code has two copies per chunk: page cache â†’ user buffer (`read()`), user buffer â†’ socket send buffer (`write()`). Visualize those two copies as two context switches and two memcpy calls per 64KB chunk.\n`sendfile(output_fd, input_fd, offset, count)` is a Linux syscall that performs the transfer inside the kernel â€” no userspace buffer needed. The kernel can use DMA to move data directly from the disk controller's memory to the NIC's DMA buffer, bypassing the CPU for the data path entirely. For a 1MB file served over a fast connection:\n- **With read/write**: 16 read() calls + 16 write() calls + 2MB of memcpy = ~30Âµs of CPU time\n- **With sendfile()**: 1 syscall, kernel handles DMA = ~5Âµs of CPU time\nThis is the technique behind nginx's legendary efficiency. nginx's inner loop for static file serving is essentially: open the file, `sendfile()` to the socket, close the file. No userspace buffer, no memcpy. The kernel does everything.\nThe concept extends: `splice()` transfers data between two file descriptors (not necessarily a file and a socket), `tee()` duplicates pipe data, and `copy_file_range()` copies between two regular files â€” all in kernel space, all avoiding the userspace round-trip. Go's `net/http` server uses `sendfile()` automatically when serving files via `http.ServeFile()`. Rust's `tokio` async runtime exposes it through `tokio::fs::File`. Understanding why it exists â€” because the double-copy in read+write is wasteful physics â€” lets you recognize when to reach for it.\n### 3. Browser Caching Architecture\nThe `If-Modified-Since` / `Last-Modified` / `304` flow you just implemented is the oldest layer of the web's caching stack. Understanding it bottom-up unlocks the entire architecture:\n- **`Last-Modified` + `If-Modified-Since`**: Time-based validation. Granularity: one second. Weakness: if a file changes and reverts within one second, the cache won't invalidate. What you just built.\n- **`ETag` + `If-None-Match`**: Hash-based validation. The server sends a hash of the file content as the `ETag`. Clients send `If-None-Match: <etag>` on subsequent requests. Hash comparison is unambiguous â€” any change, regardless of timestamp granularity, produces a different ETag. nginx computes ETags as `mtime-size` (modification time XOR file size).\n- **`Cache-Control`**: Proactive caching directives. `Cache-Control: max-age=3600` tells the browser \"don't even ask for 1 hour â€” assume it's fresh.\" No request is sent at all. `Cache-Control: no-cache` means \"always validate but reuse if 304.\" `Cache-Control: no-store` means \"never cache this.\"\n- **CDN invalidation**: CDNs (Cloudflare, Fastly, AWS CloudFront) cache your responses at edge nodes globally. When you update a file, you send a \"purge\" API call to invalidate the CDN cache. The CDN then uses `If-Modified-Since` or `ETag` to revalidate with your origin server. The mechanics are exactly what you built â€” just distributed.\n- **Service Workers**: A JavaScript-controlled cache layer in the browser that intercepts fetch requests. Service workers can implement arbitrary caching logic â€” but they use the same `Response` objects with the same `Last-Modified` and `ETag` semantics. Understanding the HTTP layer means understanding what service workers are working with.\n### 4. MIME Types as Content Negotiation â€” The Simple Case of a Deep Concept\nThe `Content-Type` header you're setting per file extension is the simplest form of HTTP **content negotiation**. The general principle: the client and server negotiate what representation of a resource to use. MIME types for static files require no negotiation â€” the server picks the type based on the file. But the same infrastructure supports richer negotiation:\n- **`Accept-Language: en-US, fr;q=0.9`**: Client prefers US English, accepts French at 90% quality. Server picks the best available language version of the resource.\n- **`Accept-Encoding: gzip, deflate, br`**: Client can decompress these encodings. Server sends a gzip-compressed response with `Content-Encoding: gzip`, saving 70â€“80% of bandwidth for text files.\n- **`Accept: application/json, text/html`**: REST APIs use this to serve JSON to API clients and HTML to browsers from the same URL.\n- **API versioning via `Accept`**: `Accept: application/vnd.myapi.v2+json` â€” the client requests a specific API version through the Accept header. GitHub's API works this way.\nEvery one of these is a generalization of the same concept you implemented: use metadata about the resource and the client's capabilities to pick the right representation.\n### 5. `stat()` and the Unix Inode Model\n`stat()` is a window into the Unix inode model. An **inode** (index node) is the kernel data structure that stores file metadata: size, permissions (`st_mode`), owner (`st_uid`), group (`st_gid`), timestamps (`st_atime`, `st_mtime`, `st_ctime`), and the block pointers that tell the kernel where the file's data lives on disk. Notably, the inode does *not* store the filename â€” that lives in the directory entry, which is a separate structure that maps names to inode numbers.\nThis separation explains seemingly strange behaviors:\n- You can have two filenames that point to the same inode (`hard links`). Both names share the same metadata, the same content, the same modification time.\n- A file can be \"deleted\" (the directory entry removed) but its inode persists until all file descriptors to it are closed. This is why `unlink()` doesn't immediately free disk space if a process has the file open â€” the inode stays alive.\n- `stat()` and `lstat()` differ: `stat()` follows symlinks to the target's inode; `lstat()` returns the symlink's own inode (with `st_mode` indicating it's a symlink).\nUnderstanding inodes is the foundation for understanding filesystem implementation (how SQLite manages its database file, how PostgreSQL manages tablespace files), for understanding why `mv` within a filesystem is instantaneous (renames the directory entry, doesn't move inode data), and for understanding why cross-filesystem `mv` is slow (must copy all data, create new inode, delete old entry).\n---\n## Common Mistakes That Will Burn You\n**1. Calling `realpath()` on the document root per request, not at startup.**\n`realpath()` on the document root doesn't change between requests (it's your configuration). Calling it per request adds 5â€“10 `lstat()` syscalls on every single request. Call it once at startup, store the result, pass it to every connection handler.\n**2. Checking the prefix before calling `realpath()`.**\nThe entire point of `realpath()` is that the raw path string cannot be trusted. Any check before `realpath()` is checking attacker-controlled data and provides no security guarantee. **Canonicalize first. Always.**\n**3. Text-mode reading for binary files.**\nOn Linux, `open()` with `O_RDONLY` gives you raw bytes â€” there's no \"text mode\" vs \"binary mode\" distinction at the syscall level. However, if you ever use `fopen()` with `\"r\"` instead of `\"rb\"`, some platforms (Windows) translate `\\r\\n` sequences to `\\n` in text mode, corrupting binary files. Use `open()` + `read()` directly (as in the code above), or use `fopen(..., \"rb\")` if you use stdio. Never use `\"r\"` for files that might be binary.\n**4. Using `st_mtime` without understanding its granularity.**\nOn some filesystems (FAT32, older HFS+), file modification times have 2-second or 1-second granularity. On ext4 and modern filesystems, `st_mtim.tv_nsec` gives nanosecond precision. But HTTP-date format only has 1-second resolution. When comparing `st_mtime` against an `If-Modified-Since` timestamp, use only the second-precision `st_mtime` (not `st_mtim.tv_nsec`), and use `<=` comparison as shown above.\n**5. Not closing `file_fd` on all error paths.**\nEvery early return after `file_fd = open(...)` must include `close(file_fd)`. Draw the control flow. If `write_all()` of the headers fails (client disconnected), you break out of the function â€” have you closed `file_fd`? Check every branch.\n**6. Forgetting to handle the path prefix edge case.**\nThe check `strncmp(resolved, root, root_len) == 0` passes for both `/var/www` (the root itself) and `/var/www-backup` (a different directory). Always verify that the character at `resolved[root_len]` is either `'/'` or `'\\0'`.\n**7. Using `atoi()` for Content-Length in Milestone 2 (carry-forward)**\nYou already handle this, but if you missed it: `atoi(\"-1\")` returns `-1`, and `atoi(\"9999999999999\")` overflows silently on 32-bit `int`. `strtol()` with bounds checking is the only safe approach.\n---\n## Acceptance Criteria Checklist\nBefore proceeding to Milestone 4, verify each item:\n- [ ] `./http_server 8080 /tmp/www` starts, prints the canonical document root path\n- [ ] `curl http://localhost:8080/` returns `200 OK` with `Content-Type: text/html; charset=utf-8` and the content of `index.html`\n- [ ] `curl http://localhost:8080/style.css` returns `Content-Type: text/css`\n- [ ] `curl http://localhost:8080/app.js` returns `Content-Type: application/javascript`\n- [ ] `curl http://localhost:8080/images/logo.png` returns `Content-Type: image/png` and binary-intact PNG data\n- [ ] All responses include a correctly formatted `Last-Modified` header (day-of-week, day, mon, year, time, \"GMT\")\n- [ ] `curl -H \"If-Modified-Since: <valid future date>\" http://localhost:8080/index.html` returns `304 Not Modified` with no body\n- [ ] `curl http://localhost:8080/missing.html` returns `404 Not Found` with an HTML error body\n- [ ] `printf \"GET /../../../etc/passwd HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\" | nc localhost 8080` returns `403 Forbidden`, never file contents\n- [ ] `printf \"GET /%2e%2e%2f%2e%2e%2fetc%2fpasswd HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\" | nc localhost 8080` returns `403 Forbidden`\n- [ ] A symlink inside the document root pointing outside it returns `403 Forbidden`\n- [ ] `curl http://localhost:8080/empty-dir/` (directory without `index.html`) returns `403 Forbidden`\n- [ ] `curl -X HEAD http://localhost:8080/index.html` returns `200 OK` with correct `Content-Length` and zero bytes of body\n- [ ] FD count after 1000 requests (mix of 200, 304, 404, 403) returns to baseline â€” no leaks\n<!-- END_MS -->\n\n\n<!-- MS_ID: http-server-basic-m4 -->\n<!-- MS_ID: http-server-basic-m4 -->\n# Milestone 4: Concurrent Connections\n## Where You Are in the System\nYou have built three-quarters of a real HTTP server. Your server binds a port, reads raw bytes off TCP connections, parses them into structured HTTP requests, and serves files with proper security validation. What you have right now is a fully correct sequential server â€” one that would serve a single developer testing a local site with zero problems.\nWhat you do not have yet is a server that could survive contact with reality.\n\n![HTTP Server Architecture â€” Satellite Map](./diagrams/diag-satellite-map.svg)\n\nReality looks like this: a user opens a browser and loads a page with 20 assets (HTML, CSS, JavaScript files, images). The browser opens multiple connections simultaneously to fetch those assets in parallel. A second user hits the site at the same moment. Your sequential accept loop â€” which finishes one connection completely before calling `accept()` again â€” makes everyone wait in line. The second user's browser times out before it gets a response. Your server, from the outside, appears broken.\nThis milestone fixes that by introducing **concurrency**: the ability to handle multiple connections at the same time. You will build two models â€” thread-per-connection first (simple, reveals the problem) and then a bounded thread pool (the real solution) â€” and layer on top the three features that make concurrent connection management work in production: HTTP/1.1 keep-alive, per-connection idle timeouts, and graceful shutdown.\n---\n## The Revelation: \"Just Spawn a Thread\" Is Not a Solution\nBefore writing any threading code, you need to understand why the obvious approach is dangerous.\nThe obvious approach is: when a new connection arrives, spawn a thread to handle it. Done. Each client gets a thread. Threads can run concurrently. Problem solved.\nThis works perfectly in testing. You connect with curl, it gets a thread, the thread handles the request, everything is fine. You connect with ten curls in parallel, ten threads handle them simultaneously. Still fine.\nNow an attacker runs this:\n```bash\n# Slowloris: open 10,000 connections and send HTTP headers one byte every 20 seconds\n# Never complete the request â€” hold the connections open indefinitely\npython3 slowloris.py --port 8080 --connections 10000 --sleep 20\n```\nThe Slowloris attack, discovered in 2009 by Robert \"RSnake\" Hansen, exploits exactly the \"just spawn a thread\" model. Each connection gets a thread. The thread blocks in `read()` waiting for the complete HTTP headers. The attacker sends one byte every 20 seconds â€” just enough to keep the connection alive and prevent your timeout (if you have one). With 10,000 connections, you have 10,000 threads.\nHere is what 10,000 threads cost on Linux:\nEach thread, by default, gets an **8MB stack**. This is the kernel's default (`ulimit -s` reports it). The stack is virtual memory â€” it doesn't all map to physical RAM immediately â€” but the kernel still reserves the virtual address space. On a 64-bit system with 256GB of virtual address space, you might think this is fine. But:\n- 10,000 threads Ã— 8MB stack = **80GB of virtual address space** reserved\n- Kernel overhead per thread: ~64KB for the task_struct and related kernel data structures = **640MB of kernel memory**\n- Context switches between 10,000 threads: the scheduler now has 10,000 runnable (or blocked) threads to manage â€” scheduling overhead becomes visible\n- The Linux default maximum number of threads (`/proc/sys/kernel/threads-max`) is often around 32,000. With 10,000 connections, you're already at 31% of the system limit. A real attack can push past it entirely, causing `pthread_create()` to fail with `EAGAIN` â€” your server can no longer handle even legitimate connections\n\n![Thread-Per-Connection Model â€” How It Works and How It Breaks](./diagrams/diag-m4-thread-per-connection.svg)\n\nThe resource exhaustion is not hypothetical. It's the exact failure mode that took down Apache web servers in 2009 before patches were deployed. Apache's default model was thread-per-connection (actually process-per-connection, which is worse). Slowloris exploited the OS limit on concurrent processes, not the attack's bandwidth requirements. The attacking machine needed almost no resources; the defending server was overwhelmed.\n**The insight: thread creation is not free, and thread count must be bounded.**\nA bounded thread pool eliminates this entire attack surface. If your pool has 16 threads, the 17th connection waits in a queue. Queued connections consume no threads, no kernel task_structs, no 8MB stacks. The 10,000th Slowloris connection just adds to the queue (which you can also bound â€” more on that shortly). Your server continues serving legitimate requests normally.\nBut there is a second revelation hiding inside the first. Even with a bounded pool, keep-alive connections without idle timeouts create a slow leak. If your 16 threads are all handling keep-alive connections from browsers that opened them 10 minutes ago and haven't sent a second request, all 16 threads are blocked in `read()`. New legitimate connections sit in the queue forever. The pool is full of zombie connections â€” technically alive, sending no data, consuming a thread each.\nThe complete solution requires three interlocking pieces: a bounded thread pool, per-connection idle timeouts, and a keep-alive loop that correctly reuses connections when appropriate and closes them when not.\n---\n## POSIX Threads: The API You Will Use\n[[EXPLAIN:pthread-api|POSIX Threads (pthreads) â€” creation, mutexes, and condition variables]]\nThe pthreads API is POSIX's standardized interface for multi-threading in C. Linux implements it via the `<pthread.h>` header and the `libpthread` library (link with `-lpthread`). You need four concepts from it.\n**Thread creation: `pthread_create()`**\n```c\n#include <pthread.h>\n// Signature:\nint pthread_create(\n    pthread_t *thread,        // OUTPUT: handle to the new thread\n    const pthread_attr_t *attr, // Thread attributes (NULL for defaults)\n    void *(*start_fn)(void*), // Function the thread will run\n    void *arg                 // Argument passed to start_fn\n);\n// Returns 0 on success, error code on failure (EAGAIN = too many threads, ENOMEM = out of memory)\n```\nThe new thread starts executing `start_fn(arg)` immediately, concurrently with your calling thread. Both threads run in the same process, sharing the same heap memory, global variables, and file descriptors. That shared access is what makes synchronization necessary.\n**Mutexes: `pthread_mutex_t`**\nA mutex (**mut**ual **ex**clusion lock) is a synchronization primitive that ensures only one thread accesses a shared resource at a time. Imagine a bathroom key on a hook â€” only the person holding the key can enter; everyone else waits.\n```c\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;  // Static initialization\npthread_mutex_lock(&lock);   // Acquire lock â€” blocks if another thread holds it\n// ... access shared data here ...\npthread_mutex_unlock(&lock); // Release lock â€” wakes one waiting thread\n```\nAny code that reads or writes shared state (a counter, a log file, a work queue) must hold the mutex while doing so. Code that doesn't hold the mutex and accesses shared data has a **data race** â€” the result is undefined behavior in C, meaning anything can happen: corrupted data, crashes, or apparently correct behavior that breaks under load.\n**Condition variables: `pthread_cond_t`**\nA condition variable lets a thread sleep until some condition becomes true. Used together with a mutex, it allows \"wait until there is work to do\" â€” essential for thread pool worker loops.\n```c\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n// In a producer thread: signal that work is available\npthread_mutex_lock(&lock);\n// ... add work to shared queue ...\npthread_cond_signal(&cond);  // Wake one sleeping consumer\npthread_mutex_unlock(&lock);\n// In a consumer thread: wait for work\npthread_mutex_lock(&lock);\nwhile (queue_is_empty(&queue)) {\n    pthread_cond_wait(&cond, &lock);\n    // pthread_cond_wait atomically: releases lock AND sleeps\n    // When signaled: reacquires lock AND returns\n    // The while loop (not if) handles spurious wakeups\n}\n// ... take work from queue ...\npthread_mutex_unlock(&lock);\n```\nThe `while` loop around `pthread_cond_wait()` is not optional ceremony. POSIX permits **spurious wakeups** â€” a thread can wake from `pthread_cond_wait()` even without being signaled. Always re-check the condition after waking.\n**Thread joining and detaching**\n```c\npthread_join(thread, NULL);   // Block until thread exits, then clean up its resources\npthread_detach(thread);       // Thread cleans up its own resources when it exits\n```\nYou must either join or detach every thread. A thread that is neither joined nor detached is a resource leak â€” its kernel task_struct remains allocated until the process exits.\n---\n## The Thread Pool Architecture\nNow build the actual solution. A thread pool consists of:\n1. **A fixed array of worker threads** â€” created at startup, they run a loop waiting for work\n2. **A shared work queue** â€” a bounded queue of file descriptors waiting to be handled\n3. **A mutex protecting the queue** â€” ensures threads don't corrupt the queue by accessing it simultaneously\n4. **A condition variable** â€” lets workers sleep efficiently when the queue is empty\n5. **A shutdown flag** â€” signals workers to exit cleanly\n\n![Thread Pool Internal Architecture](./diagrams/diag-m4-thread-pool-architecture.svg)\n\n```c\n#include <pthread.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <time.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#define POOL_SIZE_DEFAULT    16\n#define QUEUE_SIZE_DEFAULT   256\n#define IDLE_TIMEOUT_SECS    30\n// A single item in the work queue: a client file descriptor to serve\ntypedef struct {\n    int client_fd;\n} work_item_t;\n// The thread pool and its shared state\ntypedef struct {\n    // --- Work queue (circular buffer) ---\n    work_item_t  *queue;          // Fixed-size circular buffer of work items\n    int           queue_capacity; // Maximum items in queue\n    int           queue_head;     // Index of next item to consume\n    int           queue_tail;     // Index of next slot to produce into\n    int           queue_size;     // Current number of items in queue\n    // --- Synchronization ---\n    pthread_mutex_t lock;         // Protects all queue fields and shutdown flag\n    pthread_cond_t  not_empty;    // Signaled when an item is added to empty queue\n    pthread_cond_t  not_full;     // Signaled when an item is removed from full queue\n    // --- Worker threads ---\n    pthread_t    *threads;        // Array of worker thread handles\n    int           num_threads;    // Number of worker threads\n    // --- Lifecycle ---\n    int           shutdown;       // 1 = workers should exit after draining queue\n    // --- Shared statistics (protected by lock) ---\n    int           active_connections;  // Number of connections currently being served\n    long          total_requests;      // Cumulative request count for access log\n    // --- Server configuration (read-only after init, no lock needed) ---\n    const char   *document_root;  // Canonical document root path\n    int           idle_timeout;   // Per-connection idle timeout in seconds\n} thread_pool_t;\n```\n### Memory Layout\nThe work queue is a **circular buffer** â€” a fixed-size array where the head and tail pointers wrap around. When the tail reaches the end, it wraps back to index 0. This gives O(1) enqueue and dequeue without any allocation.\n```\nQueue capacity = 8, current state: head=2, tail=5, size=3\nIndex: 0     1     2     3     4     5     6     7\n       [  ] [  ] [fd=9][fd=12][fd=15][    ][    ][  ]\n                  â†‘head                â†‘tail\nItems waiting: fd=9, fd=12, fd=15\n```\nWhen `queue_size == queue_capacity`, the queue is full. A new connection arriving while the queue is full gets rejected with 503.\n### Initialization\n```c\nint thread_pool_init(thread_pool_t *pool, int num_threads, int queue_capacity,\n                     const char *document_root, int idle_timeout) {\n    memset(pool, 0, sizeof(*pool));\n    pool->queue = calloc((size_t)queue_capacity, sizeof(work_item_t));\n    if (!pool->queue) return -1;\n    pool->queue_capacity = queue_capacity;\n    pool->num_threads    = num_threads;\n    pool->document_root  = document_root;\n    pool->idle_timeout   = idle_timeout;\n    pthread_mutex_init(&pool->lock, NULL);\n    pthread_cond_init(&pool->not_empty, NULL);\n    pthread_cond_init(&pool->not_full, NULL);\n    pool->threads = calloc((size_t)num_threads, sizeof(pthread_t));\n    if (!pool->threads) { free(pool->queue); return -1; }\n    for (int i = 0; i < num_threads; i++) {\n        int rc = pthread_create(&pool->threads[i], NULL, worker_thread_fn, pool);\n        if (rc != 0) {\n            // Failed to create thread â€” initiate shutdown of already-created threads\n            pool->shutdown = 1;\n            pthread_cond_broadcast(&pool->not_empty);\n            for (int j = 0; j < i; j++) pthread_join(pool->threads[j], NULL);\n            free(pool->threads);\n            free(pool->queue);\n            return -1;\n        }\n    }\n    return 0;\n}\n```\n`pthread_cond_broadcast()` wakes *all* sleeping threads (unlike `signal()` which wakes one). Used during shutdown to ensure all workers wake up and check the shutdown flag.\n### The Worker Thread Loop\n```c\nstatic void *worker_thread_fn(void *arg) {\n    thread_pool_t *pool = (thread_pool_t *)arg;\n    for (;;) {\n        // --- Wait for work ---\n        pthread_mutex_lock(&pool->lock);\n        while (pool->queue_size == 0 && !pool->shutdown) {\n            pthread_cond_wait(&pool->not_empty, &pool->lock);\n        }\n        if (pool->shutdown && pool->queue_size == 0) {\n            // Shutdown: no work left â€” this worker exits\n            pthread_mutex_unlock(&pool->lock);\n            return NULL;\n        }\n        // --- Dequeue one item ---\n        work_item_t item = pool->queue[pool->queue_head];\n        pool->queue_head = (pool->queue_head + 1) % pool->queue_capacity;\n        pool->queue_size--;\n        pool->active_connections++;\n        // Signal that queue has space (for the accept loop, if it was blocked)\n        pthread_cond_signal(&pool->not_full);\n        pthread_mutex_unlock(&pool->lock);\n        // --- Handle the connection (OUTSIDE the lock) ---\n        handle_connection(item.client_fd, pool);\n        // --- Update stats ---\n        pthread_mutex_lock(&pool->lock);\n        pool->active_connections--;\n        pthread_mutex_unlock(&pool->lock);\n    }\n}\n```\nThe critical discipline: **hold the lock only while touching shared data, never while doing I/O or long computation.** The actual connection handling â€” which involves network reads, file opens, and potentially seconds of waiting â€” happens completely outside the mutex. If you held the mutex during connection handling, all other threads would be blocked waiting for it. You'd have effectively serialized your \"concurrent\" server.\n### Enqueue: Submitting Work\n```c\n// Submit a client connection to the thread pool for handling.\n// Returns 0 on success, -1 if pool is full (caller should send 503 and close fd).\nint thread_pool_submit(thread_pool_t *pool, int client_fd) {\n    pthread_mutex_lock(&pool->lock);\n    if (pool->shutdown) {\n        pthread_mutex_unlock(&pool->lock);\n        return -1;  // Server is shutting down\n    }\n    if (pool->queue_size >= pool->queue_capacity) {\n        // Queue is full â€” reject this connection\n        pthread_mutex_unlock(&pool->lock);\n        return -1;\n    }\n    pool->queue[pool->queue_tail] = (work_item_t){ .client_fd = client_fd };\n    pool->queue_tail = (pool->queue_tail + 1) % pool->queue_capacity;\n    pool->queue_size++;\n    // Wake one sleeping worker\n    pthread_cond_signal(&pool->not_empty);\n    pthread_mutex_unlock(&pool->lock);\n    return 0;\n}\n```\nWhen `thread_pool_submit()` returns -1, the accept loop must send a `503 Service Unavailable` response and close the file descriptor. This is the graceful overload response: tell the client the server is temporarily busy, rather than silently dropping the connection or crashing.\n```c\n// Send a minimal 503 response â€” used when the pool is full.\n// We send the smallest valid HTTP response to minimize time holding the fd.\nstatic void send_503(int client_fd) {\n    const char *resp =\n        \"HTTP/1.1 503 Service Unavailable\\r\\n\"\n        \"Content-Type: text/html\\r\\n\"\n        \"Content-Length: 63\\r\\n\"\n        \"Connection: close\\r\\n\"\n        \"\\r\\n\"\n        \"<html><body><h1>503 Service Unavailable</h1></body></html>\";\n    // Best-effort write â€” if client already disconnected, EPIPE is ignored\n    write(client_fd, resp, strlen(resp));\n    close(client_fd);\n}\n```\n---\n## HTTP/1.1 Keep-Alive: The Connection Reuse Loop\nHTTP/1.0 opened a new TCP connection for every single request/response cycle â€” a three-way handshake for each asset, before sending anything. For a page with 50 assets, that's 50 TCP handshakes. On a cross-continental connection with 100ms RTT, that's 5 seconds of pure handshake overhead before any real data transfers.\nHTTP/1.1 introduced **persistent connections** (keep-alive): by default, the connection stays open after a response, and the client sends the next request on the same socket. The overhead of TCP connection establishment â€” one handshake for the entire session â€” is paid once.\n\n![HTTP/1.1 Keep-Alive â€” Connection Reuse Timeline](./diagrams/diag-m4-keep-alive-timeline.svg)\n\nFrom your Milestone 2 parser, you already track `req.keep_alive` and set the `Connection: keep-alive` or `Connection: close` response header. Now you need to make the connection actually persist when keep-alive is requested.\nThe keep-alive loop wraps the request-read â†’ parse â†’ serve cycle inside a `while` loop on the same `client_fd`. Here is the complete connection handler that replaces the simple sequential handler:\n\n![Complete Connection Handler â€” Full Request Loop with Keep-Alive](./diagrams/diag-m4-connection-handling-flowchart.svg)\n\n```c\nvoid handle_connection(int client_fd, thread_pool_t *pool) {\n    // Set the receive timeout on the socket.\n    // If no data arrives within idle_timeout seconds, read() returns EAGAIN/EWOULDBLOCK.\n    struct timeval tv;\n    tv.tv_sec  = pool->idle_timeout;\n    tv.tv_usec = 0;\n    setsockopt(client_fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));\n    // Keep-alive loop: serve multiple requests on one connection\n    for (;;) {\n        // --- Phase 1: Read the request ---\n        char req_buf[REQUEST_BUF_SIZE];\n        int header_end = -1;\n        ssize_t bytes_read = read_http_request(client_fd, req_buf,\n                                               REQUEST_BUF_SIZE, &header_end);\n        if (bytes_read < 0 || header_end < 0) {\n            // Timeout (EAGAIN), client disconnect (0 bytes), or read error\n            // In all cases: close the connection, return thread to pool\n            break;\n        }\n        // --- Phase 2: Parse ---\n        http_request_t req;\n        int parse_err = parse_http_request(req_buf, (size_t)bytes_read,\n                                           header_end, &req);\n        if (parse_err != 0) {\n            send_error_by_code(client_fd, parse_err);\n            break;  // Close after error response\n        }\n        // --- Phase 3: Update shared stats (briefly hold lock) ---\n        pthread_mutex_lock(&pool->lock);\n        pool->total_requests++;\n        long req_num = pool->total_requests;\n        pthread_mutex_unlock(&pool->lock);\n        // --- Phase 4: Serve the request ---\n        if (req.method == METHOD_GET || req.method == METHOD_HEAD) {\n            serve_static_file(&req, client_fd, pool->document_root);\n        } else {\n            send_error_response(client_fd, 501, \"Not Implemented\",\n                \"<html><body><h1>501 Not Implemented</h1></body></html>\");\n            break;  // Don't keep-alive after 501\n        }\n        // --- Phase 5: Decide whether to continue ---\n        if (!req.keep_alive) {\n            break;  // Connection: close â€” done\n        }\n        // Otherwise: loop back, wait for the next request on this connection\n    }\n    close(client_fd);\n}\n```\nThe `SO_RCVTIMEO` socket option is the idle timeout mechanism. When you set it, `recv()` and `read()` will return -1 with `errno = EAGAIN` (or `EWOULDBLOCK`) if no data arrives within the specified time. Your `read_http_request()` function from Milestone 1 already returns -1 on any error, so the timeout causes it to return -1, breaking the keep-alive loop and closing the connection. The worker thread is now free to handle a new connection.\n\n![Idle Timeout â€” The Slowloris Defense](./diagrams/diag-m4-timeout-and-idle.svg)\n\n### Why Break After Non-200 Responses?\nNotice the `break` after sending a 501 response. This is deliberate. If a client sends a malformed or unsupported request and receives a 4xx or 5xx response, the right behavior is usually to close the connection. The client clearly has a problem â€” letting it keep the connection alive and send more broken requests wastes server resources and potentially enables abuse. The exceptions are 404 and 304, where the client is well-behaved but just requesting something that doesn't exist or hasn't changed. For those, keep-alive is fine.\n---\n## Signal Handling in Multi-Threaded Programs\nWhen your server was single-threaded, signal handling was straightforward: `signal(SIGPIPE, SIG_IGN)` at startup, and you're done. Multi-threaded programs have a complication: **POSIX delivers signals to an unpredictable thread.**\n\n![Signal Handling in Multi-Threaded Programs â€” The Pitfall](./diagrams/diag-m4-signal-handling-threads.svg)\n\nThe POSIX specification says: when a signal is delivered to a process (as opposed to a specific thread via `pthread_kill()`), the kernel picks one of the threads that doesn't have the signal blocked. It may pick any thread â€” the accept loop thread, a worker thread, any of them.\nThis creates a subtle problem for SIGTERM and SIGINT (your graceful shutdown signals). If a worker thread receives SIGTERM, it might be in the middle of writing a file to the network. The signal handler runs asynchronously. If your signal handler calls `shutdown_server()` which modifies shared state while the worker thread isn't holding any lock, you have a data race inside the signal handler.\nThe safe solution for multi-threaded programs is the **dedicated signal thread** pattern:\n1. In `main()`, before creating any threads, **block all signals** using `pthread_sigmask()`\n2. Create the thread pool â€” worker threads inherit the blocked signal mask\n3. Create a dedicated signal thread that uses `sigwait()` to wait for signals synchronously\n```c\n// Block all signals in the main thread before spawning workers.\n// All threads created after this inherit the blocked mask.\nsigset_t all_signals;\nsigfillset(&all_signals);\npthread_sigmask(SIG_BLOCK, &all_signals, NULL);\n// Create the thread pool (workers inherit blocked signal mask)\nthread_pool_init(&pool, POOL_SIZE_DEFAULT, QUEUE_SIZE_DEFAULT, root, IDLE_TIMEOUT_SECS);\n// Create the dedicated signal-handling thread\npthread_t signal_thread;\npthread_create(&signal_thread, NULL, signal_handler_thread, &pool);\n// Now run the accept loop in main thread\naccept_loop(&server_fd, &pool);\n```\nThe signal-handling thread uses `sigwait()` â€” a blocking call that waits for a signal from the specified set and returns it synchronously, without running any asynchronous signal handler:\n```c\nstatic void *signal_handler_thread(void *arg) {\n    thread_pool_t *pool = (thread_pool_t *)arg;\n    // Wait for termination signals\n    sigset_t waitset;\n    sigemptyset(&waitset);\n    sigaddset(&waitset, SIGTERM);\n    sigaddset(&waitset, SIGINT);\n    // Still ignore SIGPIPE globally to avoid broken-pipe kills\n    signal(SIGPIPE, SIG_IGN);\n    int sig;\n    sigwait(&waitset, &sig);  // Blocks until SIGTERM or SIGINT arrives\n    printf(\"\\n[%s received] Initiating graceful shutdown...\\n\",\n           sig == SIGTERM ? \"SIGTERM\" : \"SIGINT\");\n    // Initiate graceful shutdown\n    thread_pool_shutdown(pool);\n    return NULL;\n}\n```\n`sigwait()` is safe to call from a regular thread context â€” no async-signal-safety concerns, no restriction on what you can do before or after it. The signal is consumed by `sigwait()` and delivered synchronously to this thread. No other thread is interrupted.\n---\n## Graceful Shutdown: The Four-Phase Dance\nGraceful shutdown means: stop accepting new work, finish all in-flight work, then exit cleanly. It is not `kill -9` and it is not `exit(0)` in the signal handler.\n\n![Graceful Shutdown â€” The 4-Phase Dance](./diagrams/diag-m4-graceful-shutdown-sequence.svg)\n\nThe four phases:\n**Phase 1: Stop accepting new connections.** The accept loop must notice the shutdown signal and stop calling `accept()`. Use an `atomic_int` or mutex-protected flag that the accept loop checks between iterations.\n**Phase 2: Close the listening socket.** This causes any pending `accept()` call (if the accept loop is sleeping in it) to return with `EBADF`. New clients attempting to connect now get \"connection refused\" â€” a clear signal that the server is down, not hanging.\n**Phase 3: Set the pool shutdown flag and wake all workers.** Workers that are sleeping in `pthread_cond_wait()` need to wake up and check the shutdown flag.\n**Phase 4: Join all workers.** Wait for every worker thread to finish its current connection and exit. Only after all workers have joined can you safely free resources and call `exit(0)`.\n```c\n// Global flag for the accept loop to check â€” written by signal thread,\n// read by accept loop. Using volatile int is NOT sufficient for thread safety\n// but using atomic_int or a mutex-protected int is.\n// We use a mutex-protected int to keep the pattern consistent with the pool.\nvoid thread_pool_shutdown(thread_pool_t *pool) {\n    pthread_mutex_lock(&pool->lock);\n    pool->shutdown = 1;\n    pthread_cond_broadcast(&pool->not_empty);  // Wake all sleeping workers\n    pthread_mutex_unlock(&pool->lock);\n    // Workers will drain the queue then exit when they see shutdown=1 and queue is empty\n}\nvoid thread_pool_join(thread_pool_t *pool) {\n    for (int i = 0; i < pool->num_threads; i++) {\n        pthread_join(pool->threads[i], NULL);\n    }\n    printf(\"All worker threads exited cleanly.\\n\");\n    free(pool->threads);\n    free(pool->queue);\n    pthread_mutex_destroy(&pool->lock);\n    pthread_cond_destroy(&pool->not_empty);\n    pthread_cond_destroy(&pool->not_full);\n}\n```\n### The Accept Loop with Shutdown Awareness\n```c\n// A global server_fd â€” needed by signal handler to close the listening socket\nstatic volatile int g_server_fd = -1;\nvoid accept_loop(int *server_fd_ptr, thread_pool_t *pool) {\n    g_server_fd = *server_fd_ptr;\n    for (;;) {\n        // Check shutdown flag BEFORE calling accept\n        pthread_mutex_lock(&pool->lock);\n        int shutting_down = pool->shutdown;\n        pthread_mutex_unlock(&pool->lock);\n        if (shutting_down) break;\n        struct sockaddr_in client_addr;\n        socklen_t client_len = sizeof(client_addr);\n        int client_fd = accept(*server_fd_ptr,\n                               (struct sockaddr*)&client_addr, &client_len);\n        if (client_fd < 0) {\n            if (errno == EINTR || errno == EBADF) break;  // Signal or fd closed\n            if (errno == EMFILE || errno == ENFILE) {\n                // Out of file descriptors â€” log and briefly yield\n                fprintf(stderr, \"accept: out of file descriptors!\\n\");\n                usleep(100000);  // 100ms back-off\n                continue;\n            }\n            perror(\"accept\");\n            continue;\n        }\n        // Try to submit to pool\n        if (thread_pool_submit(pool, client_fd) < 0) {\n            send_503(client_fd);  // Pool full or shutting down\n        }\n    }\n    close(*server_fd_ptr);\n    *server_fd_ptr = -1;\n    g_server_fd = -1;\n    printf(\"Accept loop exited.\\n\");\n}\n```\nThe `EMFILE` case â€” `errno = EMFILE` means \"too many open files\" (the process hit its file descriptor limit) â€” is important and often missed. When this happens, `accept()` fails, but the OS has already completed the TCP handshake for the waiting client. Repeatedly calling `accept()` to get this error doesn't drain the accept queue â€” the client remains waiting. The `usleep(100000)` back-off gives the server a moment to close other file descriptors (connections finishing in the worker pool) before trying again.\n---\n## Shared State and Mutex Protection\nYour server now has state shared between multiple threads: the request counter, the connection counter, and any shared output (like an access log). Every shared write creates a potential data race.\n\n![Shared State Under Concurrency â€” Data Race Example](./diagrams/diag-m4-mutex-shared-state.svg)\n\nA **data race** in C is not just \"sometimes wrong results.\" The C11 standard (and the POSIX threading specification) defines any concurrent access to the same memory location where at least one access is a write, without synchronization, as **undefined behavior** â€” the most severe category in C. The compiler is permitted to assume data races don't exist, which means it can reorder instructions, cache values in registers, and produce behavior that makes no sense from a sequential reasoning perspective.\nThe most common manifestation: a 64-bit counter incremented by two threads. Even though the increment seems atomic, it compiles to `load â†’ add â†’ store`. Two threads can both load the old value, both add 1, and both store back â€” net result: the counter only incremented by 1 instead of 2. With the compiler free to reorder, the actual behavior can be even stranger.\nHere is the shared state in the pool struct, with protection analysis:\n```c\n// Things protected by pool->lock:\n//   pool->queue_*         â€” modified by accept loop and workers\n//   pool->shutdown        â€” written by signal thread, read by workers and accept loop\n//   pool->active_connections â€” incremented/decremented by workers\n//   pool->total_requests  â€” incremented by workers\n// Things that DO NOT need the lock (read-only after initialization):\n//   pool->document_root   â€” set once at startup, never modified\n//   pool->idle_timeout    â€” set once at startup, never modified\n//   pool->num_threads     â€” set once at startup, never modified\n//   pool->threads[]       â€” array set at startup; individual elements not modified\n```\nAccessing `pool->document_root` from multiple worker threads without a lock is safe because it's read-only: the workers only read it, they never write it. The mutex only needs to protect data that is both written and read concurrently.\nFor the access log (writing to a file or stdout), mutex protection is essential:\n```c\nstatic pthread_mutex_t log_mutex = PTHREAD_MUTEX_INITIALIZER;\nvoid log_request(const char *client_ip, const http_request_t *req,\n                 int status_code, long bytes_sent) {\n    time_t now = time(NULL);\n    struct tm *gmt = gmtime(&now);\n    char time_buf[64];\n    strftime(time_buf, sizeof(time_buf), \"%d/%b/%Y:%H:%M:%S +0000\", gmt);\n    // Without this lock, output from two threads interleaves in the same line\n    pthread_mutex_lock(&log_mutex);\n    printf(\"%s - - [%s] \\\"%s %s HTTP/1.%d\\\" %d %ld\\n\",\n           client_ip, time_buf,\n           method_name(req->method), req->path, req->http_minor,\n           status_code, bytes_sent);\n    fflush(stdout);\n    pthread_mutex_unlock(&log_mutex);\n}\n```\nWithout the `log_mutex`, two threads writing to stdout simultaneously produce interleaved garbage â€” half of thread A's line, half of thread B's, all on the same output line. This looks harmless but signals sloppy concurrency discipline. If the log is wrong, you can't trust your own server's behavior reports.\n---\n## Pool Sizing: The Math That Governs Everything\nThe pool size is not a guess. For an I/O-bound workload like file serving, there is a formula from **Little's Law** and **Amdahl's Law** that gives you a principled starting point.\nFor a CPU-bound workload (cryptography, compression, rendering), the optimal thread count is:\n```\npool_size = num_cpu_cores\n```\nAdding more threads than cores causes context-switch overhead without improving throughput â€” the CPU is already fully utilized.\nFor an I/O-bound workload (file serving, database queries), threads spend most of their time waiting. The formula is:\n```\npool_size = num_cores Ã— (1 + wait_time / compute_time)\n```\nWhere `wait_time` is the time a request spends blocked on I/O (file reads from disk, network reads from client) and `compute_time` is the time spent actually executing CPU instructions (parsing, path resolution, MIME lookup).\nFor a static file server serving files from an NVMe SSD:\n- Compute time per request: ~10â€“50Âµs (mostly parsing and path operations)\n- Wait time per request: ~100Âµs for an SSD read, or ~5ms for a spinning disk, or ~0Âµs for page-cached files\nFor page-cached files (common for popular content):\n- `pool_size = num_cores Ã— (1 + ~1Âµs / ~30Âµs) â‰ˆ num_cores Ã— 1.03 â‰ˆ num_cores`\nFor SSD-served cold files:\n- `pool_size = num_cores Ã— (1 + 100Âµs / 30Âµs) â‰ˆ num_cores Ã— 4.3`\nThe default of 16 is a reasonable production starting point for a 4-core machine serving SSD-backed files with some cache warming. Monitor your active connection count and adjust: if `active_connections` is consistently near `pool_size` under load, increase the pool.\n---\n## FD Leak Detection Under Load\nThe acceptance criterion requires that after 10,000 sequential connections, the open FD count returns to baseline. This check is your comprehensive correctness test for all four milestones combined.\n\n![FD Leak Detection â€” Before and After 10,000 Connections](./diagrams/diag-m4-fd-leak-detection.svg)\n\nFD leaks in a concurrent server are more insidious than in a sequential one because the leaky code path might only execute under specific race conditions:\n- A worker thread gets a client_fd, starts serving, the client disconnects mid-response â†’ the error path exits without `close(client_fd)`\n- A `pthread_create()` fails while client_fd is already assigned â†’ cleanup path skips the close\n- A keep-alive loop exits due to timeout but closes only once when it should be fine (this is OK â€” one close per fd)\nThe test script:\n```bash\n#!/bin/bash\nSERVER_PID=$(pgrep http_server)\nROOT_PATH=/tmp/www\necho \"Starting FD baseline...\"\nBASE_FDS=$(ls /proc/$SERVER_PID/fd 2>/dev/null | wc -l)\necho \"Baseline: $BASE_FDS open FDs\"\necho \"Sending 10,000 connections...\"\nfor i in $(seq 10000); do\n    curl -s http://localhost:8080/ > /dev/null\ndone\n# Give server time to close any in-flight FDs\nsleep 2\nFINAL_FDS=$(ls /proc/$SERVER_PID/fd 2>/dev/null | wc -l)\necho \"Final: $FINAL_FDS open FDs\"\nif [ \"$FINAL_FDS\" -le \"$((BASE_FDS + 2))\" ]; then\n    echo \"PASS: No FD leak detected (within tolerance of 2)\"\nelse\n    echo \"FAIL: Leaked $((FINAL_FDS - BASE_FDS)) FDs\"\n    echo \"Current open FDs:\"\n    ls -la /proc/$SERVER_PID/fd/\nfi\n```\nA tolerance of 2 accounts for FDs that might be mid-close at the moment you sample â€” perfectly normal timing variation. Growth of 3+ is a real leak.\nOn Linux, you can identify what types of FDs are leaking:\n```bash\n# Show the types of all open FDs for your server\nls -la /proc/$(pgrep http_server)/fd/\n# symlinks point to: socket:[inode] (sockets), /path/to/file (files), pipe:[inode] (pipes)\n# If you see many socket:[...] entries that should have been closed, you have a socket leak\n```\n---\n## Complete Main: Wiring It All Together\nHere is the complete `main()` that integrates all four milestones:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <pthread.h>\n#define DEFAULT_PORT       8080\n#define DEFAULT_POOL_SIZE  16\n#define DEFAULT_QUEUE_SIZE 256\n#define DEFAULT_TIMEOUT    30\n#define MAX_PATH_SIZE      4096\nextern void accept_loop(int *server_fd, thread_pool_t *pool);\nextern int  thread_pool_init(thread_pool_t*, int, int, const char*, int);\nextern void thread_pool_join(thread_pool_t*);\nstatic thread_pool_t g_pool;\nint main(int argc, char *argv[]) {\n    int port = DEFAULT_PORT;\n    const char *doc_root = \".\";  // Default: current directory\n    if (argc >= 2) port      = atoi(argv[1]);\n    if (argc >= 3) doc_root  = argv[2];\n    // --- Canonicalize document root (once, at startup) ---\n    char canonical_root[MAX_PATH_SIZE];\n    if (realpath(doc_root, canonical_root) == NULL) {\n        perror(\"realpath (document root)\");\n        return 1;\n    }\n    printf(\"Document root: %s\\n\", canonical_root);\n    // --- Block all signals before creating any threads ---\n    // Workers inherit this blocked mask, so signals go to the signal thread only\n    sigset_t all_sigs;\n    sigfillset(&all_sigs);\n    pthread_sigmask(SIG_BLOCK, &all_sigs, NULL);\n    // SIGPIPE: ignore globally (must be done via sigaction, not masked)\n    struct sigaction sa_ignore = { .sa_handler = SIG_IGN };\n    sigaction(SIGPIPE, &sa_ignore, NULL);\n    // --- Initialize thread pool ---\n    if (thread_pool_init(&g_pool, DEFAULT_POOL_SIZE, DEFAULT_QUEUE_SIZE,\n                         canonical_root, DEFAULT_TIMEOUT) < 0) {\n        fprintf(stderr, \"Failed to initialize thread pool\\n\");\n        return 1;\n    }\n    printf(\"Thread pool: %d workers, queue capacity %d\\n\",\n           DEFAULT_POOL_SIZE, DEFAULT_QUEUE_SIZE);\n    // --- Create signal handler thread ---\n    pthread_t sig_thread;\n    pthread_create(&sig_thread, NULL, signal_handler_thread, &g_pool);\n    pthread_detach(sig_thread);  // Will exit after handling one signal\n    // --- Create the listening socket ---\n    int server_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_fd < 0) { perror(\"socket\"); return 1; }\n    int opt = 1;\n    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n    struct sockaddr_in addr;\n    memset(&addr, 0, sizeof(addr));\n    addr.sin_family      = AF_INET;\n    addr.sin_addr.s_addr = INADDR_ANY;\n    addr.sin_port        = htons((uint16_t)port);\n    if (bind(server_fd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {\n        perror(\"bind\"); close(server_fd); return 1;\n    }\n    if (listen(server_fd, SOMAXCONN) < 0) {\n        perror(\"listen\"); close(server_fd); return 1;\n    }\n    printf(\"Server listening on port %d\\n\", port);\n    // --- Run the accept loop (blocks until shutdown) ---\n    accept_loop(&server_fd, &g_pool);\n    // --- Wait for all workers to finish ---\n    thread_pool_join(&g_pool);\n    printf(\"Server shutdown complete.\\n\");\n    return 0;\n}\n```\n### Compiling the Multi-Threaded Server\n```bash\n# -lpthread links the POSIX threads library\n# -pthread is preferred on modern GCC: sets linker flags AND compiler flags\n# (-D_REENTRANT makes some library functions thread-safe)\ngcc -Wall -Wextra -pthread -O2 \\\n    -o http_server \\\n    main.c socket.c parser.c file_server.c thread_pool.c\n# Test graceful shutdown\n./http_server 8080 /tmp/www &\nSERVER_PID=$!\nsleep 1\n# Send 20 concurrent requests\nfor i in $(seq 20); do curl -s http://localhost:8080/ & done\n# Immediately send SIGTERM â€” server should finish in-flight requests then exit\nkill -SIGTERM $SERVER_PID\nwait $SERVER_PID\necho \"Exit code: $?\"  # Should be 0\n```\n---\n## Three-Level View: A Request Under Concurrency\nTake a GET request that arrives while 5 other requests are in flight and trace it through all three levels.\n**Level 1 â€” Your code:**\nThe main thread's `accept_loop()` calls `accept()` and gets `client_fd = 12`. It calls `thread_pool_submit(&pool, 12)`, which acquires the pool mutex, adds fd 12 to the circular queue, increments `queue_size`, and signals `not_empty`. Worker thread 3 (which was sleeping in `pthread_cond_wait()`) wakes up, dequeues `client_fd = 12`, increments `active_connections`, releases the lock, and calls `handle_connection(12, &pool)`. Meanwhile, the main thread is already back in `accept()`, accepting the next connection.\n**Level 2 â€” OS/Kernel:**\n`pthread_cond_signal()` doesn't run the sleeping thread immediately â€” it marks thread 3 as runnable and adds it to the kernel scheduler's run queue. The kernel's scheduler will run it when it gets a CPU timeslice (typically within ~1ms on a lightly loaded system, or immediately if a CPU is idle). The two threads â€” main thread in `accept()` and worker 3 in `handle_connection()` â€” run on separate CPU cores simultaneously: true parallelism on a multi-core machine.\nWhen worker 3 calls `read(client_fd, ...)`, the kernel checks the socket's receive buffer. If the HTTP request data is already there (common for localhost), it copies it to user space immediately. If not, the kernel moves thread 3 to the \"waiting for I/O\" state and puts another runnable thread on that CPU core. Zero CPU cycles wasted while waiting for network data.\n**Level 3 â€” Hardware:**\n`pthread_mutex_lock()` compiles to a `LOCK CMPXCHG` instruction (on x86) or `LDXR`/`STXR` (on ARM). These are **atomic compare-and-swap** instructions â€” hardware-enforced operations that compare and modify memory in a single, uninterruptible cycle. The CPU's cache coherence protocol (MESI) ensures that all cores see the same value for the mutex: when core 1 acquires the mutex (sets it from 0 to 1 with `CMPXCHG`), the cache coherence protocol invalidates the L1/L2 cache lines holding the mutex on all other cores, forcing them to reload from L3 or main memory. This cross-core coordination costs ~40â€“100 clock cycles (20â€“50ns at 2GHz) â€” the true cost of one mutex lock/unlock cycle.\nThis is why the law \"hold the lock only as long as necessary\" matters at the hardware level: every cycle you hold the mutex is a cycle another core spends stalled waiting for the cache line.\n---\n## Hardware Soul: Concurrency Costs\n**Thread creation overhead.** `pthread_create()` involves a system call (`clone()` on Linux) that creates a new kernel task_struct, allocates a kernel stack (8KB), and maps the user-space stack (8MB virtual, but initially only one 4KB page is actually mapped â€” the rest page-faults in as needed). Total cost: ~10â€“50Âµs. The thread pool amortizes this by creating threads at startup, not per-request.\n**Context switch cost.** When the scheduler switches between threads â€” which happens every ~1â€“4ms on a standard Linux configuration (`CONFIG_HZ = 250` or `1000`) â€” it must save all CPU registers (16 general-purpose registers, SSE/AVX state, etc.) for the outgoing thread and restore them for the incoming thread. On x86-64, this is ~80 cache lines of state. Cost: ~1â€“5Âµs per context switch. With 16 threads, context switching is infrequent and well within budget. With 1000 threads, it becomes the dominant cost.\n**False sharing.** The `pool->active_connections` and `pool->total_requests` counters are adjacent in memory, likely sharing a 64-byte cache line. When worker thread A increments `active_connections` and worker thread B increments `total_requests` simultaneously â€” both cache lines get invalidated on both cores even though they're touching different variables. This **false sharing** causes unnecessary cache coherence traffic. Production thread pools (Go's runtime, jemalloc's arena structure) use `__attribute__((aligned(64)))` or padding to place each frequently-written field on its own cache line. For this server at 16 threads, it's not a measurable issue â€” but understanding it prepares you for high-performance work.\n**Socket option `SO_RCVTIMEO` â€” the implementation.** Setting `SO_RCVTIMEO` stores a `struct timeval` in the socket's kernel data structure. When `read()` is called on the socket, the kernel's net/socket layer starts a timer. If data doesn't arrive within the timeout, the timer fires (via the kernel's timer interrupt) and wakes the blocked thread with `EAGAIN`. The cost is zero unless the timeout actually fires â€” it's a passive kernel structure, not a polling loop.\n---\n## Design Decisions: Concurrency Models\n| Model | Max Connections | Complexity | Latency | Used By |\n|-------|----------------|------------|---------|---------|\n| **Sequential (Milestone 1)** | 1 | Minimal | Serialized | Dev tools |\n| **Thread-per-connection** | OS thread limit (~32K) | Low | Low | Apache (legacy) |\n| **Bounded thread pool (this milestone) âœ“** | pool_size active, unlimited queued | Medium | Low | nginx workers, Java Servlet |\n| **epoll event loop (single thread)** | 100K+ | High | Very low | nginx master loop, Redis, Node.js |\n| **io_uring + async** | 100K+ | Very high | Minimal | Modern high-performance servers |\nThe thread pool is the right choice for this project: it handles the real concurrency challenges (bounded resources, keep-alive, graceful shutdown) while remaining understandable. The epoll model â€” where a single thread monitors thousands of sockets and handles I/O events without blocking â€” is the next step on the optimization ladder, but it requires rearchitecting how you think about connection state. Understanding the thread pool model first makes the epoll model's tradeoffs legible.\n---\n## Testing Concurrent Behavior\n```bash\n# Build with thread sanitizer to catch data races:\ngcc -Wall -Wextra -pthread -fsanitize=thread -g \\\n    -o http_server_tsan *.c\n# --- Test 1: Parallel connections work correctly ---\n./http_server 8080 /tmp/www &\nfor i in $(seq 50); do\n    curl -s http://localhost:8080/index.html > /tmp/response_$i.html &\ndone\nwait\n# All responses should be identical\nmd5sum /tmp/response_*.html | awk '{print $1}' | sort | uniq -c\n# Expected: one unique md5 with count 50\n# --- Test 2: Pool exhaustion returns 503 ---\n# Send 300 slow connections (pool default is 16)\n# Use a client that keeps connection open without completing request\npython3 - <<'EOF'\nimport socket, time, threading\ndef slow_connection(n):\n    s = socket.socket()\n    s.connect(('localhost', 8080))\n    s.send(b'GET / HTTP/1.1\\r\\nHost: localhost\\r\\n')\n    # Don't send the final \\r\\n â€” connection stays open\n    time.sleep(5)\n    s.close()\nthreads = [threading.Thread(target=slow_connection, args=(i,)) for i in range(300)]\nfor t in threads: t.start()\ntime.sleep(1)\n# Now try a normal request â€” should get 503\nimport urllib.request\ntry:\n    resp = urllib.request.urlopen('http://localhost:8080/')\n    print(f'Got {resp.status} (expected 503)')\nexcept urllib.error.HTTPError as e:\n    print(f'Got {e.code} (correct: 503)' if e.code == 503 else f'Wrong code: {e.code}')\nEOF\n# --- Test 3: Keep-alive reuse ---\n# HTTP/1.1 with keep-alive uses one TCP connection for multiple requests\ncurl -v --http1.1 http://localhost:8080/index.html \\\n         http://localhost:8080/style.css \\\n         http://localhost:8080/app.js\n# In verbose output, look for:\n# \"Re-using existing connection\" â€” curl reused the TCP connection\n# --- Test 4: Idle timeout closes lingering connections ---\n# Connect but don't send anything â€” should be closed after IDLE_TIMEOUT seconds\nnc -v localhost 8080\n# Just wait. After 30 seconds, the server should close the connection\n# You'll see nc print \"Connection closed by foreign host\"\n# --- Test 5: Graceful shutdown ---\n./http_server 8080 /tmp/www &\nSERVER_PID=$!\n# Start a slow download (10MB file) that takes several seconds\ndd if=/dev/urandom of=/tmp/www/bigfile.bin bs=1M count=10\ncurl -s http://localhost:8080/bigfile.bin > /dev/null &\nCURL_PID=$!\nsleep 1\n# Send SIGTERM while curl is downloading\nkill -SIGTERM $SERVER_PID\nwait $CURL_PID\necho \"curl exit code: $?\"  # Should be 0 â€” download completed before server exit\n# --- Test 6: Thread sanitizer for data races ---\n./http_server_tsan 8080 /tmp/www &\nfor i in $(seq 200); do curl -s http://localhost:8080/ > /dev/null & done\nwait\nkill $(pgrep http_server_tsan)\n# Check stderr for \"DATA RACE\" reports â€” there should be none\n# --- Test 7: FD leak under sustained load ---\nSERVER_PID=$(pgrep http_server)\nBASE=$(ls /proc/$SERVER_PID/fd | wc -l)\nfor i in $(seq 10000); do curl -s http://localhost:8080/ > /dev/null; done\nsleep 2\nFINAL=$(ls /proc/$SERVER_PID/fd | wc -l)\necho \"Base: $BASE, Final: $FINAL\"\n[ $((FINAL - BASE)) -le 2 ] && echo \"PASS\" || echo \"FAIL: leaked $((FINAL - BASE)) FDs\"\n```\nThe Thread Sanitizer (`-fsanitize=thread`) is a compiler-level instrumentation tool that detects data races at runtime. It instruments every memory access and records which thread last wrote each memory location. When two threads access the same memory without synchronization, it reports the race with a complete stack trace showing both threads. Running the TSan build under load is the definitive check that your mutex discipline is correct.\n---\n## Knowledge Cascade: What This Unlocks\n### 1. Connection Pool Sizing â€” The Universal Pattern\nThe bounded thread pool you just built is the same pattern used everywhere resources are finite and must be shared:\n**Database connection pools** (HikariCP, PgBouncer, pgpool-II): A PostgreSQL database can handle ~100â€“500 concurrent connections before performance degrades. An application server with 1,000 threads would saturate the database with 1,000 simultaneous connections. A connection pool (typically 10â€“50 connections) multiplexes the 1,000 application threads over the available database connections â€” exactly the same queue-and-wait model you built, with the same 503-equivalent (connection acquisition timeout).\n**HTTP client pools** (Go's `http.DefaultTransport`, Python's `requests.Session`, Java's `HttpClient`): Outgoing HTTP requests to external APIs go through a connection pool. `MaxIdleConnsPerHost` in Go limits how many idle connections to keep warm per target host. The idle timeout that you implemented per-connection is the same as `IdleConnTimeout` in Go's transport.\n**Goroutine limiting in Go** (`golang.org/x/sync/semaphore`, `errgroup`): Go goroutines are cheap (2KB stack), but unbounded goroutine creation is still a Slowloris-style attack surface. Production Go services use `semaphore.Weighted` or worker pool patterns â€” exactly what you built, with goroutines instead of pthreads.\n**Kubernetes pod autoscaling** (Horizontal Pod Autoscaler): The HPA watches CPU/memory utilization and adjusts the pod count. The underlying math is the same I/O-bound formula: `replicas = ceil(current_utilization / target_utilization)`. More replicas = bigger \"pool\" of workers. The HPA is Little's Law applied to a distributed system.\nThe math that governs all of these â€” **Little's Law** (`L = Î»W`, where `L` is average queue length, `Î»` is arrival rate, and `W` is average time in system) â€” was established by John Little in 1961. Understanding it as you've just implemented it makes every discussion of \"pool size tuning\" and \"capacity planning\" concrete rather than abstract.\n### 2. Why nginx Uses Event Loops Instead of Thread Pools\nYour thread pool model handles concurrency by giving each connection a thread. nginx's \"worker\" model handles concurrency differently: each worker process runs a single event loop using **epoll** (Linux's scalable I/O multiplexing interface), monitoring hundreds of thousands of sockets simultaneously with one thread.\nThe thread pool model hits a wall at roughly 1,000â€“10,000 concurrent connections â€” not because threads are expensive per se, but because:\n- Each blocked thread consumes a kernel task_struct whether it's actively processing or waiting for I/O\n- Context switching between thousands of threads adds scheduler overhead\n- Memory pressure from many stacks can cause TLB churn\nThe epoll model breaks this wall by reversing the model: instead of \"give each connection a thread,\" you \"have one thread handle all connections, switching between them when I/O is ready.\" epoll watches a set of file descriptors and tells you which ones have data available â€” so your one thread only wakes up when there is actual work to do, never burning CPU waiting.\nThe C10K problem (handling 10,000 concurrent connections) was the precise point where thread-per-connection broke and event loops became necessary. Dan Kegel's 1999 paper \"The C10K Problem\" documented this breakdown and catalyzed the design of epoll (Linux 2.5.44, 2002). Since then, the C10M problem (10 million connections) has been solved by io_uring (Linux 5.1, 2019), which takes event loops further by allowing truly asynchronous I/O submission â€” no context switches even to check if I/O is ready.\nEvery async/await keyword in Python, Rust, JavaScript, Go, and Kotlin traces back to this same insight that you've just hit the wall of: blocking-per-connection doesn't scale. Your thread pool is the last viable step before the event-loop revolution.\n### 3. Lock Granularity â€” Why Databases Use Row Locks, Not Table Locks\nYou protected your shared queue with a single mutex. This is a **coarse-grained lock** â€” one lock for all shared state. It's correct, simple to reason about, and fast enough for your server's concurrency level.\nAs concurrency scales, coarse-grained locks become bottlenecks. Every thread that wants to enqueue or dequeue must wait for the one global lock. If the critical section (the time between lock and unlock) is short, lock contention is low and it doesn't matter. If the critical section is long â€” or many threads contend simultaneously â€” the lock becomes a serialization point that eliminates the benefit of concurrency.\nPostgreSQL uses **row-level locking** instead of table-level locking: `UPDATE table SET x=1 WHERE id=5` locks only the row with `id=5`, allowing concurrent `UPDATE table SET x=2 WHERE id=7` on a different row. The lock granularity matches the actual contention scope.\njemalloc, the memory allocator used by Firefox and FreeBSD, uses **per-CPU arena locking**: instead of one global lock for all allocations, each CPU core has its own arena with its own lock. Threads allocating memory on the same core share a lock; threads on different cores never contend. This reduces lock contention roughly proportionally to the number of CPU cores.\nThe general lesson: choose your lock granularity by mapping it to the actual contention scope. A global mutex is correct. A per-connection mutex (protecting that connection's state only) allows full parallelism. A per-shard mutex (protecting 1/N of the shared data) is in between. Understanding the tradeoffs starts here, with your single-mutex thread pool.\n### 4. Graceful Shutdown as a Distributed Systems Primitive\nThe four-phase shutdown sequence â€” stop accepting â†’ drain in-flight â†’ notify workers â†’ wait for completion â€” is not just a multi-threading pattern. It is the fundamental primitive for any system that must handle state-changing operations without data loss.\n**Kubernetes pod termination** (`terminationGracePeriodSeconds`): When Kubernetes sends SIGTERM to a pod, it starts a grace period timer (default 30 seconds). The application should stop accepting new requests, complete in-flight requests, and exit cleanly. If it doesn't exit within `terminationGracePeriodSeconds`, Kubernetes sends SIGKILL. This is exactly your four-phase pattern with a deadline.\n**Rolling deployments**: When deploying a new version of a service, you stop traffic to old pods (stop accepting), wait for in-flight requests to complete (drain), then replace the old pod with the new one. The deployment controller implements your four-phase pattern at the infrastructure level.\n**Blue-green deployments**: Route traffic to the new (\"green\") environment. The old (\"blue\") environment stops accepting new traffic but finishes serving its in-flight requests. Once drained, blue is terminated. Same pattern, distributed across environments.\n**Database connection draining** (PostgreSQL `pg_terminate_backend()`): When a DBA needs to take a database offline for maintenance, they call `pg_terminate_backend()` on sessions and then wait for active transactions to commit or roll back. Forcibly killing a transaction mid-way leaves the database in an inconsistent state â€” exactly why graceful shutdown (let transactions complete) matters.\nEvery time you see \"draining,\" \"quiescing,\" or \"graceful termination\" in a distributed systems discussion, it's your four-phase pattern scaled up.\n### 5. The C10K/C10M Problem and the async/await Revolution\nDan Kegel's 1999 \"C10K Problem\" paper described the failure mode you just implemented a defense against: a server that spawns one thread or process per connection breaks at roughly 10,000 concurrent connections on typical hardware. The paper asked: can we handle 10,000 connections simultaneously on a single machine? \nThe answer required rethinking the programming model. epoll (2002), kqueue (BSD, 2000), IOCP (Windows NT 3.5) all emerged as kernel interfaces that let a single thread efficiently monitor thousands of connections. But writing epoll-based code in C is famously difficult â€” you manage connection state explicitly across non-blocking callbacks, fighting what's called \"callback hell.\"\nThe solution to callback hell is async/await â€” syntactic sugar that makes non-blocking I/O look like sequential code. Python's `asyncio`, JavaScript's Promise/async, Rust's `tokio`, Go's goroutines (which hide the event loop behind a scheduler that looks like threads) â€” all of them are the language ecosystem's answer to \"how do we get the performance of epoll without the programmer experience of raw epoll?\"\nUnderstanding why your thread pool hits a wall at scale â€” and why the alternative (one thread watching thousands of fds via epoll) is both faster and harder to code â€” is the historical context that makes async/await meaningful. You haven't just built a thread pool: you've built the exact system that motivated the most significant paradigm shift in server-side programming of the past 25 years.\n---\n## Common Mistakes That Will Burn You\n**1. Holding the mutex while doing network I/O.**\nThis is the most common threading mistake in server code. If you call `read()`, `write()`, or `serve_static_file()` while holding `pool->lock`, all other threads are blocked waiting for the lock for the entire duration of the I/O operation. Your \"16-thread concurrent server\" behaves like a sequential server. The rule: acquire the lock, modify the queue (a few pointer updates), release the lock, then do the I/O.\n**2. Checking the shutdown flag without the lock.**\n```c\n// WRONG â€” data race:\nif (pool->shutdown) break;\n// CORRECT:\npthread_mutex_lock(&pool->lock);\nint s = pool->shutdown;\npthread_mutex_unlock(&pool->lock);\nif (s) break;\n```\nReading `pool->shutdown` without the mutex is a data race â€” undefined behavior per the C11 standard. The compiler may optimize away the repeated read, caching it in a register and never re-reading from memory (\"the value can't change, it's not volatile\"). An alternative is `atomic_int` with `atomic_load_explicit()` using the appropriate memory ordering â€” but using the mutex you already have is simpler and equally correct.\n**3. Forgetting `pthread_detach()` or `pthread_join()` for every thread.**\nThe signal handler thread in our design is `pthread_detach()`'d â€” it runs once, handles one signal, and exits. Every `pthread_create()` must be matched by either `pthread_join()` (to collect exit status and free resources) or `pthread_detach()` (to let the thread clean up itself). An unjoined, undetached thread is a zombie: its task_struct stays in the kernel until the process exits.\n**4. Using `signal()` instead of `pthread_sigmask()` for multi-threaded signal masking.**\n`signal()` sets the disposition (what happens when a signal arrives) but does not control which thread receives it. Only `pthread_sigmask()` controls the signal mask per-thread. Setting `signal(SIGTERM, handler)` in a multi-threaded program means SIGTERM calls `handler` in whichever thread the kernel picks â€” which might be a worker thread in the middle of `write()`. Use `pthread_sigmask()` to block signals in all threads, then use `sigwait()` in a dedicated signal thread.\n**5. The `while` loop, not `if`, around `pthread_cond_wait()`.**\n```c\n// WRONG â€” spurious wakeup causes incorrect behavior:\nif (pool->queue_size == 0) {\n    pthread_cond_wait(&pool->not_empty, &pool->lock);\n}\n// here we assume queue is non-empty â€” WRONG if it was a spurious wakeup\n// CORRECT:\nwhile (pool->queue_size == 0 && !pool->shutdown) {\n    pthread_cond_wait(&pool->not_empty, &pool->lock);\n}\n```\nPOSIX permits spurious wakeups from `pthread_cond_wait()`. A thread can return from the wait even if no signal was sent. Always re-check the condition in a `while` loop.\n**6. Not setting `SO_RCVTIMEO` before the keep-alive loop.**\nIf you set the timeout option inside the loop on each iteration, you incur an extra syscall per request. Set it once per connection, before the `for(;;)` loop. The timeout applies to all subsequent reads on that socket.\n**7. Not sending 503 when the pool queue is full â€” just closing the FD.**\nSilently closing a TCP connection (without sending an HTTP response) leaves the client hanging, waiting for data that never arrives. The client's browser shows a \"connection reset\" error with no explanation. Sending a 503 response takes milliseconds and gives the client actionable information (\"server busy, try later\"). Always send a response before closing.\n---\n## Acceptance Criteria Checklist\nBefore calling this project complete, verify each of these:\n- [ ] `./http_server 8080 /tmp/www` starts with \"Thread pool: 16 workers, queue capacity 256\" (or configured values)\n- [ ] `for i in $(seq 50); do curl -s http://localhost:8080/ & done; wait` â€” all 50 responses are `200 OK` with correct content\n- [ ] Under Slowloris-style load (300 slow connections), the 301st connection receives `503 Service Unavailable` rather than timing out silently\n- [ ] `curl -v --http1.1 http://localhost:8080/index.html http://localhost:8080/style.css` shows \"Re-using existing connection\" in verbose output\n- [ ] An idle connection is closed after `idle_timeout` seconds (default 30) â€” verified with `nc localhost 8080` (no request sent)\n- [ ] `Connection: close` in a request causes the server to close after responding â€” verified with `curl -H \"Connection: close\" -v http://localhost:8080/`\n- [ ] SIGTERM causes graceful shutdown: in-flight downloads complete, server then exits with code 0\n- [ ] SIGINT (Ctrl+C) causes the same graceful shutdown behavior as SIGTERM\n- [ ] The thread sanitizer build (`-fsanitize=thread`) reports zero data races under parallel load\n- [ ] FD count after 10,000 sequential connections matches baseline (within tolerance of 2)\n- [ ] `pool->total_requests` counter accurately reflects total served requests (verify via server stats output or log)\n- [ ] Server logs show correct client IP and request line from each worker thread, without interleaving (log mutex prevents garbling)\n- [ ] After all workers are joined on shutdown, `valgrind --leak-check=full` reports no memory leaks\n- [ ] Thread pool size and queue capacity are configurable (compile-time constants at minimum, runtime arguments preferred)\n---\n<!-- END_MS -->\n\n\n\n\n# TDD\n\nA socket-level HTTP/1.1 server built from first principles: raw TCP socket lifecycle, adversarial HTTP parsing per RFC 7230, security-hardened static file serving with path canonicalization, and concurrent connection handling via a bounded thread pool with keep-alive and graceful shutdown. Every abstraction that frameworks hide â€” partial reads, CRLF parsing, MIME detection, realpath security, mutex-protected shared state â€” is made explicit and implementation-grade.\n\n\n\n<!-- TDD_MOD_ID: http-server-basic-m1 -->\n# MODULE SPECIFICATION: TCP Server & HTTP Response (http-server-basic-m1)\n\n## 1. Module Charter\nThis module establishes the foundational network \"Entry Point\" for the HTTP server. It is responsible for the complete lifecycle of a TCP listening socket and the sequential handling of incoming client connections.\n\n**Core Responsibilities:**\n- Initialize a passive TCP socket (the \"Listening Socket\") bound to a configurable port.\n- Implement the \"Seven-Step Socket Dance\": `socket`, `setsockopt`, `bind`, `listen`, `accept`, `read/write`, `close`.\n- Solve the \"Partial Read Problem\" by accumulating raw bytes into a fixed-size buffer until the HTTP header delimiter (`\\r\\n\\r\\n`) is detected.\n- Construct a standards-compliant (RFC 7230) hardcoded HTTP/1.1 200 OK response.\n- Ensure robust resource management by preventing file descriptor (FD) leaks and handling broken pipe signals (SIGPIPE).\n\n**What this module does NOT do:**\n- It does **not** parse the HTTP request (it treats it as raw bytes).\n- It does **not** handle concurrent connections (it is strictly sequential).\n- It does **not** serve files from disk (the response is hardcoded in memory).\n\n**Invariants:**\n- Every successfully `accept()`'ed file descriptor MUST be `close()`'d before the next `accept()` call.\n- The server must never crash due to a client disconnecting mid-write (SIGPIPE).\n\n---\n\n## 2. File Structure\nThe implementation shall follow this numbered creation order:\n\n1. `server.h`: Data structures and function prototypes.\n2. `utils.c`: Helper functions for robust I/O (`write_all`, `read_http_request`).\n3. `http.c`: HTTP response construction logic.\n4. `server.c`: The core socket lifecycle and accept loop.\n5. `main.c`: CLI entry point and signal initialization.\n\n---\n\n## 3. Complete Data Model\n\n### 3.1 Server Configuration Struct\nThis struct persists for the lifetime of the server process.\n\n| Field | Type | Offset (64-bit) | Description |\n| :--- | :--- | :--- | :--- |\n| `port` | `int` | 0x00 | The TCP port to bind (default 8080). |\n| `server_fd` | `int` | 0x04 | The listening socket file descriptor. |\n| `is_running` | `int` | 0x08 | Boolean flag for the accept loop. |\n| `padding` | `char[4]` | 0x0C | Alignment padding to 16-byte boundary. |\n\n**Total Size:** 16 bytes.\n\n### 3.2 Constants\n- `REQUEST_BUF_SIZE`: 8192 (8KB). Caps memory usage per request. Matches standard URI/header limits.\n- `BACKLOG`: `SOMAXCONN`. The kernel-level queue for pending connections.\n- `MAX_RESPONSE_SIZE`: 4096 (4KB). Sufficient for hardcoded headers and small HTML body.\n\n---\n\n## 4. Interface Contracts\n\n### 4.1 `ssize_t read_http_request(int client_fd, char *buf, size_t buf_size, int *header_end)`\n- **Purpose**: Accumulate bytes until `\\r\\n\\r\\n` is found.\n- **Parameters**: \n    - `client_fd`: The socket to read from.\n    - `buf`: The destination buffer.\n    - `buf_size`: Maximum capacity.\n    - `header_end`: [OUT] Offset in `buf` where headers end (start of body).\n- **Return**: Total bytes read on success, `0` on client disconnect, `-1` on error or buffer overflow.\n\n### 4.2 `int write_all(int fd, const char *buf, size_t len)`\n- **Purpose**: Ensure all bytes are written despite partial writes or interrupts.\n- **Return**: `0` on success, `-1` on error.\n\n### 4.3 `int build_hardcoded_response(char *buf, size_t buf_size)`\n- **Purpose**: Populate `buf` with a valid HTTP response string.\n- **Includes**: `Date` (RFC 1123 format), `Content-Type`, `Content-Length`, `Connection: close`.\n- **Return**: Length of response string or `-1` on overflow.\n\n---\n\n## 5. Algorithm Specification\n\n### 5.1 The Socket Dance (Phase 1-2)\n1. **socket()**: Call `socket(AF_INET, SOCK_STREAM, 0)`.\n2. **setsockopt()**: Set `SO_REUSEADDR` to `1` on `SOL_SOCKET`. This is mandatory for rapid server restarts.\n3. **bind()**: \n    - Initialize `struct sockaddr_in`.\n    - Use `htons(port)` for the port (Network Byte Order).\n    - Use `INADDR_ANY` for the IP.\n4. **listen()**: Set backlog to `SOMAXCONN`.\n\n### 5.2 The Accumulation Loop (Phase 3)\n{{DIAGRAM:tdd-diag-1|HTTP Accumulation Flow|Flowchart of read() calls searching for delimiter}}\n1. Initialize `total_read = 0`.\n2. While `total_read < buf_size - 1`:\n    - `n = read(client_fd, buf + total_read, buf_size - 1 - total_read)`.\n    - If `n <= 0`: Return `n` (Error or Disconnect).\n    - `total_read += n`.\n    - `buf[total_read] = '\\0'` (Null-terminate for `strstr`).\n    - `found = strstr(buf, \"\\r\\n\\r\\n\")`.\n    - If `found`:\n        - Calculate `*header_end = (found - buf) + 4`.\n        - Return `total_read`.\n3. If loop exits without `found`: Return `-1` (Request too large).\n\n### 5.3 The Sequential Accept Loop\n1. Call `accept(server_fd, ...)` which blocks.\n2. Log client IP/Port via `inet_ntop` and `ntohs`.\n3. Invoke `read_http_request`.\n4. If success: Invoke `build_hardcoded_response` and `write_all`.\n5. **CRITICAL**: Call `close(client_fd)` in all branches (success or failure) before looping.\n\n---\n\n## 6. Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n| :--- | :--- | :--- | :--- |\n| `EADDRINUSE` | `bind()` | Exit process with code 1. | Yes (Console) |\n| `EINTR` | `accept()` | `continue` the loop immediately. | No |\n| `EMFILE` | `accept()` | `sleep(1)`, log error, `continue`. | No |\n| `EPIPE` | `write()` | Stop writing, `close(client_fd)`, log disconnect. | No |\n| Buffer Overflow | `read_http_request` | `close(client_fd)`, do not respond. | No (Server logs only) |\n\n---\n\n## 7. Implementation Sequence with Checkpoints\n\n### Phase 1: Socket Setup (1 hour)\n- Implement `socket_init(int port)`.\n- **Checkpoint**: Run `netstat -tulpn | grep :8080`. You should see the process in `LISTEN` state.\n\n### Phase 2: Accept Loop & Logging (0.5 hours)\n- Implement the infinite loop calling `accept()`.\n- **Checkpoint**: Connect via `nc localhost 8080`. Server should print \"Connection from 127.0.0.1\".\n\n### Phase 3: The Accumulator (1 hour)\n- Implement `read_http_request`.\n- **Checkpoint**: Use `telnet localhost 8080`. Type `GET /` and press Enter once. Server should NOT respond. Type `\\r\\n\\r\\n`. Server should now acknowledge receipt.\n\n### Phase 4: Response & write_all (1 hour)\n- Implement `write_all` and `build_hardcoded_response`.\n- Handle `SIGPIPE` using `signal(SIGPIPE, SIG_IGN)`.\n- **Checkpoint**: `curl -v http://localhost:8080`. You should see full headers, the HTML body, and `* Connection #0 to host localhost left intact`.\n\n---\n\n## 8. Test Specification\n\n### 8.1 Happy Path: curl\n- **Command**: `curl -v http://localhost:8080/`\n- **Requirement**: HTTP 200 OK, `Content-Length` matches body size, `Date` matches current UTC time.\n\n### 8.2 Failure: Delimiter Search\n- **Command**: `printf \"GET / HTTP/1.1\\r\\n\" | nc -q 2 localhost 8080`\n- **Requirement**: Server should hang waiting for the final `\\r\\n`, then close connection (timeout or client quit). It must NOT send a 200 OK for a partial header.\n\n### 8.3 Resource Leak Test\n- **Command**: `for i in {1..1000}; do curl -s http://localhost:8080/ > /dev/null; done`\n- **Requirement**: Check `ls /proc/$(pgrep http_server)/fd | wc -l`. The count must be identical before and after the loop.\n\n---\n\n## 9. Performance Targets\n\n| Operation | Target | How to Measure |\n| :--- | :--- | :--- |\n| **Request Latency** | < 2ms | `curl -w \"%{time_total}\\n\" -o /dev/null -s http://localhost:8080/` |\n| **FD Baseline** | < 5 | `ls /proc/self/fd \\| wc -l` (stdin, out, err, server_fd + 1) |\n| **Throughput** | > 2000 req/sec | `wrk -t1 -c1 -d10s http://localhost:8080/` (Sequential) |\n\n---\n\n## 10. Hardware Soul & Memory Layout\n\n### Cache Line Optimization\nThe `char req_buf[8192]` is the most \"touched\" memory area. \n- **Alignment**: The buffer should be 64-byte aligned to prevent \"false sharing\" and ensure efficient cache line fills (though less critical in single-threaded mode, it's good practice).\n- **Access Pattern**: `strstr` scans sequentially. Modern CPUs (x86_64) will prefetch the next cache lines (64B segments) automatically during the scan.\n\n### Memory Layout Table\n| Memory Segment | Object | Size | Life Span |\n| :--- | :--- | :--- | :--- |\n| **Stack** | `req_buf` | 8192 B | Connection Duration |\n| **Stack** | `resp_buf` | 4096 B | Response Generation |\n| **Static** | `server_config` | 16 B | Process Lifetime |\n| **Kernel** | `socket_buffer` | ~87 KB | Socket Lifetime |\n\n---\n\n## 11. Concurrency Specification: The Barrier\nThis module uses a **Blocked Sequential Model**.\n\n{{DIAGRAM:tdd-diag-2|Sequential Blocking|Timeline showing Accept -> Read -> Write -> Close}}\n\n1. The `accept()` call blocks the main thread.\n2. While processing, any other clients are held in the **Kernel TCP Backlog**.\n3. If the backlog (e.g., 128) fills up, new clients will receive \"Connection Refused\" (ECONNREFUSED).\n4. **Benefit**: No race conditions, no mutexes, trivial to debug.\n5. **Constraint**: A slow client (Slowloris) can hang the server by connecting and sending nothing. This will be solved in Milestone 4.\n\n```c\n/* interface contract signatures */\nint server_init(server_config_t *config, int port);\nssize_t read_http_request(int client_fd, char *buf, size_t buf_size, int *header_end);\nint write_all(int fd, const char *buf, size_t len);\nint build_hardcoded_response(char *buf, size_t buf_size);\nvoid handle_client(int client_fd);\n```\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: http-server-basic-m2 -->\n# MODULE SPECIFICATION: HTTP Request Parsing (http-server-basic-m2)\n\n## 1. Module Charter\nThis module serves as the semantic gateway of the server, transforming raw, untrusted byte streams from the network (Milestone 1) into a structured, validated `http_request_t` object. It acts as the primary defense against protocol-level attacks and malformed inputs.\n\n**Core Responsibilities:**\n- Implement an adversarial-safe parser for HTTP/1.1 request lines and headers.\n- Enforce strict RFC 7230 structural constraints (CRLF line endings, single space delimiters).\n- Normalize header names to lowercase for case-insensitive lookup.\n- Extract semantic control fields: `Content-Length` (for body framing), `Connection` (for keep-alive), and `Host` (mandatory in HTTP/1.1).\n- Prevent buffer overruns and resource exhaustion via hard URI and header length limits.\n- Generate and transmit standards-compliant HTTP error responses (400, 414, 501) for invalid inputs.\n\n**Downstream Dependencies:**\n- Milestone 3 (Static File Serving) relies on the `path` and `method` fields for resource location.\n- Milestone 4 (Concurrency) relies on the `keep_alive` flag to manage connection persistence.\n\n**Invariants:**\n- The parser MUST NOT modify the original request buffer (except for temporary null-termination during line-at-a-time processing).\n- The parser MUST perform zero dynamic memory allocations (`malloc`) to ensure predictable latency and prevent heap fragmentation.\n- All extracted strings (path, header values) MUST be null-terminated within the `http_request_t` structure.\n\n---\n\n## 2. File Structure\nThe implementation is realized in the following sequence:\n\n1. `http_types.h`: Definition of enums, constants, and the monolithic `http_request_t` struct.\n2. `http_parser.h`: Prototypes for parsing and header lookup functions.\n3. `http_parser.c`: Implementation of the state-machine/line-iterator parsing logic.\n4. `http_errors.h`: Error response templates and constants.\n5. `http_errors.c`: Implementation of `send_error_response` and convenience wrappers.\n\n---\n\n## 3. Complete Data Model\n\n### 3.1 Enumerations\n```c\ntypedef enum {\n    METHOD_GET,\n    METHOD_HEAD,\n    METHOD_POST,\n    METHOD_UNKNOWN\n} http_method_t;\n```\n\n### 3.2 Header Entry Struct\nEach header is stored in a fixed-size slot.\n\n| Field | Type | Size | Description |\n| :--- | :--- | :--- | :--- |\n| `name` | `char[256]` | 256 B | Lowercase normalized header name. |\n| `value` | `char[8192]`| 8192 B | OWS-stripped header value. |\n\n### 3.3 The HTTP Request Struct (`http_request_t`)\nThis structure is designed for stack allocation within the connection handler. Note the significant size due to fixed-buffer constraints (approx 270KB).\n\n| Field | Type | Offset | Description |\n| :--- | :--- | :--- | :--- |\n| `method` | `int` | 0x00 | `http_method_t` enum value. |\n| `path` | `char[8192]` | 0x04 | Parsed URI path (null-terminated). |\n| `http_minor` | `int` | 0x2004 | 0 for 1.0, 1 for 1.1. |\n| `headers` | `http_header_t[32]` | 0x2008 | Contiguous array of header pairs. |\n| `header_count` | `int` | 0x44008 | Current valid entries in `headers`. |\n| `content_length`| `int` | 0x4400C | -1 if absent, else byte count. |\n| `keep_alive` | `int` | 0x44010 | 1 if persistent, 0 if close. |\n| `body` | `const char*` | 0x44018 | Pointer into the original M1 buffer. |\n\n**Total Size:** ~278,560 Bytes. \n*Note: Ensure the server's thread stack size (default 8MB on Linux) is respected. If spawning many threads in M4, use `pthread_attr_setstacksize` if 270KB per thread is problematic.*\n\n{{DIAGRAM:tdd-diag-7|Request Struct Memory Layout|Visualization of the 270KB stack-allocated struct and its alignment}}\n\n---\n\n## 4. Interface Contracts\n\n### 4.1 `int parse_http_request(const char *buf, size_t buf_len, int header_end, http_request_t *req)`\n- **Inputs**: Raw buffer, total bytes read, and the offset of `\\r\\n\\r\\n`.\n- **Outputs**: 0 on success, or an HTTP error code (400, 414, 501) on failure.\n- **Contract**: Rejects any request with more than 32 headers or lines exceeding 8KB.\n\n### 4.2 `const char* request_get_header(const http_request_t *req, const char *name)`\n- **Inputs**: Request struct and a **lowercase** name to search for.\n- **Return**: Pointer to the value string, or `NULL` if not found.\n- **Complexity**: O(N) where N is `header_count`.\n\n### 4.3 `void send_error_response(int client_fd, int status, const char *reason, const char *body)`\n- **Inputs**: Socket FD, status code (e.g., 414), phrase (e.g., \"URI Too Long\"), and HTML body.\n- **Invariants**: Must include `Date`, `Content-Length`, and `Connection: close`.\n\n---\n\n## 5. Algorithm Specification\n\n### 5.1 Request Line Parsing (`parse_request_line`)\nThe request line is the first line of the buffer. It must follow the format `METHOD SP URI SP VERSION`.\n\n1. **Token 1 (Method)**: \n   - Locate the first ` ` (space) using `memchr`.\n   - Length check: Must be between 3 and 4 characters for supported methods.\n   - Use `memcmp` to map `GET`, `HEAD`, `POST` to enums. If valid but unsupported, return `501`.\n2. **Token 2 (URI)**:\n   - Locate the second ` ` (space).\n   - Distance between spaces is the `path_len`. \n   - **Boundary Check**: If `path_len >= 8192`, return `414`.\n   - Copy to `req->path` and null-terminate.\n3. **Token 3 (Version)**:\n   - Must be exactly `HTTP/1.0` or `HTTP/1.1`.\n   - Verify prefix `HTTP/1.`.\n   - Set `req->http_minor` based on the final digit. If not '0' or '1', return `400`.\n\n{{DIAGRAM:tdd-diag-8|Request Line Tokenization|Step-by-step pointers moving through the first line}}\n\n### 5.2 Header Normalization and Storage (`parse_header_line`)\nExecuted for every line after the first until a blank line is hit.\n\n1. **Split**: Locate first `:` using `strchr`. If no colon, skip line (robustness).\n2. **Name Processing**: \n   - Copy prefix (name) to `headers[i].name`.\n   - Invoke `str_to_lower` on the field name. This facilitates O(1) case-insensitive comparisons later.\n3. **Value Processing (OWS Strip)**:\n   - Pointer `p` starts at `colon + 1`.\n   - While `*p == ' ' || *p == '\\t'`, increment `p`.\n   - Locate end of string; backtrack to remove trailing spaces.\n   - Copy to `headers[i].value`.\n4. **Counter**: Increment `req->header_count`. If `> 32`, stop parsing further headers.\n\n### 5.3 Semantic Extraction (`extract_semantic_headers`)\nPost-parse logic to set control flags.\n\n1. **Host**: \n   - `request_get_header(req, \"host\")`.\n   - If `http_minor == 1` and `host == NULL`, return `400` (Required in HTTP/1.1).\n2. **Content-Length**:\n   - `val_str = request_get_header(req, \"content-length\")`.\n   - Use `strtol(val_str, &end, 10)`. If `*end != '\\0'` or value `< 0`, set `content_length = -1`.\n3. **Keep-Alive**:\n   - If `http_minor == 1`: Default `1`, set `0` only if `Connection: close`.\n   - If `http_minor == 0`: Default `0`, set `1` only if `Connection: keep-alive`.\n\n---\n\n## 6. Error Handling Matrix\n\n| Error Condition | Status Code | Detection Point | Handling |\n| :--- | :--- | :--- | :--- |\n| Path > 8191 chars | 414 | `parse_request_line` | Call `send_414()`, close socket |\n| Method is `DELETE` | 501 | `parse_request_line` | Call `send_501()`, close socket |\n| Missing `Host` (1.1) | 400 | `extract_semantic_headers` | Call `send_400()`, close socket |\n| Space in URI | 400 | `parse_request_line` | RFC violation, 400 |\n| Invalid `Content-Length`| 400 | `extract_semantic_headers` | Reject request |\n| Header too long | Skip | `parse_header_line` | Skip specific header, continue |\n\n---\n\n## 7. Implementation Sequence with Checkpoints\n\n### Phase 1: Structs & Constants (0.5 hours)\n- Define `http_request_t` and `http_header_t` in `http_types.h`.\n- Set `MAX_PATH_LEN 8192` and `MAX_HEADERS 32`.\n- **Checkpoint**: Compile a test file that `sizeof(http_request_t)` and prints it. Ensure it is ~270KB.\n\n### Phase 2: String Helpers (1 hour)\n- Implement `str_to_lower` and `strip_ows`.\n- Implement `url_decode` (basic version: convert `%XX` to char).\n- **Checkpoint**: Test `strip_ows(\"  value  \")` returns `\"value\"`.\n\n### Phase 3: The Parser (2 hours)\n- Implement `parse_request_line`.\n- Implement `parse_header_line`.\n- Implement the main loop in `parse_http_request`.\n- **Checkpoint**: Pass a raw buffer of a valid GET request. Verify `req.method` is `METHOD_GET` and `req.path` is correct.\n\n### Phase 4: Error Dispatch (1 hour)\n- Implement `send_error_response` and convenience wrappers (`send_400`, etc.).\n- Integrate into the main server loop from M1.\n- **Checkpoint**: Use `curl -X DELETE http://localhost:8080`. Server should return 501.\n\n---\n\n## 8. Test Specification\n\n### 8.1 Happy Path: Header Normalization\n- **Input**: `GET / HTTP/1.1\\r\\nHOST: localhost\\r\\nUser-Agent: test\\r\\n\\r\\n`\n- **Assertion**: `request_get_header(req, \"host\")` returns `\"localhost\"`. `req->http_minor == 1`.\n\n### 8.2 Edge Case: Bare LF\n- **Input**: `GET /index.html HTTP/1.1\\nHost: localhost\\n\\n`\n- **Assertion**: Parser treats `\\n` as line terminator, correctly extracts path `/index.html`.\n\n### 8.3 Attack: URI Too Long\n- **Input**: `GET /` + ('A' * 9000) + ` HTTP/1.1\\r\\n...`\n- **Assertion**: `parse_http_request` returns `414`. `send_error_response` is called with 414.\n\n### 8.4 Attack: Null Byte Injection\n- **Input**: `GET /index.html%00.php HTTP/1.1\\r\\n...`\n- **Assertion**: `url_decode` detects `%00` and returns an error (400), or the resulting string is correctly terminated and handled as `/index.html`.\n\n---\n\n## 9. Performance Targets\n\n| Operation | Target | Measurement Method |\n| :--- | :--- | :--- |\n| **Request Parsing** | < 5Âµs | `clock_gettime(CLOCK_MONOTONIC)` around `parse_http_request` |\n| **Normalization** | < 1ns / char | Microbenchmark of `str_to_lower` |\n| **Memory Allocation**| 0 bytes | `valgrind --tool=massif` or manual audit (No `malloc` in scope) |\n\n---\n\n## 10. Hardware Soul: Cache and Pipeline\n\n### 10.1 Cache Locality\nBecause `http_request_t` is contiguous, the first few headers (usually the most important like `Host` and `Content-Length`) will likely share cache lines. When `request_get_header` iterates, the CPU's **L1 Data Cache Prefetcher** will pull the next header entries into the cache before the loop even reaches them. \n\n### 10.2 Branch Prediction\nIn `str_to_lower`, the check `if (c >= 'A' && c <= 'Z')` is a branch. In standard HTTP headers, most characters are lowercase. The **Branch Predictor** in modern CPUs (like Intel's TAGE predictor) will learn this and \"speculate\" that the character is already lowercase, executing the add-32 path only when necessary.\n\n{{DIAGRAM:tdd-diag-9|Header Search Pipeline|Visualizing L1 cache hits during the linear search of the headers array}}\n\n---\n\n## 11. State Machine Specification\n\nThe parser moves through the following states per connection:\n\n1. **STATE_REQ_LINE**: Expecting Method, Path, and Version. Transition to `STATE_HEADERS` on first CRLF.\n2. **STATE_HEADERS**: Extracting key-value pairs. Transition to `STATE_SEMANTIC` on `\\r\\n\\r\\n`.\n3. **STATE_SEMANTIC**: Post-parse validation (Host check, etc.).\n4. **STATE_COMPLETE**: Parsed successfully.\n5. **STATE_ERROR**: Invalid input detected. Send 4xx/5xx and terminate.\n\n{{DIAGRAM:tdd-diag-10|Parser States|State machine showing transitions and error exits}}\n\n---\n\n## 12. Implementation Path (C Details)\n\n**Warning: `strtok` is Forbidden.**\nUse `memchr` and pointer arithmetic. `strtok` is not thread-safe (uses internal static state) and modifies the source string. While M1 creates a copy, using `memchr` is a better systems-programming habit for immutable buffers.\n\n**Handling CRLF vs LF:**\n```c\n// Implementation snippet for line splitting\nconst char *line_start = cursor;\nconst char *line_end = memchr(cursor, '\\n', remaining_len);\nif (line_end) {\n    size_t actual_len = line_end - line_start;\n    if (actual_len > 0 && line_start[actual_len - 1] == '\\r') {\n        actual_len--; // Strip \\r\n    }\n    // process line_start with actual_len...\n}\n```\n\n**Normalization Snippet:**\n```c\nvoid str_to_lower(char *s) {\n    for (; *s; ++s) {\n        // Bitwise trick: 'A' | 0x20 == 'a'\n        // Only applies if it is actually an uppercase letter\n        if (*s >= 'A' && *s <= 'Z') *s |= 0x20;\n    }\n}\n```\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: http-server-basic-m3 -->\n# MODULE SPECIFICATION: Static File Serving (http-server-basic-m3)\n\n## 1. Module Charter\nThis module implements the core \"Payload Delivery\" logic of the HTTP server. It is responsible for mapping abstract URL paths to concrete filesystem resources while enforcing strict security boundaries. \n\n**Core Responsibilities:**\n- **Path Sanitization**: URL-decode incoming paths and reject malicious payloads (e.g., null-byte injections).\n- **Security Enforcement**: Use `realpath()` canonicalization to prevent directory traversal attacks by ensuring resolved paths reside strictly within the configured `document_root`.\n- **Resource Resolution**: Handle directory-to-index mapping (auto-serving `index.html`) and detect file metadata via `stat()`.\n- **Protocol Compliance**: Implement conditional GETs using `If-Modified-Since` and `Last-Modified` headers to support browser caching (304 Not Modified).\n- **Content Negotiation**: Map file extensions to MIME types using a static lookup table.\n- **Efficient I/O**: Stream file data from the kernel page cache to the network socket using a performance-tuned 64KB buffer loop.\n\n**What this module does NOT do:**\n- It does **not** manage connection persistence (Keep-Alive), which is handled by the M4 orchestrator.\n- It does **not** handle directory listings (it returns 403 if `index.html` is missing).\n- It does **not** perform compression (gzip/brotli).\n\n**Invariants:**\n- Every file opened via `open()` MUST be `close()`'d regardless of whether the `write()` to the socket succeeds or fails.\n- The server MUST NOT follow symbolic links that point outside the `document_root`.\n- All timestamps in HTTP headers MUST be in GMT/UTC per RFC 7231.\n\n---\n\n## 2. File Structure\nThe implementation follows this numbered creation order:\n\n1. `mime_types.h`: Static MIME type mapping table and lookup logic.\n2. `path_utils.h / .c`: `url_decode` and `resolve_safe_path` logic.\n3. `date_utils.h / .c`: RFC 1123 date formatting/parsing using `timegm`.\n4. `file_handler.h`: Prototypes for the main serving entry point.\n5. `file_handler.c`: Implementation of the 8-phase serving orchestration.\n\n---\n\n## 3. Complete Data Model\n\n### 3.1 MIME Entry Struct\nUsed in a static array to map extensions to types.\n\n| Field | Type | Offset | Description |\n| :--- | :--- | :--- | :--- |\n| `extension` | `const char*` | 0x00 | e.g., \".html\", \".png\" (includes dot). |\n| `mime_type` | `const char*` | 0x08 | e.g., \"text/html; charset=utf-8\". |\n\n**Total Size**: 16 bytes.\n\n### 3.2 Internal Constants\n- `MAX_PATH_SIZE`: 4096 (Defined by `PATH_MAX` in `limits.h`).\n- `IO_BUFFER_SIZE`: 65536 (64KB). Aligned with modern page cache/TCP window scaling.\n- `HTTP_DATE_SIZE`: 64. Buffer size for \"Wed, 21 Oct 2015 07:28:00 GMT\".\n\n{{DIAGRAM:tdd-diag-13|MIME Table Layout|Memory representation of the static MIME_TABLE array}}\n\n---\n\n## 4. Interface Contracts\n\n### 4.1 `int url_decode(const char *src, char *out, size_t out_size)`\n- **Purpose**: Convert `%XX` hex sequences to raw bytes and reject `%00`.\n- **Input**: `src` (untrusted URL path), `out` (destination), `out_size` (max capacity).\n- **Return**: `0` on success, `-1` on malformed hex or null-byte detection.\n- **Security**: If `%00` is detected, return `-1` immediately to prevent filename truncation attacks.\n\n### 4.2 `int resolve_safe_path(const char *url_path, const char *canonical_root, char *resolved_out)`\n- **Purpose**: The \"Security Firewall.\" Converts URL to absolute path and checks boundaries.\n- **Input**: Raw URL path, canonicalized document root.\n- **Output**: Writes absolute filesystem path to `resolved_out`.\n- **Return Codes**: \n    - `0`: Success.\n    - `400`: Malformed encoding.\n    - `403`: Traversal attempt (escaped root).\n    - `404`: Resource does not exist (via `realpath` failure).\n\n### 4.3 `void serve_static_file(const http_request_t *req, int client_fd, const char *canonical_root)`\n- **Purpose**: Main entry point. Orchestrates the 8 phases of file delivery.\n- **Contract**: Rejects non-regular files (pipes, sockets, devices) with 403.\n- **Performance**: Uses a stack-allocated 64KB buffer for the I/O loop.\n\n---\n\n## 5. Algorithm Specification\n\n### 5.1 The Resolve-Then-Check Algorithm\n{{DIAGRAM:tdd-diag-14|Path Resolution Sequence|Flow from raw URL to canonical path validation}}\n\n1. **Decode**: Invoke `url_decode()` on `req->path`.\n2. **Concatenate**: `snprintf` the `canonical_root` and `decoded_path` into a temporary `raw_path` buffer.\n3. **Canonicalize**: Call `realpath(raw_path, resolved_out)`.\n    - If `NULL`:\n        - If `errno == ENOENT`, return `404`.\n        - If `errno == EACCES`, return `403`.\n        - Else, return `404`.\n4. **Boundary Check**: \n    - `root_len = strlen(canonical_root)`.\n    - Perform `strncmp(resolved_out, canonical_root, root_len)`.\n    - If no match, return `403`.\n5. **Character Boundary Check**:\n    - If `resolved_out[root_len]` is not `\\0` AND not `/`, return `403`. (Prevents matching `/var/www-secret` against `/var/www`).\n\n### 5.2 Directory Index Logic (`handle_directory_path`)\n1. Call `stat(resolved_path, &st)`.\n2. If `S_ISDIR(st.st_mode)`:\n    - Check if `resolved_path` + `/index.html` exceeds `MAX_PATH_SIZE`.\n    - Append `/index.html`.\n    - Call `stat()` again on the new path.\n    - If second `stat()` fails, return `-1` (triggers 403 Forbidden).\n3. Return `0` (Success, serving index).\n\n### 5.3 64KB I/O Stream Loop\n{{DIAGRAM:tdd-diag-15|Zero-Allocation I/O Loop|Relationship between Kernel Page Cache and userspace buffer}}\n\n1. `int file_fd = open(resolved, O_RDONLY)`.\n2. While `(bytes_read = read(file_fd, io_buf, 65536)) > 0`:\n    - Invoke `write_all(client_fd, io_buf, bytes_read)`.\n    - If `write_all` fails (client disconnected), break loop.\n3. `close(file_fd)`.\n*Note: This utilizes the \"Stream Pattern\". For sequential reads, the CPU prefetcher will pull subsequent 64B cache lines into L1 while the current 64B is being written to the socket.*\n\n---\n\n## 6. Error Handling Matrix\n\n| Error Condition | Detected By | Recovery | User-Visible Response |\n| :--- | :--- | :--- | :--- |\n| `%00` in URL | `url_decode` | Stop processing. | `400 Bad Request` |\n| Symlink to `/etc` | `resolve_safe_path` | `realpath` resolves to `/etc`, `strncmp` fails. | `403 Forbidden` |\n| File does not exist | `realpath` | Check `errno == ENOENT`. | `404 Not Found` |\n| Missing `index.html`| `stat` (2nd call) | Fail directory resolution. | `403 Forbidden` |\n| Client quit mid-file | `write_all` | Close `file_fd`, return thread to pool. | N/A (Socket closed) |\n| Header buffer overflow| `snprintf` | Return code check on `snprintf`. | `500 Internal Server Error` |\n\n---\n\n## 7. Implementation Sequence with Checkpoints\n\n### Phase 1: URL & Path Security (1.5 hours)\n- Implement `url_decode` with hex-to-char logic.\n- Implement `resolve_safe_path` using `realpath()`.\n- **Checkpoint**: Test `resolve_safe_path(\"/../../etc/passwd\", \"/var/www\", out)`. It must return `403` or `404`, never `0`.\n\n### Phase 2: Metadata & MIME (1 hour)\n- Define `MIME_TABLE` in `mime_types.h`.\n- Implement `mime_type_for_path` with `strrchr` extension extraction.\n- **Checkpoint**: `mime_type_for_path(\"test.PNG\")` must return `image/png`.\n\n### Phase 3: Conditional GETs (1.5 hours)\n- Implement `format_http_date` and `parse_http_date`.\n- Implement `should_send_304` comparing `st_mtime` and `If-Modified-Since`.\n- **Checkpoint**: Set a file's mtime to 1 hour ago. Send an `If-Modified-Since` header with that timestamp. Server must return `304`.\n\n### Phase 4: The Orchestrator (2 hours)\n- Implement `serve_static_file` linking all previous phases.\n- Implement the 64KB `read/write` loop.\n- **Checkpoint**: `curl http://localhost:8080/index.html`. Verify headers and body are fully delivered.\n\n---\n\n## 8. Test Specification\n\n### 8.1 Security: Traversal Prevention\n- **Input**: `GET /%2e%2e%2f%2e%2e%2fetc%2fshadow`\n- **Requirement**: HTTP 403 or 404. Audit `strace` to ensure `open(\"/etc/shadow\")` was never called.\n\n### 8.2 Logic: Directory Indexing\n- **Structure**: `/www/images/index.html` exists.\n- **Input**: `GET /images/`\n- **Requirement**: Returns content of `/www/images/index.html`. `Content-Type: text/html`.\n\n### 8.3 Efficiency: 64KB Alignment\n- **Input**: Request a 10MB binary file.\n- **Requirement**: Monitor memory usage. Peak RSS must not grow significantly (staying within the 64KB buffer limit).\n\n---\n\n## 9. Performance Targets\n\n| Operation | Target | Measurement |\n| :--- | :--- | :--- |\n| **Path Resolution** | < 15Âµs | `CLOCK_MONOTONIC` across `resolve_safe_path`. |\n| **Throughput (L1 Cached)**| > 800 MB/s | `wget` on localhost for 1GB file. |\n| **MIME Lookup** | < 500ns | Micro-benchmark of `mime_type_for_path`. |\n| **Allocations** | 0 malloc/req | `valgrind --tool=memcheck` check. |\n\n---\n\n## 10. Hardware Soul & Systems View\n\n### 10.1 The Three-Level View\n- **Application**: Your C code calls `serve_static_file`.\n- **OS/Kernel**: \n    - `realpath()` performs `lstat()` on every directory component. This is a metadata-heavy operation.\n    - `read()` triggers the kernel to check the **Page Cache**. If found, the kernel uses its own memory-to-memory copy.\n    - `write()` fills the **TCP Send Buffer**. If the window is full, the thread blocks in the kernel, yielding the CPU.\n- **Hardware**:\n    - **DMA (Direct Memory Access)**: When the file is cold, the Disk Controller moves data to RAM without CPU involvement.\n    - **Cache Line Locality**: The `io_buf[65536]` is accessed sequentially. The CPU's L2 prefetcher fetches the next cache line (64B) while the current line is being processed by the `write()` syscall.\n\n{{DIAGRAM:tdd-diag-16|Three-Level View: File Serving|Interaction between NIC, CPU Cache, and Page Cache}}\n\n### 10.2 Cache Line Alignment\nThe `io_buf` should ideally be aligned to a 64-byte boundary.\n```c\n// System-level alignment for optimal cache line fills\nchar io_buf[IO_BUFFER_SIZE] __attribute__((aligned(64)));\n```\nThis ensures that every `read()` call fills exactly 1024 complete cache lines, preventing \"partial cache line\" updates which can trigger unnecessary cache coherence traffic on multi-core systems (even though M3 is single-request, the hardware still performs these checks).\n\n### 10.3 Syscall Overhead: realpath()\n`realpath()` is expensive because it involves multiple `lstat()` calls. For a path like `/a/b/c/d.txt`, there are 4 `lstat()` calls. At ~2Âµs per syscall, `realpath()` is the primary latency contributor for small requests.\n**Optimization Note**: The `canonical_root` is resolved once at startup to avoid re-calculating the base directory's components on every request.\n\n---\n\n## 11. Implementation Path (C Details)\n\n### 11.1 Date Handling (UTC)\n```c\n// MUST use timegm for UTC, as mktime assumes local timezone\ntime_t parse_http_date(const char *date_str) {\n    struct tm tm;\n    memset(&tm, 0, sizeof(tm));\n    if (strptime(date_str, \"%a, %d %b %Y %H:%M:%S GMT\", &tm) == NULL) return -1;\n    return timegm(&tm); \n}\n```\n\n### 11.2 File Descriptor Safety\n```c\nint file_fd = open(path, O_RDONLY);\nif (file_fd < 0) { /* handle error */ }\n\n// ... send headers ...\n\nssize_t n;\nwhile ((n = read(file_fd, buf, sizeof(buf))) > 0) {\n    if (write_all(client_fd, buf, n) < 0) break;\n}\n\n// Invariant: Close is guaranteed\nclose(file_fd);\n```\n\n### 11.3 MIME Lookup with strrchr\n```c\nconst char *ext = strrchr(path, '.');\nif (!ext) return \"application/octet-stream\";\n// Note: strrchr finds the LAST dot, handling \"archive.tar.gz\" correctly by finding \".gz\"\n```\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: http-server-basic-m4 -->\n# MODULE SPECIFICATION: Concurrent Connections (http-server-basic-m4)\n\n## 1. Module Charter\nThis module transforms the server from a sequential, single-request processor into a high-concurrency production-grade engine. It implements a bounded thread pool architecture to manage system resources predictably while serving multiple clients in parallel. The module is responsible for the transition from one-shot connections to HTTP/1.1 persistent (keep-alive) sessions, enforced by kernel-level idle timeouts (`SO_RCVTIMEO`). It establishes a robust \"Signal Handling\" architecture using a dedicated thread to ensure that `SIGTERM` and `SIGINT` trigger a graceful four-phase shutdown rather than immediate process termination. Crucially, it manages all shared state (request counters, connection slots) through strict mutex synchronization to prevent data races.\n\n**Core Responsibilities:**\n- Manage a fixed-size pool of worker threads and a circular FIFO work queue.\n- Implement the HTTP/1.1 Keep-Alive loop allowing multiple requests per TCP session.\n- Protect shared server statistics and the access log using mutexes.\n- Defend against resource exhaustion (Slowloris) via idle timeouts.\n- Orchestrate graceful shutdown: stop accepting, drain queue, join threads.\n- Handle `EMFILE` (file descriptor exhaustion) with exponential backoff.\n\n**Invariants:**\n- No shared variable (e.g., `active_connections`) shall be modified without holding the pool mutex.\n- The `pool->lock` MUST NEVER be held during any blocking I/O operation (`read`, `write`, `open`).\n- Every `pthread_create` must be balanced by a `pthread_join` or `pthread_detach`.\n\n---\n\n## 2. File Structure\nThe implementation follows this numbered creation order:\n\n1. `concurrency_types.h`: Definition of `thread_pool_t` and `work_item_t`.\n2. `thread_pool.c`: Core logic for initialization, worker loops, and submission.\n3. `connection_handler.c`: Revised `handle_connection` with Keep-Alive loop and `SO_RCVTIMEO`.\n4. `signals.c`: Dedicated signal handling thread logic.\n5. `main.c`: Final integration of signal masking and pool orchestration.\n\n---\n\n## 3. Complete Data Model\n\n### 3.1 Work Item Struct\nA minimal descriptor for tasks in the queue.\n\n| Field | Type | Offset | Description |\n| :--- | :--- | :--- | :--- |\n| `client_fd` | `int` | 0x00 | The file descriptor of the accepted connection. |\n| `padding` | `char[4]` | 0x04 | Alignment to 8-byte boundary. |\n\n### 3.2 Thread Pool Struct (`thread_pool_t`)\nThis struct contains the entire concurrency state. It is 64-byte aligned to optimize cache line utilization.\n\n| Field | Type | Offset (64-bit) | Description |\n| :--- | :--- | :--- | :--- |\n| **Queue Management** | | | |\n| `queue` | `work_item_t*` | 0x00 | Pointer to heap-allocated circular buffer. |\n| `queue_capacity`| `int` | 0x08 | Max items the queue can hold. |\n| `queue_size` | `int` | 0x0C | Current number of items in queue. |\n| `queue_head` | `int` | 0x10 | Next item to dequeue. |\n| `queue_tail` | `int` | 0x14 | Next slot for enqueue. |\n| **Synchronization** | | | |\n| `lock` | `pthread_mutex_t` | 0x18 | Global pool lock (approx 40 bytes). |\n| `not_empty` | `pthread_cond_t` | 0x40 | Signaled when work is added. |\n| `not_full` | `pthread_cond_t` | 0x70 | Signaled when space is cleared. |\n| **Workers & Life** | | | |\n| `threads` | `pthread_t*` | 0xA0 | Array of thread handles. |\n| `num_threads` | `int` | 0xA8 | Number of worker threads. |\n| `shutdown` | `int` | 0xAC | Shutdown flag (0 or 1). |\n| **Config & Stats** | | | |\n| `doc_root` | `char*` | 0xB0 | Document root (read-only). |\n| `idle_timeout` | `int` | 0xB8 | Seconds until idle close. |\n| `active_conns` | `int` | 0xBC | Count of threads currently serving. |\n| `total_reqs` | `long` | 0xC0 | Cumulative request counter. |\n\n**Cache Note**: `active_conns` and `total_reqs` are placed at the end to minimize \"False Sharing\" contention with the queue pointers which are modified at much higher frequency.\n\n{{DIAGRAM:tdd-diag-21|Memory Layout of thread_pool_t|Visualizing offsets and 64-byte alignment boundaries}}\n\n---\n\n## 4. Interface Contracts\n\n### 4.1 `int thread_pool_init(thread_pool_t *pool, int threads, int queue_size, const char *root, int timeout)`\n- **Purpose**: Initialize all sync primitives and spawn worker threads.\n- **Return**: `0` on success, `-1` on any failure (e.g., `pthread_create` error). \n- **Invariants**: If thread creation fails midway, it must cleanup all previously created threads before returning.\n\n### 4.2 `int thread_pool_submit(thread_pool_t *pool, int client_fd)`\n- **Purpose**: Push a new FD into the circular queue.\n- **Return**: `0` on success, `-1` if queue is full or pool is shutting down.\n- **Locking**: Must acquire `pool->lock`. Must signal `not_empty`.\n\n### 4.3 `void thread_pool_shutdown(thread_pool_t *pool)`\n- **Purpose**: Set shutdown flag and broadcast to all workers.\n- **Contract**: Does not join threads; merely signals intent.\n\n### 4.4 `void handle_connection(int client_fd, thread_pool_t *pool)`\n- **Purpose**: Revised request handler with Keep-Alive for-loop.\n- **Contract**: Must set `SO_RCVTIMEO` before entering the loop. Must check `req.keep_alive` after each response.\n\n---\n\n## 5. Algorithm Specification\n\n### 5.1 The Worker Loop (`worker_thread_fn`)\n1. **Wait**: \n   - Lock `pool->lock`.\n   - While `pool->queue_size == 0` AND `pool->shutdown == 0`:\n     - `pthread_cond_wait(&pool->not_empty, &pool->lock)`.\n2. **Shutdown Check**:\n   - If `pool->shutdown == 1` AND `pool->queue_size == 0`, unlock and `pthread_exit`.\n3. **Dequeue**:\n   - Copy `pool->queue[pool->queue_head]` to local variable.\n   - `pool->queue_head = (pool->queue_head + 1) % pool->queue_capacity`.\n   - `pool->queue_size--`.\n   - `pool->active_conns++`.\n   - `pthread_cond_signal(&pool->not_full)`.\n   - Unlock `pool->lock`.\n4. **Execute**:\n   - Call `handle_connection(local_fd, pool)`.\n5. **Cleanup**:\n   - Lock `pool->lock`.\n   - `pool->active_conns--`.\n   - Unlock `pool->lock`.\n\n{{DIAGRAM:tdd-diag-22|Worker Thread State Machine|Transitions between Idle, Waiting, and Serving}}\n\n### 5.2 HTTP/1.1 Keep-Alive Loop\nWithin `handle_connection`:\n1. **Timeout Setup**: `setsockopt(client_fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv))`.\n2. **Loop**:\n   - Call `read_http_request`.\n   - If `read` returns `-1` (including `EAGAIN` from timeout), `break` loop.\n   - Call `parse_http_request`.\n   - If success, call `serve_static_file`.\n   - If `req.keep_alive == 0`, `break` loop.\n   - Else, update stats and continue to next `read`.\n3. **Exit**: `close(client_fd)`.\n\n### 5.3 Dedicated Signal Thread (`signal_handler_thread`)\n1. Clear and populate `sigset_t` with `SIGINT` and `SIGTERM`.\n2. Call `sigwait(&set, &sig)`.\n3. On signal:\n   - Call `thread_pool_shutdown()`.\n   - `close(listening_socket_fd)` to break the main accept loop.\n\n---\n\n## 6. Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n| :--- | :--- | :--- | :--- |\n| `EAGAIN` / `EWOULDBLOCK`| `read()` | Idle timeout. Break keep-alive loop, `close(fd)`.| No |\n| `EMFILE` | `accept()` | Log error. `usleep(100000)` (100ms backoff) and `continue`.| No |\n| Queue Full | `thread_pool_submit`| Invoke `send_503(fd)` then `close(fd)`. | Yes (503 Error) |\n| `pthread_create` fail | `thread_pool_init` | Set `shutdown=1`, broadcast, join created threads, return -1. | No (Server fails start) |\n| `EINTR` | `accept()` | Common if debugger attached. `continue`. | No |\n\n---\n\n## 7. Implementation Sequence with Checkpoints\n\n### Phase 1: Shared State & Initialization (2 hours)\n- Define `thread_pool_t`. Implement `thread_pool_init` and the circular queue logic.\n- **Checkpoint**: Run test that initializes a pool of 4 threads and verifies that 4 threads are visible in `htop` for the process.\n\n### Phase 2: Worker Logic (2 hours)\n- Implement `worker_thread_fn` with `pthread_cond_wait`. Implement `thread_pool_submit`.\n- **Checkpoint**: Submit 10 dummy tasks (print sleep) to a pool of 2. Verify tasks are processed concurrently and the queue drains correctly.\n\n### Phase 3: Keep-Alive & Timeouts (2 hours)\n- Refactor `handle_connection` to include the `SO_RCVTIMEO` and the `for(;;)` loop.\n- **Checkpoint**: `telnet localhost 8080`. Send one request. Wait 30 seconds. Verify the server closes the connection automatically.\n\n### Phase 4: Graceful Shutdown (1 hour)\n- Implement `sigwait` thread and `thread_pool_join`.\n- **Checkpoint**: Start server, hammer it with `wrk`, then hit `Ctrl+C`. Verify \"All worker threads exited cleanly\" is printed and process exits with code 0.\n\n---\n\n## 8. Test Specification\n\n### 8.1 Load Test (Concurrency)\n- **Tool**: `wrk -t12 -c400 -d30s http://localhost:8080/index.html`\n- **Assertion**: No 500 errors. Success rate 100%. Throughput > 5000 req/sec (on standard hardware).\n\n### 8.2 Slowloris Defense\n- **Action**: Open 50 connections with `nc`, send `GET /`, then do nothing.\n- **Assertion**: After 30s, server must close all 50 connections. Server remains responsive to new `curl` requests during this time.\n\n### 8.3 Data Race Check\n- **Tool**: `gcc -fsanitize=thread`\n- **Action**: Run the server under load with thread sanitizer.\n- **Assertion**: Zero reports of \"Data race\" or \"Unlock of unheld mutex\".\n\n---\n\n## 9. Performance Targets\n\n| Operation | Target | Measurement |\n| :--- | :--- | :--- |\n| **Lock Contention** | < 5% CPU | `perf record` monitoring `pthread_mutex_lock`. |\n| **Keep-Alive Handshake Savings**| ~1.2ms / req | Comparison of 100 seq reqs with vs without Keep-Alive. |\n| **Context Switch Overhead** | < 2Âµs / task | `latency-top` or `perf stat` (cs). |\n| **FD Leakage** | 0.00% | Baseline FD count after 100k requests. |\n\n---\n\n## 10. Hardware Soul: Concurrency & Physics\n\n### 10.1 Cache Line Bouncing (MESI Protocol)\nWhen thread A modifies `pool->queue_size`, the CPU core invalidates that cache line in the L1/L2 caches of all other cores. When thread B tries to read `pool->queue_size`, it experiences a cache miss and must fetch the line from L3. This is the \"cost of synchronization.\" By holding the lock only for the few nanoseconds required to increment a pointer, we minimize the window where cores are fighting over the same cache lines.\n\n### 10.2 Atomic Instructions\nThe `pthread_mutex_lock` is implemented using hardware atomic instructions (e.g., `LOCK CMPXCHG` on x86). This is a \"bus lock\" or \"cache lock\" that ensures no other processor can modify the memory address during the operation. This takes ~20-50ns. If the lock is already held, the kernel puts the thread to sleep (`futex` syscall), which is much more expensive (~2-5Âµs).\n\n{{DIAGRAM:tdd-diag-23|The Futex Path|Sequence: Lock Attempt -> Fail -> Kernel Sleep -> Signal -> Wakeup}}\n\n---\n\n## 11. Concurrency Specification: Lock Ordering\n\nTo prevent **Deadlock**, the following hierarchy is enforced:\n1. `pool->lock` (The primary gatekeeper).\n2. `log_mutex` (The access log lock).\n\n**Illegal Pattern**: Holding `log_mutex` and then attempting to acquire `pool->lock`.\n**Mandatory Pattern**: Always acquire `pool->lock` first, then `log_mutex`. \n\nNote: Worker threads currently do not need to hold both simultaneously. They acquire `pool->lock` to update request stats, release it, then acquire `log_mutex` to write the access log line.\n\n---\n\n## 12. Implementation Path (C Details)\n\n### 12.1 The 503 Overload Response\n```c\nstatic void send_503(int client_fd) {\n    const char *msg = \"HTTP/1.1 503 Service Unavailable\\r\\n\"\n                      \"Content-Type: text/html\\r\\n\"\n                      \"Content-Length: 42\\r\\n\"\n                      \"Connection: close\\r\\n\\r\\n\"\n                      \"<h1>503</h1><p>Server Queue Full</p>\";\n    write_all(client_fd, msg, strlen(msg));\n}\n```\n\n### 12.2 Signal Masking Snippet\n```c\n// MUST do this before spawning ANY threads\nsigset_t set;\nsigfillset(&set);\npthread_sigmask(SIG_BLOCK, &set, NULL);\n// Worker threads will inherit this mask and ignore SIGINT/SIGTERM,\n// allowing our dedicated thread to catch them via sigwait().\n```\n\n### 12.3 Robust Dequeue\n```c\n// Inside worker loop\npthread_mutex_lock(&pool->lock);\nwhile(pool->queue_size == 0 && !pool->shutdown) {\n    pthread_cond_wait(&pool->not_empty, &pool->lock);\n}\n// Re-check after waking (Spurious Wakeup handling)\nif (pool->shutdown && pool->queue_size == 0) {\n    pthread_mutex_unlock(&pool->lock);\n    pthread_exit(NULL);\n}\n```\n<!-- END_TDD_MOD -->\n\n\n# Project Structure: HTTP Server (Basic)\n\n## Directory Tree\n\n```markdown\nhttp-server/\nâ”œâ”€â”€ include/                 # Header files (Definitions & Interfaces)\nâ”‚   â”œâ”€â”€ concurrency_types.h # M4: Thread pool & work structs\nâ”‚   â”œâ”€â”€ date_utils.h        # M3: RFC 1123 date formatting\nâ”‚   â”œâ”€â”€ file_handler.h      # M3: Static file serving logic\nâ”‚   â”œâ”€â”€ http_errors.h       # M2: Error response templates\nâ”‚   â”œâ”€â”€ http_parser.h       # M2: Request parsing prototypes\nâ”‚   â”œâ”€â”€ http_types.h        # M2: HTTP enums and request struct\nâ”‚   â”œâ”€â”€ mime_types.h        # M3: Extension-to-MIME mapping table\nâ”‚   â”œâ”€â”€ path_utils.h        # M3: URL decoding & path safety\nâ”‚   â”œâ”€â”€ server.h            # M1: Core socket structures\nâ”‚   â”œâ”€â”€ thread_pool.h       # M4: Pool management functions\nâ”‚   â”œâ”€â”€ connection_handler.h # M4: Connection lifecycle orchestration\nâ”‚   â””â”€â”€ signals.h           # M4: Signal handling thread interface\nâ”œâ”€â”€ src/                     # Source files (Implementations)\nâ”‚   â”œâ”€â”€ connection_handler.c # M4: Keep-alive loop & timeout logic\nâ”‚   â”œâ”€â”€ date_utils.c        # M3: timegm and strftime helpers\nâ”‚   â”œâ”€â”€ file_handler.c      # M3: 64KB stream I/O loop\nâ”‚   â”œâ”€â”€ http.c              # M1: Hardcoded response builder\nâ”‚   â”œâ”€â”€ http_errors.c       # M2: send_error_response implementation\nâ”‚   â”œâ”€â”€ http_parser.c       # M2: Line-based state machine\nâ”‚   â”œâ”€â”€ main.c              # M1/M4: Entry point & orchestrator\nâ”‚   â”œâ”€â”€ path_utils.c        # M3: realpath() & traversal checks\nâ”‚   â”œâ”€â”€ server.c            # M1: Socket dance (bind/listen)\nâ”‚   â”œâ”€â”€ signals.c           # M4: Synchronous sigwait() thread\nâ”‚   â”œâ”€â”€ thread_pool.c       # M4: Worker loops & sync primitives\nâ”‚   â””â”€â”€ utils.c             # M1: write_all & partial read logic\nâ”œâ”€â”€ build/                   # Compiled binaries (Build Artifact)\nâ”œâ”€â”€ Makefile                 # Build system (Build Artifact)\nâ”œâ”€â”€ .gitignore               # Version control exclusions\nâ””â”€â”€ README.md               # Project overview and testing guide\n```\n\n## Creation Order\n\n1.  **Project Scaffolding** (30 min)\n    *   Create `include/`, `src/`, and `build/` directories.\n    *   Set up `Makefile` with `-pthread` and `-Wall -Wextra` flags.\n    *   Initialize `server.h` with `server_config_t`.\n\n2.  **Milestone 1: The Socket Foundation** (2 hours)\n    *   Implement `src/utils.c` (`read_http_request`, `write_all`).\n    *   Implement `src/server.c` (`socket_init`, `bind`, `listen`).\n    *   Implement `src/http.c` (hardcoded response).\n    *   Create basic `src/main.c` accept loop.\n\n3.  **Milestone 2: Protocol Parsing** (3 hours)\n    *   Define `include/http_types.h` (`http_request_t`).\n    *   Implement `src/http_parser.c` (`parse_request_line`, `parse_header_line`).\n    *   Implement `src/http_errors.c` (`send_400`, `send_414`, `send_501`).\n    *   Integrate parser into the connection handler.\n\n4.  **Milestone 3: Payload Delivery & Security** (4 hours)\n    *   Implement `src/path_utils.c` (`url_decode`, `resolve_safe_path`).\n    *   Implement `src/date_utils.c` (RFC 1123 UTC formatting).\n    *   Define `include/mime_types.h` table.\n    *   Implement `src/file_handler.c` (The 8-phase serving orchestrator).\n\n5.  **Milestone 4: High Concurrency & Hardening** (4 hours)\n    *   Implement `src/thread_pool.c` (Mutex/CondVar work queue).\n    *   Implement `src/signals.c` (Dedicated signal thread logic).\n    *   Refactor `src/connection_handler.c` to include the Keep-Alive loop.\n    *   Update `src/main.c` to initialize pool and mask signals.\n\n## File Count Summary\n- **Total Header Files**: 12\n- **Total Source Files**: 12\n- **Build/Config Files**: 3\n- **Total Directories**: 3 (root, include, src)\n- **Estimated Lines of Code**: ~1,450 LOC (Implementation logic + Comments)\n"}