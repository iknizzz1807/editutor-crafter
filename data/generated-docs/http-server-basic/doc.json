{"html":"<h1 id=\"http-server-design-document\">HTTP Server: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>This system implements a concurrent HTTP/1.1 static file server that accepts TCP connections, parses HTTP requests, and serves files from a document root directory. The key architectural challenge is handling multiple concurrent client connections efficiently while maintaining proper HTTP protocol compliance and security boundaries.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<h2 id=\"context-and-problem-statement\">Context and Problem Statement</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Background for all milestones - establishes fundamental concepts needed throughout the project</p>\n</blockquote>\n<p>The HTTP server project presents a fascinating intersection of network programming, protocol implementation, and concurrent system design. While web servers might seem ubiquitous in modern computing, building one from scratch reveals the intricate dance of TCP socket management, HTTP message parsing, file system interaction, and concurrent connection handling. This section establishes the foundational concepts and challenges that make HTTP server implementation both educational and technically demanding.</p>\n<p>Understanding these fundamentals is crucial because HTTP servers must simultaneously handle multiple concerns: they operate at the intersection of network protocols (TCP/IP), application protocols (HTTP), operating system resources (file descriptors, threads), and security boundaries (filesystem access control). Each of these domains introduces its own complexity and failure modes, and their interaction creates emergent challenges that require careful architectural consideration.</p>\n<h3 id=\"the-library-desk-analogy\">The Library Desk Analogy</h3>\n<p>To build intuition about HTTP server architecture, consider the analogy of a library reference desk during peak hours. The reference desk represents your HTTP server, and library patrons represent client requests arriving over the network.</p>\n<p><strong>The Single Librarian Problem</strong>: Initially, imagine a library with one reference desk staffed by a single librarian. When a patron arrives with a question, the librarian must listen to the complete question, understand what information is being requested, locate the appropriate books or documents, and provide a complete answer before helping the next patron. If the requested information requires searching through archives in the basement, every other patron must wait in line while the librarian retrieves the material. This represents a <strong>sequential, blocking server model</strong> - each request must complete entirely before the next can begin processing.</p>\n<p><strong>The Multi-Desk Solution</strong>: As patron volume increases, the library might add multiple reference desks, each staffed by a different librarian. Now multiple patrons can be served simultaneously, with each librarian handling their own queue. However, this approach requires careful resource management - if all librarians are simultaneously searching the basement archives, the reference area becomes empty and new patrons face long delays. This represents a <strong>thread-per-connection model</strong> where each connection gets dedicated processing resources.</p>\n<p><strong>The Specialist Dispatcher Model</strong>: A more sophisticated approach involves a front desk that quickly categorizes patron requests and routes them to specialists - simple catalog questions go to one area, research requests to another, and document retrieval to a third team. The front desk never blocks on any individual request, instead maintaining awareness of all active requests and efficiently routing work. This represents an <strong>event-driven, asynchronous server model</strong> that can handle many concurrent connections without proportional resource scaling.</p>\n<p><strong>Resource Sharing and Conflicts</strong>: In all models, librarians must access shared resources - the card catalog, the archive keys, the photocopier. When multiple librarians need the same resource simultaneously, coordination becomes essential to prevent conflicts and ensure fair access. This mirrors the challenges of concurrent access to shared server resources like configuration data, log files, and cached content.</p>\n<p><strong>Request Complexity Variations</strong>: Some patron requests are simple (&quot;Where are the restrooms?&quot;) while others are complex (&quot;I need all documents related to 19th-century agricultural practices in the Pacific Northwest&quot;). Similarly, HTTP requests vary dramatically - serving a small CSS file requires minimal processing, while serving a large video file involves substantial I/O and bandwidth management. The server architecture must handle both efficiently without allowing complex requests to starve simple ones.</p>\n<p>This analogy illuminates several key architectural decisions that HTTP servers must make: How should incoming connections be accepted and queued? Should each connection receive dedicated processing resources or share them? How should the server handle requests of varying complexity? What happens when system resources become constrained?</p>\n<h3 id=\"existing-web-server-approaches\">Existing Web Server Approaches</h3>\n<p>Production web servers have evolved different architectural approaches to address the concurrency and performance challenges inherent in HTTP serving. Understanding these approaches provides context for the design decisions in our educational HTTP server implementation.</p>\n<table>\n<thead>\n<tr>\n<th>Server</th>\n<th>Concurrency Model</th>\n<th>Connection Handling</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Apache HTTP Server (traditional)</td>\n<td>Process-per-connection with pre-forking</td>\n<td>Each connection handled by dedicated process</td>\n<td>Strong isolation, robust fault tolerance, simple debugging</td>\n<td>High memory overhead, limited scalability, process creation costs</td>\n</tr>\n<tr>\n<td>Apache HTTP Server (modern)</td>\n<td>Hybrid with worker MPM</td>\n<td>Thread pool with event-driven accept</td>\n<td>Better resource efficiency than pure process model</td>\n<td>Still more overhead than pure event-driven approaches</td>\n</tr>\n<tr>\n<td>nginx</td>\n<td>Event-driven with worker processes</td>\n<td>Single-threaded event loop per CPU core</td>\n<td>Extremely high connection capacity, low memory usage</td>\n<td>Complex programming model, difficult debugging</td>\n</tr>\n<tr>\n<td>lighttpd</td>\n<td>Event-driven single process</td>\n<td>select/poll/epoll-based event loop</td>\n<td>Lightweight, efficient for static content</td>\n<td>Limited by single process, less robust under high load</td>\n</tr>\n</tbody></table>\n<p><strong>Apache&#39;s Process-per-Connection Legacy</strong>: The original Apache HTTP Server used a process-per-connection model where each incoming HTTP connection was handled by a dedicated process. This approach provided excellent isolation - a crash in one connection handler couldn&#39;t affect others - but suffered from severe scalability limitations. Process creation overhead meant that under high connection loads, significant CPU time was spent managing processes rather than serving content. Memory usage scaled linearly with concurrent connections, creating practical limits in the hundreds of simultaneous connections rather than thousands.</p>\n<p><strong>The C10K Problem and Event-Driven Solutions</strong>: The &quot;C10K problem&quot; - handling 10,000 concurrent connections on a single server - exposed the limitations of thread-per-connection and process-per-connection models. Event-driven architectures emerged as a solution, using operating system primitives like <code>select()</code>, <code>poll()</code>, and <code>epoll()</code> to monitor many connections simultaneously within a single thread. nginx popularized this approach, demonstrating that a single server could handle tens of thousands of concurrent connections with minimal memory overhead.</p>\n<p><strong>Hybrid Threading Models</strong>: Modern servers often combine approaches to balance simplicity and performance. A common pattern uses a small number of worker threads (typically one per CPU core) where each worker runs an event loop managing many connections. This provides the scalability benefits of event-driven architecture while maintaining some isolation between workers and enabling utilization of multiple CPU cores.</p>\n<p><strong>Thread Pool with Connection Queuing</strong>: Another common approach maintains a pool of worker threads that pull connection-handling tasks from a shared queue. New connections are accepted by a dedicated acceptor thread and placed in the work queue, where available worker threads can claim them. This model provides good resource control - the thread pool size can be tuned based on system resources - while avoiding the overhead of creating threads per connection.</p>\n<blockquote>\n<p><strong>Critical Insight</strong>: The choice of concurrency model fundamentally determines server scalability characteristics. Process-per-connection models excel at isolation and simplicity but scale poorly. Event-driven models achieve excellent scalability but increase implementation complexity and debugging difficulty. Thread pools balance these concerns but introduce coordination complexity.</p>\n</blockquote>\n<p><strong>Resource Management Implications</strong>: Each concurrency model has different implications for system resource usage. Process-per-connection models consume significant memory per connection (typically several MB per process) but provide strong CPU isolation. Thread-per-connection models reduce memory overhead (typically 8KB-2MB per thread depending on stack size) but share address space. Event-driven models minimize per-connection overhead (typically a few KB per connection state structure) but concentrate processing in fewer threads, potentially creating CPU bottlenecks.</p>\n<p><strong>Error Isolation Trade-offs</strong>: The concurrency model also determines fault isolation characteristics. In process-per-connection models, a crash in request handling affects only that single connection. In thread-per-connection models, a crash can potentially bring down the entire server process. Event-driven models face similar risks, where a bug in connection handling can affect many connections processed by the same event loop.</p>\n<h3 id=\"core-technical-challenges\">Core Technical Challenges</h3>\n<p>Building an HTTP server involves navigating several categories of technical challenges, each with distinct characteristics and common failure modes. Understanding these challenges upfront helps inform architectural decisions and implementation priorities.</p>\n<h4 id=\"network-programming-complexity\">Network Programming Complexity</h4>\n<p>Network programming introduces fundamental challenges that don&#39;t exist in traditional single-process applications. The most basic challenge is the <strong>asynchronous and unreliable nature of network communication</strong>. Unlike function calls within a process, network operations can fail in numerous ways: connections can be refused, data can be lost or corrupted, remote hosts can become unreachable, and operations can timeout. These failures can occur at any point during communication, requiring comprehensive error handling throughout the server implementation.</p>\n<p><strong>Socket Lifecycle Management</strong> presents another layer of complexity. Each client connection involves creating a socket file descriptor, binding it to network addresses, managing its state transitions (listening, accepting, reading, writing), and ensuring proper cleanup. File descriptor leaks are a common failure mode - forgetting to close socket file descriptors eventually exhausts the operating system&#39;s file descriptor limit, causing the server to refuse new connections even when CPU and memory resources are available.</p>\n<p><strong>Partial Read/Write Operations</strong> create subtle bugs that are difficult to reproduce in testing but common in production. Network operations like <code>read()</code> and <code>write()</code> are not guaranteed to process all requested data in a single call. A call to <code>read(fd, buffer, 1024)</code> might only read 237 bytes if that&#39;s all currently available in the kernel&#39;s socket buffer. Similarly, <code>write()</code> operations might only transmit part of the data if the socket&#39;s send buffer becomes full. Robust network code must loop on these operations, tracking progress and resuming from partial completion.</p>\n<table>\n<thead>\n<tr>\n<th>Network Challenge</th>\n<th>Common Failure Mode</th>\n<th>Detection Method</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Connection timeouts</td>\n<td>Client connects but never sends data</td>\n<td>Set socket timeout options, monitor idle time</td>\n<td>Close connection after timeout period</td>\n</tr>\n<tr>\n<td>Partial reads</td>\n<td>HTTP parsing fails on incomplete headers</td>\n<td>Track bytes read vs expected, buffer management</td>\n<td>Continue reading until complete message received</td>\n</tr>\n<tr>\n<td>Partial writes</td>\n<td>Response truncated, client sees incomplete data</td>\n<td>Check <code>write()</code> return value vs intended bytes</td>\n<td>Loop on writes, track progress, handle EAGAIN</td>\n</tr>\n<tr>\n<td>File descriptor exhaustion</td>\n<td><code>accept()</code> returns -1 with EMFILE/ENFILE</td>\n<td>Monitor return values, system fd limits</td>\n<td>Close idle connections, implement connection limits</td>\n</tr>\n<tr>\n<td>Port binding conflicts</td>\n<td>Server fails to start, address already in use</td>\n<td><code>bind()</code> returns -1 with EADDRINUSE</td>\n<td>Use SO_REUSEADDR socket option, check port availability</td>\n</tr>\n</tbody></table>\n<p><strong>Endianness and Binary Data Handling</strong> introduces platform-specific complexity. Network protocols typically use network byte order (big-endian), while many modern processors use little-endian byte order. Functions like <code>htons()</code> (host-to-network-short) and <code>ntohs()</code> (network-to-host-short) are essential for converting port numbers and addresses correctly. Failure to handle byte order conversion can cause connections to fail or bind to unexpected ports.</p>\n<h4 id=\"http-protocol-parsing-challenges\">HTTP Protocol Parsing Challenges</h4>\n<p>The HTTP/1.1 protocol appears deceptively simple in examples, but robust parsing requires handling numerous edge cases and protocol variations. <strong>Line Ending Variations</strong> present an immediate challenge - the HTTP specification mandates CRLF (<code>\\r\\n</code>) line endings, but real-world clients sometimes send only LF (<code>\\n</code>). Parsers must handle both variations gracefully while maintaining protocol compliance.</p>\n<p><strong>Header Parsing Complexity</strong> extends beyond simple key-value extraction. HTTP headers can span multiple lines using continuation syntax, where subsequent lines beginning with whitespace are considered part of the previous header. Header values can contain quoted strings with escape sequences. Header names are case-insensitive, requiring normalization for consistent processing. Some headers like <code>Set-Cookie</code> can appear multiple times in a single response, requiring special handling.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Example complex header scenarios:\nX-Custom-Header: value spans\n    multiple lines\nContent-Type: text/html; charset=&quot;utf-8&quot;\nSet-Cookie: session=abc123; Path=/\nSet-Cookie: preferences=theme:dark; Expires=Wed, 09 Jun 2023 10:18:14 GMT</code></pre></div>\n\n<p><strong>Content Length and Transfer Encoding</strong> create parsing state machine complexity. HTTP messages can indicate body length in several ways: explicit <code>Content-Length</code> header, chunked transfer encoding, or connection close. Each approach requires different parsing logic and buffer management. Chunked encoding, in particular, requires parsing hex-encoded chunk sizes and handling chunk boundaries correctly.</p>\n<table>\n<thead>\n<tr>\n<th>HTTP Parsing Challenge</th>\n<th>Impact</th>\n<th>Solution Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Malformed request lines</td>\n<td>Server crash or incorrect routing</td>\n<td>Validate components, return 400 Bad Request for invalid format</td>\n</tr>\n<tr>\n<td>Missing required headers</td>\n<td>Protocol violation, client confusion</td>\n<td>Check for Host header in HTTP/1.1, return appropriate error codes</td>\n</tr>\n<tr>\n<td>Oversized headers</td>\n<td>Memory exhaustion, DoS vulnerability</td>\n<td>Implement header size limits, return 431 Request Header Fields Too Large</td>\n</tr>\n<tr>\n<td>Invalid method names</td>\n<td>Security issues, unexpected behavior</td>\n<td>Whitelist valid methods, return 405 Method Not Allowed</td>\n</tr>\n<tr>\n<td>URL encoding issues</td>\n<td>Path traversal, security vulnerabilities</td>\n<td>Proper URL decoding with validation</td>\n</tr>\n</tbody></table>\n<p><strong>Request Body Handling</strong> introduces additional complexity for methods like POST and PUT. The server must read the exact number of bytes specified by the <code>Content-Length</code> header - reading too few leaves data in the socket buffer that corrupts subsequent requests, while reading too many can block waiting for data that never arrives. For chunked encoding, the server must parse chunk headers and reconstruct the original message body.</p>\n<h4 id=\"concurrency-and-thread-safety\">Concurrency and Thread Safety</h4>\n<p>Concurrent connection handling multiplies the complexity of every operation by introducing race conditions, resource contention, and synchronization requirements. <strong>Shared State Management</strong> becomes critical when multiple connections need access to server configuration, cached data, or shared resources like log files. Without proper synchronization, concurrent access can corrupt data structures, leading to crashes or incorrect behavior.</p>\n<p><strong>Resource Contention</strong> occurs when multiple connections compete for limited resources. File descriptor limits, memory allocation, thread pools, and even CPU cache lines become points of contention under high load. The server must implement fair resource allocation policies and graceful degradation when resources become scarce.</p>\n<p><strong>Deadlock Prevention</strong> requires careful ordering of lock acquisition and understanding of dependency relationships between shared resources. A common deadlock scenario occurs when one thread holds a connection lock while waiting for a file system lock, while another thread holds the file system lock while waiting for the connection lock. Breaking such cycles requires consistent lock ordering or timeout-based lock acquisition.</p>\n<table>\n<thead>\n<tr>\n<th>Concurrency Challenge</th>\n<th>Risk</th>\n<th>Prevention Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Race conditions in request counting</td>\n<td>Incorrect statistics, resource leaks</td>\n<td>Use atomic operations or proper locking</td>\n</tr>\n<tr>\n<td>Multiple threads writing to log files</td>\n<td>Corrupted log entries, file system errors</td>\n<td>Synchronize log writes or use per-thread log buffers</td>\n</tr>\n<tr>\n<td>Thread pool exhaustion</td>\n<td>New connections hang indefinitely</td>\n<td>Implement connection limits and queue bounds</td>\n</tr>\n<tr>\n<td>Memory allocation contention</td>\n<td>Performance degradation under load</td>\n<td>Use thread-local allocators or lock-free data structures</td>\n</tr>\n<tr>\n<td>Signal handling in multi-threaded context</td>\n<td>Undefined behavior, crashes</td>\n<td>Block signals in worker threads, handle in dedicated thread</td>\n</tr>\n</tbody></table>\n<p><strong>Thread Lifecycle Management</strong> adds operational complexity. Worker threads must be created, assigned work, monitored for health, and cleanly shut down during server restart. Thread creation is expensive, so servers typically use thread pools, but pool sizing requires balancing resource usage against responsiveness. Too few threads create bottlenecks under load, while too many threads can cause excessive context switching overhead.</p>\n<p><strong>Graceful Shutdown Coordination</strong> becomes complex with multiple concurrent connections. The server must stop accepting new connections, complete in-flight requests within a reasonable timeout, release resources cleanly, and coordinate shutdown across all worker threads. This requires careful state management and inter-thread communication.</p>\n<blockquote>\n<p><strong>Design Principle</strong>: The complexity of concurrent systems grows exponentially with the number of shared resources and interaction points. Minimizing shared state and designing for isolation reduces both implementation complexity and debugging difficulty.</p>\n</blockquote>\n<p>These technical challenges influence every architectural decision in HTTP server design. The choice of concurrency model affects network programming complexity - event-driven servers must handle partial operations differently than thread-per-connection servers. HTTP parsing requirements influence buffer management strategies and error handling approaches. Understanding these challenges upfront enables making informed trade-offs between simplicity, performance, and robustness throughout the implementation process.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>Understanding the theoretical challenges is essential, but translating them into working code requires practical knowledge of tools, libraries, and development approaches. This guidance bridges the gap between conceptual understanding and actual implementation.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<p>The choice of programming language significantly impacts implementation complexity and learning outcomes. Each language provides different levels of abstraction and safety guarantees for network programming:</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Beginner-Friendly Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Socket Programming</td>\n<td>C with BSD sockets (manual memory management)</td>\n<td>Go with net package (garbage collected, safer)</td>\n</tr>\n<tr>\n<td>HTTP Parsing</td>\n<td>Manual string parsing with explicit state machine</td>\n<td>Rust with nom parser combinator library</td>\n</tr>\n<tr>\n<td>Concurrency</td>\n<td>pthread library with manual thread management</td>\n<td>Go with goroutines and channels</td>\n</tr>\n<tr>\n<td>File I/O</td>\n<td>POSIX file operations (open/read/write/close)</td>\n<td>Rust with async I/O and proper error types</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>Command-line arguments with getopt</td>\n<td>TOML/YAML configuration files with validation</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>Printf to stdout/stderr</td>\n<td>Structured logging with log levels and rotation</td>\n</tr>\n</tbody></table>\n<p><strong>C Language Considerations</strong>: C provides the most direct exposure to underlying system concepts, making it excellent for educational purposes. However, C requires manual memory management, explicit error checking, and careful buffer management. Common C pitfalls include buffer overflows, memory leaks, and format string vulnerabilities. The lack of built-in string handling means implementing HTTP parsing requires careful attention to buffer boundaries.</p>\n<p><strong>Go Language Benefits</strong>: Go simplifies many network programming challenges through garbage collection, built-in string types, and comprehensive standard library networking support. The <code>net/http</code> package provides high-level abstractions, but implementing from scratch using <code>net</code> package sockets still exposes core concepts while providing memory safety. Go&#39;s goroutines make concurrent programming more approachable than manual thread management.</p>\n<p><strong>Rust Language Advantages</strong>: Rust provides memory safety without garbage collection and excellent error handling through the <code>Result</code> type system. However, Rust&#39;s ownership system can create learning obstacles for developers new to the language. The async ecosystem in Rust is powerful but complex for educational purposes.</p>\n<h4 id=\"essential-c-socket-programming-foundation\">Essential C Socket Programming Foundation</h4>\n<p>For C implementation, several fundamental patterns appear throughout HTTP server code. Understanding these patterns prevents common mistakes:</p>\n<p><strong>Socket Creation and Error Handling Pattern</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Socket creation with proper error handling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> create_server_socket</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> port</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> sockfd;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> sockaddr_in server_addr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> opt </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create socket with AF_INET, SOCK_STREAM, 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check if socket creation failed (returns -1)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Set SO_REUSEADDR option to avoid \"Address already in use\" errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Configure server_addr structure with AF_INET, INADDR_ANY, htons(port)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Bind socket to address, check for errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Start listening with reasonable backlog (e.g., 128)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return socket file descriptor</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Error handling: close socket and return -1 on any failure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Connection Accept Loop Pattern</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Main server loop accepting connections</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> server_main_loop</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> server_fd</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> sockaddr_in client_addr;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    socklen_t</span><span style=\"color:#E1E4E8\"> client_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(client_addr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> client_fd;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (server_running) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Accept incoming connection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Handle accept errors (EINTR should retry, others should log and continue)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: For thread-per-connection: create thread for handle_client(client_fd)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: For sequential: call handle_client(client_fd) directly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Ensure client_fd is closed in all code paths</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Safe Read/Write Operations</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Read complete HTTP request handling partial reads</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#B392F0\"> read_complete_request</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> sockfd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buffer</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> max_size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> total_read </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> bytes_read;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (total_read </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> max_size </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Read available data into buffer + total_read</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Handle read errors (EAGAIN/EWOULDBLOCK for non-blocking sockets)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Handle connection close (bytes_read == 0)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Update total_read counter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Check for complete HTTP request (look for \\r\\n\\r\\n)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Break when complete request found</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Null-terminate buffer and return total bytes read</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"http-message-structure-reference\">HTTP Message Structure Reference</h4>\n<p>Understanding HTTP message format is crucial for parser implementation:</p>\n<table>\n<thead>\n<tr>\n<th>HTTP Request Component</th>\n<th>Format</th>\n<th>Example</th>\n<th>Parsing Notes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Request Line</td>\n<td>METHOD URI HTTP/1.1\\r\\n</td>\n<td>GET /index.html HTTP/1.1\\r\\n</td>\n<td>Split on spaces, validate each component</td>\n</tr>\n<tr>\n<td>Header Lines</td>\n<td>Name: Value\\r\\n</td>\n<td>Content-Type: text/html\\r\\n</td>\n<td>Split on first colon, trim whitespace</td>\n</tr>\n<tr>\n<td>Header End</td>\n<td>\\r\\n</td>\n<td>\\r\\n</td>\n<td>Indicates end of headers, body follows</td>\n</tr>\n<tr>\n<td>Message Body</td>\n<td>Raw bytes</td>\n<td>File contents or form data</td>\n<td>Length specified by Content-Length header</td>\n</tr>\n</tbody></table>\n<p><strong>Common HTTP Methods to Support</strong>:</p>\n<ul>\n<li>GET: Retrieve resource, no request body</li>\n<li>HEAD: Like GET but response body omitted</li>\n<li>POST: Submit data, request body contains data</li>\n<li>OPTIONS: Query server capabilities</li>\n<li>Return 405 Method Not Allowed for unsupported methods</li>\n</ul>\n<p><strong>Essential Response Status Codes</strong>:</p>\n<ul>\n<li>200 OK: Successful GET request</li>\n<li>404 Not Found: Requested file doesn&#39;t exist</li>\n<li>400 Bad Request: Malformed HTTP request</li>\n<li>405 Method Not Allowed: Unsupported HTTP method</li>\n<li>500 Internal Server Error: Server-side error occurred</li>\n</ul>\n<h4 id=\"file-system-security-patterns\">File System Security Patterns</h4>\n<p>Preventing directory traversal attacks requires careful path validation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Secure path resolution preventing directory traversal</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> validate_and_resolve_path</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">document_root</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">request_path</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                            char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">resolved_path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> max_path_len</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Remove leading slash from request_path if present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Decode URL-encoded characters in request_path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Join document_root and request_path safely</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Resolve symbolic links and relative paths (realpath())</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify resolved path starts with document_root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return error if path traversal detected</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check if resolved path exists and is readable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Copy resolved path to output buffer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>MIME Type Detection</strong>:\nCommon file extension to Content-Type mappings:</p>\n<ul>\n<li>.html, .htm → text/html</li>\n<li>.css → text/css</li>\n<li>.js → application/javascript</li>\n<li>.png → image/png</li>\n<li>.jpg, .jpeg → image/jpeg</li>\n<li>.gif → image/gif</li>\n<li>Unknown extensions → application/octet-stream</li>\n</ul>\n<h4 id=\"development-and-testing-setup\">Development and Testing Setup</h4>\n<p><strong>Compilation flags for development</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Development build with debugging symbols and warnings</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -Wall</span><span style=\"color:#79B8FF\"> -Wextra</span><span style=\"color:#79B8FF\"> -g</span><span style=\"color:#79B8FF\"> -DDEBUG</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> httpserver</span><span style=\"color:#79B8FF\"> *</span><span style=\"color:#9ECBFF\">.c</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Production build with optimizations</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -O2</span><span style=\"color:#79B8FF\"> -DNDEBUG</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> httpserver</span><span style=\"color:#79B8FF\"> *</span><span style=\"color:#9ECBFF\">.c</span></span></code></pre></div>\n\n<p><strong>Testing with command-line tools</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test basic connectivity</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">telnet</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Send manual HTTP request</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">printf</span><span style=\"color:#9ECBFF\"> \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> nc</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test with curl</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test concurrent connections</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ab</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#9ECBFF\"> http://localhost:8080/</span></span></code></pre></div>\n\n<p><strong>Debugging techniques</strong>:</p>\n<ul>\n<li>Use <code>strace</code> to monitor system calls: <code>strace -e trace=network,file ./httpserver</code></li>\n<li>Monitor network traffic: <code>tcpdump -i lo port 8080</code></li>\n<li>Check file descriptor usage: <code>lsof -p $(pidof httpserver)</code></li>\n<li>Memory leak detection: <code>valgrind --leak-check=full ./httpserver</code></li>\n</ul>\n<h4 id=\"project-structure-organization\">Project Structure Organization</h4>\n<p>Recommended file organization for maintainable HTTP server implementation:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>httpserver/\n├── src/\n│   ├── main.c                 ← Entry point, argument parsing\n│   ├── tcp_server.c           ← Socket creation, connection accept loop\n│   ├── tcp_server.h           ← TCP server interface definitions\n│   ├── http_parser.c          ← HTTP request/response parsing\n│   ├── http_parser.h          ← HTTP data structures and functions\n│   ├── file_handler.c         ← Static file serving, MIME types\n│   ├── file_handler.h         ← File operations interface\n│   ├── worker_pool.c          ← Thread pool management (optional)\n│   ├── worker_pool.h          ← Concurrency management interface\n│   └── utils.c                ← Common utilities (logging, string ops)\n├── tests/\n│   ├── test_http_parser.c     ← Unit tests for HTTP parsing\n│   ├── test_file_handler.c    ← Unit tests for file operations\n│   └── integration_test.sh    ← End-to-end server tests\n├── www/                       ← Document root for testing\n│   ├── index.html\n│   ├── styles.css\n│   └── images/\n├── Makefile                   ← Build configuration\n└── README.md                  ← Usage instructions</code></pre></div>\n\n<p>This organization separates concerns clearly, making it easier to implement and test each component independently while maintaining clean interfaces between components.</p>\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundation for all milestones - defines scope boundaries and implementation priorities throughout the project</p>\n</blockquote>\n<p>The goals and non-goals section serves as our project compass, establishing clear boundaries between what we will build and what we deliberately exclude. Think of this like <strong>planning a camping trip</strong> - you need to decide what essential gear to pack (functional requirements), what level of comfort you&#39;re targeting (non-functional requirements), and what luxury items to leave behind despite being tempting (explicit non-goals). Just as a successful camping trip requires balancing necessity against pack weight, our HTTP server must balance educational value against implementation complexity.</p>\n<p>This educational HTTP server prioritizes <strong>deep understanding of core networking and concurrency concepts</strong> over comprehensive HTTP feature coverage. We&#39;re building a production-quality foundation that demonstrates proper socket programming, HTTP protocol handling, and concurrent connection management, while deliberately excluding advanced features that would obscure these fundamental lessons.</p>\n<p>The scope decisions made here directly impact our architectural choices throughout the project. Each functional requirement drives specific component responsibilities, each non-functional requirement influences our concurrency model selection, and each explicit non-goal prevents scope creep that could derail the learning objectives.</p>\n<h3 id=\"functional-requirements\">Functional Requirements</h3>\n<p>The functional requirements define the <strong>core HTTP/1.1 capabilities</strong> that our server must implement to qualify as a working static file server. These requirements map directly to our four project milestones and establish the minimum viable functionality needed for real-world HTTP communication.</p>\n<p><strong>TCP Connection Management</strong> forms the foundation of our server architecture. The server must bind to a configurable port address and maintain a stable listening socket throughout its lifecycle. The connection acceptance process must handle the complete TCP handshake sequence, managing the transition from listening socket to established client connections. Each accepted connection requires proper resource allocation and cleanup to prevent file descriptor leaks over extended operation periods.</p>\n<table>\n<thead>\n<tr>\n<th>Requirement</th>\n<th>Acceptance Criteria</th>\n<th>Milestone</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Port Binding</td>\n<td>Bind to configurable port (default 8080) using <code>AF_INET</code> and <code>SOCK_STREAM</code></td>\n<td>1</td>\n</tr>\n<tr>\n<td>Connection Acceptance</td>\n<td>Accept multiple sequential and concurrent client connections</td>\n<td>1, 4</td>\n</tr>\n<tr>\n<td>Socket Resource Management</td>\n<td>Properly close client file descriptors and free associated memory</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Connection Lifecycle</td>\n<td>Handle complete TCP connection establishment and teardown</td>\n<td>1</td>\n</tr>\n</tbody></table>\n<p><strong>HTTP Protocol Compliance</strong> ensures our server correctly interprets and responds to HTTP/1.1 messages according to RFC specifications. The request parsing component must handle the three-part HTTP message structure: request line, headers, and optional body. Response generation must include proper status codes, required headers, and correctly formatted message structure.</p>\n<table>\n<thead>\n<tr>\n<th>Requirement</th>\n<th>Acceptance Criteria</th>\n<th>Milestone</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Request Line Parsing</td>\n<td>Extract method, path, and HTTP version from first request line</td>\n<td>2</td>\n</tr>\n<tr>\n<td>Header Processing</td>\n<td>Parse headers into key-value pairs with whitespace normalization</td>\n<td>2</td>\n</tr>\n<tr>\n<td>GET Method Support</td>\n<td>Handle GET requests with appropriate response generation</td>\n<td>2</td>\n</tr>\n<tr>\n<td>HTTP Response Format</td>\n<td>Generate responses with status line, headers, and body</td>\n<td>2</td>\n</tr>\n<tr>\n<td>Host Header Extraction</td>\n<td>Parse Host header for virtual host routing capability</td>\n<td>2</td>\n</tr>\n<tr>\n<td>Error Response Generation</td>\n<td>Return appropriate 4xx/5xx responses for invalid requests</td>\n<td>2</td>\n</tr>\n</tbody></table>\n<p><strong>Static File Serving</strong> capabilities transform URL paths into filesystem operations while maintaining security boundaries. The path resolution system must safely map HTTP request paths to filesystem locations within a configured document root directory. Content delivery includes proper MIME type detection and binary file handling.</p>\n<table>\n<thead>\n<tr>\n<th>Requirement</th>\n<th>Acceptance Criteria</th>\n<th>Milestone</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Document Root Mapping</td>\n<td>Map URL paths to filesystem paths within configured root directory</td>\n<td>3</td>\n</tr>\n<tr>\n<td>File Content Delivery</td>\n<td>Read and serve file contents with correct Content-Length header</td>\n<td>3</td>\n</tr>\n<tr>\n<td>MIME Type Detection</td>\n<td>Set Content-Type header based on file extension analysis</td>\n<td>3</td>\n</tr>\n<tr>\n<td>404 Not Found Handling</td>\n<td>Return 404 responses for non-existent files with proper error page</td>\n<td>3</td>\n</tr>\n<tr>\n<td>Directory Traversal Prevention</td>\n<td>Reject requests containing <code>../</code> sequences or other path escape attempts</td>\n<td>3</td>\n</tr>\n<tr>\n<td>Directory Listing</td>\n<td>Display directory contents when request path maps to directory</td>\n<td>3</td>\n</tr>\n<tr>\n<td>Binary File Support</td>\n<td>Correctly serve binary files without content corruption</td>\n<td>3</td>\n</tr>\n</tbody></table>\n<p><strong>Concurrent Connection Handling</strong> enables the server to process multiple client requests simultaneously without blocking. The concurrency implementation must prevent one slow client from stalling service to other clients. Resource management becomes critical under concurrent load to prevent memory exhaustion and file descriptor depletion.</p>\n<table>\n<thead>\n<tr>\n<th>Requirement</th>\n<th>Acceptance Criteria</th>\n<th>Milestone</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Thread-per-Connection Model</td>\n<td>Create dedicated thread for each client connection</td>\n<td>4</td>\n</tr>\n<tr>\n<td>Thread Pool Option</td>\n<td>Limit concurrent threads to prevent resource exhaustion</td>\n<td>4</td>\n</tr>\n<tr>\n<td>Non-blocking I/O Option</td>\n<td>Handle multiple connections using select/poll event-driven model</td>\n<td>4</td>\n</tr>\n<tr>\n<td>Graceful Shutdown</td>\n<td>Complete in-flight requests before server termination</td>\n<td>4</td>\n</tr>\n<tr>\n<td>Connection Limits</td>\n<td>Reject new connections when resource limits are reached</td>\n<td>4</td>\n</tr>\n<tr>\n<td>Thread Safety</td>\n<td>Ensure shared resources are properly synchronized between threads</td>\n<td>4</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight</strong>: These functional requirements intentionally focus on <strong>depth over breadth</strong>. Rather than implementing dozens of HTTP features superficially, we implement core networking, parsing, file serving, and concurrency concepts thoroughly. This approach ensures learners understand the foundational principles that apply to any networked service, not just HTTP servers.</p>\n</blockquote>\n<p><strong>Configuration Management</strong> provides runtime flexibility without requiring recompilation. The server must accept configuration parameters for port binding, document root directory, thread pool sizes, and connection limits. Configuration validation ensures the server fails fast with clear error messages rather than exhibiting undefined behavior with invalid settings.</p>\n<table>\n<thead>\n<tr>\n<th>Configuration Parameter</th>\n<th>Type</th>\n<th>Default Value</th>\n<th>Validation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Listen Port</td>\n<td>Integer</td>\n<td>8080</td>\n<td>Range 1-65535, not in use</td>\n</tr>\n<tr>\n<td>Document Root</td>\n<td>String</td>\n<td>&quot;./public&quot;</td>\n<td>Directory exists and readable</td>\n</tr>\n<tr>\n<td>Max Threads</td>\n<td>Integer</td>\n<td>10</td>\n<td>Range 1-1000</td>\n</tr>\n<tr>\n<td>Max Connections</td>\n<td>Integer</td>\n<td>100</td>\n<td>Range 1-10000</td>\n</tr>\n<tr>\n<td>Request Timeout</td>\n<td>Integer</td>\n<td>30 seconds</td>\n<td>Range 1-300 seconds</td>\n</tr>\n</tbody></table>\n<h3 id=\"non-functional-requirements\">Non-Functional Requirements</h3>\n<p>The non-functional requirements establish <strong>performance and reliability characteristics</strong> appropriate for an educational implementation. These requirements balance realistic expectations with learning objectives, ensuring the server exhibits production-like behavior without requiring production-scale optimization.</p>\n<p><strong>Performance Characteristics</strong> define acceptable response times and throughput under typical educational workloads. The server should handle moderate concurrent load gracefully while providing predictable response latency. These targets ensure the implementation feels responsive during testing and demonstration while remaining achievable with straightforward algorithms.</p>\n<table>\n<thead>\n<tr>\n<th>Performance Metric</th>\n<th>Target Value</th>\n<th>Measurement Method</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Response Latency</td>\n<td>&lt; 100ms for small files</td>\n<td>Time between request completion and response start</td>\n<td>Human-perceptible responsiveness</td>\n</tr>\n<tr>\n<td>Concurrent Connections</td>\n<td>50+ simultaneous clients</td>\n<td>Load testing with multiple curl instances</td>\n<td>Demonstrates effective concurrency</td>\n</tr>\n<tr>\n<td>File Size Limit</td>\n<td>100MB maximum</td>\n<td>Server rejects larger files with 413 response</td>\n<td>Prevents memory exhaustion</td>\n</tr>\n<tr>\n<td>Request Rate</td>\n<td>100+ requests/second</td>\n<td>Sustained load testing</td>\n<td>Shows proper connection management</td>\n</tr>\n<tr>\n<td>Memory Usage</td>\n<td>&lt; 50MB under typical load</td>\n<td>Process monitoring during operation</td>\n<td>Ensures resource efficiency</td>\n</tr>\n</tbody></table>\n<p><strong>Reliability Requirements</strong> focus on <strong>graceful degradation</strong> and predictable failure modes rather than absolute fault tolerance. The server should detect error conditions promptly and respond with appropriate HTTP status codes rather than crashing or hanging indefinitely.</p>\n<table>\n<thead>\n<tr>\n<th>Reliability Aspect</th>\n<th>Requirement</th>\n<th>Detection Method</th>\n<th>Recovery Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Malformed Request Handling</td>\n<td>Return 400 Bad Request for parsing failures</td>\n<td>HTTP parser validation</td>\n<td>Send error response and close connection</td>\n</tr>\n<tr>\n<td>File System Errors</td>\n<td>Return 500 Internal Server Error for I/O failures</td>\n<td>File operation return codes</td>\n<td>Log error and return HTTP error response</td>\n</tr>\n<tr>\n<td>Connection Timeout</td>\n<td>Close idle connections after timeout period</td>\n<td>Timer-based monitoring</td>\n<td>Clean up resources and close socket</td>\n</tr>\n<tr>\n<td>Resource Exhaustion</td>\n<td>Reject new connections when limits reached</td>\n<td>Connection counting</td>\n<td>Return 503 Service Unavailable</td>\n</tr>\n<tr>\n<td>Thread Safety</td>\n<td>No data corruption under concurrent access</td>\n<td>Stress testing</td>\n<td>Use appropriate synchronization primitives</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Educational Performance Targets</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to balance realistic performance expectations with educational simplicity</li>\n<li><strong>Options Considered</strong>: Production-scale targets (1000s RPS), minimal targets (10 RPS), moderate targets (100 RPS)</li>\n<li><strong>Decision</strong>: Moderate performance targets requiring proper concurrency but not extreme optimization</li>\n<li><strong>Rationale</strong>: High enough to demonstrate the value of concurrent design, low enough to achieve with straightforward implementation</li>\n<li><strong>Consequences</strong>: Enables meaningful performance testing while keeping code complexity manageable for learning</li>\n</ul>\n</blockquote>\n<p><strong>Portability Requirements</strong> ensure the server builds and runs correctly across common development environments. The implementation should use POSIX-standard networking APIs where possible, with clear documentation of any platform-specific requirements.</p>\n<table>\n<thead>\n<tr>\n<th>Platform Aspect</th>\n<th>Requirement</th>\n<th>Implementation Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Operating System</td>\n<td>Support Linux, macOS, and Windows</td>\n<td>Use standard socket APIs with platform-specific compilation</td>\n</tr>\n<tr>\n<td>Compiler</td>\n<td>Build with GCC, Clang, and MSVC</td>\n<td>Standard C99 code with minimal extensions</td>\n</tr>\n<tr>\n<td>Dependencies</td>\n<td>Minimize external library requirements</td>\n<td>Use system libraries and standard library functions</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>Support command-line arguments and config files</td>\n<td>Standard argument parsing and file I/O</td>\n</tr>\n</tbody></table>\n<p><strong>Security Requirements</strong> implement <strong>fundamental security practices</strong> without attempting comprehensive security coverage. The focus remains on preventing basic attacks that could compromise the host system while maintaining code clarity for educational purposes.</p>\n<table>\n<thead>\n<tr>\n<th>Security Aspect</th>\n<th>Requirement</th>\n<th>Implementation Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Directory Traversal Prevention</td>\n<td>Block <code>../</code> path escape attempts</td>\n<td>Path validation and canonical path resolution</td>\n</tr>\n<tr>\n<td>Buffer Overflow Prevention</td>\n<td>Bounds checking on all string operations</td>\n<td>Fixed-size buffers with length validation</td>\n</tr>\n<tr>\n<td>Resource Exhaustion Protection</td>\n<td>Limit concurrent connections and memory usage</td>\n<td>Connection counting and request size limits</td>\n</tr>\n<tr>\n<td>Input Validation</td>\n<td>Reject malformed HTTP requests</td>\n<td>Strict parsing with early rejection</td>\n</tr>\n</tbody></table>\n<h3 id=\"explicit-non-goals\">Explicit Non-Goals</h3>\n<p>The explicit non-goals prevent <strong>scope creep</strong> by clearly stating advanced HTTP features and optimizations that we deliberately exclude. These exclusions maintain focus on core learning objectives while acknowledging that production HTTP servers require additional capabilities.</p>\n<p><strong>Advanced HTTP Protocol Features</strong> represent significant implementation complexity that would overshadow our core networking and concurrency lessons. While these features are essential for production HTTP servers, they introduce parsing complexity, state management challenges, and protocol intricacies that distract from fundamental concepts.</p>\n<table>\n<thead>\n<tr>\n<th>Excluded Feature</th>\n<th>Complexity Reason</th>\n<th>Learning Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTP/2 and HTTP/3</td>\n<td>Binary framing, multiplexing, stream management</td>\n<td>Obscures basic HTTP message structure</td>\n</tr>\n<tr>\n<td>Chunked Transfer Encoding</td>\n<td>Complex parsing state machine, streaming assembly</td>\n<td>Complicates request/response handling</td>\n</tr>\n<tr>\n<td>Content Compression</td>\n<td>Compression algorithm integration, negotiation</td>\n<td>Adds processing overhead to core flow</td>\n</tr>\n<tr>\n<td>Range Requests</td>\n<td>Partial content parsing, byte range calculations</td>\n<td>Distracts from basic file serving</td>\n</tr>\n<tr>\n<td>WebSocket Protocol</td>\n<td>Protocol upgrade negotiation, framing, persistence</td>\n<td>Different paradigm from request/response</td>\n</tr>\n<tr>\n<td>HTTP Caching</td>\n<td>Cache validation, ETags, conditional requests</td>\n<td>Complex metadata management</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Feature Scope Creep</strong>\nLearners often attempt to add these advanced features during implementation, thinking they&#39;re &quot;simple additions.&quot; However, each feature significantly increases code complexity and introduces new failure modes. For example, chunked transfer encoding requires maintaining parsing state across multiple <code>read()</code> calls, handling chunk size parsing, and assembling fragmented data - this complexity obscures the core lesson about HTTP message structure.</p>\n<p><strong>Dynamic Content Generation</strong> capabilities like server-side scripting, template processing, and database integration represent entirely different problem domains. While valuable for web application development, these features shift focus away from systems programming concepts toward application development.</p>\n<table>\n<thead>\n<tr>\n<th>Excluded Capability</th>\n<th>Rationale</th>\n<th>Alternative Learning Path</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CGI/FastCGI Integration</td>\n<td>Process management and IPC complexity</td>\n<td>Separate process management project</td>\n</tr>\n<tr>\n<td>Server-Side Scripting</td>\n<td>Language runtime integration</td>\n<td>Web application framework study</td>\n</tr>\n<tr>\n<td>Template Engine</td>\n<td>String processing and substitution logic</td>\n<td>Text processing project</td>\n</tr>\n<tr>\n<td>Database Connectivity</td>\n<td>Database protocol and connection pooling</td>\n<td>Database systems course</td>\n</tr>\n<tr>\n<td>Session Management</td>\n<td>State persistence and security</td>\n<td>Web application security study</td>\n</tr>\n</tbody></table>\n<p><strong>Production-Scale Optimizations</strong> involve sophisticated algorithms and data structures that, while important for high-performance servers, add implementation complexity without enhancing understanding of core concepts. These optimizations represent performance engineering rather than foundational systems programming.</p>\n<table>\n<thead>\n<tr>\n<th>Excluded Optimization</th>\n<th>Implementation Complexity</th>\n<th>Core Concept Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Connection Pooling</td>\n<td>Connection lifecycle management, pool algorithms</td>\n<td>Obscures basic connection handling</td>\n</tr>\n<tr>\n<td>Epoll/Kqueue Event Systems</td>\n<td>Platform-specific APIs, event dispatching</td>\n<td>Complicates concurrency model comparison</td>\n</tr>\n<tr>\n<td>Zero-Copy I/O</td>\n<td>Platform-specific sendfile(), memory mapping</td>\n<td>Distracts from basic file I/O understanding</td>\n</tr>\n<tr>\n<td>CPU Affinity Tuning</td>\n<td>Scheduler interaction, NUMA awareness</td>\n<td>Beyond scope of basic networking</td>\n</tr>\n<tr>\n<td>Load Balancing</td>\n<td>Request distribution algorithms, health checking</td>\n<td>Separate distributed systems topic</td>\n</tr>\n<tr>\n<td>Memory Pool Allocation</td>\n<td>Custom memory management, fragmentation handling</td>\n<td>Separate memory management study</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Static Files Only</strong></p>\n<ul>\n<li><strong>Context</strong>: Must choose between static file serving versus dynamic content generation</li>\n<li><strong>Options Considered</strong>: Static only, CGI support, embedded scripting, full application server</li>\n<li><strong>Decision</strong>: Static file serving exclusively</li>\n<li><strong>Rationale</strong>: Dynamic content requires process management, security sandboxing, and application-specific logic that overshadows networking fundamentals</li>\n<li><strong>Consequences</strong>: Enables focus on HTTP protocol, file I/O, and concurrency without application development complexity</li>\n</ul>\n</blockquote>\n<p><strong>Enterprise Integration Features</strong> involve external system interactions and operational concerns that extend beyond the core HTTP server implementation. While critical for production deployments, these features represent separate problem domains with their own complexity.</p>\n<table>\n<thead>\n<tr>\n<th>Integration Feature</th>\n<th>Scope Reason</th>\n<th>Separate Learning Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SSL/TLS Support</td>\n<td>Cryptographic protocol complexity</td>\n<td>Network security course</td>\n</tr>\n<tr>\n<td>Authentication Systems</td>\n<td>Identity management, credential validation</td>\n<td>Security and identity systems</td>\n</tr>\n<tr>\n<td>Logging and Monitoring</td>\n<td>Structured logging, metrics collection, alerting</td>\n<td>Operations and observability</td>\n</tr>\n<tr>\n<td>Configuration Management</td>\n<td>Hot reload, distributed configuration</td>\n<td>Configuration systems design</td>\n</tr>\n<tr>\n<td>Health Check Endpoints</td>\n<td>Service discovery, load balancer integration</td>\n<td>Distributed systems architecture</td>\n</tr>\n<tr>\n<td>Reverse Proxy Features</td>\n<td>Request forwarding, load distribution</td>\n<td>Proxy and gateway systems</td>\n</tr>\n</tbody></table>\n<p><strong>Platform-Specific Optimizations</strong> tie the implementation to particular operating systems or hardware architectures. While these optimizations provide significant performance benefits in production, they reduce code portability and introduce platform-specific complexity that distracts from universal networking concepts.</p>\n<table>\n<thead>\n<tr>\n<th>Platform Feature</th>\n<th>Exclusion Reason</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Linux-specific epoll</td>\n<td>Reduces portability, complicates event loop</td>\n</tr>\n<tr>\n<td>Windows IOCP</td>\n<td>Platform-specific async I/O model</td>\n</tr>\n<tr>\n<td>macOS kqueue</td>\n<td>BSD-specific event notification</td>\n</tr>\n<tr>\n<td>Linux sendfile()</td>\n<td>Platform-specific zero-copy optimization</td>\n</tr>\n<tr>\n<td>Memory-mapped files</td>\n<td>Complex memory management, platform differences</td>\n</tr>\n<tr>\n<td>CPU-specific SIMD</td>\n<td>Processor-specific optimization</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight</strong>: These explicit non-goals aren&#39;t permanent limitations - they represent <strong>learning prioritization</strong>. Each excluded feature could become the focus of a separate advanced project once learners master the foundational concepts. The goal is depth-first learning rather than breadth-first feature coverage.</p>\n</blockquote>\n<p>By maintaining strict boundaries around our implementation scope, we ensure that each line of code written serves the core educational objectives: understanding network programming, HTTP protocol handling, file system interaction, and concurrent request processing. Every feature addition must pass the test: &quot;Does this enhance understanding of fundamental systems programming concepts, or does it distract from them?&quot;</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The implementation approach balances <strong>educational clarity</strong> with production-quality practices, ensuring learners develop good habits while maintaining focus on core concepts.</p>\n<p><strong>A. Technology Recommendations Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Socket Programming</td>\n<td>POSIX sockets with blocking I/O</td>\n<td>Non-blocking sockets with select/poll</td>\n</tr>\n<tr>\n<td>Threading Model</td>\n<td>pthread_create per connection</td>\n<td>Thread pool with work queue</td>\n</tr>\n<tr>\n<td>HTTP Parsing</td>\n<td>String manipulation with strtok</td>\n<td>State machine parser</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>Command-line arguments only</td>\n<td>Config file + command-line override</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>printf to stdout/stderr</td>\n<td>Structured logging with levels</td>\n</tr>\n<tr>\n<td>Build System</td>\n<td>Simple Makefile</td>\n<td>Autotools or CMake</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>http-server/\n├── src/\n│   ├── main.c                 ← Entry point and configuration\n│   ├── tcp_server.c           ← TCP socket management (Milestone 1)\n│   ├── tcp_server.h\n│   ├── http_parser.c          ← HTTP request/response parsing (Milestone 2)\n│   ├── http_parser.h\n│   ├── file_handler.c         ← Static file serving (Milestone 3)\n│   ├── file_handler.h\n│   ├── concurrency.c          ← Connection management (Milestone 4)\n│   ├── concurrency.h\n│   └── common.h               ← Shared constants and utilities\n├── public/                    ← Default document root\n│   ├── index.html\n│   └── test.txt\n├── tests/                     ← Test scripts and data\n├── Makefile\n└── README.md</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code:</strong></p>\n<p>Complete configuration management system ready for use:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// common.h - Shared definitions and configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/socket.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;netinet/in.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;pthread.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_REQUEST_SIZE</span><span style=\"color:#79B8FF\"> 8192</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_PATH_LENGTH</span><span style=\"color:#79B8FF\"> 1024</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_RESPONSE_SIZE</span><span style=\"color:#79B8FF\"> 16384</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEFAULT_PORT</span><span style=\"color:#79B8FF\"> 8080</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEFAULT_DOC_ROOT</span><span style=\"color:#9ECBFF\"> \"./public\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEFAULT_MAX_THREADS</span><span style=\"color:#79B8FF\"> 10</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> port;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> document_root</span><span style=\"color:#E1E4E8\">[MAX_PATH_LENGTH];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> max_threads;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> max_connections;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> request_timeout_sec;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ServerConfig;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> method</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">[MAX_PATH_LENGTH];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> version</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> headers</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">][</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">][</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">  // [header_count][key/value][string]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> header_count;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">body;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> body_length;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} HTTPRequest;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> status_code;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> status_text</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> headers</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">][</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">][</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">  // [header_count][key/value][string]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> header_count;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">body;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> body_length;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} HTTPResponse;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> client_fd;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> sockaddr_in client_addr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    time_t</span><span style=\"color:#E1E4E8\"> connect_time;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_t</span><span style=\"color:#E1E4E8\"> thread_id;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ConnectionContext;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Configuration parsing utility - complete implementation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> parse_config</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#F97583\">[]</span><span style=\"color:#E1E4E8\">, ServerConfig </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set defaults</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config->port </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> DEFAULT_PORT;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    strncpy</span><span style=\"color:#E1E4E8\">(config->document_root, DEFAULT_DOC_ROOT, MAX_PATH_LENGTH </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config->max_threads </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> DEFAULT_MAX_THREADS;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config->max_connections </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config->request_timeout_sec </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 30</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> argc; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strcmp</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[i], </span><span style=\"color:#9ECBFF\">\"--port\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> &#x3C;</span><span style=\"color:#E1E4E8\"> argc) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            config->port </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> atoi</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">i]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (config->port </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> config->port </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 65535</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Invalid port: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, config->port);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strcmp</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[i], </span><span style=\"color:#9ECBFF\">\"--root\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> &#x3C;</span><span style=\"color:#E1E4E8\"> argc) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            strncpy</span><span style=\"color:#E1E4E8\">(config->document_root, </span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">i], MAX_PATH_LENGTH </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strcmp</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[i], </span><span style=\"color:#9ECBFF\">\"--threads\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> &#x3C;</span><span style=\"color:#E1E4E8\"> argc) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            config->max_threads </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> atoi</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// tcp_server.c - Core socket operations for learner implementation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"tcp_server.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Creates and configures a server socket bound to the specified port.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Sets SO_REUSEADDR to allow rapid server restarts.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns: socket file descriptor on success, -1 on failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> create_server_socket</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> port</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create socket using AF_INET and SOCK_STREAM</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set SO_REUSEADDR socket option to allow address reuse</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Configure sockaddr_in structure with INADDR_ANY and port</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Use htons() to convert port to network byte order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Bind socket to address using bind() system call</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Start listening with backlog of 10 connections using listen()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return socket file descriptor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Check each system call return value and use perror() for errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Reads a complete HTTP request from client socket, handling partial reads.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Continues reading until complete request is received or error occurs.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns: number of bytes read on success, -1 on error, 0 on connection close</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#B392F0\"> read_complete_request</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> sockfd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buffer</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> max_size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize total bytes read counter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Loop until complete request received or error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Use recv() to read available data into buffer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Handle partial reads by updating buffer position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Check for HTTP request end marker (\\r\\n\\r\\n)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Handle connection close (recv returns 0)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Handle errors (recv returns -1) with appropriate errno checking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Prevent buffer overflow by checking max_size limit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use strstr() to find HTTP header end sequence</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Main server loop accepting and dispatching client connections.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Runs until interrupted or fatal error occurs.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> server_main_loop</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> server_fd</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize connection tracking structures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set up signal handlers for graceful shutdown</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Main accept() loop - wait for client connections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: For each accepted connection, create ConnectionContext</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Dispatch connection to appropriate handler (thread/process/event)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Handle accept() errors and temporary failures (EAGAIN, EMFILE)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Implement graceful shutdown - complete active requests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Clean up all resources before exit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use accept() in a loop, check errno on failures</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints:</strong></p>\n<ul>\n<li><strong>Socket Creation</strong>: Use <code>socket(AF_INET, SOCK_STREAM, 0)</code> for TCP sockets</li>\n<li><strong>Address Reuse</strong>: <code>setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt))</code> prevents &quot;Address already in use&quot; errors</li>\n<li><strong>Network Byte Order</strong>: Always use <code>htons()</code> for port numbers and <code>htonl()</code> for IP addresses</li>\n<li><strong>Partial Reads</strong>: Network <code>recv()</code> calls may return fewer bytes than requested - always check return value and loop if needed</li>\n<li><strong>Error Handling</strong>: Check system call return values; use <code>perror()</code> or <code>strerror(errno)</code> for descriptive error messages</li>\n<li><strong>Signal Safety</strong>: Use <code>sigaction()</code> instead of <code>signal()</code> for reliable signal handling</li>\n<li><strong>Thread Safety</strong>: Protect shared data structures with <code>pthread_mutex_t</code>; use <code>pthread_create()</code> for thread-per-connection model</li>\n</ul>\n<p><strong>F. Milestone Checkpoint:</strong></p>\n<p>After implementing the goals and scope definition:</p>\n<ol>\n<li><strong>Document Review</strong>: Ensure all team members understand the scope boundaries</li>\n<li><strong>Setup Verification</strong>: Confirm development environment can compile and run basic C socket programs</li>\n<li><strong>Architecture Validation</strong>: Verify the planned file structure makes sense for your team&#39;s workflow</li>\n<li><strong>Scope Verification</strong>: List any features you&#39;re tempted to add and confirm they belong in the non-goals section</li>\n</ol>\n<p>Expected behavior after scope definition:</p>\n<ul>\n<li>Clear understanding of what success looks like for each milestone</li>\n<li>Agreement on which features to implement vs. defer to future projects</li>\n<li>Development environment setup and ready for Milestone 1 implementation</li>\n<li>Architectural decisions documented for future reference</li>\n</ul>\n<p><strong>G. Common Scope Management Pitfalls:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Implementation taking much longer than expected</td>\n<td>Feature creep beyond defined scope</td>\n<td>Review code against functional requirements</td>\n<td>Remove features not in requirements</td>\n</tr>\n<tr>\n<td>Code becoming extremely complex</td>\n<td>Attempting production optimizations</td>\n<td>Check against explicit non-goals</td>\n<td>Simplify to meet educational objectives</td>\n</tr>\n<tr>\n<td>Difficulty testing basic functionality</td>\n<td>Too many features implemented simultaneously</td>\n<td>Verify milestone progression</td>\n<td>Focus on one milestone at a time</td>\n</tr>\n<tr>\n<td>Team disagreement on implementation approach</td>\n<td>Unclear architectural decisions</td>\n<td>Review decision records</td>\n<td>Document additional ADRs as needed</td>\n</tr>\n</tbody></table>\n<p>The key to successful scope management is <strong>disciplined focus</strong> on the learning objectives. When in doubt, choose the simpler approach that most clearly demonstrates the core concept being taught.</p>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundation for Milestones 1-4 - provides the structural blueprint that guides implementation across TCP server basics, HTTP parsing, file serving, and concurrency management</p>\n</blockquote>\n<p>The high-level architecture section serves as our blueprint for understanding how the HTTP server&#39;s components work together to transform raw TCP connections into meaningful HTTP responses. Think of this architecture as a <strong>restaurant&#39;s service flow</strong> - just as a restaurant has distinct stations (host desk, kitchen, servers, manager) that coordinate to serve customers, our HTTP server has specialized components that each handle a specific aspect of client requests while maintaining clear boundaries and communication patterns.</p>\n<h3 id=\"component-overview\">Component Overview</h3>\n<p>The HTTP server architecture centers around four primary components, each with distinct responsibilities and clear interfaces. This separation follows the <strong>single responsibility principle</strong> - each component has one primary job and does it well, making the system easier to understand, test, and maintain.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fsystem-overview.svg\" alt=\"HTTP Server System Overview\"></p>\n<p>The <strong>TCP Server Component</strong> acts as the front door of our system, similar to a hotel&#39;s reception desk. It handles all the low-level networking concerns: creating sockets, binding to network addresses, listening for incoming connections, and accepting client requests. This component shields the rest of the system from the complexities of socket programming and network protocol details. Its primary responsibility is managing the <strong>connection lifecycle</strong> - from initial socket creation through connection acceptance to resource cleanup.</p>\n<p>The <strong>HTTP Parser Component</strong> serves as the system&#39;s translator, converting raw byte streams from TCP connections into structured HTTP message objects. Think of it as a postal worker who takes incoming mail and sorts it into organized bins - the parser takes the raw request bytes and extracts the HTTP method, URL path, headers, and body content into well-defined data structures. This component handles all the intricacies of HTTP protocol parsing, including line ending variations, header formatting, and body content processing.</p>\n<p>The <strong>File Handler Component</strong> functions as the system&#39;s librarian, responsible for mapping HTTP URL paths to actual files on the filesystem and serving their contents safely. Like a librarian who helps patrons find books while ensuring they don&#39;t access restricted sections, this component performs path resolution, security validation, MIME type detection, and file content delivery. It serves as the critical security boundary that prevents directory traversal attacks and ensures clients can only access files within the designated document root.</p>\n<p>The <strong>Concurrency Management Component</strong> orchestrates how the server handles multiple simultaneous client connections. Think of it as a restaurant manager who decides whether to assign one waiter per table, maintain a pool of waiters who serve multiple tables, or have a single super-efficient waiter handle all tables. This component implements different concurrency models (thread-per-connection, thread pool, or event-driven) and manages system resources to prevent overload while maintaining responsiveness.</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Primary Responsibility</th>\n<th>Key Abstractions</th>\n<th>Dependencies</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>TCP Server</td>\n<td>Network connection lifecycle</td>\n<td>Socket management, connection acceptance</td>\n<td>Operating system sockets</td>\n</tr>\n<tr>\n<td>HTTP Parser</td>\n<td>Protocol message translation</td>\n<td>Request/response structures, state machine</td>\n<td>TCP byte streams</td>\n</tr>\n<tr>\n<td>File Handler</td>\n<td>Static content delivery</td>\n<td>Path resolution, MIME detection</td>\n<td>Filesystem, security validation</td>\n</tr>\n<tr>\n<td>Concurrency Manager</td>\n<td>Multi-client coordination</td>\n<td>Thread/event management, resource limits</td>\n<td>Threading primitives, I/O multiplexing</td>\n</tr>\n</tbody></table>\n<p>Each component maintains clear boundaries through well-defined interfaces. The TCP Server produces raw client connections and byte streams. The HTTP Parser consumes these streams and produces structured <code>HTTPRequest</code> objects. The File Handler consumes requests and produces <code>HTTPResponse</code> objects with file content. The Concurrency Manager orchestrates these interactions across multiple simultaneous clients.</p>\n<blockquote>\n<p><strong>Key Design Insight</strong>: The component separation allows us to test each piece independently and swap implementations without affecting other parts. For example, we can start with a simple thread-per-connection model in the Concurrency Manager and later upgrade to an event-driven model without touching the parsing or file serving logic.</p>\n</blockquote>\n<h3 id=\"recommended-file-structure\">Recommended File Structure</h3>\n<p>Organizing code into a logical file structure is crucial for maintainability and understanding. The recommended structure follows C programming best practices, separating interface definitions from implementations and grouping related functionality together.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>http-server/\n├── src/\n│   ├── main.c                 ← Entry point, argument parsing, server startup\n│   ├── server.h               ← Main server interface and configuration\n│   ├── server.c               ← Server initialization and main loop coordination\n│   ├── tcp/\n│   │   ├── tcp_server.h       ← TCP server component interface\n│   │   ├── tcp_server.c       ← Socket creation, binding, acceptance logic\n│   │   └── connection.h       ← Connection context and lifecycle definitions\n│   ├── http/\n│   │   ├── http_parser.h      ← HTTP parsing interface and data structures\n│   │   ├── http_parser.c      ← Request/response parsing implementation\n│   │   ├── http_request.h     ← HTTPRequest structure and utilities\n│   │   ├── http_response.h    ← HTTPResponse structure and utilities\n│   │   └── http_status.c      ← HTTP status code definitions and utilities\n│   ├── file/\n│   │   ├── file_handler.h     ← File serving interface and security functions\n│   │   ├── file_handler.c     ← Path resolution and file serving logic\n│   │   ├── mime_types.h       ← MIME type detection interface\n│   │   └── mime_types.c       ← File extension to MIME type mapping\n│   ├── concurrency/\n│   │   ├── connection_manager.h  ← Concurrency management interface\n│   │   ├── thread_pool.c      ← Thread pool implementation\n│   │   ├── event_loop.c       ← Event-driven I/O implementation\n│   │   └── worker_thread.c    ← Individual connection handler logic\n│   └── util/\n│       ├── logger.h           ← Logging interface and macros\n│       ├── logger.c           ← Logging implementation\n│       ├── buffer.h           ← Dynamic buffer management\n│       └── buffer.c           ← Buffer allocation and manipulation\n├── config/\n│   ├── server.conf            ← Default server configuration\n│   └── mime.types             ← MIME type mappings\n├── www/                       ← Default document root directory\n│   ├── index.html            ← Default homepage\n│   ├── 404.html              ← Custom 404 error page\n│   └── static/               ← Static assets (CSS, JS, images)\n├── tests/\n│   ├── unit/                 ← Unit tests for individual components\n│   ├── integration/          ← Integration tests for component interaction\n│   └── performance/          ← Load testing and benchmarking\n├── docs/\n│   ├── README.md             ← Project documentation\n│   └── API.md                ← Component interface documentation\n└── Makefile                  ← Build configuration and targets</code></pre></div>\n\n<p>This structure provides several important benefits for the learning process. The <strong>component isolation</strong> allows students to focus on one aspect of the server at a time - they can work on TCP networking without worrying about HTTP parsing, or implement file serving without getting bogged down in concurrency details. The <strong>header/implementation separation</strong> follows C best practices and makes it easy to understand interfaces before diving into implementation details.</p>\n<p>The <strong>progressive complexity</strong> arrangement lets students implement components in dependency order. They start with basic TCP server functionality, then add HTTP parsing, followed by file serving, and finally concurrency management. Each milestone builds naturally on the previous ones without requiring major refactoring.</p>\n<blockquote>\n<p><strong>Learning Insight</strong>: The file structure mirrors the component architecture - each major directory corresponds to one of our four main components. This makes it easy to find code related to specific functionality and reinforces the architectural boundaries in the actual codebase.</p>\n</blockquote>\n<h3 id=\"request-processing-flow\">Request Processing Flow</h3>\n<p>The request processing flow describes how our four components collaborate to handle a complete HTTP request-response cycle. Understanding this flow is essential because it shows how the individual components we&#39;ll implement in later milestones work together to create a functioning web server.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Frequest-processing-flow.svg\" alt=\"Request Processing Sequence\"></p>\n<p>The flow begins when a client establishes a TCP connection to our server. The <strong>TCP Server Component</strong> receives this connection through the standard socket lifecycle: <code>socket()</code> creates the server socket, <code>bind()</code> attaches it to a specific port, <code>listen()</code> marks it as accepting connections, and <code>accept()</code> blocks until a client connects. Once a connection arrives, <code>accept()</code> returns a new client file descriptor representing the dedicated communication channel with that specific client.</p>\n<p>At this point, the <strong>Concurrency Management Component</strong> takes control of the newly accepted connection. Depending on the configured concurrency model, it either spawns a new thread to handle this client, assigns the connection to a worker thread from a pre-allocated pool, or adds the client socket to an event loop for non-blocking processing. This decision affects performance characteristics but doesn&#39;t change the fundamental processing steps that follow.</p>\n<p>The connection handler begins by reading the HTTP request data from the client socket. This involves calling <code>read()</code> or <code>recv()</code> repeatedly until a complete HTTP request is received. The challenge here is handling <strong>partial reads</strong> - network operations may return fewer bytes than requested, so the server must buffer incoming data and continue reading until it receives the complete request headers (indicated by a blank line) and any request body.</p>\n<p>Once complete request data is available, the <strong>HTTP Parser Component</strong> takes over. It processes the raw bytes according to HTTP/1.1 protocol rules, extracting the request line (method, path, HTTP version), parsing headers into key-value pairs, and handling any request body content. The parser validates the request format and populates an <code>HTTPRequest</code> structure with the parsed information. If parsing fails due to malformed input, the parser generates an appropriate HTTP error response (400 Bad Request) without proceeding to file serving.</p>\n<p>With a valid <code>HTTPRequest</code> in hand, the <strong>File Handler Component</strong> begins the process of mapping the requested URL path to actual file content. This involves several security-critical steps: validating the request path to prevent directory traversal attacks, resolving the path relative to the configured document root, checking file permissions and existence, and determining the appropriate MIME type based on the file extension.</p>\n<p>If the requested file exists and is accessible, the File Handler reads its contents and constructs an <code>HTTPResponse</code> object with appropriate headers (Content-Type, Content-Length, Last-Modified) and the file data as the response body. If the file doesn&#39;t exist, it generates a 404 Not Found response. If security validation fails (such as detecting a directory traversal attempt), it returns a 403 Forbidden response.</p>\n<p>The final step involves the connection handler sending the complete HTTP response back to the client. This requires formatting the <code>HTTPResponse</code> object into valid HTTP protocol format (status line, headers, blank line, body) and writing all the data to the client socket using <code>write()</code> or <code>send()</code> operations. Like reading, writing may require multiple system calls to send all response data, especially for large files.</p>\n<p>After successful response delivery, the connection handler performs cleanup operations: closing the client file descriptor to free the network connection, releasing any allocated memory for request/response processing, and updating connection statistics or logs. The handler then either terminates (in thread-per-connection model) or returns to process the next connection (in thread pool or event-driven models).</p>\n<table>\n<thead>\n<tr>\n<th>Processing Stage</th>\n<th>Component Responsible</th>\n<th>Key Operations</th>\n<th>Potential Failures</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Connection Accept</td>\n<td>TCP Server</td>\n<td><code>socket()</code>, <code>bind()</code>, <code>listen()</code>, <code>accept()</code></td>\n<td>Port already bound, network errors</td>\n</tr>\n<tr>\n<td>Concurrency Dispatch</td>\n<td>Concurrency Manager</td>\n<td>Thread creation or event registration</td>\n<td>Resource exhaustion, thread limits</td>\n</tr>\n<tr>\n<td>Request Reading</td>\n<td>Connection Handler</td>\n<td><code>read()</code> with partial read handling</td>\n<td>Client disconnect, timeout, oversized request</td>\n</tr>\n<tr>\n<td>HTTP Parsing</td>\n<td>HTTP Parser</td>\n<td>Protocol parsing, structure population</td>\n<td>Malformed request, unsupported method</td>\n</tr>\n<tr>\n<td>Path Resolution</td>\n<td>File Handler</td>\n<td>Security validation, file system access</td>\n<td>Directory traversal, permission denied</td>\n</tr>\n<tr>\n<td>Response Generation</td>\n<td>File Handler</td>\n<td>File reading, MIME detection, header creation</td>\n<td>File not found, I/O errors</td>\n</tr>\n<tr>\n<td>Response Transmission</td>\n<td>Connection Handler</td>\n<td><code>write()</code> with complete data delivery</td>\n<td>Client disconnect, network congestion</td>\n</tr>\n<tr>\n<td>Cleanup</td>\n<td>Connection Handler</td>\n<td>Resource deallocation, connection closure</td>\n<td>File descriptor leaks</td>\n</tr>\n</tbody></table>\n<p>The beauty of this architecture is its <strong>modularity</strong> - each component has a clear input and output interface, making it possible to test and debug each stage independently. When problems occur, the structured flow helps isolate issues to specific components and processing stages.</p>\n<blockquote>\n<p><strong>Error Propagation Design</strong>: Errors detected in any component flow back through the system as HTTP error responses rather than crashing the server. This ensures that problems with individual requests don&#39;t affect other concurrent connections or server stability.</p>\n</blockquote>\n<p>The request processing flow also demonstrates why our component separation is effective. The TCP Server handles networking complexity, the HTTP Parser manages protocol details, the File Handler deals with security and content delivery, and the Concurrency Manager coordinates multiple simultaneous flows of this same process. Each component can be implemented, tested, and optimized independently while contributing to the overall request-response capability.</p>\n<p>This flow repeats continuously as the server processes client requests. The main server loop accepts new connections and dispatches them for processing, while existing connections move through their individual request-response cycles. The architecture supports both simple sequential processing (for learning) and sophisticated concurrent processing (for performance) using the same fundamental flow pattern.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The implementation guidance bridges the gap between architectural understanding and actual C code. The following recommendations and starter code help structure the development process across all four milestones.</p>\n<h4 id=\"technology-and-library-recommendations\">Technology and Library Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Approach</th>\n<th>Production Approach</th>\n<th>Recommended for Learning</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>TCP Networking</td>\n<td>POSIX sockets (<code>socket.h</code>, <code>netinet/in.h</code>)</td>\n<td>POSIX sockets with epoll/kqueue</td>\n<td>POSIX sockets</td>\n</tr>\n<tr>\n<td>HTTP Parsing</td>\n<td>Manual string parsing with <code>strtok()</code></td>\n<td>Purpose-built state machine parser</td>\n<td>State machine parser</td>\n</tr>\n<tr>\n<td>File I/O</td>\n<td>Standard C file operations (<code>fopen()</code>, <code>fread()</code>)</td>\n<td>Memory-mapped files (<code>mmap()</code>)</td>\n<td>Standard C file operations</td>\n</tr>\n<tr>\n<td>Concurrency</td>\n<td><code>pthread</code> library</td>\n<td>Event-driven with <code>epoll</code>/<code>select</code></td>\n<td>Start with <code>pthread</code></td>\n</tr>\n<tr>\n<td>Logging</td>\n<td><code>printf()</code> to stdout/stderr</td>\n<td>Structured logging with levels</td>\n<td><code>printf()</code> with log levels</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>Command-line arguments</td>\n<td>Configuration file parsing</td>\n<td>Command-line arguments</td>\n</tr>\n</tbody></table>\n<h4 id=\"project-structure-and-build-system\">Project Structure and Build System</h4>\n<p>The Makefile should support incremental development, allowing students to build and test individual components:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">makefile</span><pre class=\"arch-pre shiki-highlighted\"><code># Makefile - Progressive build targets for milestone development\nCC = gcc\nCFLAGS = -Wall -Wextra -std=c99 -pthread -g\nSRCDIR = src\nOBJDIR = obj\n\n# Milestone 1: TCP Server basics\ntcp_server: $(OBJDIR)/main.o $(OBJDIR)/tcp_server.o $(OBJDIR)/logger.o\n\t$(CC) $(CFLAGS) -o $@ $^\n\n# Milestone 2: Add HTTP parsing\nhttp_parser: $(OBJDIR)/main.o $(OBJDIR)/tcp_server.o $(OBJDIR)/http_parser.o $(OBJDIR)/logger.o\n\t$(CC) $(CFLAGS) -o $@ $^\n\n# Milestone 3: Add file serving\nfile_server: $(OBJDIR)/main.o $(OBJDIR)/tcp_server.o $(OBJDIR)/http_parser.o $(OBJDIR)/file_handler.o $(OBJDIR)/mime_types.o $(OBJDIR)/logger.o\n\t$(CC) $(CFLAGS) -o $@ $^\n\n# Milestone 4: Complete server with concurrency\nhttp_server: $(OBJDIR)/main.o $(OBJDIR)/server.o $(OBJDIR)/tcp_server.o $(OBJDIR)/http_parser.o $(OBJDIR)/file_handler.o $(OBJDIR)/connection_manager.o $(OBJDIR)/logger.o\n\t$(CC) $(CFLAGS) -o $@ $^</code></pre></div>\n\n<h4 id=\"core-infrastructure-starter-code\">Core Infrastructure Starter Code</h4>\n<p>Students should focus their learning effort on the four main components rather than boilerplate code. The following infrastructure provides a solid foundation:</p>\n<p><strong>Logger Implementation</strong> (Complete - Ready to Use):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// src/util/logger.h - Logging infrastructure for debugging and monitoring</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> LOGGER_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> LOGGER_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;time.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LOG_DEBUG </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LOG_INFO </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LOG_WARN </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LOG_ERROR </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">log_level_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> LOG_DEBUG_MSG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fmt</span><span style=\"color:#E1E4E8\">, ...) </span><span style=\"color:#B392F0\">log_message</span><span style=\"color:#E1E4E8\">(LOG_DEBUG, </span><span style=\"color:#B392F0\">__FILE__</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">__LINE__</span><span style=\"color:#E1E4E8\">, fmt, ##</span><span style=\"color:#B392F0\">__VA_ARGS__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> LOG_INFO_MSG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fmt</span><span style=\"color:#E1E4E8\">, ...) </span><span style=\"color:#B392F0\">log_message</span><span style=\"color:#E1E4E8\">(LOG_INFO, </span><span style=\"color:#B392F0\">__FILE__</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">__LINE__</span><span style=\"color:#E1E4E8\">, fmt, ##</span><span style=\"color:#B392F0\">__VA_ARGS__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> LOG_WARN_MSG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fmt</span><span style=\"color:#E1E4E8\">, ...) </span><span style=\"color:#B392F0\">log_message</span><span style=\"color:#E1E4E8\">(LOG_WARN, </span><span style=\"color:#B392F0\">__FILE__</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">__LINE__</span><span style=\"color:#E1E4E8\">, fmt, ##</span><span style=\"color:#B392F0\">__VA_ARGS__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> LOG_ERROR_MSG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fmt</span><span style=\"color:#E1E4E8\">, ...) </span><span style=\"color:#B392F0\">log_message</span><span style=\"color:#E1E4E8\">(LOG_ERROR, </span><span style=\"color:#B392F0\">__FILE__</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">__LINE__</span><span style=\"color:#E1E4E8\">, fmt, ##</span><span style=\"color:#B392F0\">__VA_ARGS__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> log_message</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">log_level_t</span><span style=\"color:#FFAB70\"> level</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> file</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> fmt</span><span style=\"color:#E1E4E8\">, ...);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> set_log_level</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">log_level_t</span><span style=\"color:#FFAB70\"> level</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// src/util/logger.c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"logger.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdarg.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> log_level_t</span><span style=\"color:#E1E4E8\"> current_level </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> LOG_INFO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> level_names</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">\"DEBUG\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"INFO\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"WARN\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"ERROR\"</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> set_log_level</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">log_level_t</span><span style=\"color:#FFAB70\"> level</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current_level </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> level;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> log_message</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">log_level_t</span><span style=\"color:#FFAB70\"> level</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> file</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> fmt</span><span style=\"color:#E1E4E8\">, ...) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (level </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> current_level) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    time_t</span><span style=\"color:#E1E4E8\"> now </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> tm</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> tm_info </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> localtime</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">now);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> time_buffer</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">26</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    strftime</span><span style=\"color:#E1E4E8\">(time_buffer, </span><span style=\"color:#79B8FF\">26</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">Y-</span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">m-</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#FDAEB7;font-style:italic\"> %</span><span style=\"color:#9ECBFF\">H:</span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">M:</span><span style=\"color:#79B8FF\">%S</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, tm_info);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> filename </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strrchr</span><span style=\"color:#E1E4E8\">(file, </span><span style=\"color:#9ECBFF\">'/'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    filename </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> filename </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> filename </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> :</span><span style=\"color:#E1E4E8\"> file;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">] </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#79B8FF\"> %s</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> - \"</span><span style=\"color:#E1E4E8\">, time_buffer, </span><span style=\"color:#FFAB70\">level_names</span><span style=\"color:#E1E4E8\">[level], filename, line);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    va_list args;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    va_start</span><span style=\"color:#E1E4E8\">(args, fmt);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vfprintf</span><span style=\"color:#E1E4E8\">(stderr, fmt, args);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    va_end</span><span style=\"color:#E1E4E8\">(args);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fflush</span><span style=\"color:#E1E4E8\">(stderr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Configuration Management</strong> (Complete - Ready to Use):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// src/server.h - Server configuration and initialization</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> SERVER_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> SERVER_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;time.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;pthread.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;netinet/in.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_PATH_LENGTH</span><span style=\"color:#79B8FF\"> 1024</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEFAULT_PORT</span><span style=\"color:#79B8FF\"> 8080</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_REQUEST_SIZE</span><span style=\"color:#79B8FF\"> 8192</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEFAULT_MAX_THREADS</span><span style=\"color:#79B8FF\"> 50</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEFAULT_MAX_CONNECTIONS</span><span style=\"color:#79B8FF\"> 100</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEFAULT_TIMEOUT_SEC</span><span style=\"color:#79B8FF\"> 30</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> port;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> document_root</span><span style=\"color:#E1E4E8\">[MAX_PATH_LENGTH];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> max_threads;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> max_connections;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> request_timeout_sec;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ServerConfig;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> client_fd;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> sockaddr_in client_addr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    time_t</span><span style=\"color:#E1E4E8\"> connect_time;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_t</span><span style=\"color:#E1E4E8\"> thread_id;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ConnectionContext;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Configuration initialization and validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ServerConfig</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> create_default_config</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> parse_command_line_args</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char*</span><span style=\"color:#FFAB70\"> argv</span><span style=\"color:#F97583\">[]</span><span style=\"color:#E1E4E8\">, ServerConfig</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> validate_config</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> ServerConfig</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> print_config</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> ServerConfig</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span></code></pre></div>\n\n<h4 id=\"core-component-skeleton-code\">Core Component Skeleton Code</h4>\n<p>For the main learning components, provide function signatures with detailed TODO comments that map to the architectural design:</p>\n<p><strong>TCP Server Component Skeleton</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// src/tcp/tcp_server.c - TCP server implementation skeleton</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"tcp_server.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"../util/logger.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/socket.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;netinet/in.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> create_server_socket</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> port</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create TCP socket using socket(AF_INET, SOCK_STREAM, 0)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set SO_REUSEADDR option to allow port reuse after restart</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Configure sockaddr_in structure with AF_INET, port, INADDR_ANY</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Bind socket to the configured address using bind()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Start listening with listen() and appropriate backlog</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return server socket file descriptor, or -1 on error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use htons() to convert port to network byte order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Log each step for debugging - socket creation, binding, listening</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Placeholder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> server_main_loop</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> server_fd</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize infinite loop for connection acceptance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Call accept() to wait for incoming client connections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Log client connection details (IP address, port)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create ConnectionContext structure for this client</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Dispatch connection to concurrency manager for processing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Handle accept() errors (EINTR, EMFILE, ENFILE)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Continue loop after handling connection or error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: accept() blocks until client connects - this is expected</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Store client address info for logging and security</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>HTTP Parser Component Skeleton</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// src/http/http_parser.c - HTTP parsing implementation skeleton</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"http_parser.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"../util/logger.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#B392F0\"> read_complete_request</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> sockfd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char*</span><span style=\"color:#FFAB70\"> buffer</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> max_size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize buffer position and bytes remaining counter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Loop reading from socket until complete request received</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Handle partial reads - recv() may return fewer bytes than requested</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Look for \"\\r\\n\\r\\n\" sequence indicating end of headers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If Content-Length header present, continue reading body</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return total bytes read, or -1 on error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use recv() with MSG_DONTWAIT for non-blocking reads</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Grow buffer if request approaches max_size limit</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Placeholder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> parse_http_request</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> raw_request</span><span style=\"color:#E1E4E8\">, HTTPRequest</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize HTTPRequest structure to zero/empty values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Extract method, path, version from first line using strtok()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate method is supported (GET initially)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Parse headers line by line, splitting on \": \" delimiter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Store headers in request->headers array with count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Handle special headers like Content-Length, Host</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return 0 on success, HTTP error code on failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use strncpy() to prevent buffer overflows</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Trim whitespace from header values</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Placeholder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"development-and-testing-checkpoints\">Development and Testing Checkpoints</h4>\n<p>After implementing each milestone, students should verify functionality with these specific tests:</p>\n<p><strong>Milestone 1 Checkpoint</strong>: TCP Server Basics</p>\n<ul>\n<li>Command: <code>./tcp_server 8080</code></li>\n<li>Test: <code>telnet localhost 8080</code> should connect without error</li>\n<li>Expected: Server logs &quot;Client connected from 127.0.0.1:XXXXX&quot;</li>\n<li>Test: Send any text, should receive hardcoded HTTP response</li>\n<li>Signs of problems: &quot;Address already in use&quot; (port not released), connection refused (binding failed), server crashes (missing error handling)</li>\n</ul>\n<p><strong>Milestone 2 Checkpoint</strong>: HTTP Request Parsing</p>\n<ul>\n<li>Command: <code>./http_parser 8080</code></li>\n<li>Test: <code>curl -v http://localhost:8080/test.html</code></li>\n<li>Expected: Server logs parsed method=GET, path=/test.html, version=HTTP/1.1</li>\n<li>Test: <code>curl -H &quot;Custom-Header: test-value&quot; http://localhost:8080/</code></li>\n<li>Expected: Server logs the custom header in parsed headers list</li>\n<li>Signs of problems: Parsing fails on normal requests (line ending issues), crashes on malformed input (missing bounds checking)</li>\n</ul>\n<p><strong>Milestone 3 Checkpoint</strong>: Static File Serving</p>\n<ul>\n<li>Setup: Create <code>www/index.html</code> and <code>www/test.txt</code> in document root</li>\n<li>Test: <code>curl http://localhost:8080/index.html</code> should return file contents</li>\n<li>Expected: Correct Content-Type header based on .html extension</li>\n<li>Test: <code>curl http://localhost:8080/../etc/passwd</code> should return 403 Forbidden</li>\n<li>Expected: Security validation prevents directory traversal</li>\n<li>Signs of problems: Binary files corrupted (text mode reading), 404 for existing files (path resolution issues)</li>\n</ul>\n<p><strong>Milestone 4 Checkpoint</strong>: Concurrent Connections</p>\n<ul>\n<li>Test: <code>for i in {1..10}; do curl http://localhost:8080/index.html &amp; done; wait</code></li>\n<li>Expected: All 10 requests complete successfully with same response</li>\n<li>Test: Use <code>ab -n 100 -c 10 http://localhost:8080/index.html</code> for load testing</li>\n<li>Expected: No connection refused errors, consistent response times</li>\n<li>Signs of problems: Requests hang (thread deadlock), server crashes (race conditions), increasing response times (resource leaks)</li>\n</ul>\n<h4 id=\"common-implementation-pitfalls\">Common Implementation Pitfalls</h4>\n<p>⚠️ <strong>Pitfall: Network Byte Order Confusion</strong>\nStudents often forget to use <code>htons()</code> when setting port numbers in <code>sockaddr_in</code> structures. This causes the server to bind to unexpected ports (e.g., port 8080 becomes port 36895 in big-endian). Always use <code>htons()</code> for ports and <code>htonl()</code> for addresses, even though <code>INADDR_ANY</code> is already in network byte order.</p>\n<p>⚠️ <strong>Pitfall: Partial Read Handling</strong>\nNetwork reads can return fewer bytes than requested, but beginners often assume <code>recv()</code> always returns complete data. This causes parsing failures when HTTP requests are split across multiple TCP packets. Always loop on read operations until you have complete data, checking for both partial reads and error conditions.</p>\n<p>⚠️ <strong>Pitfall: File Descriptor Leaks</strong>\nForgetting to close client sockets leads to file descriptor exhaustion, especially under concurrent load. The server will eventually fail to accept new connections when the per-process file descriptor limit is reached. Ensure every <code>accept()</code> has a corresponding <code>close()</code>, even in error paths.</p>\n<p>⚠️ <strong>Pitfall: Buffer Overflow in Parsing</strong>\nHTTP header values can be arbitrarily long, but fixed-size buffers in <code>HTTPRequest</code> structures can overflow. Always use <code>strncpy()</code> instead of <code>strcpy()</code> and validate input lengths before copying. Consider rejecting requests with headers exceeding reasonable limits.</p>\n<p>⚠️ <strong>Pitfall: Directory Traversal Security</strong>\nStudents often implement simple string concatenation for path resolution (<code>document_root + request_path</code>), which allows attacks like <code>../../../etc/passwd</code>. Use <code>realpath()</code> or manual path validation to ensure resolved paths stay within the document root directory.</p>\n<h2 id=\"data-model\">Data Model</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundation for Milestones 1-4 - defines the core data structures that represent HTTP messages, server configuration, and connection state throughout TCP server basics, HTTP parsing, file serving, and concurrency management</p>\n</blockquote>\n<p>The data model forms the backbone of our HTTP server implementation, defining how we represent HTTP messages, server configuration, and connection state in memory. Think of these data structures as the <strong>vocabulary</strong> our system uses to communicate internally - just as a library has standardized forms for book requests, patron information, and checkout records, our HTTP server needs standardized structures to represent requests, responses, configuration, and active connections.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fdata-model.svg\" alt=\"HTTP Data Structures\"></p>\n<p>The data model serves several critical purposes in our architecture. First, it provides a <strong>common language</strong> between components - when the HTTP parser extracts a request, it produces an <code>HTTPRequest</code> structure that the file handler can immediately understand. Second, it establishes <strong>memory ownership</strong> boundaries, making it clear which component is responsible for allocating and freeing different data. Third, it defines the <strong>security boundaries</strong> where validation must occur, particularly around path handling and request size limits.</p>\n<h3 id=\"http-message-structures\">HTTP Message Structures</h3>\n<p>HTTP messages are the fundamental units of communication in our server. Just as a postal system has standardized envelope formats with sender addresses, recipient addresses, and contents, HTTP has standardized request and response formats that our server must parse and generate correctly.</p>\n<p>The <code>HTTPRequest</code> structure represents an incoming client request after parsing. This structure captures all the essential information from the HTTP request line and headers, providing a clean interface for other components to access request data without needing to understand HTTP parsing details.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>method</code></td>\n<td><code>char[16]</code></td>\n<td>HTTP method (GET, POST, etc.) - fixed size prevents overflow attacks</td>\n</tr>\n<tr>\n<td><code>path</code></td>\n<td><code>char[MAX_PATH_LENGTH]</code></td>\n<td>Requested URL path - bounds checked during parsing</td>\n</tr>\n<tr>\n<td><code>version</code></td>\n<td><code>char[16]</code></td>\n<td>HTTP version string (HTTP/1.1) - used for protocol compliance</td>\n</tr>\n<tr>\n<td><code>headers</code></td>\n<td><code>char[MAX_HEADERS][2][256]</code></td>\n<td>Array of header key-value pairs - [index][0] = key, [index][1] = value</td>\n</tr>\n<tr>\n<td><code>header_count</code></td>\n<td><code>int</code></td>\n<td>Number of headers parsed - prevents access beyond valid headers</td>\n</tr>\n<tr>\n<td><code>body</code></td>\n<td><code>char*</code></td>\n<td>Pointer to request body data - dynamically allocated based on Content-Length</td>\n</tr>\n<tr>\n<td><code>body_length</code></td>\n<td><code>size_t</code></td>\n<td>Size of body in bytes - critical for binary data and memory management</td>\n</tr>\n</tbody></table>\n<p>The fixed-size fields for method, path, and version provide <strong>buffer overflow protection</strong> by enforcing maximum lengths during parsing. The headers array uses a two-dimensional structure where each header occupies one slot with separate key and value strings. This design trades some memory efficiency for simplicity and safety - we can iterate through headers without complex pointer arithmetic.</p>\n<blockquote>\n<p><strong>Critical Design Insight</strong>: The <code>HTTPRequest</code> structure owns all its string data except the body, which is dynamically allocated. This ownership model ensures that once parsing completes, the request structure is self-contained and can be passed between threads safely.</p>\n</blockquote>\n<p>The <code>HTTPResponse</code> structure represents an outgoing server response. This structure mirrors the request format but includes fields specific to response generation, particularly status codes and response bodies that may contain file data.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>status_code</code></td>\n<td><code>int</code></td>\n<td>HTTP status code (200, 404, 500, etc.) - used for response line generation</td>\n</tr>\n<tr>\n<td><code>status_text</code></td>\n<td><code>char[64]</code></td>\n<td>Status reason phrase (OK, Not Found, etc.) - human readable status</td>\n</tr>\n<tr>\n<td><code>headers</code></td>\n<td><code>char[MAX_HEADERS][2][256]</code></td>\n<td>Response headers - same format as request for consistency</td>\n</tr>\n<tr>\n<td><code>header_count</code></td>\n<td><code>int</code></td>\n<td>Number of response headers - prevents iteration beyond valid headers</td>\n</tr>\n<tr>\n<td><code>body</code></td>\n<td><code>char*</code></td>\n<td>Response body content - often points to file data or error page HTML</td>\n</tr>\n<tr>\n<td><code>body_length</code></td>\n<td><code>size_t</code></td>\n<td>Size of response body - essential for Content-Length header</td>\n</tr>\n</tbody></table>\n<p>The response structure separates <code>status_code</code> as an integer from <code>status_text</code> as a string. This design allows components to set status codes using constants (200, 404) while the HTTP formatting code handles the textual representation. The body pointer typically points to either file content loaded from disk or statically allocated error page HTML.</p>\n<blockquote>\n<p><strong>Decision: Fixed-Size vs Dynamic Headers</strong></p>\n<ul>\n<li><strong>Context</strong>: HTTP headers can vary widely in number and size, and we need to balance memory efficiency with implementation simplicity</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Fixed-size array of header structs (chosen)</li>\n<li>Linked list of dynamically allocated headers</li>\n<li>Hash table for O(1) header lookup</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Fixed-size array with maximum header count</li>\n<li><strong>Rationale</strong>: Educational simplicity outweighs memory efficiency. Fixed arrays eliminate complex memory management and pointer chasing. Most HTTP requests have fewer than 20 headers, making the memory overhead acceptable.</li>\n<li><strong>Consequences</strong>: Simple iteration and memory management, but wastes memory for requests with few headers. Header count limits prevent resource exhaustion attacks.</li>\n</ul>\n</blockquote>\n<h3 id=\"server-configuration\">Server Configuration</h3>\n<p>Server configuration defines the runtime behavior and operational parameters of our HTTP server. Think of configuration as the <strong>operating procedures</strong> for our library - it defines which port to listen on (like which desk to staff), where files are stored (like which building houses the collection), and how many concurrent patrons we can serve (like staffing levels).</p>\n<p>The <code>ServerConfig</code> structure centralizes all configurable server parameters, making it easy to adjust behavior without recompiling code. This structure is typically populated from command-line arguments, configuration files, or environment variables during server startup.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>port</code></td>\n<td><code>int</code></td>\n<td>TCP port number for incoming connections - typically 8080 for development</td>\n</tr>\n<tr>\n<td><code>document_root</code></td>\n<td><code>char[MAX_PATH_LENGTH]</code></td>\n<td>Filesystem path to serve files from - security boundary for file access</td>\n</tr>\n<tr>\n<td><code>max_threads</code></td>\n<td><code>int</code></td>\n<td>Maximum number of worker threads in thread pool - prevents resource exhaustion</td>\n</tr>\n<tr>\n<td><code>max_connections</code></td>\n<td><code>int</code></td>\n<td>Maximum concurrent client connections - limits memory and file descriptor usage</td>\n</tr>\n<tr>\n<td><code>request_timeout_sec</code></td>\n<td><code>int</code></td>\n<td>Seconds to wait for complete request - prevents slowloris attacks</td>\n</tr>\n</tbody></table>\n<p>The <code>document_root</code> field establishes the <strong>security boundary</strong> for file serving. All file access must be validated against this root directory to prevent directory traversal attacks. The path validation logic uses this field as the trusted base path for resolving all requested file paths.</p>\n<p>The concurrency control fields (<code>max_threads</code>, <code>max_connections</code>) provide <strong>resource protection</strong> mechanisms. Without these limits, a malicious client could exhaust server resources by opening thousands of connections or triggering creation of unlimited threads. These limits enable <strong>graceful degradation</strong> under load rather than complete system failure.</p>\n<blockquote>\n<p><strong>Decision: Single Configuration Structure vs Component-Specific Config</strong></p>\n<ul>\n<li><strong>Context</strong>: Different server components need different configuration parameters, and we must decide how to organize these settings</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Single global configuration structure (chosen)</li>\n<li>Separate configuration structures per component</li>\n<li>Key-value configuration map with string keys</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Single <code>ServerConfig</code> structure with all parameters</li>\n<li><strong>Rationale</strong>: Simplifies configuration management and ensures all components see consistent values. Eliminates coordination issues between component-specific configs. Educational code benefits from centralized configuration.</li>\n<li><strong>Consequences</strong>: All components depend on the same config structure, which creates coupling but eliminates configuration synchronization bugs. Adding new parameters requires updating the central structure.</li>\n</ul>\n</blockquote>\n<p>The default configuration values provide sensible starting points for development and testing:</p>\n<table>\n<thead>\n<tr>\n<th>Parameter</th>\n<th>Default Value</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>port</code></td>\n<td><code>DEFAULT_PORT</code> (8080)</td>\n<td>Non-privileged port that doesn&#39;t require root access</td>\n</tr>\n<tr>\n<td><code>document_root</code></td>\n<td><code>./public</code></td>\n<td>Relative path allows easy setup in any directory</td>\n</tr>\n<tr>\n<td><code>max_threads</code></td>\n<td>10</td>\n<td>Sufficient for development testing without resource exhaustion</td>\n</tr>\n<tr>\n<td><code>max_connections</code></td>\n<td>100</td>\n<td>Reasonable limit for educational server implementation</td>\n</tr>\n<tr>\n<td><code>request_timeout_sec</code></td>\n<td>30</td>\n<td>Long enough for normal requests, short enough to prevent attacks</td>\n</tr>\n</tbody></table>\n<h3 id=\"connection-state-management\">Connection State Management</h3>\n<p>Connection state tracking manages the lifecycle and context of individual client connections. Think of connection state as the <strong>patron record</strong> system in our library analogy - for each visitor, we track when they arrived, which desk they&#39;re assigned to, and what resources they&#39;re currently using.</p>\n<p>The <code>ConnectionContext</code> structure maintains per-connection information throughout the request processing lifecycle. This context gets created when a client connects and destroyed when the connection closes, providing a clean abstraction for connection-specific data.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>client_fd</code></td>\n<td><code>int</code></td>\n<td>File descriptor for client socket - used for all I/O operations with this client</td>\n</tr>\n<tr>\n<td><code>client_addr</code></td>\n<td><code>struct sockaddr_in</code></td>\n<td>Client&#39;s IP address and port - useful for logging and access control</td>\n</tr>\n<tr>\n<td><code>connect_time</code></td>\n<td><code>time_t</code></td>\n<td>Timestamp when connection was established - enables timeout detection</td>\n</tr>\n<tr>\n<td><code>thread_id</code></td>\n<td><code>pthread_t</code></td>\n<td>Thread handling this connection - used for thread pool management</td>\n</tr>\n</tbody></table>\n<p>The <code>client_fd</code> field is the <strong>primary key</strong> for this connection - all socket operations use this file descriptor to identify which client to communicate with. This field must be carefully managed to prevent <strong>file descriptor leaks</strong>, where unclosed descriptors eventually exhaust system resources.</p>\n<p>The <code>client_addr</code> field captures the network address of the connecting client. This information serves multiple purposes: security logging (tracking which IPs generate errors), access control (blocking malicious IPs), and debugging (identifying problematic clients). The <code>sockaddr_in</code> structure contains the client&#39;s IP address and port number in network byte order.</p>\n<blockquote>\n<p><strong>Decision: Per-Connection Context vs Global Connection Tracking</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to track active connections for resource management and graceful shutdown, and must decide how to organize this tracking</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Individual context structures passed to handlers (chosen)</li>\n<li>Global connection registry with lookup by file descriptor</li>\n<li>Thread-local storage for connection data</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Individual <code>ConnectionContext</code> structures passed to request handlers</li>\n<li><strong>Rationale</strong>: Provides clear ownership model where each handler owns its connection context. Eliminates global state synchronization issues. Makes testing easier since handlers receive all needed context as parameters.</li>\n<li><strong>Consequences</strong>: Connection context must be explicitly passed between functions, but this makes data flow visible and eliminates hidden dependencies on global state.</li>\n</ul>\n</blockquote>\n<p>The connection lifecycle follows a predictable pattern that our data structures support:</p>\n<ol>\n<li><strong>Connection Establishment</strong>: TCP server creates <code>ConnectionContext</code> with client socket information</li>\n<li><strong>Request Processing</strong>: Context gets passed to HTTP parser and file handler for request processing</li>\n<li><strong>Response Generation</strong>: Context used for writing response back to client socket</li>\n<li><strong>Connection Cleanup</strong>: Context destruction triggers socket closure and resource cleanup</li>\n</ol>\n<p>Connection timeout detection uses the <code>connect_time</code> field to identify connections that have been idle too long. The timeout logic compares current time against <code>connect_time + request_timeout_sec</code> to determine if a connection should be forcibly closed:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>current_time = time(NULL);\nconnection_age = current_time - context-&gt;connect_time;\nif (connection_age &gt; config-&gt;request_timeout_sec) {\n    // Force connection closure to prevent resource exhaustion\n}</code></pre></div>\n\n<p>Thread tracking via <code>thread_id</code> enables proper cleanup during server shutdown. The main server can iterate through active connections and signal worker threads to complete current requests before terminating. This field also helps with debugging by associating log messages with specific threads.</p>\n<blockquote>\n<p>⚠️ <strong>Pitfall: Connection Context Lifecycle Management</strong></p>\n<p>The most common mistake is failing to properly clean up connection contexts, leading to memory leaks and file descriptor exhaustion. Every <code>ConnectionContext</code> creation must have a corresponding cleanup that closes the client socket and frees any dynamically allocated resources. The cleanup must occur even when errors happen during request processing - use proper error handling patterns to ensure cleanup code always runs.</p>\n</blockquote>\n<h3 id=\"common-data-model-pitfalls\">Common Data Model Pitfalls</h3>\n<p>Understanding the common mistakes made when designing and implementing these data structures helps avoid subtle bugs that can be difficult to debug in a networked system.</p>\n<p>⚠️ <strong>Pitfall: Buffer Overflow in Fixed-Size Fields</strong></p>\n<p>The fixed-size character arrays in <code>HTTPRequest</code> and <code>HTTPResponse</code> provide safety but require careful bounds checking during parsing. Failing to validate input lengths before copying into these fields creates classic buffer overflow vulnerabilities. Always use <code>strncpy</code> instead of <code>strcpy</code> and ensure null termination:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Incorrect - potential overflow</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">strcpy</span><span style=\"color:#E1E4E8\">(request</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">method</span><span style=\"color:#E1E4E8\">, parsed_method);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Correct - bounds checking with null termination</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">strncpy</span><span style=\"color:#E1E4E8\">(request</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">method</span><span style=\"color:#E1E4E8\">, parsed_method, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(request</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">method) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">request</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">method</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(request->method) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p>⚠️ <strong>Pitfall: Memory Ownership Confusion</strong></p>\n<p>The HTTP structures mix stack-allocated fixed arrays with heap-allocated dynamic content (body fields). This creates confusion about who owns what memory and when to free it. Establish clear ownership rules: the parsing component allocates body memory, the request/response structure owns it during processing, and the cleanup component frees it. Never free body memory from multiple locations.</p>\n<p>⚠️ <strong>Pitfall: Network Byte Order in Address Structures</strong></p>\n<p>The <code>sockaddr_in</code> structure in <code>ConnectionContext</code> stores addresses in network byte order, while application code typically works with host byte order. Forgetting to convert between these formats causes connection failures and incorrect logging. Always use <code>htons</code>/<code>ntohs</code> for ports and <code>htonl</code>/<code>ntohl</code> for addresses when converting between network and host byte order.</p>\n<p>⚠️ <strong>Pitfall: Thread Safety in Shared Structures</strong></p>\n<p>While individual <code>ConnectionContext</code> structures are thread-safe because each connection runs in its own thread, the shared <code>ServerConfig</code> structure requires careful handling. Multiple threads may read configuration values concurrently, which is safe, but dynamic configuration updates would require synchronization. For this educational implementation, treat <code>ServerConfig</code> as read-only after initialization to avoid concurrency issues.</p>\n<p>⚠️ <strong>Pitfall: Resource Cleanup on Early Exit</strong></p>\n<p>Error conditions during request processing can cause early returns from functions, potentially skipping cleanup code. This leads to file descriptor leaks and memory leaks that accumulate over time. Structure your code to use cleanup patterns like <code>goto error_cleanup</code> in C or defer statements in other languages to ensure resources are always freed.</p>\n<p>The data model provides the foundation for all subsequent components in our HTTP server. These structures define the contracts between components and establish the memory management patterns that prevent common security vulnerabilities and resource leaks. Understanding these structures deeply enables confident implementation of the parsing, file serving, and concurrency components that build upon this foundation.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The data model implementation focuses on creating robust, secure data structures that prevent common web server vulnerabilities while maintaining simplicity for educational purposes. The following guidance provides complete working code for structure definitions and helper functions.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Memory Management</td>\n<td>Manual malloc/free with cleanup functions</td>\n<td>Memory pools with automatic cleanup</td>\n</tr>\n<tr>\n<td>String Handling</td>\n<td>Fixed-size buffers with strncpy</td>\n<td>Dynamic strings with automatic resizing</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>Compile-time constants</td>\n<td>Runtime config file parsing</td>\n</tr>\n<tr>\n<td>Address Handling</td>\n<td>Manual network/host byte order conversion</td>\n<td>Address utility library wrapper</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>http-server/\n  src/\n    data_model.h              ← structure definitions (this section)\n    data_model.c              ← helper functions and cleanup\n    http_parser.h             ← parsing component\n    http_parser.c\n    file_handler.h            ← file serving component  \n    file_handler.c\n    tcp_server.h              ← network component\n    tcp_server.c\n    main.c                    ← entry point\n  tests/\n    test_data_model.c         ← unit tests for structures\n  public/                     ← document root for serving files\n    index.html\n    style.css</code></pre></div>\n\n<h4 id=\"complete-data-structure-definitions\">Complete Data Structure Definitions</h4>\n<p><strong>File: <code>src/data_model.h</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> DATA_MODEL_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DATA_MODEL_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/socket.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;netinet/in.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;pthread.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;time.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stddef.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Protocol and size constants</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_REQUEST_SIZE</span><span style=\"color:#79B8FF\"> 8192</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_PATH_LENGTH</span><span style=\"color:#79B8FF\"> 1024</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_HEADERS</span><span style=\"color:#79B8FF\"> 32</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_HEADER_LENGTH</span><span style=\"color:#79B8FF\"> 256</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEFAULT_PORT</span><span style=\"color:#79B8FF\"> 8080</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HTTP request structure - represents parsed client request</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> method</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">                              // HTTP method (GET, POST, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">[MAX_PATH_LENGTH];</span><span style=\"color:#6A737D\">                   // URL path component</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> version</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">                             // HTTP version (HTTP/1.1)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> headers</span><span style=\"color:#E1E4E8\">[MAX_HEADERS][</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">][MAX_HEADER_LENGTH];</span><span style=\"color:#6A737D\"> // [index][0]=key, [index][1]=value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> header_count;</span><span style=\"color:#6A737D\">                             // Number of valid headers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> body;</span><span style=\"color:#6A737D\">                                   // Dynamically allocated body content</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> body_length;</span><span style=\"color:#6A737D\">                          // Size of body in bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} HTTPRequest;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HTTP response structure - represents server response to send</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> status_code;</span><span style=\"color:#6A737D\">                              // HTTP status code (200, 404, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> status_text</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">                         // Status reason phrase</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> headers</span><span style=\"color:#E1E4E8\">[MAX_HEADERS][</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">][MAX_HEADER_LENGTH];</span><span style=\"color:#6A737D\"> // Response headers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> header_count;</span><span style=\"color:#6A737D\">                             // Number of response headers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> body;</span><span style=\"color:#6A737D\">                                   // Response body content</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> body_length;</span><span style=\"color:#6A737D\">                          // Size of response body</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} HTTPResponse;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Server configuration - runtime parameters</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> port;</span><span style=\"color:#6A737D\">                                     // TCP port to listen on</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> document_root</span><span style=\"color:#E1E4E8\">[MAX_PATH_LENGTH];</span><span style=\"color:#6A737D\">          // Root directory for file serving</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> max_threads;</span><span style=\"color:#6A737D\">                              // Maximum worker threads</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> max_connections;</span><span style=\"color:#6A737D\">                          // Maximum concurrent connections</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> request_timeout_sec;</span><span style=\"color:#6A737D\">                      // Request timeout in seconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ServerConfig;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Connection context - per-connection state tracking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> client_fd;</span><span style=\"color:#6A737D\">                                // Client socket file descriptor</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> sockaddr_in client_addr;</span><span style=\"color:#6A737D\">               // Client network address</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    time_t</span><span style=\"color:#E1E4E8\"> connect_time;</span><span style=\"color:#6A737D\">                          // When connection was established</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_t</span><span style=\"color:#E1E4E8\"> thread_id;</span><span style=\"color:#6A737D\">                          // Thread handling this connection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ConnectionContext;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper function declarations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> init_http_request</span><span style=\"color:#E1E4E8\">(HTTPRequest</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> request</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> init_http_response</span><span style=\"color:#E1E4E8\">(HTTPResponse</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> response</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> init_server_config</span><span style=\"color:#E1E4E8\">(ServerConfig</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> init_connection_context</span><span style=\"color:#E1E4E8\">(ConnectionContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> client_fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> sockaddr_in</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> addr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> cleanup_http_request</span><span style=\"color:#E1E4E8\">(HTTPRequest</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> request</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> cleanup_http_response</span><span style=\"color:#E1E4E8\">(HTTPResponse</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> response</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> add_response_header</span><span style=\"color:#E1E4E8\">(HTTPResponse</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> response</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#B392F0\"> get_request_header</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> HTTPRequest</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> request</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> // DATA_MODEL_H</span></span></code></pre></div>\n\n<h4 id=\"core-helper-functions-complete-implementation\">Core Helper Functions (Complete Implementation)</h4>\n<p><strong>File: <code>src/data_model.c</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"data_model.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize HTTPRequest structure with safe defaults</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> init_http_request</span><span style=\"color:#E1E4E8\">(HTTPRequest</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">request) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(request->method, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(request->method));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(request->path, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(request->path));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(request->version, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(request->version));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(request->headers, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(request->headers));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    request->header_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    request->body </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    request->body_length </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize HTTPResponse structure with safe defaults</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> init_http_response</span><span style=\"color:#E1E4E8\">(HTTPResponse</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> response</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">response) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response->status_code </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 200</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    strncpy</span><span style=\"color:#E1E4E8\">(response->status_text, </span><span style=\"color:#9ECBFF\">\"OK\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(response->status_text) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response->status_text[</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(response->status_text) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(response->headers, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(response->headers));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response->header_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response->body </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response->body_length </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize ServerConfig with sensible defaults</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> init_server_config</span><span style=\"color:#E1E4E8\">(ServerConfig</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">config) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config->port </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> DEFAULT_PORT;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    strncpy</span><span style=\"color:#E1E4E8\">(config->document_root, </span><span style=\"color:#9ECBFF\">\"./public\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(config->document_root) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config->document_root[</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(config->document_root) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config->max_threads </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config->max_connections </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config->request_timeout_sec </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 30</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize connection context with client information</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> init_connection_context</span><span style=\"color:#E1E4E8\">(ConnectionContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> client_fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> sockaddr_in</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> addr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">context) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context->client_fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> client_fd;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (addr) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        context->client_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">addr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">context->client_addr, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(context->client_addr));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context->connect_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context->thread_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pthread_self</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Clean up dynamically allocated request memory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> cleanup_http_request</span><span style=\"color:#E1E4E8\">(HTTPRequest</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">request) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (request->body) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        free</span><span style=\"color:#E1E4E8\">(request->body);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        request->body </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        request->body_length </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Clean up dynamically allocated response memory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> cleanup_http_response</span><span style=\"color:#E1E4E8\">(HTTPResponse</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> response</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">response) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Note: Only free body if it was dynamically allocated</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // File content bodies may point to mapped memory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (response->body) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        free</span><span style=\"color:#E1E4E8\">(response->body);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        response->body </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        response->body_length </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-for-learners-to-complete\">Core Logic Skeleton (for learners to complete)</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Add a header to HTTP response - learners implement this</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> add_response_header</span><span style=\"color:#E1E4E8\">(HTTPResponse</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> response</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if response and key/value pointers are valid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if we have space for another header (header_count &#x3C; MAX_HEADERS)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Copy key into headers[header_count][0] using strncpy with bounds checking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Copy value into headers[header_count][1] using strncpy with bounds checking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Ensure both strings are null-terminated</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Increment header_count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return 0 on success, -1 on error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Always leave one byte for null terminator when using strncpy</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Find header value by key in HTTP request - learners implement this</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#B392F0\"> get_request_header</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> HTTPRequest</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> request</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if request and key pointers are valid - return NULL if not</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Loop through request->header_count headers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For each header, compare headers[i][0] with key using strcasecmp (case-insensitive)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If match found, return pointer to headers[i][1] (the value)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If no match found after loop, return NULL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use strcasecmp for case-insensitive header name comparison</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After implementing data structures:</strong></p>\n<ol>\n<li><strong>Compilation Test</strong>: Run <code>gcc -c src/data_model.c -o data_model.o</code> - should compile without errors</li>\n<li><strong>Initialization Test</strong>: Create simple test program that initializes each structure and prints field values</li>\n<li><strong>Memory Test</strong>: Use <code>valgrind</code> to check for memory leaks in cleanup functions</li>\n</ol>\n<p><strong>Expected behavior:</strong></p>\n<ul>\n<li>All structures initialize with safe default values</li>\n<li>Header functions handle bounds checking correctly</li>\n<li>Cleanup functions prevent memory leaks</li>\n<li>No segmentation faults or buffer overflows</li>\n</ul>\n<p><strong>Signs of problems:</strong></p>\n<ul>\n<li>Compiler warnings about buffer overflows → Check strncpy usage and null termination</li>\n<li>Segfaults during initialization → Check pointer validation in functions</li>\n<li>Memory leaks in valgrind → Ensure cleanup functions free all allocated memory</li>\n</ul>\n<h4 id=\"language-specific-implementation-hints\">Language-Specific Implementation Hints</h4>\n<p><strong>C-Specific Guidelines:</strong></p>\n<ul>\n<li>Always use <code>strncpy</code> instead of <code>strcpy</code> for fixed-size buffers</li>\n<li>Set explicit null terminators: <code>buffer[size-1] = &#39;\\0&#39;</code> after strncpy</li>\n<li>Check all pointer parameters for NULL before dereferencing</li>\n<li>Use <code>memset</code> to zero-initialize structures containing arrays</li>\n<li>Free dynamically allocated memory in reverse order of allocation</li>\n</ul>\n<p><strong>Memory Management Patterns:</strong></p>\n<ul>\n<li>Initialize all structure fields to safe defaults (NULL pointers, zero values)</li>\n<li>Use consistent naming: <code>init_*</code> for initialization, <code>cleanup_*</code> for deallocation</li>\n<li>Never free the same pointer twice - set to NULL after freeing</li>\n<li>Check malloc return values - handle allocation failures gracefully</li>\n</ul>\n<p><strong>Network Address Handling:</strong></p>\n<ul>\n<li>Use <code>htons()</code> when setting port in sockaddr_in: <code>addr.sin_port = htons(port)</code></li>\n<li>Use <code>ntohs()</code> when reading port from sockaddr_in: <code>port = ntohs(addr.sin_port)</code></li>\n<li>Set address family explicitly: <code>addr.sin_family = AF_INET</code></li>\n<li>Use <code>INADDR_ANY</code> for server binding: <code>addr.sin_addr.s_addr = INADDR_ANY</code></li>\n</ul>\n<p>This implementation foundation provides type-safe, bounds-checked data structures that prevent common web server vulnerabilities while maintaining educational clarity. The helper functions establish consistent patterns for initialization and cleanup that carry forward into more complex components.</p>\n<h2 id=\"tcp-server-component\">TCP Server Component</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1 (TCP Server Basics) - creates the foundational networking layer that accepts and manages TCP connections</p>\n</blockquote>\n<h3 id=\"tcp-server-mental-model-restaurant-host-station-analogy\">TCP Server Mental Model: Restaurant Host Station Analogy</h3>\n<p>Think of the TCP server component as the host station at a busy restaurant. Just as a restaurant host manages the front door, greets guests, and assigns them to available tables, our TCP server manages the network &quot;front door,&quot; accepts incoming client connections, and prepares them for request processing.</p>\n<p>The <strong>server socket</strong> is like the restaurant&#39;s front door itself - it&#39;s a fixed location where customers know they can arrive. The host doesn&#39;t serve food directly; instead, they perform the crucial role of managing arrivals and ensuring each guest gets proper attention. Similarly, our server socket doesn&#39;t process HTTP requests directly - it focuses solely on the TCP connection lifecycle.</p>\n<p>When a customer approaches the restaurant, the host performs a standard greeting ritual: welcoming them, checking if they have a reservation, and determining where to seat them. In our TCP server, this greeting ritual is the <strong>connection acceptance process</strong>: we accept the incoming connection, validate it&#39;s properly formed, and prepare a dedicated communication channel for that specific client.</p>\n<p>The host station maintains a guest registry - tracking who&#39;s currently dining, when they arrived, and which table they&#39;re using. Our TCP server maintains <strong>connection context</strong> - tracking which clients are connected, their network addresses, and the file descriptors representing their communication channels.</p>\n<p>Just as a restaurant can only seat a limited number of guests based on table availability and staff capacity, our TCP server must manage <strong>resource limits</strong>. When the restaurant is full, the host might ask new arrivals to wait or politely suggest they try again later. Similarly, when our server reaches its connection limits, it must gracefully handle new connection attempts without crashing or leaving clients hanging indefinitely.</p>\n<p>The host station operates independently of the kitchen - guests can arrive and be seated even when the kitchen is temporarily busy. This separation of concerns is crucial in our TCP server design: connection acceptance operates independently of HTTP request processing, allowing us to maintain responsive networking even when file serving or parsing operations take time.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fconnection-lifecycle.svg\" alt=\"TCP Connection Lifecycle\"></p>\n<h3 id=\"tcp-server-interface\">TCP Server Interface</h3>\n<p>The TCP server component exposes a clean interface that abstracts the underlying socket programming complexity while providing the necessary control points for configuration and lifecycle management. This interface serves as the contract between the networking layer and the rest of our HTTP server components.</p>\n<p>The interface design follows the principle of <strong>progressive disclosure</strong> - simple cases require minimal configuration, while advanced scenarios can access detailed control options. A junior developer can get a basic server running with just a port number, while an experienced developer can fine-tune socket options, connection limits, and error handling behavior.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>create_server_socket</code></td>\n<td><code>port int</code></td>\n<td><code>int</code></td>\n<td>Creates, configures, and binds server socket to specified port. Returns server file descriptor or -1 on failure.</td>\n</tr>\n<tr>\n<td><code>server_main_loop</code></td>\n<td><code>server_fd int</code></td>\n<td><code>void</code></td>\n<td>Main connection acceptance loop. Blocks accepting connections until server shutdown signal received.</td>\n</tr>\n<tr>\n<td><code>init_connection_context</code></td>\n<td><code>context ConnectionContext*, client_fd int, addr sockaddr_in</code></td>\n<td><code>void</code></td>\n<td>Initializes connection context structure with client information and timestamps.</td>\n</tr>\n<tr>\n<td><code>accept_client_connection</code></td>\n<td><code>server_fd int, context ConnectionContext*</code></td>\n<td><code>int</code></td>\n<td>Accepts single client connection and populates context. Returns client file descriptor or -1.</td>\n</tr>\n<tr>\n<td><code>close_client_connection</code></td>\n<td><code>context ConnectionContext*</code></td>\n<td><code>void</code></td>\n<td>Properly closes client connection and cleans up associated resources.</td>\n</tr>\n<tr>\n<td><code>set_socket_options</code></td>\n<td><code>sockfd int, options int</code></td>\n<td><code>int</code></td>\n<td>Configures socket options like SO_REUSEADDR, timeouts. Returns 0 on success.</td>\n</tr>\n<tr>\n<td><code>validate_client_connection</code></td>\n<td><code>context ConnectionContext*</code></td>\n<td><code>int</code></td>\n<td>Validates incoming connection against rate limits and security policies. Returns 1 if valid.</td>\n</tr>\n</tbody></table>\n<p>The interface separates <strong>socket lifecycle management</strong> from <strong>connection processing</strong>. The <code>create_server_socket</code> function handles all the complex socket setup that must happen once at server startup: creating the socket, setting appropriate options, binding to the network interface, and beginning to listen for connections. This separation means the main server loop can focus purely on the accept-process-cleanup cycle without worrying about socket configuration details.</p>\n<p>Connection context initialization through <code>init_connection_context</code> ensures that every client connection gets proper bookkeeping from the moment it&#39;s established. This context tracking becomes crucial later when we implement concurrent connection handling - each thread or event handler needs access to connection-specific state without interfering with other active connections.</p>\n<p>The <code>validate_client_connection</code> method provides an extension point for implementing security policies, rate limiting, and resource management without cluttering the core acceptance logic. In a production server, this method might check the client&#39;s IP address against blacklists, enforce per-IP connection limits, or apply geographic restrictions.</p>\n<blockquote>\n<p><strong>Key Design Principle</strong>: The TCP server interface maintains <strong>single responsibility</strong> - it knows how to manage TCP connections but remains agnostic about what data flows over those connections. This separation allows the same TCP foundation to support not just HTTP, but potentially other protocols in future extensions.</p>\n</blockquote>\n<h3 id=\"connection-acceptance-algorithm\">Connection Acceptance Algorithm</h3>\n<p>The connection acceptance algorithm represents the core networking logic that transforms an abstract &quot;listening socket&quot; into concrete client connections ready for HTTP processing. This algorithm runs continuously while the server is active, making it one of the most critical paths in our entire system.</p>\n<p>Understanding this algorithm requires recognizing that <strong>TCP connection establishment</strong> is actually a multi-step handshake between client and server, coordinated by the operating system&#39;s networking stack. Our server code participates in this handshake through specific socket system calls, but much of the complexity is handled transparently by the kernel.</p>\n<p>Here&#39;s the detailed connection acceptance process:</p>\n<ol>\n<li><p><strong>Initialize Server Socket</strong>: Create a socket file descriptor using <code>socket(AF_INET, SOCK_STREAM, 0)</code> to establish a TCP communication endpoint. This creates a socket in the <strong>closed state</strong> that exists only in our process memory.</p>\n</li>\n<li><p><strong>Configure Socket Options</strong>: Apply socket options before binding to prevent common deployment issues. Set <code>SO_REUSEADDR</code> to allow rapid server restarts without &quot;Address already in use&quot; errors. Configure timeout options to prevent indefinite blocking on problematic connections.</p>\n</li>\n<li><p><strong>Bind to Network Address</strong>: Associate the socket with a specific network interface and port using <code>bind()</code>. This reserves the port number system-wide and transitions the socket to the <strong>bound state</strong>. The <code>sockaddr_in</code> structure specifies IPv4 protocol family, target port in network byte order, and <code>INADDR_ANY</code> to accept connections on all available network interfaces.</p>\n</li>\n<li><p><strong>Begin Listening</strong>: Transition the socket to <strong>listening state</strong> using <code>listen()</code> with a backlog parameter that determines how many pending connections the kernel will queue while our server processes current requests. A backlog of 128 provides good balance between memory usage and connection responsiveness.</p>\n</li>\n<li><p><strong>Enter Acceptance Loop</strong>: Begin the infinite loop that defines our server&#39;s operational lifetime. Each iteration handles one complete connection acceptance cycle, from detecting an incoming connection to preparing it for request processing.</p>\n</li>\n<li><p><strong>Block on Accept Call</strong>: Execute <code>accept()</code> system call which blocks the current thread until a client initiates a TCP connection. The kernel handles the three-way TCP handshake automatically - by the time <code>accept()</code> returns, the connection is fully established and ready for data exchange.</p>\n</li>\n<li><p><strong>Extract Client Information</strong>: When <code>accept()</code> returns successfully, it provides two critical pieces of information: a new file descriptor representing the established connection, and a <code>sockaddr_in</code> structure containing the client&#39;s network address and port. This client information enables logging, security validation, and debugging.</p>\n</li>\n<li><p><strong>Initialize Connection Context</strong>: Populate a <code>ConnectionContext</code> structure with the client file descriptor, address information, connection timestamp, and any other per-connection state our server needs to track. This context follows the connection through its entire processing lifecycle.</p>\n</li>\n<li><p><strong>Validate Connection</strong>: Apply security policies and resource limits to determine if this connection should be processed or rejected. Check the client&#39;s IP address against any configured restrictions, verify we haven&#39;t exceeded our maximum concurrent connection limit, and apply any rate limiting rules.</p>\n</li>\n<li><p><strong>Hand Off to Request Processor</strong>: If the connection passes validation, transfer responsibility to the HTTP processing components. In a single-threaded server, this means immediately beginning HTTP parsing. In a multi-threaded server, this means dispatching the connection to a worker thread or adding it to a work queue.</p>\n</li>\n<li><p><strong>Handle Connection Errors</strong>: If any step in the acceptance process fails, log the error with sufficient detail for debugging, ensure any partially allocated resources are cleaned up, and continue the acceptance loop. Server errors should not prevent processing other valid connections.</p>\n</li>\n<li><p><strong>Prepare for Next Connection</strong>: Reset any per-connection state, check for shutdown signals, and return to the blocking accept call to handle the next incoming connection.</p>\n</li>\n</ol>\n<p>The algorithm&#39;s <strong>error handling strategy</strong> deserves special attention because network programming involves many potential failure modes. Connection acceptance can fail due to temporary resource exhaustion (too many open file descriptors), network interface issues, or malicious connection attempts. The algorithm must distinguish between <strong>recoverable errors</strong> (temporary resource shortage) and <strong>fatal errors</strong> (socket corruption) to maintain server stability.</p>\n<p><strong>Resource management</strong> throughout this algorithm is critical for long-running server stability. Every successful <code>accept()</code> call creates a new file descriptor that must eventually be closed. Every <code>ConnectionContext</code> structure that gets allocated must eventually be cleaned up. The algorithm includes explicit checkpoints where resource cleanup occurs, preventing the gradual resource leaks that would eventually crash a long-running server.</p>\n<p>The algorithm&#39;s <strong>blocking behavior</strong> on the accept call has important implications for server architecture. In a single-threaded server, the entire server blocks waiting for connections, which means request processing must complete before new connections can be accepted. This creates a natural backpressure mechanism but limits concurrency. Understanding this blocking behavior is essential for making informed decisions about concurrency models in later milestones.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Frequest-processing-flow.svg\" alt=\"Request Processing Sequence\"></p>\n<h3 id=\"architecture-decision-records\">Architecture Decision Records</h3>\n<p>The TCP server component involves several fundamental architectural decisions that significantly impact the server&#39;s behavior, performance characteristics, and operational requirements. Each decision represents a trade-off between different operational priorities and implementation complexity levels.</p>\n<blockquote>\n<p><strong>Decision: Socket Address Configuration</strong></p>\n<ul>\n<li><strong>Context</strong>: Server must bind to a network address that clients can reach, but different deployment scenarios require different binding strategies. Local development needs different configuration than production deployment.</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Bind to localhost (127.0.0.1) only for development safety</li>\n<li>Bind to specific IP address provided via configuration</li>\n<li>Bind to INADDR_ANY (0.0.0.0) accepting connections on all interfaces</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Bind to <code>INADDR_ANY</code> with configurable port</li>\n<li><strong>Rationale</strong>: Maximum deployment flexibility allows same code to work in development (localhost access), containerized environments (bridge networks), and production (public interfaces). Security restrictions should be handled by firewalls and network policies rather than application binding logic.</li>\n<li><strong>Consequences</strong>: Enables flexible deployment but requires careful firewall configuration in production. Simplifies development and testing workflows.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Localhost only</td>\n<td>Development safety, prevents accidental exposure</td>\n<td>Requires separate production configuration, complicates container networking</td>\n</tr>\n<tr>\n<td>Specific IP configuration</td>\n<td>Precise control, explicit security</td>\n<td>Complex configuration management, brittle to infrastructure changes</td>\n</tr>\n<tr>\n<td>INADDR_ANY</td>\n<td>Maximum flexibility, simple configuration</td>\n<td>Requires external security controls, potential for misconfiguration</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Socket Option Configuration</strong></p>\n<ul>\n<li><strong>Context</strong>: Default socket behavior often conflicts with server restart requirements and connection handling preferences. Raw sockets have conservative defaults that prioritize data integrity over operational convenience.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Use default socket options for maximum compatibility</li>\n<li>Set SO_REUSEADDR only for restart convenience</li>\n<li>Configure comprehensive socket options including timeouts and buffer sizes</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Set <code>SO_REUSEADDR</code> and basic timeout options, avoid advanced optimizations</li>\n<li><strong>Rationale</strong>: <code>SO_REUSEADDR</code> solves a critical development pain point (rapid restart failures) with minimal complexity. Advanced socket tuning requires deep networking knowledge and varies significantly across operating systems. Focus on educational value rather than production optimization.</li>\n<li><strong>Consequences</strong>: Enables smooth development workflow and basic timeout protection without introducing configuration complexity that obscures learning objectives.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Default options</td>\n<td>Maximum compatibility, simple code</td>\n<td>Restart failures, no timeout protection</td>\n</tr>\n<tr>\n<td>SO_REUSEADDR only</td>\n<td>Solves restart problem, minimal complexity</td>\n<td>No protection against hung connections</td>\n</tr>\n<tr>\n<td>Comprehensive tuning</td>\n<td>Production-quality performance</td>\n<td>Complex configuration, platform-specific code</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Connection Backlog Size</strong></p>\n<ul>\n<li><strong>Context</strong>: The <code>listen()</code> system call requires a backlog parameter that determines how many pending connections the kernel queues while the server processes current requests. This value significantly impacts behavior under load.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Small backlog (5-10) for simple educational scenarios</li>\n<li>Medium backlog (128) balancing memory and responsiveness</li>\n<li>Large backlog (1024+) for maximum connection handling</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Medium backlog of 128 connections</li>\n<li><strong>Rationale</strong>: Small backlogs cause connection rejections during normal load testing with simple tools like curl loops. Large backlogs consume significant kernel memory and can mask concurrency problems by hiding the need for efficient request processing. 128 connections provides sufficient buffering for realistic testing while revealing performance bottlenecks.</li>\n<li><strong>Consequences</strong>: Allows meaningful load testing without overwhelming resource usage. Students can observe queue behavior under load without requiring sophisticated testing tools.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Small backlog (5-10)</td>\n<td>Low memory usage, simple</td>\n<td>Connection rejections during normal testing</td>\n</tr>\n<tr>\n<td>Medium backlog (128)</td>\n<td>Good testing flexibility, reasonable memory</td>\n<td>Moderate kernel memory usage</td>\n</tr>\n<tr>\n<td>Large backlog (1024+)</td>\n<td>Handles high load</td>\n<td>High memory usage, masks performance problems</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Error Handling Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Network operations can fail in numerous ways - temporary resource exhaustion, client disconnections, malformed connection attempts, and system-level networking issues. The server must handle these failures without crashing while providing useful debugging information.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Aggressive error checking with server shutdown on any failure</li>\n<li>Graceful degradation continuing operation despite individual connection failures</li>\n<li>Minimal error handling focusing on core functionality</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Graceful degradation with comprehensive logging</li>\n<li><strong>Rationale</strong>: Real servers must remain operational despite individual connection failures - network programming inherently involves partial failures that don&#39;t indicate server problems. Aggressive shutdown makes the server fragile during development and testing. Comprehensive logging provides debugging information without operational brittleness.</li>\n<li><strong>Consequences</strong>: Server remains stable during testing with imperfect clients (browsers, curl with various options) but requires systematic logging implementation and error classification.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Aggressive shutdown</td>\n<td>Simple code, fail-fast behavior</td>\n<td>Brittle operation, difficult testing</td>\n</tr>\n<tr>\n<td>Graceful degradation</td>\n<td>Stable operation, realistic behavior</td>\n<td>Complex error classification</td>\n</tr>\n<tr>\n<td>Minimal handling</td>\n<td>Simple implementation</td>\n<td>Difficult debugging, potential resource leaks</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Resource Cleanup Responsibility</strong></p>\n<ul>\n<li><strong>Context</strong>: TCP connections create file descriptors that must be properly closed to prevent resource leaks. Connection contexts may allocate memory that requires cleanup. Clear ownership of cleanup responsibility prevents resource leaks and double-free errors.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>TCP server handles all cleanup automatically</li>\n<li>Caller responsible for cleanup using provided cleanup functions</li>\n<li>Hybrid approach with automatic cleanup for errors, manual for success cases</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Caller responsible for cleanup using provided cleanup functions</li>\n<li><strong>Rationale</strong>: Clear ownership semantics prevent resource management confusion. The connection processing components need control over connection lifetime - automatic cleanup could interfere with Keep-Alive implementations or connection reuse. Explicit cleanup functions provide safety without removing control.</li>\n<li><strong>Consequences</strong>: Requires discipline in calling cleanup functions but provides clear resource ownership. Enables advanced connection management patterns in future extensions.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Automatic cleanup</td>\n<td>Simple usage, prevents leaks</td>\n<td>Limited control, complicates advanced features</td>\n</tr>\n<tr>\n<td>Caller responsible</td>\n<td>Clear ownership, maximum control</td>\n<td>Requires discipline, potential for mistakes</td>\n</tr>\n<tr>\n<td>Hybrid approach</td>\n<td>Balances safety and control</td>\n<td>Complex ownership rules, confusing semantics</td>\n</tr>\n</tbody></table>\n<h3 id=\"tcp-server-interface-implementation-details\">TCP Server Interface Implementation Details</h3>\n<p>The TCP server interface requires careful attention to <strong>state management</strong> and <strong>error propagation</strong> to ensure reliable operation across diverse deployment scenarios. Each interface method has specific preconditions and postconditions that must be clearly documented and consistently enforced.</p>\n<p>The <code>create_server_socket</code> function encapsulates the complex socket initialization sequence that must occur exactly once per server lifetime. This function performs operations that cannot be safely retried or undone, making its error handling particularly important. Socket creation can fail due to permission issues (binding to privileged ports), resource exhaustion (too many open file descriptors), or network configuration problems (invalid addresses).</p>\n<p><strong>Socket option configuration</strong> within <code>create_server_socket</code> requires platform-specific knowledge but follows a standard pattern. The <code>SO_REUSEADDR</code> option allows immediate reuse of the server&#39;s port after shutdown, preventing the &quot;Address already in use&quot; errors that commonly frustrate developers during testing. Without this option, the operating system enforces a waiting period (typically 2-4 minutes) before allowing port reuse, which severely impacts development iteration speed.</p>\n<p>The <code>server_main_loop</code> function implements the server&#39;s primary operational mode - an infinite loop accepting connections until explicitly shut down. This function&#39;s blocking behavior means it effectively <strong>owns the main thread</strong> in single-threaded server implementations. The loop must handle both normal connection acceptance and graceful shutdown signaling without dropping in-flight connections.</p>\n<p>Connection context management through <code>init_connection_context</code> establishes the data structures that track each client connection throughout its processing lifecycle. The context includes not just the client file descriptor, but also timing information for timeout enforcement, client address data for logging and security decisions, and space for connection-specific state that accumulates during request processing.</p>\n<p>The interface&#39;s <strong>error reporting strategy</strong> uses return codes rather than exceptions or global error state, following C language conventions and ensuring that error conditions can be handled immediately at the call site. Negative return values indicate errors, zero indicates success for status-returning functions, and positive values carry meaningful data (like file descriptors).</p>\n<p><strong>Resource ownership semantics</strong> throughout the interface follow a consistent pattern: the caller owns any resources returned by the interface methods and bears responsibility for cleanup. This ownership model prevents the common resource management confusion that occurs when ownership transfers unpredictably between components. The interface provides explicit cleanup functions rather than relying on automatic resource management.</p>\n<h3 id=\"connection-acceptance-algorithm-implementation\">Connection Acceptance Algorithm Implementation</h3>\n<p>The connection acceptance algorithm implementation must handle the inherent <strong>asynchronous nature</strong> of network operations while maintaining deterministic server behavior. Network clients can connect, send partial data, and disconnect at any time, creating numerous edge cases that must be handled gracefully without corrupting server state.</p>\n<p>The algorithm&#39;s <strong>blocking semantics</strong> on the accept call create an important architectural constraint. When <code>accept()</code> blocks waiting for connections, the calling thread cannot perform other operations. This blocking behavior is actually beneficial in many scenarios - it provides natural flow control and prevents the server from consuming CPU cycles when no work is available. However, it also means that server shutdown must occur through signal handling or secondary threads, since the main thread remains blocked in the accept call.</p>\n<p><strong>File descriptor management</strong> within the algorithm requires careful attention to avoid resource leaks that would eventually crash the server. Each successful accept operation creates a new file descriptor that represents the client connection. These file descriptors are a limited system resource - most operating systems impose per-process limits between 1,024 and 65,536 open file descriptors. Failing to close client connections eventually exhausts this limit and prevents new connections.</p>\n<p>The algorithm must handle <strong>partial connection establishment</strong> scenarios where clients begin the TCP handshake but fail to complete it properly. The <code>accept()</code> call returns successfully once the TCP three-way handshake completes, but clients might immediately close the connection or send malformed data. The algorithm treats these as normal occurrences rather than error conditions, logging them for debugging purposes but continuing normal operation.</p>\n<p><strong>Client address extraction</strong> from the <code>sockaddr_in</code> structure returned by accept provides valuable debugging and security information. The client&#39;s IP address and port number help diagnose connection issues and can be used for implementing security policies like rate limiting or geographic restrictions. However, this address information reflects the immediate network peer, which might be a proxy or load balancer in production deployments rather than the actual end user.</p>\n<p>The algorithm&#39;s <strong>error classification logic</strong> distinguishes between different types of accept failures to determine appropriate responses. Temporary failures like <code>EMFILE</code> (too many open files) or <code>EAGAIN</code> (resource temporarily unavailable) indicate resource pressure but don&#39;t require server shutdown. Persistent failures like <code>EBADF</code> (bad file descriptor) or <code>EINVAL</code> (invalid argument) indicate programming errors or socket corruption that require investigation.</p>\n<p><strong>Connection validation</strong> occurs immediately after successful connection establishment, before any data exchange begins. This validation checks that the new connection fits within configured resource limits, that the client address doesn&#39;t violate security policies, and that the server has sufficient resources to handle request processing. Connections that fail validation are rejected with appropriate logging but don&#39;t impact other active connections.</p>\n<p>The algorithm includes <strong>graceful degradation mechanisms</strong> for handling resource pressure without complete service failure. When connection limits are approached, the server can choose to reject new connections with meaningful error responses rather than accepting connections it cannot properly service. This degradation provides better client experience than accepting connections that will eventually timeout due to resource starvation.</p>\n<p><strong>Threading considerations</strong> affect how the connection acceptance algorithm integrates with concurrency models implemented in later milestones. In thread-per-connection models, each accepted connection gets dispatched to a dedicated thread immediately. In event-driven models, accepted connections are added to a monitoring set for asynchronous processing. The algorithm&#39;s design supports both approaches through its clear separation of connection establishment and request processing.</p>\n<h3 id=\"architecture-decision-records-advanced-considerations\">Architecture Decision Records: Advanced Considerations</h3>\n<p>Several additional architectural decisions significantly impact the TCP server&#39;s operational characteristics and integration with other system components. These decisions often involve subtle trade-offs that become apparent only during implementation and testing phases.</p>\n<blockquote>\n<p><strong>Decision: Socket Buffer Size Configuration</strong></p>\n<ul>\n<li><strong>Context</strong>: Operating system default socket buffer sizes optimize for general network usage but may not suit HTTP server workloads. HTTP requests vary dramatically in size (from simple GET requests under 200 bytes to large POST requests with file uploads), and buffer sizing affects memory usage and performance.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Use operating system defaults without modification</li>\n<li>Configure explicit send/receive buffer sizes based on expected request sizes</li>\n<li>Dynamic buffer sizing that adapts to observed request patterns</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use operating system defaults with monitoring points for future optimization</li>\n<li><strong>Rationale</strong>: Operating system defaults represent decades of networking optimization for typical workloads. Premature optimization of socket buffers often provides minimal benefit while adding configuration complexity. Monitoring points allow future measurement-driven optimization without initial complexity.</li>\n<li><strong>Consequences</strong>: Simplifies initial implementation and reduces configuration surface area. May require revisiting for high-performance scenarios, but provides solid foundation for educational objectives.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>Decision: IPv6 Support Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Modern networking environments increasingly use IPv6, but IPv6 socket programming adds significant complexity through dual-stack configuration, address family negotiation, and platform-specific behaviors.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>IPv4 only using AF_INET sockets exclusively</li>\n<li>IPv6 only using AF_INET6 sockets exclusively  </li>\n<li>Dual-stack supporting both protocols through separate sockets or IPv6 mapped addresses</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: IPv4 only for educational implementation with architecture supporting future IPv6 extension</li>\n<li><strong>Rationale</strong>: IPv4 socket programming provides clearer learning path with fewer platform-specific complications. Dual-stack networking involves subtle protocol interactions that distract from core HTTP server concepts. IPv4 remains widely supported and sufficient for learning objectives.</li>\n<li><strong>Consequences</strong>: Limits deployment scenarios but maintains focus on core concepts. Architecture design supports adding IPv6 support as advanced extension without requiring complete reimplementation.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>Decision: Connection Timeout Configuration</strong></p>\n<ul>\n<li><strong>Context</strong>: Client connections can remain idle indefinitely, consuming server resources without productive work. HTTP connections may experience network delays, slow clients, or malicious attempts to exhaust server resources through connection hoarding.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>No timeouts relying on client behavior and operating system defaults</li>\n<li>Hard timeouts that forcibly close connections after fixed duration</li>\n<li>Activity-based timeouts that reset when data is exchanged</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Configurable hard timeouts with reasonable defaults</li>\n<li><strong>Rationale</strong>: Educational servers need protection against resource exhaustion during testing with imperfect client code. Hard timeouts provide predictable resource reclamation without complex activity tracking logic. Configurable values allow adaptation to different testing scenarios.</li>\n<li><strong>Consequences</strong>: Prevents resource exhaustion during development but may close legitimate slow connections. Provides foundation for implementing more sophisticated timeout strategies in advanced versions.</li>\n</ul>\n</blockquote>\n<p>The timeout decision particularly impacts <strong>testing and debugging workflows</strong> because developers often pause execution in debuggers or step through code slowly while examining server behavior. Aggressive timeouts can interfere with debugging by closing connections while the developer investigates server state. The configurable approach allows disabling timeouts during debugging while maintaining protection during automated testing.</p>\n<p><strong>Platform portability</strong> considerations influence several interface design decisions, particularly around socket option availability and error code interpretation. Windows socket programming uses different error codes than Unix systems, and some socket options have different names or behaviors. The interface design acknowledges these differences without attempting complete abstraction, allowing platform-specific optimizations while maintaining core functionality across operating systems.</p>\n<h3 id=\"common-tcp-pitfalls\">Common TCP Pitfalls</h3>\n<p>TCP socket programming contains numerous subtle pitfalls that can create intermittent bugs, resource leaks, or security vulnerabilities. Understanding these pitfalls helps developers recognize and avoid common mistakes that can take hours to debug in complex networking code.</p>\n<p>⚠️ <strong>Pitfall: Network Byte Order Confusion</strong></p>\n<p>One of the most common mistakes in socket programming involves <strong>byte order conversion</strong> when working with port numbers and IP addresses. The <code>sockaddr_in</code> structure expects port numbers in <strong>network byte order</strong> (big-endian), but most development machines use little-endian byte order for local variables.</p>\n<p>The symptom appears as binding or connection failures with confusing error messages. A server configured to listen on port 8080 might actually attempt to bind to port 20737 (8080 with bytes swapped) if the <code>htons()</code> conversion is forgotten. This creates &quot;Address already in use&quot; errors that seem to occur randomly depending on what other services are running.</p>\n<p>The fix requires consistent use of byte order conversion functions: <code>htons()</code> for port numbers going into socket structures, and <code>ntohs()</code> for extracting port numbers from socket structures. IP addresses require <code>htonl()</code> and <code>ntohl()</code> conversion, though using <code>INADDR_ANY</code> avoids this issue for server binding.</p>\n<p>Prevention involves establishing a coding convention where all socket structure assignments use explicit byte order conversion, even when the values appear to work without conversion on the development machine. This consistency prevents subtle bugs when deploying to different architectures.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Partial Reads</strong></p>\n<p>Network I/O operations can return <strong>fewer bytes than requested</strong> even when more data is available and the connection remains active. The <code>read()</code> system call provides no guarantee about how much data it will return - it might return 1 byte, the full requested amount, or anything in between.</p>\n<p>This behavior creates intermittent parsing failures that are difficult to reproduce consistently. An HTTP request header might be split across multiple read operations, causing the parser to see incomplete lines or fragmented header fields. The resulting parsing errors often appear random and platform-dependent.</p>\n<p>The solution requires implementing <strong>complete request reading logic</strong> that continues reading until a full HTTP request has been received, rather than assuming a single read operation will capture the entire request. This involves detecting the end of HTTP headers (the empty line containing only CRLF) and reading any message body based on the Content-Length header.</p>\n<p>The <code>read_complete_request()</code> function addresses this pitfall by encapsulating the multi-read logic needed for reliable HTTP request reception. This function continues reading data until it has assembled a complete request or encounters a genuine error condition.</p>\n<p>⚠️ <strong>Pitfall: File Descriptor Leaks</strong></p>\n<p>Every successful <code>accept()</code> call creates a new <strong>file descriptor</strong> representing the client connection. These file descriptors must be explicitly closed when connection processing completes, or they accumulate over time until the server exhausts its file descriptor limit and can no longer accept connections.</p>\n<p>File descriptor leaks often go unnoticed during short-term testing but become apparent during longer test runs or load testing. The server appears to work correctly initially, then suddenly starts rejecting all new connections with &quot;Too many open files&quot; errors. This failure mode can be particularly confusing because existing connections continue working normally.</p>\n<p>The solution requires systematic <strong>resource cleanup</strong> at every exit point from connection processing code. This includes normal completion paths, error conditions, and exception scenarios. Using <code>ConnectionContext</code> structures with explicit cleanup functions helps ensure that connection-related resources are properly released.</p>\n<p>Prevention involves establishing clear <strong>resource ownership patterns</strong> where each component that acquires resources takes responsibility for releasing them. The TCP server component owns the server socket and is responsible for closing it during shutdown. Connection processing components own client file descriptors and must close them when processing completes.</p>\n<p>⚠️ <strong>Pitfall: Signal Handling Interference</strong></p>\n<p>Unix signal handling can interfere with <strong>blocking system calls</strong> like <code>accept()</code>, causing them to return with <code>EINTR</code> errors when signals are delivered. This creates intermittent connection acceptance failures that appear random and platform-dependent.</p>\n<p>The symptom manifests as occasional accept failures during normal operation, particularly when debugging tools or system monitoring generates signals. The server might work perfectly during casual testing but fail intermittently under production-like monitoring conditions.</p>\n<p>The fix involves checking for <code>EINTR</code> return codes from <code>accept()</code> and retrying the operation rather than treating it as a genuine error condition. This <strong>restart logic</strong> should be applied consistently to all blocking system calls that can be interrupted by signals.</p>\n<p>More sophisticated signal handling involves masking signals during critical operations or using dedicated signal handling threads, but these approaches add complexity that may not be justified for educational implementations.</p>\n<p>⚠️ <strong>Pitfall: Binding to Privileged Ports</strong></p>\n<p>Port numbers below 1024 are considered <strong>privileged ports</strong> that require root permissions for binding on Unix systems. Attempting to bind to port 80 (standard HTTP) or 443 (HTTPS) will fail with permission errors unless the server runs with elevated privileges.</p>\n<p>This pitfall often surprises developers who test their server on port 8080 successfully but encounter permission errors when attempting to deploy on standard HTTP ports. The error messages vary across operating systems but typically involve &quot;Permission denied&quot; or &quot;Operation not permitted&quot; responses.</p>\n<p>The solution for educational purposes involves using <strong>unprivileged ports</strong> (above 1024) like 8080 or 3000 for development and testing. Production deployment can use port forwarding, reverse proxies, or container networking to map standard ports to unprivileged ports where the server actually listens.</p>\n<p>Advanced deployment scenarios might involve <strong>privilege dropping</strong> where the server starts with root permissions to bind privileged ports, then drops to a non-privileged user for request processing. This approach requires careful sequencing of privilege changes and resource allocation.</p>\n<p>⚠️ <strong>Pitfall: Address Already in Use Errors</strong></p>\n<p>When a server shuts down, the operating system maintains the socket in a <strong>TIME_WAIT state</strong> for several minutes to handle any delayed packets from recently closed connections. Attempting to restart the server during this period fails with &quot;Address already in use&quot; errors that prevent binding to the same port.</p>\n<p>This behavior is particularly frustrating during development when rapid restart cycles are common for testing changes. The server appears to work correctly but becomes inaccessible for several minutes after each shutdown, significantly slowing development iteration.</p>\n<p>The <code>SO_REUSEADDR</code> socket option allows immediate port reuse by instructing the operating system to bypass the TIME_WAIT restriction. This option must be set before binding the socket to be effective. Setting it after binding has no effect on the current connection.</p>\n<p>Care must be taken when using <code>SO_REUSEADDR</code> in production environments, as it can allow multiple processes to bind to the same port simultaneously in some configurations, creating unpredictable connection routing behavior.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The TCP server component provides the networking foundation that all other components build upon. Understanding the socket programming patterns demonstrated here will prove essential when implementing concurrent connection handling in later milestones.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Socket Creation</td>\n<td>Standard BSD sockets with basic error checking</td>\n<td>BSD sockets with comprehensive option tuning</td>\n</tr>\n<tr>\n<td>Address Configuration</td>\n<td>Hard-coded INADDR_ANY with configurable port</td>\n<td>Full address parsing with IPv4/IPv6 detection</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Printf logging with perror for system errors</td>\n<td>Structured logging with error code classification</td>\n</tr>\n<tr>\n<td>Resource Management</td>\n<td>Manual cleanup with explicit function calls</td>\n<td>RAII-style cleanup with automatic resource tracking</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<p>The TCP server implementation should be organized to separate socket management logic from higher-level server coordination:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n├── src/\n│   ├── main.c                    ← server entry point and main loop\n│   ├── tcp_server.c              ← TCP server component implementation\n│   ├── tcp_server.h              ← TCP server interface definitions\n│   ├── server_config.c           ← configuration management\n│   └── common.h                  ← shared constants and types\n├── include/\n│   ├── http_types.h              ← HTTP data structure definitions\n│   └── network_utils.h           ← networking utility functions\n└── tests/\n    ├── tcp_server_test.c         ← unit tests for TCP functionality\n    └── integration_test.c        ← end-to-end connection testing</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p>Here&#39;s the complete TCP server foundation that handles socket creation, binding, and basic connection management:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/socket.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;netinet/in.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;arpa/inet.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;time.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEFAULT_PORT</span><span style=\"color:#79B8FF\"> 8080</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_PATH_LENGTH</span><span style=\"color:#79B8FF\"> 1024</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_HEADERS</span><span style=\"color:#79B8FF\"> 32</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_REQUEST_SIZE</span><span style=\"color:#79B8FF\"> 8192</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CONNECTION_BACKLOG</span><span style=\"color:#79B8FF\"> 128</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complete ServerConfig structure with all fields initialized</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> port;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> document_root</span><span style=\"color:#E1E4E8\">[MAX_PATH_LENGTH];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> max_threads;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> max_connections;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> request_timeout_sec;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ServerConfig;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complete ConnectionContext for tracking client state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> client_fd;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> sockaddr_in client_addr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    time_t</span><span style=\"color:#E1E4E8\"> connect_time;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_t</span><span style=\"color:#E1E4E8\"> thread_id;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ConnectionContext;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize server configuration with safe defaults</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> init_server_config</span><span style=\"color:#E1E4E8\">(ServerConfig</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(config, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(ServerConfig));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config->port </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> DEFAULT_PORT;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    strncpy</span><span style=\"color:#E1E4E8\">(config->document_root, </span><span style=\"color:#9ECBFF\">\"./public\"</span><span style=\"color:#E1E4E8\">, MAX_PATH_LENGTH </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config->max_threads </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 50</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config->max_connections </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config->request_timeout_sec </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 30</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize connection context with client information</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> init_connection_context</span><span style=\"color:#E1E4E8\">(ConnectionContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> client_fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> sockaddr_in </span><span style=\"color:#FFAB70\">addr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(context, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(ConnectionContext));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context->client_fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> client_fd;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context->client_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> addr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context->connect_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context->thread_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Will be set when assigned to thread</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complete socket creation and configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> create_server_socket</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> port</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> server_fd;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> sockaddr_in server_addr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> reuse_opt </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create TCP socket</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server_fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> socket</span><span style=\"color:#E1E4E8\">(AF_INET, SOCK_STREAM, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (server_fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to create server socket\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set SO_REUSEADDR to allow rapid server restart</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">setsockopt</span><span style=\"color:#E1E4E8\">(server_fd, SOL_SOCKET, SO_REUSEADDR, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">reuse_opt, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(reuse_opt)) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to set SO_REUSEADDR\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(server_fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Configure server address structure</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">server_addr, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(server_addr));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server_addr.sin_family </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> AF_INET;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server_addr.sin_addr.s_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> INADDR_ANY;</span><span style=\"color:#6A737D\">  // Accept on all interfaces</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server_addr.sin_port </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> htons</span><span style=\"color:#E1E4E8\">(port);</span><span style=\"color:#6A737D\">        // Convert to network byte order</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Bind socket to address</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">bind</span><span style=\"color:#E1E4E8\">(server_fd, (</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> sockaddr</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">server_addr, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(server_addr)) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to bind server socket\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(server_fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Begin listening for connections</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">listen</span><span style=\"color:#E1E4E8\">(server_fd, CONNECTION_BACKLOG) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to listen on server socket\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(server_fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Server listening on port </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, port);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> server_fd;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Accept single client connection with full error handling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> accept_client_connection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> server_fd</span><span style=\"color:#E1E4E8\">, ConnectionContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> context</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> sockaddr_in client_addr;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    socklen_t</span><span style=\"color:#E1E4E8\"> addr_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(client_addr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> client_fd;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Accept incoming connection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    client_fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> accept</span><span style=\"color:#E1E4E8\">(server_fd, (</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> sockaddr</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">client_addr, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">addr_len);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (client_fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> EINTR) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Signal interruption - retry accept</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Indicate retry needed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to accept client connection\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize connection context</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    init_connection_context</span><span style=\"color:#E1E4E8\">(context, client_fd, client_addr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Log client connection for debugging</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Accepted connection from </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (fd=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">           inet_ntoa</span><span style=\"color:#E1E4E8\">(client_addr.sin_addr),</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">           ntohs</span><span style=\"color:#E1E4E8\">(client_addr.sin_port),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           client_fd);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> client_fd;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Properly close client connection and cleanup resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> close_client_connection</span><span style=\"color:#E1E4E8\">(ConnectionContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> context</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (context->client_fd </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Closing connection fd=</span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, context->client_fd);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(context->client_fd);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        context->client_fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p>The main server loop represents the core logic that students should implement themselves. This skeleton provides the structure while requiring students to understand the connection handling flow:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Main server loop - students implement the connection handling logic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> server_main_loop</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> server_fd</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ConnectionContext context;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> request_buffer</span><span style=\"color:#E1E4E8\">[MAX_REQUEST_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Server entering main loop, waiting for connections...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span><span style=\"color:#6A737D\">  // Infinite loop until shutdown signal</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Accept incoming client connection using accept_client_connection()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Handle EINTR return by continuing the loop</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Log connection details for debugging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Read complete HTTP request from client socket</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use read_complete_request() to handle partial reads</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Check for read errors and connection closure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Send hardcoded HTTP response for Milestone 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Start with \"HTTP/1.1 200 OK\\r\\nContent-Length: 13\\r\\n\\r\\nHello World!\\n\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use write() or send() to transmit response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Clean up connection resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Always close client file descriptor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Log connection closure for debugging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Check for server shutdown signals</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Can use global variable set by signal handler</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Break from loop to allow graceful shutdown</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Server main loop exiting</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complete request reading handling partial reads - students implement the read loop</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#B392F0\"> read_complete_request</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> sockfd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char*</span><span style=\"color:#FFAB70\"> buffer</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> max_size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize read tracking variables</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Track total bytes read and current buffer position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Read data in loop until complete request received</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: HTTP request ends with \\r\\n\\r\\n (empty line after headers)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Handle partial reads by continuing to read more data</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Handle read errors and connection closure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: read() returns 0 when client closes connection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: read() returns -1 on errors, check errno for details</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Validate request doesn't exceed buffer size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Prevent buffer overflow by checking max_size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Return error if request too large for buffer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Null-terminate buffer and return total bytes read</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Ensure buffer is valid C string for parsing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Return total bytes read on success, -1 on error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Students replace with actual implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Main function with server initialization and cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char*</span><span style=\"color:#FFAB70\"> argv</span><span style=\"color:#F97583\">[]</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ServerConfig config;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> server_fd;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize server configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use init_server_config() and handle command-line port override</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create and configure server socket</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use create_server_socket() and check for errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Enter main connection handling loop</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use server_main_loop() - this runs until shutdown</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Cleanup server resources on shutdown</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Close server file descriptor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Log clean shutdown for debugging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<p>C socket programming requires attention to several platform-specific details and common conventions:</p>\n<ul>\n<li><p><strong>Include Headers</strong>: Use <code>#include &lt;sys/socket.h&gt;</code>, <code>#include &lt;netinet/in.h&gt;</code>, and <code>#include &lt;arpa/inet.h&gt;</code> for socket functions. These headers are standard on Unix-like systems but may require additional setup on Windows.</p>\n</li>\n<li><p><strong>Error Checking</strong>: Always check return values from socket functions. Use <code>perror()</code> to print meaningful error messages that include the system&#39;s description of what went wrong. Socket functions typically return -1 on error and set <code>errno</code> to indicate the specific problem.</p>\n</li>\n<li><p><strong>Byte Order</strong>: Use <code>htons()</code> for port numbers and <code>htonl()</code> for IP addresses when populating socket address structures. These functions convert from host byte order to network byte order automatically, handling platform differences transparently.</p>\n</li>\n<li><p><strong>Address Structures</strong>: Initialize <code>sockaddr_in</code> structures with <code>memset()</code> before setting individual fields. This ensures that padding bytes are zeroed, preventing subtle bugs from uninitialized memory affecting socket operations.</p>\n</li>\n<li><p><strong>File Descriptor Management</strong>: Treat file descriptors as precious resources that must be explicitly managed. Use consistent patterns for checking validity (fd &gt; 0), closing resources (always check close() return value), and setting invalid markers (fd = -1 after close).</p>\n</li>\n<li><p><strong>Signal Safety</strong>: Be aware that signal delivery can interrupt socket system calls. Production code often blocks signals during critical operations or handles <code>EINTR</code> returns consistently across all blocking calls.</p>\n</li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the TCP server component, verify correct operation through systematic testing:</p>\n<p><strong>Basic Functionality Test</strong>: Start your server and verify it accepts connections properly:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Terminal 1: Start your server</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./http_server</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Terminal 2: Connect with telnet to verify TCP connection works</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">telnet</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># You should see \"Connected to localhost\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Type anything and press Enter - server should respond with hardcoded HTTP response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Connection should close automatically after response</span></span></code></pre></div>\n\n<p><strong>Expected Output</strong>: The server should print connection acceptance messages including client IP address and file descriptor numbers. The telnet client should receive your hardcoded HTTP response and the connection should close cleanly.</p>\n<p><strong>Multiple Connection Test</strong>: Verify the server accepts multiple sequential connections:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run several telnet connections in succession</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..5}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  echo</span><span style=\"color:#9ECBFF\"> \"Test request </span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> telnet</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span></code></pre></div>\n\n<p><strong>Expected Behavior</strong>: Each connection should be accepted, receive a response, and close properly. File descriptor numbers should increment for each connection. No &quot;Address already in use&quot; errors should occur.</p>\n<p><strong>Error Condition Testing</strong>: Verify proper error handling by testing edge cases:</p>\n<ul>\n<li>Start server on port already in use (should fail gracefully with clear error message)</li>\n<li>Connect with telnet but send no data (should timeout appropriately)</li>\n<li>Kill server with Ctrl+C and restart immediately (should work due to SO_REUSEADDR)</li>\n</ul>\n<p><strong>Signs of Problems</strong>: </p>\n<ul>\n<li>&quot;Address already in use&quot; errors on restart indicate missing <code>SO_REUSEADDR</code> configuration</li>\n<li>Connections timing out indicate problems with the accept loop or response sending</li>\n<li>Increasing file descriptor numbers without corresponding closes indicate file descriptor leaks</li>\n<li>Server crashes or hangs indicate unhandled error conditions in the main loop</li>\n</ul>\n<p><strong>Debugging Steps</strong>: If tests fail, check these common issues:</p>\n<ol>\n<li>Verify socket creation returns valid file descriptor (not -1)</li>\n<li>Confirm <code>htons()</code> is used for port number conversion</li>\n<li>Check that server socket is properly closed on shutdown</li>\n<li>Verify client file descriptors are closed after each connection</li>\n<li>Confirm error checking covers all system calls with appropriate perror() messages</li>\n</ol>\n<h2 id=\"http-parser-component\">HTTP Parser Component</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 2 (HTTP Request Parsing) - transforms raw TCP data into structured HTTP message representations that enable proper request processing and response generation</p>\n</blockquote>\n<h3 id=\"http-parsing-mental-model-mail-sorting-analogy\">HTTP Parsing Mental Model: Mail Sorting Analogy</h3>\n<p>Think of HTTP parsing like working at a post office mail sorting facility. When mail trucks arrive at the facility, they dump large bags of unsorted mail onto conveyor belts. Your job as a mail sorter is to examine each piece of mail, read the addresses, validate the format, and sort everything into the correct bins for delivery.</p>\n<p>HTTP parsing works exactly the same way. The TCP server component delivers raw bytes from the network - like those unsorted mail bags. The HTTP parser acts as the mail sorter, examining the incoming byte stream character by character. Just as mail has a specific format (recipient address, return address, postal codes in specific positions), HTTP messages follow the RFC 7230 specification with request lines, headers, and optional message bodies in precise positions.</p>\n<p>A mail sorter must handle various challenges: damaged envelopes (malformed requests), missing addresses (invalid HTTP syntax), packages too large for standard processing (requests exceeding size limits), and different mail formats from various countries (different line ending conventions). Similarly, the HTTP parser must gracefully handle malformed input, missing required fields, oversized requests, and protocol variations while maintaining strict adherence to standards.</p>\n<p>The sorting process is methodical and stateful. A mail sorter doesn&#39;t randomly grab pieces - they process items in order, moving through distinct phases: examining the envelope format, reading the destination address, checking for proper postage, then routing to the appropriate bin. HTTP parsing follows the same methodical approach: first parsing the request line (method, path, version), then processing headers one by one, and finally handling any message body content.</p>\n<p>Just as a mail facility has quality control processes to catch problems early and prevent delivery errors, HTTP parsers implement strict validation at each step. A single malformed address doesn&#39;t shut down the entire facility - it gets flagged for special handling. Similarly, one bad HTTP request shouldn&#39;t crash the server; it should generate an appropriate error response and continue processing other requests.</p>\n<h3 id=\"parser-interface\">Parser Interface</h3>\n<p>The HTTP parser component exposes a clean, focused API that transforms raw network data into structured <code>HTTPRequest</code> objects. The interface design prioritizes safety, clarity, and error handling while maintaining the stateless nature that enables concurrent request processing.</p>\n<p>The parser operates through a primary parsing function that accepts raw request data and produces either a valid <code>HTTPRequest</code> structure or a specific error condition. This design choice eliminates the complexity of streaming parsers while providing sufficient functionality for the educational goals of this project.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>parse_http_request</code></td>\n<td><code>const char* raw_data</code>, <code>size_t data_length</code>, <code>HTTPRequest* request</code></td>\n<td><code>int</code> (status code)</td>\n<td>Parses complete HTTP request from raw bytes into structured request object</td>\n</tr>\n<tr>\n<td><code>parse_request_line</code></td>\n<td><code>const char* line</code>, <code>HTTPRequest* request</code></td>\n<td><code>int</code> (status code)</td>\n<td>Extracts method, path, and version from HTTP request line</td>\n</tr>\n<tr>\n<td><code>parse_header_line</code></td>\n<td><code>const char* line</code>, <code>HTTPRequest* request</code></td>\n<td><code>int</code> (status code)</td>\n<td>Parses single header line and adds to request header collection</td>\n</tr>\n<tr>\n<td><code>parse_message_body</code></td>\n<td><code>const char* body_start</code>, <code>size_t content_length</code>, <code>HTTPRequest* request</code></td>\n<td><code>int</code> (status code)</td>\n<td>Processes message body content based on Content-Length header</td>\n</tr>\n<tr>\n<td><code>validate_request_format</code></td>\n<td><code>const HTTPRequest* request</code></td>\n<td><code>int</code> (status code)</td>\n<td>Validates parsed request meets HTTP/1.1 requirements</td>\n</tr>\n<tr>\n<td><code>find_header_value</code></td>\n<td><code>const HTTPRequest* request</code>, <code>const char* header_name</code></td>\n<td><code>const char*</code></td>\n<td>Retrieves header value by name (case-insensitive search)</td>\n</tr>\n</tbody></table>\n<p>The parser interface follows a consistent error handling pattern where return values indicate parsing status. Success returns zero, while positive integers represent specific HTTP error conditions that should be returned to the client (400 Bad Request, 414 URI Too Long, etc.). This approach enables the calling code to automatically generate appropriate HTTP error responses without complex error message parsing.</p>\n<p><strong>Parser State and Memory Management</strong></p>\n<p>The parser maintains no internal state between calls, making it inherently thread-safe and suitable for concurrent request processing. Each invocation operates on caller-provided buffers and data structures, eliminating hidden dependencies and resource cleanup complexity.</p>\n<p>Memory management follows a clear ownership model. The caller provides the destination <code>HTTPRequest</code> structure and retains ownership of all memory. The parser populates fields within the provided structure but does not allocate dynamic memory for basic request processing. For requests with message bodies, the parser sets pointer fields to reference existing buffer locations rather than creating copies.</p>\n<table>\n<thead>\n<tr>\n<th>Memory Responsibility</th>\n<th>Parser Role</th>\n<th>Caller Role</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Input buffer management</td>\n<td>Read-only access to raw request data</td>\n<td>Allocate sufficient buffer, ensure null termination</td>\n</tr>\n<tr>\n<td>HTTPRequest structure</td>\n<td>Populate fields within provided structure</td>\n<td>Allocate structure, call cleanup when finished</td>\n</tr>\n<tr>\n<td>Header storage</td>\n<td>Copy header names and values to fixed arrays</td>\n<td>Provide MAX_HEADERS array space in structure</td>\n</tr>\n<tr>\n<td>Message body handling</td>\n<td>Set pointer to body location in input buffer</td>\n<td>Ensure buffer remains valid during request processing</td>\n</tr>\n<tr>\n<td>String null termination</td>\n<td>Ensure all string fields are properly terminated</td>\n<td>Validate string lengths before use</td>\n</tr>\n</tbody></table>\n<p><strong>Content-Length and Body Processing</strong></p>\n<p>The parser implements careful Content-Length processing to handle requests with message bodies safely. When a Content-Length header is present, the parser validates that sufficient data exists in the input buffer before setting the body pointer. This prevents buffer overruns while enabling efficient zero-copy body access.</p>\n<p>For requests without Content-Length headers, the parser assumes no message body exists, which is appropriate for GET requests and compliant with HTTP/1.1 specifications. The parser does not attempt to implement Transfer-Encoding chunked processing, as this falls outside the scope of a basic static file server.</p>\n<h3 id=\"http-parsing-algorithm-state-machine-for-processing-http-message-format\">HTTP Parsing Algorithm: State Machine for Processing HTTP Message Format</h3>\n<p>The HTTP parser operates as a finite state machine that processes the incoming request character by character, transitioning through distinct states based on the HTTP message format. This approach provides precise control over parsing while enabling clear error detection and recovery.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fhttp-parser-state-machine.svg\" alt=\"HTTP Parser State Machine\"></p>\n<p>The state machine recognizes that HTTP messages have a rigid structure defined by RFC 7230: a request line, zero or more header lines, a blank line separator, and an optional message body. Each component has specific format requirements that must be validated during parsing.</p>\n<p><strong>State Machine Implementation</strong></p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Input Event</th>\n<th>Next State</th>\n<th>Action Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PARSER_START</td>\n<td>Any character</td>\n<td>READING_REQUEST_LINE</td>\n<td>Begin accumulating request line characters</td>\n</tr>\n<tr>\n<td>READING_REQUEST_LINE</td>\n<td>Printable character</td>\n<td>READING_REQUEST_LINE</td>\n<td>Append character to request line buffer</td>\n</tr>\n<tr>\n<td>READING_REQUEST_LINE</td>\n<td>CRLF or LF</td>\n<td>PARSING_REQUEST_LINE</td>\n<td>Process complete request line, extract method/path/version</td>\n</tr>\n<tr>\n<td>PARSING_REQUEST_LINE</td>\n<td>Processing success</td>\n<td>READING_HEADERS</td>\n<td>Prepare to process header lines</td>\n</tr>\n<tr>\n<td>PARSING_REQUEST_LINE</td>\n<td>Processing failure</td>\n<td>PARSER_ERROR</td>\n<td>Set error code for malformed request line</td>\n</tr>\n<tr>\n<td>READING_HEADERS</td>\n<td>Printable character</td>\n<td>READING_HEADER_LINE</td>\n<td>Begin accumulating current header line</td>\n</tr>\n<tr>\n<td>READING_HEADER_LINE</td>\n<td>Printable character</td>\n<td>READING_HEADER_LINE</td>\n<td>Append character to header line buffer</td>\n</tr>\n<tr>\n<td>READING_HEADER_LINE</td>\n<td>CRLF or LF</td>\n<td>PARSING_HEADER_LINE</td>\n<td>Process complete header line</td>\n</tr>\n<tr>\n<td>PARSING_HEADER_LINE</td>\n<td>Valid header format</td>\n<td>READING_HEADERS</td>\n<td>Add header to request, continue header processing</td>\n</tr>\n<tr>\n<td>PARSING_HEADER_LINE</td>\n<td>Invalid header format</td>\n<td>PARSER_ERROR</td>\n<td>Set error code for malformed header</td>\n</tr>\n<tr>\n<td>READING_HEADERS</td>\n<td>CRLF or LF (empty line)</td>\n<td>CHECKING_BODY</td>\n<td>Headers complete, determine if body expected</td>\n</tr>\n<tr>\n<td>CHECKING_BODY</td>\n<td>Content-Length &gt; 0</td>\n<td>READING_BODY</td>\n<td>Prepare to read specified number of body bytes</td>\n</tr>\n<tr>\n<td>CHECKING_BODY</td>\n<td>No Content-Length</td>\n<td>PARSER_COMPLETE</td>\n<td>Request parsing complete (no body)</td>\n</tr>\n<tr>\n<td>READING_BODY</td>\n<td>Sufficient bytes available</td>\n<td>PARSER_COMPLETE</td>\n<td>Set body pointer, parsing complete</td>\n</tr>\n<tr>\n<td>READING_BODY</td>\n<td>Insufficient bytes</td>\n<td>PARSER_ERROR</td>\n<td>Set error code for incomplete body</td>\n</tr>\n</tbody></table>\n<p><strong>Parsing Algorithm Implementation</strong></p>\n<p>The concrete parsing algorithm follows these numbered steps to process HTTP requests systematically:</p>\n<ol>\n<li><p><strong>Initialize parser state</strong> by setting the state machine to PARSER_START and clearing all temporary buffers. Validate that the input buffer contains at least a minimal HTTP request (method + space + path + space + version + CRLF).</p>\n</li>\n<li><p><strong>Locate request line boundary</strong> by scanning from the beginning of the input buffer to find the first CRLF or LF sequence. This marks the end of the request line and enables safe string processing of the line content.</p>\n</li>\n<li><p><strong>Extract method field</strong> by finding the first space character in the request line. Copy all characters from the line start to the space into the request method field, ensuring null termination and length validation against the method buffer size.</p>\n</li>\n<li><p><strong>Extract path field</strong> by finding the second space character in the request line. Copy characters between the first and second spaces into the request path field, performing length validation and URL decoding if necessary.</p>\n</li>\n<li><p><strong>Extract version field</strong> by copying remaining characters from the second space to the line end into the request version field. Validate that the version matches expected formats like &quot;HTTP/1.1&quot; or &quot;HTTP/1.0&quot;.</p>\n</li>\n<li><p><strong>Process header lines sequentially</strong> by advancing past the request line and examining each subsequent line until encountering an empty line (CRLF CRLF or LF LF). For each header line, locate the colon separator and extract header name and value.</p>\n</li>\n<li><p><strong>Validate header format</strong> by ensuring each header line contains exactly one colon character, has a non-empty header name, and follows HTTP header naming conventions. Trim whitespace from header values while preserving significant spaces.</p>\n</li>\n<li><p><strong>Store headers in request structure</strong> by copying header names and values into the request headers array. Implement bounds checking to prevent buffer overflow when the number of headers exceeds MAX_HEADERS.</p>\n</li>\n<li><p><strong>Determine message body presence</strong> by examining the Content-Length header value. If Content-Length exists and is greater than zero, prepare to read the specified number of bytes as the message body.</p>\n</li>\n<li><p><strong>Process message body data</strong> by setting the body pointer to reference the appropriate location in the input buffer and updating the body_length field. Validate that sufficient bytes remain in the buffer to satisfy the Content-Length requirement.</p>\n</li>\n</ol>\n<p><strong>Error Detection and Recovery</strong></p>\n<p>The parsing algorithm implements comprehensive error detection at each stage to catch malformed requests early and provide meaningful error responses. Rather than failing silently or crashing, the parser generates specific HTTP error codes that can be returned to the client.</p>\n<table>\n<thead>\n<tr>\n<th>Error Condition</th>\n<th>Detection Method</th>\n<th>HTTP Status Code</th>\n<th>Recovery Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Missing request line</td>\n<td>No CRLF found in first 8192 bytes</td>\n<td>400 Bad Request</td>\n<td>Reject request, close connection</td>\n</tr>\n<tr>\n<td>Invalid method</td>\n<td>Method not in allowed set or contains invalid characters</td>\n<td>405 Method Not Allowed</td>\n<td>Return error response</td>\n</tr>\n<tr>\n<td>Malformed URL path</td>\n<td>Path contains null bytes or exceeds maximum length</td>\n<td>400 Bad Request</td>\n<td>Return error response</td>\n</tr>\n<tr>\n<td>Unsupported HTTP version</td>\n<td>Version not &quot;HTTP/1.0&quot; or &quot;HTTP/1.1&quot;</td>\n<td>505 HTTP Version Not Supported</td>\n<td>Return error response</td>\n</tr>\n<tr>\n<td>Missing header colon</td>\n<td>Header line does not contain colon separator</td>\n<td>400 Bad Request</td>\n<td>Return error response</td>\n</tr>\n<tr>\n<td>Too many headers</td>\n<td>Header count exceeds MAX_HEADERS</td>\n<td>431 Request Header Fields Too Large</td>\n<td>Return error response</td>\n</tr>\n<tr>\n<td>Invalid Content-Length</td>\n<td>Content-Length not a valid positive integer</td>\n<td>400 Bad Request</td>\n<td>Return error response</td>\n</tr>\n<tr>\n<td>Incomplete message body</td>\n<td>Available data less than Content-Length</td>\n<td>400 Bad Request</td>\n<td>Return error response</td>\n</tr>\n</tbody></table>\n<h3 id=\"architecture-decision-records\">Architecture Decision Records</h3>\n<p><strong>Decision: Synchronous Single-Pass Parsing</strong></p>\n<ul>\n<li><strong>Context</strong>: HTTP parsing can be implemented using streaming parsers that process data incrementally, or single-pass parsers that require complete request data. Streaming parsers handle partial data arrival but add state management complexity.</li>\n<li><strong>Options Considered</strong>: <ul>\n<li>Streaming parser with internal state buffers</li>\n<li>Single-pass parser requiring complete request data</li>\n<li>Hybrid approach with optional streaming support</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Implement single-pass parser requiring complete request data</li>\n<li><strong>Rationale</strong>: The TCP server component already handles partial reads and assembles complete requests before calling the parser. Single-pass parsing eliminates state management complexity, improves testability, and provides better performance for small-to-medium requests typical in educational scenarios.</li>\n<li><strong>Consequences</strong>: Simpler implementation and testing, but requires complete request buffering. Maximum request size becomes a hard limit rather than a soft constraint.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Streaming parser</td>\n<td>Handles very large requests, lower memory usage</td>\n<td>Complex state management, harder to test</td>\n</tr>\n<tr>\n<td>Single-pass parser</td>\n<td>Simple implementation, stateless, fast for small requests</td>\n<td>Requires complete buffering, memory usage scales with request size</td>\n</tr>\n<tr>\n<td>Hybrid approach</td>\n<td>Flexibility for different use cases</td>\n<td>Implementation complexity, unclear API boundaries</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Design Insight</strong>: Educational HTTP servers benefit more from implementation clarity than handling edge cases like extremely large uploads that rarely occur in static file serving scenarios.</p>\n</blockquote>\n<p><strong>Decision: Fixed-Size Header Storage</strong></p>\n<ul>\n<li><strong>Context</strong>: HTTP headers can be stored in dynamically allocated structures that grow as needed, or in fixed-size arrays with compile-time limits. Dynamic allocation provides unlimited scalability but complicates memory management.</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Dynamic header allocation with linked lists or resizable arrays</li>\n<li>Fixed-size header arrays with MAX_HEADERS limit</li>\n<li>Hybrid with small fixed buffer and dynamic overflow</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Use fixed-size header arrays with MAX_HEADERS set to 32</li>\n<li><strong>Rationale</strong>: Static file servers typically receive simple requests with 5-10 headers. A limit of 32 headers provides generous headroom while avoiding dynamic memory management complexity. Fixed-size allocation enables stack-based request structures and eliminates memory leaks.</li>\n<li><strong>Consequences</strong>: Memory usage is predictable and bounded, implementation remains simple, but requests with excessive headers will be rejected. This aligns with defensive programming practices for server security.</li>\n</ul>\n<p><strong>Decision: Case-Insensitive Header Matching</strong></p>\n<ul>\n<li><strong>Context</strong>: HTTP header names are case-insensitive per RFC 7230, but header values are case-sensitive. The parser must decide how to store and match header names while preserving original case for debugging.</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Store headers in original case, implement case-insensitive matching functions</li>\n<li>Normalize all header names to lowercase during parsing</li>\n<li>Store both original and normalized versions</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Store headers in original case with case-insensitive matching functions</li>\n<li><strong>Rationale</strong>: Preserving original case aids debugging and maintains fidelity to the original request. Case-insensitive matching functions are straightforward to implement and perform adequately for the small number of headers in typical requests.</li>\n<li><strong>Consequences</strong>: Header storage uses original case which helps with debugging, but header lookup requires case-insensitive string comparison. Performance impact is negligible for educational use cases.</li>\n</ul>\n<p><strong>Decision: Strict HTTP/1.1 Compliance</strong></p>\n<ul>\n<li><strong>Context</strong>: HTTP parsing can be lenient (accepting common deviations from standards) or strict (rejecting any non-compliant input). Lenient parsing improves compatibility but may accept invalid requests.</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Lenient parsing that accepts common browser variations</li>\n<li>Strict parsing that follows RFC 7230 exactly</li>\n<li>Configurable strictness level</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Implement strict parsing that follows RFC 7230 requirements</li>\n<li><strong>Rationale</strong>: Educational servers should demonstrate proper protocol implementation. Strict parsing helps students understand HTTP requirements and catches implementation errors in client code. Production servers can be more lenient, but learning servers should prioritize correctness.</li>\n<li><strong>Consequences</strong>: Some non-compliant clients may be rejected, but this reinforces proper HTTP protocol understanding. Error messages help developers identify and fix client implementation issues.</li>\n</ul>\n<h3 id=\"common-http-parsing-pitfalls\">Common HTTP Parsing Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Line Ending Confusion</strong>\nHTTP/1.1 specifies CRLF (\\r\\n) as the line terminator, but many clients send LF (\\n) only, especially during development testing. Parsers that only recognize CRLF will fail to parse requests from curl, telnet, or custom test clients. The parser must accept both CRLF and LF line endings while maintaining strict protocol compliance for production use. Implement line ending detection by checking for \\r\\n first, then falling back to \\n if not found. This approach maintains compatibility without compromising standards compliance.</p>\n<p>⚠️ <strong>Pitfall: Header Value Whitespace Handling</strong>\nRFC 7230 permits optional whitespace around header values (e.g., &quot;Content-Length: 1234&quot; vs &quot;Content-Length:1234&quot;), but naive parsing may include leading/trailing spaces in header values. This causes string comparison failures when looking for specific header values or parsing numeric headers like Content-Length. Always trim leading and trailing whitespace from header values during parsing, but preserve internal whitespace which may be significant. Use a trimming function that removes spaces and tabs but stops at other whitespace characters.</p>\n<p>⚠️ <strong>Pitfall: Buffer Overflow on Long Request Lines</strong>\nHTTP requests can contain extremely long URLs or header values that exceed fixed buffer sizes. Parsing without length checking can cause buffer overflows, memory corruption, and security vulnerabilities. Each parsing step must validate input length against available buffer space before copying data. Implement bounds checking by tracking remaining buffer space and comparing against input length before each copy operation. Return HTTP 414 URI Too Long or HTTP 431 Request Header Fields Too Large for oversized components.</p>\n<p>⚠️ <strong>Pitfall: Incomplete Content-Length Processing</strong>\nWhen Content-Length header is present, the parser must verify that sufficient data exists in the input buffer before setting the body pointer. Failure to validate available data length can cause the body pointer to reference memory beyond the buffer end, leading to crashes when the file handler attempts to read body content. Always compare Content-Length value against remaining buffer length after header parsing completes. Return HTTP 400 Bad Request if insufficient body data is available.</p>\n<p>⚠️ <strong>Pitfall: Method Case Sensitivity Issues</strong>\nHTTP methods like GET, POST, PUT are case-sensitive per RFC 7230, but some parsers incorrectly accept lowercase variants like &quot;get&quot; or &quot;post&quot;. This creates compatibility issues with strict servers and reinforces incorrect HTTP understanding. Validate that method names match exact case requirements and reject requests with incorrect casing. Provide clear error messages that specify the expected case format to help developers correct client implementations.</p>\n<p>⚠️ <strong>Pitfall: Missing Null Termination</strong>\nWhen copying strings from the input buffer into request structure fields, failure to null-terminate the copied strings can cause string functions to read beyond buffer boundaries. This occurs frequently when using functions like <code>strncpy</code> that don&#39;t guarantee null termination. Always ensure copied strings are null-terminated by either using <code>snprintf</code> for copying or manually adding null terminators after <code>strncpy</code>. Reserve one byte in each string field for the null terminator.</p>\n<p>⚠️ <strong>Pitfall: Header Name Duplicate Handling</strong>\nHTTP allows multiple headers with the same name (like multiple Cookie headers), but simple parsers may overwrite earlier values when encountering duplicates. This loses important request information and can break applications that depend on multiple header values. Implement duplicate header handling by either concatenating values with comma separation (per RFC 7230) or storing only the first occurrence with a warning. Document the chosen behavior clearly for API users.</p>\n<p>⚠️ <strong>Pitfall: Integer Overflow in Content-Length</strong>\nContent-Length header values are parsed as integers, but extremely large values can cause integer overflow in languages with fixed-size integer types. This can result in negative content lengths or wrap-around to small positive values, bypassing security checks. Validate Content-Length values against reasonable maximum sizes before parsing to integer form. Use appropriate integer types that can handle expected maximum request sizes, and reject requests with Content-Length values exceeding implementation limits.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>A. Technology Recommendations Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>String Processing</td>\n<td>Standard C string functions (strchr, strncpy, strcmp)</td>\n<td>Custom parsing with explicit bounds checking</td>\n</tr>\n<tr>\n<td>Memory Management</td>\n<td>Stack-allocated request structures</td>\n<td>Memory pools for zero-allocation parsing</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Integer return codes with predefined constants</td>\n<td>Structured error types with detailed context</td>\n</tr>\n<tr>\n<td>Header Storage</td>\n<td>Fixed arrays with linear search</td>\n<td>Hash tables for O(1) header lookup</td>\n</tr>\n<tr>\n<td>Line Ending Detection</td>\n<td>Check for both \\r\\n and \\n patterns</td>\n<td>Configurable line ending modes</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  src/\n    http_parser.h              ← parser interface declarations\n    http_parser.c              ← main parsing implementation\n    http_parser_internal.h     ← internal parsing state definitions\n    http_utils.c               ← string utilities and helper functions\n  test/\n    test_http_parser.c         ← comprehensive parser test suite\n    test_requests/             ← sample HTTP request files\n      valid_get_request.txt\n      malformed_header.txt\n      missing_version.txt\n  include/\n    http_types.h               ← HTTPRequest and HTTPResponse definitions</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code (COMPLETE, ready to use):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// http_utils.c - String processing utilities for HTTP parsing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;ctype.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Trims leading and trailing whitespace from a string in-place</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char*</span><span style=\"color:#B392F0\"> trim_whitespace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">char*</span><span style=\"color:#FFAB70\"> str</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> end;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Trim leading space</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">isspace</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> char</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">str)) str</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">str </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> str;</span><span style=\"color:#6A737D\">  // All spaces?</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Trim trailing space</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> str </span><span style=\"color:#F97583\">+</span><span style=\"color:#B392F0\"> strlen</span><span style=\"color:#E1E4E8\">(str) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\">(end </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> str </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#B392F0\"> isspace</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> char</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">end)) end</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write new null terminator</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    end</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> str;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Case-insensitive string comparison for header names</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> strcasecmp_http</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> s1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> s2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">s1 </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">s2) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#E1E4E8\"> c1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> tolower</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> char</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">s1);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#E1E4E8\"> c2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> tolower</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> char</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">s2);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (c1 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> c2) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> c1 </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> c2;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        s1</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        s2</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> tolower</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> char</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">s1) </span><span style=\"color:#F97583\">-</span><span style=\"color:#B392F0\"> tolower</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> char</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">s2);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Find line ending (CRLF or LF) and return pointer to start of next line</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#B392F0\"> find_line_end</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> start</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> buffer_end</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t*</span><span style=\"color:#FFAB70\"> line_length</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (pos </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> buffer_end) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pos </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> pos </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> &#x3C;</span><span style=\"color:#E1E4E8\"> buffer_end </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">(pos </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Found CRLF</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            *</span><span style=\"color:#E1E4E8\">line_length </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pos </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> pos </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Skip past CRLF</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pos </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Found LF only</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            *</span><span style=\"color:#E1E4E8\">line_length </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pos </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> pos </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Skip past LF</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pos</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // No line ending found</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Safely copy string with bounds checking and null termination</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> safe_string_copy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">char*</span><span style=\"color:#FFAB70\"> dest</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> dest_size</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> src</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> src_length</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (src_length </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> dest_size) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Source too large for destination</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    strncpy</span><span style=\"color:#E1E4E8\">(dest, src, src_length);</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    dest</span><span style=\"color:#E1E4E8\">[src_length] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code (signature + TODOs only):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// http_parser.c - Main HTTP request parsing implementation</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"http_parser.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"http_utils.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parses complete HTTP request from raw bytes into structured request object</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns 0 on success, HTTP error code on failure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> parse_http_request</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> raw_data</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> data_length</span><span style=\"color:#E1E4E8\">, HTTPRequest</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize request structure with safe defaults using init_http_request()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate input parameters (non-null pointers, reasonable data_length)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Find request line boundary using find_line_end() helper</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Parse request line (method, path, version) using parse_request_line()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Parse headers line by line until empty line found</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Check for Content-Length header and process body if present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Validate complete request format using validate_request_format()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Track current position in buffer to avoid re-parsing same data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Return specific HTTP error codes (400, 414, etc.) for different failures</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Extracts method, path, and version from HTTP request line</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Example input: \"GET /index.html HTTP/1.1\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> parse_request_line</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">, HTTPRequest</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Find first space to separate method from path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Copy method to request->method with bounds checking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Find second space to separate path from version</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Copy path to request->path with bounds checking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Copy version to request->version with bounds checking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Validate method is non-empty and contains valid characters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Validate path starts with '/' and doesn't contain null bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Validate version matches \"HTTP/1.0\" or \"HTTP/1.1\" format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use safe_string_copy() helper to prevent buffer overflows</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Return 400 for malformed request line, 405 for invalid method</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parses single header line and adds to request header collection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Example input: \"Content-Length: 1234\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> parse_header_line</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">, HTTPRequest</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Find colon separator between header name and value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate header name is non-empty and contains valid characters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Extract header name (everything before colon)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Extract header value (everything after colon)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Trim whitespace from header value using trim_whitespace()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Check if header_count exceeds MAX_HEADERS limit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Store header name and value in request->headers array</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Increment request->header_count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Header names are case-insensitive but preserve original case</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Return 431 if too many headers, 400 for malformed header format</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Processes message body content based on Content-Length header</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> parse_message_body</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> body_start</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> available_bytes</span><span style=\"color:#E1E4E8\">, HTTPRequest</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up Content-Length header using get_request_header()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Parse Content-Length value to integer (handle parsing errors)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate Content-Length is non-negative and reasonable size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check if available_bytes >= content_length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Set request->body pointer to body_start location</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Set request->body_length to parsed content_length value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Content-Length of 0 is valid (empty body)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Return 400 for invalid Content-Length, 413 if body too large</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Retrieves header value by name (case-insensitive search)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#B392F0\"> get_request_header</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> HTTPRequest</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> request</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> header_name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Iterate through request->headers array up to header_count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Compare each header name using strcasecmp_http() for case-insensitivity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return pointer to header value when match found</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return NULL if header not found</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use strcasecmp_http() helper for proper case-insensitive comparison</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints:</strong></p>\n<ul>\n<li><p><strong>String Safety</strong>: Use <code>strncpy()</code> instead of <code>strcpy()</code> to prevent buffer overflows, but remember that <code>strncpy()</code> doesn&#39;t guarantee null termination. Always manually add null terminators or use <code>snprintf()</code> for safer string copying.</p>\n</li>\n<li><p><strong>Memory Layout</strong>: The <code>HTTPRequest</code> structure uses fixed-size arrays to avoid dynamic allocation. This means stack allocation is safe and cleanup is automatic, but you must respect buffer boundaries.</p>\n</li>\n<li><p><strong>Header Processing</strong>: HTTP header names are case-insensitive, so &quot;Content-Length&quot;, &quot;content-length&quot;, and &quot;CONTENT-LENGTH&quot; should all match. Implement case-insensitive comparison using <code>tolower()</code> character by character.</p>\n</li>\n<li><p><strong>Integer Parsing</strong>: Use <code>strtol()</code> for parsing Content-Length values, and always check the return value and <code>errno</code> for parsing errors. Reject negative values and values exceeding reasonable limits.</p>\n</li>\n<li><p><strong>Line Ending Handling</strong>: Real HTTP requests may use CRLF (\\r\\n) or just LF (\\n). Check for CRLF first, then fall back to LF to maintain broad compatibility.</p>\n</li>\n</ul>\n<p><strong>F. Milestone Checkpoint:</strong></p>\n<p>After implementing the HTTP parser component, verify functionality with these tests:</p>\n<p><strong>Test Command:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> test_parser</span><span style=\"color:#9ECBFF\"> test_http_parser.c</span><span style=\"color:#9ECBFF\"> http_parser.c</span><span style=\"color:#9ECBFF\"> http_utils.c</span><span style=\"color:#79B8FF\"> -I../include</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./test_parser</span></span></code></pre></div>\n\n<p><strong>Expected Behavior:</strong></p>\n<ul>\n<li>Parser correctly extracts &quot;GET&quot;, &quot;/index.html&quot;, &quot;HTTP/1.1&quot; from request line</li>\n<li>Headers like &quot;Host: localhost&quot; are stored as separate name/value pairs</li>\n<li>Case-insensitive header lookup finds &quot;content-length&quot; when searching for &quot;Content-Length&quot;</li>\n<li>Malformed requests return appropriate HTTP error codes (400, 405, 414)</li>\n<li>Parser handles both CRLF and LF line endings without errors</li>\n</ul>\n<p><strong>Manual Testing with Sample Request:</strong>\nCreate a file <code>test_request.txt</code>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>GET /test.html HTTP/1.1\nHost: localhost:8080\nUser-Agent: TestClient/1.0\nContent-Length: 0</code></pre></div>\n\n<p>The parser should extract method=&quot;GET&quot;, path=&quot;/test.html&quot;, version=&quot;HTTP/1.1&quot;, and three headers. Test with your parsing function to verify correct field population.</p>\n<p><strong>G. Debugging Tips:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Parser crashes on valid requests</td>\n<td>Buffer overflow in string copying</td>\n<td>Use debugger to check buffer boundaries</td>\n<td>Implement proper bounds checking in all string operations</td>\n</tr>\n<tr>\n<td>Headers contain extra whitespace</td>\n<td>Not trimming header values</td>\n<td>Print header values with quotes to see whitespace</td>\n<td>Apply trim_whitespace() to all header values</td>\n</tr>\n<tr>\n<td>Case-sensitive header matching fails</td>\n<td>Using strcmp instead of strcasecmp</td>\n<td>Test with &quot;content-length&quot; vs &quot;Content-Length&quot;</td>\n<td>Use case-insensitive comparison for header names</td>\n</tr>\n<tr>\n<td>Parser accepts malformed requests</td>\n<td>Missing validation steps</td>\n<td>Test with intentionally bad requests</td>\n<td>Add validation for each parsing step</td>\n</tr>\n<tr>\n<td>Body parsing fails with Content-Length</td>\n<td>Integer parsing or bounds checking error</td>\n<td>Check Content-Length parsing and available buffer size</td>\n<td>Validate Content-Length parsing and buffer bounds</td>\n</tr>\n</tbody></table>\n<h2 id=\"file-handler-component\">File Handler Component</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 3 (Static File Serving) - maps URL paths to filesystem paths and serves static content with proper security validation and MIME type detection</p>\n</blockquote>\n<h3 id=\"file-serving-mental-model-filing-cabinet-analogy\">File Serving Mental Model: Filing Cabinet Analogy</h3>\n<p>Think of the file handler component as a corporate filing cabinet system with a security guard. When someone requests a document, they don&#39;t walk directly to the filing cabinet - they submit a request to the security guard at the front desk. The security guard performs several critical checks before retrieving any document.</p>\n<p>First, the guard validates that the requested document exists within the authorized filing system boundaries. They check the person&#39;s access badge (similar to validating the URL path stays within the document root). The guard ensures the request isn&#39;t trying to access restricted areas like the executive filing room or the basement archives (preventing directory traversal attacks). Once security validation passes, the guard locates the correct filing cabinet, opens the appropriate drawer, and retrieves the requested document.</p>\n<p>The guard also knows what type of document they&#39;re handing over - whether it&#39;s a text memo, a PDF report, or a spreadsheet - and attaches the appropriate handling instructions (setting the correct Content-Type header). If the document doesn&#39;t exist, the guard politely informs the requester with a standardized &quot;Document Not Found&quot; response rather than revealing internal filing system details.</p>\n<p>This mental model captures the three essential responsibilities of the file handler: <strong>path security validation</strong>, <strong>file content retrieval</strong>, and <strong>metadata detection</strong>. The security guard represents the validation logic that stands between external requests and the filesystem, ensuring that only authorized access occurs within defined boundaries.</p>\n<p>The filing cabinet system also illustrates why <strong>path resolution</strong> must happen in a controlled manner. Just as the security guard follows established procedures for locating documents rather than allowing requesters to wander the filing room, the file handler must resolve paths through a secure, predictable process that prevents unauthorized access to system files or confidential data outside the document root.</p>\n<h3 id=\"file-handler-interface\">File Handler Interface</h3>\n<p>The file handler component exposes a clean interface that separates security validation, file operations, and response generation into distinct responsibilities. This separation allows the HTTP parser component to focus on message structure while delegating filesystem concerns to a specialized handler.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>validate_and_resolve_path</code></td>\n<td><code>document_root char*</code>, <code>request_path char*</code>, <code>resolved_path char*</code>, <code>max_path_len size_t</code></td>\n<td><code>int</code> (0 success, -1 error)</td>\n<td>Validates request path against directory traversal attacks and resolves to absolute filesystem path within document root boundaries</td>\n</tr>\n<tr>\n<td><code>detect_mime_type</code></td>\n<td><code>file_path char*</code>, <code>mime_type char*</code>, <code>max_mime_len size_t</code></td>\n<td><code>int</code> (0 success, -1 error)</td>\n<td>Determines MIME type based on file extension and sets Content-Type header value for HTTP response</td>\n</tr>\n<tr>\n<td><code>serve_file_content</code></td>\n<td><code>resolved_path char*</code>, <code>response HTTPResponse*</code></td>\n<td><code>int</code> (0 success, -1 file not found, -2 read error)</td>\n<td>Reads file contents into response body and sets appropriate Content-Length header</td>\n</tr>\n<tr>\n<td><code>handle_directory_request</code></td>\n<td><code>resolved_path char*</code>, <code>response HTTPResponse*</code></td>\n<td><code>int</code> (0 success, -1 error)</td>\n<td>Generates directory listing HTML when request path maps to a directory rather than a file</td>\n</tr>\n<tr>\n<td><code>generate_error_response</code></td>\n<td><code>status_code int</code>, <code>error_message char*</code>, <code>response HTTPResponse*</code></td>\n<td><code>void</code></td>\n<td>Creates standardized HTTP error response with appropriate status code and minimal error details</td>\n</tr>\n<tr>\n<td><code>check_file_permissions</code></td>\n<td><code>file_path char*</code></td>\n<td><code>int</code> (0 readable, -1 permission denied)</td>\n<td>Verifies that the server process has read permissions for the requested file</td>\n</tr>\n</tbody></table>\n<p>The interface design emphasizes <strong>defensive programming</strong> by requiring callers to provide pre-allocated buffers for path resolution and MIME type detection. This approach prevents memory allocation failures during request processing and ensures predictable memory usage patterns. Buffer sizes are validated through the <code>max_path_len</code> and <code>max_mime_len</code> parameters, providing protection against buffer overflow attacks.</p>\n<p>The return codes follow a consistent pattern where zero indicates success and negative values indicate specific error conditions. This allows the HTTP parser component to translate file handler errors into appropriate HTTP status codes without requiring detailed knowledge of filesystem error semantics.</p>\n<p><strong>Path Validation Interface Details:</strong></p>\n<p>The <code>validate_and_resolve_path</code> method performs the most security-critical operation in the entire HTTP server. It accepts a user-provided <code>request_path</code> (extracted from the HTTP request URL) and transforms it into a <code>resolved_path</code> that points to a real filesystem location. The validation process ensures that the resolved path remains within the <code>document_root</code> directory tree, preventing directory traversal attacks that could expose system files or sensitive data.</p>\n<table>\n<thead>\n<tr>\n<th>Validation Step</th>\n<th>Purpose</th>\n<th>Example Input</th>\n<th>Example Output</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>URL decode</td>\n<td>Convert percent-encoded characters</td>\n<td><code>/docs/file%20name.txt</code></td>\n<td><code>/docs/file name.txt</code></td>\n</tr>\n<tr>\n<td>Path normalization</td>\n<td>Remove <code>.</code> and <code>..</code> components</td>\n<td><code>/docs/../admin/secret.txt</code></td>\n<td><code>/admin/secret.txt</code></td>\n</tr>\n<tr>\n<td>Root boundary check</td>\n<td>Ensure path stays within document root</td>\n<td><code>/admin/secret.txt</code> with root <code>/var/www</code></td>\n<td><strong>REJECT</strong> - outside boundary</td>\n</tr>\n<tr>\n<td>Absolute path construction</td>\n<td>Build complete filesystem path</td>\n<td><code>/index.html</code> with root <code>/var/www</code></td>\n<td><code>/var/www/index.html</code></td>\n</tr>\n</tbody></table>\n<p><strong>MIME Type Detection Interface:</strong></p>\n<p>The <code>detect_mime_type</code> method provides content type detection based on file extensions. While production web servers often use more sophisticated methods like magic number detection or libmagic integration, the educational implementation focuses on extension-based mapping for simplicity and predictability.</p>\n<table>\n<thead>\n<tr>\n<th>File Extension</th>\n<th>MIME Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>.html</code>, <code>.htm</code></td>\n<td><code>text/html</code></td>\n<td>HTML documents</td>\n</tr>\n<tr>\n<td><code>.css</code></td>\n<td><code>text/css</code></td>\n<td>Cascading Style Sheets</td>\n</tr>\n<tr>\n<td><code>.js</code></td>\n<td><code>application/javascript</code></td>\n<td>JavaScript files</td>\n</tr>\n<tr>\n<td><code>.json</code></td>\n<td><code>application/json</code></td>\n<td>JSON data</td>\n</tr>\n<tr>\n<td><code>.txt</code></td>\n<td><code>text/plain</code></td>\n<td>Plain text files</td>\n</tr>\n<tr>\n<td><code>.png</code></td>\n<td><code>image/png</code></td>\n<td>PNG images</td>\n</tr>\n<tr>\n<td><code>.jpg</code>, <code>.jpeg</code></td>\n<td><code>image/jpeg</code></td>\n<td>JPEG images</td>\n</tr>\n<tr>\n<td><code>.gif</code></td>\n<td><code>image/gif</code></td>\n<td>GIF images</td>\n</tr>\n<tr>\n<td>(unknown)</td>\n<td><code>application/octet-stream</code></td>\n<td>Binary data fallback</td>\n</tr>\n</tbody></table>\n<h3 id=\"file-serving-algorithm\">File Serving Algorithm</h3>\n<p>The file serving algorithm implements a multi-stage process that prioritizes security validation before performing any filesystem operations. This approach ensures that malicious requests are rejected early in the process, minimizing resource consumption and potential attack vectors.</p>\n<p><strong>Stage 1: Request Path Validation</strong></p>\n<ol>\n<li><strong>Extract the path component</strong> from the HTTP request URL, handling query parameters and fragment identifiers by truncating at the first <code>?</code> or <code>#</code> character</li>\n<li><strong>Perform URL decoding</strong> to convert percent-encoded characters back to their original form, handling special characters like spaces (<code>%20</code>) and non-ASCII characters</li>\n<li><strong>Normalize the path</strong> by resolving <code>.</code> (current directory) and <code>..</code> (parent directory) components using a stack-based algorithm that processes each path segment</li>\n<li><strong>Validate path boundaries</strong> by ensuring the normalized path, when combined with the document root, produces an absolute path that remains within the document root directory tree</li>\n<li><strong>Check for null bytes</strong> and other control characters that could indicate path injection attacks or malformed input data</li>\n<li><strong>Construct the resolved absolute path</strong> by concatenating the document root with the validated relative path using appropriate path separator characters</li>\n</ol>\n<p><strong>Stage 2: Filesystem Verification</strong></p>\n<ol start=\"7\">\n<li><strong>Check file existence</strong> using the <code>access()</code> system call or equivalent to determine if the resolved path corresponds to an actual filesystem entry</li>\n<li><strong>Determine entry type</strong> by calling <code>stat()</code> to distinguish between regular files, directories, symbolic links, and other filesystem objects</li>\n<li><strong>Verify read permissions</strong> to ensure the server process has appropriate access rights to read the requested file or directory contents</li>\n<li><strong>Handle symbolic links</strong> by either following them (if policy allows) or treating them as regular files, depending on security configuration</li>\n</ol>\n<p><strong>Stage 3: Content Delivery</strong></p>\n<ol start=\"11\">\n<li><strong>For regular files</strong>: Open the file, determine its size, detect the MIME type based on the file extension, and read the contents into the response body buffer</li>\n<li><strong>For directories</strong>: Generate an HTML directory listing showing available files and subdirectories, or serve a default index file (<code>index.html</code>) if present</li>\n<li><strong>Set response headers</strong> including <code>Content-Type</code>, <code>Content-Length</code>, and <code>Last-Modified</code> based on file metadata and detected content type</li>\n<li><strong>Handle large files</strong> by implementing chunked reading to avoid loading entire files into memory, particularly important for binary content like images or videos</li>\n</ol>\n<blockquote>\n<p><strong>Design Insight</strong>: The algorithm&#39;s security-first approach means that path validation errors result in immediate rejection with a 400 Bad Request response, while filesystem errors (like permission denied or file not found) generate appropriate 4xx error responses. This distinction helps legitimate clients understand whether their request was malformed or simply requested a non-existent resource.</p>\n</blockquote>\n<p><strong>Error Handling Throughout the Algorithm:</strong></p>\n<p>At each stage, specific error conditions require different responses and cleanup actions. Path validation errors typically indicate malicious requests and should be logged for security monitoring. Filesystem errors might represent temporary conditions (like permission changes) or legitimate requests for non-existent resources.</p>\n<table>\n<thead>\n<tr>\n<th>Error Condition</th>\n<th>Detection Point</th>\n<th>HTTP Status</th>\n<th>Response Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Invalid URL encoding</td>\n<td>Stage 1, Step 2</td>\n<td>400 Bad Request</td>\n<td>Log security warning, minimal error details</td>\n</tr>\n<tr>\n<td>Directory traversal attempt</td>\n<td>Stage 1, Step 4</td>\n<td>400 Bad Request</td>\n<td>Log security alert, block request</td>\n</tr>\n<tr>\n<td>File not found</td>\n<td>Stage 2, Step 7</td>\n<td>404 Not Found</td>\n<td>Standard not found page</td>\n</tr>\n<tr>\n<td>Permission denied</td>\n<td>Stage 2, Step 9</td>\n<td>403 Forbidden</td>\n<td>Access denied message</td>\n</tr>\n<tr>\n<td>File read error</td>\n<td>Stage 3, Step 11</td>\n<td>500 Internal Server Error</td>\n<td>Generic error, log details</td>\n</tr>\n</tbody></table>\n<h3 id=\"architecture-decision-records\">Architecture Decision Records</h3>\n<blockquote>\n<p><strong>Decision: Path Security Validation Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: The file handler must prevent directory traversal attacks while allowing legitimate file access within the document root. Attackers commonly use <code>../</code> sequences to access system files outside the intended serving directory.</li>\n<li><strong>Options Considered</strong>: 1) Simple string matching to reject <code>..</code> patterns, 2) Filesystem-based validation using realpath(), 3) Stack-based path normalization with boundary checking</li>\n<li><strong>Decision</strong>: Implement stack-based path normalization combined with absolute path boundary validation</li>\n<li><strong>Rationale</strong>: String matching is easily bypassed with encoded characters or alternate representations. Realpath() requires filesystem access and may have race conditions. Stack-based normalization handles all <code>..</code> variations while boundary checking prevents any escape from the document root.</li>\n<li><strong>Consequences</strong>: Provides robust security against directory traversal attacks but requires more complex implementation than simple string matching. Performance impact is minimal since path validation occurs once per request.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Security Level</th>\n<th>Performance</th>\n<th>Implementation Complexity</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>String matching</td>\n<td>Low - easily bypassed</td>\n<td>High</td>\n<td>Low</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Realpath() validation</td>\n<td>Medium - race conditions</td>\n<td>Medium</td>\n<td>Medium</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Stack-based normalization</td>\n<td>High - handles all cases</td>\n<td>High</td>\n<td>High</td>\n<td><strong>Yes</strong></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: MIME Type Detection Method</strong></p>\n<ul>\n<li><strong>Context</strong>: HTTP responses must include accurate Content-Type headers to enable proper browser rendering and security policies. Different detection methods offer varying accuracy and performance characteristics.</li>\n<li><strong>Options Considered</strong>: 1) File extension mapping, 2) Magic number detection from file contents, 3) External library integration (libmagic)</li>\n<li><strong>Decision</strong>: Implement file extension mapping with a comprehensive MIME type table</li>\n<li><strong>Rationale</strong>: Extension mapping provides predictable, fast results suitable for educational purposes. Magic number detection requires reading file contents and adds complexity. Library integration introduces dependencies and may be overkill for a learning project.</li>\n<li><strong>Consequences</strong>: Fast, predictable MIME type detection with minimal resource usage. May incorrectly classify files with wrong extensions, but this is acceptable for educational static file serving.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Accuracy</th>\n<th>Performance</th>\n<th>Dependencies</th>\n<th>Complexity</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Extension mapping</td>\n<td>Medium</td>\n<td>High</td>\n<td>None</td>\n<td>Low</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Magic numbers</td>\n<td>High</td>\n<td>Medium</td>\n<td>None</td>\n<td>High</td>\n<td>No</td>\n</tr>\n<tr>\n<td>libmagic integration</td>\n<td>Highest</td>\n<td>Medium</td>\n<td>External library</td>\n<td>Medium</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Large File Handling Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Static file servers must handle files of varying sizes, from small text files to large images or videos. Loading entire files into memory can cause resource exhaustion and poor performance.</li>\n<li><strong>Options Considered</strong>: 1) Load complete files into memory, 2) Stream files with fixed-size chunks, 3) Memory-mapped file access</li>\n<li><strong>Decision</strong>: Implement streaming with 8KB fixed-size chunks for files larger than 64KB</li>\n<li><strong>Rationale</strong>: Complete memory loading causes resource exhaustion with large files. Streaming provides predictable memory usage and good performance. Memory mapping adds complexity and platform-specific code.</li>\n<li><strong>Consequences</strong>: Controlled memory usage regardless of file size, but requires more complex response generation logic. Small files still load completely for optimal performance.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Memory Usage</th>\n<th>Performance</th>\n<th>Complexity</th>\n<th>Scalability</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Complete memory load</td>\n<td>Unpredictable</td>\n<td>High for small files</td>\n<td>Low</td>\n<td>Poor</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Fixed-size streaming</td>\n<td>Predictable</td>\n<td>Good for all sizes</td>\n<td>Medium</td>\n<td>Excellent</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Memory mapping</td>\n<td>Low</td>\n<td>Highest</td>\n<td>High</td>\n<td>Excellent</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Directory Listing Generation</strong></p>\n<ul>\n<li><strong>Context</strong>: When a request maps to a directory rather than a file, the server must decide how to respond. Options include serving default files, generating listings, or returning errors.</li>\n<li><strong>Options Considered</strong>: 1) Always return 404 for directory requests, 2) Serve index.html if present otherwise 404, 3) Generate HTML directory listings</li>\n<li><strong>Decision</strong>: Serve index.html if present, otherwise generate basic HTML directory listing</li>\n<li><strong>Rationale</strong>: This matches conventional web server behavior and provides useful functionality for development and testing. Directory listings help developers verify file placement and organization.</li>\n<li><strong>Consequences</strong>: Adds complexity to handle directory traversal and HTML generation, but provides valuable development functionality. Security risk is minimal since listings only show files within the document root.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Developer Utility</th>\n<th>Security Risk</th>\n<th>Implementation Complexity</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Always 404</td>\n<td>Low</td>\n<td>None</td>\n<td>Low</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Index.html only</td>\n<td>Medium</td>\n<td>None</td>\n<td>Medium</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Generated listings</td>\n<td>High</td>\n<td>Low</td>\n<td>High</td>\n<td><strong>Yes</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"common-file-serving-pitfalls\">Common File Serving Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Directory Traversal Vulnerability</strong></p>\n<p>The most critical security vulnerability in static file servers occurs when path validation fails to prevent directory traversal attacks. Attackers use sequences like <code>../</code> to escape the document root and access system files like <code>/etc/passwd</code> or application configuration files containing sensitive data.</p>\n<p><strong>Why it&#39;s dangerous</strong>: A successful directory traversal attack can expose any file readable by the server process, including system configuration, application secrets, or user data stored outside the web root. This represents a complete compromise of server confidentiality.</p>\n<p><strong>Common mistakes</strong>: Implementing path validation with simple string matching (<code>if (strstr(path, &quot;..&quot;))</code>) that can be bypassed with URL encoding (<code>%2e%2e%2f</code>), Unicode normalization attacks, or alternate path representations. Another mistake is validating the request path but not the resolved absolute path.</p>\n<p><strong>How to fix</strong>: Implement comprehensive path normalization using a stack-based algorithm that processes each path component individually. After normalization, construct the absolute path and verify it begins with the document root path. Always validate the final resolved path, not intermediate representations.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG - easily bypassed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strstr</span><span style=\"color:#E1E4E8\">(request_path, </span><span style=\"color:#9ECBFF\">\"..\"</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // reject</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CORRECT - normalize then validate final path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\"> normalized </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> normalize_path_components</span><span style=\"color:#E1E4E8\">(request_path);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\"> absolute </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> combine_paths</span><span style=\"color:#E1E4E8\">(document_root, normalized);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">path_starts_with</span><span style=\"color:#E1E4E8\">(absolute, document_root)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // reject - outside boundary</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>⚠️ <strong>Pitfall: Binary File Corruption</strong></p>\n<p>Static file servers must handle both text and binary content correctly. A common mistake is treating all files as text and applying transformations like line ending conversion or character encoding changes that corrupt binary data like images, executables, or compressed files.</p>\n<p><strong>Why it&#39;s wrong</strong>: Binary file corruption makes images unreadable, breaks downloadable software, and causes unpredictable application behavior. Modern web applications rely heavily on binary assets that must be delivered bit-for-bit identical to their stored versions.</p>\n<p><strong>Detection signs</strong>: Images appear broken in browsers, PDF downloads are corrupted, or binary files have different checksums after serving compared to their original versions stored on disk.</p>\n<p><strong>How to fix</strong>: Always read files in binary mode using appropriate flags (<code>&quot;rb&quot;</code> for fopen() or <code>O_BINARY</code> for open()). Never apply text transformations to file contents. Set appropriate Content-Type headers to help browsers handle binary content correctly.</p>\n<p>⚠️ <strong>Pitfall: Inadequate Error Information Disclosure</strong></p>\n<p>File serving errors require careful balance between helpful debugging information and security. Revealing too much information in error responses helps attackers understand the server&#39;s internal structure and identify potential attack vectors.</p>\n<p><strong>Why it&#39;s wrong</strong>: Detailed error messages like &quot;Permission denied accessing /var/www/admin/secret.txt&quot; reveal internal filesystem structure and confirm the existence of potentially sensitive directories. This information helps attackers refine their attacks.</p>\n<p><strong>How to fix</strong>: Generate standardized error responses that provide sufficient information for legitimate debugging without revealing internal details. Log detailed error information on the server side for administrator review while sending minimal information to clients.</p>\n<table>\n<thead>\n<tr>\n<th>Error Condition</th>\n<th>Bad Response</th>\n<th>Good Response</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>File not found</td>\n<td>&quot;File /var/www/docs/secret.txt not found&quot;</td>\n<td>&quot;404 Not Found&quot;</td>\n</tr>\n<tr>\n<td>Permission denied</td>\n<td>&quot;Permission denied: /etc/passwd&quot;</td>\n<td>&quot;403 Forbidden&quot;</td>\n</tr>\n<tr>\n<td>Read error</td>\n<td>&quot;I/O error reading /home/user/.ssh/id_rsa&quot;</td>\n<td>&quot;500 Internal Server Error&quot;</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Inefficient Large File Handling</strong></p>\n<p>Loading entire files into memory before sending responses causes memory exhaustion when serving large files or handling multiple concurrent requests for substantial content. This creates denial of service vulnerabilities and poor performance characteristics.</p>\n<p><strong>Why it&#39;s wrong</strong>: A 100MB video file loaded completely into memory for each concurrent request quickly exhausts available RAM. Multiple simultaneous requests for large files can crash the server or trigger out-of-memory kills by the operating system.</p>\n<p><strong>Detection signs</strong>: Memory usage spikes correlating with large file requests, server crashes when serving substantial content, or extremely slow response times for large files due to memory pressure and swapping.</p>\n<p><strong>How to fix</strong>: Implement streaming file delivery using fixed-size buffers (typically 4-8KB). Read chunks from the file and write them directly to the network socket without accumulating the entire file in memory. This provides predictable memory usage regardless of file size.</p>\n<p>⚠️ <strong>Pitfall: Race Conditions in File Operations</strong></p>\n<p>File serving involves multiple filesystem operations (stat, open, read) that can create race conditions if files are modified, deleted, or have permissions changed between operations. This can lead to serving partially updated content or crashing due to unexpected file states.</p>\n<p><strong>Why it&#39;s wrong</strong>: A file might exist during the stat() check but be deleted before open(), causing the server to crash or return confusing errors. Similarly, files being written by other processes might be served in incomplete states, delivering corrupted content to clients.</p>\n<p><strong>How to fix</strong>: Use atomic file operations where possible and implement proper error handling for all filesystem calls. Consider using file locking for critical operations, though this may impact performance. Design the serving logic to gracefully handle files that become unavailable between checks.</p>\n<p>⚠️ <strong>Pitfall: Missing Content-Length Headers</strong></p>\n<p>HTTP responses should include Content-Length headers to enable proper connection handling and download progress indication. Omitting this header forces chunked transfer encoding or connection closing, reducing performance and compatibility.</p>\n<p><strong>Why it&#39;s wrong</strong>: Browsers cannot display download progress without Content-Length headers. HTTP/1.1 keep-alive connections may not work properly, forcing new TCP connections for each request and significantly impacting performance.</p>\n<p><strong>How to fix</strong>: Always determine file size using stat() before beginning content delivery and include the Content-Length header in the HTTP response. For chunked file reading, calculate the total size upfront rather than omitting the header.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Path manipulation</td>\n<td>Manual string operations with bounds checking</td>\n<td>Path normalization library (realpath, canonicalize_file_name)</td>\n</tr>\n<tr>\n<td>MIME detection</td>\n<td>Static extension-to-type mapping table</td>\n<td>libmagic integration for content-based detection</td>\n</tr>\n<tr>\n<td>File I/O</td>\n<td>Standard C file operations (fopen, fread, fclose)</td>\n<td>Memory-mapped files with mmap() for large content</td>\n</tr>\n<tr>\n<td>Directory listing</td>\n<td>Simple opendir/readdir with manual HTML generation</td>\n<td>Template engine for customizable directory pages</td>\n</tr>\n<tr>\n<td>Security validation</td>\n<td>Custom path normalization with stack algorithm</td>\n<td>chroot() jail for complete filesystem isolation</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<p>The file handler component integrates into the HTTP server project as a dedicated module responsible for all filesystem operations and security validation:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n├── src/\n│   ├── server.c              ← main server loop and TCP handling\n│   ├── http_parser.c         ← HTTP request/response parsing\n│   ├── file_handler.c        ← this component - file serving logic\n│   ├── file_handler.h        ← public interface definitions\n│   └── mime_types.c          ← MIME type mapping table\n├── include/\n│   ├── http_server.h         ← shared type definitions\n│   └── file_handler.h        ← file handler interface\n├── config/\n│   ├── mime.types            ← MIME type configuration file\n│   └── server.conf           ← server configuration\n├── www/                      ← default document root\n│   ├── index.html           \n│   ├── css/\n│   └── images/\n└── tests/\n    ├── test_file_handler.c   ← unit tests for file operations\n    └── test_security.c       ← security validation tests</code></pre></div>\n\n<p>This structure separates file handling concerns from network and HTTP parsing logic while providing a clear interface for integration with the overall server architecture.</p>\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Complete MIME Type Detection System:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// mime_types.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> MIME_TYPES_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MIME_TYPES_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> extension;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> mime_type;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} MimeTypeMapping;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize MIME type system</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> init_mime_types</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Get MIME type by file extension</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#B392F0\"> get_mime_type</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> file_path</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Cleanup MIME type resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> cleanup_mime_types</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// mime_types.c - Complete implementation ready to use</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"mime_types.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;ctype.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#E1E4E8\"> MimeTypeMapping mime_mappings</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#9ECBFF\">\".html\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"text/html\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#9ECBFF\">\".htm\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"text/html\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#9ECBFF\">\".css\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"text/css\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#9ECBFF\">\".js\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"application/javascript\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#9ECBFF\">\".json\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"application/json\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#9ECBFF\">\".txt\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"text/plain\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#9ECBFF\">\".png\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"image/png\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#9ECBFF\">\".jpg\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"image/jpeg\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#9ECBFF\">\".jpeg\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"image/jpeg\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#9ECBFF\">\".gif\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"image/gif\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#9ECBFF\">\".svg\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"image/svg+xml\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#9ECBFF\">\".pdf\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"application/pdf\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#9ECBFF\">\".zip\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"application/zip\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">}</span><span style=\"color:#6A737D\">  // Sentinel</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> init_mime_types</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // MIME system initialized with static table</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#B392F0\"> get_mime_type</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> file_path</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">file_path) </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"application/octet-stream\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find last dot in filename</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> dot </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strrchr</span><span style=\"color:#E1E4E8\">(file_path, </span><span style=\"color:#9ECBFF\">'.'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">dot) </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"application/octet-stream\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Convert extension to lowercase for comparison</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> ext_lower</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">dot</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 31</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        ext_lower</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> tolower</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">dot</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    ext_lower</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Search mapping table</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#FFAB70\">mime_mappings</span><span style=\"color:#E1E4E8\">[j].extension; j</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strcmp</span><span style=\"color:#E1E4E8\">(ext_lower, </span><span style=\"color:#FFAB70\">mime_mappings</span><span style=\"color:#E1E4E8\">[j].extension) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#FFAB70\"> mime_mappings</span><span style=\"color:#E1E4E8\">[j].mime_type;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#9ECBFF\"> \"application/octet-stream\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> cleanup_mime_types</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Static table requires no cleanup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Complete Path Utility Functions:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// path_utils.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> PATH_UTILS_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PATH_UTILS_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stddef.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// URL decode a path string in-place</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> url_decode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">char*</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Check if path contains directory traversal attempts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> has_directory_traversal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Normalize path by removing . and .. components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> normalize_path</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> input</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char*</span><span style=\"color:#FFAB70\"> output</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> output_size</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Check if resolved path is within document root</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> is_path_within_root</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> document_root</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> resolved_path</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// path_utils.c - Complete implementation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"path_utils.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;ctype.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> url_decode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">char*</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> read </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> path;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> write </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> path;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">read) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">read </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '%'</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#FFAB70\"> read</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#FFAB70\"> read</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">]) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Convert hex digits to character</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            char</span><span style=\"color:#FFAB70\"> hex</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#FFAB70\">read</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#FFAB70\">read</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            char*</span><span style=\"color:#E1E4E8\"> endptr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            long</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strtol</span><span style=\"color:#E1E4E8\">(hex, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">endptr, </span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">endptr </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 255</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                *</span><span style=\"color:#E1E4E8\">write </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char</span><span style=\"color:#E1E4E8\">)value;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                read </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                *</span><span style=\"color:#E1E4E8\">write </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">read;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                read</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">read </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '+'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            *</span><span style=\"color:#E1E4E8\">write </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> ' '</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            read</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            *</span><span style=\"color:#E1E4E8\">write </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">read;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            read</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        write</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">write </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> has_directory_traversal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Look for .. components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> path;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> ((pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strstr</span><span style=\"color:#E1E4E8\">(pos, </span><span style=\"color:#9ECBFF\">\"..\"</span><span style=\"color:#E1E4E8\">)) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check if .. is a complete path component</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> is_component </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (pos </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> path </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#FFAB70\"> pos</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> '/'</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#FFAB70\"> pos</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\\\</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            is_component </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pos</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#FFAB70\"> pos</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> '/'</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#FFAB70\"> pos</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\\\</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            is_component </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (is_component) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Found directory traversal</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Additional utility functions with complete implementations...</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>Main File Handler Interface:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// file_handler.h - Core interfaces for learner implementation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"http_server.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Primary file serving function - learners implement this</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> serve_static_file</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> HTTPRequest</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> request</span><span style=\"color:#E1E4E8\">, HTTPResponse</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> response</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                     const</span><span style=\"color:#E1E4E8\"> ServerConfig</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Extract path from request URL, handling query parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate and resolve path against document root using validate_and_resolve_path()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check if resolved path exists and get file stats using stat()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Handle directory requests - look for index.html or generate listing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: For regular files, detect MIME type and set Content-Type header</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Read file contents and populate response body</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Set Content-Length header based on file size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Handle all error cases with appropriate HTTP status codes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use the infrastructure functions for path validation and MIME detection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Path security validation - learners implement core logic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> validate_and_resolve_path</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> document_root</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> request_path</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                             char*</span><span style=\"color:#FFAB70\"> resolved_path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> max_path_len</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create working copy of request_path for manipulation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Perform URL decoding using url_decode() utility function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check for directory traversal patterns using has_directory_traversal()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Normalize path components to resolve . and .. using normalize_path()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Construct absolute path by combining document_root + normalized_path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Verify final path stays within document_root boundaries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Check for null bytes or other control characters in path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Copy validated path to resolved_path output buffer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Reject immediately if any security check fails</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// File content reading with streaming support - learners implement</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> read_file_content</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> file_path</span><span style=\"color:#E1E4E8\">, HTTPResponse</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> response</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Open file in binary mode for reading</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Get file size using fstat() or stat()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Allocate response body buffer or set up streaming</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: For small files (&#x3C; 64KB), read entire content into memory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: For large files, implement chunked reading with 8KB buffers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Set response->body_length to actual bytes read</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Handle read errors and clean up file descriptor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Return appropriate error codes for different failure modes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Always close file descriptor in error cases</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Directory listing generation - learners implement</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> generate_directory_listing</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> dir_path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> url_path</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                              HTTPResponse</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> response</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Open directory using opendir()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Read directory entries with readdir() in a loop</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Filter out hidden files (starting with .) if desired</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Sort entries alphabetically for consistent presentation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Generate HTML page with proper DOCTYPE and headers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Create table or list showing filenames, sizes, and modification times</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Make filenames clickable links with proper URL encoding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Set Content-Type to text/html and calculate Content-Length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Include parent directory link (..) except for document root</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints-for-c-implementation\">Language-Specific Hints for C Implementation</h4>\n<p><strong>File System Operations:</strong></p>\n<ul>\n<li>Use <code>stat()</code> or <code>fstat()</code> to get file information including size, type, and permissions</li>\n<li>Open files with <code>fopen(path, &quot;rb&quot;)</code> to ensure binary mode for all file types</li>\n<li>Check <code>errno</code> after failed system calls to determine specific error conditions</li>\n<li>Use <code>access(path, R_OK)</code> to verify read permissions before attempting file operations</li>\n</ul>\n<p><strong>Memory Management:</strong></p>\n<ul>\n<li>Always validate buffer sizes before string operations to prevent buffer overflows</li>\n<li>Use <code>strncpy()</code> and <code>snprintf()</code> instead of <code>strcpy()</code> and <code>sprintf()</code> for bounds checking</li>\n<li>Free allocated memory in all code paths, including error handling branches</li>\n<li>Consider using stack-allocated buffers for path manipulation to avoid malloc/free overhead</li>\n</ul>\n<p><strong>Security Considerations:</strong></p>\n<ul>\n<li>Validate all user input including URL paths, query parameters, and header values</li>\n<li>Use <code>realpath()</code> on systems that support it for canonical path resolution</li>\n<li>Be careful with signed/unsigned integer comparisons when checking buffer bounds</li>\n<li>Always null-terminate strings after manipulation to prevent buffer over-reads</li>\n</ul>\n<p><strong>Performance Tips:</strong></p>\n<ul>\n<li>Cache file statistics for recently accessed files to avoid repeated stat() calls</li>\n<li>Use <code>sendfile()</code> on Linux or equivalent zero-copy mechanisms for large file transfers</li>\n<li>Consider <code>mmap()</code> for files accessed frequently, but handle mapping failures gracefully</li>\n<li>Implement proper error logging to help diagnose filesystem permission or availability issues</li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the file handler component, verify the functionality with these specific tests:</p>\n<p><strong>Basic File Serving Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Start your HTTP server on port 8080</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./http_server</span><span style=\"color:#79B8FF\"> --port</span><span style=\"color:#79B8FF\"> 8080</span><span style=\"color:#79B8FF\"> --docroot</span><span style=\"color:#9ECBFF\"> ./www</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test basic file serving</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/index.html</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: 200 OK response with HTML content and proper Content-Type header</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test CSS file serving  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/css/style.css</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: 200 OK with Content-Type: text/css</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test image serving</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/images/logo.png</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: 200 OK with Content-Type: image/png and binary content</span></span></code></pre></div>\n\n<p><strong>Security Validation Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test directory traversal prevention</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> \"http://localhost:8080/../etc/passwd\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: 400 Bad Request or 404 Not Found (never file contents)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test encoded traversal attempts</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> \"http://localhost:8080/%2e%2e%2f%2e%2e%2fetc%2fpasswd\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: 400 Bad Request (should be caught by URL decoding + validation)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test file not found</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/nonexistent.html</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: 404 Not Found with standard error page</span></span></code></pre></div>\n\n<p><strong>Directory Handling Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test directory listing</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/images/</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: 200 OK with HTML directory listing or index.html if present</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test root directory</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: index.html content or directory listing of document root</span></span></code></pre></div>\n\n<p><strong>Signs of Correct Implementation:</strong></p>\n<ul>\n<li>All responses include proper <code>Content-Type</code> and <code>Content-Length</code> headers</li>\n<li>Binary files (images) display correctly in web browsers  </li>\n<li>Directory traversal attempts are rejected with 4xx status codes</li>\n<li>File not found generates 404 responses, not server errors</li>\n<li>Directory requests show listings or serve index files appropriately</li>\n</ul>\n<p><strong>Signs Something is Wrong:</strong></p>\n<ul>\n<li>Images appear corrupted or broken in browsers → binary file handling issue</li>\n<li>Server crashes on directory traversal attempts → path validation missing</li>\n<li>All files served as <code>text/plain</code> → MIME type detection not working</li>\n<li>Memory usage grows continuously → file descriptor or memory leaks</li>\n<li>Slow response times for large files → not implementing streaming properly</li>\n</ul>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Frequest-processing-flow.svg\" alt=\"Request Processing Sequence\"></p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Ffile-serving-flow.svg\" alt=\"File Serving Security Flow\"></p>\n<h2 id=\"concurrency-management-component\">Concurrency Management Component</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 4 (Concurrent Connections) - handles multiple simultaneous client connections using different concurrency models to prevent blocking and enable scalable request processing</p>\n</blockquote>\n<h3 id=\"concurrency-mental-model-restaurant-service-models\">Concurrency Mental Model: Restaurant Service Models</h3>\n<p>Think of an HTTP server handling concurrent connections like a restaurant serving multiple customers simultaneously. Just as restaurants have different service models to handle varying numbers of diners, HTTP servers employ different concurrency strategies to manage multiple client connections efficiently.</p>\n<p>The <strong>thread-per-connection model</strong> resembles a high-end restaurant where each table gets a dedicated waiter for the entire meal. When customers arrive, the host (main server thread) seats them and assigns a personal waiter (spawns a new thread) who handles all their needs from start to finish. This provides excellent individual attention - each table gets immediate, personalized service without waiting for other tables to finish. However, this model becomes expensive with many tables since you need to hire more waiters (create more threads), and each waiter consumes resources even when just standing around waiting for the customers to decide what they want (thread overhead during I/O operations).</p>\n<p>The <strong>thread pool model</strong> works like a restaurant with a fixed number of waiters who serve multiple tables. When customers arrive, the host seats them and assigns the next available waiter from the existing staff. If all waiters are busy, new customers wait in line until someone becomes free. This prevents the restaurant from hiring unlimited staff during rush hours (prevents thread exhaustion) and maintains consistent service quality. The trade-off is that some customers might wait longer during peak times, but the restaurant operates more efficiently overall.</p>\n<p>The <strong>event-driven model</strong> resembles a fast-casual restaurant with a single highly efficient coordinator who manages all orders simultaneously. Instead of assigning dedicated waiters, this coordinator continuously monitors all tables - taking orders when customers are ready, delivering food when the kitchen calls out orders, and processing payments when customers signal they&#39;re done. This coordinator never stands idle waiting for one table while others need attention. This model can handle many more customers with fewer staff members, but requires the coordinator to be exceptionally organized and efficient at task-switching.</p>\n<p>Each model has distinct trade-offs in terms of resource usage, scalability, complexity, and responsiveness. The choice depends on expected load patterns, available system resources, and performance requirements - just as a restaurant&#39;s service model depends on its target clientele, budget constraints, and dining style.</p>\n<h3 id=\"concurrency-manager-interface\">Concurrency Manager Interface</h3>\n<p>The concurrency management component provides a unified interface for handling multiple simultaneous client connections regardless of the underlying concurrency model. This abstraction allows the server to switch between different concurrency strategies without changing the core HTTP processing logic.</p>\n<p>The primary interface centers around connection dispatching, resource management, and lifecycle control. The concurrency manager accepts new client connections from the TCP server component and routes them to available processing resources according to the chosen concurrency model.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>init_concurrency_manager</code></td>\n<td><code>config: ServerConfig*, model: ConcurrencyModel</code></td>\n<td><code>ConcurrencyManager*</code></td>\n<td>Initializes concurrency manager with specified model and configuration limits</td>\n</tr>\n<tr>\n<td><code>start_connection_handler</code></td>\n<td><code>manager: ConcurrencyManager*, client_fd: int, client_addr: sockaddr_in</code></td>\n<td><code>int</code></td>\n<td>Dispatches new client connection to available handler based on concurrency model</td>\n</tr>\n<tr>\n<td><code>wait_for_completion</code></td>\n<td><code>manager: ConcurrencyManager*</code></td>\n<td><code>void</code></td>\n<td>Blocks until all active connections complete processing (used during shutdown)</td>\n</tr>\n<tr>\n<td><code>get_active_connection_count</code></td>\n<td><code>manager: ConcurrencyManager*</code></td>\n<td><code>int</code></td>\n<td>Returns number of currently active client connections being processed</td>\n</tr>\n<tr>\n<td><code>shutdown_concurrency_manager</code></td>\n<td><code>manager: ConcurrencyManager*, graceful: int</code></td>\n<td><code>void</code></td>\n<td>Initiates shutdown sequence, optionally waiting for active connections to complete</td>\n</tr>\n<tr>\n<td><code>cleanup_concurrency_manager</code></td>\n<td><code>manager: ConcurrencyManager*</code></td>\n<td><code>void</code></td>\n<td>Releases all resources including thread pools, connection tracking structures</td>\n</tr>\n</tbody></table>\n<p>The concurrency manager maintains internal state to track active connections, available resources, and configuration limits. This state enables proper resource management and prevents system overload during high traffic periods.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>model</code></td>\n<td><code>ConcurrencyModel</code></td>\n<td>Active concurrency model (thread-per-connection, pool, or event-driven)</td>\n</tr>\n<tr>\n<td><code>max_connections</code></td>\n<td><code>int</code></td>\n<td>Maximum simultaneous connections allowed before rejecting new clients</td>\n</tr>\n<tr>\n<td><code>max_threads</code></td>\n<td><code>int</code></td>\n<td>Maximum threads in pool model, ignored for other models</td>\n</tr>\n<tr>\n<td><code>active_connections</code></td>\n<td><code>ConnectionContext*</code></td>\n<td>Array tracking all currently active client connections</td>\n</tr>\n<tr>\n<td><code>connection_count</code></td>\n<td><code>int</code></td>\n<td>Current number of active connections being processed</td>\n</tr>\n<tr>\n<td><code>thread_pool</code></td>\n<td><code>pthread_t*</code></td>\n<td>Thread pool array for pool-based concurrency model</td>\n</tr>\n<tr>\n<td><code>connection_queue</code></td>\n<td><code>ConnectionQueue*</code></td>\n<td>Queue of pending connections awaiting thread assignment in pool model</td>\n</tr>\n<tr>\n<td><code>shutdown_requested</code></td>\n<td><code>volatile int</code></td>\n<td>Flag indicating graceful shutdown has been initiated</td>\n</tr>\n<tr>\n<td><code>connection_mutex</code></td>\n<td><code>pthread_mutex_t</code></td>\n<td>Protects connection tracking data structures from concurrent access</td>\n</tr>\n</tbody></table>\n<p>The interface design separates concurrency concerns from HTTP processing logic. The HTTP parser, file handler, and response generation components remain unchanged regardless of concurrency model. This separation enables testing different concurrency approaches without rewriting core functionality.</p>\n<p>Connection lifecycle management follows a consistent pattern across all models. The concurrency manager receives a client file descriptor and address from the TCP server, creates a <code>ConnectionContext</code> structure to track the connection state, dispatches the connection to an available processor, and ensures proper cleanup when processing completes.</p>\n<blockquote>\n<p><strong>Key Design Insight</strong>: The concurrency manager acts as a resource allocation layer between the TCP server and HTTP processing components. By abstracting concurrency model details, we can optimize for different deployment scenarios (high-throughput vs. low-latency, resource-constrained vs. resource-abundant) without changing the core HTTP server logic.</p>\n</blockquote>\n<h3 id=\"concurrency-model-options\">Concurrency Model Options</h3>\n<p>The HTTP server supports three distinct concurrency models, each optimized for different scenarios and resource constraints. Understanding the trade-offs between these models is crucial for selecting the appropriate approach based on expected traffic patterns and system capabilities.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fconcurrency-models.svg\" alt=\"Concurrency Model Comparison\"></p>\n<h4 id=\"thread-per-connection-model\">Thread-Per-Connection Model</h4>\n<p>The thread-per-connection model creates a dedicated thread for each incoming client connection. When the TCP server accepts a new connection, the concurrency manager immediately spawns a new thread and passes the client file descriptor to that thread for complete request processing.</p>\n<p>This model provides excellent isolation between client connections - a slow or problematic client cannot block processing for other clients since each operates in its own thread. The implementation is straightforward since each thread can use blocking I/O operations without affecting other connections. Error handling is simplified because thread-local failures don&#39;t propagate to other client connections.</p>\n<p>However, thread-per-connection has significant scalability limitations. Each thread consumes system memory for its stack (typically 8MB on Linux), and thread creation overhead becomes substantial under high connection rates. The operating system&#39;s thread scheduler becomes a bottleneck when managing hundreds or thousands of concurrent threads. Many threads spend most of their time blocked on I/O operations, leading to inefficient resource utilization.</p>\n<p>The processing algorithm for thread-per-connection follows these steps:</p>\n<ol>\n<li>Main server thread accepts new client connection from TCP listener</li>\n<li>Concurrency manager checks current connection count against <code>max_connections</code> limit</li>\n<li>If limit not exceeded, manager calls <code>pthread_create</code> to spawn new handler thread</li>\n<li>New thread receives client file descriptor and address as startup parameters</li>\n<li>Thread calls <code>init_connection_context</code> to establish per-connection state tracking</li>\n<li>Thread enters complete HTTP request-response processing cycle independently</li>\n<li>Thread handles request parsing, file serving, and response transmission</li>\n<li>Upon completion or error, thread calls connection cleanup and terminates</li>\n<li>Main thread decrements active connection counter when notified of thread completion</li>\n</ol>\n<p>This model works best for scenarios with moderate connection concurrency (under 100 simultaneous connections) where simplicity and connection isolation are more important than maximum throughput.</p>\n<h4 id=\"thread-pool-model\">Thread Pool Model</h4>\n<p>The thread pool model pre-creates a fixed number of worker threads that share responsibility for processing client connections. Instead of creating threads dynamically, the concurrency manager maintains a pool of persistent threads that pull work from a shared connection queue.</p>\n<p>This approach eliminates thread creation overhead since worker threads are reused across multiple connections. The fixed thread count prevents system resource exhaustion even under heavy load, providing predictable performance characteristics. Thread pool size can be tuned based on available CPU cores and expected workload patterns.</p>\n<p>The trade-off is increased complexity in work distribution and resource sharing. Multiple threads must safely access shared data structures, requiring proper synchronization. Connection processing becomes less isolated since threads are reused, potentially allowing state from one connection to affect another if cleanup is incomplete.</p>\n<p>The thread pool processing algorithm coordinates work distribution among fixed resources:</p>\n<ol>\n<li>Server initialization creates <code>max_threads</code> worker threads in blocked state</li>\n<li>Each worker thread enters loop calling <code>dequeue_connection</code> on shared work queue</li>\n<li>Main server thread accepts new client connections as usual</li>\n<li>Concurrency manager adds new connections to work queue instead of creating threads</li>\n<li>Next available worker thread dequeues connection and processes complete request-response cycle</li>\n<li>Worker thread performs connection cleanup and returns to queue waiting state</li>\n<li>If work queue fills beyond capacity, new connections are rejected with appropriate error</li>\n<li>During shutdown, manager signals all worker threads to exit after completing current work</li>\n</ol>\n<p>Queue management requires careful synchronization to prevent race conditions. The connection queue uses mutex protection and condition variables to coordinate between the main thread adding work and worker threads removing work.</p>\n<table>\n<thead>\n<tr>\n<th>Queue Operation</th>\n<th>Synchronization</th>\n<th>Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>enqueue_connection</code></td>\n<td>Acquire queue mutex</td>\n<td>Add connection to tail, signal waiting workers</td>\n</tr>\n<tr>\n<td><code>dequeue_connection</code></td>\n<td>Acquire queue mutex</td>\n<td>Remove connection from head, block if empty</td>\n</tr>\n<tr>\n<td><code>queue_full</code></td>\n<td>Acquire queue mutex</td>\n<td>Check if queue size exceeds configured limit</td>\n</tr>\n<tr>\n<td><code>shutdown_queue</code></td>\n<td>Acquire queue mutex</td>\n<td>Mark queue closed, wake all waiting workers</td>\n</tr>\n</tbody></table>\n<p>Thread pool size tuning depends on workload characteristics. CPU-bound workloads benefit from thread count matching CPU core count. I/O-bound workloads (typical for file serving) can benefit from higher thread counts since threads spend time blocked on disk operations. Monitoring connection queue depth and thread utilization helps optimize pool size for specific deployment scenarios.</p>\n<h4 id=\"event-driven-model\">Event-Driven Model</h4>\n<p>The event-driven model uses a single thread with non-blocking I/O and I/O multiplexing to handle multiple connections simultaneously. Instead of dedicating threads to connections, this model monitors all active file descriptors using <code>select</code> or <code>poll</code> system calls and processes whichever connections have data ready.</p>\n<p>This approach achieves excellent scalability since it eliminates thread overhead entirely. A single event loop can handle thousands of simultaneous connections with minimal memory footprint. Context switching overhead is eliminated since only one thread runs, and the model naturally prioritizes connections with available data over blocked connections.</p>\n<p>The complexity trade-off is substantial. All I/O operations must be non-blocking, requiring careful state machine management to handle partial reads and writes. Application logic must be structured to avoid blocking operations, since any blocking call stalls processing for all connections. Error handling becomes more complex since connection failures must be managed within the shared event loop.</p>\n<p>The event-driven processing algorithm manages multiple connection states within a single thread:</p>\n<ol>\n<li>Server initialization sets all client sockets to non-blocking mode using <code>fcntl</code></li>\n<li>Main event loop calls <code>select</code> or <code>poll</code> with all active file descriptors</li>\n<li>System call blocks until at least one file descriptor has data ready</li>\n<li>Event loop iterates through ready file descriptors to determine required processing</li>\n<li>For server socket readiness, loop accepts new connection and adds to monitoring set</li>\n<li>For client socket readiness, loop determines connection state and processes next step</li>\n<li>Connection processing advances state machine: reading request, parsing, serving file, writing response</li>\n<li>Partial operations save state and yield control back to event loop for next iteration</li>\n<li>Completed connections are cleaned up and removed from monitoring set</li>\n<li>Loop continues until shutdown signal received</li>\n</ol>\n<p>Connection state management requires tracking progress through the HTTP request-response cycle:</p>\n<table>\n<thead>\n<tr>\n<th>Connection State</th>\n<th>Next Action</th>\n<th>Success Transition</th>\n<th>Error Transition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>STATE_READING_REQUEST</code></td>\n<td><code>read_complete_request</code> non-blocking</td>\n<td><code>STATE_PARSING_REQUEST</code></td>\n<td><code>STATE_ERROR_CLEANUP</code></td>\n</tr>\n<tr>\n<td><code>STATE_PARSING_REQUEST</code></td>\n<td><code>parse_http_request</code></td>\n<td><code>STATE_SERVING_FILE</code></td>\n<td><code>STATE_ERROR_RESPONSE</code></td>\n</tr>\n<tr>\n<td><code>STATE_SERVING_FILE</code></td>\n<td><code>serve_static_file</code></td>\n<td><code>STATE_WRITING_RESPONSE</code></td>\n<td><code>STATE_ERROR_RESPONSE</code></td>\n</tr>\n<tr>\n<td><code>STATE_WRITING_RESPONSE</code></td>\n<td><code>send</code> response non-blocking</td>\n<td><code>STATE_COMPLETE_CLEANUP</code></td>\n<td><code>STATE_ERROR_CLEANUP</code></td>\n</tr>\n<tr>\n<td><code>STATE_ERROR_RESPONSE</code></td>\n<td>Generate and send error</td>\n<td><code>STATE_COMPLETE_CLEANUP</code></td>\n<td><code>STATE_ERROR_CLEANUP</code></td>\n</tr>\n</tbody></table>\n<p>The event-driven model excels for high-concurrency scenarios with many simultaneous connections, particularly when most connections involve small file transfers or when memory usage must be minimized.</p>\n<h3 id=\"architecture-decision-records\">Architecture Decision Records</h3>\n<p>The concurrency management component involves several critical design decisions that significantly impact the server&#39;s scalability, complexity, and resource usage characteristics.</p>\n<blockquote>\n<p><strong>Decision: Primary Concurrency Model Selection</strong></p>\n<ul>\n<li><strong>Context</strong>: The server must handle multiple simultaneous client connections efficiently while remaining suitable for educational purposes. Different concurrency models have varying complexity, performance, and resource usage characteristics.</li>\n<li><strong>Options Considered</strong>: Thread-per-connection for simplicity, thread pool for balanced scalability, event-driven for maximum performance</li>\n<li><strong>Decision</strong>: Implement thread-per-connection as the primary model with thread pool as an advanced option</li>\n<li><strong>Rationale</strong>: Thread-per-connection provides the clearest learning progression from single-connection handling to concurrent processing. The blocking I/O model matches earlier milestones and doesn&#39;t require restructuring HTTP processing logic. Thread pool can be added incrementally to demonstrate resource management concepts.</li>\n<li><strong>Consequences</strong>: Initial implementation will have limited scalability (hundreds vs thousands of connections) but will be easier to debug and understand. Students can observe resource exhaustion directly and understand why more sophisticated models exist.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Concurrency Model</th>\n<th>Learning Value</th>\n<th>Implementation Complexity</th>\n<th>Scalability</th>\n<th>Resource Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Thread-per-connection</td>\n<td>High - clear progression</td>\n<td>Low - familiar blocking I/O</td>\n<td>Low - hundreds of connections</td>\n<td>High - thread overhead</td>\n</tr>\n<tr>\n<td>Thread pool</td>\n<td>Medium - resource management</td>\n<td>Medium - queue synchronization</td>\n<td>Medium - thousands of connections</td>\n<td>Medium - fixed thread count</td>\n</tr>\n<tr>\n<td>Event-driven</td>\n<td>Low - requires restructuring</td>\n<td>High - state machine complexity</td>\n<td>High - tens of thousands</td>\n<td>Low - single thread</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Connection Limit Enforcement</strong></p>\n<ul>\n<li><strong>Context</strong>: Unbounded connection acceptance can lead to resource exhaustion and system instability. The server needs protection against connection flooding while maintaining acceptable service for legitimate clients.</li>\n<li><strong>Options Considered</strong>: No limits (simplest), hard connection limit (reject new connections), connection queuing with timeout</li>\n<li><strong>Decision</strong>: Implement hard connection limit with immediate rejection of excess connections</li>\n<li><strong>Rationale</strong>: Hard limits provide predictable resource usage and prevent system overload. Immediate rejection gives clear feedback to clients and doesn&#39;t consume server resources on queued connections. This approach is easier to implement correctly than timeout-based queuing.</li>\n<li><strong>Consequences</strong>: Some legitimate clients may be rejected during traffic spikes, but server stability is guaranteed. Students learn about capacity planning and graceful degradation under load.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>Decision: Graceful Shutdown Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Server shutdown should complete in-flight requests when possible to avoid client errors and data corruption. However, shutdown cannot wait indefinitely for slow or malicious clients.</li>\n<li><strong>Options Considered</strong>: Immediate shutdown (close all connections), graceful with timeout (wait limited time), graceful without timeout (wait indefinitely)</li>\n<li><strong>Decision</strong>: Graceful shutdown with configurable timeout</li>\n<li><strong>Rationale</strong>: Graceful shutdown demonstrates proper resource cleanup and client consideration. Timeout prevents infinite waiting on problematic connections. Configurable timeout allows tuning based on expected request processing time.</li>\n<li><strong>Consequences</strong>: Shutdown sequence becomes more complex but more robust. Students learn about lifecycle management and the trade-offs between responsiveness and correctness.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>Decision: Thread Safety Approach</strong></p>\n<ul>\n<li><strong>Context</strong>: Multiple threads accessing shared server state (configuration, connection counters, logging) require synchronization to prevent data corruption and race conditions.</li>\n<li><strong>Options Considered</strong>: No shared state (fully isolated), fine-grained locking (per-data-structure mutexes), coarse-grained locking (single server mutex)</li>\n<li><strong>Decision</strong>: Minimal shared state with fine-grained locking for specific data structures</li>\n<li><strong>Rationale</strong>: Reducing shared state minimizes synchronization complexity and potential deadlock scenarios. Fine-grained locking allows better concurrency than coarse-grained approaches while remaining understandable for educational purposes.</li>\n<li><strong>Consequences</strong>: Each shared data structure requires careful analysis for thread safety requirements. Students learn about concurrent programming principles and common synchronization patterns.</li>\n</ul>\n</blockquote>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fconnection-lifecycle.svg\" alt=\"TCP Connection Lifecycle\"></p>\n<h3 id=\"common-concurrency-pitfalls\">Common Concurrency Pitfalls</h3>\n<p>Concurrent programming introduces subtle bugs and resource management issues that are particularly challenging for developers new to multi-threaded systems. Understanding these common pitfalls helps avoid frustrating debugging sessions and system instability.</p>\n<p>⚠️ <strong>Pitfall: Thread Resource Leaks</strong></p>\n<p>The most common issue in thread-per-connection implementations is failing to properly clean up thread resources when connections terminate. Each <code>pthread_create</code> call allocates system resources that must be explicitly released through <code>pthread_join</code> or <code>pthread_detach</code>. Failing to do so causes thread handles to accumulate in the kernel, eventually exhausting system thread limits.</p>\n<p>The symptom appears as the server initially handling connections correctly, then gradually becoming unable to create new threads. Error messages like &quot;Resource temporarily unavailable&quot; from <code>pthread_create</code> indicate thread handle exhaustion. This problem is insidious because it may not manifest during light testing but causes failures after handling hundreds or thousands of connections.</p>\n<p>The correct approach is to create threads in detached state using <code>pthread_detach</code> immediately after creation, or to use <code>pthread_attr_setdetachstate</code> with <code>PTHREAD_CREATE_DETACHED</code> when calling <code>pthread_create</code>. Detached threads automatically release their resources when they terminate, eliminating the need for explicit joining.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: Thread handle leaks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">pthread_t</span><span style=\"color:#E1E4E8\"> thread_id;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pthread_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">thread_id</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, handle_client, client_context);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Thread handle never cleaned up - resource leak!</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CORRECT: Detached thread cleans up automatically</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">pthread_t</span><span style=\"color:#E1E4E8\"> thread_id;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pthread_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">thread_id</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, handle_client, client_context);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pthread_detach</span><span style=\"color:#E1E4E8\">(thread_id);</span><span style=\"color:#6A737D\">  // Thread will clean up when it exits</span></span></code></pre></div>\n\n<p>⚠️ <strong>Pitfall: Race Conditions in Connection Counting</strong></p>\n<p>Tracking the number of active connections requires careful synchronization since multiple threads modify the connection counter simultaneously. A common mistake is using non-atomic operations to increment and decrement the counter, leading to race conditions where the count becomes inaccurate.</p>\n<p>Inaccurate connection counting can cause the server to accept more connections than intended (potentially causing resource exhaustion) or to reject connections when capacity is actually available (reducing throughput unnecessarily). The race condition typically manifests as connection counts that drift from the true value over time.</p>\n<p>Proper connection counting requires mutex protection around all counter modifications or use of atomic operations. The counter must be incremented when connections are accepted and decremented when connections complete, with both operations protected by the same synchronization mechanism.</p>\n<p>⚠️ <strong>Pitfall: Deadlock in Shutdown Sequence</strong></p>\n<p>Graceful shutdown sequences can create deadlock scenarios when the main thread waits for worker threads to complete while worker threads wait for shared resources that the main thread holds. This commonly occurs when the main thread holds a mutex while signaling shutdown, and worker threads need that same mutex to complete their cleanup.</p>\n<p>The symptom is a server that appears to hang during shutdown - it stops accepting new connections but never fully terminates. Worker threads block waiting for resources, while the main thread blocks waiting for worker threads to finish.</p>\n<p>The solution is to carefully order shutdown operations: first stop accepting new connections, then release any shared resources, then signal worker threads to shut down, and finally wait for worker thread completion. Never hold locks while waiting for thread completion.</p>\n<p>⚠️ <strong>Pitfall: Buffer Ownership Confusion</strong></p>\n<p>In concurrent servers, multiple threads may reference the same buffer memory for request data, response content, or configuration strings. Confusion about which thread owns (is responsible for freeing) shared buffers leads to either memory leaks or double-free errors.</p>\n<p>Memory ownership should be clearly defined and documented. The safest approach is to avoid sharing buffers between threads - each thread should work with its own copy of data. When sharing is necessary for performance reasons, use reference counting or clear ownership transfer protocols.</p>\n<p>⚠️ <strong>Pitfall: Non-Reentrant Function Usage</strong></p>\n<p>Many standard library functions are not thread-safe and cannot be called simultaneously from multiple threads. Common examples include <code>strtok</code> (use <code>strtok_r</code> instead), <code>gethostbyname</code> (use <code>getaddrinfo</code>), and global variable access in error handling functions like <code>errno</code>.</p>\n<p>Using non-reentrant functions in multi-threaded code can cause data corruption, incorrect results, or crashes that are difficult to reproduce since they depend on thread scheduling timing. These bugs often appear intermittently and may not manifest during development but cause failures in production.</p>\n<p>Always use the reentrant (_r suffix) versions of standard library functions when available, or protect non-reentrant functions with mutexes. Check function documentation for thread safety guarantees before using them in multi-threaded contexts.</p>\n<p>⚠️ <strong>Pitfall: Blocking Operations in Event-Driven Model</strong></p>\n<p>When implementing event-driven concurrency, any blocking operation (file I/O, DNS lookups, logging to slow storage) stalls the entire event loop and prevents processing of all other connections. This defeats the primary advantage of the event-driven model and can cause connection timeouts for clients that would otherwise be served successfully.</p>\n<p>Symptoms include good performance with few connections that degrades dramatically as connection count increases, or periodic freezes where all connections stop responding simultaneously. These issues often correlate with slow file system operations or network lookups.</p>\n<p>Event-driven implementations must use non-blocking I/O for all operations or delegate potentially blocking work to background threads. File operations should use <code>O_NONBLOCK</code> flags, and functions like <code>gethostbyname</code> should be replaced with asynchronous alternatives or offloaded to worker threads.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The concurrency management component bridges the gap between single-threaded HTTP processing and production-ready multi-client handling. This implementation guidance provides the necessary infrastructure and patterns to implement robust concurrent connection handling.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Threading</td>\n<td>POSIX pthread library with basic create/join</td>\n<td>Thread pool with condition variables</td>\n</tr>\n<tr>\n<td>Synchronization</td>\n<td>pthread_mutex for shared data</td>\n<td>pthread_rwlock for read-heavy data</td>\n</tr>\n<tr>\n<td>I/O Multiplexing</td>\n<td>select() for basic event handling</td>\n<td>epoll (Linux) or kqueue (BSD) for high performance</td>\n</tr>\n<tr>\n<td>Connection Tracking</td>\n<td>Fixed-size arrays with linear search</td>\n<td>Dynamic hash table with connection IDs</td>\n</tr>\n<tr>\n<td>Work Queuing</td>\n<td>Simple array with mutex protection</td>\n<td>Lock-free queue with atomic operations</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<p>The concurrency management component integrates with existing server structure while maintaining clear separation of concerns:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>http-server/\n  src/\n    main.c                     ← server startup and shutdown coordination\n    tcp_server.c               ← existing TCP connection acceptance\n    http_parser.c              ← existing HTTP request parsing  \n    file_handler.c             ← existing static file serving\n    concurrency_manager.c      ← NEW: connection dispatching and resource management\n    concurrency_manager.h      ← NEW: concurrency interface definitions\n    connection_context.c       ← NEW: per-connection state management\n    connection_context.h       ← NEW: connection tracking structures\n    thread_pool.c             ← NEW: worker thread management (optional)\n    thread_pool.h             ← NEW: thread pool interface (optional)\n  tests/\n    test_concurrency.c        ← concurrency-specific test cases\n    test_integration.c        ← multi-client integration tests\n  config/\n    server.conf               ← concurrency tuning parameters</code></pre></div>\n\n<p>This structure keeps concurrency concerns separate from HTTP processing logic while providing clear integration points for connection handling.</p>\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Complete Connection Context Management</strong> (connection_context.c):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"connection_context.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;time.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> init_connection_context</span><span style=\"color:#E1E4E8\">(ConnectionContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> client_fd</span><span style=\"color:#E1E4E8\">, sockaddr_in </span><span style=\"color:#FFAB70\">addr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(context, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(ConnectionContext));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context->client_fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> client_fd;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context->client_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> addr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context->connect_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context->thread_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pthread_self</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> cleanup_connection_context</span><span style=\"color:#E1E4E8\">(ConnectionContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> context</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (context->client_fd </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(context->client_fd);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        context->client_fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Clear sensitive data</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(context, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(ConnectionContext));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Thread-safe connection counter for resource tracking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> active_connection_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> pthread_mutex_t</span><span style=\"color:#E1E4E8\"> connection_count_mutex </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PTHREAD_MUTEX_INITIALIZER;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> increment_connection_count</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">connection_count_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> new_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> ++</span><span style=\"color:#E1E4E8\">active_connection_count;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">connection_count_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> new_count;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> decrement_connection_count</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">connection_count_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> new_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> --</span><span style=\"color:#E1E4E8\">active_connection_count;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">connection_count_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> new_count;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> get_active_connection_count</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">connection_count_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> active_connection_count;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">connection_count_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> count;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Complete Thread-Safe Logging Utility</strong> (logger.c):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;time.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;pthread.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdarg.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> pthread_mutex_t</span><span style=\"color:#E1E4E8\"> log_mutex </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PTHREAD_MUTEX_INITIALIZER;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#E1E4E8\"> FILE</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> log_file </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> init_logger</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> log_filename</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">log_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    log_file </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fopen</span><span style=\"color:#E1E4E8\">(log_filename, </span><span style=\"color:#9ECBFF\">\"a\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">log_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (log_file </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> :</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> log_message</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> level</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> format</span><span style=\"color:#E1E4E8\">, ...) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">log_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    time_t</span><span style=\"color:#E1E4E8\"> now </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> time_str</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    strftime</span><span style=\"color:#E1E4E8\">(time_str, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(time_str), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">Y-</span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">m-</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#FDAEB7;font-style:italic\"> %</span><span style=\"color:#9ECBFF\">H:</span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">M:</span><span style=\"color:#79B8FF\">%S</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">localtime</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">now));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FILE</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> output </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> log_file </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> log_file </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> stderr;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(output, </span><span style=\"color:#9ECBFF\">\"[</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">] [</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">] [Thread </span><span style=\"color:#79B8FF\">%lu</span><span style=\"color:#9ECBFF\">] \"</span><span style=\"color:#E1E4E8\">, time_str, level, </span><span style=\"color:#B392F0\">pthread_self</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    va_list args;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    va_start</span><span style=\"color:#E1E4E8\">(args, format);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vfprintf</span><span style=\"color:#E1E4E8\">(output, format, args);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    va_end</span><span style=\"color:#E1E4E8\">(args);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(output, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fflush</span><span style=\"color:#E1E4E8\">(output);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">log_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> cleanup_logger</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">log_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (log_file) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fclose</span><span style=\"color:#E1E4E8\">(log_file);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        log_file </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">log_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>Concurrency Manager Implementation</strong> (concurrency_manager.c):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"concurrency_manager.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"connection_context.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"http_parser.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"file_handler.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;pthread.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ConcurrencyModel model;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> max_connections;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> max_threads;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> shutdown_requested;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_mutex_t</span><span style=\"color:#E1E4E8\"> manager_mutex;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ConcurrencyManager;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Thread entry point for handling individual client connections</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> handle_client_connection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> arg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ConnectionContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ConnectionContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)arg;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize HTTP request and response structures using init_http_request/init_http_response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Read complete HTTP request from client socket using read_complete_request</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle partial reads and network timeouts appropriately</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Parse HTTP request using parse_http_request, handle parsing errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Serve static file content using serve_static_file from file_handler component</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Send HTTP response back to client, handle partial writes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Clean up request/response structures and connection context</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Decrement active connection count and log connection completion</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: For detached threads, perform final cleanup and return NULL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ConcurrencyManager</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> init_concurrency_manager</span><span style=\"color:#E1E4E8\">(ServerConfig</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">, ConcurrencyModel </span><span style=\"color:#FFAB70\">model</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Allocate ConcurrencyManager structure and initialize fields from config</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Initialize mutex for protecting shared manager state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Set concurrency model and resource limits from ServerConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If model is THREAD_POOL, initialize worker thread pool and work queue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use pthread_create to spawn config->max_threads worker threads</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If model is EVENT_DRIVEN, initialize file descriptor sets and event tracking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Initialize connection tracking data structures</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return initialized manager or NULL on failure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> start_connection_handler</span><span style=\"color:#E1E4E8\">(ConcurrencyManager</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> manager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> client_fd</span><span style=\"color:#E1E4E8\">, sockaddr_in </span><span style=\"color:#FFAB70\">client_addr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if shutdown has been requested, reject new connections if so</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check current connection count against max_connections limit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If limit exceeded, send HTTP 503 Service Unavailable and close client_fd</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create and initialize ConnectionContext for this client</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use init_connection_context with client_fd and client_addr</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Increment active connection count using thread-safe counter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Dispatch connection based on concurrency model:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - THREAD_PER_CONNECTION: Create detached thread with handle_client_connection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - THREAD_POOL: Add connection to work queue for worker threads</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - EVENT_DRIVEN: Add client_fd to monitored file descriptor set</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Log successful connection acceptance with client address</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return 0 on success, -1 on failure (cleanup connection on failure)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> shutdown_concurrency_manager</span><span style=\"color:#E1E4E8\">(ConcurrencyManager</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> manager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> graceful</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Set shutdown_requested flag to prevent new connection acceptance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If graceful shutdown requested, wait for active connections to complete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use configurable timeout to prevent infinite waiting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For THREAD_POOL model, signal worker threads to exit and join them</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: For EVENT_DRIVEN model, close event loop and cleanup file descriptor sets</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Close any remaining client connections and cleanup resources</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Log shutdown completion with final connection statistics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<p><strong>POSIX Thread Management:</strong></p>\n<ul>\n<li>Use <code>pthread_create</code> with <code>PTHREAD_CREATE_DETACHED</code> attribute to avoid thread handle leaks</li>\n<li>Always check <code>pthread_create</code> return value - thread creation can fail under high load</li>\n<li>Use <code>pthread_self()</code> for logging and debugging thread-specific operations</li>\n<li>Mutex initialization with <code>PTHREAD_MUTEX_INITIALIZER</code> is simpler than <code>pthread_mutex_init</code></li>\n</ul>\n<p><strong>Socket Configuration for Concurrency:</strong></p>\n<ul>\n<li>Set <code>SO_REUSEADDR</code> on server socket to allow quick restart during development</li>\n<li>Consider <code>TCP_NODELAY</code> for reducing latency on small HTTP responses</li>\n<li>Use <code>fcntl(fd, F_SETFL, O_NONBLOCK)</code> for event-driven model socket configuration</li>\n<li>Monitor <code>EMFILE</code> and <code>ENFILE</code> errors which indicate file descriptor exhaustion</li>\n</ul>\n<p><strong>Memory Management in Multithreaded Context:</strong></p>\n<ul>\n<li>Each thread needs its own request/response buffers to avoid sharing conflicts</li>\n<li>Use <code>malloc</code>/<code>free</code> carefully - consider memory pools for high-frequency allocation</li>\n<li>Clear sensitive data from buffers before freeing to prevent information leaks</li>\n<li>Consider using <code>valgrind --tool=helgrind</code> to detect thread safety issues</li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing thread-per-connection concurrency:</p>\n<p><strong>Verification Command:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Terminal 1: Start server</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./http_server</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#79B8FF\"> 8080</span><span style=\"color:#79B8FF\"> -r</span><span style=\"color:#9ECBFF\"> ./www</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#79B8FF\"> 10</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Terminal 2: Test concurrent connections</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..5}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> http://localhost:8080/test.html</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">wait</span></span></code></pre></div>\n\n<p><strong>Expected Behavior:</strong></p>\n<ul>\n<li>Server accepts all 5 simultaneous connections without blocking</li>\n<li>Each connection receives complete HTTP response with correct content</li>\n<li>Server logs show multiple thread IDs handling concurrent requests</li>\n<li>Connection count increases to 5 then decreases back to 0</li>\n<li>No resource leaks or error messages about thread creation failures</li>\n</ul>\n<p><strong>Signs of Problems:</strong></p>\n<ul>\n<li>Connections hang or timeout: Check for blocking I/O operations</li>\n<li>&quot;Resource temporarily unavailable&quot; errors: Thread cleanup issues or limits exceeded  </li>\n<li>Inconsistent responses: Race conditions in shared data structures</li>\n<li>Server crashes under load: Buffer overflows or memory corruption</li>\n</ul>\n<p><strong>Advanced Testing:</strong>\nUse <code>ab</code> (Apache Bench) for stress testing: <code>ab -n 100 -c 10 http://localhost:8080/</code>\nMonitor with <code>ps -eLf | grep http_server</code> to observe thread creation patterns</p>\n<h2 id=\"interactions-and-data-flow\">Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Integrates all Milestones 1-4 - describes how TCP server, HTTP parser, file handler, and concurrency manager work together to process complete client requests</p>\n</blockquote>\n<p>The interactions and data flow section reveals how our HTTP server&#39;s four main components orchestrate together to transform raw TCP connections into complete HTTP responses. Think of this as watching the backstage choreography of a theater production - while audiences see a seamless performance, the magic happens through precise coordination between lighting, sound, props, and actors, each playing their role at exactly the right moment with perfect timing.</p>\n<p>Understanding component interactions is crucial because distributed systems fail most often at the boundaries between components, not within individual components themselves. A TCP connection might succeed, HTTP parsing might work perfectly, file serving might execute flawlessly, and concurrency management might handle threading correctly, yet the system could still fail if these components don&#39;t communicate properly or if data transformations between them introduce errors.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Fsystem-overview.svg\" alt=\"HTTP Server System Overview\"></p>\n<p>The interaction patterns we&#39;ll explore demonstrate three fundamental distributed systems principles: <strong>separation of concerns</strong> (each component has a single, well-defined responsibility), <strong>loose coupling</strong> (components interact through clean interfaces rather than tight dependencies), and <strong>error isolation</strong> (failures in one component don&#39;t cascade uncontrollably to others). These principles become especially important as we scale from handling a single client to managing hundreds of concurrent connections.</p>\n<h3 id=\"component-communication-patterns\">Component Communication Patterns</h3>\n<p>Think of component communication like a hospital emergency room - when a patient arrives, there&#39;s a well-established protocol for how information flows between triage, doctors, nurses, lab technicians, and administrators. Each role has specific responsibilities, clear communication channels, and standardized handoff procedures. No single person needs to understand every other role in detail, but everyone must know exactly how to receive information, what to do with it, and where to send the results.</p>\n<p>Our HTTP server follows similar communication patterns, with each component serving as a specialist that receives structured input, performs its specific function, and produces structured output for the next component in the chain. This design enables us to test, debug, and modify components independently while maintaining system-wide coherence.</p>\n<h4 id=\"primary-communication-flow\">Primary Communication Flow</h4>\n<p>The primary communication pattern follows a <strong>request-response pipeline</strong> where data flows sequentially through components, with each component adding value and structure to the information stream. Unlike event-driven architectures where components communicate through asynchronous messages, our HTTP server uses <strong>synchronous handoffs</strong> - each component completes its work before passing control to the next component.</p>\n<table>\n<thead>\n<tr>\n<th>Source Component</th>\n<th>Target Component</th>\n<th>Data Passed</th>\n<th>Communication Method</th>\n<th>Error Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>TCP Server</td>\n<td>Concurrency Manager</td>\n<td><code>client_fd</code>, <code>client_addr</code></td>\n<td>Function call with <code>ConnectionContext*</code></td>\n<td>Returns error code, caller handles cleanup</td>\n</tr>\n<tr>\n<td>Concurrency Manager</td>\n<td>HTTP Parser</td>\n<td><code>client_fd</code>, raw request buffer</td>\n<td>Thread function parameter</td>\n<td>Exception/return code propagates to thread handler</td>\n</tr>\n<tr>\n<td>HTTP Parser</td>\n<td>File Handler</td>\n<td><code>HTTPRequest*</code> with parsed fields</td>\n<td>Struct pointer parameter</td>\n<td>Parser sets error flags, handler checks validity</td>\n</tr>\n<tr>\n<td>File Handler</td>\n<td>HTTP Response</td>\n<td><code>HTTPResponse*</code> with content</td>\n<td>Struct modification in-place</td>\n<td>Handler sets appropriate HTTP status codes</td>\n</tr>\n<tr>\n<td>HTTP Response</td>\n<td>TCP Server</td>\n<td>Response bytes, content length</td>\n<td>Buffer pointer and size</td>\n<td>TCP write errors trigger connection cleanup</td>\n</tr>\n</tbody></table>\n<p>The <strong>ownership transfer model</strong> governs memory management and resource responsibility as data flows between components. When the TCP server accepts a connection, it owns the client file descriptor and must ensure it gets closed. When it hands the connection to the concurrency manager, ownership transfers - the concurrency manager becomes responsible for cleanup. Similarly, when the HTTP parser allocates memory for request body content, it owns that memory until the request processing completes.</p>\n<h4 id=\"secondary-communication-patterns\">Secondary Communication Patterns</h4>\n<p>Beyond the primary request-response pipeline, components use several secondary communication patterns for configuration, monitoring, and resource management:</p>\n<p><strong>Configuration Propagation</strong>: The <code>ServerConfig</code> structure flows downward from the main server loop to each component, providing runtime parameters like document root, thread limits, and timeout values. This follows an <strong>immutable configuration</strong> pattern - once the server starts, configuration values don&#39;t change, eliminating the need for complex synchronization.</p>\n<p><strong>Resource Status Reporting</strong>: Components report their resource usage back to the concurrency manager through atomic counters and status flags. The concurrency manager tracks active connection counts, thread pool utilization, and memory usage to make scheduling decisions and prevent resource exhaustion.</p>\n<p><strong>Error Signal Propagation</strong>: When components encounter non-recoverable errors, they use a combination of return codes and shared error state to signal problems upstream. This enables graceful degradation - if the file handler can&#39;t read a requested file, it generates a 404 response rather than crashing the entire connection.</p>\n<blockquote>\n<p><strong>Decision: Synchronous Pipeline vs. Asynchronous Event-Driven Communication</strong></p>\n<ul>\n<li><strong>Context</strong>: Components need to coordinate request processing while maintaining clear boundaries and error handling</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Synchronous function calls with direct data passing</li>\n<li>Asynchronous message queues between components  </li>\n<li>Shared memory with event notifications</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Synchronous function calls with structured data passing</li>\n<li><strong>Rationale</strong>: Synchronous calls provide simpler error handling, easier debugging, and clearer resource ownership semantics for an educational project. Asynchronous approaches add complexity without significant benefits at this scale.</li>\n<li><strong>Consequences</strong>: Enables straightforward testing and debugging but limits scalability compared to fully asynchronous designs</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Communication Pattern</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Used For</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Synchronous Pipeline</td>\n<td>Simple error handling, clear ownership, easy debugging</td>\n<td>Blocking behavior, limited scalability</td>\n<td>Primary request processing</td>\n</tr>\n<tr>\n<td>Shared Configuration</td>\n<td>Consistent settings, no synchronization needed</td>\n<td>Requires server restart for changes</td>\n<td>Runtime parameters</td>\n</tr>\n<tr>\n<td>Status Reporting</td>\n<td>Real-time resource monitoring, automatic throttling</td>\n<td>Additional complexity, potential contention</td>\n<td>Resource management</td>\n</tr>\n<tr>\n<td>Error Propagation</td>\n<td>Graceful degradation, localized failure recovery</td>\n<td>Complex error code hierarchy</td>\n<td>Failure handling</td>\n</tr>\n</tbody></table>\n<h3 id=\"complete-request-response-cycle\">Complete Request-Response Cycle</h3>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Frequest-processing-flow.svg\" alt=\"Request Processing Sequence\"></p>\n<p>The complete request-response cycle represents the journey of a single HTTP request from the moment a TCP connection arrives until the response bytes are sent back to the client and the connection is cleaned up. Think of this like tracking a letter through the postal system - from the moment it&#39;s dropped in a mailbox, through sorting facilities, delivery routes, and final delivery, with each step adding information and moving the letter closer to its destination.</p>\n<p>Understanding this complete cycle is essential for debugging because most HTTP server issues manifest as problems in the handoffs between stages rather than within individual stages. A request might fail because the TCP server doesn&#39;t read enough bytes, because the HTTP parser mishandles headers, because the file handler can&#39;t resolve paths, or because the concurrency manager runs out of threads.</p>\n<h4 id=\"stage-1-connection-establishment-and-acceptance\">Stage 1: Connection Establishment and Acceptance</h4>\n<p>The request-response cycle begins when a client establishes a TCP connection to our server. The TCP server component, running in its main event loop, detects the incoming connection through the <code>accept()</code> system call and creates the foundational data structures that will carry information through the entire request processing pipeline.</p>\n<p><strong>Detailed Connection Acceptance Process:</strong></p>\n<ol>\n<li><p><strong>Socket Event Detection</strong>: The main server loop calls <code>accept()</code> on the listening socket <code>server_fd</code>, which blocks until a client attempts to connect. When <code>accept()</code> returns, it provides a new <code>client_fd</code> representing the specific client connection and a <code>sockaddr_in</code> structure containing the client&#39;s IP address and port.</p>\n</li>\n<li><p><strong>Connection Context Creation</strong>: The server calls <code>init_connection_context()</code> to create a <code>ConnectionContext</code> structure that will track this connection&#39;s lifecycle. This context includes the client file descriptor, client address information, connection timestamp, and eventually thread identification for debugging purposes.</p>\n</li>\n<li><p><strong>Resource Availability Check</strong>: Before proceeding with request processing, the server checks whether accepting this connection would exceed configured limits. It queries the concurrency manager&#39;s active connection count and compares it against <code>MAX_CONNECTIONS</code> from the <code>ServerConfig</code>.</p>\n</li>\n<li><p><strong>Connection Handoff</strong>: If resources are available, the server passes the <code>ConnectionContext</code> to the concurrency manager via <code>start_connection_handler()</code>. This transfer of ownership is critical - from this point forward, the concurrency manager becomes responsible for the client file descriptor and must ensure it gets closed even if errors occur.</p>\n</li>\n<li><p><strong>Failure Recovery</strong>: If resource limits are exceeded or if connection handoff fails, the TCP server immediately closes the <code>client_fd</code> and logs the failure. This prevents file descriptor leaks and ensures the client receives a connection refused error rather than hanging indefinitely.</p>\n</li>\n</ol>\n<p><strong>Data Structures at Connection Establishment:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Structure</th>\n<th>Field</th>\n<th>Value</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ConnectionContext</code></td>\n<td><code>client_fd</code></td>\n<td>Result of <code>accept()</code> call</td>\n<td>Socket for client communication</td>\n</tr>\n<tr>\n<td><code>ConnectionContext</code></td>\n<td><code>client_addr</code></td>\n<td>Client&#39;s <code>sockaddr_in</code></td>\n<td>Source IP and port for logging</td>\n</tr>\n<tr>\n<td><code>ConnectionContext</code></td>\n<td><code>connect_time</code></td>\n<td><code>time(NULL)</code></td>\n<td>Connection timestamp for timeout detection</td>\n</tr>\n<tr>\n<td><code>ConnectionContext</code></td>\n<td><code>thread_id</code></td>\n<td>Initially 0</td>\n<td>Will be set by concurrency manager</td>\n</tr>\n</tbody></table>\n<h4 id=\"stage-2-concurrency-dispatching-and-resource-allocation\">Stage 2: Concurrency Dispatching and Resource Allocation</h4>\n<p>Once the concurrency manager receives the connection context, it must decide how to handle the new connection based on the configured concurrency model. This stage is where our server&#39;s scalability characteristics are determined - poor decisions here can lead to resource exhaustion, thread thrashing, or connection starvation.</p>\n<p><strong>Thread-per-Connection Model Processing:</strong></p>\n<ol>\n<li><p><strong>Thread Creation</strong>: The concurrency manager calls <code>pthread_create()</code> to spawn a new thread with <code>handle_client_connection()</code> as the entry point and the <code>ConnectionContext*</code> as the parameter. The new thread receives a copy of the connection context and begins executing independently.</p>\n</li>\n<li><p><strong>Resource Tracking</strong>: The manager increments its active connection counter using atomic operations to prevent race conditions. This counter is checked by the TCP server before accepting new connections and is used for resource limit enforcement.</p>\n</li>\n<li><p><strong>Thread Configuration</strong>: The newly created thread is configured as detached using <code>pthread_detach()</code> so that it automatically cleans up its resources when the connection processing completes. This prevents the need for explicit <code>pthread_join()</code> calls.</p>\n</li>\n<li><p><strong>Error Recovery</strong>: If thread creation fails due to system resource limits, the concurrency manager immediately closes the <code>client_fd</code>, decrements any counters that were incremented, and returns an error code to the TCP server.</p>\n</li>\n</ol>\n<p><strong>Thread Pool Model Processing:</strong></p>\n<ol>\n<li><p><strong>Work Queue Insertion</strong>: Instead of creating a new thread, the concurrency manager calls <code>enqueue_connection()</code> to add the connection context to a shared work queue protected by a mutex. Worker threads continuously poll this queue for new work.</p>\n</li>\n<li><p><strong>Worker Thread Notification</strong>: After enqueuing the connection, the manager signals a condition variable to wake up sleeping worker threads. This ensures that connections don&#39;t sit in the queue longer than necessary.</p>\n</li>\n<li><p><strong>Queue Overflow Handling</strong>: If the work queue is full, indicating that all worker threads are busy and the queue has reached its maximum capacity, the manager can either block waiting for space or immediately reject the connection based on configuration.</p>\n</li>\n</ol>\n<p><strong>Resource State Tracking:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Resource Type</th>\n<th>Counter Variable</th>\n<th>Limit Check</th>\n<th>Cleanup Responsibility</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Active Connections</td>\n<td><code>active_connection_count</code></td>\n<td>Against <code>max_connections</code></td>\n<td>Connection thread</td>\n</tr>\n<tr>\n<td>Worker Threads</td>\n<td><code>thread_pool_size</code></td>\n<td>Against <code>max_threads</code></td>\n<td>Concurrency manager</td>\n</tr>\n<tr>\n<td>Work Queue Entries</td>\n<td><code>queue-&gt;size</code></td>\n<td>Against <code>queue-&gt;capacity</code></td>\n<td>Worker thread</td>\n</tr>\n<tr>\n<td>File Descriptors</td>\n<td>System-level tracking</td>\n<td>Against <code>ulimit -n</code></td>\n<td>Connection thread</td>\n</tr>\n</tbody></table>\n<h4 id=\"stage-3-http-request-reading-and-buffering\">Stage 3: HTTP Request Reading and Buffering</h4>\n<p>Once a worker thread (or dedicated connection thread) begins processing the connection, its first responsibility is reading the complete HTTP request from the client socket. This stage is more complex than it initially appears because TCP provides a byte stream, not message boundaries, and HTTP requests can arrive in multiple TCP segments or be split across several <code>read()</code> operations.</p>\n<p><strong>Request Reading Algorithm:</strong></p>\n<ol>\n<li><p><strong>Buffer Initialization</strong>: The connection handler allocates a request buffer of <code>MAX_REQUEST_SIZE</code> bytes (typically 8192) and initializes reading state variables including bytes read so far, buffer remaining, and completion status.</p>\n</li>\n<li><p><strong>Partial Read Loop</strong>: The handler calls <code>read_complete_request()</code> in a loop, which internally uses <code>recv()</code> to read bytes from <code>client_fd</code>. Each call to <code>recv()</code> may return fewer bytes than requested, requiring multiple iterations to read the complete request.</p>\n</li>\n<li><p><strong>Request Boundary Detection</strong>: As bytes are read, the handler scans for the HTTP request boundary, which is indicated by a blank line (two consecutive CRLF sequences: <code>\\r\\n\\r\\n</code>). For requests with message bodies, additional reading may be required based on the <code>Content-Length</code> header.</p>\n</li>\n<li><p><strong>Timeout Handling</strong>: Each read operation is performed with a socket timeout to prevent connections from hanging indefinitely. If the timeout expires before a complete request is received, the handler generates a 408 Request Timeout response.</p>\n</li>\n<li><p><strong>Buffer Overflow Protection</strong>: The handler continuously checks that the total bytes read doesn&#39;t exceed <code>MAX_REQUEST_SIZE</code>. If the request is too large, it generates a 413 Request Entity Too Large response and closes the connection.</p>\n</li>\n</ol>\n<p><strong>Request Buffer Management:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Request Buffer Layout:\n[HTTP Request Line]\\r\\n\n[Header1: Value1]\\r\\n  \n[Header2: Value2]\\r\\n\n...\n[HeaderN: ValueN]\\r\\n\n\\r\\n\n[Message Body (if present)]\n\nBuffer State Variables:\n- buffer_start: Points to beginning of allocated buffer\n- write_position: Current position for writing new bytes  \n- bytes_available: Remaining space in buffer\n- request_complete: Boolean indicating full request received</code></pre></div>\n\n<p>The critical challenge in this stage is handling <strong>partial reads</strong> correctly. Network conditions, TCP window sizes, and operating system buffering can cause HTTP requests to arrive in fragments. A robust implementation must accumulate these fragments while detecting request boundaries and preventing buffer overflows.</p>\n<h4 id=\"stage-4-http-request-parsing-and-validation\">Stage 4: HTTP Request Parsing and Validation</h4>\n<p>After the complete HTTP request is buffered, the connection handler passes the raw request data to the HTTP parser component. This stage transforms the unstructured byte stream into the structured <code>HTTPRequest</code> data structure that subsequent components can process safely.</p>\n<p><strong>Parsing Process Flow:</strong></p>\n<ol>\n<li><p><strong>Request Structure Initialization</strong>: The handler calls <code>init_http_request()</code> to create an <code>HTTPRequest</code> structure with safe default values and null pointers. This ensures that cleanup functions work correctly even if parsing fails partway through.</p>\n</li>\n<li><p><strong>Request Line Parsing</strong>: The parser calls <code>parse_request_line()</code> to extract the HTTP method, requested URL path, and protocol version from the first line of the request. This involves finding space characters that separate these three components and validating that each component contains legal characters.</p>\n</li>\n<li><p><strong>Header Parsing Loop</strong>: The parser enters a loop calling <code>parse_header_line()</code> for each subsequent line until it encounters the blank line that separates headers from the message body. Each header line is split on the first colon character, with header names normalized to lowercase and header values trimmed of whitespace.</p>\n</li>\n<li><p><strong>Message Body Handling</strong>: If the request includes a <code>Content-Length</code> header, the parser calls <code>parse_message_body()</code> to copy the specified number of bytes into the request&#39;s body buffer. This stage must handle cases where the content length is larger than remaining buffer space.</p>\n</li>\n<li><p><strong>Request Validation</strong>: After parsing completes, the parser performs semantic validation: checking that the HTTP method is supported, that the URL path doesn&#39;t contain illegal characters, and that required headers are present.</p>\n</li>\n</ol>\n<p><strong>Parsing State Validation:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Validation Check</th>\n<th>Condition</th>\n<th>Error Response</th>\n<th>Recovery Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Method Validity</td>\n<td>Method in allowed list</td>\n<td>405 Method Not Allowed</td>\n<td>Close connection</td>\n</tr>\n<tr>\n<td>Path Format</td>\n<td>No null bytes, valid UTF-8</td>\n<td>400 Bad Request</td>\n<td>Close connection</td>\n</tr>\n<tr>\n<td>Header Format</td>\n<td>Contains colon separator</td>\n<td>400 Bad Request</td>\n<td>Skip invalid header</td>\n</tr>\n<tr>\n<td>Content Length</td>\n<td>Numeric, non-negative</td>\n<td>400 Bad Request</td>\n<td>Close connection</td>\n</tr>\n<tr>\n<td>Protocol Version</td>\n<td>HTTP/1.0 or HTTP/1.1</td>\n<td>505 HTTP Version Not Supported</td>\n<td>Close connection</td>\n</tr>\n</tbody></table>\n<p>The parsing stage must be extremely robust because it processes untrusted input directly from network clients. Malformed requests, overly long headers, binary content in text fields, and other anomalies are common and must be handled gracefully without crashing the server or enabling security vulnerabilities.</p>\n<h4 id=\"stage-5-file-path-resolution-and-security-validation\">Stage 5: File Path Resolution and Security Validation</h4>\n<p>With a valid <code>HTTPRequest</code> structure in hand, the connection handler passes control to the file handler component. The file handler&#39;s primary responsibility is translating the HTTP request&#39;s URL path into a safe filesystem path within the configured document root, while preventing directory traversal attacks and other path-based security vulnerabilities.</p>\n<p><strong>Path Resolution Algorithm:</strong></p>\n<ol>\n<li><p><strong>URL Decoding</strong>: The file handler calls <code>url_decode()</code> to convert percent-encoded characters in the request path back to their original form. For example, <code>%20</code> becomes a space character, and <code>%2F</code> becomes a forward slash.</p>\n</li>\n<li><p><strong>Path Normalization</strong>: The handler calls <code>normalize_path()</code> to resolve relative path components like <code>.</code> (current directory) and <code>..</code> (parent directory). This step is crucial for security because it prevents clients from using sequences like <code>../../../etc/passwd</code> to escape the document root.</p>\n</li>\n<li><p><strong>Security Validation</strong>: The handler calls <code>validate_and_resolve_path()</code> to ensure that the normalized path, when combined with the document root, doesn&#39;t reference any location outside the configured document root directory.</p>\n</li>\n<li><p><strong>Filesystem Path Construction</strong>: If validation succeeds, the handler constructs the complete filesystem path by concatenating the document root with the normalized request path.</p>\n</li>\n<li><p><strong>File Existence and Permission Checks</strong>: The handler uses <code>stat()</code> to check whether the resolved path exists and whether the server process has read permissions. It also determines whether the path points to a regular file or a directory.</p>\n</li>\n</ol>\n<p><strong>Security Validation Details:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Security Check</th>\n<th>Purpose</th>\n<th>Implementation</th>\n<th>Failure Response</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Directory Traversal</td>\n<td>Prevent access outside document root</td>\n<td>Check resolved path starts with document root</td>\n<td>403 Forbidden</td>\n</tr>\n<tr>\n<td>Symbolic Link Following</td>\n<td>Prevent link-based escapes</td>\n<td>Use <code>lstat()</code> and validate link targets</td>\n<td>403 Forbidden</td>\n</tr>\n<tr>\n<td>Hidden File Access</td>\n<td>Respect Unix hidden file convention</td>\n<td>Check for filenames starting with &#39;.&#39;</td>\n<td>404 Not Found</td>\n</tr>\n<tr>\n<td>Permission Validation</td>\n<td>Ensure server can read file</td>\n<td>Use <code>access()</code> with R_OK flag</td>\n<td>403 Forbidden</td>\n</tr>\n<tr>\n<td>Path Length Limits</td>\n<td>Prevent buffer overflow attacks</td>\n<td>Check total path length against limits</td>\n<td>414 URI Too Long</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>The path resolution stage implements the principle of <strong>defense in depth</strong> - multiple independent security checks that each provide protection against different attack vectors. Even if one check fails, the others should still prevent unauthorized access.</p>\n</blockquote>\n<h4 id=\"stage-6-file-content-reading-and-response-generation\">Stage 6: File Content Reading and Response Generation</h4>\n<p>Once the file handler has validated the request path and confirmed that the requested resource exists and is accessible, it moves to the content serving phase. This stage reads the file contents, determines appropriate HTTP headers, and constructs the complete HTTP response structure.</p>\n<p><strong>Content Serving Process:</strong></p>\n<ol>\n<li><p><strong>MIME Type Detection</strong>: The handler calls <code>detect_mime_type()</code> to examine the file extension and determine the appropriate <code>Content-Type</code> header. This ensures that browsers handle different file types correctly - serving HTML files with <code>text/html</code>, images with <code>image/jpeg</code>, and so forth.</p>\n</li>\n<li><p><strong>File Size Calculation</strong>: The handler uses the <code>stat()</code> result from the previous stage to determine the file size, which becomes the <code>Content-Length</code> header value. This allows clients to display download progress and detect truncated responses.</p>\n</li>\n<li><p><strong>Response Structure Initialization</strong>: The handler calls <code>init_http_response()</code> to create an <code>HTTPResponse</code> structure with appropriate default values, then sets the status code to 200 OK for successful requests.</p>\n</li>\n<li><p><strong>Response Header Population</strong>: The handler calls <code>add_response_header()</code> multiple times to populate standard HTTP headers including <code>Content-Type</code>, <code>Content-Length</code>, <code>Last-Modified</code>, and <code>Server</code>. Each header addition is bounds-checked to prevent buffer overflows.</p>\n</li>\n<li><p><strong>File Content Reading</strong>: The handler calls <code>serve_file_content()</code> to read the file contents into the response body buffer. For large files, this may involve chunked reading to avoid memory exhaustion.</p>\n</li>\n</ol>\n<p><strong>Response Generation for Different Resource Types:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Resource Type</th>\n<th>Detection Method</th>\n<th>Response Generation</th>\n<th>Special Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Regular File</td>\n<td><code>S_ISREG()</code> macro on stat result</td>\n<td>Read file contents into response body</td>\n<td>Binary file detection, streaming for large files</td>\n</tr>\n<tr>\n<td>Directory</td>\n<td><code>S_ISDIR()</code> macro on stat result</td>\n<td>Generate HTML directory listing</td>\n<td>Sort entries, format sizes, security filtering</td>\n</tr>\n<tr>\n<td>Missing Resource</td>\n<td><code>stat()</code> returns -1 with <code>ENOENT</code></td>\n<td>Generate 404 Not Found response</td>\n<td>Include helpful error message</td>\n</tr>\n<tr>\n<td>Permission Denied</td>\n<td><code>stat()</code> returns -1 with <code>EACCES</code></td>\n<td>Generate 403 Forbidden response</td>\n<td>Log access attempt for security monitoring</td>\n</tr>\n</tbody></table>\n<p><strong>Directory Listing Generation</strong>: When the requested path maps to a directory rather than a file, the handler generates an HTML directory listing by calling <code>generate_directory_listing()</code>. This function reads directory entries, sorts them alphabetically, and formats them as clickable links within a basic HTML page structure.</p>\n<h4 id=\"stage-7-http-response-transmission-and-connection-cleanup\">Stage 7: HTTP Response Transmission and Connection Cleanup</h4>\n<p>The final stage of the request-response cycle involves serializing the <code>HTTPResponse</code> structure into the HTTP wire format and transmitting it back to the client through the TCP connection. This stage must handle partial writes, connection errors, and proper resource cleanup regardless of whether transmission succeeds or fails.</p>\n<p><strong>Response Transmission Process:</strong></p>\n<ol>\n<li><p><strong>Response Serialization</strong>: The connection handler constructs the complete HTTP response by formatting the status line, serializing all response headers, and appending the message body. The result is a single buffer containing the complete response in HTTP wire format.</p>\n</li>\n<li><p><strong>Partial Write Loop</strong>: The handler calls <code>send()</code> in a loop to transmit the response buffer to the client. Like reading, writing to TCP sockets can result in partial writes where only some bytes are sent in each operation.</p>\n</li>\n<li><p><strong>Write Timeout Handling</strong>: Each write operation is performed with a timeout to prevent connections from hanging if the client stops reading data. If a write timeout occurs, the handler logs the event and proceeds to connection cleanup.</p>\n</li>\n<li><p><strong>Connection State Management</strong>: After successful response transmission, the handler determines whether to keep the connection open for additional requests (HTTP keep-alive) or close it immediately. For this educational server, we typically close connections after each response.</p>\n</li>\n<li><p><strong>Resource Cleanup</strong>: The handler calls cleanup functions for all allocated resources: <code>cleanup_http_request()</code> for the parsed request, <code>cleanup_http_response()</code> for the response structure, <code>close()</code> for the client file descriptor, and <code>cleanup_connection_context()</code> for connection tracking.</p>\n</li>\n</ol>\n<p><strong>Cleanup Sequence and Error Recovery:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Cleanup Stage</th>\n<th>Resources Released</th>\n<th>Error Handling</th>\n<th>Consequences of Failure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTP Request Cleanup</td>\n<td>Request body buffer, header storage</td>\n<td>Always performed, errors logged</td>\n<td>Memory leak for single connection</td>\n</tr>\n<tr>\n<td>HTTP Response Cleanup</td>\n<td>Response body buffer, header storage</td>\n<td>Always performed, errors logged</td>\n<td>Memory leak for single connection</td>\n</tr>\n<tr>\n<td>Socket Closure</td>\n<td>Client file descriptor</td>\n<td>Check return value, log errors</td>\n<td>File descriptor leak</td>\n</tr>\n<tr>\n<td>Connection Context Cleanup</td>\n<td>Context structure, thread resources</td>\n<td>Always performed</td>\n<td>Memory leak, thread resource leak</td>\n</tr>\n<tr>\n<td>Concurrency Manager Notification</td>\n<td>Active connection count decrement</td>\n<td>Always performed</td>\n<td>Resource limit tracking error</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Critical Insight</strong>: The cleanup sequence must be performed in <strong>reverse dependency order</strong> - resources that depend on others must be cleaned up first. For example, the response body buffer must be freed before the response structure itself, and the socket must be closed before the connection context is cleaned up.</p>\n</blockquote>\n<p>The connection handler implements <strong>exception safety</strong> by using a cleanup pattern that works correctly even if errors occur during response transmission. All resource cleanup operations are designed to be <strong>idempotent</strong> - calling them multiple times or with already-cleaned resources produces safe, predictable results.</p>\n<h3 id=\"error-propagation-between-components\">Error Propagation Between Components</h3>\n<p>Error propagation in distributed systems is like a hospital&#39;s emergency response system - when something goes wrong, information about the problem must flow quickly and accurately to the right people who can take appropriate action. A misdiagnosed symptom or a communication failure between departments can turn a manageable situation into a crisis.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Ferror-handling-flow.svg\" alt=\"Error Handling and Recovery\"></p>\n<p>In our HTTP server, errors can originate from multiple sources: network problems (connection timeouts, socket errors), parsing failures (malformed HTTP requests, invalid headers), filesystem issues (missing files, permission denials), and concurrency problems (thread creation failures, resource exhaustion). Each type of error requires different handling strategies and generates different types of HTTP responses to clients.</p>\n<p>The error propagation design follows the principle of <strong>failing fast and failing safely</strong> - when components detect problems they can&#39;t handle locally, they immediately signal the error to calling components rather than attempting incomplete or potentially dangerous recovery. This prevents error conditions from cascading into more serious failures or security vulnerabilities.</p>\n<h4 id=\"error-classification-and-response-mapping\">Error Classification and Response Mapping</h4>\n<p>Our HTTP server categorizes errors into distinct classes based on their source and severity, with each class mapped to appropriate HTTP status codes and recovery strategies. This classification enables consistent error handling across components and ensures that clients receive meaningful error responses rather than generic failure messages.</p>\n<p><strong>System-Level Error Categories:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Error Category</th>\n<th>Source Components</th>\n<th>HTTP Status Mapping</th>\n<th>Recovery Strategy</th>\n<th>Example Scenarios</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Network Errors</td>\n<td>TCP Server, Connection Handler</td>\n<td>500 Internal Server Error</td>\n<td>Close connection, log error</td>\n<td>Socket creation failure, connection reset</td>\n</tr>\n<tr>\n<td>Protocol Errors</td>\n<td>HTTP Parser</td>\n<td>400 Bad Request, 405 Method Not Allowed</td>\n<td>Send error response, close connection</td>\n<td>Malformed request line, unsupported method</td>\n</tr>\n<tr>\n<td>Resource Errors</td>\n<td>File Handler</td>\n<td>404 Not Found, 403 Forbidden</td>\n<td>Send error response, continue connection</td>\n<td>Missing file, permission denied</td>\n</tr>\n<tr>\n<td>Capacity Errors</td>\n<td>Concurrency Manager</td>\n<td>503 Service Unavailable</td>\n<td>Reject connection or queue request</td>\n<td>Thread pool exhausted, connection limit reached</td>\n</tr>\n<tr>\n<td>Security Errors</td>\n<td>File Handler, HTTP Parser</td>\n<td>403 Forbidden, 400 Bad Request</td>\n<td>Send error response, log security event</td>\n<td>Directory traversal attempt, oversized request</td>\n</tr>\n</tbody></table>\n<p><strong>Error Severity Levels:</strong></p>\n<p>The server distinguishes between different severity levels to determine appropriate logging, alerting, and recovery actions:</p>\n<ul>\n<li><strong>Fatal Errors</strong>: System-level failures that prevent the server from accepting new connections (port binding failures, memory exhaustion)</li>\n<li><strong>Connection Errors</strong>: Problems that affect individual connections but don&#39;t impact overall server operation (client disconnections, parsing failures)  </li>\n<li><strong>Request Errors</strong>: Issues with specific requests that can be handled with appropriate HTTP error responses (file not found, method not allowed)</li>\n<li><strong>Warning Conditions</strong>: Unusual but manageable situations that should be logged for monitoring (approaching resource limits, slow client connections)</li>\n</ul>\n<h4 id=\"component-error-interfaces\">Component Error Interfaces</h4>\n<p>Each component in our HTTP server implements a consistent error reporting interface that enables upstream components to understand what went wrong and how to respond appropriately. This interface combines traditional C error codes with structured error information that can be used to generate detailed HTTP error responses.</p>\n<p><strong>TCP Server Error Interface:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Function</th>\n<th>Success Return</th>\n<th>Error Return</th>\n<th>Error Information</th>\n<th>Cleanup Required</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>create_server_socket()</code></td>\n<td>Valid file descriptor (&gt;= 0)</td>\n<td>-1</td>\n<td><code>errno</code> set to specific error</td>\n<td>None</td>\n</tr>\n<tr>\n<td><code>server_main_loop()</code></td>\n<td>Does not return</td>\n<td>void</td>\n<td>Logs fatal errors before exit</td>\n<td>Close server socket</td>\n</tr>\n<tr>\n<td><code>read_complete_request()</code></td>\n<td>Bytes read (&gt; 0)</td>\n<td>-1 for errors, 0 for EOF</td>\n<td><code>errno</code> or connection state</td>\n<td>Close client connection</td>\n</tr>\n</tbody></table>\n<p><strong>HTTP Parser Error Interface:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Function</th>\n<th>Success Return</th>\n<th>Error Return</th>\n<th>Error Information</th>\n<th>Cleanup Required</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>parse_http_request()</code></td>\n<td>0</td>\n<td>Error code constant</td>\n<td>Sets error fields in request structure</td>\n<td>Call <code>cleanup_http_request()</code></td>\n</tr>\n<tr>\n<td><code>parse_request_line()</code></td>\n<td>0</td>\n<td><code>PARSE_ERROR_INVALID_METHOD</code>, <code>PARSE_ERROR_INVALID_PATH</code></td>\n<td>Error details in parser state</td>\n<td>None</td>\n</tr>\n<tr>\n<td><code>parse_header_line()</code></td>\n<td>0</td>\n<td><code>PARSE_ERROR_MALFORMED_HEADER</code></td>\n<td>Line number and content in error state</td>\n<td>None</td>\n</tr>\n<tr>\n<td><code>parse_message_body()</code></td>\n<td>0</td>\n<td><code>PARSE_ERROR_BODY_TOO_LARGE</code></td>\n<td>Content length and buffer size in error state</td>\n<td>Free partial body allocation</td>\n</tr>\n</tbody></table>\n<p><strong>File Handler Error Interface:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Function</th>\n<th>Success Return</th>\n<th>Error Return</th>\n<th>Error Information</th>\n<th>Cleanup Required</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>validate_and_resolve_path()</code></td>\n<td>0</td>\n<td><code>PATH_ERROR_TRAVERSAL</code>, <code>PATH_ERROR_TOO_LONG</code></td>\n<td>Path details in error structure</td>\n<td>None</td>\n</tr>\n<tr>\n<td><code>serve_file_content()</code></td>\n<td>0</td>\n<td><code>FILE_ERROR_NOT_FOUND</code>, <code>FILE_ERROR_PERMISSION</code></td>\n<td>File path and system error in response</td>\n<td>Close file handle if opened</td>\n</tr>\n<tr>\n<td><code>detect_mime_type()</code></td>\n<td>0</td>\n<td>Non-zero for unknown types</td>\n<td>Uses default MIME type</td>\n<td>None</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Structured Error Codes vs. Exception-Style Error Handling</strong></p>\n<ul>\n<li><strong>Context</strong>: Components need to communicate detailed error information while maintaining C compatibility and performance</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Simple integer return codes with global error state</li>\n<li>Structured error objects with detailed context</li>\n<li>Exception-style error handling (not available in C)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Structured error codes with component-specific error information</li>\n<li><strong>Rationale</strong>: Provides detailed error context for generating appropriate HTTP responses while maintaining C compatibility and avoiding global state that complicates threading</li>\n<li><strong>Consequences</strong>: Requires more complex error handling code but enables better error responses and debugging</li>\n</ul>\n</blockquote>\n<h4 id=\"error-response-generation-pipeline\">Error Response Generation Pipeline</h4>\n<p>When any component detects an error condition, it must be transformed into an appropriate HTTP response that provides useful information to the client while avoiding information disclosure that could aid attackers. The error response generation pipeline ensures consistent error formatting and appropriate security filtering.</p>\n<p><strong>Error-to-Response Transformation Process:</strong></p>\n<ol>\n<li><p><strong>Error Context Collection</strong>: The component detecting the error collects relevant context information including error type, severity, affected resource, and any client-safe details that might help with debugging.</p>\n</li>\n<li><p><strong>Security Filtering</strong>: The error pipeline calls security filtering functions to remove sensitive information like internal file paths, system error messages that might reveal server configuration, and other implementation details.</p>\n</li>\n<li><p><strong>HTTP Status Code Selection</strong>: Based on the error category and specific error type, the pipeline selects the most appropriate HTTP status code from the standard set (400 Bad Request, 403 Forbidden, 404 Not Found, 500 Internal Server Error, etc.).</p>\n</li>\n<li><p><strong>Error Response Construction</strong>: The pipeline calls <code>generate_error_response()</code> to create a complete <code>HTTPResponse</code> structure with the appropriate status code, standard error headers, and a formatted error message body.</p>\n</li>\n<li><p><strong>Error Logging</strong>: Before returning the error response to the client, the pipeline logs the complete error details (including sensitive information) to the server&#39;s error log for debugging and security monitoring.</p>\n</li>\n</ol>\n<p><strong>Standard Error Response Format:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>HTTP/1.1 [Status Code] [Status Text]\nContent-Type: text/html\nContent-Length: [Body Length]\nConnection: close\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;&lt;title&gt;[Status Code] [Status Text]&lt;/title&gt;&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;[Status Code] [Status Text]&lt;/h1&gt;\n&lt;p&gt;[Client-safe error description]&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;[Server identification]&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre></div>\n\n<p><strong>Error Response Examples by Category:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Error Source</th>\n<th>Status Code</th>\n<th>Client Message</th>\n<th>Internal Log Message</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Path traversal attempt</td>\n<td>403 Forbidden</td>\n<td>&quot;Access to the requested resource is forbidden&quot;</td>\n<td>&quot;Directory traversal attempt: /app/docs/../../../etc/passwd from 192.168.1.100&quot;</td>\n</tr>\n<tr>\n<td>File not found</td>\n<td>404 Not Found</td>\n<td>&quot;The requested resource could not be found&quot;</td>\n<td>&quot;File not found: /var/www/html/missing.html (resolved from /missing.html)&quot;</td>\n</tr>\n<tr>\n<td>Request too large</td>\n<td>413 Request Entity Too Large</td>\n<td>&quot;Request size exceeds server limits&quot;</td>\n<td>&quot;Request size 16384 exceeds MAX_REQUEST_SIZE 8192 from 192.168.1.100&quot;</td>\n</tr>\n<tr>\n<td>Resource exhaustion</td>\n<td>503 Service Unavailable</td>\n<td>&quot;Server temporarily unable to handle request&quot;</td>\n<td>&quot;Thread pool exhausted: 10/10 threads active, connection queue full&quot;</td>\n</tr>\n</tbody></table>\n<h4 id=\"error-recovery-and-connection-state-management\">Error Recovery and Connection State Management</h4>\n<p>Error recovery in our HTTP server follows different strategies depending on the error severity and the stage of request processing where the error occurred. The goal is to maintain system stability while providing useful feedback to clients and maintaining clear resource cleanup responsibilities.</p>\n<p><strong>Connection State During Error Recovery:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Error Stage</th>\n<th>Connection State</th>\n<th>Recovery Action</th>\n<th>Resource Cleanup Required</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Pre-request (TCP connection)</td>\n<td>Connection established but no request received</td>\n<td>Send 408 Request Timeout, close connection</td>\n<td>Close client socket, free connection context</td>\n</tr>\n<tr>\n<td>Request parsing</td>\n<td>Partial request received, parsing failed</td>\n<td>Send 400 Bad Request, close connection</td>\n<td>Free request buffers, close socket</td>\n</tr>\n<tr>\n<td>File handling</td>\n<td>Valid request, file operation failed</td>\n<td>Send appropriate 4xx/5xx error, keep connection open</td>\n<td>Free response buffers, but keep connection</td>\n</tr>\n<tr>\n<td>Response transmission</td>\n<td>Response generated, send failed</td>\n<td>Log error, close connection</td>\n<td>Free all response resources, close socket</td>\n</tr>\n</tbody></table>\n<p><strong>Graceful Degradation Strategies:</strong></p>\n<p>When the server encounters resource exhaustion or other capacity-related errors, it implements graceful degradation rather than hard failures:</p>\n<ol>\n<li><p><strong>Connection Queuing</strong>: When the thread pool is full, new connections can be queued for a limited time rather than immediately rejected.</p>\n</li>\n<li><p><strong>Reduced Functionality</strong>: Under high load, the server might disable non-essential features like directory listings or detailed error messages to conserve resources.</p>\n</li>\n<li><p><strong>Request Prioritization</strong>: Static file requests for small resources might be prioritized over large file downloads during capacity constraints.</p>\n</li>\n<li><p><strong>Circuit Breaker Pattern</strong>: If filesystem errors reach a threshold, the server might temporarily return 503 Service Unavailable for all requests to prevent cascading failures.</p>\n</li>\n</ol>\n<p><strong>Error Propagation Chain Example:</strong></p>\n<p>Consider a request for <code>/documents/../../../etc/passwd</code> and how the error propagates through the system:</p>\n<ol>\n<li><strong>HTTP Parser</strong>: Successfully parses the request, creates valid <code>HTTPRequest</code> structure with path <code>/documents/../../../etc/passwd</code></li>\n<li><strong>File Handler</strong>: Calls <code>normalize_path()</code> which resolves to <code>/etc/passwd</code>, then <code>validate_and_resolve_path()</code> detects this is outside document root</li>\n<li><strong>Security Error Generation</strong>: File handler creates security error with type <code>PATH_ERROR_TRAVERSAL</code> and context information</li>\n<li><strong>Error Response Pipeline</strong>: Maps security error to 403 Forbidden status, generates safe client message</li>\n<li><strong>Security Logging</strong>: Logs full attack details including client IP, requested path, and resolved path to security log</li>\n<li><strong>Connection Continuation</strong>: Returns error response to client but keeps connection open for additional requests</li>\n</ol>\n<p>This error propagation chain demonstrates how security errors are handled with appropriate response codes while maintaining detailed internal logging for security monitoring and attack detection.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The interactions and data flow implementation requires careful orchestration of multiple components working together. This section provides the infrastructure and patterns needed to coordinate TCP server, HTTP parser, file handler, and concurrency manager components effectively.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component Integration</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Inter-component Communication</td>\n<td>Direct function calls with error codes</td>\n<td>Message passing with error queues</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Return codes with errno-style error state</td>\n<td>Structured error objects with context</td>\n</tr>\n<tr>\n<td>Resource Management</td>\n<td>Manual cleanup with goto error handling</td>\n<td>RAII-style cleanup with cleanup functions</td>\n</tr>\n<tr>\n<td>Data Flow Monitoring</td>\n<td>Simple printf debugging</td>\n<td>Structured logging with request tracing</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>http-server/\n  src/\n    main.c                      ← Main server loop and component coordination\n    connection_handler.c         ← Complete request-response cycle implementation\n    error_handling.c            ← Error response generation and propagation\n    \n  include/\n    server_types.h              ← All data structure definitions\n    component_interfaces.h      ← Function signatures for component communication\n    error_codes.h               ← Error type definitions and response mappings\n    \n  components/\n    tcp_server/                 ← TCP server component (from previous sections)\n    http_parser/                ← HTTP parser component  \n    file_handler/               ← File handler component\n    concurrency_manager/        ← Concurrency management component\n    \n  tests/\n    integration_tests.c         ← Full request-response cycle tests\n    error_handling_tests.c      ← Error propagation and recovery tests</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Complete Error Response Generation System</strong> (ready to use):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// error_handling.c - Complete error response infrastructure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;time.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"server_types.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"error_codes.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Error code to HTTP status mapping</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> error_code;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> http_status;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> status_text;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> client_message;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} error_mappings</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {PATH_ERROR_TRAVERSAL, </span><span style=\"color:#79B8FF\">403</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Forbidden\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Access to the requested resource is forbidden\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {PATH_ERROR_TOO_LONG, </span><span style=\"color:#79B8FF\">414</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"URI Too Long\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"The requested URI is too long\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {FILE_ERROR_NOT_FOUND, </span><span style=\"color:#79B8FF\">404</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Not Found\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"The requested resource could not be found\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {FILE_ERROR_PERMISSION, </span><span style=\"color:#79B8FF\">403</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Forbidden\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Access to the requested resource is forbidden\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {PARSE_ERROR_INVALID_METHOD, </span><span style=\"color:#79B8FF\">405</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Method Not Allowed\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"The request method is not supported\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {PARSE_ERROR_INVALID_PATH, </span><span style=\"color:#79B8FF\">400</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Bad Request\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"The request path contains invalid characters\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {PARSE_ERROR_MALFORMED_HEADER, </span><span style=\"color:#79B8FF\">400</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Bad Request\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"The request contains malformed headers\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {PARSE_ERROR_BODY_TOO_LARGE, </span><span style=\"color:#79B8FF\">413</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Request Entity Too Large\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Request size exceeds server limits\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {CAPACITY_ERROR_THREAD_POOL, </span><span style=\"color:#79B8FF\">503</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Service Unavailable\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Server temporarily unable to handle request\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {CAPACITY_ERROR_CONNECTION_LIMIT, </span><span style=\"color:#79B8FF\">503</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Service Unavailable\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Server connection limit reached\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">500</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Internal Server Error\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"An internal server error occurred\"</span><span style=\"color:#E1E4E8\">}</span><span style=\"color:#6A737D\"> // Default</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> generate_error_response</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> error_code</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> error_context</span><span style=\"color:#E1E4E8\">, HTTPResponse</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> response</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find appropriate error mapping</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> error_mapping</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> mapping </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#FFAB70\">error_mappings</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\"> // Default to last entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#FFAB70\">error_mappings</span><span style=\"color:#E1E4E8\">[i].error_code </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">error_mappings</span><span style=\"color:#E1E4E8\">[i].error_code </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> error_code) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            mapping </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#FFAB70\">error_mappings</span><span style=\"color:#E1E4E8\">[i];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize response structure</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    init_http_response</span><span style=\"color:#E1E4E8\">(response);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response->status_code </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mapping->http_status;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    strncpy</span><span style=\"color:#E1E4E8\">(response->status_text, mapping->status_text, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(response->status_text) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add standard headers</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    add_response_header</span><span style=\"color:#E1E4E8\">(response, </span><span style=\"color:#9ECBFF\">\"Content-Type\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"text/html\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    add_response_header</span><span style=\"color:#E1E4E8\">(response, </span><span style=\"color:#9ECBFF\">\"Connection\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"close\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Generate HTML error page</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> error_body</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(error_body, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(error_body),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;!DOCTYPE html></span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;html></span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;head>&#x3C;title></span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#79B8FF\"> %s</span><span style=\"color:#9ECBFF\">&#x3C;/title>&#x3C;/head></span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;body></span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;h1></span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#79B8FF\"> %s</span><span style=\"color:#9ECBFF\">&#x3C;/h1></span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;p></span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">&#x3C;/p></span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;hr></span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;p>HTTP Server/1.0&#x3C;/p></span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;/body></span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;/html></span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        mapping->http_status, mapping->status_text,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        mapping->http_status, mapping->status_text,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        mapping->client_message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set response body</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response->body_length </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strlen</span><span style=\"color:#E1E4E8\">(error_body);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response->body </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(response->body_length </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (response->body) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        strcpy</span><span style=\"color:#E1E4E8\">(response->body, error_body);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Add Content-Length header</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#FFAB70\"> content_length</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        snprintf</span><span style=\"color:#E1E4E8\">(content_length, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(content_length), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, response->body_length);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        add_response_header</span><span style=\"color:#E1E4E8\">(response, </span><span style=\"color:#9ECBFF\">\"Content-Length\"</span><span style=\"color:#E1E4E8\">, content_length);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Security event logging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> log_security_event</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> event_type</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> client_ip</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                       const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> request_path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> details</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    time_t</span><span style=\"color:#E1E4E8\"> now </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> timestamp</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    strftime</span><span style=\"color:#E1E4E8\">(timestamp, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(timestamp), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">Y-</span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">m-</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#FDAEB7;font-style:italic\"> %</span><span style=\"color:#9ECBFF\">H:</span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">M:</span><span style=\"color:#79B8FF\">%S</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">localtime</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">now));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">] SECURITY </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: client=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> path=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> details=</span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            timestamp, event_type, client_ip, request_path, details);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Request context for error tracking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ConnectionContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> connection;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HTTPRequest</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> request;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> client_ip</span><span style=\"color:#E1E4E8\">[INET_ADDRSTRLEN];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    time_t</span><span style=\"color:#E1E4E8\"> start_time;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} RequestContext;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> init_request_context</span><span style=\"color:#E1E4E8\">(RequestContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> ctx</span><span style=\"color:#E1E4E8\">, ConnectionContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> conn</span><span style=\"color:#E1E4E8\">, HTTPRequest</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> req</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx->connection </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> conn;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx->request </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> req;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx->start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Convert client address to string for logging</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    inet_ntop</span><span style=\"color:#E1E4E8\">(AF_INET, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">conn->client_addr.sin_addr, ctx->client_ip, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(ctx->client_ip));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Complete Connection Lifecycle Management</strong> (ready to use):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// connection_handler.c - Request-response cycle coordination</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"server_types.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"component_interfaces.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"error_codes.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Resource cleanup with error safety</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HTTPRequest</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> request;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HTTPResponse</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> response; </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ConnectionContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> connection;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> client_fd;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> cleanup_flags;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ResourceCleanupContext;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CLEANUP_REQUEST</span><span style=\"color:#E1E4E8\">  (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CLEANUP_RESPONSE</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CLEANUP_CONNECTION</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CLEANUP_SOCKET</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> cleanup_request_resources</span><span style=\"color:#E1E4E8\">(ResourceCleanupContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> cleanup</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (cleanup->cleanup_flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> CLEANUP_REQUEST </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> cleanup->request) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        cleanup_http_request</span><span style=\"color:#E1E4E8\">(cleanup->request);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        free</span><span style=\"color:#E1E4E8\">(cleanup->request);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cleanup->request </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (cleanup->cleanup_flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> CLEANUP_RESPONSE </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> cleanup->response) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        cleanup_http_response</span><span style=\"color:#E1E4E8\">(cleanup->response);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        free</span><span style=\"color:#E1E4E8\">(cleanup->response);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cleanup->response </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (cleanup->cleanup_flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> CLEANUP_SOCKET </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> cleanup->client_fd </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(cleanup->client_fd);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cleanup->client_fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (cleanup->cleanup_flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> CLEANUP_CONNECTION </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> cleanup->connection) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        cleanup_connection_context</span><span style=\"color:#E1E4E8\">(cleanup->connection);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        free</span><span style=\"color:#E1E4E8\">(cleanup->connection);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cleanup->connection </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Connection state machine for error recovery</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONNECTION_READING_REQUEST,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONNECTION_PARSING_REQUEST,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONNECTION_HANDLING_REQUEST,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONNECTION_SENDING_RESPONSE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONNECTION_CLEANUP,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONNECTION_ERROR</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ConnectionState;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> connection_state_names</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"READING_REQUEST\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"PARSING_REQUEST\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"HANDLING_REQUEST\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"SENDING_RESPONSE\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"CLEANUP\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"ERROR\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>Main Request-Response Orchestration</strong> (implement the TODOs):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Main connection handling thread function</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> handle_client_connection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> arg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ConnectionContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> conn_ctx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ConnectionContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)arg;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ResourceCleanupContext cleanup </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RequestContext req_ctx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ConnectionState state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CONNECTION_READING_REQUEST;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> error_code </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize cleanup context</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cleanup.connection </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> conn_ctx;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cleanup.client_fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> conn_ctx->client_fd;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cleanup.cleanup_flags </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CLEANUP_CONNECTION </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> CLEANUP_SOCKET;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Set socket timeout options for client_fd</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use setsockopt() with SO_RCVTIMEO and SO_SNDTIMEO</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set both receive and send timeouts to request_timeout_sec from ServerConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Allocate HTTPRequest and HTTPResponse structures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use malloc() and set cleanup flags appropriately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Call init_http_request() and init_http_response() for safe defaults</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Initialize request context for error tracking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Call init_request_context() with connection and request pointers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This enables detailed logging if errors occur</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Main request processing state machine</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (state </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> CONNECTION_CLEANUP </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> state </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> CONNECTION_ERROR) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        switch</span><span style=\"color:#E1E4E8\"> (state) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> CONNECTION_READING_REQUEST: {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 4: Read complete HTTP request from socket</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Call read_complete_request() with appropriate buffer and size limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Handle partial reads by calling in loop until complete request received</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Set error_code and state = CONNECTION_ERROR if reading fails</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#6A737D\">/* request reading succeeded */</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CONNECTION_PARSING_REQUEST;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    // TODO 5: Generate 408 Request Timeout or 400 Bad Request response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    // Use generate_error_response() with appropriate error code</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    // Set state = CONNECTION_SENDING_RESPONSE to send error back to client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> CONNECTION_PARSING_REQUEST: {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 6: Parse raw request data into HTTPRequest structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Call parse_http_request() with raw buffer and HTTPRequest pointer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Handle parsing errors by checking return code and setting error_code</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#6A737D\">/* parsing succeeded */</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CONNECTION_HANDLING_REQUEST;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    // TODO 7: Generate appropriate parsing error response (400, 405, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    // Use error_code returned from parser to select correct HTTP status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    // Log security events for suspicious requests (oversized, malformed)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> CONNECTION_HANDLING_REQUEST: {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 8: Process request through file handler</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Call serve_static_file() with request, response, and server config</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Handle file serving errors (404, 403) by checking return codes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#6A737D\">/* file serving succeeded */</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CONNECTION_SENDING_RESPONSE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    // TODO 9: File handler should have populated error response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    // Verify response structure contains appropriate error status code</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    // Log file access attempts for security monitoring</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> CONNECTION_SENDING_RESPONSE: {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 10: Send complete HTTP response back to client</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Serialize response structure into wire format (status line + headers + body)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Handle partial writes by calling send() in loop until all bytes transmitted</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Set appropriate error codes if transmission fails</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CONNECTION_CLEANUP;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 11: Perform cleanup based on cleanup context flags</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Call cleanup_request_resources() to release all allocated resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Ensure cleanup happens even if errors occurred during processing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Log connection completion with timing and status information</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 12: Notify concurrency manager of connection completion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Call decrement_connection_count() to update resource tracking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Enable server to accept new connections if limits were reached</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Error Propagation Integration Points</strong> (implement the TODOs):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Component error handling integration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> process_request_with_error_handling</span><span style=\"color:#E1E4E8\">(HTTPRequest</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> request</span><span style=\"color:#E1E4E8\">, HTTPResponse</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> response</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                       ServerConfig</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">, RequestContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> req_ctx</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Attempt file serving with comprehensive error capture</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Call serve_static_file() and capture both return code and any error context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check for security violations (directory traversal, permission issues)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#6A737D\">/* serve_static_file succeeded */</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Success</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Classify error type and severity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Map component-specific error codes to error categories</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Determine if error requires security logging or just standard error response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#6A737D\">/* error classification */</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> SECURITY_ERROR:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 3: Log security event with full context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Include client IP, requested path, attack type, timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Use log_security_event() with appropriate event classification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> RESOURCE_ERROR:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 4: Log resource access issue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Include file path (sanitized), permission details, filesystem error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Check if this indicates a configuration problem</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> CAPACITY_ERROR:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 5: Update server health metrics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Track resource exhaustion events for monitoring</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Consider implementing backpressure or rate limiting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Generate appropriate error response for client</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use generate_error_response() with error code and safe context information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Ensure response includes appropriate HTTP status and client-safe message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After implementing component integration:</strong></p>\n<ul>\n<li><strong>Command</strong>: <code>./http-server 8080 /var/www/html</code></li>\n<li><strong>Test</strong>: <code>curl -v http://localhost:8080/index.html</code></li>\n<li><strong>Expected</strong>: Complete HTTP response with headers, body content, proper connection handling</li>\n<li><strong>Debug</strong>: Check that all cleanup functions are called, no file descriptors leaked</li>\n</ul>\n<p><strong>After implementing error handling:</strong></p>\n<ul>\n<li><strong>Command</strong>: <code>curl -v http://localhost:8080/../../../etc/passwd</code></li>\n<li><strong>Expected</strong>: 403 Forbidden response, security event logged, connection remains open</li>\n<li><strong>Debug</strong>: Verify security logging captures attack attempts with client IP and details</li>\n</ul>\n<p><strong>After implementing complete request-response cycle:</strong></p>\n<ul>\n<li><strong>Concurrent Test</strong>: Run multiple <code>curl</code> commands simultaneously</li>\n<li><strong>Expected</strong>: All requests complete successfully, proper resource cleanup</li>\n<li><strong>Debug</strong>: Monitor with <code>lsof</code> to verify no file descriptor leaks under load</li>\n</ul>\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All Milestones 1-4 - provides comprehensive error handling strategy that spans TCP connections, HTTP parsing, file system operations, and concurrent request management</p>\n</blockquote>\n<p>Robust error handling forms the backbone of any production-quality HTTP server. Think of error handling as the hospital&#39;s emergency response system - when things go wrong, there must be clear protocols for diagnosis, treatment, and recovery that prevent cascading failures from bringing down the entire system. Just as a hospital has different response procedures for minor injuries versus life-threatening emergencies, our HTTP server must classify errors by severity and respond appropriately.</p>\n<p>The challenge in HTTP server error handling lies in the distributed nature of failures. Errors can originate from network connectivity issues, malformed client requests, filesystem problems, resource exhaustion, or concurrent access conflicts. Each error source requires different detection mechanisms, recovery strategies, and user-facing responses. The server must maintain service availability for healthy connections while gracefully handling problematic ones.</p>\n<h3 id=\"error-categories\">Error Categories</h3>\n<p>Understanding error classification provides the foundation for systematic error handling. Different error categories require different detection methods, recovery strategies, and HTTP status code mappings. This classification system enables consistent error handling across all server components.</p>\n<p><strong>Network Layer Errors</strong> represent the most fundamental category since they affect the basic communication channel between client and server. These errors occur during socket operations, connection management, and data transmission. Network errors often indicate external conditions beyond the server&#39;s control, such as client disconnections, network timeouts, or system resource limitations.</p>\n<p><strong>Protocol Layer Errors</strong> emerge during HTTP message parsing and protocol compliance checking. These errors indicate malformed requests, unsupported HTTP features, or protocol violations by clients. Unlike network errors, protocol errors usually result from client implementation problems or malicious requests rather than infrastructure issues.</p>\n<p><strong>Application Layer Errors</strong> occur during request processing, specifically file system operations and path resolution. These errors indicate problems with the requested resources, security violations, or server configuration issues. Application errors often require detailed logging for security monitoring since they may indicate attack attempts.</p>\n<p><strong>Resource Management Errors</strong> arise from system resource exhaustion, memory allocation failures, or concurrency limits being exceeded. These errors indicate server capacity issues and often require immediate load shedding or graceful degradation to maintain service for existing connections.</p>\n<p><strong>Security Errors</strong> represent a special category that spans multiple layers but requires elevated attention due to their potential security implications. Directory traversal attempts, permission violations, and suspicious request patterns fall into this category and trigger additional logging and monitoring.</p>\n<table>\n<thead>\n<tr>\n<th>Error Category</th>\n<th>Typical Causes</th>\n<th>Detection Method</th>\n<th>Immediate Response</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Network Layer</td>\n<td>Connection drops, socket errors, timeouts</td>\n<td>System call return codes, errno values</td>\n<td>Close connection, cleanup resources</td>\n<td>Retry for transient errors, log persistent issues</td>\n</tr>\n<tr>\n<td>Protocol Layer</td>\n<td>Malformed requests, invalid headers, unsupported methods</td>\n<td>Parser state machine errors, validation failures</td>\n<td>Generate 4xx error response</td>\n<td>Continue processing other connections</td>\n</tr>\n<tr>\n<td>Application Layer</td>\n<td>File not found, permission denied, path resolution failures</td>\n<td>File system API errors, security validation</td>\n<td>Generate 4xx/5xx error response</td>\n<td>Log security events, continue serving</td>\n</tr>\n<tr>\n<td>Resource Management</td>\n<td>Memory exhaustion, thread pool full, file descriptor limits</td>\n<td>Resource allocation failures, capacity checks</td>\n<td>Reject new connections, return 503 responses</td>\n<td>Implement backpressure, graceful degradation</td>\n</tr>\n<tr>\n<td>Security</td>\n<td>Directory traversal, suspicious patterns, access violations</td>\n<td>Path validation, pattern detection</td>\n<td>Block request, log security event</td>\n<td>Update security rules, potential IP blocking</td>\n</tr>\n</tbody></table>\n<p>The error category determines the appropriate logging level, response generation strategy, and resource cleanup requirements. Network layer errors typically require connection termination and resource cleanup but minimal logging since they&#39;re often transient. Protocol layer errors generate HTTP error responses and moderate logging for debugging purposes. Application layer errors trigger detailed request logging for troubleshooting. Resource management errors initiate capacity management procedures and high-priority alerts. Security errors activate comprehensive logging and monitoring workflows.</p>\n<blockquote>\n<p><strong>Critical Design Insight</strong>: Error classification must happen as early as possible in the request processing pipeline. Early classification enables appropriate resource allocation for error handling and prevents resource waste on requests that will ultimately fail. The classification also determines whether the error represents a recoverable condition or requires connection termination.</p>\n</blockquote>\n<h3 id=\"http-error-response-generation\">HTTP Error Response Generation</h3>\n<p>Converting internal system errors into appropriate HTTP status codes and error responses requires a systematic mapping strategy. The HTTP specification provides standardized status codes that communicate error conditions to clients in a universally understood format. However, the mapping between internal error states and HTTP responses must balance informativeness with security considerations.</p>\n<p><strong>Status Code Selection Strategy</strong> follows HTTP semantic conventions while considering security implications. The server must provide enough information for legitimate clients to understand and potentially retry requests, while avoiding information disclosure that could assist attackers. This balance influences both status code selection and error message content.</p>\n<p>The <code>generate_error_response</code> function serves as the central error response factory, ensuring consistent formatting and appropriate security filtering across all error conditions. This centralized approach prevents inconsistent error handling and ensures security policies apply uniformly.</p>\n<table>\n<thead>\n<tr>\n<th>Internal Error Type</th>\n<th>HTTP Status Code</th>\n<th>Status Text</th>\n<th>Response Body Strategy</th>\n<th>Security Considerations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>FILE_ERROR_NOT_FOUND</code></td>\n<td>404</td>\n<td>Not Found</td>\n<td>Generic &quot;Resource not found&quot; message</td>\n<td>Never reveal internal path structure</td>\n</tr>\n<tr>\n<td><code>FILE_ERROR_PERMISSION</code></td>\n<td>403</td>\n<td>Forbidden</td>\n<td>Generic &quot;Access denied&quot; message</td>\n<td>Don&#39;t distinguish between non-existent and forbidden</td>\n</tr>\n<tr>\n<td><code>PATH_ERROR_TRAVERSAL</code></td>\n<td>400</td>\n<td>Bad Request</td>\n<td>Generic &quot;Invalid request&quot; message</td>\n<td>Don&#39;t reveal security validation details</td>\n</tr>\n<tr>\n<td><code>PATH_ERROR_TOO_LONG</code></td>\n<td>414</td>\n<td>Request-URI Too Long</td>\n<td>Standard HTTP message</td>\n<td>Safe to be specific about length limits</td>\n</tr>\n<tr>\n<td><code>PARSE_ERROR_INVALID_METHOD</code></td>\n<td>405</td>\n<td>Method Not Allowed</td>\n<td>Include Allow header with supported methods</td>\n<td>Include proper Allow header for compliance</td>\n</tr>\n<tr>\n<td><code>PARSE_ERROR_MALFORMED_HEADER</code></td>\n<td>400</td>\n<td>Bad Request</td>\n<td>Generic &quot;Malformed request&quot; message</td>\n<td>Don&#39;t reveal parsing implementation details</td>\n</tr>\n<tr>\n<td><code>CAPACITY_ERROR_THREAD_POOL</code></td>\n<td>503</td>\n<td>Service Unavailable</td>\n<td>Include Retry-After header</td>\n<td>Indicate temporary condition to encourage retry</td>\n</tr>\n<tr>\n<td>Socket read/write errors</td>\n<td>500</td>\n<td>Internal Server Error</td>\n<td>Generic server error message</td>\n<td>Never expose internal error details</td>\n</tr>\n<tr>\n<td>Memory allocation failures</td>\n<td>500</td>\n<td>Internal Server Error</td>\n<td>Generic server error message</td>\n<td>Resource exhaustion details are internal</td>\n</tr>\n</tbody></table>\n<p>The error response generation process follows a structured approach to ensure consistency and security compliance. First, the error classification determines the appropriate HTTP status code family (4xx for client errors, 5xx for server errors). Second, the specific status code selection considers both HTTP semantics and security implications. Third, the response body generation applies security filtering to prevent information disclosure while providing actionable information for legitimate clients.</p>\n<p><strong>Error Response Structure</strong> maintains consistency across all error conditions. Every error response includes standard HTTP headers, properly formatted status lines, and sanitized response bodies. The response structure includes security headers that apply regardless of error type, ensuring consistent security posture.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> status_code;</span><span style=\"color:#6A737D\">           // HTTP status code (400-599 range)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> status_text</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">      // Standard HTTP reason phrase</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> error_type</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">       // Internal error classification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> sanitized_message</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\"> // Security-filtered user message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> include_retry_after;</span><span style=\"color:#6A737D\">   // Whether to include Retry-After header</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> retry_seconds;</span><span style=\"color:#6A737D\">         // Retry-After header value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ErrorResponse;</span></span></code></pre></div>\n\n<p>The error response generation algorithm ensures consistent processing while allowing customization for specific error types:</p>\n<ol>\n<li><strong>Error Classification</strong>: Determine the error category and internal error type from the failure condition</li>\n<li><strong>Status Code Mapping</strong>: Apply the status code mapping table to select the appropriate HTTP response code</li>\n<li><strong>Message Sanitization</strong>: Filter the error message to remove internal implementation details and potential security information</li>\n<li><strong>Header Generation</strong>: Include standard error response headers plus any error-specific headers like Retry-After or Allow</li>\n<li><strong>Response Assembly</strong>: Construct the complete HTTP response with proper formatting and content length calculation</li>\n<li><strong>Security Header Injection</strong>: Add security-related headers that apply to all error responses</li>\n<li><strong>Logging Coordination</strong>: Ensure error logging occurs with appropriate detail level before response transmission</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Centralized Error Response Generation</strong></p>\n<ul>\n<li><strong>Context</strong>: Error responses must be consistent across all server components while maintaining security filtering and proper HTTP compliance</li>\n<li><strong>Options Considered</strong>: Component-specific error handling, centralized error factory, hybrid approach with component customization</li>\n<li><strong>Decision</strong>: Centralized error response factory with configurable message templates</li>\n<li><strong>Rationale</strong>: Centralized generation ensures consistent security filtering, HTTP compliance, and response formatting while allowing customization through error type classification</li>\n<li><strong>Consequences</strong>: All components must use the central error factory, but this ensures security policies apply uniformly and reduces code duplication</li>\n</ul>\n</blockquote>\n<p><strong>Security-Aware Error Messaging</strong> prevents information disclosure while providing actionable feedback. The error message generation process applies multiple filtering layers to remove sensitive information that could assist attackers or reveal implementation details. Internal error messages contain full diagnostic information for logging and debugging, while external error messages provide only sanitized, user-appropriate information.</p>\n<p>The message sanitization process removes file system paths, internal error codes, memory addresses, configuration details, and other implementation-specific information from user-facing error messages. This filtering happens automatically in the <code>generate_error_response</code> function, ensuring consistent security posture regardless of which component detected the error.</p>\n<p><img src=\"/api/project/http-server-basic/architecture-doc/asset?path=diagrams%2Ferror-handling-flow.svg\" alt=\"Error Handling and Recovery\"></p>\n<h3 id=\"resource-cleanup-strategies\">Resource Cleanup Strategies</h3>\n<p>Proper resource cleanup becomes critical when errors occur, as failed request processing can leave allocated resources in an inconsistent state. Think of resource cleanup like the closing procedures at a restaurant - when something goes wrong during service, there must be clear protocols for clearing tables, returning borrowed items, and resetting the space for the next customer. Without systematic cleanup, resources accumulate and eventually exhaust system capacity.</p>\n<p>The challenge in error-time resource cleanup lies in maintaining consistency across multiple resource types while handling partial failures. A single request may involve socket file descriptors, heap-allocated memory, temporary buffers, file handles, thread resources, and connection context structures. When an error occurs partway through processing, some resources may be allocated while others remain uninitialized, requiring careful tracking and conditional cleanup.</p>\n<p><strong>Resource Ownership Tracking</strong> establishes clear responsibility for resource lifecycle management. Each resource must have a single owner responsible for both allocation and deallocation. The <code>ResourceCleanupContext</code> structure provides a centralized tracking mechanism that records resource allocation and coordinates cleanup activities across error conditions.</p>\n<table>\n<thead>\n<tr>\n<th>Resource Type</th>\n<th>Allocation Owner</th>\n<th>Cleanup Trigger</th>\n<th>Cleanup Method</th>\n<th>Failure Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Client Socket FD</td>\n<td>TCP Server Component</td>\n<td>Connection termination</td>\n<td><code>close()</code> system call</td>\n<td>Log error, continue cleanup</td>\n</tr>\n<tr>\n<td>Request Memory</td>\n<td>HTTP Parser Component</td>\n<td>Request processing completion</td>\n<td><code>free()</code> heap memory</td>\n<td>Mark as freed, continue</td>\n</tr>\n<tr>\n<td>Response Memory</td>\n<td>File Handler Component</td>\n<td>Response transmission completion</td>\n<td><code>free()</code> heap memory</td>\n<td>Mark as freed, continue</td>\n</tr>\n<tr>\n<td>File Handles</td>\n<td>File Handler Component</td>\n<td>File serving completion</td>\n<td><code>fclose()</code> file descriptor</td>\n<td>Log error, continue cleanup</td>\n</tr>\n<tr>\n<td>Thread Resources</td>\n<td>Concurrency Manager</td>\n<td>Thread termination</td>\n<td><code>pthread_detach()</code> or <code>pthread_join()</code></td>\n<td>Mark thread as orphaned</td>\n</tr>\n<tr>\n<td>Connection Context</td>\n<td>Connection Manager</td>\n<td>Connection lifecycle end</td>\n<td><code>cleanup_connection_context()</code></td>\n<td>Free partial state</td>\n</tr>\n</tbody></table>\n<p>The <code>ResourceCleanupContext</code> structure maintains comprehensive resource tracking throughout request processing. This tracking enables systematic cleanup even when errors occur at any point in the request handling pipeline. The cleanup context uses bit flags to indicate which resources require cleanup, allowing the cleanup process to skip unallocated resources safely.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HTTPRequest</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> request;</span><span style=\"color:#6A737D\">           // NULL if not allocated</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HTTPResponse</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> response;</span><span style=\"color:#6A737D\">         // NULL if not allocated  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ConnectionContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> connection;</span><span style=\"color:#6A737D\">  // NULL if not allocated</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> client_fd;</span><span style=\"color:#6A737D\">                 // -1 if not allocated</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> cleanup_flags;</span><span style=\"color:#6A737D\">             // Bitmask indicating allocated resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    time_t</span><span style=\"color:#E1E4E8\"> error_time;</span><span style=\"color:#6A737D\">             // When error occurred for timeout tracking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> error_context</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">       // Description of error location</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ResourceCleanupContext;</span></span></code></pre></div>\n\n<p>The cleanup flags use bit manipulation to efficiently track resource allocation status. This approach provides O(1) checking for resource status and enables atomic updates to allocation state. The flag definitions correspond to the major resource categories that require explicit cleanup.</p>\n<table>\n<thead>\n<tr>\n<th>Cleanup Flag</th>\n<th>Resource Indicates</th>\n<th>Set When</th>\n<th>Cleared When</th>\n<th>Used By</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>CLEANUP_REQUEST</code></td>\n<td>HTTPRequest allocated</td>\n<td><code>init_http_request()</code> succeeds</td>\n<td><code>cleanup_http_request()</code> completes</td>\n<td>HTTP Parser Component</td>\n</tr>\n<tr>\n<td><code>CLEANUP_RESPONSE</code></td>\n<td>HTTPResponse allocated</td>\n<td><code>init_http_response()</code> succeeds</td>\n<td><code>cleanup_http_response()</code> completes</td>\n<td>File Handler Component</td>\n</tr>\n<tr>\n<td><code>CLEANUP_CONNECTION</code></td>\n<td>ConnectionContext allocated</td>\n<td><code>init_connection_context()</code> succeeds</td>\n<td><code>cleanup_connection_context()</code> completes</td>\n<td>Connection Manager</td>\n</tr>\n<tr>\n<td><code>CLEANUP_SOCKET</code></td>\n<td>Client socket open</td>\n<td><code>accept()</code> succeeds</td>\n<td><code>close()</code> completes</td>\n<td>TCP Server Component</td>\n</tr>\n</tbody></table>\n<p><strong>Cleanup Sequencing</strong> ensures resources are released in the correct order to avoid dependency violations and potential crashes. Some resources depend on others remaining valid during cleanup, requiring careful ordering of deallocation operations. The cleanup sequence follows the reverse order of allocation, ensuring dependencies remain valid throughout the cleanup process.</p>\n<p>The systematic cleanup algorithm processes resources in dependency order while handling partial cleanup failures gracefully:</p>\n<ol>\n<li><strong>Error Detection and Context Initialization</strong>: When an error occurs, initialize a <code>ResourceCleanupContext</code> structure with the current resource allocation state and error details</li>\n<li><strong>Response Resource Cleanup</strong>: If response resources were allocated, call <code>cleanup_http_response()</code> to free response body memory and reset response structure</li>\n<li><strong>Request Resource Cleanup</strong>: If request resources were allocated, call <code>cleanup_http_request()</code> to free request body memory and header storage</li>\n<li><strong>File Handle Cleanup</strong>: If file handles remain open from file serving operations, close them and log any cleanup failures</li>\n<li><strong>Connection Context Cleanup</strong>: If connection context was allocated, call <code>cleanup_connection_context()</code> to free connection-specific memory and reset state</li>\n<li><strong>Socket Cleanup</strong>: If the client socket remains open, close the file descriptor and log the connection termination</li>\n<li><strong>Thread Resource Cleanup</strong>: If thread-specific resources were allocated, detach or join threads as appropriate for the concurrency model</li>\n<li><strong>Cleanup Verification</strong>: Verify all resources marked for cleanup have been properly released and log any cleanup failures for debugging</li>\n</ol>\n<blockquote>\n<p><strong>Decision: RAII-Style Cleanup with Explicit Context</strong></p>\n<ul>\n<li><strong>Context</strong>: C lacks automatic resource management, requiring explicit cleanup coordination across error paths</li>\n<li><strong>Options Considered</strong>: Manual cleanup at each error site, cleanup callback registration, centralized cleanup context</li>\n<li><strong>Decision</strong>: Centralized cleanup context with explicit resource tracking and ordered cleanup</li>\n<li><strong>Rationale</strong>: Centralized context ensures consistent cleanup across all error paths while explicit tracking prevents double-free errors and resource leaks</li>\n<li><strong>Consequences</strong>: All resource allocation must update the cleanup context, but this ensures systematic cleanup regardless of error location</li>\n</ul>\n</blockquote>\n<p><strong>Error Recovery vs. Connection Termination</strong> requires careful consideration of error severity and recovery feasibility. Some errors allow request processing to continue with degraded functionality, while others require immediate connection termination to prevent further problems. The decision depends on error type, resource state, and potential impact on other connections.</p>\n<p><strong>Recoverable Error Conditions</strong> allow the connection to remain open for additional requests after appropriate error response generation. Protocol-level errors like malformed headers or unsupported methods can generate error responses without affecting the underlying connection. File system errors like missing files or permission problems also allow connection reuse since they don&#39;t indicate connection-level problems.</p>\n<p><strong>Non-Recoverable Error Conditions</strong> require immediate connection termination to prevent cascading failures or security breaches. Network-level errors like socket read failures or connection timeouts indicate unreliable communication channels. Resource exhaustion errors suggest system-wide problems that may affect all connections. Security errors like directory traversal attempts may indicate malicious clients requiring immediate disconnection.</p>\n<table>\n<thead>\n<tr>\n<th>Error Condition</th>\n<th>Recovery Strategy</th>\n<th>Connection Fate</th>\n<th>Resource Priority</th>\n<th>Logging Level</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Malformed HTTP headers</td>\n<td>Generate 400 response</td>\n<td>Keep connection open</td>\n<td>Normal cleanup</td>\n<td>INFO</td>\n</tr>\n<tr>\n<td>File not found</td>\n<td>Generate 404 response</td>\n<td>Keep connection open</td>\n<td>Normal cleanup</td>\n<td>DEBUG</td>\n</tr>\n<tr>\n<td>Socket read failure</td>\n<td>Immediate cleanup</td>\n<td>Terminate connection</td>\n<td>Emergency cleanup</td>\n<td>WARN</td>\n</tr>\n<tr>\n<td>Memory allocation failure</td>\n<td>Generate 503 response</td>\n<td>Terminate connection</td>\n<td>Emergency cleanup</td>\n<td>ERROR</td>\n</tr>\n<tr>\n<td>Directory traversal attempt</td>\n<td>Generate 400 response</td>\n<td>Terminate connection</td>\n<td>Normal cleanup + security log</td>\n<td>SECURITY</td>\n</tr>\n<tr>\n<td>Thread pool exhaustion</td>\n<td>Generate 503 response</td>\n<td>Queue for later processing</td>\n<td>Delayed cleanup</td>\n<td>WARN</td>\n</tr>\n</tbody></table>\n<p>The recovery strategy selection process considers both immediate error handling and long-term system stability. Recoverable errors focus on providing appropriate client feedback while maintaining connection state for future requests. Non-recoverable errors prioritize system stability and security, sacrificing the individual connection to protect overall server health.</p>\n<p><strong>Emergency Cleanup Procedures</strong> handle situations where normal cleanup processes may fail or take too long. When system resources are critically low or security events require immediate response, emergency cleanup bypasses normal cleanup verification and focuses on rapidly releasing critical resources. Emergency cleanup trades thoroughness for speed, accepting some resource leakage to prevent system-wide failure.</p>\n<p>The emergency cleanup process prioritizes file descriptors and memory over cleanup verification, since these resources most directly impact system capacity. Connection context and thread resources receive lower priority since their leakage has less immediate system impact. Emergency cleanup includes aggressive timeout handling to prevent cleanup operations from blocking system recovery.</p>\n<h3 id=\"common-error-handling-pitfalls\">Common Error Handling Pitfalls</h3>\n<p>Understanding typical error handling mistakes helps developers avoid subtle bugs that can cause resource leaks, security vulnerabilities, or service disruption. These pitfalls often arise from the complexity of coordinating cleanup across multiple system components and the edge cases that occur under error conditions.</p>\n<p>⚠️ <strong>Pitfall: Double-Close of File Descriptors</strong></p>\n<p>One of the most common resource management errors involves closing the same file descriptor multiple times. This occurs when error handling code closes a socket or file handle, but subsequent cleanup code attempts to close the same descriptor again. The second close operation may succeed silently, close an unrelated file descriptor that was allocated after the first close, or generate an error that disrupts cleanup of other resources.</p>\n<p>The problem manifests when cleanup code doesn&#39;t properly track whether resources have already been released. Multiple code paths may each attempt to close the same descriptor, especially when error handling interrupts normal cleanup sequences. File descriptor reuse by the operating system means the second close may affect a completely different resource, leading to difficult-to-debug corruption.</p>\n<p>To prevent double-close errors, always set file descriptors to -1 after closing them and check for -1 before attempting to close. The cleanup functions should verify descriptor validity and update resource tracking immediately after successful close operations.</p>\n<p>⚠️ <strong>Pitfall: Incomplete Error Information in Log Messages</strong></p>\n<p>Error log messages often lack sufficient context for effective debugging, making it difficult to reproduce problems or understand their root causes. Generic error messages like &quot;request failed&quot; or &quot;file error&quot; provide little actionable information when troubleshooting server problems. Missing context information like client IP addresses, request paths, or error timing makes it nearly impossible to correlate errors with specific client behaviors or system conditions.</p>\n<p>This problem occurs when error handling code focuses on resource cleanup without capturing diagnostic information at the error site. By the time cleanup completes, much of the context that would help identify the error cause has been deallocated or overwritten. Error messages that only include system error codes without application-specific context force debugging efforts to rely on external log correlation.</p>\n<p>Effective error logging captures error context at the detection site before cleanup begins. Include client identification, request details, system state, and precise error location in all error log entries. Use structured logging formats that enable automated analysis and correlation across multiple error events.</p>\n<p>⚠️ <strong>Pitfall: Resource Cleanup Failures Blocking Shutdown</strong></p>\n<p>Cleanup operations themselves can fail, potentially blocking server shutdown or causing resource accumulation. When cleanup code encounters errors like filesystem permission problems or network timeouts, it may block indefinitely waiting for cleanup operations to complete. This blocking can prevent graceful shutdown and force administrators to kill server processes, potentially causing data loss or corruption.</p>\n<p>The problem becomes critical during high error rates when many cleanup operations execute simultaneously. If cleanup operations have unbounded timeouts or lack failure handling, a cascade of cleanup failures can overwhelm system resources and prevent recovery. Cleanup code that retries operations indefinitely can consume excessive CPU and memory resources even when the underlying problems are unrecoverable.</p>\n<p>Implement timeout-based cleanup with failure tolerance to prevent cleanup operations from blocking system recovery. Cleanup operations should have strict time limits and continue with partial cleanup when individual operations fail. Log cleanup failures for debugging but don&#39;t allow them to prevent overall resource release.</p>\n<p>⚠️ <strong>Pitfall: Security Information Disclosure in Error Messages</strong></p>\n<p>Error messages that include internal system information can provide attackers with valuable reconnaissance data about server implementation, filesystem structure, or security mechanisms. Error messages containing file paths, internal error codes, memory addresses, or configuration details help attackers understand system internals and identify potential attack vectors.</p>\n<p>This information disclosure often occurs when development-focused error messages reach production environments without proper filtering. Database error messages, filesystem paths, stack traces, and internal function names all provide implementation details that assist in attack planning. Even seemingly innocent information like exact file locations or error timing can reveal system structure to determined attackers.</p>\n<p>The solution requires systematic message sanitization that removes internal details while preserving actionable information for legitimate users. Implement separate error message systems for internal logging and external client communication, ensuring sensitive details never reach client-facing error responses.</p>\n<p>⚠️ <strong>Pitfall: Memory Leaks During Error Conditions</strong></p>\n<p>Memory allocated during request processing may not be properly freed when errors interrupt normal execution flow. This problem is particularly common in C where manual memory management requires explicit free operations for every malloc. Error conditions that cause early return from functions can skip cleanup code, leading to gradual memory consumption that eventually exhausts system resources.</p>\n<p>The issue compounds during high error rates when many requests encounter problems simultaneously. Each leaked allocation is typically small, making the problem difficult to detect during normal testing. However, sustained error conditions can accumulate significant memory usage that impacts overall system performance and stability.</p>\n<p>Implement systematic memory tracking using the cleanup context pattern to ensure all allocations are tracked and freed regardless of error conditions. Use tools like valgrind during development to detect memory leaks and verify cleanup code paths execute properly under error conditions.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The error handling implementation requires careful coordination across all server components to ensure consistent behavior and proper resource management. The following guidance provides complete implementations for infrastructure components and detailed skeletons for core error handling logic.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Error Logging</td>\n<td>Standard C printf to stderr</td>\n<td>Structured logging with syslog integration</td>\n</tr>\n<tr>\n<td>Resource Tracking</td>\n<td>Manual bit flags in cleanup context</td>\n<td>Automated RAII-style wrappers</td>\n</tr>\n<tr>\n<td>Error Response Generation</td>\n<td>Template-based string formatting</td>\n<td>JSON-based error response with schema validation</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>src/\n  error_handling.h          ← Error types, cleanup context, function declarations\n  error_handling.c          ← Core error handling and cleanup implementation\n  http_errors.h            ← HTTP status code mappings and response generation\n  http_errors.c            ← HTTP error response implementation\n  logging.h                ← Logging interface and security event handling\n  logging.c                ← Logging implementation with different output targets\n  tests/\n    test_error_handling.c   ← Unit tests for error classification and cleanup\n    test_http_errors.c      ← Integration tests for error response generation</code></pre></div>\n\n<p><strong>Complete Error Type Infrastructure:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// error_handling.h - Complete error type system ready for use</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;time.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;pthread.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Error category definitions for systematic classification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ERROR_CATEGORY_NETWORK,</span><span style=\"color:#6A737D\">     // Socket and TCP connection errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ERROR_CATEGORY_PROTOCOL,</span><span style=\"color:#6A737D\">    // HTTP parsing and protocol violations  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ERROR_CATEGORY_APPLICATION,</span><span style=\"color:#6A737D\"> // File system and request processing errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ERROR_CATEGORY_RESOURCE,</span><span style=\"color:#6A737D\">    // Memory, threads, and capacity errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ERROR_CATEGORY_SECURITY</span><span style=\"color:#6A737D\">     // Security violations and suspicious activity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ErrorCategory;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Specific error codes within each category</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Network layer errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NETWORK_ERROR_CONNECTION_LOST,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NETWORK_ERROR_SOCKET_READ,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NETWORK_ERROR_SOCKET_WRITE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NETWORK_ERROR_TIMEOUT,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Protocol layer errors  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PROTOCOL_ERROR_MALFORMED_REQUEST,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PROTOCOL_ERROR_INVALID_METHOD,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PROTOCOL_ERROR_UNSUPPORTED_VERSION,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PROTOCOL_ERROR_HEADER_TOO_LONG,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Application layer errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    APP_ERROR_FILE_NOT_FOUND,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    APP_ERROR_PERMISSION_DENIED,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    APP_ERROR_PATH_TRAVERSAL,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    APP_ERROR_PATH_TOO_LONG,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Resource management errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RESOURCE_ERROR_MEMORY_ALLOCATION,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RESOURCE_ERROR_THREAD_POOL_FULL,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RESOURCE_ERROR_FD_EXHAUSTION,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Security errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SECURITY_ERROR_SUSPICIOUS_PATH,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SECURITY_ERROR_RATE_LIMIT,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SECURITY_ERROR_BLOCKED_IP</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} SpecificErrorCode;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complete error information structure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ErrorCategory category;</span><span style=\"color:#6A737D\">           // High-level error classification</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SpecificErrorCode specific_code;</span><span style=\"color:#6A737D\">  // Detailed error identification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> system_errno;</span><span style=\"color:#6A737D\">                 // System error code if applicable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    time_t</span><span style=\"color:#E1E4E8\"> timestamp;</span><span style=\"color:#6A737D\">                 // When error occurred</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> client_ip</span><span style=\"color:#E1E4E8\">[INET_ADDRSTRLEN];</span><span style=\"color:#6A737D\">  // Client identification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> context_info</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">           // Detailed error context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> internal_message</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">       // Full diagnostic information</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> external_message</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">       // Sanitized user-facing message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ErrorInfo;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Resource cleanup context with comprehensive tracking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HTTPRequest</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> request;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HTTPResponse</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> response;  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ConnectionContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> connection;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> client_fd;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> cleanup_flags;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    time_t</span><span style=\"color:#E1E4E8\"> error_time;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> error_context</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_mutex_t</span><span style=\"color:#E1E4E8\"> cleanup_mutex;</span><span style=\"color:#6A737D\">    // Thread safety for cleanup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ResourceCleanupContext;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Infrastructure function declarations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ErrorInfo</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> create_error_info</span><span style=\"color:#E1E4E8\">(ErrorCategory </span><span style=\"color:#FFAB70\">category</span><span style=\"color:#E1E4E8\">, SpecificErrorCode </span><span style=\"color:#FFAB70\">code</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                            const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> context</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> log_error_with_context</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> ErrorInfo</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> error</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> log_security_event</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> event_type</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> client_ip</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> details</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> cleanup_request_resources</span><span style=\"color:#E1E4E8\">(ResourceCleanupContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> cleanup</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> emergency_cleanup</span><span style=\"color:#E1E4E8\">(ResourceCleanupContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> cleanup</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> timeout_sec</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Complete HTTP Error Response Infrastructure:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// http_errors.c - Complete HTTP error response system</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"http_errors.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;time.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Status code mapping table - complete and ready to use</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SpecificErrorCode error_code;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> http_status;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> status_text;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> template_message;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> include_retry_after;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ErrorMapping;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#E1E4E8\"> ErrorMapping error_mappings</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {APP_ERROR_FILE_NOT_FOUND, </span><span style=\"color:#79B8FF\">404</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Not Found\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"The requested resource was not found\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {APP_ERROR_PERMISSION_DENIED, </span><span style=\"color:#79B8FF\">403</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Forbidden\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Access to the requested resource is forbidden\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {APP_ERROR_PATH_TRAVERSAL, </span><span style=\"color:#79B8FF\">400</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Bad Request\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"The request contains invalid path information\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {PROTOCOL_ERROR_INVALID_METHOD, </span><span style=\"color:#79B8FF\">405</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Method Not Allowed\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"The request method is not supported\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {PROTOCOL_ERROR_MALFORMED_REQUEST, </span><span style=\"color:#79B8FF\">400</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Bad Request\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"The request is malformed\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {RESOURCE_ERROR_THREAD_POOL_FULL, </span><span style=\"color:#79B8FF\">503</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Service Unavailable\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"The server is temporarily overloaded\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {RESOURCE_ERROR_MEMORY_ALLOCATION, </span><span style=\"color:#79B8FF\">500</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Internal Server Error\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"An internal server error occurred\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {NETWORK_ERROR_TIMEOUT, </span><span style=\"color:#79B8FF\">408</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Request Timeout\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"The request timed out\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complete HTTP error response generation - ready to use</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> generate_error_response</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> status_code</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> error_message</span><span style=\"color:#E1E4E8\">, HTTPResponse</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> response</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize response structure</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    init_http_response</span><span style=\"color:#E1E4E8\">(response);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set status information</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response->status_code </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> status_code;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find appropriate status text</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> status_text </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"Unknown Error\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(error_mappings) </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ErrorMapping); i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">error_mappings</span><span style=\"color:#E1E4E8\">[i].http_status </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> status_code) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            status_text </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> error_mappings</span><span style=\"color:#E1E4E8\">[i].status_text;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    strncpy</span><span style=\"color:#E1E4E8\">(response->status_text, status_text, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(response->status_text) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create HTML error page body</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> html_body</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(html_body, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(html_body),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;!DOCTYPE html></span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;html>&#x3C;head>&#x3C;title></span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#79B8FF\"> %s</span><span style=\"color:#9ECBFF\">&#x3C;/title>&#x3C;/head></span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;body>&#x3C;h1></span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#79B8FF\"> %s</span><span style=\"color:#9ECBFF\">&#x3C;/h1></span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;p></span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">&#x3C;/p></span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"&#x3C;hr>&#x3C;p>HTTP Server&#x3C;/p>&#x3C;/body>&#x3C;/html></span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        status_code, status_text, status_code, status_text, error_message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate and copy response body</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response->body_length </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strlen</span><span style=\"color:#E1E4E8\">(html_body);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response->body </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(response->body_length </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (response->body) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        strcpy</span><span style=\"color:#E1E4E8\">(response->body, html_body);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add standard error response headers</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    add_response_header</span><span style=\"color:#E1E4E8\">(response, </span><span style=\"color:#9ECBFF\">\"Content-Type\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"text/html; charset=utf-8\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    add_response_header</span><span style=\"color:#E1E4E8\">(response, </span><span style=\"color:#9ECBFF\">\"Connection\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"close\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add Content-Length header</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> content_length</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(content_length, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(content_length), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, response->body_length);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    add_response_header</span><span style=\"color:#E1E4E8\">(response, </span><span style=\"color:#9ECBFF\">\"Content-Length\"</span><span style=\"color:#E1E4E8\">, content_length);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add security headers</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    add_response_header</span><span style=\"color:#E1E4E8\">(response, </span><span style=\"color:#9ECBFF\">\"X-Content-Type-Options\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"nosniff\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    add_response_header</span><span style=\"color:#E1E4E8\">(response, </span><span style=\"color:#9ECBFF\">\"X-Frame-Options\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"DENY\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Core Error Handling Skeleton:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// error_handling.c - Core logic to implement</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Error classification function - implement this</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ErrorCategory </span><span style=\"color:#B392F0\">classify_error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> system_errno</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> context</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check for network-related errno values (ECONNRESET, EPIPE, ETIMEDOUT)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Return ERROR_CATEGORY_NETWORK for connection issues</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check for file system errno values (ENOENT, EACCES, EPERM)  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Return ERROR_CATEGORY_APPLICATION for file access issues</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check for resource errno values (ENOMEM, EAGAIN, EMFILE)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Return ERROR_CATEGORY_RESOURCE for capacity issues</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Analyze context string for security indicators</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Look for \"..\" patterns, suspicious characters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Return ERROR_CATEGORY_SECURITY for potential attacks</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Default to ERROR_CATEGORY_PROTOCOL for parsing/HTTP issues</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         This handles cases not covered by system errno</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ERROR_CATEGORY_PROTOCOL;</span><span style=\"color:#6A737D\"> // Placeholder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complete error information creation - implement this  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ErrorInfo</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> create_error_info</span><span style=\"color:#E1E4E8\">(ErrorCategory </span><span style=\"color:#FFAB70\">category</span><span style=\"color:#E1E4E8\">, SpecificErrorCode </span><span style=\"color:#FFAB70\">code</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> context</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Allocate ErrorInfo structure with malloc, check for NULL return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set category, specific_code, and current timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Use time() function for timestamp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Copy context string to context_info field with bounds checking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Use strncpy to prevent buffer overflow</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Set system_errno to current errno value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Save errno immediately since other calls may modify it</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Generate internal_message with full diagnostic details</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Include errno string using strerror(), context, timestamp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Generate external_message with sanitized information  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Remove internal paths, error codes, implementation details</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Use security-safe generic messages for external consumption</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Placeholder - return allocated ErrorInfo*</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Resource cleanup with error handling - implement this</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> cleanup_request_resources</span><span style=\"color:#E1E4E8\">(ResourceCleanupContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> cleanup</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">cleanup) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> cleanup_errors </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Lock cleanup mutex for thread safety</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Use pthread_mutex_lock with error checking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check CLEANUP_RESPONSE flag and call cleanup_http_response()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Clear flag after successful cleanup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Increment cleanup_errors if cleanup fails</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check CLEANUP_REQUEST flag and call cleanup_http_request()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Clear flag after successful cleanup  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Increment cleanup_errors if cleanup fails</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check CLEANUP_CONNECTION flag and call cleanup_connection_context()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Clear flag after successful cleanup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Increment cleanup_errors if cleanup fails</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Check CLEANUP_SOCKET flag and close client_fd if valid (>= 0)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Set client_fd to -1 after successful close</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Clear CLEANUP_SOCKET flag</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Increment cleanup_errors if close fails</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Unlock cleanup mutex</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Use pthread_mutex_unlock</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return 0 for complete success, positive value for partial failures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Log cleanup errors for debugging but don't fail overall cleanup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> cleanup_errors;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Security Event Logging Infrastructure:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// logging.c - Complete security logging system</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;syslog.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize logging system - complete implementation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> init_logging_system</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> server_name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    openlog</span><span style=\"color:#E1E4E8\">(server_name, LOG_PID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> LOG_CONS, LOG_DAEMON);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Security event logging with context - complete implementation  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> log_security_event</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> event_type</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> client_ip</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                       const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> request_path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> details</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> log_message</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    time_t</span><span style=\"color:#E1E4E8\"> now </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> timestamp</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    strftime</span><span style=\"color:#E1E4E8\">(timestamp, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(timestamp), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">Y-</span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">m-</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#FDAEB7;font-style:italic\"> %</span><span style=\"color:#9ECBFF\">H:</span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">M:</span><span style=\"color:#79B8FF\">%S</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">localtime</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">now));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(log_message, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(log_message),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SECURITY_EVENT: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> | Time: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> | Client: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> | Path: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> | Details: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        event_type, timestamp, client_ip </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> client_ip </span><span style=\"color:#F97583\">:</span><span style=\"color:#9ECBFF\"> \"unknown\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        request_path </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> request_path </span><span style=\"color:#F97583\">:</span><span style=\"color:#9ECBFF\"> \"none\"</span><span style=\"color:#E1E4E8\">, details </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> details </span><span style=\"color:#F97583\">:</span><span style=\"color:#9ECBFF\"> \"none\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Log to syslog for centralized security monitoring</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    syslog</span><span style=\"color:#E1E4E8\">(LOG_WARNING, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, log_message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Also log to stderr for development/debugging</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[SECURITY] </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, log_message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Error logging with full context - complete implementation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> log_error_with_context</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> ErrorInfo</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">error) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> category_names</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"NETWORK\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"PROTOCOL\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"APPLICATION\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"RESOURCE\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"SECURITY\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> timestamp</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    strftime</span><span style=\"color:#E1E4E8\">(timestamp, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(timestamp), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">Y-</span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">m-</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#FDAEB7;font-style:italic\"> %</span><span style=\"color:#9ECBFF\">H:</span><span style=\"color:#FDAEB7;font-style:italic\">%</span><span style=\"color:#9ECBFF\">M:</span><span style=\"color:#79B8FF\">%S</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">             localtime</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">error->timestamp));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Determine log level based on category</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> log_level </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> LOG_INFO;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> (error->category) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> ERROR_CATEGORY_SECURITY: log_level </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> LOG_WARNING; </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> ERROR_CATEGORY_RESOURCE: log_level </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> LOG_ERR; </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> ERROR_CATEGORY_NETWORK: log_level </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> LOG_INFO; </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        default</span><span style=\"color:#E1E4E8\">: log_level </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> LOG_INFO; </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    syslog</span><span style=\"color:#E1E4E8\">(log_level, </span><span style=\"color:#9ECBFF\">\"ERROR: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> | Time: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> | Client: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> | Context: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> | Details: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">           category_names</span><span style=\"color:#E1E4E8\">[error->category], timestamp, error->client_ip,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           error->context_info, error->internal_message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoints:</strong></p>\n<p>After implementing error handling:</p>\n<ol>\n<li><strong>Test Error Classification</strong>: Create test requests that trigger each error category. Verify correct status codes:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Test file not found</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/nonexistent.html</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Should return 404 Not Found</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Test directory traversal  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/../etc/passwd</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Should return 400 Bad Request and log security event</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Test malformed request</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">   echo</span><span style=\"color:#79B8FF\"> -e</span><span style=\"color:#9ECBFF\"> \"INVALID HTTP REQUEST\\r\\n\\r\\n\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> nc</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Should return 400 Bad Request</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Verify Resource Cleanup</strong>: Use process monitoring to confirm no resource leaks:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Monitor file descriptor usage</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   lsof</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">pgrep</span><span style=\"color:#9ECBFF\"> http_server</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">|</span><span style=\"color:#B392F0\"> wc</span><span style=\"color:#79B8FF\"> -l</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Count should remain stable under error conditions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Check memory usage under error load</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   ps</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">pgrep</span><span style=\"color:#9ECBFF\"> http_server</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#79B8FF\">-o</span><span style=\"color:#9ECBFF\"> pid,vsz,rss</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Memory should not grow continuously during error tests</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Check Security Logging</strong>: Verify security events appear in logs:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Check syslog for security events</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   tail</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> /var/log/syslog</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> SECURITY_EVENT</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Trigger directory traversal and verify logging</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#9ECBFF\"> http://localhost:8080/../../../../etc/passwd</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Should see security event logged with client IP and path</span></span></code></pre></div>\n\n<p><strong>Debugging Tips:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Server crashes on error</td>\n<td>Double-free or NULL pointer access</td>\n<td>Run with valgrind, check cleanup order</td>\n<td>Add NULL checks, fix cleanup sequence</td>\n</tr>\n<tr>\n<td>Memory usage grows over time</td>\n<td>Resource leaks in error paths</td>\n<td>Use valgrind --leak-check=full</td>\n<td>Implement cleanup context tracking</td>\n</tr>\n<tr>\n<td>Clients receive generic errors</td>\n<td>Error message sanitization too aggressive</td>\n<td>Check error mapping table</td>\n<td>Add specific but safe error messages</td>\n</tr>\n<tr>\n<td>Security events not logged</td>\n<td>Logging initialization missing</td>\n<td>Check syslog configuration</td>\n<td>Call init_logging_system() at startup</td>\n</tr>\n<tr>\n<td>Cleanup hangs during shutdown</td>\n<td>Cleanup operations blocking indefinitely</td>\n<td>Add timeout monitoring</td>\n<td>Implement emergency_cleanup() with timeouts</td>\n</tr>\n</tbody></table>\n<h2 id=\"testing-strategy\">Testing Strategy</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All Milestones 1-4 - provides verification approach for TCP server basics, HTTP request parsing, static file serving, and concurrent connections with specific test scenarios and expected behaviors</p>\n</blockquote>\n<p>The testing strategy for an HTTP server requires a systematic approach that verifies functionality at each development milestone while building confidence in the system&#39;s reliability and correctness. Think of testing an HTTP server like quality assurance in a restaurant kitchen - you need to verify each station (prep, cooking, plating) works correctly in isolation, then test how they coordinate during a busy dinner rush. Each milestone represents a different level of complexity, from basic socket operations to handling multiple simultaneous diners (clients) with different dietary requirements (HTTP requests).</p>\n<p>The testing approach must balance thorough verification with practical implementation constraints. Unlike production web servers that undergo extensive automated testing suites, this educational HTTP server focuses on milestone-driven verification that builds understanding while ensuring correctness. The testing strategy emphasizes hands-on verification using standard tools that developers commonly use for HTTP server testing and debugging.</p>\n<h3 id=\"milestone-verification-checkpoints\">Milestone Verification Checkpoints</h3>\n<p>Each milestone represents a significant functional capability that must be thoroughly verified before proceeding to the next development phase. The checkpoint approach ensures that fundamental issues are caught early, preventing compound problems that become difficult to diagnose in later milestones. Think of these checkpoints like safety inspections at each floor of a building under construction - you must verify the foundation before adding the framework, and the framework before installing utilities.</p>\n<h4 id=\"milestone-1-tcp-server-basics-verification\">Milestone 1: TCP Server Basics Verification</h4>\n<p>The first milestone verification focuses on the fundamental networking capabilities that form the foundation for all HTTP functionality. At this stage, the server should demonstrate proper socket management, connection handling, and basic request-response cycles without any HTTP protocol awareness.</p>\n<p><strong>Socket Creation and Binding Verification:</strong></p>\n<p>The initial test verifies that the server can create and configure a listening socket correctly. Start the server and verify it binds to the specified port without errors. Use the <code>netstat</code> command to confirm the server socket is in the LISTEN state:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">netstat</span><span style=\"color:#79B8FF\"> -tlnp</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> :8080</span></span></code></pre></div>\n\n<p>Expected output should show a TCP socket in LISTEN state bound to port 8080. The server should accept the <code>SO_REUSEADDR</code> socket option, allowing rapid restart without encountering &quot;Address already in use&quot; errors. If binding fails, common causes include port conflicts with other services or insufficient privileges for ports below 1024.</p>\n<p><strong>Connection Acceptance Testing:</strong></p>\n<p>Test the server&#39;s ability to accept incoming TCP connections by establishing a raw TCP connection using telnet. This test verifies the accept loop and basic connection handling without HTTP protocol concerns:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">telnet</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span></span></code></pre></div>\n\n<p>Upon successful connection, telnet should report &quot;Connected to localhost&quot; and provide a command prompt. The server should accept the connection without blocking or crashing. Multiple sequential connections should work correctly, demonstrating proper cleanup of previous connections.</p>\n<p><strong>Basic Request-Response Cycle:</strong></p>\n<p>Send a simple string through the telnet connection and verify the server reads the data and responds with a hardcoded HTTP response. At this milestone, the server doesn&#39;t need to understand HTTP format - it should read any incoming data and respond with a fixed HTTP-formatted message:</p>\n<p>Expected response format:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>HTTP/1.1 200 OK\nContent-Type: text/plain\nContent-Length: 13\n\nHello, World!</code></pre></div>\n\n<p>The server should close the connection after sending the response, and telnet should indicate the connection was closed by the remote host.</p>\n<p><strong>Resource Management Verification:</strong></p>\n<p>Test proper cleanup by establishing multiple sequential connections and monitoring file descriptors. Use the <code>lsof</code> command to verify the server doesn&#39;t leak file descriptors:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">lsof</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#F97583\"> &#x3C;</span><span style=\"color:#9ECBFF\">server_process_i</span><span style=\"color:#E1E4E8\">d</span><span style=\"color:#F97583\">></span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> TCP</span></span></code></pre></div>\n\n<p>After each connection closes, the client file descriptor should disappear from the lsof output, indicating proper cleanup.</p>\n<p><strong>Error Handling at TCP Level:</strong></p>\n<p>Test error conditions specific to TCP operations:</p>\n<ul>\n<li>Start two server instances on the same port - the second should fail gracefully with an appropriate error message</li>\n<li>Kill the server process and attempt connection - clients should receive connection refused</li>\n<li>Send data to the server and immediately close the client connection - server should handle the disconnection without crashing</li>\n</ul>\n<h4 id=\"milestone-2-http-request-parsing-verification\">Milestone 2: HTTP Request Parsing Verification</h4>\n<p>The second milestone verification focuses on the server&#39;s ability to parse HTTP requests correctly and respond based on the parsed information. This represents a significant complexity increase from basic TCP handling to protocol-aware request processing.</p>\n<p><strong>HTTP Request Line Parsing:</strong></p>\n<p>Test the server&#39;s ability to extract method, path, and version from various HTTP request formats. Use curl to send requests with different methods and paths:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/test/path</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:8080/api/endpoint</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> HEAD</span><span style=\"color:#9ECBFF\"> http://localhost:8080/</span></span></code></pre></div>\n\n<p>The server should correctly parse each request and potentially log the extracted components. Even if file serving isn&#39;t implemented yet, the server should demonstrate it understands the differences between GET, POST, and HEAD requests and can extract the requested path.</p>\n<p><strong>HTTP Header Parsing Testing:</strong></p>\n<p>Send requests with various header configurations to test header parsing robustness:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -H</span><span style=\"color:#9ECBFF\"> \"Host: example.com\"</span><span style=\"color:#79B8FF\"> -H</span><span style=\"color:#9ECBFF\"> \"User-Agent: TestClient/1.0\"</span><span style=\"color:#9ECBFF\"> http://localhost:8080/</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -H</span><span style=\"color:#9ECBFF\"> \"Content-Type: application/json\"</span><span style=\"color:#9ECBFF\"> http://localhost:8080/</span></span></code></pre></div>\n\n<p>The server should parse headers into key-value pairs and handle common HTTP headers correctly. Test edge cases like headers with extra whitespace around values and headers spanning multiple lines (if supported).</p>\n<p><strong>Malformed Request Handling:</strong></p>\n<p>Test the server&#39;s response to malformed HTTP requests using telnet to send malformed data:</p>\n<ul>\n<li>Send incomplete request line: <code>GET /path</code> (missing HTTP version)</li>\n<li>Send malformed headers: <code>InvalidHeader without colon</code></li>\n<li>Send requests with invalid methods: <code>INVALID /path HTTP/1.1</code></li>\n</ul>\n<p>The server should respond with appropriate HTTP error codes (400 Bad Request) rather than crashing or hanging.</p>\n<p><strong>Content-Length and Body Handling:</strong></p>\n<p>If body parsing is implemented, test POST requests with message bodies:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#79B8FF\"> -d</span><span style=\"color:#9ECBFF\"> \"test data\"</span><span style=\"color:#79B8FF\"> -H</span><span style=\"color:#9ECBFF\"> \"Content-Type: text/plain\"</span><span style=\"color:#9ECBFF\"> http://localhost:8080/</span></span></code></pre></div>\n\n<p>The server should read the exact number of bytes specified in the Content-Length header and not attempt to read beyond the message body.</p>\n<h4 id=\"milestone-3-static-file-serving-verification\">Milestone 3: Static File Serving Verification</h4>\n<p>The third milestone verification tests the server&#39;s ability to serve files from the filesystem safely and correctly, implementing the core functionality expected from a static web server.</p>\n<p><strong>Basic File Serving:</strong></p>\n<p>Create a test directory structure with various file types:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>document_root/\n  index.html\n  style.css\n  script.js\n  images/\n    logo.png\n    background.jpg\n  documents/\n    readme.txt</code></pre></div>\n\n<p>Test file retrieval with curl:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/index.html</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/style.css</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/images/logo.png</span></span></code></pre></div>\n\n<p>Verify that:</p>\n<ul>\n<li>Files are served with correct Content-Type headers based on file extensions</li>\n<li>Content-Length headers match actual file sizes</li>\n<li>Binary files (images) are served without corruption</li>\n<li>File contents in the response body match the actual file contents exactly</li>\n</ul>\n<p><strong>Directory Listing Testing:</strong></p>\n<p>Test directory requests to verify directory listing functionality:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/images/</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/</span></span></code></pre></div>\n\n<p>If directory listings are implemented, verify they include:</p>\n<ul>\n<li>Links to all files and subdirectories</li>\n<li>Proper HTML formatting</li>\n<li>Parent directory navigation (..)</li>\n<li>File size and modification time information</li>\n</ul>\n<p><strong>404 Error Handling:</strong></p>\n<p>Test requests for non-existent files:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/nonexistent.html</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/missing/path/file.txt</span></span></code></pre></div>\n\n<p>The server should respond with:</p>\n<ul>\n<li>HTTP 404 Not Found status code</li>\n<li>Appropriate error page content</li>\n<li>Proper Content-Type header for the error response</li>\n</ul>\n<p><strong>Security Validation Testing:</strong></p>\n<p>Test directory traversal attack prevention:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/../../../etc/passwd</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/./../../sensitive_file</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> \"http://localhost:8080/%2e%2e%2f%2e%2e%2fpasswd\"</span></span></code></pre></div>\n\n<p>The server should reject these requests with 403 Forbidden or 400 Bad Request responses, never serving files outside the document root directory.</p>\n<p><strong>MIME Type Detection Verification:</strong></p>\n<p>Test various file types to verify correct MIME type detection:</p>\n<table>\n<thead>\n<tr>\n<th>File Extension</th>\n<th>Expected MIME Type</th>\n<th>Test Command</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>.html</td>\n<td>text/html</td>\n<td><code>curl -I http://localhost:8080/test.html</code></td>\n</tr>\n<tr>\n<td>.css</td>\n<td>text/css</td>\n<td><code>curl -I http://localhost:8080/style.css</code></td>\n</tr>\n<tr>\n<td>.js</td>\n<td>application/javascript</td>\n<td><code>curl -I http://localhost:8080/script.js</code></td>\n</tr>\n<tr>\n<td>.png</td>\n<td>image/png</td>\n<td><code>curl -I http://localhost:8080/image.png</code></td>\n</tr>\n<tr>\n<td>.jpg</td>\n<td>image/jpeg</td>\n<td><code>curl -I http://localhost:8080/photo.jpg</code></td>\n</tr>\n<tr>\n<td>.txt</td>\n<td>text/plain</td>\n<td><code>curl -I http://localhost:8080/readme.txt</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"milestone-4-concurrent-connections-verification\">Milestone 4: Concurrent Connections Verification</h4>\n<p>The fourth milestone verification tests the server&#39;s ability to handle multiple simultaneous client connections without blocking or corrupting responses. This represents the most complex testing scenario, requiring coordination of multiple clients and verification of correct concurrent behavior.</p>\n<p><strong>Sequential Connection Handling:</strong></p>\n<p>Before testing true concurrency, verify that multiple sequential connections work correctly:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..10}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> http://localhost:8080/index.html</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/null</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  echo</span><span style=\"color:#9ECBFF\"> \"Request </span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\"> completed\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span></code></pre></div>\n\n<p>All requests should complete successfully without errors or connection failures.</p>\n<p><strong>Basic Concurrent Connection Testing:</strong></p>\n<p>Test multiple simultaneous connections using background processes:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..5}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> http://localhost:8080/index.html</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> response_</span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\">.html</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">wait</span></span></code></pre></div>\n\n<p>Verify that all response files contain identical, correct content and no responses are corrupted or incomplete due to concurrent access.</p>\n<p><strong>Connection Limit Testing:</strong></p>\n<p>Test the server&#39;s behavior when the maximum connection limit is reached:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Create connections that stay open briefly</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..20}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  (</span><span style=\"color:#B392F0\">sleep</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> http://localhost:8080/</span><span style=\"color:#E1E4E8\">) &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span></code></pre></div>\n\n<p>The server should either queue additional connections (thread pool model) or reject excess connections gracefully rather than crashing or hanging.</p>\n<p><strong>Resource Management Under Load:</strong></p>\n<p>Monitor server resource usage during concurrent load:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Monitor file descriptors</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">watch</span><span style=\"color:#9ECBFF\"> \"lsof -p &#x3C;server_pid> | wc -l\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Monitor threads (if using threading)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">watch</span><span style=\"color:#9ECBFF\"> \"ps -T -p &#x3C;server_pid>\"</span></span></code></pre></div>\n\n<p>Verify that:</p>\n<ul>\n<li>File descriptor count returns to baseline after connections close</li>\n<li>Thread count remains within configured limits</li>\n<li>Memory usage doesn&#39;t grow unboundedly</li>\n<li>No zombie processes are created</li>\n</ul>\n<h3 id=\"testing-tools-and-techniques\">Testing Tools and Techniques</h3>\n<p>The testing strategy relies on a combination of standard HTTP client tools, low-level networking utilities, and custom testing scripts to verify functionality across all complexity levels. Each tool serves specific purposes in the verification process, from basic connectivity testing to detailed HTTP protocol validation.</p>\n<h4 id=\"command-line-http-clients\">Command-Line HTTP Clients</h4>\n<p><strong>curl - Primary HTTP Testing Tool:</strong></p>\n<p>curl serves as the primary HTTP testing client due to its comprehensive HTTP protocol support and detailed output capabilities. The verbose flag (<code>-v</code>) provides essential debugging information including request headers, response headers, and connection details.</p>\n<p>Common curl usage patterns for HTTP server testing:</p>\n<table>\n<thead>\n<tr>\n<th>Test Purpose</th>\n<th>curl Command</th>\n<th>Key Flags Explained</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Basic request</td>\n<td><code>curl -v http://localhost:8080/</code></td>\n<td><code>-v</code> shows request/response headers</td>\n</tr>\n<tr>\n<td>HEAD request</td>\n<td><code>curl -I http://localhost:8080/</code></td>\n<td><code>-I</code> sends HEAD instead of GET</td>\n</tr>\n<tr>\n<td>Custom headers</td>\n<td><code>curl -H &quot;Host: test.com&quot; http://localhost:8080/</code></td>\n<td><code>-H</code> adds custom header</td>\n</tr>\n<tr>\n<td>POST request</td>\n<td><code>curl -X POST -d &quot;data&quot; http://localhost:8080/</code></td>\n<td><code>-X</code> specifies method, <code>-d</code> sends data</td>\n</tr>\n<tr>\n<td>Follow redirects</td>\n<td><code>curl -L http://localhost:8080/redirect</code></td>\n<td><code>-L</code> follows Location headers</td>\n</tr>\n<tr>\n<td>Timeout control</td>\n<td><code>curl --max-time 5 http://localhost:8080/</code></td>\n<td>Prevents hanging on slow responses</td>\n</tr>\n<tr>\n<td>Save response</td>\n<td><code>curl -o output.html http://localhost:8080/</code></td>\n<td><code>-o</code> saves response to file</td>\n</tr>\n<tr>\n<td>Show timing</td>\n<td><code>curl -w &quot;@curl-format.txt&quot; http://localhost:8080/</code></td>\n<td>Custom timing format</td>\n</tr>\n</tbody></table>\n<p><strong>wget - Alternative HTTP Client:</strong></p>\n<p>wget provides different capabilities useful for testing file download scenarios and recursive retrieval:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Download files recursively</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">wget</span><span style=\"color:#79B8FF\"> -r</span><span style=\"color:#79B8FF\"> --no-parent</span><span style=\"color:#9ECBFF\"> http://localhost:8080/</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test resume capability (if implemented)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">wget</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> http://localhost:8080/large-file.zip</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Mirror directory structure</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">wget</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> http://localhost:8080/</span></span></code></pre></div>\n\n<h4 id=\"low-level-network-testing-tools\">Low-Level Network Testing Tools</h4>\n<p><strong>telnet - Raw TCP Connection Testing:</strong></p>\n<p>telnet enables direct TCP connection testing without HTTP protocol formatting, essential for testing TCP server basics and debugging connection issues:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Basic connection test</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">telnet</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test connection timeout</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">timeout</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#9ECBFF\"> telnet</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Scripted telnet for automated testing</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#79B8FF\"> -e</span><span style=\"color:#9ECBFF\"> \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> telnet</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span></span></code></pre></div>\n\n<p><strong>netcat (nc) - Advanced Network Testing:</strong></p>\n<p>netcat provides more flexibility than telnet for network testing scenarios:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Send HTTP request via netcat</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#79B8FF\"> -e</span><span style=\"color:#9ECBFF\"> \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> nc</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test UDP (if server supports it)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"test\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> nc</span><span style=\"color:#79B8FF\"> -u</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Port scanning to verify server is listening</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">nc</span><span style=\"color:#79B8FF\"> -z</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span></span></code></pre></div>\n\n<p><strong>openssl s_client - HTTPS Testing:</strong></p>\n<p>If HTTPS support is added in future extensions:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test HTTPS connection</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">openssl</span><span style=\"color:#9ECBFF\"> s_client</span><span style=\"color:#79B8FF\"> -connect</span><span style=\"color:#9ECBFF\"> localhost:8443</span><span style=\"color:#79B8FF\"> -servername</span><span style=\"color:#9ECBFF\"> localhost</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test certificate validation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">openssl</span><span style=\"color:#9ECBFF\"> s_client</span><span style=\"color:#79B8FF\"> -connect</span><span style=\"color:#9ECBFF\"> localhost:8443</span><span style=\"color:#79B8FF\"> -verify_return_error</span></span></code></pre></div>\n\n<h4 id=\"browser-testing-strategies\">Browser Testing Strategies</h4>\n<p><strong>Interactive Browser Testing:</strong></p>\n<p>Real browser testing provides essential validation of HTTP server behavior with actual web clients, revealing issues that command-line tools might miss:</p>\n<ol>\n<li><strong>Basic Functionality Testing:</strong> Open <code>http://localhost:8080/</code> in multiple browsers (Chrome, Firefox, Safari) to verify cross-browser compatibility</li>\n<li><strong>Developer Tools Inspection:</strong> Use browser developer tools (F12) to examine:<ul>\n<li>Network tab: Request/response headers, timing, status codes</li>\n<li>Console tab: JavaScript errors if serving HTML with scripts</li>\n<li>Sources tab: Verify file contents load correctly</li>\n</ul>\n</li>\n<li><strong>Cache Behavior Testing:</strong> Use Ctrl+F5 (force refresh) to test cache headers and ensure proper cache validation</li>\n</ol>\n<p><strong>Browser-Specific Testing Scenarios:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Test Scenario</th>\n<th>Browser Action</th>\n<th>Expected Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Favicon request</td>\n<td>Load any page</td>\n<td>Server should handle <code>/favicon.ico</code> gracefully</td>\n</tr>\n<tr>\n<td>Multiple tabs</td>\n<td>Open same URL in multiple tabs</td>\n<td>All tabs should load correctly</td>\n</tr>\n<tr>\n<td>File download</td>\n<td>Click download link</td>\n<td>File should download without corruption</td>\n</tr>\n<tr>\n<td>Image loading</td>\n<td>Page with multiple images</td>\n<td>All images load without broken links</td>\n</tr>\n<tr>\n<td>Large file handling</td>\n<td>Request large files</td>\n<td>Download progresses without timeout</td>\n</tr>\n</tbody></table>\n<h4 id=\"automated-testing-scripts\">Automated Testing Scripts</h4>\n<p><strong>Bash Testing Scripts:</strong></p>\n<p>Create reusable test scripts for consistent verification across development iterations:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">#!/bin/bash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># http_server_test.sh - Comprehensive server testing</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SERVER_URL</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"http://localhost:8080\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">TEST_DIR</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"test_files\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test basic connectivity</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">test_connectivity</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"Testing basic connectivity...\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#79B8FF\"> --max-time</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$SERVER_URL</span><span style=\"color:#9ECBFF\">/\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/null</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        echo</span><span style=\"color:#9ECBFF\"> \"✓ Server is reachable\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        echo</span><span style=\"color:#9ECBFF\"> \"✗ Server connectivity failed\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    fi</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test file serving</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">test_file_serving</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"Testing file serving...\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">in</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$TEST_DIR</span><span style=\"color:#9ECBFF\">\"/*.html</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$TEST_DIR</span><span style=\"color:#9ECBFF\">\"/*.css</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$TEST_DIR</span><span style=\"color:#9ECBFF\">\"/*.js</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        filename</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">basename</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$file</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#B392F0\"> curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$SERVER_URL</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#E1E4E8\">$filename</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> diff</span><span style=\"color:#9ECBFF\"> -</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$file</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/null</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            echo</span><span style=\"color:#9ECBFF\"> \"✓ </span><span style=\"color:#E1E4E8\">$filename</span><span style=\"color:#9ECBFF\"> served correctly\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            echo</span><span style=\"color:#9ECBFF\"> \"✗ </span><span style=\"color:#E1E4E8\">$filename</span><span style=\"color:#9ECBFF\"> content mismatch\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        fi</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    done</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test concurrent connections</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">test_concurrency</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"Testing concurrent connections...\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..10}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$SERVER_URL</span><span style=\"color:#9ECBFF\">/\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> \"/tmp/response_</span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    done</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    wait</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Verify all responses are identical</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> diff</span><span style=\"color:#9ECBFF\"> /tmp/response_1</span><span style=\"color:#9ECBFF\"> /tmp/response_2</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/null</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        echo</span><span style=\"color:#9ECBFF\"> \"✓ Concurrent responses are consistent\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        echo</span><span style=\"color:#9ECBFF\"> \"✗ Concurrent responses differ\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    fi</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run all tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    test_connectivity</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> exit</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    test_file_serving</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    test_concurrency</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"Testing completed\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">main</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">$@</span><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<h3 id=\"concurrency-testing\">Concurrency Testing</h3>\n<p>Concurrency testing represents the most complex verification challenge, requiring careful coordination of multiple clients and observation of server behavior under simultaneous load. Think of concurrency testing like stress-testing a restaurant during the dinner rush - you need to simulate multiple customers arriving simultaneously, ordering different items, and verify that each customer receives their correct order without delays caused by kitchen coordination issues.</p>\n<h4 id=\"thread-per-connection-model-testing\">Thread-Per-Connection Model Testing</h4>\n<p>The thread-per-connection concurrency model creates a dedicated thread for each client connection, making it relatively straightforward to test but important to verify proper thread management and resource cleanup.</p>\n<p><strong>Basic Thread Creation Verification:</strong></p>\n<p>Test that the server creates threads correctly for multiple connections:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Monitor thread creation in real-time</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">watch</span><span style=\"color:#9ECBFF\"> \"ps -T -p $(</span><span style=\"color:#B392F0\">pgrep</span><span style=\"color:#9ECBFF\"> http_server) | wc -l\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Create multiple connections and observe thread count</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..5}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#B392F0\">sleep</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#B392F0\">curl</span><span style=\"color:#9ECBFF\"> http://localhost:8080/</span><span style=\"color:#E1E4E8\">) &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span></code></pre></div>\n\n<p>Expected behavior: Thread count should increase as connections are accepted and decrease as they complete. Total thread count should not exceed the number of active connections plus the main thread.</p>\n<p><strong>Thread Resource Management Testing:</strong></p>\n<p>Verify that threads are properly cleaned up and don&#39;t accumulate over time:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Baseline thread count</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">BASELINE</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">ps</span><span style=\"color:#79B8FF\"> -T</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">pgrep</span><span style=\"color:#9ECBFF\"> http_server</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">|</span><span style=\"color:#B392F0\"> wc</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Create and complete many connections</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> round </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..10}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..5}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> http://localhost:8080/</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/null</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    done</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    wait</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sleep</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check final thread count</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">FINAL</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">ps</span><span style=\"color:#79B8FF\"> -T</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">pgrep</span><span style=\"color:#9ECBFF\"> http_server</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">|</span><span style=\"color:#B392F0\"> wc</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> [ $FINAL </span><span style=\"color:#F97583\">-eq</span><span style=\"color:#E1E4E8\"> $BASELINE ]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"✓ Thread cleanup working correctly\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"✗ Thread leak detected: </span><span style=\"color:#E1E4E8\">$BASELINE</span><span style=\"color:#9ECBFF\"> -> </span><span style=\"color:#E1E4E8\">$FINAL</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">fi</span></span></code></pre></div>\n\n<p><strong>Thread Safety Validation:</strong></p>\n<p>Test that concurrent threads don&#39;t interfere with each other&#39;s request processing:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Create files with unique content</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#9ECBFF\"> test_content</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..10}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"Unique content for file </span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\"> - $(</span><span style=\"color:#B392F0\">date</span><span style=\"color:#9ECBFF\">)\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> \"test_content/file</span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\">.txt\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Request all files simultaneously</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..10}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> \"http://localhost:8080/file</span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\">.txt\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> \"response</span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\">.txt\"</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">wait</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify each response matches its expected content</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..10}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> diff</span><span style=\"color:#9ECBFF\"> \"test_content/file</span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\">.txt\"</span><span style=\"color:#9ECBFF\"> \"response</span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\">.txt\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/null</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        echo</span><span style=\"color:#9ECBFF\"> \"✓ File </span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\"> content correct\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        echo</span><span style=\"color:#9ECBFF\"> \"✗ File </span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\"> content corrupted or swapped\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    fi</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span></code></pre></div>\n\n<h4 id=\"thread-pool-model-testing\">Thread Pool Model Testing</h4>\n<p>The thread pool model maintains a fixed number of worker threads that handle connections from a queue, requiring different testing approaches focused on queue management and worker coordination.</p>\n<p><strong>Thread Pool Size Verification:</strong></p>\n<p>Test that the server maintains the configured number of worker threads:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Server should maintain exactly N worker threads plus main thread</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">EXPECTED_THREADS</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$((</span><span style=\"color:#B392F0\">THREAD_POOL_SIZE</span><span style=\"color:#9ECBFF\"> +</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ACTUAL_THREADS</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">ps</span><span style=\"color:#79B8FF\"> -T</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">pgrep</span><span style=\"color:#9ECBFF\"> http_server</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">|</span><span style=\"color:#B392F0\"> wc</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> [ $ACTUAL_THREADS </span><span style=\"color:#F97583\">-eq</span><span style=\"color:#E1E4E8\"> $EXPECTED_THREADS ]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"✓ Thread pool size correct: </span><span style=\"color:#E1E4E8\">$ACTUAL_THREADS</span><span style=\"color:#9ECBFF\"> threads\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"✗ Thread pool size incorrect: expected </span><span style=\"color:#E1E4E8\">$EXPECTED_THREADS</span><span style=\"color:#9ECBFF\">, got </span><span style=\"color:#E1E4E8\">$ACTUAL_THREADS</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">fi</span></span></code></pre></div>\n\n<p><strong>Queue Overflow Testing:</strong></p>\n<p>Test server behavior when more connections arrive than the thread pool can handle immediately:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Create more simultaneous connections than thread pool size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">CONNECTIONS</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$((</span><span style=\"color:#B392F0\">THREAD_POOL_SIZE</span><span style=\"color:#79B8FF\"> *</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Creating </span><span style=\"color:#E1E4E8\">$CONNECTIONS</span><span style=\"color:#9ECBFF\"> simultaneous connections...\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">seq</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> $CONNECTIONS); </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Add delay to keep connections active</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#79B8FF\"> --max-time</span><span style=\"color:#79B8FF\"> 30</span><span style=\"color:#9ECBFF\"> \"http://localhost:8080/?delay=5\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> \"pool_response_</span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        echo</span><span style=\"color:#79B8FF\"> $!</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> \"pool_pid_</span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Wait for all connections</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">wait</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify all connections completed successfully</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SUCCESS_COUNT</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">seq</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> $CONNECTIONS); </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> [ </span><span style=\"color:#F97583\">-s</span><span style=\"color:#9ECBFF\"> \"pool_response_</span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> ]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        SUCCESS_COUNT</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$((</span><span style=\"color:#B392F0\">SUCCESS_COUNT</span><span style=\"color:#9ECBFF\"> +</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    fi</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Successful connections: </span><span style=\"color:#E1E4E8\">$SUCCESS_COUNT</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#E1E4E8\">$CONNECTIONS</span><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<p><strong>Worker Thread Load Distribution:</strong></p>\n<p>Verify that work is distributed among thread pool workers rather than handled by a single thread:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Enable thread ID logging in server (if available)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Send requests and check logs for thread distribution</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..20}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> \"http://localhost:8080/worker-test-</span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/null</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Analyze server logs to verify multiple thread IDs handled requests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># This requires the server to log thread IDs for verification</span></span></code></pre></div>\n\n<h4 id=\"event-driven-model-testing\">Event-Driven Model Testing</h4>\n<p>The event-driven (select/poll) model uses a single thread with non-blocking I/O to handle multiple connections, requiring specialized testing to verify proper multiplexing behavior.</p>\n<p><strong>Non-Blocking Behavior Verification:</strong></p>\n<p>Test that the server doesn&#39;t block on slow clients:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Create a slow client that sends data gradually</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"GET / HTTP/1.1\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sleep</span><span style=\"color:#79B8FF\"> 5</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"Host: localhost\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sleep</span><span style=\"color:#79B8FF\"> 5</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#F97583\">|</span><span style=\"color:#B392F0\"> nc</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SLOW_PID</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">$!</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># While slow client is active, send fast requests</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..5}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> http://localhost:8080/</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> \"fast_response_</span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">wait</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify fast requests completed despite slow client</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">kill</span><span style=\"color:#E1E4E8\"> $SLOW_PID </span><span style=\"color:#F97583\">2></span><span style=\"color:#9ECBFF\">/dev/null</span></span></code></pre></div>\n\n<p><strong>Connection Multiplexing Testing:</strong></p>\n<p>Verify that a single thread can handle multiple simultaneous connections:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Verify server uses only one main thread</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">THREAD_COUNT</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">ps</span><span style=\"color:#79B8FF\"> -T</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">pgrep</span><span style=\"color:#9ECBFF\"> http_server</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">|</span><span style=\"color:#B392F0\"> wc</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> [ $THREAD_COUNT </span><span style=\"color:#F97583\">-gt</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\"> ]; </span><span style=\"color:#F97583\">then</span><span style=\"color:#6A737D\">  # Main thread + perhaps one helper</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"✗ Event-driven server should not create multiple threads\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"✓ Server using event-driven single-thread model\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">fi</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Create many simultaneous connections</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..50}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#79B8FF\">echo</span><span style=\"color:#79B8FF\"> -e</span><span style=\"color:#9ECBFF\"> \"GET /test</span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\"> HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> nc</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> \"event_response_</span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">) &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">wait</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Count successful responses</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SUCCESS_COUNT</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> event_response_</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> wc</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Event-driven model handled </span><span style=\"color:#E1E4E8\">$SUCCESS_COUNT</span><span style=\"color:#9ECBFF\">/50 connections\"</span></span></code></pre></div>\n\n<h4 id=\"load-testing-and-stress-testing\">Load Testing and Stress Testing</h4>\n<p><strong>Progressive Load Testing:</strong></p>\n<p>Gradually increase the load to identify the server&#39;s capacity limits:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">#!/bin/bash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># progressive_load_test.sh</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">test_load</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    local</span><span style=\"color:#E1E4E8\"> connections</span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\">$1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    local</span><span style=\"color:#E1E4E8\"> duration</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">10</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    local</span><span style=\"color:#E1E4E8\"> success</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"Testing with </span><span style=\"color:#E1E4E8\">$connections</span><span style=\"color:#9ECBFF\"> concurrent connections...\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">seq</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> $connections); </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        timeout</span><span style=\"color:#E1E4E8\"> $duration </span><span style=\"color:#9ECBFF\">curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> http://localhost:8080/</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/null</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; success</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$((</span><span style=\"color:#B392F0\">success</span><span style=\"color:#9ECBFF\"> +</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)) &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    done</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    wait</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    local</span><span style=\"color:#E1E4E8\"> success_rate</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$((</span><span style=\"color:#B392F0\">success</span><span style=\"color:#79B8FF\"> *</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#9ECBFF\"> /</span><span style=\"color:#9ECBFF\"> connections</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"Success rate: </span><span style=\"color:#E1E4E8\">$success_rate</span><span style=\"color:#9ECBFF\">% (</span><span style=\"color:#E1E4E8\">$success</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#E1E4E8\">$connections</span><span style=\"color:#9ECBFF\">)\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> $success_rate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test increasing loads</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> load </span><span style=\"color:#F97583\">in</span><span style=\"color:#9ECBFF\"> 10</span><span style=\"color:#9ECBFF\"> 25</span><span style=\"color:#9ECBFF\"> 50</span><span style=\"color:#9ECBFF\"> 100</span><span style=\"color:#9ECBFF\"> 200</span><span style=\"color:#9ECBFF\"> 500</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    test_load</span><span style=\"color:#E1E4E8\"> $load</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sleep</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#6A737D\">  # Recovery time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span></code></pre></div>\n\n<p><strong>Memory and Resource Monitoring:</strong></p>\n<p>Monitor server resource usage during concurrent load:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Start resource monitoring</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#9ECBFF\"> true</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        echo</span><span style=\"color:#9ECBFF\"> \"$(</span><span style=\"color:#B392F0\">date</span><span style=\"color:#9ECBFF\">): $(</span><span style=\"color:#B392F0\">ps</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> pid,vsz,rss,pcpu,pmem,nlwp </span><span style=\"color:#79B8FF\">-p</span><span style=\"color:#9ECBFF\"> $(</span><span style=\"color:#B392F0\">pgrep</span><span style=\"color:#9ECBFF\"> http_server))\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        sleep</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    done</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> resource_usage.log &#x26;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">MONITOR_PID</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">$!</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Generate load</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..100}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> http://localhost:8080/large-file.html</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/null</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">wait</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Stop monitoring</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">kill</span><span style=\"color:#E1E4E8\"> $MONITOR_PID</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Analyze resource usage</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Peak memory usage:\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sort</span><span style=\"color:#79B8FF\"> -k3</span><span style=\"color:#79B8FF\"> -nr</span><span style=\"color:#9ECBFF\"> resource_usage.log</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> head</span><span style=\"color:#79B8FF\"> -1</span></span></code></pre></div>\n\n<h4 id=\"failure-recovery-testing\">Failure Recovery Testing</h4>\n<p><strong>Connection Interruption Handling:</strong></p>\n<p>Test server resilience when clients disconnect unexpectedly:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Create connections that disconnect abruptly</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..10}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        echo</span><span style=\"color:#9ECBFF\"> \"GET / HTTP/1.1\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        echo</span><span style=\"color:#9ECBFF\"> \"Host: localhost\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Disconnect without completing request</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">|</span><span style=\"color:#B392F0\"> timeout</span><span style=\"color:#79B8FF\"> 0.1</span><span style=\"color:#9ECBFF\"> nc</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Immediately send normal requests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sleep</span><span style=\"color:#79B8FF\"> 0.5</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..5}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> http://localhost:8080/</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> \"recovery_test_</span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">wait</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify normal requests succeeded despite connection failures</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SUCCESS</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..5}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> [ </span><span style=\"color:#F97583\">-s</span><span style=\"color:#9ECBFF\"> \"recovery_test_</span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> ]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        SUCCESS</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$((</span><span style=\"color:#B392F0\">SUCCESS</span><span style=\"color:#9ECBFF\"> +</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    fi</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Recovery test: </span><span style=\"color:#E1E4E8\">$SUCCESS</span><span style=\"color:#9ECBFF\">/5 requests succeeded\"</span></span></code></pre></div>\n\n<p><strong>Graceful Shutdown Testing:</strong></p>\n<p>Test that the server handles shutdown signals correctly while serving active connections:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Start long-running requests</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..5}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> \"http://localhost:8080/?delay=10\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> \"shutdown_test_</span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sleep</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#6A737D\">  # Let requests start processing</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Send shutdown signal</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">kill</span><span style=\"color:#79B8FF\"> -TERM</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">pgrep</span><span style=\"color:#9ECBFF\"> http_server</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Wait for requests to complete</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">wait</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify existing requests completed successfully</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">COMPLETED</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..5}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> [ </span><span style=\"color:#F97583\">-s</span><span style=\"color:#9ECBFF\"> \"shutdown_test_</span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> ]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        COMPLETED</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$((</span><span style=\"color:#B392F0\">COMPLETED</span><span style=\"color:#9ECBFF\"> +</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    fi</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Graceful shutdown: </span><span style=\"color:#E1E4E8\">$COMPLETED</span><span style=\"color:#9ECBFF\">/5 requests completed\"</span></span></code></pre></div>\n\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The testing strategy implementation requires creating a comprehensive test suite that can be executed at each milestone to verify functionality and catch regressions. The testing approach combines automated scripts with manual verification procedures to ensure thorough coverage.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Testing Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTP Client Testing</td>\n<td>curl command-line scripts</td>\n<td>Python requests library with unittest</td>\n</tr>\n<tr>\n<td>Load Testing</td>\n<td>Bash scripts with background processes</td>\n<td>Apache Bench (ab) or wrk load tester</td>\n</tr>\n<tr>\n<td>Resource Monitoring</td>\n<td>ps/lsof command-line tools</td>\n<td>Custom monitoring with htop/iotop</td>\n</tr>\n<tr>\n<td>Automated Testing</td>\n<td>Shell scripts with basic assertions</td>\n<td>Python pytest with HTTP test fixtures</td>\n</tr>\n<tr>\n<td>Concurrency Testing</td>\n<td>Manual curl with background jobs</td>\n<td>Custom multi-threaded test client</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  tests/\n    milestone1/\n      test_tcp_basics.sh           ← TCP socket functionality\n      test_connection_handling.sh  ← Connection accept/close\n    milestone2/\n      test_http_parsing.sh         ← HTTP request parsing\n      test_error_responses.sh      ← Malformed request handling\n      sample_requests/             ← Test HTTP request files\n    milestone3/\n      test_file_serving.sh         ← Static file serving\n      test_security.sh             ← Directory traversal tests\n      test_content/                ← Test files and directories\n        index.html\n        style.css\n        images/\n          test.png\n    milestone4/\n      test_concurrency.sh          ← Concurrent connection tests\n      test_load.sh                 ← Load testing scripts\n      test_resource_limits.sh      ← Resource management tests\n    tools/\n      http_test_client.c           ← Custom test client\n      monitor_resources.sh         ← Resource monitoring utilities\n      test_runner.sh               ← Master test execution script\n  test_results/                    ← Test output and logs\n    milestone1_results.txt\n    milestone2_results.txt\n    resource_usage.log</code></pre></div>\n\n<h4 id=\"infrastructure-testing-code\">Infrastructure Testing Code</h4>\n<p><strong>Complete HTTP Test Client Implementation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// tools/http_test_client.c - Complete HTTP testing client</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/socket.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;netinet/in.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;arpa/inet.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;time.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;pthread.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_RESPONSE_SIZE</span><span style=\"color:#79B8FF\"> 8192</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_CONCURRENT_CLIENTS</span><span style=\"color:#79B8FF\"> 100</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> server_host;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> server_port;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> request_path;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> client_id;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int*</span><span style=\"color:#E1E4E8\"> success_count;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_mutex_t*</span><span style=\"color:#E1E4E8\"> count_mutex;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ClientConfig;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Send HTTP request and receive response</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> send_http_request</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> host</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> port</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char*</span><span style=\"color:#FFAB70\"> response</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> max_response</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> sockfd;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> sockaddr_in server_addr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> request</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> bytes_received;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create socket</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sockfd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> socket</span><span style=\"color:#E1E4E8\">(AF_INET, SOCK_STREAM, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (sockfd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"socket creation failed\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Configure server address</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">server_addr, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(server_addr));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server_addr.sin_family </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> AF_INET;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server_addr.sin_port </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> htons</span><span style=\"color:#E1E4E8\">(port);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">inet_pton</span><span style=\"color:#E1E4E8\">(AF_INET, host, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">server_addr.sin_addr) </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid address\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(sockfd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Connect to server</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">connect</span><span style=\"color:#E1E4E8\">(sockfd, (</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> sockaddr</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">server_addr, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(server_addr)) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"connection failed\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(sockfd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Send HTTP request</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(request, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(request), </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">             \"GET </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> HTTP/1.1</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">Host: </span><span style=\"color:#79B8FF\">%s\\r\\n</span><span style=\"color:#9ECBFF\">Connection: close</span><span style=\"color:#79B8FF\">\\r\\n\\r\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">             path, host);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">send</span><span style=\"color:#E1E4E8\">(sockfd, request, </span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(request), </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"send failed\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(sockfd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Receive response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bytes_received </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> recv</span><span style=\"color:#E1E4E8\">(sockfd, response, max_response </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (bytes_received </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"recv failed\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(sockfd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    response</span><span style=\"color:#E1E4E8\">[bytes_received] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(sockfd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> bytes_received;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Thread function for concurrent testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> client_thread</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> arg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ClientConfig</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> config </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ClientConfig</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)arg;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> response</span><span style=\"color:#E1E4E8\">[MAX_RESPONSE_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> send_http_request</span><span style=\"color:#E1E4E8\">(config->server_host, config->server_port, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                   config->request_path, response, MAX_RESPONSE_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (result </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(config->count_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">config->success_count)</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(config->count_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Client </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">: SUCCESS (</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> bytes)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, config->client_id, result);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Client </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">: FAILED</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, config->client_id);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char*</span><span style=\"color:#FFAB70\"> argv</span><span style=\"color:#F97583\">[]</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (argc </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Usage: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> &#x3C;host> &#x3C;port> &#x3C;path> [concurrent_clients]</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> host </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> port </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> atoi</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> path </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> concurrent_clients </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (argc </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#B392F0\"> atoi</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">]) </span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (concurrent_clients </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Single request mode</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#FFAB70\"> response</span><span style=\"color:#E1E4E8\">[MAX_RESPONSE_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> send_http_request</span><span style=\"color:#E1E4E8\">(host, port, path, response, MAX_RESPONSE_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (result </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Response received (</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> bytes):</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, result);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, response);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Request failed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Concurrent testing mode</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pthread_t</span><span style=\"color:#FFAB70\"> threads</span><span style=\"color:#E1E4E8\">[MAX_CONCURRENT_CLIENTS];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ClientConfig </span><span style=\"color:#FFAB70\">configs</span><span style=\"color:#E1E4E8\">[MAX_CONCURRENT_CLIENTS];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> success_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pthread_mutex_t</span><span style=\"color:#E1E4E8\"> count_mutex </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PTHREAD_MUTEX_INITIALIZER;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (concurrent_clients </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> MAX_CONCURRENT_CLIENTS) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            concurrent_clients </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> MAX_CONCURRENT_CLIENTS;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Starting </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> concurrent clients...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, concurrent_clients);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Start concurrent clients</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> concurrent_clients; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            configs</span><span style=\"color:#E1E4E8\">[i].server_host </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> host;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            configs</span><span style=\"color:#E1E4E8\">[i].server_port </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> port;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            configs</span><span style=\"color:#E1E4E8\">[i].request_path </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> path;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            configs</span><span style=\"color:#E1E4E8\">[i].client_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            configs</span><span style=\"color:#E1E4E8\">[i].success_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">success_count;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            configs</span><span style=\"color:#E1E4E8\">[i].count_mutex </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">count_mutex;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">pthread_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">threads</span><span style=\"color:#E1E4E8\">[i], </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, client_thread, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">configs</span><span style=\"color:#E1E4E8\">[i]) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"pthread_create failed\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Wait for all threads to complete</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> concurrent_clients; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            pthread_join</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">threads</span><span style=\"color:#E1E4E8\">[i], </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Concurrent test completed: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> clients succeeded</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               success_count, concurrent_clients);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (success_count </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> concurrent_clients) </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> :</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Complete Resource Monitoring Script:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">#!/bin/bash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># tools/monitor_resources.sh - Complete resource monitoring utility</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SCRIPT_DIR</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"$(</span><span style=\"color:#79B8FF\">cd</span><span style=\"color:#9ECBFF\"> \"$(</span><span style=\"color:#B392F0\">dirname</span><span style=\"color:#9ECBFF\"> \"${</span><span style=\"color:#E1E4E8\">BASH_SOURCE</span><span style=\"color:#9ECBFF\">[0]}\")\" &#x26;&#x26; </span><span style=\"color:#79B8FF\">pwd</span><span style=\"color:#9ECBFF\">)\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">LOG_DIR</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">$SCRIPT_DIR</span><span style=\"color:#9ECBFF\">/../test_results\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SERVER_NAME</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"http_server\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Ensure log directory exists</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$LOG_DIR</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Get server process ID</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">get_server_pid</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pgrep</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$SERVER_NAME</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> head</span><span style=\"color:#79B8FF\"> -1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Monitor server resources</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">monitor_resources</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    local</span><span style=\"color:#E1E4E8\"> duration</span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\">$1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    local</span><span style=\"color:#E1E4E8\"> interval</span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\">${2</span><span style=\"color:#F97583\">:-</span><span style=\"color:#FFAB70\">1}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    local</span><span style=\"color:#E1E4E8\"> output_file</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">$LOG_DIR</span><span style=\"color:#9ECBFF\">/resource_monitor_$(</span><span style=\"color:#B392F0\">date</span><span style=\"color:#9ECBFF\"> +%Y%m%d_%H%M%S).log\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"Monitoring server resources for ${</span><span style=\"color:#E1E4E8\">duration</span><span style=\"color:#9ECBFF\">}s (interval: ${</span><span style=\"color:#E1E4E8\">interval</span><span style=\"color:#9ECBFF\">}s)\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"Output: </span><span style=\"color:#E1E4E8\">$output_file</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"Timestamp,PID,VSZ_KB,RSS_KB,CPU_PCT,MEM_PCT,THREADS,FD_COUNT\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$output_file</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    local</span><span style=\"color:#E1E4E8\"> start_time</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">date</span><span style=\"color:#9ECBFF\"> +%s</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    local</span><span style=\"color:#E1E4E8\"> end_time</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$((</span><span style=\"color:#B392F0\">start_time</span><span style=\"color:#9ECBFF\"> +</span><span style=\"color:#9ECBFF\"> duration</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> [ $(</span><span style=\"color:#B392F0\">date</span><span style=\"color:#9ECBFF\"> +%s</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">-lt</span><span style=\"color:#E1E4E8\"> $end_time ]; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        local</span><span style=\"color:#E1E4E8\"> server_pid</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">get_server_pid</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> [ </span><span style=\"color:#F97583\">-n</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$server_pid</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> ]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Get process statistics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            local</span><span style=\"color:#E1E4E8\"> ps_info</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">ps</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> pid,vsz,rss,pcpu,pmem,nlwp</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$server_pid</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\"> --no-headers</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> [ </span><span style=\"color:#F97583\">-n</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$ps_info</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> ]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Count file descriptors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                local</span><span style=\"color:#E1E4E8\"> fd_count</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#E1E4E8\">$server_pid</span><span style=\"color:#9ECBFF\">/fd</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> wc</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Format output</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                local</span><span style=\"color:#E1E4E8\"> timestamp</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">date</span><span style=\"color:#9ECBFF\"> '+%Y-%m-%d %H:%M:%S'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                echo</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$timestamp</span><span style=\"color:#9ECBFF\">,</span><span style=\"color:#E1E4E8\">$ps_info</span><span style=\"color:#9ECBFF\">,</span><span style=\"color:#E1E4E8\">$fd_count</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> tr</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> ' '</span><span style=\"color:#9ECBFF\"> ','</span><span style=\"color:#F97583\"> >></span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$output_file</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                echo</span><span style=\"color:#9ECBFF\"> \"$(</span><span style=\"color:#B392F0\">date</span><span style=\"color:#9ECBFF\"> '+%Y-%m-%d %H:%M:%S'),SERVER_NOT_FOUND,,,,,,\"</span><span style=\"color:#F97583\"> >></span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$output_file</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            fi</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            echo</span><span style=\"color:#9ECBFF\"> \"$(</span><span style=\"color:#B392F0\">date</span><span style=\"color:#9ECBFF\"> '+%Y-%m-%d %H:%M:%S'),PID_NOT_FOUND,,,,,,\"</span><span style=\"color:#F97583\"> >></span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$output_file</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        fi</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        sleep</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$interval</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    done</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"Monitoring completed. Results saved to: </span><span style=\"color:#E1E4E8\">$output_file</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Generate summary</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> [ </span><span style=\"color:#F97583\">-s</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$output_file</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> ]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        echo</span><span style=\"color:#9ECBFF\"> \"Resource Usage Summary:\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        echo</span><span style=\"color:#9ECBFF\"> \"======================\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        echo</span><span style=\"color:#9ECBFF\"> \"Peak VSZ (KB): $(</span><span style=\"color:#B392F0\">tail</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#9ECBFF\"> +2 \"</span><span style=\"color:#E1E4E8\">$output_file</span><span style=\"color:#9ECBFF\">\" </span><span style=\"color:#F97583\">|</span><span style=\"color:#B392F0\"> cut</span><span style=\"color:#79B8FF\"> -d</span><span style=\"color:#9ECBFF\">',' </span><span style=\"color:#79B8FF\">-f3</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> sort</span><span style=\"color:#79B8FF\"> -nr</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> head</span><span style=\"color:#79B8FF\"> -1</span><span style=\"color:#9ECBFF\">)\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        echo</span><span style=\"color:#9ECBFF\"> \"Peak RSS (KB): $(</span><span style=\"color:#B392F0\">tail</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#9ECBFF\"> +2 \"</span><span style=\"color:#E1E4E8\">$output_file</span><span style=\"color:#9ECBFF\">\" </span><span style=\"color:#F97583\">|</span><span style=\"color:#B392F0\"> cut</span><span style=\"color:#79B8FF\"> -d</span><span style=\"color:#9ECBFF\">',' </span><span style=\"color:#79B8FF\">-f4</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> sort</span><span style=\"color:#79B8FF\"> -nr</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> head</span><span style=\"color:#79B8FF\"> -1</span><span style=\"color:#9ECBFF\">)\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        echo</span><span style=\"color:#9ECBFF\"> \"Peak Threads: $(</span><span style=\"color:#B392F0\">tail</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#9ECBFF\"> +2 \"</span><span style=\"color:#E1E4E8\">$output_file</span><span style=\"color:#9ECBFF\">\" </span><span style=\"color:#F97583\">|</span><span style=\"color:#B392F0\"> cut</span><span style=\"color:#79B8FF\"> -d</span><span style=\"color:#9ECBFF\">',' </span><span style=\"color:#79B8FF\">-f6</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> sort</span><span style=\"color:#79B8FF\"> -nr</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> head</span><span style=\"color:#79B8FF\"> -1</span><span style=\"color:#9ECBFF\">)\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        echo</span><span style=\"color:#9ECBFF\"> \"Peak FDs: $(</span><span style=\"color:#B392F0\">tail</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#9ECBFF\"> +2 \"</span><span style=\"color:#E1E4E8\">$output_file</span><span style=\"color:#9ECBFF\">\" </span><span style=\"color:#F97583\">|</span><span style=\"color:#B392F0\"> cut</span><span style=\"color:#79B8FF\"> -d</span><span style=\"color:#9ECBFF\">',' </span><span style=\"color:#79B8FF\">-f7</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> sort</span><span style=\"color:#79B8FF\"> -nr</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> head</span><span style=\"color:#79B8FF\"> -1</span><span style=\"color:#9ECBFF\">)\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    fi</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test connection limits</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">test_connection_limits</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    local</span><span style=\"color:#E1E4E8\"> max_connections</span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\">$1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    local</span><span style=\"color:#E1E4E8\"> server_pid</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">get_server_pid</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> [ </span><span style=\"color:#F97583\">-z</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$server_pid</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> ]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        echo</span><span style=\"color:#9ECBFF\"> \"Server not running\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    fi</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"Testing connection limits (max: </span><span style=\"color:#E1E4E8\">$max_connections</span><span style=\"color:#9ECBFF\">)\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Start monitoring</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    monitor_resources</span><span style=\"color:#79B8FF\"> 60</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    local</span><span style=\"color:#E1E4E8\"> monitor_pid</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">$!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Create connections gradually</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    local</span><span style=\"color:#E1E4E8\"> success_count</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">seq</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> $max_connections); </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#B392F0\"> timeout</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$SCRIPT_DIR</span><span style=\"color:#9ECBFF\">/../tools/http_test_client\"</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span><span style=\"color:#9ECBFF\"> /</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> 2>&#x26;1</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            success_count</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$((</span><span style=\"color:#B392F0\">success_count</span><span style=\"color:#9ECBFF\"> +</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            echo</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#9ECBFF\"> \".\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            echo</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#9ECBFF\"> \"x\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        fi</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Brief delay between connections</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        sleep</span><span style=\"color:#79B8FF\"> 0.1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    done</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"Connection test completed: </span><span style=\"color:#E1E4E8\">$success_count</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#E1E4E8\">$max_connections</span><span style=\"color:#9ECBFF\"> successful\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Stop monitoring</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    kill</span><span style=\"color:#E1E4E8\"> $monitor_pid </span><span style=\"color:#F97583\">2></span><span style=\"color:#9ECBFF\">/dev/null</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    wait</span><span style=\"color:#E1E4E8\"> $monitor_pid </span><span style=\"color:#F97583\">2></span><span style=\"color:#9ECBFF\">/dev/null</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Main function</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">${1</span><span style=\"color:#F97583\">:-</span><span style=\"color:#E1E4E8\">help</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> in</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"monitor\"</span><span style=\"color:#F97583\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            monitor_resources</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">${2</span><span style=\"color:#F97583\">:-</span><span style=\"color:#79B8FF\">30}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">${3</span><span style=\"color:#F97583\">:-</span><span style=\"color:#79B8FF\">1}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ;;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"limits\"</span><span style=\"color:#F97583\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            test_connection_limits</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">${2</span><span style=\"color:#F97583\">:-</span><span style=\"color:#79B8FF\">100}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ;;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"help\"</span><span style=\"color:#F97583\">|*</span><span style=\"color:#F97583\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            echo</span><span style=\"color:#9ECBFF\"> \"Usage: </span><span style=\"color:#79B8FF\">$0</span><span style=\"color:#9ECBFF\"> &#x3C;command> [options]\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            echo</span><span style=\"color:#9ECBFF\"> \"Commands:\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            echo</span><span style=\"color:#9ECBFF\"> \"  monitor &#x3C;duration> [interval]  - Monitor resources for duration seconds\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            echo</span><span style=\"color:#9ECBFF\"> \"  limits &#x3C;max_connections>       - Test connection limits\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            echo</span><span style=\"color:#9ECBFF\"> \"  help                          - Show this help\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ;;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    esac</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">main</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">$@</span><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<h4 id=\"core-testing-logic-skeletons\">Core Testing Logic Skeletons</h4>\n<p><strong>Master Test Runner:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">#!/bin/bash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># tests/test_runner.sh - Master test execution script</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># TODO 1: Set up test environment - create test directories, compile test tools</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># TODO 2: Start server in background and wait for it to be ready</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># TODO 3: Execute milestone 1 tests - TCP server basics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># TODO 4: Execute milestone 2 tests - HTTP request parsing  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># TODO 5: Execute milestone 3 tests - static file serving</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># TODO 6: Execute milestone 4 tests - concurrent connections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># TODO 7: Run load testing and resource monitoring</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># TODO 8: Generate comprehensive test report</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># TODO 9: Clean up test environment and stop server</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># TODO 10: Return appropriate exit code based on test results</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">run_milestone_tests</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    local</span><span style=\"color:#E1E4E8\"> milestone</span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\">$1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Execute all tests for specified milestone</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Collect results and update overall test status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Log detailed results to milestone-specific log file</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">setup_test_environment</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Create necessary test directories and files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Compile custom test clients and utilities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Verify required testing tools are available</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cleanup_test_environment</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Remove temporary test files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Kill any remaining background processes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Restore original system state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">generate_test_report</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Combine results from all milestone tests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Create HTML or text report with pass/fail summary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Include performance metrics and resource usage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>Milestone 1 Verification Script:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">#!/bin/bash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># tests/milestone1/test_tcp_basics.sh</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"=== Milestone 1: TCP Server Basics Testing ===\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 1: Server starts and binds to port</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">test_server_startup</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"Testing server startup and port binding...\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Start server in background</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Wait for server to be ready (check port binding)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Verify server is listening on correct port using netstat</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Test that server accepts basic TCP connections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Expected: Server binds to port 8080 and shows LISTEN state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 2: Connection acceptance</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">test_connection_acceptance</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"Testing connection acceptance...\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Use telnet to connect to server</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Verify connection is accepted (telnet shows \"Connected\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Send simple string and verify server reads it</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Verify server sends hardcoded HTTP response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Expected: Connection accepted, response received, connection closed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Milestone 4 Concurrent Testing:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">#!/bin/bash  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># tests/milestone4/test_concurrency.sh</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test concurrent request handling</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">test_concurrent_requests</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"Testing concurrent request handling...\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Create multiple background curl processes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Monitor that all requests complete successfully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Verify response content is consistent across all requests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Check that no responses are corrupted or mixed up</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Expected: All concurrent requests succeed with correct content</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test resource limits</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">test_resource_limits</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"Testing resource limits...\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Create connections exceeding configured limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Verify server handles excess connections gracefully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Monitor file descriptor and thread usage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # TODO: Ensure no resource leaks after connections close</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Expected: Server enforces limits without crashing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All Milestones 1-4 - provides systematic troubleshooting for TCP server basics, HTTP request parsing, static file serving, and concurrent connections with specific diagnostic techniques</p>\n</blockquote>\n<h3 id=\"debugging-mental-model-the-detective39s-toolkit\">Debugging Mental Model: The Detective&#39;s Toolkit</h3>\n<p>Think of debugging an HTTP server like being a detective investigating a crime scene. Just as detectives use systematic methods to gather evidence, interview witnesses, and piece together what happened, server debugging requires a methodical approach to collecting symptoms, examining evidence, and forming hypotheses. The server&#39;s logs are like witness statements, network packet captures are like security footage, and debugger traces are like forensic analysis. A good detective doesn&#39;t jump to conclusions but follows the evidence methodically, and a good server debugger applies the same systematic thinking to isolate and resolve issues.</p>\n<p>The debugging process for HTTP servers involves three critical phases: symptom identification (what is the observable behavior), evidence collection (gathering diagnostic data from multiple sources), and root cause analysis (correlating evidence to identify the underlying problem). Just as a detective considers multiple theories and tests each one against the evidence, effective server debugging requires considering multiple potential causes and systematically eliminating possibilities through targeted investigation.</p>\n<h3 id=\"symptom-based-diagnosis-table\">Symptom-Based Diagnosis Table</h3>\n<p>The following comprehensive diagnosis table organizes common HTTP server issues by observable symptoms, providing a systematic approach to troubleshooting. Each symptom includes multiple potential causes because server problems often manifest in similar ways but have different underlying roots.</p>\n<table>\n<thead>\n<tr>\n<th><strong>Symptom</strong></th>\n<th><strong>Likely Causes</strong></th>\n<th><strong>Diagnostic Techniques</strong></th>\n<th><strong>Investigation Commands</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Server fails to start</strong></td>\n<td>Port already in use; Permission denied for port binding; Invalid configuration values; Missing document root directory</td>\n<td>Check port availability; Verify user permissions; Validate configuration; Check filesystem permissions</td>\n<td><code>netstat -tlnp | grep 8080</code>; <code>sudo lsof -i :8080</code>; <code>ls -la /path/to/document/root</code>; <code>id</code> (check user)</td>\n</tr>\n<tr>\n<td><strong>Clients cannot connect</strong></td>\n<td>Firewall blocking connections; Server not listening on correct interface; DNS resolution issues; Network connectivity problems</td>\n<td>Verify server listening state; Test local vs remote connections; Check firewall rules; Test network path</td>\n<td><code>ss -tlnp | grep :8080</code>; <code>telnet localhost 8080</code>; <code>curl -v http://server:8080/</code>; <code>iptables -L</code></td>\n</tr>\n<tr>\n<td><strong>Connection accepted but no response</strong></td>\n<td>Server hanging in request reading; Infinite loop in request processing; Deadlock in thread synchronization; Process crashed after accept</td>\n<td>Monitor server process state; Check thread states; Examine system resources; Look for core dumps</td>\n<td><code>ps aux | grep server</code>; <code>top -H -p &lt;pid&gt;</code>; <code>strace -p &lt;pid&gt;</code>; <code>gdb -p &lt;pid&gt;</code></td>\n</tr>\n<tr>\n<td><strong>Request parsing fails</strong></td>\n<td>Malformed HTTP request format; Line ending issues (CRLF vs LF); Buffer overflow in parsing; Invalid characters in headers</td>\n<td>Capture raw request data; Examine line endings; Check buffer boundaries; Validate character encoding</td>\n<td><code>tcpdump -i lo -A port 8080</code>; <code>xxd request.txt</code>; <code>strace -e read,write -p &lt;pid&gt;</code></td>\n</tr>\n<tr>\n<td><strong>File not found errors</strong></td>\n<td>Incorrect path mapping; Directory traversal protection; Case sensitivity issues; Permission denied access</td>\n<td>Trace path resolution; Check filesystem permissions; Verify document root mapping; Test file accessibility</td>\n<td><code>ls -la /document/root/requested/path</code>; <code>sudo -u www-data cat /path/to/file</code>; <code>realpath /document/root/../etc/passwd</code></td>\n</tr>\n<tr>\n<td><strong>Slow response times</strong></td>\n<td>Disk I/O bottleneck; Thread pool exhaustion; Memory allocation delays; Network congestion</td>\n<td>Monitor system performance; Check thread utilization; Profile memory usage; Measure network latency</td>\n<td><code>iostat -x 1</code>; <code>sar -u 1</code>; <code>valgrind --tool=massif ./server</code>; <code>iftop</code></td>\n</tr>\n<tr>\n<td><strong>High CPU usage</strong></td>\n<td>Infinite loop in request processing; Excessive string operations; Inefficient parsing algorithms; Busy-wait conditions</td>\n<td>Profile CPU usage; Trace function calls; Examine parsing logic; Check synchronization primitives</td>\n<td><code>perf top -p &lt;pid&gt;</code>; <code>strace -c -p &lt;pid&gt;</code>; <code>gdb -p &lt;pid&gt; -ex bt</code></td>\n</tr>\n<tr>\n<td><strong>Memory leaks</strong></td>\n<td>Missing <code>cleanup_http_request()</code> calls; Unreleased connection contexts; Thread resource leaks; File descriptor leaks</td>\n<td>Track memory allocation; Monitor file descriptor count; Check cleanup sequences; Analyze heap growth</td>\n<td><code>valgrind --leak-check=full ./server</code>; <code>lsof -p &lt;pid&gt; | wc -l</code>; <code>pmap &lt;pid&gt;</code></td>\n</tr>\n<tr>\n<td><strong>Concurrent connection issues</strong></td>\n<td>Race conditions in shared data; Thread pool deadlock; Resource limit exceeded; Improper thread synchronization</td>\n<td>Test under load; Check thread states; Monitor resource limits; Examine synchronization code</td>\n<td><code>siege -c 100 -t 30s http://localhost:8080/</code>; <code>ulimit -a</code>; <code>ps -eLf | grep server</code></td>\n</tr>\n<tr>\n<td><strong>Partial responses</strong></td>\n<td>Early connection termination; Buffer size limitations; Network timeout issues; Incomplete file reads</td>\n<td>Monitor connection lifecycle; Check buffer sizes; Measure transfer times; Verify file integrity</td>\n<td><code>curl -v --max-time 30 http://localhost:8080/large.file</code>; <code>nc localhost 8080 &lt; request.txt</code></td>\n</tr>\n<tr>\n<td><strong>Security vulnerabilities</strong></td>\n<td>Directory traversal attacks; Path injection; Buffer overflow; Insufficient input validation</td>\n<td>Test path traversal; Inject malformed input; Check boundary conditions; Verify input sanitization</td>\n<td><code>curl &quot;http://localhost:8080/../../../etc/passwd&quot;</code>; <code>python -c &quot;print(&#39;A&#39;*10000)&quot; | nc localhost 8080</code></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Critical Insight</strong>: Many HTTP server issues present with similar symptoms but have completely different root causes. Systematic evidence collection prevents misdiagnosis and reduces debugging time significantly. Always start with the simplest possible cause before investigating complex scenarios.</p>\n</blockquote>\n<h3 id=\"debugging-tools-and-techniques\">Debugging Tools and Techniques</h3>\n<p>Effective HTTP server debugging requires a multi-layered approach using different tools to examine behavior at the network, system, and application levels. Each tool provides a different perspective on server operation, and combining insights from multiple tools leads to faster problem resolution.</p>\n<h4 id=\"network-level-debugging\">Network-Level Debugging</h4>\n<p>Network-level debugging examines the raw TCP connections and HTTP message flow between clients and servers. This level reveals issues with connection establishment, protocol compliance, and message formatting that may not be visible at higher abstraction levels.</p>\n<p><strong>Packet Capture and Analysis:</strong>\nThe <code>tcpdump</code> utility captures raw network traffic, allowing examination of actual bytes transmitted between client and server. This technique reveals protocol violations, malformed messages, and connection timing issues that application-level logging might miss.</p>\n<table>\n<thead>\n<tr>\n<th><strong>Tool</strong></th>\n<th><strong>Purpose</strong></th>\n<th><strong>Key Commands</strong></th>\n<th><strong>What to Look For</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>tcpdump</code></td>\n<td>Capture raw network packets</td>\n<td><code>tcpdump -i lo -A -s 0 port 8080</code></td>\n<td>Connection establishment, HTTP message format, connection termination</td>\n</tr>\n<tr>\n<td><code>wireshark</code></td>\n<td>GUI packet analysis</td>\n<td><code>wireshark -i lo -f &quot;port 8080&quot;</code></td>\n<td>Protocol violations, timing issues, malformed headers</td>\n</tr>\n<tr>\n<td><code>netcat</code></td>\n<td>Manual connection testing</td>\n<td><code>nc localhost 8080</code> then type HTTP request</td>\n<td>Server response to hand-crafted requests</td>\n</tr>\n<tr>\n<td><code>telnet</code></td>\n<td>Basic connectivity testing</td>\n<td><code>telnet localhost 8080</code></td>\n<td>Whether TCP connection can be established</td>\n</tr>\n</tbody></table>\n<p><strong>Connection State Monitoring:</strong>\nUnderstanding the current state of TCP connections helps identify stuck connections, resource leaks, and capacity issues. Different connection states indicate different phases of the request-response cycle.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Monitor active connections and their states</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ss</span><span style=\"color:#79B8FF\"> -tuln</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> :8080</span><span style=\"color:#6A737D\">                    # Check if server is listening</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ss</span><span style=\"color:#79B8FF\"> -tpn</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> :8080</span><span style=\"color:#6A737D\">                     # Show active connections with process info</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">netstat</span><span style=\"color:#79B8FF\"> -an</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> :8080</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> ESTABLISHED</span><span style=\"color:#6A737D\">  # Count active client connections</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">lsof</span><span style=\"color:#79B8FF\"> -i</span><span style=\"color:#9ECBFF\"> TCP:8080</span><span style=\"color:#6A737D\">                         # Show processes using port 8080</span></span></code></pre></div>\n\n<h4 id=\"system-level-debugging\">System-Level Debugging</h4>\n<p>System-level debugging examines resource usage, process behavior, and operating system interactions. This perspective reveals issues with memory management, file descriptor usage, and system call patterns that impact server performance and stability.</p>\n<p><strong>Process and Thread Monitoring:</strong>\nUnderstanding how the server process and its threads behave under different conditions helps identify concurrency issues, resource exhaustion, and performance bottlenecks.</p>\n<table>\n<thead>\n<tr>\n<th><strong>Tool</strong></th>\n<th><strong>Purpose</strong></th>\n<th><strong>Key Commands</strong></th>\n<th><strong>Diagnostic Information</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ps</code></td>\n<td>Process state monitoring</td>\n<td>`ps -eLf</td>\n<td>grep server`</td>\n</tr>\n<tr>\n<td><code>top</code></td>\n<td>Real-time resource monitoring</td>\n<td><code>top -H -p &lt;pid&gt;</code></td>\n<td>Per-thread CPU usage, memory growth</td>\n</tr>\n<tr>\n<td><code>strace</code></td>\n<td>System call tracing</td>\n<td><code>strace -p &lt;pid&gt; -e trace=network,file</code></td>\n<td>Network operations, file access patterns</td>\n</tr>\n<tr>\n<td><code>ltrace</code></td>\n<td>Library call tracing</td>\n<td><code>ltrace -p &lt;pid&gt; -e malloc,free</code></td>\n<td>Memory allocation patterns</td>\n</tr>\n<tr>\n<td><code>pmap</code></td>\n<td>Memory mapping analysis</td>\n<td><code>pmap -x &lt;pid&gt;</code></td>\n<td>Memory layout, shared libraries</td>\n</tr>\n</tbody></table>\n<p><strong>Resource Limit Investigation:</strong>\nSystem resource limits can cause mysterious server failures that don&#39;t generate clear error messages. Checking both soft and hard limits helps identify capacity constraints.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Check resource limits for server process</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#9ECBFF\">pi</span><span style=\"color:#E1E4E8\">d</span><span style=\"color:#F97583\">></span><span style=\"color:#9ECBFF\">/limits</span><span style=\"color:#6A737D\">                   # Current limits for process</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">ulimit</span><span style=\"color:#79B8FF\"> -a</span><span style=\"color:#6A737D\">                               # Limits for current shell</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sysctl</span><span style=\"color:#9ECBFF\"> fs.file-max</span><span style=\"color:#6A737D\">                      # System-wide file descriptor limit</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /proc/sys/net/core/somaxconn</span><span style=\"color:#6A737D\">        # TCP listen backlog limit</span></span></code></pre></div>\n\n<h4 id=\"application-level-debugging\">Application-Level Debugging</h4>\n<p>Application-level debugging uses debuggers and profiling tools to examine the server&#39;s internal state, variable values, and execution flow. This level provides the most detailed view of program behavior but requires understanding of the server&#39;s implementation.</p>\n<p><strong>Interactive Debugging with GDB:</strong>\nThe GNU Debugger allows real-time examination of server state, including variable values, call stacks, and execution flow. This technique is essential for investigating deadlocks, infinite loops, and logic errors.</p>\n<table>\n<thead>\n<tr>\n<th><strong>GDB Command</strong></th>\n<th><strong>Purpose</strong></th>\n<th><strong>When to Use</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>gdb -p &lt;pid&gt;</code></td>\n<td>Attach to running server</td>\n<td>Server appears hung or behaving unexpectedly</td>\n</tr>\n<tr>\n<td><code>bt</code></td>\n<td>Show call stack</td>\n<td>Identify where server is stuck</td>\n</tr>\n<tr>\n<td><code>thread apply all bt</code></td>\n<td>Show all thread call stacks</td>\n<td>Investigate deadlocks and thread states</td>\n</tr>\n<tr>\n<td><code>p variable_name</code></td>\n<td>Print variable value</td>\n<td>Check request parsing state, connection context</td>\n</tr>\n<tr>\n<td><code>info threads</code></td>\n<td>List all threads</td>\n<td>See thread count and current activity</td>\n</tr>\n</tbody></table>\n<p><strong>Memory Debugging with Valgrind:</strong>\nValgrind detects memory leaks, buffer overflows, and invalid memory access patterns that can cause crashes or security vulnerabilities. Running the server under Valgrind during testing reveals memory management issues.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run server with comprehensive memory checking</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">valgrind</span><span style=\"color:#79B8FF\"> --leak-check=full</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">         --show-leak-kinds=all</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">         --track-origins=yes</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">         --verbose</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">         ./http_server</span><span style=\"color:#79B8FF\"> --port</span><span style=\"color:#79B8FF\"> 8080</span><span style=\"color:#79B8FF\"> --root</span><span style=\"color:#9ECBFF\"> /var/www</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Monitor for specific error types</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">valgrind</span><span style=\"color:#79B8FF\"> --tool=memcheck</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">         --track-fds=yes</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">         ./http_server</span><span style=\"color:#6A737D\">  # Track file descriptor leaks</span></span></code></pre></div>\n\n<p><strong>Performance Profiling:</strong>\nUnderstanding where the server spends its execution time helps identify performance bottlenecks and optimization opportunities.</p>\n<table>\n<thead>\n<tr>\n<th><strong>Tool</strong></th>\n<th><strong>Purpose</strong></th>\n<th><strong>Usage</strong></th>\n<th><strong>Output Analysis</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>perf</code></td>\n<td>CPU profiling</td>\n<td><code>perf record -p &lt;pid&gt;; perf report</code></td>\n<td>Function call frequency, CPU hotspots</td>\n</tr>\n<tr>\n<td><code>gprof</code></td>\n<td>Function profiling</td>\n<td>Compile with <code>-pg</code>, run server, analyze <code>gmon.out</code></td>\n<td>Function execution time, call graph</td>\n</tr>\n<tr>\n<td><code>time</code></td>\n<td>Basic timing</td>\n<td><code>time ./http_server</code></td>\n<td>Overall execution time breakdown</td>\n</tr>\n</tbody></table>\n<h3 id=\"milestone-specific-issues\">Milestone-Specific Issues</h3>\n<p>Each milestone introduces specific types of problems based on the functionality being implemented. Understanding common issues for each milestone helps focus debugging efforts and provides targeted solutions.</p>\n<h4 id=\"milestone-1-tcp-server-basics-issues\">Milestone 1: TCP Server Basics Issues</h4>\n<p>The TCP server foundation presents networking-specific challenges related to socket programming, connection management, and basic protocol handling. These issues often manifest as connection failures or server startup problems.</p>\n<p><strong>Socket Creation and Binding Problems:</strong></p>\n<p>⚠️ <strong>Pitfall: Port Already in Use</strong>\nWhen the server fails to start with &quot;Address already in use&quot; errors, another process is likely using the target port. This commonly happens when a previous server instance didn&#39;t terminate cleanly or when system services are using standard ports.</p>\n<table>\n<thead>\n<tr>\n<th><strong>Symptom</strong></th>\n<th><strong>Cause</strong></th>\n<th><strong>Diagnosis</strong></th>\n<th><strong>Solution</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>bind()</code> fails with <code>EADDRINUSE</code></td>\n<td>Another process using port</td>\n<td><code>netstat -tlnp | grep 8080</code></td>\n<td>Kill existing process or use different port</td>\n</tr>\n<tr>\n<td>Server starts but clients can&#39;t connect</td>\n<td>Binding to localhost only</td>\n<td><code>ss -tlnp | grep 8080</code></td>\n<td>Bind to <code>INADDR_ANY</code> instead of localhost</td>\n</tr>\n<tr>\n<td>Permission denied on port binding</td>\n<td>Non-root user binding privileged port</td>\n<td><code>id; echo $PORT</code></td>\n<td>Use port &gt; 1024 or run with sudo</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Incorrect Socket Options</strong>\nForgetting to set <code>SO_REUSEADDR</code> causes server restart failures when connections are in TIME_WAIT state. This is especially problematic during development when restarting the server frequently.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Missing socket option setup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> server_fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> socket</span><span style=\"color:#E1E4E8\">(AF_INET, SOCK_STREAM, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// bind() will fail if previous connections are in TIME_WAIT</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Correct approach with socket options</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> server_fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> socket</span><span style=\"color:#E1E4E8\">(AF_INET, SOCK_STREAM, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> opt </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">setsockopt</span><span style=\"color:#E1E4E8\">(server_fd, SOL_SOCKET, SO_REUSEADDR, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">opt</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(opt));</span></span></code></pre></div>\n\n<p><strong>Connection Acceptance Issues:</strong></p>\n<p>⚠️ <strong>Pitfall: Blocking Accept Loop</strong>\nUsing a simple <code>accept()</code> loop without proper signal handling or shutdown logic can create servers that cannot be stopped gracefully. The server continues accepting new connections even when shutdown is requested.</p>\n<table>\n<thead>\n<tr>\n<th><strong>Problem</strong></th>\n<th><strong>Symptom</strong></th>\n<th><strong>Investigation</strong></th>\n<th><strong>Fix</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Server cannot be stopped</td>\n<td>Process ignores SIGTERM</td>\n<td><code>kill -TERM &lt;pid&gt;; ps aux | grep server</code></td>\n<td>Add signal handler for graceful shutdown</td>\n</tr>\n<tr>\n<td>Accept loop consumes 100% CPU</td>\n<td>Server spins without blocking</td>\n<td><code>strace -p &lt;pid&gt;</code> shows rapid <code>accept()</code> calls</td>\n<td>Check <code>accept()</code> error handling</td>\n</tr>\n<tr>\n<td>Client connections dropped</td>\n<td><code>accept()</code> failing silently</td>\n<td><code>strace -e accept -p &lt;pid&gt;</code></td>\n<td>Add error logging for failed accepts</td>\n</tr>\n</tbody></table>\n<p><strong>File Descriptor Management:</strong></p>\n<p>⚠️ <strong>Pitfall: File Descriptor Leaks</strong>\nFailing to close client sockets after processing requests leads to file descriptor exhaustion. This typically manifests as the server stopping accepting new connections after handling a certain number of requests.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Monitor file descriptor usage</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">watch</span><span style=\"color:#9ECBFF\"> \"lsof -p &#x3C;server_pid> | wc -l\"</span><span style=\"color:#6A737D\">     # Total FDs in use</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#9ECBFF\">pi</span><span style=\"color:#E1E4E8\">d</span><span style=\"color:#F97583\">></span><span style=\"color:#9ECBFF\">/fd/</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> wc</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#6A737D\">               # Count open file descriptors</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#9ECBFF\">pi</span><span style=\"color:#E1E4E8\">d</span><span style=\"color:#F97583\">></span><span style=\"color:#9ECBFF\">/limits</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> \"Max open files\"</span><span style=\"color:#6A737D\">  # Check FD limit</span></span></code></pre></div>\n\n<h4 id=\"milestone-2-http-request-parsing-issues\">Milestone 2: HTTP Request Parsing Issues</h4>\n<p>HTTP parsing introduces complexity around message format compliance, buffer management, and protocol error handling. These issues often manifest as parsing failures or protocol violations.</p>\n<p><strong>Request Line Parsing Problems:</strong></p>\n<p>⚠️ <strong>Pitfall: Line Ending Confusion</strong>\nHTTP specifies CRLF (<code>\\r\\n</code>) line endings, but clients sometimes send only LF (<code>\\n</code>). Parsers that expect exact CRLF sequences fail on otherwise valid requests.</p>\n<table>\n<thead>\n<tr>\n<th><strong>Symptom</strong></th>\n<th><strong>Client Type</strong></th>\n<th><strong>Line Ending</strong></th>\n<th><strong>Parser Behavior</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Parsing fails on curl requests</td>\n<td>curl on Unix</td>\n<td>LF only</td>\n<td><code>find_line_end()</code> doesn&#39;t find CRLF</td>\n</tr>\n<tr>\n<td>Browser requests fail</td>\n<td>Some web browsers</td>\n<td>CRLF</td>\n<td>Parser works correctly</td>\n</tr>\n<tr>\n<td>Telnet testing fails</td>\n<td>Manual telnet session</td>\n<td>Mixed endings</td>\n<td>Inconsistent parsing results</td>\n</tr>\n</tbody></table>\n<p><strong>Buffer Overflow Protection:</strong></p>\n<p>⚠️ <strong>Pitfall: Unbounded Buffer Reads</strong>\nReading request data into fixed-size buffers without bounds checking can cause buffer overflows when clients send large requests or malicious input designed to exploit buffer boundaries.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Dangerous approach - no bounds checking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> buffer</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">read</span><span style=\"color:#E1E4E8\">(client_fd, buffer, </span><span style=\"color:#79B8FF\">2048</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Can overflow buffer!</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Safe approach with bounds checking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> buffer</span><span style=\"color:#E1E4E8\">[MAX_REQUEST_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#E1E4E8\"> bytes_read </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> read_complete_request</span><span style=\"color:#E1E4E8\">(client_fd, buffer, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(buffer));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (bytes_read </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(buffer)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Request too large - send 413 Entity Too Large</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Header Parsing Edge Cases:</strong></p>\n<p>⚠️ <strong>Pitfall: Header Value Whitespace</strong>\nHTTP headers can have leading and trailing whitespace around values that must be trimmed. Failing to handle this correctly causes header matching failures and incorrect behavior.</p>\n<table>\n<thead>\n<tr>\n<th><strong>Header Format</strong></th>\n<th><strong>Raw Value</strong></th>\n<th><strong>Trimmed Value</strong></th>\n<th><strong>Impact if Not Trimmed</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Host: localhost:8080</code></td>\n<td><code>localhost:8080</code></td>\n<td><code>localhost:8080</code></td>\n<td>No issue</td>\n</tr>\n<tr>\n<td><code>Host:   localhost:8080   </code></td>\n<td><code> localhost:8080  </code></td>\n<td><code>localhost:8080</code></td>\n<td>Host matching fails</td>\n</tr>\n<tr>\n<td><code>Content-Type: text/html</code></td>\n<td><code> text/html</code></td>\n<td><code>text/html</code></td>\n<td>MIME type detection fails</td>\n</tr>\n</tbody></table>\n<h4 id=\"milestone-3-static-file-serving-issues\">Milestone 3: Static File Serving Issues</h4>\n<p>File serving introduces security concerns, filesystem interaction complexity, and content type handling challenges. These issues often manifest as security vulnerabilities or incorrect content delivery.</p>\n<p><strong>Path Traversal Security:</strong></p>\n<p>⚠️ <strong>Pitfall: Directory Traversal Attacks</strong>\nFailing to properly validate and canonicalize request paths allows attackers to access files outside the document root using <code>../</code> sequences. This is a critical security vulnerability.</p>\n<table>\n<thead>\n<tr>\n<th><strong>Attack Vector</strong></th>\n<th><strong>Request Path</strong></th>\n<th><strong>Resolved Path</strong></th>\n<th><strong>Security Impact</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Basic traversal</td>\n<td><code>/../../../etc/passwd</code></td>\n<td><code>/etc/passwd</code></td>\n<td>System file access</td>\n</tr>\n<tr>\n<td>URL encoded</td>\n<td><code>/%2E%2E/%2E%2E/etc/passwd</code></td>\n<td><code>/../etc/passwd</code></td>\n<td>Bypass basic filters</td>\n</tr>\n<tr>\n<td>Mixed encoding</td>\n<td><code>/..%2F..%2Fetc%2Fpasswd</code></td>\n<td><code>/../etc/passwd</code></td>\n<td>Bypass simple validation</td>\n</tr>\n</tbody></table>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Proper path validation sequence</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> validate_and_resolve_path</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> document_root</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                             const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> request_path</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                             char*</span><span style=\"color:#FFAB70\"> resolved_path</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                             size_t</span><span style=\"color:#FFAB70\"> max_path_len</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. URL decode the request path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Normalize path (remove . and .. components)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Prepend document root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Canonicalize using realpath()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5. Verify result stays within document root</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>MIME Type Detection Issues:</strong></p>\n<p>⚠️ <strong>Pitfall: Incorrect Content-Type Headers</strong>\nSending files without proper <code>Content-Type</code> headers causes browsers to misinterpret content, leading to security issues (MIME sniffing attacks) or display problems.</p>\n<table>\n<thead>\n<tr>\n<th><strong>File Extension</strong></th>\n<th><strong>MIME Type</strong></th>\n<th><strong>Browser Behavior Without Correct Type</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>.html</code></td>\n<td><code>text/html</code></td>\n<td>May display as plain text</td>\n</tr>\n<tr>\n<td><code>.css</code></td>\n<td><code>text/css</code></td>\n<td>Stylesheet not applied</td>\n</tr>\n<tr>\n<td><code>.js</code></td>\n<td><code>application/javascript</code></td>\n<td>Script not executed</td>\n</tr>\n<tr>\n<td><code>.pdf</code></td>\n<td><code>application/pdf</code></td>\n<td>Downloaded instead of displayed</td>\n</tr>\n<tr>\n<td><code>.jpg</code></td>\n<td><code>image/jpeg</code></td>\n<td>May not display inline</td>\n</tr>\n</tbody></table>\n<p><strong>File Permission and Access Issues:</strong></p>\n<p>⚠️ <strong>Pitfall: Permission Denied Errors</strong>\nServer processes running under restricted user accounts may not have read permissions for files in the document root. This causes 403 Forbidden errors instead of 404 Not Found errors.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Check file permissions for server user</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#79B8FF\"> -u</span><span style=\"color:#9ECBFF\"> www-data</span><span style=\"color:#9ECBFF\"> ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /var/www/html/requested-file.txt</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#79B8FF\"> -u</span><span style=\"color:#9ECBFF\"> www-data</span><span style=\"color:#9ECBFF\"> cat</span><span style=\"color:#9ECBFF\"> /var/www/html/requested-file.txt</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Fix permission issues</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> chown</span><span style=\"color:#79B8FF\"> -R</span><span style=\"color:#9ECBFF\"> www-data:www-data</span><span style=\"color:#9ECBFF\"> /var/www/html/</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> chmod</span><span style=\"color:#79B8FF\"> -R</span><span style=\"color:#79B8FF\"> 644</span><span style=\"color:#9ECBFF\"> /var/www/html/</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#9ECBFF\">.txt</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> chmod</span><span style=\"color:#79B8FF\"> -R</span><span style=\"color:#79B8FF\"> 755</span><span style=\"color:#9ECBFF\"> /var/www/html/</span><span style=\"color:#6A737D\">  # Directories need execute permission</span></span></code></pre></div>\n\n<h4 id=\"milestone-4-concurrent-connections-issues\">Milestone 4: Concurrent Connections Issues</h4>\n<p>Concurrency introduces complex issues around thread safety, resource contention, and synchronization. These problems often appear only under load or in specific timing conditions.</p>\n<p><strong>Thread Safety Violations:</strong></p>\n<p>⚠️ <strong>Pitfall: Shared Data Race Conditions</strong>\nMultiple threads accessing shared data structures without proper synchronization leads to data corruption, crashes, and unpredictable behavior that only appears under concurrent load.</p>\n<table>\n<thead>\n<tr>\n<th><strong>Shared Resource</strong></th>\n<th><strong>Race Condition</strong></th>\n<th><strong>Symptom</strong></th>\n<th><strong>Solution</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Connection counter</td>\n<td>Increment/decrement without mutex</td>\n<td>Incorrect active count</td>\n<td>Use atomic operations or mutex</td>\n</tr>\n<tr>\n<td>Configuration data</td>\n<td>Modification during request processing</td>\n<td>Inconsistent behavior</td>\n<td>Make configuration read-only</td>\n</tr>\n<tr>\n<td>Log files</td>\n<td>Concurrent writes</td>\n<td>Interleaved log messages</td>\n<td>Use per-thread buffers or mutex</td>\n</tr>\n<tr>\n<td>File handle cache</td>\n<td>Cache updates</td>\n<td>File corruption</td>\n<td>Synchronize cache operations</td>\n</tr>\n</tbody></table>\n<p><strong>Thread Pool Exhaustion:</strong></p>\n<p>⚠️ <strong>Pitfall: Uncontrolled Thread Creation</strong>\nCreating unlimited threads for incoming connections leads to resource exhaustion and system instability under high load. The system runs out of memory or reaches thread limits.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Dangerous approach - unlimited thread creation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> handle_connection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> server_fd</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> client_fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> accept</span><span style=\"color:#E1E4E8\">(server_fd, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_t</span><span style=\"color:#E1E4E8\"> thread;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">thread, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, handle_client_connection, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">client_fd);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_detach</span><span style=\"color:#E1E4E8\">(thread);</span><span style=\"color:#6A737D\">  // Creates unlimited threads!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Safe approach with connection limits</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ConcurrencyManager</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> manager </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> init_concurrency_manager</span><span style=\"color:#E1E4E8\">(config, THREAD_POOL);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">get_active_connection_count</span><span style=\"color:#E1E4E8\">(manager) </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> config</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">max_connections) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    send_503_service_unavailable</span><span style=\"color:#E1E4E8\">(client_fd);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(client_fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Deadlock Detection:</strong></p>\n<p>⚠️ <strong>Pitfall: Lock Ordering Deadlocks</strong>\nMultiple threads acquiring locks in different orders can create deadlock situations where threads wait for each other indefinitely. This causes the server to hang completely.</p>\n<table>\n<thead>\n<tr>\n<th><strong>Thread A</strong></th>\n<th><strong>Thread B</strong></th>\n<th><strong>Deadlock Scenario</strong></th>\n<th><strong>Prevention</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Lock mutex1, then mutex2</td>\n<td>Lock mutex2, then mutex1</td>\n<td>Both threads wait forever</td>\n<td>Consistent lock ordering</td>\n</tr>\n<tr>\n<td>Lock connection_mutex, then stats_mutex</td>\n<td>Lock stats_mutex, then connection_mutex</td>\n<td>Circular wait condition</td>\n<td>Lock hierarchy</td>\n</tr>\n</tbody></table>\n<p><strong>Resource Cleanup Issues:</strong></p>\n<p>⚠️ <strong>Pitfall: Incomplete Thread Cleanup</strong>\nFailing to properly clean up thread resources on connection termination leads to memory leaks and resource exhaustion over time. Resources accumulate until the server becomes unstable.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Monitor thread resource usage</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ps</span><span style=\"color:#79B8FF\"> -eLf</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> server</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> wc</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#6A737D\">           # Count total threads</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#9ECBFF\">pi</span><span style=\"color:#E1E4E8\">d</span><span style=\"color:#F97583\">></span><span style=\"color:#9ECBFF\">/status</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> Threads</span><span style=\"color:#6A737D\">   # Thread count from kernel</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#9ECBFF\">pi</span><span style=\"color:#E1E4E8\">d</span><span style=\"color:#F97583\">></span><span style=\"color:#9ECBFF\">/task/</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> wc</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#6A737D\">            # Another way to count threads</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check for resource leaks over time</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">watch</span><span style=\"color:#9ECBFF\"> \"ps -o pid,ppid,tid,tty,time,cmd -L -p &#x3C;pid>\"</span></span></code></pre></div>\n\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations-table\">Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th><strong>Component</strong></th>\n<th><strong>Simple Option</strong></th>\n<th><strong>Advanced Option</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Debugging Tools</td>\n<td><code>printf()</code> debugging + <code>gdb</code></td>\n<td><code>valgrind</code> + <code>perf</code> + automated testing</td>\n</tr>\n<tr>\n<td>Log Analysis</td>\n<td><code>grep</code> + manual inspection</td>\n<td><code>logrotate</code> + structured logging</td>\n</tr>\n<tr>\n<td>Network Testing</td>\n<td><code>curl</code> + <code>telnet</code></td>\n<td><code>siege</code> + <code>ab</code> (Apache Bench)</td>\n</tr>\n<tr>\n<td>Memory Debugging</td>\n<td><code>valgrind --leak-check=simple</code></td>\n<td><code>valgrind --leak-check=full</code> + heap profiling</td>\n</tr>\n<tr>\n<td>Performance Testing</td>\n<td>Single client testing</td>\n<td>Multi-threaded load testing</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  debug/\n    debug.h                  ← Debug macros and logging utilities\n    debug.c                  ← Debug implementation\n    test_client.c           ← Simple client for testing\n    load_test.c             ← Concurrent load testing tool\n  logs/\n    server.log              ← Application log output\n    access.log              ← HTTP request logging\n    error.log               ← Error-specific logging\n  tools/\n    monitor.sh              ← System resource monitoring script\n    test_suite.sh           ← Automated test runner\n    debug_server.sh         ← Script to start server with debugging</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Debug Logging Utility (<code>debug/debug.h</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> DEBUG_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEBUG_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;time.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/types.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Debug levels</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DEBUG_ERROR </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DEBUG_WARN </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DEBUG_INFO </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DEBUG_DEBUG </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DEBUG_TRACE </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 4</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} DebugLevel;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Debug configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#E1E4E8\"> DebugLevel current_debug_level;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#E1E4E8\"> FILE</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> debug_output;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize debugging system</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> init_debug_system</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> log_file</span><span style=\"color:#E1E4E8\">, DebugLevel </span><span style=\"color:#FFAB70\">level</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> cleanup_debug_system</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Logging macros with file, line, and timestamp</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEBUG_LOG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">level</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fmt</span><span style=\"color:#E1E4E8\">, ...) </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    do</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (level </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> current_debug_level) { </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            time_t</span><span style=\"color:#E1E4E8\"> now </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            struct</span><span style=\"color:#E1E4E8\"> tm</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> tm_info </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> localtime</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">now); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(debug_output, </span><span style=\"color:#9ECBFF\">\"[</span><span style=\"color:#79B8FF\">%04d</span><span style=\"color:#9ECBFF\">-</span><span style=\"color:#79B8FF\">%02d</span><span style=\"color:#9ECBFF\">-</span><span style=\"color:#79B8FF\">%02d</span><span style=\"color:#79B8FF\"> %02d</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">%02d</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">%02d</span><span style=\"color:#9ECBFF\">] [</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">] </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">: \"</span><span style=\"color:#E1E4E8\"> fmt </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    tm_info->tm_year </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1900</span><span style=\"color:#E1E4E8\">, tm_info->tm_mon </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, tm_info->tm_mday, </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    tm_info->tm_hour, tm_info->tm_min, tm_info->tm_sec, </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    level_to_string</span><span style=\"color:#E1E4E8\">(level), </span><span style=\"color:#B392F0\">__FILE__</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">__LINE__</span><span style=\"color:#E1E4E8\">, ##</span><span style=\"color:#B392F0\">__VA_ARGS__</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fflush</span><span style=\"color:#E1E4E8\">(debug_output); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ERROR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fmt</span><span style=\"color:#E1E4E8\">, ...)   </span><span style=\"color:#B392F0\">DEBUG_LOG</span><span style=\"color:#E1E4E8\">(DEBUG_ERROR, fmt, ##</span><span style=\"color:#B392F0\">__VA_ARGS__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> WARN</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fmt</span><span style=\"color:#E1E4E8\">, ...)    </span><span style=\"color:#B392F0\">DEBUG_LOG</span><span style=\"color:#E1E4E8\">(DEBUG_WARN, fmt, ##</span><span style=\"color:#B392F0\">__VA_ARGS__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> INFO</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fmt</span><span style=\"color:#E1E4E8\">, ...)    </span><span style=\"color:#B392F0\">DEBUG_LOG</span><span style=\"color:#E1E4E8\">(DEBUG_INFO, fmt, ##</span><span style=\"color:#B392F0\">__VA_ARGS__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEBUG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fmt</span><span style=\"color:#E1E4E8\">, ...)   </span><span style=\"color:#B392F0\">DEBUG_LOG</span><span style=\"color:#E1E4E8\">(DEBUG_DEBUG, fmt, ##</span><span style=\"color:#B392F0\">__VA_ARGS__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TRACE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fmt</span><span style=\"color:#E1E4E8\">, ...)   </span><span style=\"color:#B392F0\">DEBUG_LOG</span><span style=\"color:#E1E4E8\">(DEBUG_TRACE, fmt, ##</span><span style=\"color:#B392F0\">__VA_ARGS__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Performance timing helpers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> timespec start_time;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> operation_name;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} PerfTimer;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> start_perf_timer</span><span style=\"color:#E1E4E8\">(PerfTimer</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> timer</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> operation</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> end_perf_timer</span><span style=\"color:#E1E4E8\">(PerfTimer</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> timer</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Memory debugging helpers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> debug_malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> file</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> debug_free</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> file</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifdef</span><span style=\"color:#B392F0\"> DEBUG_MEMORY</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">size</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">debug_malloc</span><span style=\"color:#E1E4E8\">(size, </span><span style=\"color:#B392F0\">__FILE__</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">__LINE__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> free</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ptr</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">debug_free</span><span style=\"color:#E1E4E8\">(ptr, </span><span style=\"color:#B392F0\">__FILE__</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">__LINE__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Network debugging helpers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> dump_http_request</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> HTTPRequest</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> request</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> dump_http_response</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> HTTPResponse</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> response</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> dump_connection_context</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> ConnectionContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> context</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> log_connection_event</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> ConnectionContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> event</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Resource monitoring</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> log_resource_usage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> server_pid</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> check_file_descriptor_leaks</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> server_pid</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> // DEBUG_H</span></span></code></pre></div>\n\n<p><strong>Test Client Utility (<code>debug/test_client.c</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/socket.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;netinet/in.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;arpa/inet.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;pthread.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;time.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"debug.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> server_host</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> server_port;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> request_path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> client_id;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int*</span><span style=\"color:#E1E4E8\"> success_count;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_mutex_t*</span><span style=\"color:#E1E4E8\"> count_mutex;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ClientConfig;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complete test client implementation for concurrent testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> send_http_request</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> host</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> port</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                     char*</span><span style=\"color:#FFAB70\"> response</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> max_response</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> sockfd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> socket</span><span style=\"color:#E1E4E8\">(AF_INET, SOCK_STREAM, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (sockfd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ERROR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to create socket: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">strerror</span><span style=\"color:#E1E4E8\">(errno));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> sockaddr_in server_addr;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">server_addr, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(server_addr));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server_addr.sin_family </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> AF_INET;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server_addr.sin_port </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> htons</span><span style=\"color:#E1E4E8\">(port);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">inet_pton</span><span style=\"color:#E1E4E8\">(AF_INET, host, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">server_addr.sin_addr) </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ERROR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Invalid address: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, host);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(sockfd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">connect</span><span style=\"color:#E1E4E8\">(sockfd, (</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> sockaddr</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">server_addr, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(server_addr)) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ERROR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Connection failed: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">strerror</span><span style=\"color:#E1E4E8\">(errno));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(sockfd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Send HTTP request</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> request</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(request, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(request),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">             \"GET </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> HTTP/1.1</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">             \"Host: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">%d\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">             \"Connection: close</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">             \"</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">             path, host, port);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> sent </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> send</span><span style=\"color:#E1E4E8\">(sockfd, request, </span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(request), </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (sent </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ERROR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to send request: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">strerror</span><span style=\"color:#E1E4E8\">(errno));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(sockfd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Receive response</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> received </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> recv</span><span style=\"color:#E1E4E8\">(sockfd, response, max_response </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (received </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ERROR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to receive response: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">strerror</span><span style=\"color:#E1E4E8\">(errno));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(sockfd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    response</span><span style=\"color:#E1E4E8\">[received] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(sockfd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> client_thread</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> arg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ClientConfig</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> config </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ClientConfig</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)arg;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> response</span><span style=\"color:#E1E4E8\">[MAX_RESPONSE_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    INFO</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Client </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> starting request to </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">%d%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">         config->client_id, config->server_host, config->server_port, config->request_path);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> send_http_request</span><span style=\"color:#E1E4E8\">(config->server_host, config->server_port, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                  config->request_path, response, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(response));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (result </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check for successful HTTP response</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strstr</span><span style=\"color:#E1E4E8\">(response, </span><span style=\"color:#9ECBFF\">\"HTTP/1.1 200\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(config->count_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">config->success_count)</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(config->count_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            INFO</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Client </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> received successful response\"</span><span style=\"color:#E1E4E8\">, config->client_id);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            WARN</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Client </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> received error response: </span><span style=\"color:#79B8FF\">%.100s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, config->client_id, response);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ERROR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Client </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> failed to send request\"</span><span style=\"color:#E1E4E8\">, config->client_id);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Main function for concurrent client testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char*</span><span style=\"color:#FFAB70\"> argv</span><span style=\"color:#F97583\">[]</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (argc </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Usage: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> &#x3C;host> &#x3C;port> &#x3C;path> &#x3C;num_clients></span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    init_debug_system</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"test_client.log\"</span><span style=\"color:#E1E4E8\">, DEBUG_INFO);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> host </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> port </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> atoi</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> path </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> num_clients </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> atoi</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_t</span><span style=\"color:#FFAB70\"> threads</span><span style=\"color:#E1E4E8\">[MAX_CONCURRENT_CLIENTS];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ClientConfig </span><span style=\"color:#FFAB70\">configs</span><span style=\"color:#E1E4E8\">[MAX_CONCURRENT_CLIENTS];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> success_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_mutex_t</span><span style=\"color:#E1E4E8\"> count_mutex </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PTHREAD_MUTEX_INITIALIZER;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (num_clients </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> MAX_CONCURRENT_CLIENTS) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ERROR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Too many clients requested. Maximum is </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, MAX_CONCURRENT_CLIENTS);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    INFO</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Starting concurrent test with </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> clients\"</span><span style=\"color:#E1E4E8\">, num_clients);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    time_t</span><span style=\"color:#E1E4E8\"> start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create client threads</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> num_clients; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        strncpy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">configs</span><span style=\"color:#E1E4E8\">[i].server_host, host, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">configs</span><span style=\"color:#E1E4E8\">[i].server_host) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        configs</span><span style=\"color:#E1E4E8\">[i].server_port </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> port;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        strncpy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">configs</span><span style=\"color:#E1E4E8\">[i].request_path, path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">configs</span><span style=\"color:#E1E4E8\">[i].request_path) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        configs</span><span style=\"color:#E1E4E8\">[i].client_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> i;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        configs</span><span style=\"color:#E1E4E8\">[i].success_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">success_count;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        configs</span><span style=\"color:#E1E4E8\">[i].count_mutex </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">count_mutex;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">pthread_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">threads</span><span style=\"color:#E1E4E8\">[i], </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, client_thread, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">configs</span><span style=\"color:#E1E4E8\">[i]) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            ERROR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to create client thread </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, i);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Wait for all clients to complete</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> num_clients; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pthread_join</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">threads</span><span style=\"color:#E1E4E8\">[i], </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    time_t</span><span style=\"color:#E1E4E8\"> end_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    INFO</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Test completed: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> requests succeeded in </span><span style=\"color:#79B8FF\">%ld</span><span style=\"color:#9ECBFF\"> seconds\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">         success_count, num_clients, end_time </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start_time);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    cleanup_debug_system</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (success_count </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> num_clients) </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> :</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>Debug Integration Points (<code>debug/debug.c</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"debug.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"../http_server.h\"</span><span style=\"color:#6A737D\">  // Include main server headers</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO 1: Implement debug level configuration from command line or config file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO 2: Add rotation support for log files to prevent disk space issues</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO 3: Implement performance counters for requests per second, average response time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO 4: Add memory leak detection hooks that track malloc/free pairs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO 5: Implement network event logging for connection accept, close, error events</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> init_debug_system</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> log_file</span><span style=\"color:#E1E4E8\">, DebugLevel </span><span style=\"color:#FFAB70\">level</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Open log file with error checking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Set up signal handlers for log rotation (SIGUSR1)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Initialize performance monitoring structures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Set debug level and validate range</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> log_request_processing</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> HTTPRequest</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> request</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> ConnectionContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> context</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Log request line (method, path, version) with client IP</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Log important headers (Host, Content-Length, User-Agent)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Record request timestamp for performance measurement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Assign unique request ID for tracking through processing pipeline</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Log any security-relevant information (potential attacks)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> log_response_generation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> HTTPResponse</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> response</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> ConnectionContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> context</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Log response status code and reason phrase</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Log response size (Content-Length) for bandwidth monitoring</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Calculate and log request processing time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Log any errors that occurred during request processing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update performance counters (total requests, success rate)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> debug_connection_state</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> ConnectionContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> context</span><span style=\"color:#E1E4E8\">, ConnectionState </span><span style=\"color:#FFAB70\">state</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Log state transition with timestamp and connection ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Track connection duration in each state for performance analysis</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Detect stuck connections that stay in same state too long</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Log thread ID handling this connection for concurrency debugging</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Record any error conditions that triggered state changes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> monitor_server_health</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> server_pid</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Read /proc/&#x3C;pid>/stat to get CPU usage, memory usage, thread count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Count open file descriptors in /proc/&#x3C;pid>/fd/ directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check listening socket status and connection queue depth</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Monitor for memory leaks by tracking heap size growth</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Alert if resource usage exceeds configurable thresholds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use /proc filesystem for detailed process information</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<p><strong>GDB Debugging Techniques:</strong></p>\n<ul>\n<li>Use <code>set follow-fork-mode child</code> to debug worker threads in thread-per-connection model</li>\n<li>Create <code>.gdbinit</code> file with custom commands for examining server structures</li>\n<li>Use <code>thread apply all bt</code> to see all thread call stacks when investigating deadlocks</li>\n<li>Set conditional breakpoints: <code>break handle_client_connection if client_fd == 7</code></li>\n</ul>\n<p><strong>Valgrind Memory Debugging:</strong></p>\n<ul>\n<li>Compile with <code>-g -O0</code> for better stack traces in Valgrind output</li>\n<li>Use <code>--track-origins=yes</code> to see where uninitialized memory came from</li>\n<li>Set <code>--leak-check=full --show-leak-kinds=all</code> for comprehensive leak detection</li>\n<li>Use suppressions file to ignore false positives from system libraries</li>\n</ul>\n<p><strong>System Call Tracing:</strong></p>\n<ul>\n<li>Use <code>strace -e trace=network,file</code> to see only networking and file operations</li>\n<li>Add <code>-f</code> flag to trace child processes and threads</li>\n<li>Use <code>-o trace.log</code> to capture output to file for analysis</li>\n<li>Filter specific operations: <code>strace -e trace=read,write,accept,close</code></li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p><strong>After Implementing Debug Infrastructure:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Compile server with debug support</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -DDEBUG_MEMORY</span><span style=\"color:#79B8FF\"> -g</span><span style=\"color:#79B8FF\"> -O0</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> http_server</span><span style=\"color:#79B8FF\"> *</span><span style=\"color:#9ECBFF\">.c</span><span style=\"color:#79B8FF\"> -lpthread</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Start server with debug logging</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./http_server</span><span style=\"color:#79B8FF\"> --debug-level=3</span><span style=\"color:#79B8FF\"> --log-file=debug.log</span><span style=\"color:#79B8FF\"> --port=8080</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test with concurrent clients</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./test_client</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8080</span><span style=\"color:#9ECBFF\"> /index.html</span><span style=\"color:#79B8FF\"> 10</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check for resource leaks</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">valgrind</span><span style=\"color:#79B8FF\"> --leak-check=full</span><span style=\"color:#9ECBFF\"> ./http_server</span><span style=\"color:#79B8FF\"> --port=8081</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sleep</span><span style=\"color:#79B8FF\"> 5</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./test_client</span><span style=\"color:#9ECBFF\"> localhost</span><span style=\"color:#79B8FF\"> 8081</span><span style=\"color:#9ECBFF\"> /</span><span style=\"color:#79B8FF\"> 5</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">kill</span><span style=\"color:#9ECBFF\"> %1</span></span></code></pre></div>\n\n<p><strong>Expected Debug Output:</strong></p>\n<ul>\n<li>Connection accept and close events with timestamps</li>\n<li>Request parsing progress with validation results</li>\n<li>File serving operations with path resolution details</li>\n<li>Thread creation and cleanup events</li>\n<li>Performance timing for each request phase</li>\n<li>Resource usage summaries (memory, file descriptors, threads)</li>\n</ul>\n<p><strong>Signs of Issues:</strong></p>\n<ul>\n<li>Missing cleanup log entries indicate resource leaks</li>\n<li>Increasing response times suggest performance degradation</li>\n<li>Error logs with stack traces indicate crash conditions</li>\n<li>File descriptor counts that don&#39;t decrease indicate leaks</li>\n</ul>\n<h2 id=\"future-extensions\">Future Extensions</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Beyond Milestones 1-4 - explores potential enhancements and architectural considerations for evolving the HTTP server into a production-quality system</p>\n</blockquote>\n<p>The future extensions section serves as our <strong>roadmap for growth</strong> - examining how the current educational HTTP server can evolve into a production-ready system while maintaining its architectural foundations. Think of this like <strong>planning the expansion of a successful small business</strong>: we need to understand which parts of our current structure will scale gracefully, which components will need fundamental redesign, and how to prioritize improvements based on real-world usage patterns.</p>\n<p>The beauty of a well-designed educational project lies not just in what it teaches initially, but in how it <strong>grows with the learner</strong>. Our current HTTP server implementation provides a solid foundation of networking, HTTP protocol handling, and concurrency management concepts. However, the gap between an educational server and a production system involves numerous considerations around performance, security, standards compliance, and operational requirements.</p>\n<p>This section explores three major categories of extensions: <strong>HTTP protocol enhancements</strong> that expand our standards compliance and feature set, <strong>performance optimizations</strong> that enable the server to handle production-scale loads efficiently, and <strong>security enhancements</strong> that protect against real-world threats. Each category represents a different dimension of system evolution, and understanding their interactions helps guide prioritization decisions.</p>\n<p>The architectural decisions we made during the initial implementation - particularly around component separation, data structure design, and error handling patterns - directly impact how easily these extensions can be integrated. Well-designed extensibility points become <strong>force multipliers</strong> for future development, while architectural technical debt creates <strong>friction and complexity</strong> that slows enhancement efforts.</p>\n<h3 id=\"http-protocol-extensions\">HTTP Protocol Extensions</h3>\n<p>The HTTP protocol landscape extends far beyond the basic GET request handling implemented in our educational server. Modern web applications require support for additional HTTP methods, transfer encoding mechanisms, and protocol versions that enable richer client-server interactions and improved performance characteristics.</p>\n<h4 id=\"mental-model-library-service-expansion\">Mental Model: Library Service Expansion</h4>\n<p>Think of HTTP protocol extensions like <strong>expanding a library&#39;s services</strong>. Our current server is like a basic reference desk that can find and deliver books (static files). Adding POST support is like adding a <strong>suggestion box</strong> where patrons can submit new information. Implementing chunked encoding is like allowing <strong>serialized novel delivery</strong> - sending a long book chapter by chapter rather than making patrons wait for the complete volume. Upgrading to HTTP/2 is like <strong>revolutionizing the entire library system</strong> - allowing multiple simultaneous book requests, prioritized delivery, and compressed catalog information.</p>\n<p>Each protocol extension builds upon our existing foundation while adding new capabilities that serve different use cases and performance requirements.</p>\n<h4 id=\"post-request-support\">POST Request Support</h4>\n<p>Adding POST request support represents the most fundamental HTTP protocol extension, transforming our server from a <strong>read-only content delivery system</strong> into a <strong>bidirectional communication platform</strong>. This enhancement primarily impacts our HTTP parser component and requires new data handling patterns throughout the request processing pipeline.</p>\n<p>The POST method differs significantly from GET requests in several key aspects. POST requests typically include substantial <strong>message body content</strong> that must be parsed, validated, and processed according to the specified Content-Type header. Unlike GET requests where all parameters are encoded in the URL path and query string, POST requests can carry <strong>arbitrary payload data</strong> ranging from form submissions to JSON API calls to file uploads.</p>\n<p>Our current <code>HTTPRequest</code> structure already includes <code>body</code> and <code>body_length</code> fields designed to accommodate POST request handling, but the parser implementation focuses exclusively on GET request scenarios. Extending POST support requires enhancing the <code>parse_message_body</code> function to handle different encoding types and implementing new request processing logic throughout the system.</p>\n<table>\n<thead>\n<tr>\n<th>POST Implementation Component</th>\n<th>Current State</th>\n<th>Required Enhancement</th>\n<th>Complexity Level</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Request Body Parsing</td>\n<td>Placeholder implementation</td>\n<td>Full Content-Length and Content-Type handling</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td>Form Data Processing</td>\n<td>Not implemented</td>\n<td>URL-encoded and multipart parsing</td>\n<td>High</td>\n</tr>\n<tr>\n<td>JSON Payload Handling</td>\n<td>Not implemented</td>\n<td>JSON parsing and validation</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td>File Upload Support</td>\n<td>Not implemented</td>\n<td>Multipart form processing with file boundaries</td>\n<td>High</td>\n</tr>\n<tr>\n<td>Request Routing</td>\n<td>Path-based only</td>\n<td>Method-based routing with POST endpoints</td>\n<td>Low</td>\n</tr>\n<tr>\n<td>Response Generation</td>\n<td>Static content only</td>\n<td>Dynamic response creation based on POST data</td>\n<td>Medium</td>\n</tr>\n</tbody></table>\n<p>The most straightforward POST enhancement involves implementing <strong>application/x-www-form-urlencoded</strong> form processing, where the message body contains key-value pairs encoded similar to URL query parameters. This builds directly on existing URL parsing concepts while introducing message body handling patterns.</p>\n<p>More sophisticated POST implementations require supporting <strong>multipart/form-data</strong> encoding for file uploads, which introduces complex parsing logic for boundary detection and multiple content sections within a single request. The multipart parsing challenge involves state machine logic similar to our existing HTTP header parsing but with additional complexity around binary data handling and content boundary recognition.</p>\n<blockquote>\n<p><strong>Key Design Insight</strong>: POST request support fundamentally changes the server&#39;s role from a passive content delivery system to an active data processing system, requiring careful consideration of data validation, storage, and security implications.</p>\n</blockquote>\n<p><strong>Architecture Decision Record for POST Implementation Strategy:</strong></p>\n<blockquote>\n<p><strong>Decision: Form-First POST Implementation</strong></p>\n<ul>\n<li><strong>Context</strong>: Multiple POST payload types have different complexity levels and use cases, requiring prioritization of implementation order</li>\n<li><strong>Options Considered</strong>: 1) JSON-first API server approach, 2) Form-first web application approach, 3) Generic payload processor</li>\n<li><strong>Decision</strong>: Implement form-encoded POST requests first, followed by JSON, then multipart file uploads</li>\n<li><strong>Rationale</strong>: Form encoding builds naturally on existing URL parsing logic, provides immediate value for web applications, and establishes message body processing patterns for more complex formats</li>\n<li><strong>Consequences</strong>: Creates a natural progression from simple to complex POST handling while maintaining compatibility with existing GET-focused architecture</li>\n</ul>\n</blockquote>\n<h4 id=\"chunked-transfer-encoding\">Chunked Transfer Encoding</h4>\n<p>Chunked transfer encoding addresses a fundamental limitation in our current static file serving approach: the requirement to know the complete response size before sending the HTTP headers. This encoding mechanism enables <strong>streaming response delivery</strong> where content can be generated and transmitted incrementally without buffering the entire response in memory.</p>\n<p>The current file serving implementation uses the <code>serve_file_content</code> function to read complete files into memory and set the Content-Length header before transmission. This approach works well for small static files but creates <strong>memory pressure</strong> and <strong>response latency</strong> issues for large files or dynamically generated content.</p>\n<p>Chunked encoding transforms the HTTP response format by removing the Content-Length header and instead sending the message body as a series of <strong>size-prefixed chunks</strong> terminated by a zero-length chunk. Each chunk includes a hexadecimal size indicator followed by the actual data bytes, enabling the client to reconstruct the complete response without knowing the total size in advance.</p>\n<table>\n<thead>\n<tr>\n<th>Chunked Encoding Component</th>\n<th>Implementation Requirements</th>\n<th>Integration Points</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Response Header Modification</td>\n<td>Replace Content-Length with Transfer-Encoding: chunked</td>\n<td><code>add_response_header</code> function</td>\n</tr>\n<tr>\n<td>Chunk Size Calculation</td>\n<td>Determine optimal chunk sizes for different content types</td>\n<td>File reading and response generation</td>\n</tr>\n<tr>\n<td>Chunk Formatting</td>\n<td>Hex size prefix + CRLF + data + CRLF formatting</td>\n<td>Socket writing functions</td>\n</tr>\n<tr>\n<td>Stream Processing</td>\n<td>Read-process-send pipeline instead of read-all-send</td>\n<td><code>serve_file_content</code> redesign</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Partial chunk transmission and recovery scenarios</td>\n<td>Connection cleanup procedures</td>\n</tr>\n<tr>\n<td>Client Compatibility</td>\n<td>HTTP/1.1 compliance and graceful fallback</td>\n<td>Request parsing and negotiation</td>\n</tr>\n</tbody></table>\n<p>The implementation challenge centers around <strong>transforming our file serving pipeline</strong> from a buffer-based approach to a streaming approach. Instead of calling <code>read_file_content</code> to load an entire file, the chunked implementation requires a <code>stream_file_content</code> function that reads fixed-size chunks, formats them according to the chunked encoding specification, and sends them immediately.</p>\n<p>Chunked encoding particularly benefits scenarios involving <strong>large static files</strong> (videos, archives, datasets) and <strong>dynamic content generation</strong> (server-side rendering, API responses based on database queries). The memory usage remains constant regardless of response size, and clients can begin processing received data before the complete response arrives.</p>\n<p>The error handling implications of chunked encoding extend beyond simple file reading failures. Network interruptions during chunk transmission create <strong>partially transmitted responses</strong> that require careful cleanup and potential retry logic. Unlike fixed-length responses where clients can easily detect incomplete transmissions, chunked responses require proper termination with a zero-length chunk to signal completion.</p>\n<blockquote>\n<p><strong>Performance Consideration</strong>: Chunked encoding trades CPU overhead (chunk formatting) for memory efficiency and reduced latency, making it particularly valuable for resource-constrained servers handling large files or high concurrency loads.</p>\n</blockquote>\n<h4 id=\"http2-protocol-support\">HTTP/2 Protocol Support</h4>\n<p>HTTP/2 represents the most significant protocol enhancement, introducing <strong>multiplexed streams</strong>, <strong>header compression</strong>, <strong>server push</strong>, and <strong>binary framing</strong> that fundamentally change client-server communication patterns. This upgrade provides substantial performance benefits but requires extensive architectural modifications throughout our server implementation.</p>\n<p>The current HTTP server operates on HTTP/1.1 assumptions: <strong>one request per connection</strong>, <strong>text-based headers</strong>, and <strong>sequential request processing</strong>. HTTP/2 transforms each TCP connection into a <strong>multiplexed stream container</strong> where multiple requests and responses can be interleaved, prioritized, and processed concurrently.</p>\n<p><strong>Key HTTP/2 Features and Implementation Challenges:</strong></p>\n<table>\n<thead>\n<tr>\n<th>HTTP/2 Feature</th>\n<th>Description</th>\n<th>Implementation Complexity</th>\n<th>Architectural Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Binary Framing</td>\n<td>Replace text-based protocol with binary frame format</td>\n<td>High</td>\n<td>Complete parser rewrite</td>\n</tr>\n<tr>\n<td>Stream Multiplexing</td>\n<td>Multiple requests per connection with stream IDs</td>\n<td>Very High</td>\n<td>Concurrency model redesign</td>\n</tr>\n<tr>\n<td>Header Compression (HPACK)</td>\n<td>Stateful header compression across requests</td>\n<td>High</td>\n<td>New compression state management</td>\n</tr>\n<tr>\n<td>Server Push</td>\n<td>Proactive resource delivery before client requests</td>\n<td>Medium</td>\n<td>New response generation patterns</td>\n</tr>\n<tr>\n<td>Flow Control</td>\n<td>Per-stream and connection-level flow control</td>\n<td>High</td>\n<td>New backpressure handling</td>\n</tr>\n<tr>\n<td>Stream Prioritization</td>\n<td>Client-specified request priority handling</td>\n<td>Medium</td>\n<td>Scheduler implementation</td>\n</tr>\n</tbody></table>\n<p>The <strong>binary framing layer</strong> represents the foundation of HTTP/2 implementation, requiring a complete replacement of our text-based HTTP parser with a binary frame parser that handles different frame types (DATA, HEADERS, SETTINGS, WINDOW_UPDATE, etc.). This change affects every component that currently processes HTTP messages.</p>\n<p><strong>Stream multiplexing</strong> introduces the most significant architectural challenge: transforming our connection-based concurrency model into a <strong>stream-based model</strong>. Instead of dedicating threads or event handlers to individual connections, HTTP/2 requires managing multiple concurrent streams within each connection while maintaining proper flow control and prioritization.</p>\n<p>The HPACK header compression algorithm maintains <strong>connection-specific compression state</strong> that must be synchronized between client and server across all streams within a connection. This stateful compression provides significant bandwidth savings for repeated headers but introduces complexity around state management and error recovery.</p>\n<p><strong>HTTP/2 Architecture Decision Record:</strong></p>\n<blockquote>\n<p><strong>Decision: HTTP/2 as Separate Server Implementation</strong></p>\n<ul>\n<li><strong>Context</strong>: HTTP/2 requires extensive architectural changes that conflict with educational clarity of current HTTP/1.1 implementation</li>\n<li><strong>Options Considered</strong>: 1) Extend current server with HTTP/2 support, 2) Create separate HTTP/2 server, 3) Implement HTTP/2 proxy layer</li>\n<li><strong>Decision</strong>: Implement HTTP/2 as a separate server that shares file handling and configuration components</li>\n<li><strong>Rationale</strong>: Maintains educational clarity of HTTP/1.1 implementation while allowing HTTP/2 exploration without architectural compromises</li>\n<li><strong>Consequences</strong>: Requires code duplication for shared functionality but preserves learning progression and enables focused HTTP/2 study</li>\n</ul>\n</blockquote>\n<p>HTTP/2 server push capabilities enable <strong>proactive resource delivery</strong> where the server anticipates client needs and sends resources before explicit requests. For static file servers, this might involve automatically pushing CSS and JavaScript files when serving HTML pages, reducing overall page load times.</p>\n<p>The implementation complexity of full HTTP/2 support suggests treating it as a <strong>separate learning project</strong> rather than an extension of the current server. The concepts learned from HTTP/1.1 implementation provide essential background for understanding HTTP/2 benefits and trade-offs, but the implementation approaches differ significantly enough to warrant dedicated focus.</p>\n<h3 id=\"performance-optimizations\">Performance Optimizations</h3>\n<p>Performance optimization transforms our educational HTTP server from a <strong>learning demonstration</strong> into a <strong>production-capable system</strong> by addressing efficiency bottlenecks, resource utilization patterns, and scalability limitations inherent in the straightforward implementation approach.</p>\n<h4 id=\"mental-model-restaurant-efficiency-improvements\">Mental Model: Restaurant Efficiency Improvements</h4>\n<p>Think of performance optimizations like <strong>improving restaurant operations</strong>. Our current server is like a small family restaurant that prepares each order individually from scratch - functional but inefficient under load. Adding caching is like <strong>preparing popular dishes in advance</strong> and keeping them warm. Connection pooling is like <strong>seating arrangements</strong> that minimize table turnover time. Asynchronous I/O is like <strong>optimizing kitchen workflow</strong> so cooks don&#39;t wait idle while ingredients are being prepared.</p>\n<p>Each optimization addresses specific bottlenecks while maintaining the core functionality and correctness of the original system.</p>\n<h4 id=\"response-caching-system\">Response Caching System</h4>\n<p>Response caching addresses the fundamental inefficiency of <strong>repeatedly reading and processing identical static files</strong> for multiple client requests. Our current implementation calls <code>serve_file_content</code> for every request, resulting in redundant file system operations, memory allocations, and response formatting work.</p>\n<p>A well-designed caching system maintains <strong>pre-processed response data</strong> in memory for frequently requested files, eliminating file system access latency and reducing CPU overhead for duplicate requests. The caching implementation requires careful consideration of memory usage, cache invalidation policies, and thread safety for concurrent access patterns.</p>\n<p><strong>Cache Architecture Components:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Cache Component</th>\n<th>Responsibility</th>\n<th>Design Considerations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cache Storage</td>\n<td>In-memory response data storage</td>\n<td>Memory limits, eviction policies, data structure efficiency</td>\n</tr>\n<tr>\n<td>Cache Keys</td>\n<td>Unique identifiers for cached responses</td>\n<td>File path normalization, query parameter handling</td>\n</tr>\n<tr>\n<td>Cache Validation</td>\n<td>Determining when cached data is stale</td>\n<td>File modification time tracking, TTL policies</td>\n</tr>\n<tr>\n<td>Cache Population</td>\n<td>Loading and formatting responses for storage</td>\n<td>Background vs. on-demand loading strategies</td>\n</tr>\n<tr>\n<td>Cache Eviction</td>\n<td>Removing entries when memory limits reached</td>\n<td>LRU, LFU, or size-based eviction algorithms</td>\n</tr>\n<tr>\n<td>Thread Safety</td>\n<td>Concurrent access protection</td>\n<td>Read-write locks, atomic operations</td>\n</tr>\n</tbody></table>\n<p>The cache key generation strategy directly impacts both <strong>correctness</strong> and <strong>performance</strong>. Simple file path keys work for basic static serving but require enhancement for scenarios involving query parameters, range requests, or content negotiation. Cache keys must account for all factors that influence response content while remaining efficient to compute and compare.</p>\n<p><strong>Cache Validation Mechanisms:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Validation Approach</th>\n<th>Implementation</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>File Modification Time</td>\n<td>Compare cached mtime with current file mtime</td>\n<td>Simple, automatic invalidation</td>\n<td>Requires stat() system call per request</td>\n</tr>\n<tr>\n<td>Time-To-Live (TTL)</td>\n<td>Expire entries after fixed time period</td>\n<td>Minimal overhead, predictable memory usage</td>\n<td>May serve stale content, requires tuning</td>\n</tr>\n<tr>\n<td>Manual Invalidation</td>\n<td>Administrative cache clearing commands</td>\n<td>Precise control over freshness</td>\n<td>Requires operational procedures</td>\n</tr>\n<tr>\n<td>Content Hashing</td>\n<td>Hash file contents for change detection</td>\n<td>Accurate change detection</td>\n<td>CPU overhead for large files</td>\n</tr>\n</tbody></table>\n<p>Memory management becomes critical for caching systems serving diverse content types and sizes. <strong>Large file caching</strong> can quickly exhaust available memory, while <strong>many small files</strong> create overhead from cache entry bookkeeping. Effective cache implementations require <strong>adaptive policies</strong> that balance memory usage against cache hit rates.</p>\n<p>The thread safety requirements for caching introduce <strong>reader-writer lock patterns</strong> where multiple threads can simultaneously read cached responses but cache updates require exclusive access. High-performance implementations might use <strong>lock-free data structures</strong> or <strong>per-thread cache partitions</strong> to minimize synchronization overhead.</p>\n<blockquote>\n<p><strong>Cache Design Insight</strong>: The optimal cache strategy depends heavily on access patterns - a few frequently requested files benefit from simple LRU caching, while many equally popular files require more sophisticated memory management and eviction policies.</p>\n</blockquote>\n<p><strong>Architecture Decision Record for Cache Implementation:</strong></p>\n<blockquote>\n<p><strong>Decision: Two-Tier Cache with Size-Based Eviction</strong></p>\n<ul>\n<li><strong>Context</strong>: Static file servers exhibit varied access patterns from hot index pages to diverse asset files, requiring different caching strategies</li>\n<li><strong>Options Considered</strong>: 1) Simple LRU cache, 2) TTL-based cache, 3) Two-tier cache with hot/warm separation</li>\n<li><strong>Decision</strong>: Implement small hot cache for most frequent files plus larger warm cache with size-based eviction</li>\n<li><strong>Rationale</strong>: Hot cache ensures best performance for critical files, warm cache handles diverse access patterns without excessive memory usage</li>\n<li><strong>Consequences</strong>: Increased implementation complexity but better performance characteristics across different usage patterns</li>\n</ul>\n</blockquote>\n<h4 id=\"connection-pooling-and-keep-alive\">Connection Pooling and Keep-Alive</h4>\n<p>Connection pooling optimizations address the <strong>TCP connection establishment overhead</strong> that becomes significant under high request loads. Our current implementation follows a <strong>connection-per-request</strong> pattern where each HTTP request requires complete TCP handshake, processing, and teardown cycles.</p>\n<p>HTTP/1.1 keep-alive functionality enables <strong>connection reuse</strong> where a single TCP connection can handle multiple sequential HTTP requests, eliminating repeated connection establishment costs. This optimization particularly benefits scenarios with <strong>multiple small requests</strong> from the same client, such as web pages loading numerous CSS, JavaScript, and image assets.</p>\n<p><strong>Keep-Alive Implementation Requirements:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Keep-Alive Component</th>\n<th>Current Implementation</th>\n<th>Required Changes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Connection State Tracking</td>\n<td>Single request per connection</td>\n<td>Multi-request connection lifecycle management</td>\n</tr>\n<tr>\n<td>Request Parsing</td>\n<td>Read once and close</td>\n<td>Continuous parsing loop with request boundaries</td>\n</tr>\n<tr>\n<td>Response Headers</td>\n<td>Connection: close default</td>\n<td>Connection: keep-alive header management</td>\n</tr>\n<tr>\n<td>Timeout Handling</td>\n<td>Simple request timeout</td>\n<td>Idle connection timeout and cleanup</td>\n</tr>\n<tr>\n<td>Resource Management</td>\n<td>Per-request cleanup</td>\n<td>Connection-level resource management</td>\n</tr>\n<tr>\n<td>Error Recovery</td>\n<td>Close on any error</td>\n<td>Graceful error handling with connection preservation</td>\n</tr>\n</tbody></table>\n<p>The keep-alive implementation transforms our <strong>connection handling loop</strong> from a single request processor into a <strong>multi-request state machine</strong>. After sending each response, the server must determine whether to close the connection or continue listening for additional requests on the same socket.</p>\n<p>Connection timeout management becomes more sophisticated with keep-alive support. Instead of simple request processing timeouts, the server must track <strong>idle connection time</strong> and implement policies for closing connections that remain unused beyond acceptable limits. This prevents <strong>connection resource exhaustion</strong> from clients that establish connections but send no additional requests.</p>\n<p><strong>Connection Pooling Architecture:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Pool Component</th>\n<th>Functionality</th>\n<th>Implementation Considerations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Active Connection Registry</td>\n<td>Track all open keep-alive connections</td>\n<td>Thread-safe connection list management</td>\n</tr>\n<tr>\n<td>Idle Timeout Monitor</td>\n<td>Close connections exceeding idle time limits</td>\n<td>Background cleanup thread or event-driven expiration</td>\n</tr>\n<tr>\n<td>Connection Limits</td>\n<td>Enforce maximum concurrent connection counts</td>\n<td>Per-client and global connection limits</td>\n</tr>\n<tr>\n<td>Graceful Shutdown</td>\n<td>Complete in-flight requests before closing</td>\n<td>Coordinated shutdown across pooled connections</td>\n</tr>\n</tbody></table>\n<p>The connection pooling system must <strong>balance resource utilization</strong> against performance benefits. Keeping too many idle connections consumes file descriptors and memory, while aggressive connection closing eliminates performance advantages. Effective implementations use <strong>adaptive timeout policies</strong> that adjust based on server load and connection usage patterns.</p>\n<p>Error handling complexity increases with connection pooling because errors can occur <strong>between requests</strong> rather than just during request processing. Network errors, client disconnections, and protocol violations must be detected and handled gracefully while preserving other active connections within the pool.</p>\n<blockquote>\n<p><strong>Performance Trade-off</strong>: Keep-alive connections reduce latency and CPU overhead for multiple requests but increase memory usage and complexity around connection lifecycle management and error recovery.</p>\n</blockquote>\n<h4 id=\"asynchronous-io-and-event-driven-processing\">Asynchronous I/O and Event-Driven Processing</h4>\n<p>Asynchronous I/O represents the most significant architectural optimization, transforming our <strong>thread-based concurrency model</strong> into an <strong>event-driven model</strong> that can handle thousands of concurrent connections with minimal resource overhead. This optimization addresses the fundamental scalability limitation of thread-per-connection architectures.</p>\n<p>Our current threading implementation creates <strong>OS threads</strong> for each client connection, leading to substantial memory overhead (typically 2-8MB per thread for stack space) and <strong>context switching costs</strong> as the number of concurrent connections increases. Event-driven architectures use a <strong>single thread with I/O multiplexing</strong> to handle many connections efficiently.</p>\n<p><strong>Event-Driven Architecture Components:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Thread-Based Current</th>\n<th>Event-Driven Alternative</th>\n<th>Benefits</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Connection Management</td>\n<td>Thread per connection</td>\n<td>Single event loop with connection registry</td>\n<td>Reduced memory overhead</td>\n</tr>\n<tr>\n<td>I/O Operations</td>\n<td>Blocking reads and writes</td>\n<td>Non-blocking I/O with event notifications</td>\n<td>Eliminate thread blocking</td>\n</tr>\n<tr>\n<td>Request Processing</td>\n<td>Sequential within thread</td>\n<td>State machine with event callbacks</td>\n<td>Handle partial operations efficiently</td>\n</tr>\n<tr>\n<td>Concurrency Control</td>\n<td>Thread synchronization</td>\n<td>Single-threaded with cooperative scheduling</td>\n<td>Eliminate race conditions</td>\n</tr>\n<tr>\n<td>Resource Usage</td>\n<td>Scales with thread count</td>\n<td>Constant regardless of connection count</td>\n<td>Improved scalability</td>\n</tr>\n</tbody></table>\n<p>The <strong>event loop</strong> becomes the core architectural component, continuously polling for I/O events across all active connections and dispatching appropriate handlers based on event types (readable, writable, error conditions). This requires transforming our <strong>sequential request processing logic</strong> into a <strong>state machine</strong> that can handle partial operations and resume processing when I/O operations complete.</p>\n<p><strong>State Machine for Event-Driven Request Processing:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Connection State</th>\n<th>Event Trigger</th>\n<th>Next State</th>\n<th>Actions Performed</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>CONNECTION_READING_REQUEST</code></td>\n<td>Socket readable</td>\n<td><code>CONNECTION_PARSING_REQUEST</code></td>\n<td>Read available data, check for complete request</td>\n</tr>\n<tr>\n<td><code>CONNECTION_PARSING_REQUEST</code></td>\n<td>Request complete</td>\n<td><code>CONNECTION_HANDLING_REQUEST</code></td>\n<td>Parse HTTP request, validate headers</td>\n</tr>\n<tr>\n<td><code>CONNECTION_HANDLING_REQUEST</code></td>\n<td>File I/O complete</td>\n<td><code>CONNECTION_SENDING_RESPONSE</code></td>\n<td>Generate response, prepare for transmission</td>\n</tr>\n<tr>\n<td><code>CONNECTION_SENDING_RESPONSE</code></td>\n<td>Socket writable</td>\n<td><code>CONNECTION_READING_REQUEST</code> or cleanup</td>\n<td>Send response data, handle partial writes</td>\n</tr>\n<tr>\n<td><code>CONNECTION_ERROR</code></td>\n<td>Any error condition</td>\n<td>Connection cleanup</td>\n<td>Log error, close socket, free resources</td>\n</tr>\n</tbody></table>\n<p>The <strong>file I/O handling</strong> presents particular challenges for event-driven architectures because traditional file operations are <strong>inherently blocking</strong>. Reading large files can stall the entire event loop, negating the benefits of asynchronous networking. Advanced implementations require <strong>thread pools for blocking operations</strong> or <strong>asynchronous file I/O</strong> using system-specific interfaces like Linux&#39;s <code>io_uring</code> or POSIX AIO.</p>\n<p><strong>Non-Blocking I/O Considerations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>I/O Operation</th>\n<th>Blocking Behavior</th>\n<th>Event-Driven Solution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Socket Accept</td>\n<td>May block if no connections pending</td>\n<td>Use <code>select</code>/<code>poll</code>/<code>epoll</code> to check readiness</td>\n</tr>\n<tr>\n<td>Socket Read</td>\n<td>May block if no data available</td>\n<td>Read only when socket is readable, handle partial reads</td>\n</tr>\n<tr>\n<td>Socket Write</td>\n<td>May block if send buffer full</td>\n<td>Write only when socket is writable, queue remaining data</td>\n</tr>\n<tr>\n<td>File Read</td>\n<td>Always blocks until data available</td>\n<td>Use thread pool or async file I/O interfaces</td>\n</tr>\n<tr>\n<td>File Stat</td>\n<td>May block for network filesystems</td>\n<td>Cache stat results or use background threads</td>\n</tr>\n</tbody></table>\n<p>Memory management patterns change significantly in event-driven architectures. Instead of <strong>per-thread stack allocation</strong>, all connection state must be <strong>heap-allocated</strong> and managed explicitly. This requires careful attention to memory leaks and proper cleanup when connections close unexpectedly.</p>\n<p><strong>Architecture Decision Record for Asynchronous I/O:</strong></p>\n<blockquote>\n<p><strong>Decision: Hybrid Event-Driven with Thread Pool for Blocking Operations</strong></p>\n<ul>\n<li><strong>Context</strong>: Pure event-driven architecture conflicts with educational clarity while pure threading doesn&#39;t scale effectively</li>\n<li><strong>Options Considered</strong>: 1) Pure event-driven with async file I/O, 2) Thread-per-connection with optimizations, 3) Hybrid approach</li>\n<li><strong>Decision</strong>: Event-driven networking with dedicated thread pool for file operations</li>\n<li><strong>Rationale</strong>: Provides scalability benefits of event-driven I/O while maintaining comprehensible file handling logic</li>\n<li><strong>Consequences</strong>: More complex architecture but realistic performance characteristics for production deployment</li>\n</ul>\n</blockquote>\n<p>The debugging and development complexity of event-driven systems significantly exceeds threaded implementations. <strong>State transitions</strong> must be carefully managed, <strong>partial operations</strong> must be handled correctly, and <strong>error conditions</strong> can occur at any point in the state machine. However, the scalability benefits often justify this complexity for production systems.</p>\n<h3 id=\"security-enhancements\">Security Enhancements</h3>\n<p>Security enhancements transform our educational HTTP server from a <strong>trusted environment demonstration</strong> into a <strong>production-hardened system</strong> capable of safely handling untrusted client requests and operating in hostile network environments. These enhancements address authentication, authorization, encryption, and attack prevention mechanisms essential for real-world deployment.</p>\n<h4 id=\"mental-model-bank-security-systems\">Mental Model: Bank Security Systems</h4>\n<p>Think of security enhancements like <strong>progressively fortifying a bank</strong>. Our current server is like a <strong>friendly neighborhood credit union</strong> - functional and trustworthy within a known community but lacking defenses against sophisticated threats. Adding HTTPS is like <strong>installing bulletproof glass</strong> and <strong>encrypted communication channels</strong>. Implementing authentication is like <strong>requiring ID verification</strong> and <strong>access badges</strong>. Additional security headers are like <strong>alarm systems</strong> and <strong>surveillance cameras</strong> that detect and deter various attack patterns.</p>\n<p>Each security layer addresses specific threat categories while maintaining the core functionality of the underlying system.</p>\n<h4 id=\"https-and-tls-implementation\">HTTPS and TLS Implementation</h4>\n<p>HTTPS support addresses the fundamental security vulnerability of <strong>unencrypted communication</strong> between clients and servers. Our current HTTP implementation transmits all data in plaintext, making it vulnerable to <strong>eavesdropping</strong>, <strong>man-in-the-middle attacks</strong>, and <strong>content tampering</strong> by network intermediaries.</p>\n<p>TLS (Transport Layer Security) provides <strong>cryptographic protection</strong> through authentication, encryption, and integrity verification. The TLS handshake establishes a secure channel between client and server using certificate-based server authentication and negotiated encryption algorithms.</p>\n<p><strong>TLS Integration Architecture:</strong></p>\n<table>\n<thead>\n<tr>\n<th>TLS Component</th>\n<th>Integration Point</th>\n<th>Implementation Requirements</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Certificate Management</td>\n<td>Server startup and configuration</td>\n<td>X.509 certificate loading, private key handling, certificate chain validation</td>\n</tr>\n<tr>\n<td>TLS Handshake</td>\n<td>TCP connection acceptance</td>\n<td>Protocol version negotiation, cipher suite selection, certificate presentation</td>\n</tr>\n<tr>\n<td>Encrypted I/O</td>\n<td>Socket read/write operations</td>\n<td>TLS record layer encryption/decryption, MAC verification</td>\n</tr>\n<tr>\n<td>Session Management</td>\n<td>Connection lifecycle</td>\n<td>Session resumption, renegotiation, graceful termination</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Connection and protocol errors</td>\n<td>TLS-specific error codes, certificate validation failures</td>\n</tr>\n</tbody></table>\n<p>The <strong>certificate management system</strong> requires handling X.509 certificates, private keys, and certificate authority chains. Production deployments need <strong>automated certificate renewal</strong> integration with services like Let&#39;s Encrypt, certificate validation procedures, and secure private key storage.</p>\n<p><strong>TLS Handshake Process Integration:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Handshake Phase</th>\n<th>Server Responsibilities</th>\n<th>Implementation Considerations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ClientHello Processing</td>\n<td>Parse supported cipher suites and extensions</td>\n<td>Version compatibility, cipher suite selection policies</td>\n</tr>\n<tr>\n<td>Certificate Presentation</td>\n<td>Send server certificate chain</td>\n<td>Certificate chain validation, intermediate CA handling</td>\n</tr>\n<tr>\n<td>Key Exchange</td>\n<td>Generate and exchange cryptographic keys</td>\n<td>RSA, ECDHE, or other key exchange algorithms</td>\n</tr>\n<tr>\n<td>Finished Messages</td>\n<td>Verify handshake integrity</td>\n<td>MAC computation and verification</td>\n</tr>\n<tr>\n<td>Application Data</td>\n<td>Begin encrypted HTTP processing</td>\n<td>Seamless transition to normal HTTP request handling</td>\n</tr>\n</tbody></table>\n<p>The <strong>performance implications</strong> of TLS encryption include CPU overhead for cryptographic operations, memory requirements for TLS state, and additional network round-trips for handshake completion. Modern servers use <strong>hardware acceleration</strong> for cryptographic operations and <strong>session resumption</strong> to amortize handshake costs across multiple connections.</p>\n<p><strong>TLS Library Integration Options:</strong></p>\n<table>\n<thead>\n<tr>\n<th>TLS Library</th>\n<th>Implementation Approach</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OpenSSL</td>\n<td>Direct library integration</td>\n<td>Full feature support, widely used</td>\n<td>Complex API, large dependency</td>\n</tr>\n<tr>\n<td>mbedTLS</td>\n<td>Embedded-focused TLS library</td>\n<td>Smaller footprint, cleaner API</td>\n<td>Less community support</td>\n</tr>\n<tr>\n<td>LibreSSL</td>\n<td>OpenSSL fork with security focus</td>\n<td>Improved security, simplified API</td>\n<td>Compatibility considerations</td>\n</tr>\n<tr>\n<td>Native OS TLS</td>\n<td>Platform-specific TLS APIs</td>\n<td>OS integration, automatic updates</td>\n<td>Platform-specific implementation</td>\n</tr>\n</tbody></table>\n<p>The integration challenge involves <strong>replacing standard socket operations</strong> with TLS-aware equivalents throughout our connection handling code. The <code>read_complete_request</code> and response sending functions must use TLS library calls instead of direct socket I/O while maintaining identical semantics for the higher-level HTTP processing logic.</p>\n<blockquote>\n<p><strong>Security Consideration</strong>: TLS configuration requires careful attention to cipher suite selection, protocol version support, and certificate validation policies to prevent downgrade attacks and ensure strong cryptographic protection.</p>\n</blockquote>\n<p><strong>Architecture Decision Record for HTTPS Implementation:</strong></p>\n<blockquote>\n<p><strong>Decision: TLS Termination at HTTP Server Level</strong></p>\n<ul>\n<li><strong>Context</strong>: HTTPS support can be implemented at the HTTP server level or handled by a reverse proxy in front of our server</li>\n<li><strong>Options Considered</strong>: 1) Integrate TLS directly into HTTP server, 2) Use reverse proxy for TLS termination, 3) Support both deployment modes</li>\n<li><strong>Decision</strong>: Implement TLS integration directly in HTTP server with configuration option to disable for proxy deployments</li>\n<li><strong>Rationale</strong>: Educational value of understanding TLS integration while maintaining flexibility for production deployment patterns</li>\n<li><strong>Consequences</strong>: Increased complexity but comprehensive understanding of HTTPS implementation details</li>\n</ul>\n</blockquote>\n<h4 id=\"authentication-and-authorization-framework\">Authentication and Authorization Framework</h4>\n<p>Authentication and authorization mechanisms enable <strong>identity verification</strong> and <strong>access control</strong> for protected resources, transforming our public file server into a <strong>controlled access system</strong> with user management and permission enforcement capabilities.</p>\n<p>Authentication addresses the question <strong>&quot;who is this user?&quot;</strong> through credential verification mechanisms like username/password combinations, API keys, or cryptographic certificates. Authorization answers <strong>&quot;what can this user access?&quot;</strong> through permission systems that control resource access based on verified identity and assigned roles.</p>\n<p><strong>Authentication Mechanisms for HTTP Servers:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Authentication Method</th>\n<th>Implementation Requirements</th>\n<th>Security Characteristics</th>\n<th>Use Cases</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTP Basic Authentication</td>\n<td>Base64 credential encoding, credential verification</td>\n<td>Simple but requires HTTPS for security</td>\n<td>Development, simple applications</td>\n</tr>\n<tr>\n<td>HTTP Digest Authentication</td>\n<td>Challenge-response with cryptographic hashes</td>\n<td>More secure than basic, complex implementation</td>\n<td>Legacy compatibility</td>\n</tr>\n<tr>\n<td>Bearer Token Authentication</td>\n<td>Token generation, validation, and management</td>\n<td>Flexible, supports various token formats</td>\n<td>API access, modern web applications</td>\n</tr>\n<tr>\n<td>Certificate-Based Authentication</td>\n<td>Client certificate verification during TLS handshake</td>\n<td>Strong security, complex PKI requirements</td>\n<td>High-security environments</td>\n</tr>\n<tr>\n<td>Session-Based Authentication</td>\n<td>Session token management with server-side storage</td>\n<td>Traditional web application pattern</td>\n<td>User-facing web applications</td>\n</tr>\n</tbody></table>\n<p><strong>HTTP Basic Authentication</strong> provides the simplest starting point, requiring minimal protocol changes while demonstrating fundamental authentication concepts. The client sends credentials in an Authorization header, and the server validates them against a user database or configuration file.</p>\n<p><strong>Basic Authentication Implementation Components:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Functionality</th>\n<th>Integration Points</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Credential Storage</td>\n<td>User database with hashed passwords</td>\n<td>Configuration system, user management</td>\n</tr>\n<tr>\n<td>Header Parsing</td>\n<td>Extract and decode Authorization header</td>\n<td>HTTP parser component</td>\n</tr>\n<tr>\n<td>Credential Verification</td>\n<td>Compare provided credentials against stored values</td>\n<td>Request processing pipeline</td>\n</tr>\n<tr>\n<td>Challenge Generation</td>\n<td>Send WWW-Authenticate header for unauthorized requests</td>\n<td>Error response generation</td>\n</tr>\n<tr>\n<td>Protected Resource Identification</td>\n<td>Determine which paths require authentication</td>\n<td>File handler component</td>\n</tr>\n</tbody></table>\n<p>The <strong>authorization framework</strong> builds upon authentication to implement <strong>role-based access control</strong> (RBAC) or <strong>access control lists</strong> (ACLs) that define resource-specific permissions. This requires extending our path resolution logic to check user permissions before serving files.</p>\n<p><strong>Authorization Policy Examples:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Resource Pattern</th>\n<th>Permission Model</th>\n<th>Implementation Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>/public/*</code></td>\n<td>Open access</td>\n<td>No authentication required</td>\n</tr>\n<tr>\n<td><code>/private/*</code></td>\n<td>Authenticated users only</td>\n<td>Require valid authentication</td>\n</tr>\n<tr>\n<td><code>/admin/*</code></td>\n<td>Administrative users only</td>\n<td>Role-based permission check</td>\n</tr>\n<tr>\n<td><code>/user/{username}/*</code></td>\n<td>Owner access only</td>\n<td>Path-based ownership validation</td>\n</tr>\n<tr>\n<td><code>/api/v1/*</code></td>\n<td>API key authentication</td>\n<td>Token-based authentication</td>\n</tr>\n</tbody></table>\n<p>The <strong>session management</strong> aspect of authentication involves maintaining user state across multiple requests. This requires <strong>secure session token generation</strong>, <strong>server-side session storage</strong>, and <strong>session timeout policies</strong> to balance security and usability.</p>\n<p><strong>Session Management Architecture:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Session Component</th>\n<th>Responsibilities</th>\n<th>Security Considerations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Session Token Generation</td>\n<td>Create cryptographically secure session identifiers</td>\n<td>Use sufficient entropy, avoid predictable patterns</td>\n</tr>\n<tr>\n<td>Session Storage</td>\n<td>Maintain server-side session data</td>\n<td>Memory management, persistence options</td>\n</tr>\n<tr>\n<td>Session Validation</td>\n<td>Verify session tokens on each request</td>\n<td>Constant-time comparison, timeout enforcement</td>\n</tr>\n<tr>\n<td>Session Cleanup</td>\n<td>Remove expired sessions</td>\n<td>Background cleanup processes, memory management</td>\n</tr>\n<tr>\n<td>Session Security</td>\n<td>Protect against session-based attacks</td>\n<td>CSRF protection, secure cookie attributes</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Authentication Design Principle</strong>: Authentication systems must balance security requirements with usability concerns - overly complex authentication reduces adoption while insufficient security creates vulnerability to compromise.</p>\n</blockquote>\n<h4 id=\"security-headers-and-attack-prevention\">Security Headers and Attack Prevention</h4>\n<p>Security headers provide <strong>defense-in-depth protection</strong> against common web application attacks by instructing browsers and other clients to enforce additional security policies. These headers complement server-side security measures with <strong>client-side protection mechanisms</strong>.</p>\n<p><strong>Essential Security Headers:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Header Name</th>\n<th>Protection Purpose</th>\n<th>Configuration Considerations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Strict-Transport-Security</code> (HSTS)</td>\n<td>Enforce HTTPS connections, prevent protocol downgrade</td>\n<td>Max-age policy, subdomain inclusion</td>\n</tr>\n<tr>\n<td><code>Content-Security-Policy</code> (CSP)</td>\n<td>Prevent XSS attacks through content source restrictions</td>\n<td>Policy complexity, compatibility requirements</td>\n</tr>\n<tr>\n<td><code>X-Frame-Options</code></td>\n<td>Prevent clickjacking attacks</td>\n<td>Deny vs. SAMEORIGIN policy choice</td>\n</tr>\n<tr>\n<td><code>X-Content-Type-Options</code></td>\n<td>Prevent MIME-type sniffing attacks</td>\n<td>nosniff directive for all content</td>\n</tr>\n<tr>\n<td><code>Referrer-Policy</code></td>\n<td>Control referrer information disclosure</td>\n<td>Privacy vs. functionality balance</td>\n</tr>\n<tr>\n<td><code>Permissions-Policy</code></td>\n<td>Control browser feature access</td>\n<td>Feature-specific policy configuration</td>\n</tr>\n</tbody></table>\n<p><strong>Content Security Policy (CSP)</strong> represents the most sophisticated security header, enabling fine-grained control over resource loading and script execution. For static file servers, CSP policies must balance security restrictions with legitimate content requirements.</p>\n<p><strong>CSP Policy Examples for Static File Server:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Content Type</th>\n<th>CSP Directive</th>\n<th>Policy Recommendation</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Scripts</td>\n<td><code>script-src</code></td>\n<td><code>&#39;self&#39;</code> for same-origin scripts</td>\n<td>Prevent inline scripts and external script injection</td>\n</tr>\n<tr>\n<td>Stylesheets</td>\n<td><code>style-src</code></td>\n<td><code>&#39;self&#39; &#39;unsafe-inline&#39;</code> if needed</td>\n<td>Allow legitimate styles while blocking malicious CSS</td>\n</tr>\n<tr>\n<td>Images</td>\n<td><code>img-src</code></td>\n<td><code>&#39;self&#39; data:</code></td>\n<td>Permit same-origin and data URL images</td>\n</tr>\n<tr>\n<td>Media</td>\n<td><code>media-src</code></td>\n<td><code>&#39;self&#39;</code></td>\n<td>Restrict audio/video sources</td>\n</tr>\n<tr>\n<td>Fonts</td>\n<td><code>font-src</code></td>\n<td><code>&#39;self&#39;</code></td>\n<td>Control font loading sources</td>\n</tr>\n<tr>\n<td>Default</td>\n<td><code>default-src</code></td>\n<td><code>&#39;self&#39;</code></td>\n<td>Fallback policy for unspecified resource types</td>\n</tr>\n</tbody></table>\n<p><strong>Attack Prevention Mechanisms:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Attack Vector</th>\n<th>Prevention Approach</th>\n<th>Implementation Location</th>\n<th>Effectiveness</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Directory Traversal</td>\n<td>Path validation and normalization</td>\n<td>File handler component</td>\n<td>High</td>\n</tr>\n<tr>\n<td>Request Smuggling</td>\n<td>Strict HTTP parsing and validation</td>\n<td>HTTP parser component</td>\n<td>High</td>\n</tr>\n<tr>\n<td>Denial of Service</td>\n<td>Rate limiting and resource constraints</td>\n<td>Connection management</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td>Buffer Overflow</td>\n<td>Bounds checking and safe string operations</td>\n<td>All input processing</td>\n<td>High</td>\n</tr>\n<tr>\n<td>Injection Attacks</td>\n<td>Input validation and sanitization</td>\n<td>Request processing pipeline</td>\n<td>High</td>\n</tr>\n<tr>\n<td>Information Disclosure</td>\n<td>Error message sanitization</td>\n<td>Error handling system</td>\n<td>Medium</td>\n</tr>\n</tbody></table>\n<p><strong>Rate limiting</strong> mechanisms protect against <strong>denial of service attacks</strong> and <strong>resource exhaustion</strong> by limiting the request rate from individual clients or IP addresses. This requires tracking client request patterns and implementing <strong>sliding window</strong> or <strong>token bucket</strong> algorithms for rate enforcement.</p>\n<p><strong>Rate Limiting Implementation Architecture:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Rate Limiting Component</th>\n<th>Functionality</th>\n<th>Design Considerations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Request Tracking</td>\n<td>Monitor requests per client/IP address</td>\n<td>Memory usage, cleanup policies</td>\n</tr>\n<tr>\n<td>Rate Calculation</td>\n<td>Compute current request rates</td>\n<td>Sliding window vs. fixed window algorithms</td>\n</tr>\n<tr>\n<td>Limit Enforcement</td>\n<td>Block or throttle excessive requests</td>\n<td>HTTP 429 response generation</td>\n</tr>\n<tr>\n<td>Configuration Management</td>\n<td>Adjustable rate limits per resource</td>\n<td>Per-path limits, global limits</td>\n</tr>\n<tr>\n<td>Persistence</td>\n<td>Optional rate limit state persistence</td>\n<td>Recovery after server restart</td>\n</tr>\n</tbody></table>\n<p><strong>Input validation</strong> and <strong>output encoding</strong> prevent various injection attacks by ensuring that user-provided data cannot be interpreted as executable code or control characters. For HTTP servers, this primarily involves <strong>header validation</strong>, <strong>URL encoding verification</strong>, and <strong>safe error message generation</strong>.</p>\n<blockquote>\n<p><strong>Security Design Insight</strong>: Effective security requires defense-in-depth approaches where multiple independent mechanisms provide overlapping protection against different attack vectors and failure modes.</p>\n</blockquote>\n<p><strong>Architecture Decision Record for Security Implementation Approach:</strong></p>\n<blockquote>\n<p><strong>Decision: Graduated Security Implementation with Configuration Control</strong></p>\n<ul>\n<li><strong>Context</strong>: Security requirements vary significantly between development, staging, and production environments</li>\n<li><strong>Options Considered</strong>: 1) Maximum security by default, 2) Minimal security with opt-in features, 3) Configurable security levels</li>\n<li><strong>Decision</strong>: Implement tiered security levels (development, staging, production) with clear configuration options</li>\n<li><strong>Rationale</strong>: Enables appropriate security for each deployment context while maintaining educational clarity and flexibility</li>\n<li><strong>Consequences</strong>: Increased configuration complexity but realistic security posture for different deployment scenarios</li>\n</ul>\n</blockquote>\n<p>The integration of security enhancements requires careful <strong>performance impact assessment</strong> since security operations (encryption, authentication, header processing) add computational overhead to request processing. Production deployments must balance security requirements against performance characteristics and resource utilization constraints.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The future extensions described above represent significant undertakings that transform our educational HTTP server into a production-ready system. This implementation guidance provides practical approaches for tackling these enhancements systematically while maintaining code quality and educational value.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Extension Category</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>POST Request Support</td>\n<td>Form-encoded parsing with fixed-size buffers</td>\n<td>Streaming parser with configurable size limits</td>\n</tr>\n<tr>\n<td>Chunked Encoding</td>\n<td>Fixed-size chunks with simple formatting</td>\n<td>Adaptive chunk sizing based on content type</td>\n</tr>\n<tr>\n<td>HTTP/2 Implementation</td>\n<td>Separate server using existing libraries</td>\n<td>Custom implementation for learning</td>\n</tr>\n<tr>\n<td>Response Caching</td>\n<td>In-memory hash table with LRU eviction</td>\n<td>Multi-tier cache with persistence options</td>\n</tr>\n<tr>\n<td>Connection Pooling</td>\n<td>Basic keep-alive with fixed timeouts</td>\n<td>Adaptive timeout policies with health monitoring</td>\n</tr>\n<tr>\n<td>Asynchronous I/O</td>\n<td>Event-driven with thread pool for file I/O</td>\n<td>Pure async with io_uring or IOCP</td>\n</tr>\n<tr>\n<td>HTTPS Support</td>\n<td>OpenSSL integration with basic configuration</td>\n<td>Full TLS configuration management</td>\n</tr>\n<tr>\n<td>Authentication</td>\n<td>HTTP Basic with file-based user storage</td>\n<td>Token-based with database integration</td>\n</tr>\n<tr>\n<td>Security Headers</td>\n<td>Static header configuration</td>\n<td>Dynamic policy generation based on content</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-project-structure-for-extensions\">Recommended Project Structure for Extensions</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>http-server-extended/\n├── cmd/\n│   ├── http-server/main.c           ← Original HTTP/1.1 server\n│   ├── http2-server/main.c          ← Separate HTTP/2 implementation  \n│   └── config-tool/main.c           ← Configuration management utility\n├── src/\n│   ├── core/                        ← Shared core components\n│   │   ├── http_parser.c/h          ← Enhanced parser with POST support\n│   │   ├── file_handler.c/h         ← File serving with caching\n│   │   ├── connection_manager.c/h   ← Connection pooling and lifecycle\n│   │   └── config.c/h               ← Configuration management\n│   ├── extensions/                  ← Extension implementations\n│   │   ├── cache/                   ← Response caching system\n│   │   │   ├── cache_manager.c/h\n│   │   │   ├── lru_eviction.c/h\n│   │   │   └── cache_stats.c/h\n│   │   ├── security/                ← Security enhancements\n│   │   │   ├── tls_integration.c/h\n│   │   │   ├── auth_handler.c/h\n│   │   │   ├── security_headers.c/h\n│   │   │   └── rate_limiter.c/h\n│   │   ├── performance/             ← Performance optimizations\n│   │   │   ├── async_io.c/h\n│   │   │   ├── connection_pool.c/h\n│   │   │   └── chunked_encoding.c/h\n│   │   └── http2/                   ← HTTP/2 implementation\n│   │       ├── frame_parser.c/h\n│   │       ├── stream_manager.c/h\n│   │       ├── hpack_compression.c/h\n│   │       └── multiplexer.c/h\n│   └── utils/                       ← Shared utilities\n│       ├── memory_pool.c/h          ← Memory management\n│       ├── thread_pool.c/h          ← Thread pool implementation\n│       ├── event_loop.c/h           ← Event-driven I/O support\n│       └── crypto_utils.c/h         ← Cryptographic helpers\n├── tests/\n│   ├── unit/                        ← Component unit tests\n│   ├── integration/                 ← Full system integration tests\n│   ├── performance/                 ← Load and stress testing\n│   └── security/                    ← Security verification tests\n├── config/\n│   ├── server.conf                  ← Server configuration\n│   ├── mime.types                   ← MIME type mappings\n│   ├── users.conf                   ← User authentication data\n│   └── security.conf                ← Security policy configuration\n└── docs/\n    ├── extensions/                  ← Extension-specific documentation\n    ├── deployment/                  ← Production deployment guides\n    └── performance/                 ← Performance tuning guides</code></pre></div>\n\n<h4 id=\"cache-implementation-starter-code\">Cache Implementation Starter Code</h4>\n<p><strong>Complete Cache Manager Infrastructure:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// cache_manager.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> CACHE_MANAGER_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CACHE_MANAGER_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;time.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;pthread.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_CACHE_ENTRIES</span><span style=\"color:#79B8FF\"> 1000</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_CACHED_FILE_SIZE</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">  // 1MB max per file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CACHE_KEY_LENGTH</span><span style=\"color:#79B8FF\"> 256</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> CacheEntry {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">[CACHE_KEY_LENGTH];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> response_data;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> response_length;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    time_t</span><span style=\"color:#E1E4E8\"> created_time;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    time_t</span><span style=\"color:#E1E4E8\"> last_access;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> access_count;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> CacheEntry</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> next;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> CacheEntry</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> prev;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} CacheEntry;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> CacheManager {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CacheEntry</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> entries</span><span style=\"color:#E1E4E8\">[MAX_CACHE_ENTRIES];</span><span style=\"color:#6A737D\">  // Hash table buckets</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CacheEntry</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> lru_head;</span><span style=\"color:#6A737D\">                    // LRU list head</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CacheEntry</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> lru_tail;</span><span style=\"color:#6A737D\">                    // LRU list tail</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> total_memory;</span><span style=\"color:#6A737D\">                     // Current memory usage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> max_memory;</span><span style=\"color:#6A737D\">                       // Memory limit</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> hits;</span><span style=\"color:#6A737D\">                           // Cache hit statistics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> misses;</span><span style=\"color:#6A737D\">                         // Cache miss statistics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_rwlock_t</span><span style=\"color:#E1E4E8\"> cache_lock;</span><span style=\"color:#6A737D\">             // Reader-writer lock</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} CacheManager;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize cache manager with memory limits</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">CacheManager</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> init_cache_manager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> max_memory_bytes</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Store response in cache with automatic eviction if needed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> cache_store_response</span><span style=\"color:#E1E4E8\">(CacheManager</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> cache</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> response_data</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> response_length</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Retrieve cached response, returns NULL if not found or expired</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char*</span><span style=\"color:#B392F0\"> cache_get_response</span><span style=\"color:#E1E4E8\">(CacheManager</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> cache</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        size_t*</span><span style=\"color:#FFAB70\"> response_length</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Generate cache key from request path and relevant headers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> generate_cache_key</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> file_path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> query_string</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                       char*</span><span style=\"color:#FFAB70\"> cache_key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> key_length</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Remove expired entries and enforce memory limits</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> cache_cleanup_expired</span><span style=\"color:#E1E4E8\">(CacheManager</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> cache</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">time_t</span><span style=\"color:#FFAB70\"> max_age_seconds</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Get cache statistics for monitoring</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> get_cache_statistics</span><span style=\"color:#E1E4E8\">(CacheManager</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> cache</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint64_t*</span><span style=\"color:#FFAB70\"> hits</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint64_t*</span><span style=\"color:#FFAB70\"> misses</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         size_t*</span><span style=\"color:#FFAB70\"> memory_used</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t*</span><span style=\"color:#FFAB70\"> entry_count</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Cleanup and free cache resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> cleanup_cache_manager</span><span style=\"color:#E1E4E8\">(CacheManager</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> cache</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> // CACHE_MANAGER_H</span></span></code></pre></div>\n\n<h4 id=\"authentication-framework-skeleton\">Authentication Framework Skeleton</h4>\n<p><strong>HTTP Basic Authentication Core Logic:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Basic authentication handler - learner implements credential verification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> handle_basic_authentication</span><span style=\"color:#E1E4E8\">(HTTPRequest</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> request</span><span style=\"color:#E1E4E8\">, HTTPResponse</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> response</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Extract Authorization header from request</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> auth_header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_request_header</span><span style=\"color:#E1E4E8\">(request, </span><span style=\"color:#9ECBFF\">\"Authorization\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">auth_header) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Generate 401 response with WWW-Authenticate header</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use generate_error_response with status 401</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Add header: WWW-Authenticate: Basic realm=\"Restricted Area\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Authentication required</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify Authorization header starts with \"Basic \"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Extract and decode base64 credentials</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use base64_decode function to decode credentials</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Split decoded credentials into username:password</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Verify credentials against user database</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use verify_user_credentials function</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Set authentication context for authorized requests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Store username in request context for access control</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Authentication successful</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// User credential verification - implement based on storage choice</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> verify_user_credentials</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> username</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> password</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Load user database (file, memory, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Find user entry by username</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Compare password hash using secure comparison</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use constant-time comparison to prevent timing attacks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return 1 for valid credentials, 0 for invalid</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"tls-integration-framework\">TLS Integration Framework</h4>\n<p><strong>TLS Socket Wrapper for HTTPS Support:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// tls_socket.h - TLS wrapper around standard sockets</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> TLS_SOCKET_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TLS_SOCKET_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;openssl/ssl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;openssl/err.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> TLSContext {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SSL_CTX</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> ssl_ctx;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SSL</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> ssl;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> socket_fd;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> is_server;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} TLSContext;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize TLS context with certificate and key files</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">TLSContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> init_tls_server_context</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> cert_file</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> key_file</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Accept TLS connection on server socket</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> tls_accept_connection</span><span style=\"color:#E1E4E8\">(TLSContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> server_ctx</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> client_fd</span><span style=\"color:#E1E4E8\">, TLSContext</span><span style=\"color:#F97583\">**</span><span style=\"color:#FFAB70\"> client_ctx</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TLS-aware versions of standard socket operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#B392F0\"> tls_read</span><span style=\"color:#E1E4E8\">(TLSContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> ctx</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> buffer</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> length</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#B392F0\"> tls_write</span><span style=\"color:#E1E4E8\">(TLSContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> ctx</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> void*</span><span style=\"color:#FFAB70\"> buffer</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> length</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> tls_close</span><span style=\"color:#E1E4E8\">(TLSContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> ctx</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Cleanup TLS resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> cleanup_tls_context</span><span style=\"color:#E1E4E8\">(TLSContext</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> ctx</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> // TLS_SOCKET_H</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints-for-extensions\">Milestone Checkpoints for Extensions</h4>\n<p><strong>POST Request Support Milestone:</strong></p>\n<ol>\n<li><strong>Command</strong>: <code>curl -X POST -d &quot;name=test&amp;value=hello&quot; http://localhost:8080/echo</code></li>\n<li><strong>Expected Response</strong>: HTTP 200 with request body echoed back</li>\n<li><strong>Verification</strong>: Check that Content-Length header is correctly parsed and body data is accessible</li>\n<li><strong>Common Issues</strong>: Incomplete body reading, missing Content-Type handling, buffer overflow on large posts</li>\n</ol>\n<p><strong>Caching System Milestone:</strong></p>\n<ol>\n<li><strong>Command</strong>: <code>ab -n 1000 -c 10 http://localhost:8080/index.html</code></li>\n<li><strong>Expected Behavior</strong>: Significant performance improvement on repeated requests</li>\n<li><strong>Verification</strong>: Cache hit rate &gt; 90% for repeated file access, memory usage within configured limits</li>\n<li><strong>Monitoring</strong>: Check cache statistics show hits/misses, verify LRU eviction under memory pressure</li>\n</ol>\n<p><strong>HTTPS Support Milestone:</strong></p>\n<ol>\n<li><strong>Setup</strong>: Generate self-signed certificate: <code>openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes</code></li>\n<li><strong>Command</strong>: <code>curl -k https://localhost:8443/index.html</code></li>\n<li><strong>Expected Response</strong>: Same content as HTTP version but over encrypted connection</li>\n<li><strong>Verification</strong>: Use <code>openssl s_client -connect localhost:8443</code> to verify TLS handshake</li>\n<li><strong>Common Issues</strong>: Certificate loading failures, cipher suite compatibility, port binding conflicts</li>\n</ol>\n<h4 id=\"performance-testing-and-optimization\">Performance Testing and Optimization</h4>\n<p><strong>Load Testing Framework:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">#!/bin/bash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># performance_test.sh - Comprehensive server performance testing</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Starting HTTP Server Performance Test Suite\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 1: Concurrent connection handling</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Test 1: Concurrent Connections\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ab</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#9ECBFF\"> http://localhost:8080/index.html</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 2: Large file transfer</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Test 2: Large File Performance\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -w</span><span style=\"color:#9ECBFF\"> \"@curl-format.txt\"</span><span style=\"color:#9ECBFF\"> http://localhost:8080/large-file.dat</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 3: Keep-alive connection reuse</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Test 3: Keep-Alive Performance\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ab</span><span style=\"color:#79B8FF\"> -k</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#79B8FF\"> 5000</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#79B8FF\"> 50</span><span style=\"color:#9ECBFF\"> http://localhost:8080/small-file.txt</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 4: Cache effectiveness</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Test 4: Cache Hit Rate\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Send same request multiple times and measure response time improvement</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 5: Memory usage under load</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Test 5: Memory Usage Monitoring\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Monitor server memory usage during high concurrent load</span></span></code></pre></div>\n\n<h4 id=\"security-testing-verification\">Security Testing Verification</h4>\n<p><strong>Security Audit Checklist:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Security Feature</th>\n<th>Verification Method</th>\n<th>Expected Result</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTPS Encryption</td>\n<td><code>nmap --script ssl-enum-ciphers -p 8443 localhost</code></td>\n<td>Strong cipher suites only</td>\n</tr>\n<tr>\n<td>Authentication</td>\n<td><code>curl -u invalid:credentials https://localhost:8443/private/</code></td>\n<td>401 Unauthorized response</td>\n</tr>\n<tr>\n<td>Directory Traversal</td>\n<td><code>curl https://localhost:8443/../../../etc/passwd</code></td>\n<td>400 Bad Request or 403 Forbidden</td>\n</tr>\n<tr>\n<td>Security Headers</td>\n<td><code>curl -I https://localhost:8443/</code></td>\n<td>HSTS, CSP, X-Frame-Options present</td>\n</tr>\n<tr>\n<td>Rate Limiting</td>\n<td>Rapid request script</td>\n<td>429 Too Many Requests after threshold</td>\n</tr>\n<tr>\n<td>Input Validation</td>\n<td>Malformed HTTP requests</td>\n<td>Graceful error handling, no crashes</td>\n</tr>\n</tbody></table>\n<p>These extensions transform the educational HTTP server into a comprehensive web server implementation suitable for production deployment while maintaining the architectural clarity that makes the codebase an effective learning tool. Each extension builds upon the foundational concepts established in the original implementation, demonstrating how systems evolve to meet real-world requirements.</p>\n<h2 id=\"glossary\">Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All Milestones 1-4 - provides essential terminology definitions used across TCP server basics, HTTP request parsing, static file serving, and concurrent connections</p>\n</blockquote>\n<p>The glossary serves as your technical compass throughout the HTTP server implementation journey. Think of it as a specialized dictionary that translates between the abstract concepts described in this design document and the concrete technical terminology you&#39;ll encounter in networking documentation, HTTP specifications, and systems programming resources. Just as a traveler needs a phrasebook to navigate a foreign country, you need this glossary to navigate the interconnected domains of network programming, HTTP protocol implementation, and concurrent systems design.</p>\n<p>This glossary organizes terminology into logical groupings that mirror the architectural components of our HTTP server. Each definition provides not just the meaning but also the contextual significance within our specific implementation. The terminology here bridges the gap between theoretical computer science concepts and practical systems programming, helping you understand not just what each term means but why it matters for building a robust HTTP server.</p>\n<h3 id=\"networking-and-tcp-fundamentals\">Networking and TCP Fundamentals</h3>\n<p>The networking layer forms the foundation of our HTTP server, requiring precise understanding of how TCP connections operate at the system level.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in HTTP Server</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Address Family</strong></td>\n<td>Protocol family identifier specifying address format and addressing scheme</td>\n<td><code>AF_INET</code> specifies IPv4 addressing for our server socket configuration</td>\n</tr>\n<tr>\n<td><strong>Bind Operation</strong></td>\n<td>System call associating a socket with a specific local address and port</td>\n<td>Our server binds to configured port (default 8080) to accept incoming connections</td>\n</tr>\n<tr>\n<td><strong>Client Socket</strong></td>\n<td>Network endpoint representing the client side of a TCP connection</td>\n<td>Each accepted connection creates a client socket for bidirectional communication</td>\n</tr>\n<tr>\n<td><strong>Connection Establishment</strong></td>\n<td>Three-way handshake process (SYN, SYN-ACK, ACK) creating a TCP connection</td>\n<td>Happens automatically when clients connect to our listening server socket</td>\n</tr>\n<tr>\n<td><strong>File Descriptor</strong></td>\n<td>Integer handle representing an open file or socket in the operating system</td>\n<td>Our server manages multiple file descriptors for server socket and client connections</td>\n</tr>\n<tr>\n<td><strong>File Descriptor Leak</strong></td>\n<td>Programming error where file descriptors are not properly closed, causing resource exhaustion</td>\n<td>Critical bug pattern in our server - must close client sockets after handling requests</td>\n</tr>\n<tr>\n<td><strong>Listen Backlog</strong></td>\n<td>Maximum number of pending connections that can wait for acceptance</td>\n<td>Configured during socket setup to handle burst of simultaneous connection attempts</td>\n</tr>\n<tr>\n<td><strong>Listen Operation</strong></td>\n<td>System call marking a socket as passive, ready to accept incoming connections</td>\n<td>Transitions our server socket from active to passive state for connection acceptance</td>\n</tr>\n<tr>\n<td><strong>Network Byte Order</strong></td>\n<td>Big-endian byte ordering used in network protocols for multi-byte values</td>\n<td>Port numbers must be converted using <code>htons()</code> for proper network transmission</td>\n</tr>\n<tr>\n<td><strong>Partial Read</strong></td>\n<td>Network read operation returning fewer bytes than requested due to buffering</td>\n<td>Common in TCP - our server must handle incomplete HTTP requests with multiple read calls</td>\n</tr>\n<tr>\n<td><strong>Partial Write</strong></td>\n<td>Network write operation sending fewer bytes than requested due to buffering</td>\n<td>HTTP responses may require multiple write calls to send complete data</td>\n</tr>\n<tr>\n<td><strong>Server Socket</strong></td>\n<td>Network endpoint configured to accept incoming client connections</td>\n<td>Primary socket bound to server port, never used for actual data transmission</td>\n</tr>\n<tr>\n<td><strong>Socket Address Structure</strong></td>\n<td>Data structure containing address family, port, and IP address information</td>\n<td><code>sockaddr_in</code> structure configures server binding and tracks client connection details</td>\n</tr>\n<tr>\n<td><strong>Socket Options</strong></td>\n<td>Configuration parameters controlling socket behavior and features</td>\n<td><code>SO_REUSEADDR</code> allows immediate port reuse after server restart during development</td>\n</tr>\n<tr>\n<td><strong>TCP Connection</strong></td>\n<td>Reliable, ordered, bidirectional communication channel between client and server</td>\n<td>Foundation for HTTP request-response exchange with guaranteed delivery and ordering</td>\n</tr>\n<tr>\n<td><strong>TCP Connection Lifecycle</strong></td>\n<td>Complete sequence from socket creation through data exchange to connection termination</td>\n<td>Our server manages: create → bind → listen → accept → read → write → close</td>\n</tr>\n</tbody></table>\n<h3 id=\"http-protocol-terminology\">HTTP Protocol Terminology</h3>\n<p>HTTP protocol implementation requires understanding of message structure, parsing challenges, and protocol semantics.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in HTTP Server</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Content-Length Header</strong></td>\n<td>HTTP header specifying the exact size of the message body in bytes</td>\n<td>Critical for reading request body completely and setting response body size</td>\n</tr>\n<tr>\n<td><strong>Content-Type Header</strong></td>\n<td>HTTP header indicating the media type of the request or response body</td>\n<td>Our server sets this based on file extension to help browsers handle served files</td>\n</tr>\n<tr>\n<td><strong>CRLF Line Endings</strong></td>\n<td>Carriage Return + Line Feed (<code>\\r\\n</code>) sequence required by HTTP specification</td>\n<td>HTTP standard mandates CRLF, but our parser handles both CRLF and LF for robustness</td>\n</tr>\n<tr>\n<td><strong>HTTP Header</strong></td>\n<td>Key-value pair providing metadata about the request or response message</td>\n<td>Parsed into our header array structure with case-insensitive key matching</td>\n</tr>\n<tr>\n<td><strong>HTTP Message Body</strong></td>\n<td>Optional payload data following the headers in an HTTP message</td>\n<td>For requests: form data or file uploads; for responses: file content or error pages</td>\n</tr>\n<tr>\n<td><strong>HTTP Method</strong></td>\n<td>Verb indicating the desired action to be performed on the identified resource</td>\n<td>Our server primarily handles GET requests, with basic support for HEAD and OPTIONS</td>\n</tr>\n<tr>\n<td><strong>HTTP Request</strong></td>\n<td>Client message containing method, path, headers, and optional body</td>\n<td>Parsed into our <code>HTTPRequest</code> structure with validated method, path, and header collection</td>\n</tr>\n<tr>\n<td><strong>HTTP Request Line</strong></td>\n<td>First line of HTTP request containing method, path, and protocol version</td>\n<td>Format: <code>GET /index.html HTTP/1.1</code> - parsed to extract three components</td>\n</tr>\n<tr>\n<td><strong>HTTP Response</strong></td>\n<td>Server message containing status code, headers, and optional body content</td>\n<td>Generated using our <code>HTTPResponse</code> structure with appropriate status and content headers</td>\n</tr>\n<tr>\n<td><strong>HTTP Status Code</strong></td>\n<td>Three-digit code indicating the result of the server&#39;s attempt to process the request</td>\n<td>200 OK for successful file serving, 404 Not Found for missing files, 500 for errors</td>\n</tr>\n<tr>\n<td><strong>HTTP Version</strong></td>\n<td>Protocol version identifier indicating capabilities and message format requirements</td>\n<td>Our server supports HTTP/1.1 with basic connection handling and header processing</td>\n</tr>\n<tr>\n<td><strong>Host Header</strong></td>\n<td>HTTP/1.1 required header specifying the domain name and port of the server</td>\n<td>Used for virtual host routing, though our basic implementation serves single document root</td>\n</tr>\n<tr>\n<td><strong>Request Path</strong></td>\n<td>URL path component specifying the requested resource location on the server</td>\n<td>Validated for security (no directory traversal) and mapped to filesystem paths</td>\n</tr>\n<tr>\n<td><strong>Request Parsing</strong></td>\n<td>Process of converting raw HTTP message bytes into structured data representation</td>\n<td>Critical parsing phase handling malformed requests, invalid headers, and protocol violations</td>\n</tr>\n<tr>\n<td><strong>Response Generation</strong></td>\n<td>Process of creating properly formatted HTTP response messages from server data</td>\n<td>Includes status line construction, header addition, and body content formatting</td>\n</tr>\n<tr>\n<td><strong>Status Line</strong></td>\n<td>First line of HTTP response containing protocol version, status code, and reason phrase</td>\n<td>Format: <code>HTTP/1.1 200 OK</code> - automatically generated based on request processing results</td>\n</tr>\n</tbody></table>\n<h3 id=\"file-system-and-security\">File System and Security</h3>\n<p>Static file serving requires careful handling of filesystem operations and security validation.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in HTTP Server</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Binary File Handling</strong></td>\n<td>Special processing required for non-text files to preserve exact byte content</td>\n<td>Our server must avoid text-mode I/O operations that could corrupt binary file data</td>\n</tr>\n<tr>\n<td><strong>Directory Listing</strong></td>\n<td>HTML page displaying the contents of a directory when no index file exists</td>\n<td>Generated dynamically when request path maps to directory rather than specific file</td>\n</tr>\n<tr>\n<td><strong>Directory Traversal</strong></td>\n<td>Security attack using relative path components (<code>../</code>) to access files outside document root</td>\n<td>Prevented by path normalization and validation before filesystem access</td>\n</tr>\n<tr>\n<td><strong>Document Root</strong></td>\n<td>Base directory on the filesystem from which files are served to clients</td>\n<td>Security boundary - all served files must reside within this directory tree</td>\n</tr>\n<tr>\n<td><strong>File Extension</strong></td>\n<td>Suffix portion of filename used to determine file type and appropriate handling</td>\n<td>Used for MIME type detection to set proper Content-Type header in responses</td>\n</tr>\n<tr>\n<td><strong>File Permission</strong></td>\n<td>Operating system access control determining read, write, and execute capabilities</td>\n<td>Server process must have read permission for all files intended for serving</td>\n</tr>\n<tr>\n<td><strong>MIME Type</strong></td>\n<td>Standard identifier indicating the nature and format of file content</td>\n<td>Mapped from file extensions to Content-Type headers (e.g., <code>.html</code> → <code>text/html</code>)</td>\n</tr>\n<tr>\n<td><strong>Path Normalization</strong></td>\n<td>Process of removing redundant path components (<code>.</code>, <code>..</code>) to create canonical paths</td>\n<td>Security measure preventing directory traversal attacks through path manipulation</td>\n</tr>\n<tr>\n<td><strong>Path Resolution</strong></td>\n<td>Process of mapping URL paths to corresponding filesystem paths within document root</td>\n<td>Core file serving operation that must validate security constraints before file access</td>\n</tr>\n<tr>\n<td><strong>Path Validation</strong></td>\n<td>Security checks ensuring requested paths don&#39;t escape document root boundaries</td>\n<td>Combines path normalization with boundary checking to prevent unauthorized file access</td>\n</tr>\n<tr>\n<td><strong>Static Content</strong></td>\n<td>Pre-existing files served without server-side processing or dynamic generation</td>\n<td>HTML, CSS, JavaScript, images - served directly from filesystem with appropriate headers</td>\n</tr>\n<tr>\n<td><strong>URL Decoding</strong></td>\n<td>Process of converting percent-encoded characters in URLs back to original form</td>\n<td>Handles encoded characters like <code>%20</code> (space) in filenames and paths</td>\n</tr>\n</tbody></table>\n<h3 id=\"concurrency-and-threading\">Concurrency and Threading</h3>\n<p>Concurrent connection handling requires understanding of different concurrency models and their trade-offs.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in HTTP Server</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Asynchronous I/O</strong></td>\n<td>Non-blocking I/O operations with event notification for completion</td>\n<td>Alternative to threading - single thread handles multiple connections with I/O multiplexing</td>\n</tr>\n<tr>\n<td><strong>Connection Context</strong></td>\n<td>Per-connection state structure tracking client information and processing status</td>\n<td><code>ConnectionContext</code> structure maintaining client socket, address, timing, and thread information</td>\n</tr>\n<tr>\n<td><strong>Connection Multiplexing</strong></td>\n<td>Single thread handling multiple simultaneous connections through event-driven programming</td>\n<td>Achieved using <code>select()</code> or <code>poll()</code> to monitor multiple sockets for activity</td>\n</tr>\n<tr>\n<td><strong>Connection Pooling</strong></td>\n<td>Reusing TCP connections across multiple HTTP requests to reduce connection overhead</td>\n<td>Optimization for keep-alive connections, though not implemented in our basic server</td>\n</tr>\n<tr>\n<td><strong>Deadlock</strong></td>\n<td>Circular waiting condition where two or more threads block each other indefinitely</td>\n<td>Avoided through consistent lock ordering and avoiding nested lock acquisition</td>\n</tr>\n<tr>\n<td><strong>Detached Thread</strong></td>\n<td>Thread that automatically releases its resources when it terminates</td>\n<td>Created with <code>PTHREAD_CREATE_DETACHED</code> attribute to avoid memory leaks from unjoined threads</td>\n</tr>\n<tr>\n<td><strong>Event-Driven Model</strong></td>\n<td>Concurrency approach using single thread with I/O multiplexing to handle multiple connections</td>\n<td>Alternative to threading - uses <code>select()</code> or <code>epoll()</code> to monitor socket events</td>\n</tr>\n<tr>\n<td><strong>Graceful Shutdown</strong></td>\n<td>Shutdown process that allows in-flight requests to complete before stopping the server</td>\n<td>Prevents client connection errors during server restart by finishing active request processing</td>\n</tr>\n<tr>\n<td><strong>Mutex</strong></td>\n<td>Mutual exclusion primitive protecting shared data from concurrent access</td>\n<td><code>pthread_mutex_t</code> used to protect connection counters and shared server state</td>\n</tr>\n<tr>\n<td><strong>Non-blocking I/O</strong></td>\n<td>I/O operations that return immediately rather than waiting for completion</td>\n<td>Socket option <code>O_NONBLOCK</code> allows event-driven handling without thread blocking</td>\n</tr>\n<tr>\n<td><strong>Race Condition</strong></td>\n<td>Bug where program behavior depends on timing of concurrent operations</td>\n<td>Prevented by proper synchronization around shared data like connection counters</td>\n</tr>\n<tr>\n<td><strong>Resource Exhaustion</strong></td>\n<td>System running out of threads, memory, or file descriptors under high load</td>\n<td>Prevented by connection limits, thread pool sizing, and proper resource cleanup</td>\n</tr>\n<tr>\n<td><strong>Thread Pool</strong></td>\n<td>Fixed number of worker threads sharing the workload of processing client connections</td>\n<td>Limits resource usage compared to thread-per-connection while maintaining concurrency</td>\n</tr>\n<tr>\n<td><strong>Thread Safety</strong></td>\n<td>Property that code functions correctly when accessed by multiple threads simultaneously</td>\n<td>Achieved through mutex synchronization and avoiding shared mutable state where possible</td>\n</tr>\n<tr>\n<td><strong>Thread-per-connection</strong></td>\n<td>Concurrency model creating dedicated thread for each client connection</td>\n<td>Simplest approach but resource-intensive - each connection consumes thread stack memory</td>\n</tr>\n</tbody></table>\n<h3 id=\"error-handling-and-debugging\">Error Handling and Debugging</h3>\n<p>Robust error handling requires understanding of error categories, propagation patterns, and recovery strategies.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in HTTP Server</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Cleanup Sequence</strong></td>\n<td>Ordered process of releasing resources when connections complete or fail</td>\n<td>Ensures sockets are closed, memory freed, and threads properly terminated</td>\n</tr>\n<tr>\n<td><strong>Error Classification</strong></td>\n<td>Categorizing errors by source (network, protocol, application) and severity level</td>\n<td>Helps determine appropriate HTTP status codes and recovery actions</td>\n</tr>\n<tr>\n<td><strong>Error Propagation</strong></td>\n<td>Flow of error information between system components to appropriate handlers</td>\n<td>Network errors become HTTP 500, file not found becomes HTTP 404</td>\n</tr>\n<tr>\n<td><strong>Graceful Degradation</strong></td>\n<td>System continuing to function with reduced capability under stress or failure</td>\n<td>Server remains responsive even when some requests fail or resources are limited</td>\n</tr>\n<tr>\n<td><strong>Memory Ownership</strong></td>\n<td>Clear responsibility for allocating and freeing dynamically allocated memory</td>\n<td>Prevents memory leaks by defining which component owns and cleans up each allocation</td>\n</tr>\n<tr>\n<td><strong>Resource Cleanup</strong></td>\n<td>Process of properly releasing system resources (sockets, files, memory) after use</td>\n<td>Critical for preventing resource leaks that would eventually crash the server</td>\n</tr>\n<tr>\n<td><strong>Security Event Logging</strong></td>\n<td>Recording security-relevant events (access attempts, blocked requests) for monitoring</td>\n<td>Logs directory traversal attempts, permission denials, and suspicious request patterns</td>\n</tr>\n</tbody></table>\n<h3 id=\"performance-and-testing\">Performance and Testing</h3>\n<p>Understanding performance characteristics and testing approaches for validating server behavior.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in HTTP Server</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Cache Eviction</strong></td>\n<td>Removal of entries from cache storage due to memory limits or age</td>\n<td>LRU (Least Recently Used) policy removes oldest entries when cache reaches capacity</td>\n</tr>\n<tr>\n<td><strong>Cache Hit</strong></td>\n<td>Successful retrieval of requested data from cache storage</td>\n<td>Avoids expensive file I/O operations by serving content from memory</td>\n</tr>\n<tr>\n<td><strong>Connection Limits</strong></td>\n<td>Maximum number of simultaneous connections the server will accept</td>\n<td>Prevents resource exhaustion by rejecting connections beyond configured threshold</td>\n</tr>\n<tr>\n<td><strong>Load Testing</strong></td>\n<td>Testing system behavior under expected operational load conditions</td>\n<td>Verifies server handles target number of concurrent connections without degradation</td>\n</tr>\n<tr>\n<td><strong>Performance Monitoring</strong></td>\n<td>Tracking system metrics like response time, throughput, and resource usage</td>\n<td>Measures request processing time, concurrent connection count, and memory usage</td>\n</tr>\n<tr>\n<td><strong>Stress Testing</strong></td>\n<td>Testing system limits and failure modes under extreme load</td>\n<td>Determines maximum connection capacity and validates graceful failure behavior</td>\n</tr>\n</tbody></table>\n<h3 id=\"advanced-features-and-extensions\">Advanced Features and Extensions</h3>\n<p>Terminology for potential future enhancements beyond the basic HTTP server implementation.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in HTTP Server</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Authentication</strong></td>\n<td>Identity verification process for user credentials</td>\n<td>HTTP Basic Authentication validates username/password for access control</td>\n</tr>\n<tr>\n<td><strong>Authorization</strong></td>\n<td>Access control based on verified user identity</td>\n<td>Determines which authenticated users can access specific resources</td>\n</tr>\n<tr>\n<td><strong>Certificate Management</strong></td>\n<td>Handling X.509 certificates and private keys for HTTPS</td>\n<td>Required for TLS-enabled servers to prove identity to clients</td>\n</tr>\n<tr>\n<td><strong>Chunked Encoding</strong></td>\n<td>HTTP transfer encoding for streaming responses without predetermined Content-Length</td>\n<td>Allows serving dynamically generated content of unknown size</td>\n</tr>\n<tr>\n<td><strong>Keep-Alive</strong></td>\n<td>HTTP connection reuse mechanism for multiple requests over single TCP connection</td>\n<td>Reduces connection establishment overhead for clients making multiple requests</td>\n</tr>\n<tr>\n<td><strong>Rate Limiting</strong></td>\n<td>Restricting request frequency from clients to prevent abuse</td>\n<td>Protects server resources from denial-of-service attacks</td>\n</tr>\n<tr>\n<td><strong>Security Headers</strong></td>\n<td>HTTP headers providing client-side security policies</td>\n<td>Headers like <code>X-Content-Type-Options</code> and <code>X-Frame-Options</code> enhance browser security</td>\n</tr>\n<tr>\n<td><strong>TLS Handshake</strong></td>\n<td>Cryptographic negotiation process establishing secure HTTPS connection</td>\n<td>Establishes encryption keys and validates server certificate before application data</td>\n</tr>\n</tbody></table>\n<h3 id=\"system-programming-concepts\">System Programming Concepts</h3>\n<p>Low-level systems programming concepts essential for robust HTTP server implementation.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in HTTP Server</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Buffer Overflow Protection</strong></td>\n<td>Programming techniques preventing writes beyond allocated memory boundaries</td>\n<td>Critical for parsing HTTP headers and handling file paths safely</td>\n</tr>\n<tr>\n<td><strong>Endianness</strong></td>\n<td>Byte ordering for multi-byte values in memory and network transmission</td>\n<td>Network byte order (big-endian) differs from host byte order on little-endian systems</td>\n</tr>\n<tr>\n<td><strong>Process Management</strong></td>\n<td>Operating system concepts for creating, monitoring, and terminating processes</td>\n<td>Understanding daemon processes and signal handling for production deployment</td>\n</tr>\n<tr>\n<td><strong>Signal Handling</strong></td>\n<td>Mechanism for asynchronous notification of events to running processes</td>\n<td>SIGTERM and SIGINT handling for graceful shutdown, SIGPIPE handling for broken connections</td>\n</tr>\n<tr>\n<td><strong>System Call Interface</strong></td>\n<td>Operating system API for network operations, file I/O, and process management</td>\n<td>Socket operations, file operations, and threading primitives used throughout server</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Implementation Note</strong>: This glossary provides the foundational vocabulary needed to understand the HTTP server design and implementation. Each term connects to specific code elements, data structures, or algorithms described in the component sections. When encountering unfamiliar terminology in networking documentation or HTTP specifications, refer back to these definitions to maintain context within our specific server architecture.</p>\n</blockquote>\n<p>The terminology here bridges multiple technical domains - from low-level socket programming to high-level HTTP protocol semantics. Understanding these connections helps you see how abstract protocol concepts translate into concrete programming tasks and data structures.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides practical guidance for understanding and using the terminology throughout your HTTP server implementation.</p>\n<h4 id=\"terminology-usage-patterns\">Terminology Usage Patterns</h4>\n<p>The terminology in this glossary follows specific patterns that map to our implementation structure:</p>\n<p><strong>Component-Specific Terms</strong>: Terms like &quot;TCP Connection Lifecycle&quot; and &quot;HTTP Request Parsing&quot; map directly to component responsibilities. When implementing the TCP Server Component, focus on networking terms. When building the HTTP Parser Component, emphasize protocol terminology.</p>\n<p><strong>Data Structure Mapping</strong>: Many terms correspond directly to fields in our data structures. &quot;HTTP Method&quot; maps to the <code>method</code> field in <code>HTTPRequest</code>. &quot;Connection Context&quot; is embodied by the <code>ConnectionContext</code> structure. &quot;MIME Type&quot; relates to the <code>MimeTypeMapping</code> structure.</p>\n<p><strong>Error Category Alignment</strong>: Error-related terminology aligns with our <code>ErrorCategory</code> enumeration. &quot;Network&quot; errors include &quot;Partial Read&quot; and &quot;File Descriptor Leak&quot;. &quot;Protocol&quot; errors encompass &quot;HTTP Request Parsing&quot; failures and malformed headers.</p>\n<h4 id=\"cross-reference-guide\">Cross-Reference Guide</h4>\n<table>\n<thead>\n<tr>\n<th>Implementation Area</th>\n<th>Key Terms</th>\n<th>Primary Data Structures</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Socket Programming</td>\n<td>Network Byte Order, File Descriptor, TCP Connection Lifecycle</td>\n<td><code>sockaddr_in</code>, <code>ConnectionContext</code></td>\n</tr>\n<tr>\n<td>HTTP Processing</td>\n<td>Request Parsing, Status Code, Content-Type Header</td>\n<td><code>HTTPRequest</code>, <code>HTTPResponse</code></td>\n</tr>\n<tr>\n<td>File Operations</td>\n<td>Directory Traversal, Path Validation, MIME Type</td>\n<td><code>ServerConfig</code>, <code>MimeTypeMapping</code></td>\n</tr>\n<tr>\n<td>Concurrency</td>\n<td>Thread Safety, Mutex, Resource Exhaustion</td>\n<td><code>ConcurrencyManager</code>, <code>ConnectionQueue</code></td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Error Classification, Cleanup Sequence, Error Propagation</td>\n<td><code>ErrorInfo</code>, <code>ResourceCleanupContext</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"common-term-confusion\">Common Term Confusion</h4>\n<p>Several terms are frequently confused during implementation:</p>\n<p><strong>&quot;Connection&quot; vs &quot;Socket&quot;</strong>: A TCP connection represents the logical communication channel, while a socket is the programming interface. Our server socket accepts connections, creating client sockets for communication.</p>\n<p><strong>&quot;Request Parsing&quot; vs &quot;Message Parsing&quot;</strong>: Request parsing specifically handles the HTTP request structure, while message parsing could apply to both requests and responses.</p>\n<p><strong>&quot;Thread Pool&quot; vs &quot;Connection Pool&quot;</strong>: Thread pools manage worker threads, while connection pools would manage reusable TCP connections (not implemented in our basic server).</p>\n<p><strong>&quot;Graceful Shutdown&quot; vs &quot;Graceful Degradation&quot;</strong>: Shutdown refers to stopping the server cleanly, while degradation means continuing operation with reduced functionality.</p>\n<h4 id=\"debugging-vocabulary\">Debugging Vocabulary</h4>\n<p>When troubleshooting issues, these terms help communicate problems precisely:</p>\n<ul>\n<li><strong>&quot;Partial Read&quot;</strong> indicates incomplete HTTP request reception</li>\n<li><strong>&quot;Directory Traversal&quot;</strong> signals a security validation failure  </li>\n<li><strong>&quot;Race Condition&quot;</strong> suggests thread synchronization problems</li>\n<li><strong>&quot;Resource Exhaustion&quot;</strong> points to connection or thread limit issues</li>\n<li><strong>&quot;File Descriptor Leak&quot;</strong> means sockets aren&#39;t being closed properly</li>\n</ul>\n<p>Understanding this vocabulary accelerates both independent debugging and communication with others when seeking help.</p>\n","toc":[{"level":1,"text":"HTTP Server: Design Document","id":"http-server-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Context and Problem Statement","id":"context-and-problem-statement"},{"level":3,"text":"The Library Desk Analogy","id":"the-library-desk-analogy"},{"level":3,"text":"Existing Web Server Approaches","id":"existing-web-server-approaches"},{"level":3,"text":"Core Technical Challenges","id":"core-technical-challenges"},{"level":4,"text":"Network Programming Complexity","id":"network-programming-complexity"},{"level":4,"text":"HTTP Protocol Parsing Challenges","id":"http-protocol-parsing-challenges"},{"level":4,"text":"Concurrency and Thread Safety","id":"concurrency-and-thread-safety"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Essential C Socket Programming Foundation","id":"essential-c-socket-programming-foundation"},{"level":4,"text":"HTTP Message Structure Reference","id":"http-message-structure-reference"},{"level":4,"text":"File System Security Patterns","id":"file-system-security-patterns"},{"level":4,"text":"Development and Testing Setup","id":"development-and-testing-setup"},{"level":4,"text":"Project Structure Organization","id":"project-structure-organization"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"Functional Requirements","id":"functional-requirements"},{"level":3,"text":"Non-Functional Requirements","id":"non-functional-requirements"},{"level":3,"text":"Explicit Non-Goals","id":"explicit-non-goals"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"Component Overview","id":"component-overview"},{"level":3,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":3,"text":"Request Processing Flow","id":"request-processing-flow"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology and Library Recommendations","id":"technology-and-library-recommendations"},{"level":4,"text":"Project Structure and Build System","id":"project-structure-and-build-system"},{"level":4,"text":"Core Infrastructure Starter Code","id":"core-infrastructure-starter-code"},{"level":4,"text":"Core Component Skeleton Code","id":"core-component-skeleton-code"},{"level":4,"text":"Development and Testing Checkpoints","id":"development-and-testing-checkpoints"},{"level":4,"text":"Common Implementation Pitfalls","id":"common-implementation-pitfalls"},{"level":2,"text":"Data Model","id":"data-model"},{"level":3,"text":"HTTP Message Structures","id":"http-message-structures"},{"level":3,"text":"Server Configuration","id":"server-configuration"},{"level":3,"text":"Connection State Management","id":"connection-state-management"},{"level":3,"text":"Common Data Model Pitfalls","id":"common-data-model-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Complete Data Structure Definitions","id":"complete-data-structure-definitions"},{"level":4,"text":"Core Helper Functions (Complete Implementation)","id":"core-helper-functions-complete-implementation"},{"level":4,"text":"Core Logic Skeleton (for learners to complete)","id":"core-logic-skeleton-for-learners-to-complete"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Language-Specific Implementation Hints","id":"language-specific-implementation-hints"},{"level":2,"text":"TCP Server Component","id":"tcp-server-component"},{"level":3,"text":"TCP Server Mental Model: Restaurant Host Station Analogy","id":"tcp-server-mental-model-restaurant-host-station-analogy"},{"level":3,"text":"TCP Server Interface","id":"tcp-server-interface"},{"level":3,"text":"Connection Acceptance Algorithm","id":"connection-acceptance-algorithm"},{"level":3,"text":"Architecture Decision Records","id":"architecture-decision-records"},{"level":3,"text":"TCP Server Interface Implementation Details","id":"tcp-server-interface-implementation-details"},{"level":3,"text":"Connection Acceptance Algorithm Implementation","id":"connection-acceptance-algorithm-implementation"},{"level":3,"text":"Architecture Decision Records: Advanced Considerations","id":"architecture-decision-records-advanced-considerations"},{"level":3,"text":"Common TCP Pitfalls","id":"common-tcp-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"HTTP Parser Component","id":"http-parser-component"},{"level":3,"text":"HTTP Parsing Mental Model: Mail Sorting Analogy","id":"http-parsing-mental-model-mail-sorting-analogy"},{"level":3,"text":"Parser Interface","id":"parser-interface"},{"level":3,"text":"HTTP Parsing Algorithm: State Machine for Processing HTTP Message Format","id":"http-parsing-algorithm-state-machine-for-processing-http-message-format"},{"level":3,"text":"Architecture Decision Records","id":"architecture-decision-records"},{"level":3,"text":"Common HTTP Parsing Pitfalls","id":"common-http-parsing-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"File Handler Component","id":"file-handler-component"},{"level":3,"text":"File Serving Mental Model: Filing Cabinet Analogy","id":"file-serving-mental-model-filing-cabinet-analogy"},{"level":3,"text":"File Handler Interface","id":"file-handler-interface"},{"level":3,"text":"File Serving Algorithm","id":"file-serving-algorithm"},{"level":3,"text":"Architecture Decision Records","id":"architecture-decision-records"},{"level":3,"text":"Common File Serving Pitfalls","id":"common-file-serving-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints for C Implementation","id":"language-specific-hints-for-c-implementation"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Concurrency Management Component","id":"concurrency-management-component"},{"level":3,"text":"Concurrency Mental Model: Restaurant Service Models","id":"concurrency-mental-model-restaurant-service-models"},{"level":3,"text":"Concurrency Manager Interface","id":"concurrency-manager-interface"},{"level":3,"text":"Concurrency Model Options","id":"concurrency-model-options"},{"level":4,"text":"Thread-Per-Connection Model","id":"thread-per-connection-model"},{"level":4,"text":"Thread Pool Model","id":"thread-pool-model"},{"level":4,"text":"Event-Driven Model","id":"event-driven-model"},{"level":3,"text":"Architecture Decision Records","id":"architecture-decision-records"},{"level":3,"text":"Common Concurrency Pitfalls","id":"common-concurrency-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Interactions and Data Flow","id":"interactions-and-data-flow"},{"level":3,"text":"Component Communication Patterns","id":"component-communication-patterns"},{"level":4,"text":"Primary Communication Flow","id":"primary-communication-flow"},{"level":4,"text":"Secondary Communication Patterns","id":"secondary-communication-patterns"},{"level":3,"text":"Complete Request-Response Cycle","id":"complete-request-response-cycle"},{"level":4,"text":"Stage 1: Connection Establishment and Acceptance","id":"stage-1-connection-establishment-and-acceptance"},{"level":4,"text":"Stage 2: Concurrency Dispatching and Resource Allocation","id":"stage-2-concurrency-dispatching-and-resource-allocation"},{"level":4,"text":"Stage 3: HTTP Request Reading and Buffering","id":"stage-3-http-request-reading-and-buffering"},{"level":4,"text":"Stage 4: HTTP Request Parsing and Validation","id":"stage-4-http-request-parsing-and-validation"},{"level":4,"text":"Stage 5: File Path Resolution and Security Validation","id":"stage-5-file-path-resolution-and-security-validation"},{"level":4,"text":"Stage 6: File Content Reading and Response Generation","id":"stage-6-file-content-reading-and-response-generation"},{"level":4,"text":"Stage 7: HTTP Response Transmission and Connection Cleanup","id":"stage-7-http-response-transmission-and-connection-cleanup"},{"level":3,"text":"Error Propagation Between Components","id":"error-propagation-between-components"},{"level":4,"text":"Error Classification and Response Mapping","id":"error-classification-and-response-mapping"},{"level":4,"text":"Component Error Interfaces","id":"component-error-interfaces"},{"level":4,"text":"Error Response Generation Pipeline","id":"error-response-generation-pipeline"},{"level":4,"text":"Error Recovery and Connection State Management","id":"error-recovery-and-connection-state-management"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"Error Categories","id":"error-categories"},{"level":3,"text":"HTTP Error Response Generation","id":"http-error-response-generation"},{"level":3,"text":"Resource Cleanup Strategies","id":"resource-cleanup-strategies"},{"level":3,"text":"Common Error Handling Pitfalls","id":"common-error-handling-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Testing Strategy","id":"testing-strategy"},{"level":3,"text":"Milestone Verification Checkpoints","id":"milestone-verification-checkpoints"},{"level":4,"text":"Milestone 1: TCP Server Basics Verification","id":"milestone-1-tcp-server-basics-verification"},{"level":4,"text":"Milestone 2: HTTP Request Parsing Verification","id":"milestone-2-http-request-parsing-verification"},{"level":4,"text":"Milestone 3: Static File Serving Verification","id":"milestone-3-static-file-serving-verification"},{"level":4,"text":"Milestone 4: Concurrent Connections Verification","id":"milestone-4-concurrent-connections-verification"},{"level":3,"text":"Testing Tools and Techniques","id":"testing-tools-and-techniques"},{"level":4,"text":"Command-Line HTTP Clients","id":"command-line-http-clients"},{"level":4,"text":"Low-Level Network Testing Tools","id":"low-level-network-testing-tools"},{"level":4,"text":"Browser Testing Strategies","id":"browser-testing-strategies"},{"level":4,"text":"Automated Testing Scripts","id":"automated-testing-scripts"},{"level":3,"text":"Concurrency Testing","id":"concurrency-testing"},{"level":4,"text":"Thread-Per-Connection Model Testing","id":"thread-per-connection-model-testing"},{"level":4,"text":"Thread Pool Model Testing","id":"thread-pool-model-testing"},{"level":4,"text":"Event-Driven Model Testing","id":"event-driven-model-testing"},{"level":4,"text":"Load Testing and Stress Testing","id":"load-testing-and-stress-testing"},{"level":4,"text":"Failure Recovery Testing","id":"failure-recovery-testing"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Testing Code","id":"infrastructure-testing-code"},{"level":4,"text":"Core Testing Logic Skeletons","id":"core-testing-logic-skeletons"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"Debugging Mental Model: The Detective&#39;s Toolkit","id":"debugging-mental-model-the-detective39s-toolkit"},{"level":3,"text":"Symptom-Based Diagnosis Table","id":"symptom-based-diagnosis-table"},{"level":3,"text":"Debugging Tools and Techniques","id":"debugging-tools-and-techniques"},{"level":4,"text":"Network-Level Debugging","id":"network-level-debugging"},{"level":4,"text":"System-Level Debugging","id":"system-level-debugging"},{"level":4,"text":"Application-Level Debugging","id":"application-level-debugging"},{"level":3,"text":"Milestone-Specific Issues","id":"milestone-specific-issues"},{"level":4,"text":"Milestone 1: TCP Server Basics Issues","id":"milestone-1-tcp-server-basics-issues"},{"level":4,"text":"Milestone 2: HTTP Request Parsing Issues","id":"milestone-2-http-request-parsing-issues"},{"level":4,"text":"Milestone 3: Static File Serving Issues","id":"milestone-3-static-file-serving-issues"},{"level":4,"text":"Milestone 4: Concurrent Connections Issues","id":"milestone-4-concurrent-connections-issues"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations Table","id":"technology-recommendations-table"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Future Extensions","id":"future-extensions"},{"level":3,"text":"HTTP Protocol Extensions","id":"http-protocol-extensions"},{"level":4,"text":"Mental Model: Library Service Expansion","id":"mental-model-library-service-expansion"},{"level":4,"text":"POST Request Support","id":"post-request-support"},{"level":4,"text":"Chunked Transfer Encoding","id":"chunked-transfer-encoding"},{"level":4,"text":"HTTP/2 Protocol Support","id":"http2-protocol-support"},{"level":3,"text":"Performance Optimizations","id":"performance-optimizations"},{"level":4,"text":"Mental Model: Restaurant Efficiency Improvements","id":"mental-model-restaurant-efficiency-improvements"},{"level":4,"text":"Response Caching System","id":"response-caching-system"},{"level":4,"text":"Connection Pooling and Keep-Alive","id":"connection-pooling-and-keep-alive"},{"level":4,"text":"Asynchronous I/O and Event-Driven Processing","id":"asynchronous-io-and-event-driven-processing"},{"level":3,"text":"Security Enhancements","id":"security-enhancements"},{"level":4,"text":"Mental Model: Bank Security Systems","id":"mental-model-bank-security-systems"},{"level":4,"text":"HTTPS and TLS Implementation","id":"https-and-tls-implementation"},{"level":4,"text":"Authentication and Authorization Framework","id":"authentication-and-authorization-framework"},{"level":4,"text":"Security Headers and Attack Prevention","id":"security-headers-and-attack-prevention"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended Project Structure for Extensions","id":"recommended-project-structure-for-extensions"},{"level":4,"text":"Cache Implementation Starter Code","id":"cache-implementation-starter-code"},{"level":4,"text":"Authentication Framework Skeleton","id":"authentication-framework-skeleton"},{"level":4,"text":"TLS Integration Framework","id":"tls-integration-framework"},{"level":4,"text":"Milestone Checkpoints for Extensions","id":"milestone-checkpoints-for-extensions"},{"level":4,"text":"Performance Testing and Optimization","id":"performance-testing-and-optimization"},{"level":4,"text":"Security Testing Verification","id":"security-testing-verification"},{"level":2,"text":"Glossary","id":"glossary"},{"level":3,"text":"Networking and TCP Fundamentals","id":"networking-and-tcp-fundamentals"},{"level":3,"text":"HTTP Protocol Terminology","id":"http-protocol-terminology"},{"level":3,"text":"File System and Security","id":"file-system-and-security"},{"level":3,"text":"Concurrency and Threading","id":"concurrency-and-threading"},{"level":3,"text":"Error Handling and Debugging","id":"error-handling-and-debugging"},{"level":3,"text":"Performance and Testing","id":"performance-and-testing"},{"level":3,"text":"Advanced Features and Extensions","id":"advanced-features-and-extensions"},{"level":3,"text":"System Programming Concepts","id":"system-programming-concepts"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Terminology Usage Patterns","id":"terminology-usage-patterns"},{"level":4,"text":"Cross-Reference Guide","id":"cross-reference-guide"},{"level":4,"text":"Common Term Confusion","id":"common-term-confusion"},{"level":4,"text":"Debugging Vocabulary","id":"debugging-vocabulary"}],"title":"HTTP Server: Design Document","markdown":"# HTTP Server: Design Document\n\n\n## Overview\n\nThis system implements a concurrent HTTP/1.1 static file server that accepts TCP connections, parses HTTP requests, and serves files from a document root directory. The key architectural challenge is handling multiple concurrent client connections efficiently while maintaining proper HTTP protocol compliance and security boundaries.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n## Context and Problem Statement\n\n> **Milestone(s):** Background for all milestones - establishes fundamental concepts needed throughout the project\n\nThe HTTP server project presents a fascinating intersection of network programming, protocol implementation, and concurrent system design. While web servers might seem ubiquitous in modern computing, building one from scratch reveals the intricate dance of TCP socket management, HTTP message parsing, file system interaction, and concurrent connection handling. This section establishes the foundational concepts and challenges that make HTTP server implementation both educational and technically demanding.\n\nUnderstanding these fundamentals is crucial because HTTP servers must simultaneously handle multiple concerns: they operate at the intersection of network protocols (TCP/IP), application protocols (HTTP), operating system resources (file descriptors, threads), and security boundaries (filesystem access control). Each of these domains introduces its own complexity and failure modes, and their interaction creates emergent challenges that require careful architectural consideration.\n\n### The Library Desk Analogy\n\nTo build intuition about HTTP server architecture, consider the analogy of a library reference desk during peak hours. The reference desk represents your HTTP server, and library patrons represent client requests arriving over the network.\n\n**The Single Librarian Problem**: Initially, imagine a library with one reference desk staffed by a single librarian. When a patron arrives with a question, the librarian must listen to the complete question, understand what information is being requested, locate the appropriate books or documents, and provide a complete answer before helping the next patron. If the requested information requires searching through archives in the basement, every other patron must wait in line while the librarian retrieves the material. This represents a **sequential, blocking server model** - each request must complete entirely before the next can begin processing.\n\n**The Multi-Desk Solution**: As patron volume increases, the library might add multiple reference desks, each staffed by a different librarian. Now multiple patrons can be served simultaneously, with each librarian handling their own queue. However, this approach requires careful resource management - if all librarians are simultaneously searching the basement archives, the reference area becomes empty and new patrons face long delays. This represents a **thread-per-connection model** where each connection gets dedicated processing resources.\n\n**The Specialist Dispatcher Model**: A more sophisticated approach involves a front desk that quickly categorizes patron requests and routes them to specialists - simple catalog questions go to one area, research requests to another, and document retrieval to a third team. The front desk never blocks on any individual request, instead maintaining awareness of all active requests and efficiently routing work. This represents an **event-driven, asynchronous server model** that can handle many concurrent connections without proportional resource scaling.\n\n**Resource Sharing and Conflicts**: In all models, librarians must access shared resources - the card catalog, the archive keys, the photocopier. When multiple librarians need the same resource simultaneously, coordination becomes essential to prevent conflicts and ensure fair access. This mirrors the challenges of concurrent access to shared server resources like configuration data, log files, and cached content.\n\n**Request Complexity Variations**: Some patron requests are simple (\"Where are the restrooms?\") while others are complex (\"I need all documents related to 19th-century agricultural practices in the Pacific Northwest\"). Similarly, HTTP requests vary dramatically - serving a small CSS file requires minimal processing, while serving a large video file involves substantial I/O and bandwidth management. The server architecture must handle both efficiently without allowing complex requests to starve simple ones.\n\nThis analogy illuminates several key architectural decisions that HTTP servers must make: How should incoming connections be accepted and queued? Should each connection receive dedicated processing resources or share them? How should the server handle requests of varying complexity? What happens when system resources become constrained?\n\n### Existing Web Server Approaches\n\nProduction web servers have evolved different architectural approaches to address the concurrency and performance challenges inherent in HTTP serving. Understanding these approaches provides context for the design decisions in our educational HTTP server implementation.\n\n| Server | Concurrency Model | Connection Handling | Pros | Cons |\n|---------|------------------|-------------------|------|------|\n| Apache HTTP Server (traditional) | Process-per-connection with pre-forking | Each connection handled by dedicated process | Strong isolation, robust fault tolerance, simple debugging | High memory overhead, limited scalability, process creation costs |\n| Apache HTTP Server (modern) | Hybrid with worker MPM | Thread pool with event-driven accept | Better resource efficiency than pure process model | Still more overhead than pure event-driven approaches |\n| nginx | Event-driven with worker processes | Single-threaded event loop per CPU core | Extremely high connection capacity, low memory usage | Complex programming model, difficult debugging |\n| lighttpd | Event-driven single process | select/poll/epoll-based event loop | Lightweight, efficient for static content | Limited by single process, less robust under high load |\n\n**Apache's Process-per-Connection Legacy**: The original Apache HTTP Server used a process-per-connection model where each incoming HTTP connection was handled by a dedicated process. This approach provided excellent isolation - a crash in one connection handler couldn't affect others - but suffered from severe scalability limitations. Process creation overhead meant that under high connection loads, significant CPU time was spent managing processes rather than serving content. Memory usage scaled linearly with concurrent connections, creating practical limits in the hundreds of simultaneous connections rather than thousands.\n\n**The C10K Problem and Event-Driven Solutions**: The \"C10K problem\" - handling 10,000 concurrent connections on a single server - exposed the limitations of thread-per-connection and process-per-connection models. Event-driven architectures emerged as a solution, using operating system primitives like `select()`, `poll()`, and `epoll()` to monitor many connections simultaneously within a single thread. nginx popularized this approach, demonstrating that a single server could handle tens of thousands of concurrent connections with minimal memory overhead.\n\n**Hybrid Threading Models**: Modern servers often combine approaches to balance simplicity and performance. A common pattern uses a small number of worker threads (typically one per CPU core) where each worker runs an event loop managing many connections. This provides the scalability benefits of event-driven architecture while maintaining some isolation between workers and enabling utilization of multiple CPU cores.\n\n**Thread Pool with Connection Queuing**: Another common approach maintains a pool of worker threads that pull connection-handling tasks from a shared queue. New connections are accepted by a dedicated acceptor thread and placed in the work queue, where available worker threads can claim them. This model provides good resource control - the thread pool size can be tuned based on system resources - while avoiding the overhead of creating threads per connection.\n\n> **Critical Insight**: The choice of concurrency model fundamentally determines server scalability characteristics. Process-per-connection models excel at isolation and simplicity but scale poorly. Event-driven models achieve excellent scalability but increase implementation complexity and debugging difficulty. Thread pools balance these concerns but introduce coordination complexity.\n\n**Resource Management Implications**: Each concurrency model has different implications for system resource usage. Process-per-connection models consume significant memory per connection (typically several MB per process) but provide strong CPU isolation. Thread-per-connection models reduce memory overhead (typically 8KB-2MB per thread depending on stack size) but share address space. Event-driven models minimize per-connection overhead (typically a few KB per connection state structure) but concentrate processing in fewer threads, potentially creating CPU bottlenecks.\n\n**Error Isolation Trade-offs**: The concurrency model also determines fault isolation characteristics. In process-per-connection models, a crash in request handling affects only that single connection. In thread-per-connection models, a crash can potentially bring down the entire server process. Event-driven models face similar risks, where a bug in connection handling can affect many connections processed by the same event loop.\n\n### Core Technical Challenges\n\nBuilding an HTTP server involves navigating several categories of technical challenges, each with distinct characteristics and common failure modes. Understanding these challenges upfront helps inform architectural decisions and implementation priorities.\n\n#### Network Programming Complexity\n\nNetwork programming introduces fundamental challenges that don't exist in traditional single-process applications. The most basic challenge is the **asynchronous and unreliable nature of network communication**. Unlike function calls within a process, network operations can fail in numerous ways: connections can be refused, data can be lost or corrupted, remote hosts can become unreachable, and operations can timeout. These failures can occur at any point during communication, requiring comprehensive error handling throughout the server implementation.\n\n**Socket Lifecycle Management** presents another layer of complexity. Each client connection involves creating a socket file descriptor, binding it to network addresses, managing its state transitions (listening, accepting, reading, writing), and ensuring proper cleanup. File descriptor leaks are a common failure mode - forgetting to close socket file descriptors eventually exhausts the operating system's file descriptor limit, causing the server to refuse new connections even when CPU and memory resources are available.\n\n**Partial Read/Write Operations** create subtle bugs that are difficult to reproduce in testing but common in production. Network operations like `read()` and `write()` are not guaranteed to process all requested data in a single call. A call to `read(fd, buffer, 1024)` might only read 237 bytes if that's all currently available in the kernel's socket buffer. Similarly, `write()` operations might only transmit part of the data if the socket's send buffer becomes full. Robust network code must loop on these operations, tracking progress and resuming from partial completion.\n\n| Network Challenge | Common Failure Mode | Detection Method | Recovery Strategy |\n|-------------------|---------------------|------------------|-------------------|\n| Connection timeouts | Client connects but never sends data | Set socket timeout options, monitor idle time | Close connection after timeout period |\n| Partial reads | HTTP parsing fails on incomplete headers | Track bytes read vs expected, buffer management | Continue reading until complete message received |\n| Partial writes | Response truncated, client sees incomplete data | Check `write()` return value vs intended bytes | Loop on writes, track progress, handle EAGAIN |\n| File descriptor exhaustion | `accept()` returns -1 with EMFILE/ENFILE | Monitor return values, system fd limits | Close idle connections, implement connection limits |\n| Port binding conflicts | Server fails to start, address already in use | `bind()` returns -1 with EADDRINUSE | Use SO_REUSEADDR socket option, check port availability |\n\n**Endianness and Binary Data Handling** introduces platform-specific complexity. Network protocols typically use network byte order (big-endian), while many modern processors use little-endian byte order. Functions like `htons()` (host-to-network-short) and `ntohs()` (network-to-host-short) are essential for converting port numbers and addresses correctly. Failure to handle byte order conversion can cause connections to fail or bind to unexpected ports.\n\n#### HTTP Protocol Parsing Challenges\n\nThe HTTP/1.1 protocol appears deceptively simple in examples, but robust parsing requires handling numerous edge cases and protocol variations. **Line Ending Variations** present an immediate challenge - the HTTP specification mandates CRLF (`\\r\\n`) line endings, but real-world clients sometimes send only LF (`\\n`). Parsers must handle both variations gracefully while maintaining protocol compliance.\n\n**Header Parsing Complexity** extends beyond simple key-value extraction. HTTP headers can span multiple lines using continuation syntax, where subsequent lines beginning with whitespace are considered part of the previous header. Header values can contain quoted strings with escape sequences. Header names are case-insensitive, requiring normalization for consistent processing. Some headers like `Set-Cookie` can appear multiple times in a single response, requiring special handling.\n\n```\nExample complex header scenarios:\nX-Custom-Header: value spans\n    multiple lines\nContent-Type: text/html; charset=\"utf-8\"\nSet-Cookie: session=abc123; Path=/\nSet-Cookie: preferences=theme:dark; Expires=Wed, 09 Jun 2023 10:18:14 GMT\n```\n\n**Content Length and Transfer Encoding** create parsing state machine complexity. HTTP messages can indicate body length in several ways: explicit `Content-Length` header, chunked transfer encoding, or connection close. Each approach requires different parsing logic and buffer management. Chunked encoding, in particular, requires parsing hex-encoded chunk sizes and handling chunk boundaries correctly.\n\n| HTTP Parsing Challenge | Impact | Solution Approach |\n|------------------------|---------|------------------|\n| Malformed request lines | Server crash or incorrect routing | Validate components, return 400 Bad Request for invalid format |\n| Missing required headers | Protocol violation, client confusion | Check for Host header in HTTP/1.1, return appropriate error codes |\n| Oversized headers | Memory exhaustion, DoS vulnerability | Implement header size limits, return 431 Request Header Fields Too Large |\n| Invalid method names | Security issues, unexpected behavior | Whitelist valid methods, return 405 Method Not Allowed |\n| URL encoding issues | Path traversal, security vulnerabilities | Proper URL decoding with validation |\n\n**Request Body Handling** introduces additional complexity for methods like POST and PUT. The server must read the exact number of bytes specified by the `Content-Length` header - reading too few leaves data in the socket buffer that corrupts subsequent requests, while reading too many can block waiting for data that never arrives. For chunked encoding, the server must parse chunk headers and reconstruct the original message body.\n\n#### Concurrency and Thread Safety\n\nConcurrent connection handling multiplies the complexity of every operation by introducing race conditions, resource contention, and synchronization requirements. **Shared State Management** becomes critical when multiple connections need access to server configuration, cached data, or shared resources like log files. Without proper synchronization, concurrent access can corrupt data structures, leading to crashes or incorrect behavior.\n\n**Resource Contention** occurs when multiple connections compete for limited resources. File descriptor limits, memory allocation, thread pools, and even CPU cache lines become points of contention under high load. The server must implement fair resource allocation policies and graceful degradation when resources become scarce.\n\n**Deadlock Prevention** requires careful ordering of lock acquisition and understanding of dependency relationships between shared resources. A common deadlock scenario occurs when one thread holds a connection lock while waiting for a file system lock, while another thread holds the file system lock while waiting for the connection lock. Breaking such cycles requires consistent lock ordering or timeout-based lock acquisition.\n\n| Concurrency Challenge | Risk | Prevention Strategy |\n|-----------------------|------|-------------------|\n| Race conditions in request counting | Incorrect statistics, resource leaks | Use atomic operations or proper locking |\n| Multiple threads writing to log files | Corrupted log entries, file system errors | Synchronize log writes or use per-thread log buffers |\n| Thread pool exhaustion | New connections hang indefinitely | Implement connection limits and queue bounds |\n| Memory allocation contention | Performance degradation under load | Use thread-local allocators or lock-free data structures |\n| Signal handling in multi-threaded context | Undefined behavior, crashes | Block signals in worker threads, handle in dedicated thread |\n\n**Thread Lifecycle Management** adds operational complexity. Worker threads must be created, assigned work, monitored for health, and cleanly shut down during server restart. Thread creation is expensive, so servers typically use thread pools, but pool sizing requires balancing resource usage against responsiveness. Too few threads create bottlenecks under load, while too many threads can cause excessive context switching overhead.\n\n**Graceful Shutdown Coordination** becomes complex with multiple concurrent connections. The server must stop accepting new connections, complete in-flight requests within a reasonable timeout, release resources cleanly, and coordinate shutdown across all worker threads. This requires careful state management and inter-thread communication.\n\n> **Design Principle**: The complexity of concurrent systems grows exponentially with the number of shared resources and interaction points. Minimizing shared state and designing for isolation reduces both implementation complexity and debugging difficulty.\n\nThese technical challenges influence every architectural decision in HTTP server design. The choice of concurrency model affects network programming complexity - event-driven servers must handle partial operations differently than thread-per-connection servers. HTTP parsing requirements influence buffer management strategies and error handling approaches. Understanding these challenges upfront enables making informed trade-offs between simplicity, performance, and robustness throughout the implementation process.\n\n### Implementation Guidance\n\nUnderstanding the theoretical challenges is essential, but translating them into working code requires practical knowledge of tools, libraries, and development approaches. This guidance bridges the gap between conceptual understanding and actual implementation.\n\n#### Technology Recommendations\n\nThe choice of programming language significantly impacts implementation complexity and learning outcomes. Each language provides different levels of abstraction and safety guarantees for network programming:\n\n| Component | Beginner-Friendly Option | Advanced Option |\n|-----------|-------------------------|-----------------|\n| Socket Programming | C with BSD sockets (manual memory management) | Go with net package (garbage collected, safer) |\n| HTTP Parsing | Manual string parsing with explicit state machine | Rust with nom parser combinator library |\n| Concurrency | pthread library with manual thread management | Go with goroutines and channels |\n| File I/O | POSIX file operations (open/read/write/close) | Rust with async I/O and proper error types |\n| Configuration | Command-line arguments with getopt | TOML/YAML configuration files with validation |\n| Logging | Printf to stdout/stderr | Structured logging with log levels and rotation |\n\n**C Language Considerations**: C provides the most direct exposure to underlying system concepts, making it excellent for educational purposes. However, C requires manual memory management, explicit error checking, and careful buffer management. Common C pitfalls include buffer overflows, memory leaks, and format string vulnerabilities. The lack of built-in string handling means implementing HTTP parsing requires careful attention to buffer boundaries.\n\n**Go Language Benefits**: Go simplifies many network programming challenges through garbage collection, built-in string types, and comprehensive standard library networking support. The `net/http` package provides high-level abstractions, but implementing from scratch using `net` package sockets still exposes core concepts while providing memory safety. Go's goroutines make concurrent programming more approachable than manual thread management.\n\n**Rust Language Advantages**: Rust provides memory safety without garbage collection and excellent error handling through the `Result` type system. However, Rust's ownership system can create learning obstacles for developers new to the language. The async ecosystem in Rust is powerful but complex for educational purposes.\n\n#### Essential C Socket Programming Foundation\n\nFor C implementation, several fundamental patterns appear throughout HTTP server code. Understanding these patterns prevents common mistakes:\n\n**Socket Creation and Error Handling Pattern**:\n```c\n// Socket creation with proper error handling\nint create_server_socket(int port) {\n    int sockfd;\n    struct sockaddr_in server_addr;\n    int opt = 1;\n    \n    // TODO: Create socket with AF_INET, SOCK_STREAM, 0\n    // TODO: Check if socket creation failed (returns -1)\n    // TODO: Set SO_REUSEADDR option to avoid \"Address already in use\" errors\n    // TODO: Configure server_addr structure with AF_INET, INADDR_ANY, htons(port)\n    // TODO: Bind socket to address, check for errors\n    // TODO: Start listening with reasonable backlog (e.g., 128)\n    // TODO: Return socket file descriptor\n    \n    // Error handling: close socket and return -1 on any failure\n}\n```\n\n**Connection Accept Loop Pattern**:\n```c\n// Main server loop accepting connections\nvoid server_main_loop(int server_fd) {\n    struct sockaddr_in client_addr;\n    socklen_t client_len = sizeof(client_addr);\n    int client_fd;\n    \n    while (server_running) {\n        // TODO: Accept incoming connection\n        // TODO: Handle accept errors (EINTR should retry, others should log and continue)\n        // TODO: For thread-per-connection: create thread for handle_client(client_fd)\n        // TODO: For sequential: call handle_client(client_fd) directly\n        // TODO: Ensure client_fd is closed in all code paths\n    }\n}\n```\n\n**Safe Read/Write Operations**:\n```c\n// Read complete HTTP request handling partial reads\nssize_t read_complete_request(int sockfd, char *buffer, size_t max_size) {\n    size_t total_read = 0;\n    ssize_t bytes_read;\n    \n    while (total_read < max_size - 1) {\n        // TODO: Read available data into buffer + total_read\n        // TODO: Handle read errors (EAGAIN/EWOULDBLOCK for non-blocking sockets)\n        // TODO: Handle connection close (bytes_read == 0)\n        // TODO: Update total_read counter\n        // TODO: Check for complete HTTP request (look for \\r\\n\\r\\n)\n        // TODO: Break when complete request found\n    }\n    \n    // TODO: Null-terminate buffer and return total bytes read\n}\n```\n\n#### HTTP Message Structure Reference\n\nUnderstanding HTTP message format is crucial for parser implementation:\n\n| HTTP Request Component | Format | Example | Parsing Notes |\n|------------------------|---------|---------|---------------|\n| Request Line | METHOD URI HTTP/1.1\\r\\n | GET /index.html HTTP/1.1\\r\\n | Split on spaces, validate each component |\n| Header Lines | Name: Value\\r\\n | Content-Type: text/html\\r\\n | Split on first colon, trim whitespace |\n| Header End | \\r\\n | \\r\\n | Indicates end of headers, body follows |\n| Message Body | Raw bytes | File contents or form data | Length specified by Content-Length header |\n\n**Common HTTP Methods to Support**:\n- GET: Retrieve resource, no request body\n- HEAD: Like GET but response body omitted\n- POST: Submit data, request body contains data\n- OPTIONS: Query server capabilities\n- Return 405 Method Not Allowed for unsupported methods\n\n**Essential Response Status Codes**:\n- 200 OK: Successful GET request\n- 404 Not Found: Requested file doesn't exist\n- 400 Bad Request: Malformed HTTP request\n- 405 Method Not Allowed: Unsupported HTTP method\n- 500 Internal Server Error: Server-side error occurred\n\n#### File System Security Patterns\n\nPreventing directory traversal attacks requires careful path validation:\n\n```c\n// Secure path resolution preventing directory traversal\nint validate_and_resolve_path(const char *document_root, const char *request_path, \n                            char *resolved_path, size_t max_path_len) {\n    // TODO: Remove leading slash from request_path if present\n    // TODO: Decode URL-encoded characters in request_path\n    // TODO: Join document_root and request_path safely\n    // TODO: Resolve symbolic links and relative paths (realpath())\n    // TODO: Verify resolved path starts with document_root\n    // TODO: Return error if path traversal detected\n    // TODO: Check if resolved path exists and is readable\n    // TODO: Copy resolved path to output buffer\n}\n```\n\n**MIME Type Detection**:\nCommon file extension to Content-Type mappings:\n- .html, .htm → text/html\n- .css → text/css\n- .js → application/javascript\n- .png → image/png\n- .jpg, .jpeg → image/jpeg\n- .gif → image/gif\n- Unknown extensions → application/octet-stream\n\n#### Development and Testing Setup\n\n**Compilation flags for development**:\n```bash\n# Development build with debugging symbols and warnings\ngcc -Wall -Wextra -g -DDEBUG -o httpserver *.c\n\n# Production build with optimizations\ngcc -O2 -DNDEBUG -o httpserver *.c\n```\n\n**Testing with command-line tools**:\n```bash\n# Test basic connectivity\ntelnet localhost 8080\n\n# Send manual HTTP request\nprintf \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\" | nc localhost 8080\n\n# Test with curl\ncurl -v http://localhost:8080/\n\n# Test concurrent connections\nab -n 100 -c 10 http://localhost:8080/\n```\n\n**Debugging techniques**:\n- Use `strace` to monitor system calls: `strace -e trace=network,file ./httpserver`\n- Monitor network traffic: `tcpdump -i lo port 8080`\n- Check file descriptor usage: `lsof -p $(pidof httpserver)`\n- Memory leak detection: `valgrind --leak-check=full ./httpserver`\n\n#### Project Structure Organization\n\nRecommended file organization for maintainable HTTP server implementation:\n\n```\nhttpserver/\n├── src/\n│   ├── main.c                 ← Entry point, argument parsing\n│   ├── tcp_server.c           ← Socket creation, connection accept loop\n│   ├── tcp_server.h           ← TCP server interface definitions\n│   ├── http_parser.c          ← HTTP request/response parsing\n│   ├── http_parser.h          ← HTTP data structures and functions\n│   ├── file_handler.c         ← Static file serving, MIME types\n│   ├── file_handler.h         ← File operations interface\n│   ├── worker_pool.c          ← Thread pool management (optional)\n│   ├── worker_pool.h          ← Concurrency management interface\n│   └── utils.c                ← Common utilities (logging, string ops)\n├── tests/\n│   ├── test_http_parser.c     ← Unit tests for HTTP parsing\n│   ├── test_file_handler.c    ← Unit tests for file operations\n│   └── integration_test.sh    ← End-to-end server tests\n├── www/                       ← Document root for testing\n│   ├── index.html\n│   ├── styles.css\n│   └── images/\n├── Makefile                   ← Build configuration\n└── README.md                  ← Usage instructions\n```\n\nThis organization separates concerns clearly, making it easier to implement and test each component independently while maintaining clean interfaces between components.\n\n\n## Goals and Non-Goals\n\n> **Milestone(s):** Foundation for all milestones - defines scope boundaries and implementation priorities throughout the project\n\nThe goals and non-goals section serves as our project compass, establishing clear boundaries between what we will build and what we deliberately exclude. Think of this like **planning a camping trip** - you need to decide what essential gear to pack (functional requirements), what level of comfort you're targeting (non-functional requirements), and what luxury items to leave behind despite being tempting (explicit non-goals). Just as a successful camping trip requires balancing necessity against pack weight, our HTTP server must balance educational value against implementation complexity.\n\nThis educational HTTP server prioritizes **deep understanding of core networking and concurrency concepts** over comprehensive HTTP feature coverage. We're building a production-quality foundation that demonstrates proper socket programming, HTTP protocol handling, and concurrent connection management, while deliberately excluding advanced features that would obscure these fundamental lessons.\n\nThe scope decisions made here directly impact our architectural choices throughout the project. Each functional requirement drives specific component responsibilities, each non-functional requirement influences our concurrency model selection, and each explicit non-goal prevents scope creep that could derail the learning objectives.\n\n### Functional Requirements\n\nThe functional requirements define the **core HTTP/1.1 capabilities** that our server must implement to qualify as a working static file server. These requirements map directly to our four project milestones and establish the minimum viable functionality needed for real-world HTTP communication.\n\n**TCP Connection Management** forms the foundation of our server architecture. The server must bind to a configurable port address and maintain a stable listening socket throughout its lifecycle. The connection acceptance process must handle the complete TCP handshake sequence, managing the transition from listening socket to established client connections. Each accepted connection requires proper resource allocation and cleanup to prevent file descriptor leaks over extended operation periods.\n\n| Requirement | Acceptance Criteria | Milestone |\n|-------------|-------------------|-----------|\n| Port Binding | Bind to configurable port (default 8080) using `AF_INET` and `SOCK_STREAM` | 1 |\n| Connection Acceptance | Accept multiple sequential and concurrent client connections | 1, 4 |\n| Socket Resource Management | Properly close client file descriptors and free associated memory | 1 |\n| Connection Lifecycle | Handle complete TCP connection establishment and teardown | 1 |\n\n**HTTP Protocol Compliance** ensures our server correctly interprets and responds to HTTP/1.1 messages according to RFC specifications. The request parsing component must handle the three-part HTTP message structure: request line, headers, and optional body. Response generation must include proper status codes, required headers, and correctly formatted message structure.\n\n| Requirement | Acceptance Criteria | Milestone |\n|-------------|-------------------|-----------|\n| Request Line Parsing | Extract method, path, and HTTP version from first request line | 2 |\n| Header Processing | Parse headers into key-value pairs with whitespace normalization | 2 |\n| GET Method Support | Handle GET requests with appropriate response generation | 2 |\n| HTTP Response Format | Generate responses with status line, headers, and body | 2 |\n| Host Header Extraction | Parse Host header for virtual host routing capability | 2 |\n| Error Response Generation | Return appropriate 4xx/5xx responses for invalid requests | 2 |\n\n**Static File Serving** capabilities transform URL paths into filesystem operations while maintaining security boundaries. The path resolution system must safely map HTTP request paths to filesystem locations within a configured document root directory. Content delivery includes proper MIME type detection and binary file handling.\n\n| Requirement | Acceptance Criteria | Milestone |\n|-------------|-------------------|-----------|\n| Document Root Mapping | Map URL paths to filesystem paths within configured root directory | 3 |\n| File Content Delivery | Read and serve file contents with correct Content-Length header | 3 |\n| MIME Type Detection | Set Content-Type header based on file extension analysis | 3 |\n| 404 Not Found Handling | Return 404 responses for non-existent files with proper error page | 3 |\n| Directory Traversal Prevention | Reject requests containing `../` sequences or other path escape attempts | 3 |\n| Directory Listing | Display directory contents when request path maps to directory | 3 |\n| Binary File Support | Correctly serve binary files without content corruption | 3 |\n\n**Concurrent Connection Handling** enables the server to process multiple client requests simultaneously without blocking. The concurrency implementation must prevent one slow client from stalling service to other clients. Resource management becomes critical under concurrent load to prevent memory exhaustion and file descriptor depletion.\n\n| Requirement | Acceptance Criteria | Milestone |\n|-------------|-------------------|-----------|\n| Thread-per-Connection Model | Create dedicated thread for each client connection | 4 |\n| Thread Pool Option | Limit concurrent threads to prevent resource exhaustion | 4 |\n| Non-blocking I/O Option | Handle multiple connections using select/poll event-driven model | 4 |\n| Graceful Shutdown | Complete in-flight requests before server termination | 4 |\n| Connection Limits | Reject new connections when resource limits are reached | 4 |\n| Thread Safety | Ensure shared resources are properly synchronized between threads | 4 |\n\n> **Design Insight**: These functional requirements intentionally focus on **depth over breadth**. Rather than implementing dozens of HTTP features superficially, we implement core networking, parsing, file serving, and concurrency concepts thoroughly. This approach ensures learners understand the foundational principles that apply to any networked service, not just HTTP servers.\n\n**Configuration Management** provides runtime flexibility without requiring recompilation. The server must accept configuration parameters for port binding, document root directory, thread pool sizes, and connection limits. Configuration validation ensures the server fails fast with clear error messages rather than exhibiting undefined behavior with invalid settings.\n\n| Configuration Parameter | Type | Default Value | Validation |\n|------------------------|------|---------------|------------|\n| Listen Port | Integer | 8080 | Range 1-65535, not in use |\n| Document Root | String | \"./public\" | Directory exists and readable |\n| Max Threads | Integer | 10 | Range 1-1000 |\n| Max Connections | Integer | 100 | Range 1-10000 |\n| Request Timeout | Integer | 30 seconds | Range 1-300 seconds |\n\n### Non-Functional Requirements\n\nThe non-functional requirements establish **performance and reliability characteristics** appropriate for an educational implementation. These requirements balance realistic expectations with learning objectives, ensuring the server exhibits production-like behavior without requiring production-scale optimization.\n\n**Performance Characteristics** define acceptable response times and throughput under typical educational workloads. The server should handle moderate concurrent load gracefully while providing predictable response latency. These targets ensure the implementation feels responsive during testing and demonstration while remaining achievable with straightforward algorithms.\n\n| Performance Metric | Target Value | Measurement Method | Rationale |\n|-------------------|--------------|-------------------|-----------|\n| Response Latency | < 100ms for small files | Time between request completion and response start | Human-perceptible responsiveness |\n| Concurrent Connections | 50+ simultaneous clients | Load testing with multiple curl instances | Demonstrates effective concurrency |\n| File Size Limit | 100MB maximum | Server rejects larger files with 413 response | Prevents memory exhaustion |\n| Request Rate | 100+ requests/second | Sustained load testing | Shows proper connection management |\n| Memory Usage | < 50MB under typical load | Process monitoring during operation | Ensures resource efficiency |\n\n**Reliability Requirements** focus on **graceful degradation** and predictable failure modes rather than absolute fault tolerance. The server should detect error conditions promptly and respond with appropriate HTTP status codes rather than crashing or hanging indefinitely.\n\n| Reliability Aspect | Requirement | Detection Method | Recovery Action |\n|-------------------|-------------|------------------|-----------------|\n| Malformed Request Handling | Return 400 Bad Request for parsing failures | HTTP parser validation | Send error response and close connection |\n| File System Errors | Return 500 Internal Server Error for I/O failures | File operation return codes | Log error and return HTTP error response |\n| Connection Timeout | Close idle connections after timeout period | Timer-based monitoring | Clean up resources and close socket |\n| Resource Exhaustion | Reject new connections when limits reached | Connection counting | Return 503 Service Unavailable |\n| Thread Safety | No data corruption under concurrent access | Stress testing | Use appropriate synchronization primitives |\n\n> **Decision: Educational Performance Targets**\n> - **Context**: Need to balance realistic performance expectations with educational simplicity\n> - **Options Considered**: Production-scale targets (1000s RPS), minimal targets (10 RPS), moderate targets (100 RPS)\n> - **Decision**: Moderate performance targets requiring proper concurrency but not extreme optimization\n> - **Rationale**: High enough to demonstrate the value of concurrent design, low enough to achieve with straightforward implementation\n> - **Consequences**: Enables meaningful performance testing while keeping code complexity manageable for learning\n\n**Portability Requirements** ensure the server builds and runs correctly across common development environments. The implementation should use POSIX-standard networking APIs where possible, with clear documentation of any platform-specific requirements.\n\n| Platform Aspect | Requirement | Implementation Strategy |\n|------------------|-------------|------------------------|\n| Operating System | Support Linux, macOS, and Windows | Use standard socket APIs with platform-specific compilation |\n| Compiler | Build with GCC, Clang, and MSVC | Standard C99 code with minimal extensions |\n| Dependencies | Minimize external library requirements | Use system libraries and standard library functions |\n| Configuration | Support command-line arguments and config files | Standard argument parsing and file I/O |\n\n**Security Requirements** implement **fundamental security practices** without attempting comprehensive security coverage. The focus remains on preventing basic attacks that could compromise the host system while maintaining code clarity for educational purposes.\n\n| Security Aspect | Requirement | Implementation Approach |\n|------------------|-------------|------------------------|\n| Directory Traversal Prevention | Block `../` path escape attempts | Path validation and canonical path resolution |\n| Buffer Overflow Prevention | Bounds checking on all string operations | Fixed-size buffers with length validation |\n| Resource Exhaustion Protection | Limit concurrent connections and memory usage | Connection counting and request size limits |\n| Input Validation | Reject malformed HTTP requests | Strict parsing with early rejection |\n\n### Explicit Non-Goals\n\nThe explicit non-goals prevent **scope creep** by clearly stating advanced HTTP features and optimizations that we deliberately exclude. These exclusions maintain focus on core learning objectives while acknowledging that production HTTP servers require additional capabilities.\n\n**Advanced HTTP Protocol Features** represent significant implementation complexity that would overshadow our core networking and concurrency lessons. While these features are essential for production HTTP servers, they introduce parsing complexity, state management challenges, and protocol intricacies that distract from fundamental concepts.\n\n| Excluded Feature | Complexity Reason | Learning Impact |\n|------------------|-------------------|-----------------|\n| HTTP/2 and HTTP/3 | Binary framing, multiplexing, stream management | Obscures basic HTTP message structure |\n| Chunked Transfer Encoding | Complex parsing state machine, streaming assembly | Complicates request/response handling |\n| Content Compression | Compression algorithm integration, negotiation | Adds processing overhead to core flow |\n| Range Requests | Partial content parsing, byte range calculations | Distracts from basic file serving |\n| WebSocket Protocol | Protocol upgrade negotiation, framing, persistence | Different paradigm from request/response |\n| HTTP Caching | Cache validation, ETags, conditional requests | Complex metadata management |\n\n⚠️ **Pitfall: Feature Scope Creep**\nLearners often attempt to add these advanced features during implementation, thinking they're \"simple additions.\" However, each feature significantly increases code complexity and introduces new failure modes. For example, chunked transfer encoding requires maintaining parsing state across multiple `read()` calls, handling chunk size parsing, and assembling fragmented data - this complexity obscures the core lesson about HTTP message structure.\n\n**Dynamic Content Generation** capabilities like server-side scripting, template processing, and database integration represent entirely different problem domains. While valuable for web application development, these features shift focus away from systems programming concepts toward application development.\n\n| Excluded Capability | Rationale | Alternative Learning Path |\n|---------------------|-----------|-------------------------|\n| CGI/FastCGI Integration | Process management and IPC complexity | Separate process management project |\n| Server-Side Scripting | Language runtime integration | Web application framework study |\n| Template Engine | String processing and substitution logic | Text processing project |\n| Database Connectivity | Database protocol and connection pooling | Database systems course |\n| Session Management | State persistence and security | Web application security study |\n\n**Production-Scale Optimizations** involve sophisticated algorithms and data structures that, while important for high-performance servers, add implementation complexity without enhancing understanding of core concepts. These optimizations represent performance engineering rather than foundational systems programming.\n\n| Excluded Optimization | Implementation Complexity | Core Concept Impact |\n|-----------------------|---------------------------|-------------------|\n| Connection Pooling | Connection lifecycle management, pool algorithms | Obscures basic connection handling |\n| Epoll/Kqueue Event Systems | Platform-specific APIs, event dispatching | Complicates concurrency model comparison |\n| Zero-Copy I/O | Platform-specific sendfile(), memory mapping | Distracts from basic file I/O understanding |\n| CPU Affinity Tuning | Scheduler interaction, NUMA awareness | Beyond scope of basic networking |\n| Load Balancing | Request distribution algorithms, health checking | Separate distributed systems topic |\n| Memory Pool Allocation | Custom memory management, fragmentation handling | Separate memory management study |\n\n> **Decision: Static Files Only**\n> - **Context**: Must choose between static file serving versus dynamic content generation\n> - **Options Considered**: Static only, CGI support, embedded scripting, full application server\n> - **Decision**: Static file serving exclusively\n> - **Rationale**: Dynamic content requires process management, security sandboxing, and application-specific logic that overshadows networking fundamentals\n> - **Consequences**: Enables focus on HTTP protocol, file I/O, and concurrency without application development complexity\n\n**Enterprise Integration Features** involve external system interactions and operational concerns that extend beyond the core HTTP server implementation. While critical for production deployments, these features represent separate problem domains with their own complexity.\n\n| Integration Feature | Scope Reason | Separate Learning Context |\n|--------------------|--------------|-------------------------|\n| SSL/TLS Support | Cryptographic protocol complexity | Network security course |\n| Authentication Systems | Identity management, credential validation | Security and identity systems |\n| Logging and Monitoring | Structured logging, metrics collection, alerting | Operations and observability |\n| Configuration Management | Hot reload, distributed configuration | Configuration systems design |\n| Health Check Endpoints | Service discovery, load balancer integration | Distributed systems architecture |\n| Reverse Proxy Features | Request forwarding, load distribution | Proxy and gateway systems |\n\n**Platform-Specific Optimizations** tie the implementation to particular operating systems or hardware architectures. While these optimizations provide significant performance benefits in production, they reduce code portability and introduce platform-specific complexity that distracts from universal networking concepts.\n\n| Platform Feature | Exclusion Reason |\n|------------------|------------------|\n| Linux-specific epoll | Reduces portability, complicates event loop |\n| Windows IOCP | Platform-specific async I/O model |\n| macOS kqueue | BSD-specific event notification |\n| Linux sendfile() | Platform-specific zero-copy optimization |\n| Memory-mapped files | Complex memory management, platform differences |\n| CPU-specific SIMD | Processor-specific optimization |\n\n> **Key Insight**: These explicit non-goals aren't permanent limitations - they represent **learning prioritization**. Each excluded feature could become the focus of a separate advanced project once learners master the foundational concepts. The goal is depth-first learning rather than breadth-first feature coverage.\n\nBy maintaining strict boundaries around our implementation scope, we ensure that each line of code written serves the core educational objectives: understanding network programming, HTTP protocol handling, file system interaction, and concurrent request processing. Every feature addition must pass the test: \"Does this enhance understanding of fundamental systems programming concepts, or does it distract from them?\"\n\n### Implementation Guidance\n\nThe implementation approach balances **educational clarity** with production-quality practices, ensuring learners develop good habits while maintaining focus on core concepts.\n\n**A. Technology Recommendations Table:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Socket Programming | POSIX sockets with blocking I/O | Non-blocking sockets with select/poll |\n| Threading Model | pthread_create per connection | Thread pool with work queue |\n| HTTP Parsing | String manipulation with strtok | State machine parser |\n| Configuration | Command-line arguments only | Config file + command-line override |\n| Logging | printf to stdout/stderr | Structured logging with levels |\n| Build System | Simple Makefile | Autotools or CMake |\n\n**B. Recommended File/Module Structure:**\n\n```\nhttp-server/\n├── src/\n│   ├── main.c                 ← Entry point and configuration\n│   ├── tcp_server.c           ← TCP socket management (Milestone 1)\n│   ├── tcp_server.h\n│   ├── http_parser.c          ← HTTP request/response parsing (Milestone 2)\n│   ├── http_parser.h\n│   ├── file_handler.c         ← Static file serving (Milestone 3)\n│   ├── file_handler.h\n│   ├── concurrency.c          ← Connection management (Milestone 4)\n│   ├── concurrency.h\n│   └── common.h               ← Shared constants and utilities\n├── public/                    ← Default document root\n│   ├── index.html\n│   └── test.txt\n├── tests/                     ← Test scripts and data\n├── Makefile\n└── README.md\n```\n\n**C. Infrastructure Starter Code:**\n\nComplete configuration management system ready for use:\n\n```c\n// common.h - Shared definitions and configuration\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <pthread.h>\n\n#define MAX_REQUEST_SIZE 8192\n#define MAX_PATH_LENGTH 1024\n#define MAX_RESPONSE_SIZE 16384\n#define DEFAULT_PORT 8080\n#define DEFAULT_DOC_ROOT \"./public\"\n#define DEFAULT_MAX_THREADS 10\n\ntypedef struct {\n    int port;\n    char document_root[MAX_PATH_LENGTH];\n    int max_threads;\n    int max_connections;\n    int request_timeout_sec;\n} ServerConfig;\n\ntypedef struct {\n    char method[16];\n    char path[MAX_PATH_LENGTH];\n    char version[16];\n    char headers[32][2][256];  // [header_count][key/value][string]\n    int header_count;\n    char *body;\n    size_t body_length;\n} HTTPRequest;\n\ntypedef struct {\n    int status_code;\n    char status_text[64];\n    char headers[32][2][256];  // [header_count][key/value][string]\n    int header_count;\n    char *body;\n    size_t body_length;\n} HTTPResponse;\n\ntypedef struct {\n    int client_fd;\n    struct sockaddr_in client_addr;\n    time_t connect_time;\n    pthread_t thread_id;\n} ConnectionContext;\n\n// Configuration parsing utility - complete implementation\nint parse_config(int argc, char *argv[], ServerConfig *config) {\n    // Set defaults\n    config->port = DEFAULT_PORT;\n    strncpy(config->document_root, DEFAULT_DOC_ROOT, MAX_PATH_LENGTH - 1);\n    config->max_threads = DEFAULT_MAX_THREADS;\n    config->max_connections = 100;\n    config->request_timeout_sec = 30;\n    \n    for (int i = 1; i < argc; i++) {\n        if (strcmp(argv[i], \"--port\") == 0 && i + 1 < argc) {\n            config->port = atoi(argv[++i]);\n            if (config->port < 1 || config->port > 65535) {\n                fprintf(stderr, \"Invalid port: %d\\n\", config->port);\n                return -1;\n            }\n        } else if (strcmp(argv[i], \"--root\") == 0 && i + 1 < argc) {\n            strncpy(config->document_root, argv[++i], MAX_PATH_LENGTH - 1);\n        } else if (strcmp(argv[i], \"--threads\") == 0 && i + 1 < argc) {\n            config->max_threads = atoi(argv[++i]);\n        }\n    }\n    \n    return 0;\n}\n```\n\n**D. Core Logic Skeleton Code:**\n\n```c\n// tcp_server.c - Core socket operations for learner implementation\n#include \"tcp_server.h\"\n\n/**\n * Creates and configures a server socket bound to the specified port.\n * Sets SO_REUSEADDR to allow rapid server restarts.\n * Returns: socket file descriptor on success, -1 on failure\n */\nint create_server_socket(int port) {\n    // TODO 1: Create socket using AF_INET and SOCK_STREAM\n    // TODO 2: Set SO_REUSEADDR socket option to allow address reuse\n    // TODO 3: Configure sockaddr_in structure with INADDR_ANY and port\n    // TODO 4: Use htons() to convert port to network byte order\n    // TODO 5: Bind socket to address using bind() system call\n    // TODO 6: Start listening with backlog of 10 connections using listen()\n    // TODO 7: Return socket file descriptor\n    // Hint: Check each system call return value and use perror() for errors\n}\n\n/**\n * Reads a complete HTTP request from client socket, handling partial reads.\n * Continues reading until complete request is received or error occurs.\n * Returns: number of bytes read on success, -1 on error, 0 on connection close\n */\nssize_t read_complete_request(int sockfd, char *buffer, size_t max_size) {\n    // TODO 1: Initialize total bytes read counter\n    // TODO 2: Loop until complete request received or error\n    // TODO 3: Use recv() to read available data into buffer\n    // TODO 4: Handle partial reads by updating buffer position\n    // TODO 5: Check for HTTP request end marker (\\r\\n\\r\\n)\n    // TODO 6: Handle connection close (recv returns 0)\n    // TODO 7: Handle errors (recv returns -1) with appropriate errno checking\n    // TODO 8: Prevent buffer overflow by checking max_size limit\n    // Hint: Use strstr() to find HTTP header end sequence\n}\n\n/**\n * Main server loop accepting and dispatching client connections.\n * Runs until interrupted or fatal error occurs.\n */\nvoid server_main_loop(int server_fd) {\n    // TODO 1: Initialize connection tracking structures\n    // TODO 2: Set up signal handlers for graceful shutdown\n    // TODO 3: Main accept() loop - wait for client connections\n    // TODO 4: For each accepted connection, create ConnectionContext\n    // TODO 5: Dispatch connection to appropriate handler (thread/process/event)\n    // TODO 6: Handle accept() errors and temporary failures (EAGAIN, EMFILE)\n    // TODO 7: Implement graceful shutdown - complete active requests\n    // TODO 8: Clean up all resources before exit\n    // Hint: Use accept() in a loop, check errno on failures\n}\n```\n\n**E. Language-Specific Hints:**\n\n- **Socket Creation**: Use `socket(AF_INET, SOCK_STREAM, 0)` for TCP sockets\n- **Address Reuse**: `setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))` prevents \"Address already in use\" errors\n- **Network Byte Order**: Always use `htons()` for port numbers and `htonl()` for IP addresses\n- **Partial Reads**: Network `recv()` calls may return fewer bytes than requested - always check return value and loop if needed\n- **Error Handling**: Check system call return values; use `perror()` or `strerror(errno)` for descriptive error messages\n- **Signal Safety**: Use `sigaction()` instead of `signal()` for reliable signal handling\n- **Thread Safety**: Protect shared data structures with `pthread_mutex_t`; use `pthread_create()` for thread-per-connection model\n\n**F. Milestone Checkpoint:**\n\nAfter implementing the goals and scope definition:\n1. **Document Review**: Ensure all team members understand the scope boundaries\n2. **Setup Verification**: Confirm development environment can compile and run basic C socket programs\n3. **Architecture Validation**: Verify the planned file structure makes sense for your team's workflow\n4. **Scope Verification**: List any features you're tempted to add and confirm they belong in the non-goals section\n\nExpected behavior after scope definition:\n- Clear understanding of what success looks like for each milestone\n- Agreement on which features to implement vs. defer to future projects\n- Development environment setup and ready for Milestone 1 implementation\n- Architectural decisions documented for future reference\n\n**G. Common Scope Management Pitfalls:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Implementation taking much longer than expected | Feature creep beyond defined scope | Review code against functional requirements | Remove features not in requirements |\n| Code becoming extremely complex | Attempting production optimizations | Check against explicit non-goals | Simplify to meet educational objectives |\n| Difficulty testing basic functionality | Too many features implemented simultaneously | Verify milestone progression | Focus on one milestone at a time |\n| Team disagreement on implementation approach | Unclear architectural decisions | Review decision records | Document additional ADRs as needed |\n\nThe key to successful scope management is **disciplined focus** on the learning objectives. When in doubt, choose the simpler approach that most clearly demonstrates the core concept being taught.\n\n\n## High-Level Architecture\n\n> **Milestone(s):** Foundation for Milestones 1-4 - provides the structural blueprint that guides implementation across TCP server basics, HTTP parsing, file serving, and concurrency management\n\nThe high-level architecture section serves as our blueprint for understanding how the HTTP server's components work together to transform raw TCP connections into meaningful HTTP responses. Think of this architecture as a **restaurant's service flow** - just as a restaurant has distinct stations (host desk, kitchen, servers, manager) that coordinate to serve customers, our HTTP server has specialized components that each handle a specific aspect of client requests while maintaining clear boundaries and communication patterns.\n\n### Component Overview\n\nThe HTTP server architecture centers around four primary components, each with distinct responsibilities and clear interfaces. This separation follows the **single responsibility principle** - each component has one primary job and does it well, making the system easier to understand, test, and maintain.\n\n![HTTP Server System Overview](./diagrams/system-overview.svg)\n\nThe **TCP Server Component** acts as the front door of our system, similar to a hotel's reception desk. It handles all the low-level networking concerns: creating sockets, binding to network addresses, listening for incoming connections, and accepting client requests. This component shields the rest of the system from the complexities of socket programming and network protocol details. Its primary responsibility is managing the **connection lifecycle** - from initial socket creation through connection acceptance to resource cleanup.\n\nThe **HTTP Parser Component** serves as the system's translator, converting raw byte streams from TCP connections into structured HTTP message objects. Think of it as a postal worker who takes incoming mail and sorts it into organized bins - the parser takes the raw request bytes and extracts the HTTP method, URL path, headers, and body content into well-defined data structures. This component handles all the intricacies of HTTP protocol parsing, including line ending variations, header formatting, and body content processing.\n\nThe **File Handler Component** functions as the system's librarian, responsible for mapping HTTP URL paths to actual files on the filesystem and serving their contents safely. Like a librarian who helps patrons find books while ensuring they don't access restricted sections, this component performs path resolution, security validation, MIME type detection, and file content delivery. It serves as the critical security boundary that prevents directory traversal attacks and ensures clients can only access files within the designated document root.\n\nThe **Concurrency Management Component** orchestrates how the server handles multiple simultaneous client connections. Think of it as a restaurant manager who decides whether to assign one waiter per table, maintain a pool of waiters who serve multiple tables, or have a single super-efficient waiter handle all tables. This component implements different concurrency models (thread-per-connection, thread pool, or event-driven) and manages system resources to prevent overload while maintaining responsiveness.\n\n| Component | Primary Responsibility | Key Abstractions | Dependencies |\n|-----------|------------------------|------------------|--------------|\n| TCP Server | Network connection lifecycle | Socket management, connection acceptance | Operating system sockets |\n| HTTP Parser | Protocol message translation | Request/response structures, state machine | TCP byte streams |\n| File Handler | Static content delivery | Path resolution, MIME detection | Filesystem, security validation |\n| Concurrency Manager | Multi-client coordination | Thread/event management, resource limits | Threading primitives, I/O multiplexing |\n\nEach component maintains clear boundaries through well-defined interfaces. The TCP Server produces raw client connections and byte streams. The HTTP Parser consumes these streams and produces structured `HTTPRequest` objects. The File Handler consumes requests and produces `HTTPResponse` objects with file content. The Concurrency Manager orchestrates these interactions across multiple simultaneous clients.\n\n> **Key Design Insight**: The component separation allows us to test each piece independently and swap implementations without affecting other parts. For example, we can start with a simple thread-per-connection model in the Concurrency Manager and later upgrade to an event-driven model without touching the parsing or file serving logic.\n\n### Recommended File Structure\n\nOrganizing code into a logical file structure is crucial for maintainability and understanding. The recommended structure follows C programming best practices, separating interface definitions from implementations and grouping related functionality together.\n\n```\nhttp-server/\n├── src/\n│   ├── main.c                 ← Entry point, argument parsing, server startup\n│   ├── server.h               ← Main server interface and configuration\n│   ├── server.c               ← Server initialization and main loop coordination\n│   ├── tcp/\n│   │   ├── tcp_server.h       ← TCP server component interface\n│   │   ├── tcp_server.c       ← Socket creation, binding, acceptance logic\n│   │   └── connection.h       ← Connection context and lifecycle definitions\n│   ├── http/\n│   │   ├── http_parser.h      ← HTTP parsing interface and data structures\n│   │   ├── http_parser.c      ← Request/response parsing implementation\n│   │   ├── http_request.h     ← HTTPRequest structure and utilities\n│   │   ├── http_response.h    ← HTTPResponse structure and utilities\n│   │   └── http_status.c      ← HTTP status code definitions and utilities\n│   ├── file/\n│   │   ├── file_handler.h     ← File serving interface and security functions\n│   │   ├── file_handler.c     ← Path resolution and file serving logic\n│   │   ├── mime_types.h       ← MIME type detection interface\n│   │   └── mime_types.c       ← File extension to MIME type mapping\n│   ├── concurrency/\n│   │   ├── connection_manager.h  ← Concurrency management interface\n│   │   ├── thread_pool.c      ← Thread pool implementation\n│   │   ├── event_loop.c       ← Event-driven I/O implementation\n│   │   └── worker_thread.c    ← Individual connection handler logic\n│   └── util/\n│       ├── logger.h           ← Logging interface and macros\n│       ├── logger.c           ← Logging implementation\n│       ├── buffer.h           ← Dynamic buffer management\n│       └── buffer.c           ← Buffer allocation and manipulation\n├── config/\n│   ├── server.conf            ← Default server configuration\n│   └── mime.types             ← MIME type mappings\n├── www/                       ← Default document root directory\n│   ├── index.html            ← Default homepage\n│   ├── 404.html              ← Custom 404 error page\n│   └── static/               ← Static assets (CSS, JS, images)\n├── tests/\n│   ├── unit/                 ← Unit tests for individual components\n│   ├── integration/          ← Integration tests for component interaction\n│   └── performance/          ← Load testing and benchmarking\n├── docs/\n│   ├── README.md             ← Project documentation\n│   └── API.md                ← Component interface documentation\n└── Makefile                  ← Build configuration and targets\n```\n\nThis structure provides several important benefits for the learning process. The **component isolation** allows students to focus on one aspect of the server at a time - they can work on TCP networking without worrying about HTTP parsing, or implement file serving without getting bogged down in concurrency details. The **header/implementation separation** follows C best practices and makes it easy to understand interfaces before diving into implementation details.\n\nThe **progressive complexity** arrangement lets students implement components in dependency order. They start with basic TCP server functionality, then add HTTP parsing, followed by file serving, and finally concurrency management. Each milestone builds naturally on the previous ones without requiring major refactoring.\n\n> **Learning Insight**: The file structure mirrors the component architecture - each major directory corresponds to one of our four main components. This makes it easy to find code related to specific functionality and reinforces the architectural boundaries in the actual codebase.\n\n### Request Processing Flow\n\nThe request processing flow describes how our four components collaborate to handle a complete HTTP request-response cycle. Understanding this flow is essential because it shows how the individual components we'll implement in later milestones work together to create a functioning web server.\n\n![Request Processing Sequence](./diagrams/request-processing-flow.svg)\n\nThe flow begins when a client establishes a TCP connection to our server. The **TCP Server Component** receives this connection through the standard socket lifecycle: `socket()` creates the server socket, `bind()` attaches it to a specific port, `listen()` marks it as accepting connections, and `accept()` blocks until a client connects. Once a connection arrives, `accept()` returns a new client file descriptor representing the dedicated communication channel with that specific client.\n\nAt this point, the **Concurrency Management Component** takes control of the newly accepted connection. Depending on the configured concurrency model, it either spawns a new thread to handle this client, assigns the connection to a worker thread from a pre-allocated pool, or adds the client socket to an event loop for non-blocking processing. This decision affects performance characteristics but doesn't change the fundamental processing steps that follow.\n\nThe connection handler begins by reading the HTTP request data from the client socket. This involves calling `read()` or `recv()` repeatedly until a complete HTTP request is received. The challenge here is handling **partial reads** - network operations may return fewer bytes than requested, so the server must buffer incoming data and continue reading until it receives the complete request headers (indicated by a blank line) and any request body.\n\nOnce complete request data is available, the **HTTP Parser Component** takes over. It processes the raw bytes according to HTTP/1.1 protocol rules, extracting the request line (method, path, HTTP version), parsing headers into key-value pairs, and handling any request body content. The parser validates the request format and populates an `HTTPRequest` structure with the parsed information. If parsing fails due to malformed input, the parser generates an appropriate HTTP error response (400 Bad Request) without proceeding to file serving.\n\nWith a valid `HTTPRequest` in hand, the **File Handler Component** begins the process of mapping the requested URL path to actual file content. This involves several security-critical steps: validating the request path to prevent directory traversal attacks, resolving the path relative to the configured document root, checking file permissions and existence, and determining the appropriate MIME type based on the file extension.\n\nIf the requested file exists and is accessible, the File Handler reads its contents and constructs an `HTTPResponse` object with appropriate headers (Content-Type, Content-Length, Last-Modified) and the file data as the response body. If the file doesn't exist, it generates a 404 Not Found response. If security validation fails (such as detecting a directory traversal attempt), it returns a 403 Forbidden response.\n\nThe final step involves the connection handler sending the complete HTTP response back to the client. This requires formatting the `HTTPResponse` object into valid HTTP protocol format (status line, headers, blank line, body) and writing all the data to the client socket using `write()` or `send()` operations. Like reading, writing may require multiple system calls to send all response data, especially for large files.\n\nAfter successful response delivery, the connection handler performs cleanup operations: closing the client file descriptor to free the network connection, releasing any allocated memory for request/response processing, and updating connection statistics or logs. The handler then either terminates (in thread-per-connection model) or returns to process the next connection (in thread pool or event-driven models).\n\n| Processing Stage | Component Responsible | Key Operations | Potential Failures |\n|------------------|----------------------|----------------|--------------------|\n| Connection Accept | TCP Server | `socket()`, `bind()`, `listen()`, `accept()` | Port already bound, network errors |\n| Concurrency Dispatch | Concurrency Manager | Thread creation or event registration | Resource exhaustion, thread limits |\n| Request Reading | Connection Handler | `read()` with partial read handling | Client disconnect, timeout, oversized request |\n| HTTP Parsing | HTTP Parser | Protocol parsing, structure population | Malformed request, unsupported method |\n| Path Resolution | File Handler | Security validation, file system access | Directory traversal, permission denied |\n| Response Generation | File Handler | File reading, MIME detection, header creation | File not found, I/O errors |\n| Response Transmission | Connection Handler | `write()` with complete data delivery | Client disconnect, network congestion |\n| Cleanup | Connection Handler | Resource deallocation, connection closure | File descriptor leaks |\n\nThe beauty of this architecture is its **modularity** - each component has a clear input and output interface, making it possible to test and debug each stage independently. When problems occur, the structured flow helps isolate issues to specific components and processing stages.\n\n> **Error Propagation Design**: Errors detected in any component flow back through the system as HTTP error responses rather than crashing the server. This ensures that problems with individual requests don't affect other concurrent connections or server stability.\n\nThe request processing flow also demonstrates why our component separation is effective. The TCP Server handles networking complexity, the HTTP Parser manages protocol details, the File Handler deals with security and content delivery, and the Concurrency Manager coordinates multiple simultaneous flows of this same process. Each component can be implemented, tested, and optimized independently while contributing to the overall request-response capability.\n\nThis flow repeats continuously as the server processes client requests. The main server loop accepts new connections and dispatches them for processing, while existing connections move through their individual request-response cycles. The architecture supports both simple sequential processing (for learning) and sophisticated concurrent processing (for performance) using the same fundamental flow pattern.\n\n### Implementation Guidance\n\nThe implementation guidance bridges the gap between architectural understanding and actual C code. The following recommendations and starter code help structure the development process across all four milestones.\n\n#### Technology and Library Recommendations\n\n| Component | Simple Approach | Production Approach | Recommended for Learning |\n|-----------|----------------|-------------------|------------------------|\n| TCP Networking | POSIX sockets (`socket.h`, `netinet/in.h`) | POSIX sockets with epoll/kqueue | POSIX sockets |\n| HTTP Parsing | Manual string parsing with `strtok()` | Purpose-built state machine parser | State machine parser |\n| File I/O | Standard C file operations (`fopen()`, `fread()`) | Memory-mapped files (`mmap()`) | Standard C file operations |\n| Concurrency | `pthread` library | Event-driven with `epoll`/`select` | Start with `pthread` |\n| Logging | `printf()` to stdout/stderr | Structured logging with levels | `printf()` with log levels |\n| Configuration | Command-line arguments | Configuration file parsing | Command-line arguments |\n\n#### Project Structure and Build System\n\nThe Makefile should support incremental development, allowing students to build and test individual components:\n\n```makefile\n# Makefile - Progressive build targets for milestone development\nCC = gcc\nCFLAGS = -Wall -Wextra -std=c99 -pthread -g\nSRCDIR = src\nOBJDIR = obj\n\n# Milestone 1: TCP Server basics\ntcp_server: $(OBJDIR)/main.o $(OBJDIR)/tcp_server.o $(OBJDIR)/logger.o\n\t$(CC) $(CFLAGS) -o $@ $^\n\n# Milestone 2: Add HTTP parsing\nhttp_parser: $(OBJDIR)/main.o $(OBJDIR)/tcp_server.o $(OBJDIR)/http_parser.o $(OBJDIR)/logger.o\n\t$(CC) $(CFLAGS) -o $@ $^\n\n# Milestone 3: Add file serving\nfile_server: $(OBJDIR)/main.o $(OBJDIR)/tcp_server.o $(OBJDIR)/http_parser.o $(OBJDIR)/file_handler.o $(OBJDIR)/mime_types.o $(OBJDIR)/logger.o\n\t$(CC) $(CFLAGS) -o $@ $^\n\n# Milestone 4: Complete server with concurrency\nhttp_server: $(OBJDIR)/main.o $(OBJDIR)/server.o $(OBJDIR)/tcp_server.o $(OBJDIR)/http_parser.o $(OBJDIR)/file_handler.o $(OBJDIR)/connection_manager.o $(OBJDIR)/logger.o\n\t$(CC) $(CFLAGS) -o $@ $^\n```\n\n#### Core Infrastructure Starter Code\n\nStudents should focus their learning effort on the four main components rather than boilerplate code. The following infrastructure provides a solid foundation:\n\n**Logger Implementation** (Complete - Ready to Use):\n```c\n// src/util/logger.h - Logging infrastructure for debugging and monitoring\n#ifndef LOGGER_H\n#define LOGGER_H\n\n#include <stdio.h>\n#include <time.h>\n\ntypedef enum {\n    LOG_DEBUG = 0,\n    LOG_INFO = 1,\n    LOG_WARN = 2,\n    LOG_ERROR = 3\n} log_level_t;\n\n#define LOG_DEBUG_MSG(fmt, ...) log_message(LOG_DEBUG, __FILE__, __LINE__, fmt, ##__VA_ARGS__)\n#define LOG_INFO_MSG(fmt, ...) log_message(LOG_INFO, __FILE__, __LINE__, fmt, ##__VA_ARGS__)\n#define LOG_WARN_MSG(fmt, ...) log_message(LOG_WARN, __FILE__, __LINE__, fmt, ##__VA_ARGS__)\n#define LOG_ERROR_MSG(fmt, ...) log_message(LOG_ERROR, __FILE__, __LINE__, fmt, ##__VA_ARGS__)\n\nvoid log_message(log_level_t level, const char* file, int line, const char* fmt, ...);\nvoid set_log_level(log_level_t level);\n\n#endif\n\n// src/util/logger.c\n#include \"logger.h\"\n#include <stdarg.h>\n#include <string.h>\n\nstatic log_level_t current_level = LOG_INFO;\nstatic const char* level_names[] = {\"DEBUG\", \"INFO\", \"WARN\", \"ERROR\"};\n\nvoid set_log_level(log_level_t level) {\n    current_level = level;\n}\n\nvoid log_message(log_level_t level, const char* file, int line, const char* fmt, ...) {\n    if (level < current_level) return;\n    \n    time_t now = time(NULL);\n    struct tm* tm_info = localtime(&now);\n    char time_buffer[26];\n    strftime(time_buffer, 26, \"%Y-%m-%d %H:%M:%S\", tm_info);\n    \n    const char* filename = strrchr(file, '/');\n    filename = filename ? filename + 1 : file;\n    \n    fprintf(stderr, \"[%s] %s %s:%d - \", time_buffer, level_names[level], filename, line);\n    \n    va_list args;\n    va_start(args, fmt);\n    vfprintf(stderr, fmt, args);\n    va_end(args);\n    \n    fprintf(stderr, \"\\n\");\n    fflush(stderr);\n}\n```\n\n**Configuration Management** (Complete - Ready to Use):\n```c\n// src/server.h - Server configuration and initialization\n#ifndef SERVER_H\n#define SERVER_H\n\n#include <time.h>\n#include <pthread.h>\n#include <netinet/in.h>\n\n#define MAX_PATH_LENGTH 1024\n#define DEFAULT_PORT 8080\n#define MAX_REQUEST_SIZE 8192\n#define DEFAULT_MAX_THREADS 50\n#define DEFAULT_MAX_CONNECTIONS 100\n#define DEFAULT_TIMEOUT_SEC 30\n\ntypedef struct {\n    int port;\n    char document_root[MAX_PATH_LENGTH];\n    int max_threads;\n    int max_connections;\n    int request_timeout_sec;\n} ServerConfig;\n\ntypedef struct {\n    int client_fd;\n    struct sockaddr_in client_addr;\n    time_t connect_time;\n    pthread_t thread_id;\n} ConnectionContext;\n\n// Configuration initialization and validation\nServerConfig* create_default_config(void);\nint parse_command_line_args(int argc, char* argv[], ServerConfig* config);\nint validate_config(const ServerConfig* config);\nvoid print_config(const ServerConfig* config);\n\n#endif\n```\n\n#### Core Component Skeleton Code\n\nFor the main learning components, provide function signatures with detailed TODO comments that map to the architectural design:\n\n**TCP Server Component Skeleton**:\n```c\n// src/tcp/tcp_server.c - TCP server implementation skeleton\n#include \"tcp_server.h\"\n#include \"../util/logger.h\"\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <errno.h>\n\nint create_server_socket(int port) {\n    // TODO 1: Create TCP socket using socket(AF_INET, SOCK_STREAM, 0)\n    // TODO 2: Set SO_REUSEADDR option to allow port reuse after restart\n    // TODO 3: Configure sockaddr_in structure with AF_INET, port, INADDR_ANY\n    // TODO 4: Bind socket to the configured address using bind()\n    // TODO 5: Start listening with listen() and appropriate backlog\n    // TODO 6: Return server socket file descriptor, or -1 on error\n    // Hint: Use htons() to convert port to network byte order\n    // Hint: Log each step for debugging - socket creation, binding, listening\n    return -1; // Placeholder\n}\n\nvoid server_main_loop(int server_fd) {\n    // TODO 1: Initialize infinite loop for connection acceptance\n    // TODO 2: Call accept() to wait for incoming client connections\n    // TODO 3: Log client connection details (IP address, port)\n    // TODO 4: Create ConnectionContext structure for this client\n    // TODO 5: Dispatch connection to concurrency manager for processing\n    // TODO 6: Handle accept() errors (EINTR, EMFILE, ENFILE)\n    // TODO 7: Continue loop after handling connection or error\n    // Hint: accept() blocks until client connects - this is expected\n    // Hint: Store client address info for logging and security\n}\n```\n\n**HTTP Parser Component Skeleton**:\n```c\n// src/http/http_parser.c - HTTP parsing implementation skeleton\n#include \"http_parser.h\"\n#include \"../util/logger.h\"\n#include <string.h>\n#include <stdlib.h>\n\nssize_t read_complete_request(int sockfd, char* buffer, size_t max_size) {\n    // TODO 1: Initialize buffer position and bytes remaining counter\n    // TODO 2: Loop reading from socket until complete request received\n    // TODO 3: Handle partial reads - recv() may return fewer bytes than requested\n    // TODO 4: Look for \"\\r\\n\\r\\n\" sequence indicating end of headers\n    // TODO 5: If Content-Length header present, continue reading body\n    // TODO 6: Return total bytes read, or -1 on error\n    // Hint: Use recv() with MSG_DONTWAIT for non-blocking reads\n    // Hint: Grow buffer if request approaches max_size limit\n    return -1; // Placeholder\n}\n\nint parse_http_request(const char* raw_request, HTTPRequest* request) {\n    // TODO 1: Initialize HTTPRequest structure to zero/empty values\n    // TODO 2: Extract method, path, version from first line using strtok()\n    // TODO 3: Validate method is supported (GET initially)\n    // TODO 4: Parse headers line by line, splitting on \": \" delimiter\n    // TODO 5: Store headers in request->headers array with count\n    // TODO 6: Handle special headers like Content-Length, Host\n    // TODO 7: Return 0 on success, HTTP error code on failure\n    // Hint: Use strncpy() to prevent buffer overflows\n    // Hint: Trim whitespace from header values\n    return -1; // Placeholder\n}\n```\n\n#### Development and Testing Checkpoints\n\nAfter implementing each milestone, students should verify functionality with these specific tests:\n\n**Milestone 1 Checkpoint**: TCP Server Basics\n- Command: `./tcp_server 8080`\n- Test: `telnet localhost 8080` should connect without error\n- Expected: Server logs \"Client connected from 127.0.0.1:XXXXX\"\n- Test: Send any text, should receive hardcoded HTTP response\n- Signs of problems: \"Address already in use\" (port not released), connection refused (binding failed), server crashes (missing error handling)\n\n**Milestone 2 Checkpoint**: HTTP Request Parsing\n- Command: `./http_parser 8080`\n- Test: `curl -v http://localhost:8080/test.html`\n- Expected: Server logs parsed method=GET, path=/test.html, version=HTTP/1.1\n- Test: `curl -H \"Custom-Header: test-value\" http://localhost:8080/`\n- Expected: Server logs the custom header in parsed headers list\n- Signs of problems: Parsing fails on normal requests (line ending issues), crashes on malformed input (missing bounds checking)\n\n**Milestone 3 Checkpoint**: Static File Serving\n- Setup: Create `www/index.html` and `www/test.txt` in document root\n- Test: `curl http://localhost:8080/index.html` should return file contents\n- Expected: Correct Content-Type header based on .html extension\n- Test: `curl http://localhost:8080/../etc/passwd` should return 403 Forbidden\n- Expected: Security validation prevents directory traversal\n- Signs of problems: Binary files corrupted (text mode reading), 404 for existing files (path resolution issues)\n\n**Milestone 4 Checkpoint**: Concurrent Connections\n- Test: `for i in {1..10}; do curl http://localhost:8080/index.html & done; wait`\n- Expected: All 10 requests complete successfully with same response\n- Test: Use `ab -n 100 -c 10 http://localhost:8080/index.html` for load testing\n- Expected: No connection refused errors, consistent response times\n- Signs of problems: Requests hang (thread deadlock), server crashes (race conditions), increasing response times (resource leaks)\n\n#### Common Implementation Pitfalls\n\n⚠️ **Pitfall: Network Byte Order Confusion**\nStudents often forget to use `htons()` when setting port numbers in `sockaddr_in` structures. This causes the server to bind to unexpected ports (e.g., port 8080 becomes port 36895 in big-endian). Always use `htons()` for ports and `htonl()` for addresses, even though `INADDR_ANY` is already in network byte order.\n\n⚠️ **Pitfall: Partial Read Handling**\nNetwork reads can return fewer bytes than requested, but beginners often assume `recv()` always returns complete data. This causes parsing failures when HTTP requests are split across multiple TCP packets. Always loop on read operations until you have complete data, checking for both partial reads and error conditions.\n\n⚠️ **Pitfall: File Descriptor Leaks**\nForgetting to close client sockets leads to file descriptor exhaustion, especially under concurrent load. The server will eventually fail to accept new connections when the per-process file descriptor limit is reached. Ensure every `accept()` has a corresponding `close()`, even in error paths.\n\n⚠️ **Pitfall: Buffer Overflow in Parsing**\nHTTP header values can be arbitrarily long, but fixed-size buffers in `HTTPRequest` structures can overflow. Always use `strncpy()` instead of `strcpy()` and validate input lengths before copying. Consider rejecting requests with headers exceeding reasonable limits.\n\n⚠️ **Pitfall: Directory Traversal Security**\nStudents often implement simple string concatenation for path resolution (`document_root + request_path`), which allows attacks like `../../../etc/passwd`. Use `realpath()` or manual path validation to ensure resolved paths stay within the document root directory.\n\n\n## Data Model\n\n> **Milestone(s):** Foundation for Milestones 1-4 - defines the core data structures that represent HTTP messages, server configuration, and connection state throughout TCP server basics, HTTP parsing, file serving, and concurrency management\n\nThe data model forms the backbone of our HTTP server implementation, defining how we represent HTTP messages, server configuration, and connection state in memory. Think of these data structures as the **vocabulary** our system uses to communicate internally - just as a library has standardized forms for book requests, patron information, and checkout records, our HTTP server needs standardized structures to represent requests, responses, configuration, and active connections.\n\n![HTTP Data Structures](./diagrams/data-model.svg)\n\nThe data model serves several critical purposes in our architecture. First, it provides a **common language** between components - when the HTTP parser extracts a request, it produces an `HTTPRequest` structure that the file handler can immediately understand. Second, it establishes **memory ownership** boundaries, making it clear which component is responsible for allocating and freeing different data. Third, it defines the **security boundaries** where validation must occur, particularly around path handling and request size limits.\n\n### HTTP Message Structures\n\nHTTP messages are the fundamental units of communication in our server. Just as a postal system has standardized envelope formats with sender addresses, recipient addresses, and contents, HTTP has standardized request and response formats that our server must parse and generate correctly.\n\nThe `HTTPRequest` structure represents an incoming client request after parsing. This structure captures all the essential information from the HTTP request line and headers, providing a clean interface for other components to access request data without needing to understand HTTP parsing details.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `method` | `char[16]` | HTTP method (GET, POST, etc.) - fixed size prevents overflow attacks |\n| `path` | `char[MAX_PATH_LENGTH]` | Requested URL path - bounds checked during parsing |\n| `version` | `char[16]` | HTTP version string (HTTP/1.1) - used for protocol compliance |\n| `headers` | `char[MAX_HEADERS][2][256]` | Array of header key-value pairs - [index][0] = key, [index][1] = value |\n| `header_count` | `int` | Number of headers parsed - prevents access beyond valid headers |\n| `body` | `char*` | Pointer to request body data - dynamically allocated based on Content-Length |\n| `body_length` | `size_t` | Size of body in bytes - critical for binary data and memory management |\n\nThe fixed-size fields for method, path, and version provide **buffer overflow protection** by enforcing maximum lengths during parsing. The headers array uses a two-dimensional structure where each header occupies one slot with separate key and value strings. This design trades some memory efficiency for simplicity and safety - we can iterate through headers without complex pointer arithmetic.\n\n> **Critical Design Insight**: The `HTTPRequest` structure owns all its string data except the body, which is dynamically allocated. This ownership model ensures that once parsing completes, the request structure is self-contained and can be passed between threads safely.\n\nThe `HTTPResponse` structure represents an outgoing server response. This structure mirrors the request format but includes fields specific to response generation, particularly status codes and response bodies that may contain file data.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `status_code` | `int` | HTTP status code (200, 404, 500, etc.) - used for response line generation |\n| `status_text` | `char[64]` | Status reason phrase (OK, Not Found, etc.) - human readable status |\n| `headers` | `char[MAX_HEADERS][2][256]` | Response headers - same format as request for consistency |\n| `header_count` | `int` | Number of response headers - prevents iteration beyond valid headers |\n| `body` | `char*` | Response body content - often points to file data or error page HTML |\n| `body_length` | `size_t` | Size of response body - essential for Content-Length header |\n\nThe response structure separates `status_code` as an integer from `status_text` as a string. This design allows components to set status codes using constants (200, 404) while the HTTP formatting code handles the textual representation. The body pointer typically points to either file content loaded from disk or statically allocated error page HTML.\n\n> **Decision: Fixed-Size vs Dynamic Headers**\n> - **Context**: HTTP headers can vary widely in number and size, and we need to balance memory efficiency with implementation simplicity\n> - **Options Considered**:\n>   1. Fixed-size array of header structs (chosen)\n>   2. Linked list of dynamically allocated headers\n>   3. Hash table for O(1) header lookup\n> - **Decision**: Fixed-size array with maximum header count\n> - **Rationale**: Educational simplicity outweighs memory efficiency. Fixed arrays eliminate complex memory management and pointer chasing. Most HTTP requests have fewer than 20 headers, making the memory overhead acceptable.\n> - **Consequences**: Simple iteration and memory management, but wastes memory for requests with few headers. Header count limits prevent resource exhaustion attacks.\n\n### Server Configuration\n\nServer configuration defines the runtime behavior and operational parameters of our HTTP server. Think of configuration as the **operating procedures** for our library - it defines which port to listen on (like which desk to staff), where files are stored (like which building houses the collection), and how many concurrent patrons we can serve (like staffing levels).\n\nThe `ServerConfig` structure centralizes all configurable server parameters, making it easy to adjust behavior without recompiling code. This structure is typically populated from command-line arguments, configuration files, or environment variables during server startup.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `port` | `int` | TCP port number for incoming connections - typically 8080 for development |\n| `document_root` | `char[MAX_PATH_LENGTH]` | Filesystem path to serve files from - security boundary for file access |\n| `max_threads` | `int` | Maximum number of worker threads in thread pool - prevents resource exhaustion |\n| `max_connections` | `int` | Maximum concurrent client connections - limits memory and file descriptor usage |\n| `request_timeout_sec` | `int` | Seconds to wait for complete request - prevents slowloris attacks |\n\nThe `document_root` field establishes the **security boundary** for file serving. All file access must be validated against this root directory to prevent directory traversal attacks. The path validation logic uses this field as the trusted base path for resolving all requested file paths.\n\nThe concurrency control fields (`max_threads`, `max_connections`) provide **resource protection** mechanisms. Without these limits, a malicious client could exhaust server resources by opening thousands of connections or triggering creation of unlimited threads. These limits enable **graceful degradation** under load rather than complete system failure.\n\n> **Decision: Single Configuration Structure vs Component-Specific Config**\n> - **Context**: Different server components need different configuration parameters, and we must decide how to organize these settings\n> - **Options Considered**:\n>   1. Single global configuration structure (chosen)\n>   2. Separate configuration structures per component\n>   3. Key-value configuration map with string keys\n> - **Decision**: Single `ServerConfig` structure with all parameters\n> - **Rationale**: Simplifies configuration management and ensures all components see consistent values. Eliminates coordination issues between component-specific configs. Educational code benefits from centralized configuration.\n> - **Consequences**: All components depend on the same config structure, which creates coupling but eliminates configuration synchronization bugs. Adding new parameters requires updating the central structure.\n\nThe default configuration values provide sensible starting points for development and testing:\n\n| Parameter | Default Value | Rationale |\n|-----------|---------------|-----------|\n| `port` | `DEFAULT_PORT` (8080) | Non-privileged port that doesn't require root access |\n| `document_root` | `./public` | Relative path allows easy setup in any directory |\n| `max_threads` | 10 | Sufficient for development testing without resource exhaustion |\n| `max_connections` | 100 | Reasonable limit for educational server implementation |\n| `request_timeout_sec` | 30 | Long enough for normal requests, short enough to prevent attacks |\n\n### Connection State Management\n\nConnection state tracking manages the lifecycle and context of individual client connections. Think of connection state as the **patron record** system in our library analogy - for each visitor, we track when they arrived, which desk they're assigned to, and what resources they're currently using.\n\nThe `ConnectionContext` structure maintains per-connection information throughout the request processing lifecycle. This context gets created when a client connects and destroyed when the connection closes, providing a clean abstraction for connection-specific data.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `client_fd` | `int` | File descriptor for client socket - used for all I/O operations with this client |\n| `client_addr` | `struct sockaddr_in` | Client's IP address and port - useful for logging and access control |\n| `connect_time` | `time_t` | Timestamp when connection was established - enables timeout detection |\n| `thread_id` | `pthread_t` | Thread handling this connection - used for thread pool management |\n\nThe `client_fd` field is the **primary key** for this connection - all socket operations use this file descriptor to identify which client to communicate with. This field must be carefully managed to prevent **file descriptor leaks**, where unclosed descriptors eventually exhaust system resources.\n\nThe `client_addr` field captures the network address of the connecting client. This information serves multiple purposes: security logging (tracking which IPs generate errors), access control (blocking malicious IPs), and debugging (identifying problematic clients). The `sockaddr_in` structure contains the client's IP address and port number in network byte order.\n\n> **Decision: Per-Connection Context vs Global Connection Tracking**\n> - **Context**: We need to track active connections for resource management and graceful shutdown, and must decide how to organize this tracking\n> - **Options Considered**:\n>   1. Individual context structures passed to handlers (chosen)\n>   2. Global connection registry with lookup by file descriptor\n>   3. Thread-local storage for connection data\n> - **Decision**: Individual `ConnectionContext` structures passed to request handlers\n> - **Rationale**: Provides clear ownership model where each handler owns its connection context. Eliminates global state synchronization issues. Makes testing easier since handlers receive all needed context as parameters.\n> - **Consequences**: Connection context must be explicitly passed between functions, but this makes data flow visible and eliminates hidden dependencies on global state.\n\nThe connection lifecycle follows a predictable pattern that our data structures support:\n\n1. **Connection Establishment**: TCP server creates `ConnectionContext` with client socket information\n2. **Request Processing**: Context gets passed to HTTP parser and file handler for request processing\n3. **Response Generation**: Context used for writing response back to client socket\n4. **Connection Cleanup**: Context destruction triggers socket closure and resource cleanup\n\nConnection timeout detection uses the `connect_time` field to identify connections that have been idle too long. The timeout logic compares current time against `connect_time + request_timeout_sec` to determine if a connection should be forcibly closed:\n\n```\ncurrent_time = time(NULL);\nconnection_age = current_time - context->connect_time;\nif (connection_age > config->request_timeout_sec) {\n    // Force connection closure to prevent resource exhaustion\n}\n```\n\nThread tracking via `thread_id` enables proper cleanup during server shutdown. The main server can iterate through active connections and signal worker threads to complete current requests before terminating. This field also helps with debugging by associating log messages with specific threads.\n\n> ⚠️ **Pitfall: Connection Context Lifecycle Management**\n> \n> The most common mistake is failing to properly clean up connection contexts, leading to memory leaks and file descriptor exhaustion. Every `ConnectionContext` creation must have a corresponding cleanup that closes the client socket and frees any dynamically allocated resources. The cleanup must occur even when errors happen during request processing - use proper error handling patterns to ensure cleanup code always runs.\n\n### Common Data Model Pitfalls\n\nUnderstanding the common mistakes made when designing and implementing these data structures helps avoid subtle bugs that can be difficult to debug in a networked system.\n\n⚠️ **Pitfall: Buffer Overflow in Fixed-Size Fields**\n\nThe fixed-size character arrays in `HTTPRequest` and `HTTPResponse` provide safety but require careful bounds checking during parsing. Failing to validate input lengths before copying into these fields creates classic buffer overflow vulnerabilities. Always use `strncpy` instead of `strcpy` and ensure null termination:\n\n```c\n// Incorrect - potential overflow\nstrcpy(request->method, parsed_method);\n\n// Correct - bounds checking with null termination\nstrncpy(request->method, parsed_method, sizeof(request->method) - 1);\nrequest->method[sizeof(request->method) - 1] = '\\0';\n```\n\n⚠️ **Pitfall: Memory Ownership Confusion**\n\nThe HTTP structures mix stack-allocated fixed arrays with heap-allocated dynamic content (body fields). This creates confusion about who owns what memory and when to free it. Establish clear ownership rules: the parsing component allocates body memory, the request/response structure owns it during processing, and the cleanup component frees it. Never free body memory from multiple locations.\n\n⚠️ **Pitfall: Network Byte Order in Address Structures**\n\nThe `sockaddr_in` structure in `ConnectionContext` stores addresses in network byte order, while application code typically works with host byte order. Forgetting to convert between these formats causes connection failures and incorrect logging. Always use `htons`/`ntohs` for ports and `htonl`/`ntohl` for addresses when converting between network and host byte order.\n\n⚠️ **Pitfall: Thread Safety in Shared Structures**\n\nWhile individual `ConnectionContext` structures are thread-safe because each connection runs in its own thread, the shared `ServerConfig` structure requires careful handling. Multiple threads may read configuration values concurrently, which is safe, but dynamic configuration updates would require synchronization. For this educational implementation, treat `ServerConfig` as read-only after initialization to avoid concurrency issues.\n\n⚠️ **Pitfall: Resource Cleanup on Early Exit**\n\nError conditions during request processing can cause early returns from functions, potentially skipping cleanup code. This leads to file descriptor leaks and memory leaks that accumulate over time. Structure your code to use cleanup patterns like `goto error_cleanup` in C or defer statements in other languages to ensure resources are always freed.\n\nThe data model provides the foundation for all subsequent components in our HTTP server. These structures define the contracts between components and establish the memory management patterns that prevent common security vulnerabilities and resource leaks. Understanding these structures deeply enables confident implementation of the parsing, file serving, and concurrency components that build upon this foundation.\n\n### Implementation Guidance\n\nThe data model implementation focuses on creating robust, secure data structures that prevent common web server vulnerabilities while maintaining simplicity for educational purposes. The following guidance provides complete working code for structure definitions and helper functions.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Memory Management | Manual malloc/free with cleanup functions | Memory pools with automatic cleanup |\n| String Handling | Fixed-size buffers with strncpy | Dynamic strings with automatic resizing |\n| Configuration | Compile-time constants | Runtime config file parsing |\n| Address Handling | Manual network/host byte order conversion | Address utility library wrapper |\n\n#### Recommended File Structure\n\n```\nhttp-server/\n  src/\n    data_model.h              ← structure definitions (this section)\n    data_model.c              ← helper functions and cleanup\n    http_parser.h             ← parsing component\n    http_parser.c\n    file_handler.h            ← file serving component  \n    file_handler.c\n    tcp_server.h              ← network component\n    tcp_server.c\n    main.c                    ← entry point\n  tests/\n    test_data_model.c         ← unit tests for structures\n  public/                     ← document root for serving files\n    index.html\n    style.css\n```\n\n#### Complete Data Structure Definitions\n\n**File: `src/data_model.h`**\n\n```c\n#ifndef DATA_MODEL_H\n#define DATA_MODEL_H\n\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <pthread.h>\n#include <time.h>\n#include <stddef.h>\n\n// Protocol and size constants\n#define MAX_REQUEST_SIZE 8192\n#define MAX_PATH_LENGTH 1024\n#define MAX_HEADERS 32\n#define MAX_HEADER_LENGTH 256\n#define DEFAULT_PORT 8080\n\n// HTTP request structure - represents parsed client request\ntypedef struct {\n    char method[16];                              // HTTP method (GET, POST, etc.)\n    char path[MAX_PATH_LENGTH];                   // URL path component\n    char version[16];                             // HTTP version (HTTP/1.1)\n    char headers[MAX_HEADERS][2][MAX_HEADER_LENGTH]; // [index][0]=key, [index][1]=value\n    int header_count;                             // Number of valid headers\n    char* body;                                   // Dynamically allocated body content\n    size_t body_length;                          // Size of body in bytes\n} HTTPRequest;\n\n// HTTP response structure - represents server response to send\ntypedef struct {\n    int status_code;                              // HTTP status code (200, 404, etc.)\n    char status_text[64];                         // Status reason phrase\n    char headers[MAX_HEADERS][2][MAX_HEADER_LENGTH]; // Response headers\n    int header_count;                             // Number of response headers\n    char* body;                                   // Response body content\n    size_t body_length;                          // Size of response body\n} HTTPResponse;\n\n// Server configuration - runtime parameters\ntypedef struct {\n    int port;                                     // TCP port to listen on\n    char document_root[MAX_PATH_LENGTH];          // Root directory for file serving\n    int max_threads;                              // Maximum worker threads\n    int max_connections;                          // Maximum concurrent connections\n    int request_timeout_sec;                      // Request timeout in seconds\n} ServerConfig;\n\n// Connection context - per-connection state tracking\ntypedef struct {\n    int client_fd;                                // Client socket file descriptor\n    struct sockaddr_in client_addr;               // Client network address\n    time_t connect_time;                          // When connection was established\n    pthread_t thread_id;                          // Thread handling this connection\n} ConnectionContext;\n\n// Helper function declarations\nvoid init_http_request(HTTPRequest* request);\nvoid init_http_response(HTTPResponse* response);\nvoid init_server_config(ServerConfig* config);\nvoid init_connection_context(ConnectionContext* context, int client_fd, struct sockaddr_in* addr);\n\nvoid cleanup_http_request(HTTPRequest* request);\nvoid cleanup_http_response(HTTPResponse* response);\n\nint add_response_header(HTTPResponse* response, const char* key, const char* value);\nconst char* get_request_header(const HTTPRequest* request, const char* key);\n\n#endif // DATA_MODEL_H\n```\n\n#### Core Helper Functions (Complete Implementation)\n\n**File: `src/data_model.c`**\n\n```c\n#include \"data_model.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n// Initialize HTTPRequest structure with safe defaults\nvoid init_http_request(HTTPRequest* request) {\n    if (!request) return;\n    \n    memset(request->method, 0, sizeof(request->method));\n    memset(request->path, 0, sizeof(request->path));\n    memset(request->version, 0, sizeof(request->version));\n    memset(request->headers, 0, sizeof(request->headers));\n    request->header_count = 0;\n    request->body = NULL;\n    request->body_length = 0;\n}\n\n// Initialize HTTPResponse structure with safe defaults\nvoid init_http_response(HTTPResponse* response) {\n    if (!response) return;\n    \n    response->status_code = 200;\n    strncpy(response->status_text, \"OK\", sizeof(response->status_text) - 1);\n    response->status_text[sizeof(response->status_text) - 1] = '\\0';\n    memset(response->headers, 0, sizeof(response->headers));\n    response->header_count = 0;\n    response->body = NULL;\n    response->body_length = 0;\n}\n\n// Initialize ServerConfig with sensible defaults\nvoid init_server_config(ServerConfig* config) {\n    if (!config) return;\n    \n    config->port = DEFAULT_PORT;\n    strncpy(config->document_root, \"./public\", sizeof(config->document_root) - 1);\n    config->document_root[sizeof(config->document_root) - 1] = '\\0';\n    config->max_threads = 10;\n    config->max_connections = 100;\n    config->request_timeout_sec = 30;\n}\n\n// Initialize connection context with client information\nvoid init_connection_context(ConnectionContext* context, int client_fd, struct sockaddr_in* addr) {\n    if (!context) return;\n    \n    context->client_fd = client_fd;\n    if (addr) {\n        context->client_addr = *addr;\n    } else {\n        memset(&context->client_addr, 0, sizeof(context->client_addr));\n    }\n    context->connect_time = time(NULL);\n    context->thread_id = pthread_self();\n}\n\n// Clean up dynamically allocated request memory\nvoid cleanup_http_request(HTTPRequest* request) {\n    if (!request) return;\n    \n    if (request->body) {\n        free(request->body);\n        request->body = NULL;\n        request->body_length = 0;\n    }\n}\n\n// Clean up dynamically allocated response memory\nvoid cleanup_http_response(HTTPResponse* response) {\n    if (!response) return;\n    \n    // Note: Only free body if it was dynamically allocated\n    // File content bodies may point to mapped memory\n    if (response->body) {\n        free(response->body);\n        response->body = NULL;\n        response->body_length = 0;\n    }\n}\n```\n\n#### Core Logic Skeleton (for learners to complete)\n\n```c\n// Add a header to HTTP response - learners implement this\nint add_response_header(HTTPResponse* response, const char* key, const char* value) {\n    // TODO 1: Check if response and key/value pointers are valid\n    // TODO 2: Check if we have space for another header (header_count < MAX_HEADERS)\n    // TODO 3: Copy key into headers[header_count][0] using strncpy with bounds checking\n    // TODO 4: Copy value into headers[header_count][1] using strncpy with bounds checking\n    // TODO 5: Ensure both strings are null-terminated\n    // TODO 6: Increment header_count\n    // TODO 7: Return 0 on success, -1 on error\n    // Hint: Always leave one byte for null terminator when using strncpy\n}\n\n// Find header value by key in HTTP request - learners implement this\nconst char* get_request_header(const HTTPRequest* request, const char* key) {\n    // TODO 1: Check if request and key pointers are valid - return NULL if not\n    // TODO 2: Loop through request->header_count headers\n    // TODO 3: For each header, compare headers[i][0] with key using strcasecmp (case-insensitive)\n    // TODO 4: If match found, return pointer to headers[i][1] (the value)\n    // TODO 5: If no match found after loop, return NULL\n    // Hint: Use strcasecmp for case-insensitive header name comparison\n}\n```\n\n#### Milestone Checkpoints\n\n**After implementing data structures:**\n\n1. **Compilation Test**: Run `gcc -c src/data_model.c -o data_model.o` - should compile without errors\n2. **Initialization Test**: Create simple test program that initializes each structure and prints field values\n3. **Memory Test**: Use `valgrind` to check for memory leaks in cleanup functions\n\n**Expected behavior:**\n- All structures initialize with safe default values\n- Header functions handle bounds checking correctly\n- Cleanup functions prevent memory leaks\n- No segmentation faults or buffer overflows\n\n**Signs of problems:**\n- Compiler warnings about buffer overflows → Check strncpy usage and null termination\n- Segfaults during initialization → Check pointer validation in functions\n- Memory leaks in valgrind → Ensure cleanup functions free all allocated memory\n\n#### Language-Specific Implementation Hints\n\n**C-Specific Guidelines:**\n- Always use `strncpy` instead of `strcpy` for fixed-size buffers\n- Set explicit null terminators: `buffer[size-1] = '\\0'` after strncpy\n- Check all pointer parameters for NULL before dereferencing\n- Use `memset` to zero-initialize structures containing arrays\n- Free dynamically allocated memory in reverse order of allocation\n\n**Memory Management Patterns:**\n- Initialize all structure fields to safe defaults (NULL pointers, zero values)\n- Use consistent naming: `init_*` for initialization, `cleanup_*` for deallocation\n- Never free the same pointer twice - set to NULL after freeing\n- Check malloc return values - handle allocation failures gracefully\n\n**Network Address Handling:**\n- Use `htons()` when setting port in sockaddr_in: `addr.sin_port = htons(port)`\n- Use `ntohs()` when reading port from sockaddr_in: `port = ntohs(addr.sin_port)`\n- Set address family explicitly: `addr.sin_family = AF_INET`\n- Use `INADDR_ANY` for server binding: `addr.sin_addr.s_addr = INADDR_ANY`\n\nThis implementation foundation provides type-safe, bounds-checked data structures that prevent common web server vulnerabilities while maintaining educational clarity. The helper functions establish consistent patterns for initialization and cleanup that carry forward into more complex components.\n\n\n## TCP Server Component\n\n> **Milestone(s):** Milestone 1 (TCP Server Basics) - creates the foundational networking layer that accepts and manages TCP connections\n\n### TCP Server Mental Model: Restaurant Host Station Analogy\n\nThink of the TCP server component as the host station at a busy restaurant. Just as a restaurant host manages the front door, greets guests, and assigns them to available tables, our TCP server manages the network \"front door,\" accepts incoming client connections, and prepares them for request processing.\n\nThe **server socket** is like the restaurant's front door itself - it's a fixed location where customers know they can arrive. The host doesn't serve food directly; instead, they perform the crucial role of managing arrivals and ensuring each guest gets proper attention. Similarly, our server socket doesn't process HTTP requests directly - it focuses solely on the TCP connection lifecycle.\n\nWhen a customer approaches the restaurant, the host performs a standard greeting ritual: welcoming them, checking if they have a reservation, and determining where to seat them. In our TCP server, this greeting ritual is the **connection acceptance process**: we accept the incoming connection, validate it's properly formed, and prepare a dedicated communication channel for that specific client.\n\nThe host station maintains a guest registry - tracking who's currently dining, when they arrived, and which table they're using. Our TCP server maintains **connection context** - tracking which clients are connected, their network addresses, and the file descriptors representing their communication channels.\n\nJust as a restaurant can only seat a limited number of guests based on table availability and staff capacity, our TCP server must manage **resource limits**. When the restaurant is full, the host might ask new arrivals to wait or politely suggest they try again later. Similarly, when our server reaches its connection limits, it must gracefully handle new connection attempts without crashing or leaving clients hanging indefinitely.\n\nThe host station operates independently of the kitchen - guests can arrive and be seated even when the kitchen is temporarily busy. This separation of concerns is crucial in our TCP server design: connection acceptance operates independently of HTTP request processing, allowing us to maintain responsive networking even when file serving or parsing operations take time.\n\n![TCP Connection Lifecycle](./diagrams/connection-lifecycle.svg)\n\n### TCP Server Interface\n\nThe TCP server component exposes a clean interface that abstracts the underlying socket programming complexity while providing the necessary control points for configuration and lifecycle management. This interface serves as the contract between the networking layer and the rest of our HTTP server components.\n\nThe interface design follows the principle of **progressive disclosure** - simple cases require minimal configuration, while advanced scenarios can access detailed control options. A junior developer can get a basic server running with just a port number, while an experienced developer can fine-tune socket options, connection limits, and error handling behavior.\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `create_server_socket` | `port int` | `int` | Creates, configures, and binds server socket to specified port. Returns server file descriptor or -1 on failure. |\n| `server_main_loop` | `server_fd int` | `void` | Main connection acceptance loop. Blocks accepting connections until server shutdown signal received. |\n| `init_connection_context` | `context ConnectionContext*, client_fd int, addr sockaddr_in` | `void` | Initializes connection context structure with client information and timestamps. |\n| `accept_client_connection` | `server_fd int, context ConnectionContext*` | `int` | Accepts single client connection and populates context. Returns client file descriptor or -1. |\n| `close_client_connection` | `context ConnectionContext*` | `void` | Properly closes client connection and cleans up associated resources. |\n| `set_socket_options` | `sockfd int, options int` | `int` | Configures socket options like SO_REUSEADDR, timeouts. Returns 0 on success. |\n| `validate_client_connection` | `context ConnectionContext*` | `int` | Validates incoming connection against rate limits and security policies. Returns 1 if valid. |\n\nThe interface separates **socket lifecycle management** from **connection processing**. The `create_server_socket` function handles all the complex socket setup that must happen once at server startup: creating the socket, setting appropriate options, binding to the network interface, and beginning to listen for connections. This separation means the main server loop can focus purely on the accept-process-cleanup cycle without worrying about socket configuration details.\n\nConnection context initialization through `init_connection_context` ensures that every client connection gets proper bookkeeping from the moment it's established. This context tracking becomes crucial later when we implement concurrent connection handling - each thread or event handler needs access to connection-specific state without interfering with other active connections.\n\nThe `validate_client_connection` method provides an extension point for implementing security policies, rate limiting, and resource management without cluttering the core acceptance logic. In a production server, this method might check the client's IP address against blacklists, enforce per-IP connection limits, or apply geographic restrictions.\n\n> **Key Design Principle**: The TCP server interface maintains **single responsibility** - it knows how to manage TCP connections but remains agnostic about what data flows over those connections. This separation allows the same TCP foundation to support not just HTTP, but potentially other protocols in future extensions.\n\n### Connection Acceptance Algorithm\n\nThe connection acceptance algorithm represents the core networking logic that transforms an abstract \"listening socket\" into concrete client connections ready for HTTP processing. This algorithm runs continuously while the server is active, making it one of the most critical paths in our entire system.\n\nUnderstanding this algorithm requires recognizing that **TCP connection establishment** is actually a multi-step handshake between client and server, coordinated by the operating system's networking stack. Our server code participates in this handshake through specific socket system calls, but much of the complexity is handled transparently by the kernel.\n\nHere's the detailed connection acceptance process:\n\n1. **Initialize Server Socket**: Create a socket file descriptor using `socket(AF_INET, SOCK_STREAM, 0)` to establish a TCP communication endpoint. This creates a socket in the **closed state** that exists only in our process memory.\n\n2. **Configure Socket Options**: Apply socket options before binding to prevent common deployment issues. Set `SO_REUSEADDR` to allow rapid server restarts without \"Address already in use\" errors. Configure timeout options to prevent indefinite blocking on problematic connections.\n\n3. **Bind to Network Address**: Associate the socket with a specific network interface and port using `bind()`. This reserves the port number system-wide and transitions the socket to the **bound state**. The `sockaddr_in` structure specifies IPv4 protocol family, target port in network byte order, and `INADDR_ANY` to accept connections on all available network interfaces.\n\n4. **Begin Listening**: Transition the socket to **listening state** using `listen()` with a backlog parameter that determines how many pending connections the kernel will queue while our server processes current requests. A backlog of 128 provides good balance between memory usage and connection responsiveness.\n\n5. **Enter Acceptance Loop**: Begin the infinite loop that defines our server's operational lifetime. Each iteration handles one complete connection acceptance cycle, from detecting an incoming connection to preparing it for request processing.\n\n6. **Block on Accept Call**: Execute `accept()` system call which blocks the current thread until a client initiates a TCP connection. The kernel handles the three-way TCP handshake automatically - by the time `accept()` returns, the connection is fully established and ready for data exchange.\n\n7. **Extract Client Information**: When `accept()` returns successfully, it provides two critical pieces of information: a new file descriptor representing the established connection, and a `sockaddr_in` structure containing the client's network address and port. This client information enables logging, security validation, and debugging.\n\n8. **Initialize Connection Context**: Populate a `ConnectionContext` structure with the client file descriptor, address information, connection timestamp, and any other per-connection state our server needs to track. This context follows the connection through its entire processing lifecycle.\n\n9. **Validate Connection**: Apply security policies and resource limits to determine if this connection should be processed or rejected. Check the client's IP address against any configured restrictions, verify we haven't exceeded our maximum concurrent connection limit, and apply any rate limiting rules.\n\n10. **Hand Off to Request Processor**: If the connection passes validation, transfer responsibility to the HTTP processing components. In a single-threaded server, this means immediately beginning HTTP parsing. In a multi-threaded server, this means dispatching the connection to a worker thread or adding it to a work queue.\n\n11. **Handle Connection Errors**: If any step in the acceptance process fails, log the error with sufficient detail for debugging, ensure any partially allocated resources are cleaned up, and continue the acceptance loop. Server errors should not prevent processing other valid connections.\n\n12. **Prepare for Next Connection**: Reset any per-connection state, check for shutdown signals, and return to the blocking accept call to handle the next incoming connection.\n\nThe algorithm's **error handling strategy** deserves special attention because network programming involves many potential failure modes. Connection acceptance can fail due to temporary resource exhaustion (too many open file descriptors), network interface issues, or malicious connection attempts. The algorithm must distinguish between **recoverable errors** (temporary resource shortage) and **fatal errors** (socket corruption) to maintain server stability.\n\n**Resource management** throughout this algorithm is critical for long-running server stability. Every successful `accept()` call creates a new file descriptor that must eventually be closed. Every `ConnectionContext` structure that gets allocated must eventually be cleaned up. The algorithm includes explicit checkpoints where resource cleanup occurs, preventing the gradual resource leaks that would eventually crash a long-running server.\n\nThe algorithm's **blocking behavior** on the accept call has important implications for server architecture. In a single-threaded server, the entire server blocks waiting for connections, which means request processing must complete before new connections can be accepted. This creates a natural backpressure mechanism but limits concurrency. Understanding this blocking behavior is essential for making informed decisions about concurrency models in later milestones.\n\n![Request Processing Sequence](./diagrams/request-processing-flow.svg)\n\n### Architecture Decision Records\n\nThe TCP server component involves several fundamental architectural decisions that significantly impact the server's behavior, performance characteristics, and operational requirements. Each decision represents a trade-off between different operational priorities and implementation complexity levels.\n\n> **Decision: Socket Address Configuration**\n> - **Context**: Server must bind to a network address that clients can reach, but different deployment scenarios require different binding strategies. Local development needs different configuration than production deployment.\n> - **Options Considered**: \n>   1. Bind to localhost (127.0.0.1) only for development safety\n>   2. Bind to specific IP address provided via configuration\n>   3. Bind to INADDR_ANY (0.0.0.0) accepting connections on all interfaces\n> - **Decision**: Bind to `INADDR_ANY` with configurable port\n> - **Rationale**: Maximum deployment flexibility allows same code to work in development (localhost access), containerized environments (bridge networks), and production (public interfaces). Security restrictions should be handled by firewalls and network policies rather than application binding logic.\n> - **Consequences**: Enables flexible deployment but requires careful firewall configuration in production. Simplifies development and testing workflows.\n\n| Option | Pros | Cons |\n|--------|------|------|\n| Localhost only | Development safety, prevents accidental exposure | Requires separate production configuration, complicates container networking |\n| Specific IP configuration | Precise control, explicit security | Complex configuration management, brittle to infrastructure changes |\n| INADDR_ANY | Maximum flexibility, simple configuration | Requires external security controls, potential for misconfiguration |\n\n> **Decision: Socket Option Configuration**\n> - **Context**: Default socket behavior often conflicts with server restart requirements and connection handling preferences. Raw sockets have conservative defaults that prioritize data integrity over operational convenience.\n> - **Options Considered**:\n>   1. Use default socket options for maximum compatibility\n>   2. Set SO_REUSEADDR only for restart convenience\n>   3. Configure comprehensive socket options including timeouts and buffer sizes\n> - **Decision**: Set `SO_REUSEADDR` and basic timeout options, avoid advanced optimizations\n> - **Rationale**: `SO_REUSEADDR` solves a critical development pain point (rapid restart failures) with minimal complexity. Advanced socket tuning requires deep networking knowledge and varies significantly across operating systems. Focus on educational value rather than production optimization.\n> - **Consequences**: Enables smooth development workflow and basic timeout protection without introducing configuration complexity that obscures learning objectives.\n\n| Option | Pros | Cons |\n|--------|------|------|\n| Default options | Maximum compatibility, simple code | Restart failures, no timeout protection |\n| SO_REUSEADDR only | Solves restart problem, minimal complexity | No protection against hung connections |\n| Comprehensive tuning | Production-quality performance | Complex configuration, platform-specific code |\n\n> **Decision: Connection Backlog Size**\n> - **Context**: The `listen()` system call requires a backlog parameter that determines how many pending connections the kernel queues while the server processes current requests. This value significantly impacts behavior under load.\n> - **Options Considered**:\n>   1. Small backlog (5-10) for simple educational scenarios\n>   2. Medium backlog (128) balancing memory and responsiveness\n>   3. Large backlog (1024+) for maximum connection handling\n> - **Decision**: Medium backlog of 128 connections\n> - **Rationale**: Small backlogs cause connection rejections during normal load testing with simple tools like curl loops. Large backlogs consume significant kernel memory and can mask concurrency problems by hiding the need for efficient request processing. 128 connections provides sufficient buffering for realistic testing while revealing performance bottlenecks.\n> - **Consequences**: Allows meaningful load testing without overwhelming resource usage. Students can observe queue behavior under load without requiring sophisticated testing tools.\n\n| Option | Pros | Cons |\n|--------|------|------|\n| Small backlog (5-10) | Low memory usage, simple | Connection rejections during normal testing |\n| Medium backlog (128) | Good testing flexibility, reasonable memory | Moderate kernel memory usage |\n| Large backlog (1024+) | Handles high load | High memory usage, masks performance problems |\n\n> **Decision: Error Handling Strategy**\n> - **Context**: Network operations can fail in numerous ways - temporary resource exhaustion, client disconnections, malformed connection attempts, and system-level networking issues. The server must handle these failures without crashing while providing useful debugging information.\n> - **Options Considered**:\n>   1. Aggressive error checking with server shutdown on any failure\n>   2. Graceful degradation continuing operation despite individual connection failures\n>   3. Minimal error handling focusing on core functionality\n> - **Decision**: Graceful degradation with comprehensive logging\n> - **Rationale**: Real servers must remain operational despite individual connection failures - network programming inherently involves partial failures that don't indicate server problems. Aggressive shutdown makes the server fragile during development and testing. Comprehensive logging provides debugging information without operational brittleness.\n> - **Consequences**: Server remains stable during testing with imperfect clients (browsers, curl with various options) but requires systematic logging implementation and error classification.\n\n| Option | Pros | Cons |\n|--------|------|------|\n| Aggressive shutdown | Simple code, fail-fast behavior | Brittle operation, difficult testing |\n| Graceful degradation | Stable operation, realistic behavior | Complex error classification |\n| Minimal handling | Simple implementation | Difficult debugging, potential resource leaks |\n\n> **Decision: Resource Cleanup Responsibility**\n> - **Context**: TCP connections create file descriptors that must be properly closed to prevent resource leaks. Connection contexts may allocate memory that requires cleanup. Clear ownership of cleanup responsibility prevents resource leaks and double-free errors.\n> - **Options Considered**:\n>   1. TCP server handles all cleanup automatically\n>   2. Caller responsible for cleanup using provided cleanup functions\n>   3. Hybrid approach with automatic cleanup for errors, manual for success cases\n> - **Decision**: Caller responsible for cleanup using provided cleanup functions\n> - **Rationale**: Clear ownership semantics prevent resource management confusion. The connection processing components need control over connection lifetime - automatic cleanup could interfere with Keep-Alive implementations or connection reuse. Explicit cleanup functions provide safety without removing control.\n> - **Consequences**: Requires discipline in calling cleanup functions but provides clear resource ownership. Enables advanced connection management patterns in future extensions.\n\n| Option | Pros | Cons |\n|--------|------|------|\n| Automatic cleanup | Simple usage, prevents leaks | Limited control, complicates advanced features |\n| Caller responsible | Clear ownership, maximum control | Requires discipline, potential for mistakes |\n| Hybrid approach | Balances safety and control | Complex ownership rules, confusing semantics |\n\n### TCP Server Interface Implementation Details\n\nThe TCP server interface requires careful attention to **state management** and **error propagation** to ensure reliable operation across diverse deployment scenarios. Each interface method has specific preconditions and postconditions that must be clearly documented and consistently enforced.\n\nThe `create_server_socket` function encapsulates the complex socket initialization sequence that must occur exactly once per server lifetime. This function performs operations that cannot be safely retried or undone, making its error handling particularly important. Socket creation can fail due to permission issues (binding to privileged ports), resource exhaustion (too many open file descriptors), or network configuration problems (invalid addresses).\n\n**Socket option configuration** within `create_server_socket` requires platform-specific knowledge but follows a standard pattern. The `SO_REUSEADDR` option allows immediate reuse of the server's port after shutdown, preventing the \"Address already in use\" errors that commonly frustrate developers during testing. Without this option, the operating system enforces a waiting period (typically 2-4 minutes) before allowing port reuse, which severely impacts development iteration speed.\n\nThe `server_main_loop` function implements the server's primary operational mode - an infinite loop accepting connections until explicitly shut down. This function's blocking behavior means it effectively **owns the main thread** in single-threaded server implementations. The loop must handle both normal connection acceptance and graceful shutdown signaling without dropping in-flight connections.\n\nConnection context management through `init_connection_context` establishes the data structures that track each client connection throughout its processing lifecycle. The context includes not just the client file descriptor, but also timing information for timeout enforcement, client address data for logging and security decisions, and space for connection-specific state that accumulates during request processing.\n\nThe interface's **error reporting strategy** uses return codes rather than exceptions or global error state, following C language conventions and ensuring that error conditions can be handled immediately at the call site. Negative return values indicate errors, zero indicates success for status-returning functions, and positive values carry meaningful data (like file descriptors).\n\n**Resource ownership semantics** throughout the interface follow a consistent pattern: the caller owns any resources returned by the interface methods and bears responsibility for cleanup. This ownership model prevents the common resource management confusion that occurs when ownership transfers unpredictably between components. The interface provides explicit cleanup functions rather than relying on automatic resource management.\n\n### Connection Acceptance Algorithm Implementation\n\nThe connection acceptance algorithm implementation must handle the inherent **asynchronous nature** of network operations while maintaining deterministic server behavior. Network clients can connect, send partial data, and disconnect at any time, creating numerous edge cases that must be handled gracefully without corrupting server state.\n\nThe algorithm's **blocking semantics** on the accept call create an important architectural constraint. When `accept()` blocks waiting for connections, the calling thread cannot perform other operations. This blocking behavior is actually beneficial in many scenarios - it provides natural flow control and prevents the server from consuming CPU cycles when no work is available. However, it also means that server shutdown must occur through signal handling or secondary threads, since the main thread remains blocked in the accept call.\n\n**File descriptor management** within the algorithm requires careful attention to avoid resource leaks that would eventually crash the server. Each successful accept operation creates a new file descriptor that represents the client connection. These file descriptors are a limited system resource - most operating systems impose per-process limits between 1,024 and 65,536 open file descriptors. Failing to close client connections eventually exhausts this limit and prevents new connections.\n\nThe algorithm must handle **partial connection establishment** scenarios where clients begin the TCP handshake but fail to complete it properly. The `accept()` call returns successfully once the TCP three-way handshake completes, but clients might immediately close the connection or send malformed data. The algorithm treats these as normal occurrences rather than error conditions, logging them for debugging purposes but continuing normal operation.\n\n**Client address extraction** from the `sockaddr_in` structure returned by accept provides valuable debugging and security information. The client's IP address and port number help diagnose connection issues and can be used for implementing security policies like rate limiting or geographic restrictions. However, this address information reflects the immediate network peer, which might be a proxy or load balancer in production deployments rather than the actual end user.\n\nThe algorithm's **error classification logic** distinguishes between different types of accept failures to determine appropriate responses. Temporary failures like `EMFILE` (too many open files) or `EAGAIN` (resource temporarily unavailable) indicate resource pressure but don't require server shutdown. Persistent failures like `EBADF` (bad file descriptor) or `EINVAL` (invalid argument) indicate programming errors or socket corruption that require investigation.\n\n**Connection validation** occurs immediately after successful connection establishment, before any data exchange begins. This validation checks that the new connection fits within configured resource limits, that the client address doesn't violate security policies, and that the server has sufficient resources to handle request processing. Connections that fail validation are rejected with appropriate logging but don't impact other active connections.\n\nThe algorithm includes **graceful degradation mechanisms** for handling resource pressure without complete service failure. When connection limits are approached, the server can choose to reject new connections with meaningful error responses rather than accepting connections it cannot properly service. This degradation provides better client experience than accepting connections that will eventually timeout due to resource starvation.\n\n**Threading considerations** affect how the connection acceptance algorithm integrates with concurrency models implemented in later milestones. In thread-per-connection models, each accepted connection gets dispatched to a dedicated thread immediately. In event-driven models, accepted connections are added to a monitoring set for asynchronous processing. The algorithm's design supports both approaches through its clear separation of connection establishment and request processing.\n\n### Architecture Decision Records: Advanced Considerations\n\nSeveral additional architectural decisions significantly impact the TCP server's operational characteristics and integration with other system components. These decisions often involve subtle trade-offs that become apparent only during implementation and testing phases.\n\n> **Decision: Socket Buffer Size Configuration**\n> - **Context**: Operating system default socket buffer sizes optimize for general network usage but may not suit HTTP server workloads. HTTP requests vary dramatically in size (from simple GET requests under 200 bytes to large POST requests with file uploads), and buffer sizing affects memory usage and performance.\n> - **Options Considered**:\n>   1. Use operating system defaults without modification\n>   2. Configure explicit send/receive buffer sizes based on expected request sizes\n>   3. Dynamic buffer sizing that adapts to observed request patterns\n> - **Decision**: Use operating system defaults with monitoring points for future optimization\n> - **Rationale**: Operating system defaults represent decades of networking optimization for typical workloads. Premature optimization of socket buffers often provides minimal benefit while adding configuration complexity. Monitoring points allow future measurement-driven optimization without initial complexity.\n> - **Consequences**: Simplifies initial implementation and reduces configuration surface area. May require revisiting for high-performance scenarios, but provides solid foundation for educational objectives.\n\n> **Decision: IPv6 Support Strategy**\n> - **Context**: Modern networking environments increasingly use IPv6, but IPv6 socket programming adds significant complexity through dual-stack configuration, address family negotiation, and platform-specific behaviors.\n> - **Options Considered**:\n>   1. IPv4 only using AF_INET sockets exclusively\n>   2. IPv6 only using AF_INET6 sockets exclusively  \n>   3. Dual-stack supporting both protocols through separate sockets or IPv6 mapped addresses\n> - **Decision**: IPv4 only for educational implementation with architecture supporting future IPv6 extension\n> - **Rationale**: IPv4 socket programming provides clearer learning path with fewer platform-specific complications. Dual-stack networking involves subtle protocol interactions that distract from core HTTP server concepts. IPv4 remains widely supported and sufficient for learning objectives.\n> - **Consequences**: Limits deployment scenarios but maintains focus on core concepts. Architecture design supports adding IPv6 support as advanced extension without requiring complete reimplementation.\n\n> **Decision: Connection Timeout Configuration**\n> - **Context**: Client connections can remain idle indefinitely, consuming server resources without productive work. HTTP connections may experience network delays, slow clients, or malicious attempts to exhaust server resources through connection hoarding.\n> - **Options Considered**:\n>   1. No timeouts relying on client behavior and operating system defaults\n>   2. Hard timeouts that forcibly close connections after fixed duration\n>   3. Activity-based timeouts that reset when data is exchanged\n> - **Decision**: Configurable hard timeouts with reasonable defaults\n> - **Rationale**: Educational servers need protection against resource exhaustion during testing with imperfect client code. Hard timeouts provide predictable resource reclamation without complex activity tracking logic. Configurable values allow adaptation to different testing scenarios.\n> - **Consequences**: Prevents resource exhaustion during development but may close legitimate slow connections. Provides foundation for implementing more sophisticated timeout strategies in advanced versions.\n\nThe timeout decision particularly impacts **testing and debugging workflows** because developers often pause execution in debuggers or step through code slowly while examining server behavior. Aggressive timeouts can interfere with debugging by closing connections while the developer investigates server state. The configurable approach allows disabling timeouts during debugging while maintaining protection during automated testing.\n\n**Platform portability** considerations influence several interface design decisions, particularly around socket option availability and error code interpretation. Windows socket programming uses different error codes than Unix systems, and some socket options have different names or behaviors. The interface design acknowledges these differences without attempting complete abstraction, allowing platform-specific optimizations while maintaining core functionality across operating systems.\n\n### Common TCP Pitfalls\n\nTCP socket programming contains numerous subtle pitfalls that can create intermittent bugs, resource leaks, or security vulnerabilities. Understanding these pitfalls helps developers recognize and avoid common mistakes that can take hours to debug in complex networking code.\n\n⚠️ **Pitfall: Network Byte Order Confusion**\n\nOne of the most common mistakes in socket programming involves **byte order conversion** when working with port numbers and IP addresses. The `sockaddr_in` structure expects port numbers in **network byte order** (big-endian), but most development machines use little-endian byte order for local variables.\n\nThe symptom appears as binding or connection failures with confusing error messages. A server configured to listen on port 8080 might actually attempt to bind to port 20737 (8080 with bytes swapped) if the `htons()` conversion is forgotten. This creates \"Address already in use\" errors that seem to occur randomly depending on what other services are running.\n\nThe fix requires consistent use of byte order conversion functions: `htons()` for port numbers going into socket structures, and `ntohs()` for extracting port numbers from socket structures. IP addresses require `htonl()` and `ntohl()` conversion, though using `INADDR_ANY` avoids this issue for server binding.\n\nPrevention involves establishing a coding convention where all socket structure assignments use explicit byte order conversion, even when the values appear to work without conversion on the development machine. This consistency prevents subtle bugs when deploying to different architectures.\n\n⚠️ **Pitfall: Ignoring Partial Reads**\n\nNetwork I/O operations can return **fewer bytes than requested** even when more data is available and the connection remains active. The `read()` system call provides no guarantee about how much data it will return - it might return 1 byte, the full requested amount, or anything in between.\n\nThis behavior creates intermittent parsing failures that are difficult to reproduce consistently. An HTTP request header might be split across multiple read operations, causing the parser to see incomplete lines or fragmented header fields. The resulting parsing errors often appear random and platform-dependent.\n\nThe solution requires implementing **complete request reading logic** that continues reading until a full HTTP request has been received, rather than assuming a single read operation will capture the entire request. This involves detecting the end of HTTP headers (the empty line containing only CRLF) and reading any message body based on the Content-Length header.\n\nThe `read_complete_request()` function addresses this pitfall by encapsulating the multi-read logic needed for reliable HTTP request reception. This function continues reading data until it has assembled a complete request or encounters a genuine error condition.\n\n⚠️ **Pitfall: File Descriptor Leaks**\n\nEvery successful `accept()` call creates a new **file descriptor** representing the client connection. These file descriptors must be explicitly closed when connection processing completes, or they accumulate over time until the server exhausts its file descriptor limit and can no longer accept connections.\n\nFile descriptor leaks often go unnoticed during short-term testing but become apparent during longer test runs or load testing. The server appears to work correctly initially, then suddenly starts rejecting all new connections with \"Too many open files\" errors. This failure mode can be particularly confusing because existing connections continue working normally.\n\nThe solution requires systematic **resource cleanup** at every exit point from connection processing code. This includes normal completion paths, error conditions, and exception scenarios. Using `ConnectionContext` structures with explicit cleanup functions helps ensure that connection-related resources are properly released.\n\nPrevention involves establishing clear **resource ownership patterns** where each component that acquires resources takes responsibility for releasing them. The TCP server component owns the server socket and is responsible for closing it during shutdown. Connection processing components own client file descriptors and must close them when processing completes.\n\n⚠️ **Pitfall: Signal Handling Interference**\n\nUnix signal handling can interfere with **blocking system calls** like `accept()`, causing them to return with `EINTR` errors when signals are delivered. This creates intermittent connection acceptance failures that appear random and platform-dependent.\n\nThe symptom manifests as occasional accept failures during normal operation, particularly when debugging tools or system monitoring generates signals. The server might work perfectly during casual testing but fail intermittently under production-like monitoring conditions.\n\nThe fix involves checking for `EINTR` return codes from `accept()` and retrying the operation rather than treating it as a genuine error condition. This **restart logic** should be applied consistently to all blocking system calls that can be interrupted by signals.\n\nMore sophisticated signal handling involves masking signals during critical operations or using dedicated signal handling threads, but these approaches add complexity that may not be justified for educational implementations.\n\n⚠️ **Pitfall: Binding to Privileged Ports**\n\nPort numbers below 1024 are considered **privileged ports** that require root permissions for binding on Unix systems. Attempting to bind to port 80 (standard HTTP) or 443 (HTTPS) will fail with permission errors unless the server runs with elevated privileges.\n\nThis pitfall often surprises developers who test their server on port 8080 successfully but encounter permission errors when attempting to deploy on standard HTTP ports. The error messages vary across operating systems but typically involve \"Permission denied\" or \"Operation not permitted\" responses.\n\nThe solution for educational purposes involves using **unprivileged ports** (above 1024) like 8080 or 3000 for development and testing. Production deployment can use port forwarding, reverse proxies, or container networking to map standard ports to unprivileged ports where the server actually listens.\n\nAdvanced deployment scenarios might involve **privilege dropping** where the server starts with root permissions to bind privileged ports, then drops to a non-privileged user for request processing. This approach requires careful sequencing of privilege changes and resource allocation.\n\n⚠️ **Pitfall: Address Already in Use Errors**\n\nWhen a server shuts down, the operating system maintains the socket in a **TIME_WAIT state** for several minutes to handle any delayed packets from recently closed connections. Attempting to restart the server during this period fails with \"Address already in use\" errors that prevent binding to the same port.\n\nThis behavior is particularly frustrating during development when rapid restart cycles are common for testing changes. The server appears to work correctly but becomes inaccessible for several minutes after each shutdown, significantly slowing development iteration.\n\nThe `SO_REUSEADDR` socket option allows immediate port reuse by instructing the operating system to bypass the TIME_WAIT restriction. This option must be set before binding the socket to be effective. Setting it after binding has no effect on the current connection.\n\nCare must be taken when using `SO_REUSEADDR` in production environments, as it can allow multiple processes to bind to the same port simultaneously in some configurations, creating unpredictable connection routing behavior.\n\n### Implementation Guidance\n\nThe TCP server component provides the networking foundation that all other components build upon. Understanding the socket programming patterns demonstrated here will prove essential when implementing concurrent connection handling in later milestones.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Socket Creation | Standard BSD sockets with basic error checking | BSD sockets with comprehensive option tuning |\n| Address Configuration | Hard-coded INADDR_ANY with configurable port | Full address parsing with IPv4/IPv6 detection |\n| Error Handling | Printf logging with perror for system errors | Structured logging with error code classification |\n| Resource Management | Manual cleanup with explicit function calls | RAII-style cleanup with automatic resource tracking |\n\n#### Recommended File Structure\n\nThe TCP server implementation should be organized to separate socket management logic from higher-level server coordination:\n\n```\nproject-root/\n├── src/\n│   ├── main.c                    ← server entry point and main loop\n│   ├── tcp_server.c              ← TCP server component implementation\n│   ├── tcp_server.h              ← TCP server interface definitions\n│   ├── server_config.c           ← configuration management\n│   └── common.h                  ← shared constants and types\n├── include/\n│   ├── http_types.h              ← HTTP data structure definitions\n│   └── network_utils.h           ← networking utility functions\n└── tests/\n    ├── tcp_server_test.c         ← unit tests for TCP functionality\n    └── integration_test.c        ← end-to-end connection testing\n```\n\n#### Infrastructure Starter Code\n\nHere's the complete TCP server foundation that handles socket creation, binding, and basic connection management:\n\n```c\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define DEFAULT_PORT 8080\n#define MAX_PATH_LENGTH 1024\n#define MAX_HEADERS 32\n#define MAX_REQUEST_SIZE 8192\n#define CONNECTION_BACKLOG 128\n\n// Complete ServerConfig structure with all fields initialized\ntypedef struct {\n    int port;\n    char document_root[MAX_PATH_LENGTH];\n    int max_threads;\n    int max_connections;\n    int request_timeout_sec;\n} ServerConfig;\n\n// Complete ConnectionContext for tracking client state\ntypedef struct {\n    int client_fd;\n    struct sockaddr_in client_addr;\n    time_t connect_time;\n    pthread_t thread_id;\n} ConnectionContext;\n\n// Initialize server configuration with safe defaults\nvoid init_server_config(ServerConfig* config) {\n    memset(config, 0, sizeof(ServerConfig));\n    config->port = DEFAULT_PORT;\n    strncpy(config->document_root, \"./public\", MAX_PATH_LENGTH - 1);\n    config->max_threads = 50;\n    config->max_connections = 100;\n    config->request_timeout_sec = 30;\n}\n\n// Initialize connection context with client information\nvoid init_connection_context(ConnectionContext* context, int client_fd, struct sockaddr_in addr) {\n    memset(context, 0, sizeof(ConnectionContext));\n    context->client_fd = client_fd;\n    context->client_addr = addr;\n    context->connect_time = time(NULL);\n    context->thread_id = 0;  // Will be set when assigned to thread\n}\n\n// Complete socket creation and configuration\nint create_server_socket(int port) {\n    int server_fd;\n    struct sockaddr_in server_addr;\n    int reuse_opt = 1;\n    \n    // Create TCP socket\n    server_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_fd < 0) {\n        perror(\"Failed to create server socket\");\n        return -1;\n    }\n    \n    // Set SO_REUSEADDR to allow rapid server restart\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &reuse_opt, sizeof(reuse_opt)) < 0) {\n        perror(\"Failed to set SO_REUSEADDR\");\n        close(server_fd);\n        return -1;\n    }\n    \n    // Configure server address structure\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = INADDR_ANY;  // Accept on all interfaces\n    server_addr.sin_port = htons(port);        // Convert to network byte order\n    \n    // Bind socket to address\n    if (bind(server_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        perror(\"Failed to bind server socket\");\n        close(server_fd);\n        return -1;\n    }\n    \n    // Begin listening for connections\n    if (listen(server_fd, CONNECTION_BACKLOG) < 0) {\n        perror(\"Failed to listen on server socket\");\n        close(server_fd);\n        return -1;\n    }\n    \n    printf(\"Server listening on port %d\\n\", port);\n    return server_fd;\n}\n\n// Accept single client connection with full error handling\nint accept_client_connection(int server_fd, ConnectionContext* context) {\n    struct sockaddr_in client_addr;\n    socklen_t addr_len = sizeof(client_addr);\n    int client_fd;\n    \n    // Accept incoming connection\n    client_fd = accept(server_fd, (struct sockaddr*)&client_addr, &addr_len);\n    if (client_fd < 0) {\n        if (errno == EINTR) {\n            // Signal interruption - retry accept\n            return 0;  // Indicate retry needed\n        }\n        perror(\"Failed to accept client connection\");\n        return -1;\n    }\n    \n    // Initialize connection context\n    init_connection_context(context, client_fd, client_addr);\n    \n    // Log client connection for debugging\n    printf(\"Accepted connection from %s:%d (fd=%d)\\n\",\n           inet_ntoa(client_addr.sin_addr),\n           ntohs(client_addr.sin_port),\n           client_fd);\n    \n    return client_fd;\n}\n\n// Properly close client connection and cleanup resources\nvoid close_client_connection(ConnectionContext* context) {\n    if (context->client_fd > 0) {\n        printf(\"Closing connection fd=%d\\n\", context->client_fd);\n        close(context->client_fd);\n        context->client_fd = -1;\n    }\n}\n```\n\n#### Core Logic Skeleton Code\n\nThe main server loop represents the core logic that students should implement themselves. This skeleton provides the structure while requiring students to understand the connection handling flow:\n\n```c\n// Main server loop - students implement the connection handling logic\nvoid server_main_loop(int server_fd) {\n    ConnectionContext context;\n    char request_buffer[MAX_REQUEST_SIZE];\n    \n    printf(\"Server entering main loop, waiting for connections...\\n\");\n    \n    while (1) {  // Infinite loop until shutdown signal\n        // TODO 1: Accept incoming client connection using accept_client_connection()\n        // Hint: Handle EINTR return by continuing the loop\n        // Hint: Log connection details for debugging\n        \n        // TODO 2: Read complete HTTP request from client socket\n        // Hint: Use read_complete_request() to handle partial reads\n        // Hint: Check for read errors and connection closure\n        \n        // TODO 3: Send hardcoded HTTP response for Milestone 1\n        // Hint: Start with \"HTTP/1.1 200 OK\\r\\nContent-Length: 13\\r\\n\\r\\nHello World!\\n\"\n        // Hint: Use write() or send() to transmit response\n        \n        // TODO 4: Clean up connection resources\n        // Hint: Always close client file descriptor\n        // Hint: Log connection closure for debugging\n        \n        // TODO 5: Check for server shutdown signals\n        // Hint: Can use global variable set by signal handler\n        // Hint: Break from loop to allow graceful shutdown\n    }\n    \n    printf(\"Server main loop exiting\\n\");\n}\n\n// Complete request reading handling partial reads - students implement the read loop\nssize_t read_complete_request(int sockfd, char* buffer, size_t max_size) {\n    // TODO 1: Initialize read tracking variables\n    // Hint: Track total bytes read and current buffer position\n    \n    // TODO 2: Read data in loop until complete request received\n    // Hint: HTTP request ends with \\r\\n\\r\\n (empty line after headers)\n    // Hint: Handle partial reads by continuing to read more data\n    \n    // TODO 3: Handle read errors and connection closure\n    // Hint: read() returns 0 when client closes connection\n    // Hint: read() returns -1 on errors, check errno for details\n    \n    // TODO 4: Validate request doesn't exceed buffer size\n    // Hint: Prevent buffer overflow by checking max_size\n    // Hint: Return error if request too large for buffer\n    \n    // TODO 5: Null-terminate buffer and return total bytes read\n    // Hint: Ensure buffer is valid C string for parsing\n    // Hint: Return total bytes read on success, -1 on error\n    \n    return -1;  // Students replace with actual implementation\n}\n\n// Main function with server initialization and cleanup\nint main(int argc, char* argv[]) {\n    ServerConfig config;\n    int server_fd;\n    \n    // TODO 1: Initialize server configuration\n    // Hint: Use init_server_config() and handle command-line port override\n    \n    // TODO 2: Create and configure server socket\n    // Hint: Use create_server_socket() and check for errors\n    \n    // TODO 3: Enter main connection handling loop\n    // Hint: Use server_main_loop() - this runs until shutdown\n    \n    // TODO 4: Cleanup server resources on shutdown\n    // Hint: Close server file descriptor\n    // Hint: Log clean shutdown for debugging\n    \n    return 0;\n}\n```\n\n#### Language-Specific Hints\n\nC socket programming requires attention to several platform-specific details and common conventions:\n\n- **Include Headers**: Use `#include <sys/socket.h>`, `#include <netinet/in.h>`, and `#include <arpa/inet.h>` for socket functions. These headers are standard on Unix-like systems but may require additional setup on Windows.\n\n- **Error Checking**: Always check return values from socket functions. Use `perror()` to print meaningful error messages that include the system's description of what went wrong. Socket functions typically return -1 on error and set `errno` to indicate the specific problem.\n\n- **Byte Order**: Use `htons()` for port numbers and `htonl()` for IP addresses when populating socket address structures. These functions convert from host byte order to network byte order automatically, handling platform differences transparently.\n\n- **Address Structures**: Initialize `sockaddr_in` structures with `memset()` before setting individual fields. This ensures that padding bytes are zeroed, preventing subtle bugs from uninitialized memory affecting socket operations.\n\n- **File Descriptor Management**: Treat file descriptors as precious resources that must be explicitly managed. Use consistent patterns for checking validity (fd > 0), closing resources (always check close() return value), and setting invalid markers (fd = -1 after close).\n\n- **Signal Safety**: Be aware that signal delivery can interrupt socket system calls. Production code often blocks signals during critical operations or handles `EINTR` returns consistently across all blocking calls.\n\n#### Milestone Checkpoint\n\nAfter implementing the TCP server component, verify correct operation through systematic testing:\n\n**Basic Functionality Test**: Start your server and verify it accepts connections properly:\n```bash\n# Terminal 1: Start your server\n./http_server\n\n# Terminal 2: Connect with telnet to verify TCP connection works\ntelnet localhost 8080\n# You should see \"Connected to localhost\"\n# Type anything and press Enter - server should respond with hardcoded HTTP response\n# Connection should close automatically after response\n```\n\n**Expected Output**: The server should print connection acceptance messages including client IP address and file descriptor numbers. The telnet client should receive your hardcoded HTTP response and the connection should close cleanly.\n\n**Multiple Connection Test**: Verify the server accepts multiple sequential connections:\n```bash\n# Run several telnet connections in succession\nfor i in {1..5}; do\n  echo \"Test request $i\" | telnet localhost 8080\ndone\n```\n\n**Expected Behavior**: Each connection should be accepted, receive a response, and close properly. File descriptor numbers should increment for each connection. No \"Address already in use\" errors should occur.\n\n**Error Condition Testing**: Verify proper error handling by testing edge cases:\n- Start server on port already in use (should fail gracefully with clear error message)\n- Connect with telnet but send no data (should timeout appropriately)\n- Kill server with Ctrl+C and restart immediately (should work due to SO_REUSEADDR)\n\n**Signs of Problems**: \n- \"Address already in use\" errors on restart indicate missing `SO_REUSEADDR` configuration\n- Connections timing out indicate problems with the accept loop or response sending\n- Increasing file descriptor numbers without corresponding closes indicate file descriptor leaks\n- Server crashes or hangs indicate unhandled error conditions in the main loop\n\n**Debugging Steps**: If tests fail, check these common issues:\n1. Verify socket creation returns valid file descriptor (not -1)\n2. Confirm `htons()` is used for port number conversion\n3. Check that server socket is properly closed on shutdown\n4. Verify client file descriptors are closed after each connection\n5. Confirm error checking covers all system calls with appropriate perror() messages\n\n\n## HTTP Parser Component\n\n> **Milestone(s):** Milestone 2 (HTTP Request Parsing) - transforms raw TCP data into structured HTTP message representations that enable proper request processing and response generation\n\n### HTTP Parsing Mental Model: Mail Sorting Analogy\n\nThink of HTTP parsing like working at a post office mail sorting facility. When mail trucks arrive at the facility, they dump large bags of unsorted mail onto conveyor belts. Your job as a mail sorter is to examine each piece of mail, read the addresses, validate the format, and sort everything into the correct bins for delivery.\n\nHTTP parsing works exactly the same way. The TCP server component delivers raw bytes from the network - like those unsorted mail bags. The HTTP parser acts as the mail sorter, examining the incoming byte stream character by character. Just as mail has a specific format (recipient address, return address, postal codes in specific positions), HTTP messages follow the RFC 7230 specification with request lines, headers, and optional message bodies in precise positions.\n\nA mail sorter must handle various challenges: damaged envelopes (malformed requests), missing addresses (invalid HTTP syntax), packages too large for standard processing (requests exceeding size limits), and different mail formats from various countries (different line ending conventions). Similarly, the HTTP parser must gracefully handle malformed input, missing required fields, oversized requests, and protocol variations while maintaining strict adherence to standards.\n\nThe sorting process is methodical and stateful. A mail sorter doesn't randomly grab pieces - they process items in order, moving through distinct phases: examining the envelope format, reading the destination address, checking for proper postage, then routing to the appropriate bin. HTTP parsing follows the same methodical approach: first parsing the request line (method, path, version), then processing headers one by one, and finally handling any message body content.\n\nJust as a mail facility has quality control processes to catch problems early and prevent delivery errors, HTTP parsers implement strict validation at each step. A single malformed address doesn't shut down the entire facility - it gets flagged for special handling. Similarly, one bad HTTP request shouldn't crash the server; it should generate an appropriate error response and continue processing other requests.\n\n### Parser Interface\n\nThe HTTP parser component exposes a clean, focused API that transforms raw network data into structured `HTTPRequest` objects. The interface design prioritizes safety, clarity, and error handling while maintaining the stateless nature that enables concurrent request processing.\n\nThe parser operates through a primary parsing function that accepts raw request data and produces either a valid `HTTPRequest` structure or a specific error condition. This design choice eliminates the complexity of streaming parsers while providing sufficient functionality for the educational goals of this project.\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `parse_http_request` | `const char* raw_data`, `size_t data_length`, `HTTPRequest* request` | `int` (status code) | Parses complete HTTP request from raw bytes into structured request object |\n| `parse_request_line` | `const char* line`, `HTTPRequest* request` | `int` (status code) | Extracts method, path, and version from HTTP request line |\n| `parse_header_line` | `const char* line`, `HTTPRequest* request` | `int` (status code) | Parses single header line and adds to request header collection |\n| `parse_message_body` | `const char* body_start`, `size_t content_length`, `HTTPRequest* request` | `int` (status code) | Processes message body content based on Content-Length header |\n| `validate_request_format` | `const HTTPRequest* request` | `int` (status code) | Validates parsed request meets HTTP/1.1 requirements |\n| `find_header_value` | `const HTTPRequest* request`, `const char* header_name` | `const char*` | Retrieves header value by name (case-insensitive search) |\n\nThe parser interface follows a consistent error handling pattern where return values indicate parsing status. Success returns zero, while positive integers represent specific HTTP error conditions that should be returned to the client (400 Bad Request, 414 URI Too Long, etc.). This approach enables the calling code to automatically generate appropriate HTTP error responses without complex error message parsing.\n\n**Parser State and Memory Management**\n\nThe parser maintains no internal state between calls, making it inherently thread-safe and suitable for concurrent request processing. Each invocation operates on caller-provided buffers and data structures, eliminating hidden dependencies and resource cleanup complexity.\n\nMemory management follows a clear ownership model. The caller provides the destination `HTTPRequest` structure and retains ownership of all memory. The parser populates fields within the provided structure but does not allocate dynamic memory for basic request processing. For requests with message bodies, the parser sets pointer fields to reference existing buffer locations rather than creating copies.\n\n| Memory Responsibility | Parser Role | Caller Role |\n|----------------------|-------------|-------------|\n| Input buffer management | Read-only access to raw request data | Allocate sufficient buffer, ensure null termination |\n| HTTPRequest structure | Populate fields within provided structure | Allocate structure, call cleanup when finished |\n| Header storage | Copy header names and values to fixed arrays | Provide MAX_HEADERS array space in structure |\n| Message body handling | Set pointer to body location in input buffer | Ensure buffer remains valid during request processing |\n| String null termination | Ensure all string fields are properly terminated | Validate string lengths before use |\n\n**Content-Length and Body Processing**\n\nThe parser implements careful Content-Length processing to handle requests with message bodies safely. When a Content-Length header is present, the parser validates that sufficient data exists in the input buffer before setting the body pointer. This prevents buffer overruns while enabling efficient zero-copy body access.\n\nFor requests without Content-Length headers, the parser assumes no message body exists, which is appropriate for GET requests and compliant with HTTP/1.1 specifications. The parser does not attempt to implement Transfer-Encoding chunked processing, as this falls outside the scope of a basic static file server.\n\n### HTTP Parsing Algorithm: State Machine for Processing HTTP Message Format\n\nThe HTTP parser operates as a finite state machine that processes the incoming request character by character, transitioning through distinct states based on the HTTP message format. This approach provides precise control over parsing while enabling clear error detection and recovery.\n\n![HTTP Parser State Machine](./diagrams/http-parser-state-machine.svg)\n\nThe state machine recognizes that HTTP messages have a rigid structure defined by RFC 7230: a request line, zero or more header lines, a blank line separator, and an optional message body. Each component has specific format requirements that must be validated during parsing.\n\n**State Machine Implementation**\n\n| Current State | Input Event | Next State | Action Taken |\n|---------------|-------------|------------|--------------|\n| PARSER_START | Any character | READING_REQUEST_LINE | Begin accumulating request line characters |\n| READING_REQUEST_LINE | Printable character | READING_REQUEST_LINE | Append character to request line buffer |\n| READING_REQUEST_LINE | CRLF or LF | PARSING_REQUEST_LINE | Process complete request line, extract method/path/version |\n| PARSING_REQUEST_LINE | Processing success | READING_HEADERS | Prepare to process header lines |\n| PARSING_REQUEST_LINE | Processing failure | PARSER_ERROR | Set error code for malformed request line |\n| READING_HEADERS | Printable character | READING_HEADER_LINE | Begin accumulating current header line |\n| READING_HEADER_LINE | Printable character | READING_HEADER_LINE | Append character to header line buffer |\n| READING_HEADER_LINE | CRLF or LF | PARSING_HEADER_LINE | Process complete header line |\n| PARSING_HEADER_LINE | Valid header format | READING_HEADERS | Add header to request, continue header processing |\n| PARSING_HEADER_LINE | Invalid header format | PARSER_ERROR | Set error code for malformed header |\n| READING_HEADERS | CRLF or LF (empty line) | CHECKING_BODY | Headers complete, determine if body expected |\n| CHECKING_BODY | Content-Length > 0 | READING_BODY | Prepare to read specified number of body bytes |\n| CHECKING_BODY | No Content-Length | PARSER_COMPLETE | Request parsing complete (no body) |\n| READING_BODY | Sufficient bytes available | PARSER_COMPLETE | Set body pointer, parsing complete |\n| READING_BODY | Insufficient bytes | PARSER_ERROR | Set error code for incomplete body |\n\n**Parsing Algorithm Implementation**\n\nThe concrete parsing algorithm follows these numbered steps to process HTTP requests systematically:\n\n1. **Initialize parser state** by setting the state machine to PARSER_START and clearing all temporary buffers. Validate that the input buffer contains at least a minimal HTTP request (method + space + path + space + version + CRLF).\n\n2. **Locate request line boundary** by scanning from the beginning of the input buffer to find the first CRLF or LF sequence. This marks the end of the request line and enables safe string processing of the line content.\n\n3. **Extract method field** by finding the first space character in the request line. Copy all characters from the line start to the space into the request method field, ensuring null termination and length validation against the method buffer size.\n\n4. **Extract path field** by finding the second space character in the request line. Copy characters between the first and second spaces into the request path field, performing length validation and URL decoding if necessary.\n\n5. **Extract version field** by copying remaining characters from the second space to the line end into the request version field. Validate that the version matches expected formats like \"HTTP/1.1\" or \"HTTP/1.0\".\n\n6. **Process header lines sequentially** by advancing past the request line and examining each subsequent line until encountering an empty line (CRLF CRLF or LF LF). For each header line, locate the colon separator and extract header name and value.\n\n7. **Validate header format** by ensuring each header line contains exactly one colon character, has a non-empty header name, and follows HTTP header naming conventions. Trim whitespace from header values while preserving significant spaces.\n\n8. **Store headers in request structure** by copying header names and values into the request headers array. Implement bounds checking to prevent buffer overflow when the number of headers exceeds MAX_HEADERS.\n\n9. **Determine message body presence** by examining the Content-Length header value. If Content-Length exists and is greater than zero, prepare to read the specified number of bytes as the message body.\n\n10. **Process message body data** by setting the body pointer to reference the appropriate location in the input buffer and updating the body_length field. Validate that sufficient bytes remain in the buffer to satisfy the Content-Length requirement.\n\n**Error Detection and Recovery**\n\nThe parsing algorithm implements comprehensive error detection at each stage to catch malformed requests early and provide meaningful error responses. Rather than failing silently or crashing, the parser generates specific HTTP error codes that can be returned to the client.\n\n| Error Condition | Detection Method | HTTP Status Code | Recovery Action |\n|-----------------|------------------|------------------|-----------------|\n| Missing request line | No CRLF found in first 8192 bytes | 400 Bad Request | Reject request, close connection |\n| Invalid method | Method not in allowed set or contains invalid characters | 405 Method Not Allowed | Return error response |\n| Malformed URL path | Path contains null bytes or exceeds maximum length | 400 Bad Request | Return error response |\n| Unsupported HTTP version | Version not \"HTTP/1.0\" or \"HTTP/1.1\" | 505 HTTP Version Not Supported | Return error response |\n| Missing header colon | Header line does not contain colon separator | 400 Bad Request | Return error response |\n| Too many headers | Header count exceeds MAX_HEADERS | 431 Request Header Fields Too Large | Return error response |\n| Invalid Content-Length | Content-Length not a valid positive integer | 400 Bad Request | Return error response |\n| Incomplete message body | Available data less than Content-Length | 400 Bad Request | Return error response |\n\n### Architecture Decision Records\n\n**Decision: Synchronous Single-Pass Parsing**\n- **Context**: HTTP parsing can be implemented using streaming parsers that process data incrementally, or single-pass parsers that require complete request data. Streaming parsers handle partial data arrival but add state management complexity.\n- **Options Considered**: \n  - Streaming parser with internal state buffers\n  - Single-pass parser requiring complete request data\n  - Hybrid approach with optional streaming support\n- **Decision**: Implement single-pass parser requiring complete request data\n- **Rationale**: The TCP server component already handles partial reads and assembles complete requests before calling the parser. Single-pass parsing eliminates state management complexity, improves testability, and provides better performance for small-to-medium requests typical in educational scenarios.\n- **Consequences**: Simpler implementation and testing, but requires complete request buffering. Maximum request size becomes a hard limit rather than a soft constraint.\n\n| Option | Pros | Cons |\n|--------|------|------|\n| Streaming parser | Handles very large requests, lower memory usage | Complex state management, harder to test |\n| Single-pass parser | Simple implementation, stateless, fast for small requests | Requires complete buffering, memory usage scales with request size |\n| Hybrid approach | Flexibility for different use cases | Implementation complexity, unclear API boundaries |\n\n> **Key Design Insight**: Educational HTTP servers benefit more from implementation clarity than handling edge cases like extremely large uploads that rarely occur in static file serving scenarios.\n\n**Decision: Fixed-Size Header Storage**\n- **Context**: HTTP headers can be stored in dynamically allocated structures that grow as needed, or in fixed-size arrays with compile-time limits. Dynamic allocation provides unlimited scalability but complicates memory management.\n- **Options Considered**:\n  - Dynamic header allocation with linked lists or resizable arrays\n  - Fixed-size header arrays with MAX_HEADERS limit\n  - Hybrid with small fixed buffer and dynamic overflow\n- **Decision**: Use fixed-size header arrays with MAX_HEADERS set to 32\n- **Rationale**: Static file servers typically receive simple requests with 5-10 headers. A limit of 32 headers provides generous headroom while avoiding dynamic memory management complexity. Fixed-size allocation enables stack-based request structures and eliminates memory leaks.\n- **Consequences**: Memory usage is predictable and bounded, implementation remains simple, but requests with excessive headers will be rejected. This aligns with defensive programming practices for server security.\n\n**Decision: Case-Insensitive Header Matching**\n- **Context**: HTTP header names are case-insensitive per RFC 7230, but header values are case-sensitive. The parser must decide how to store and match header names while preserving original case for debugging.\n- **Options Considered**:\n  - Store headers in original case, implement case-insensitive matching functions\n  - Normalize all header names to lowercase during parsing\n  - Store both original and normalized versions\n- **Decision**: Store headers in original case with case-insensitive matching functions\n- **Rationale**: Preserving original case aids debugging and maintains fidelity to the original request. Case-insensitive matching functions are straightforward to implement and perform adequately for the small number of headers in typical requests.\n- **Consequences**: Header storage uses original case which helps with debugging, but header lookup requires case-insensitive string comparison. Performance impact is negligible for educational use cases.\n\n**Decision: Strict HTTP/1.1 Compliance**\n- **Context**: HTTP parsing can be lenient (accepting common deviations from standards) or strict (rejecting any non-compliant input). Lenient parsing improves compatibility but may accept invalid requests.\n- **Options Considered**:\n  - Lenient parsing that accepts common browser variations\n  - Strict parsing that follows RFC 7230 exactly\n  - Configurable strictness level\n- **Decision**: Implement strict parsing that follows RFC 7230 requirements\n- **Rationale**: Educational servers should demonstrate proper protocol implementation. Strict parsing helps students understand HTTP requirements and catches implementation errors in client code. Production servers can be more lenient, but learning servers should prioritize correctness.\n- **Consequences**: Some non-compliant clients may be rejected, but this reinforces proper HTTP protocol understanding. Error messages help developers identify and fix client implementation issues.\n\n### Common HTTP Parsing Pitfalls\n\n⚠️ **Pitfall: Line Ending Confusion**\nHTTP/1.1 specifies CRLF (\\\\r\\\\n) as the line terminator, but many clients send LF (\\\\n) only, especially during development testing. Parsers that only recognize CRLF will fail to parse requests from curl, telnet, or custom test clients. The parser must accept both CRLF and LF line endings while maintaining strict protocol compliance for production use. Implement line ending detection by checking for \\\\r\\\\n first, then falling back to \\\\n if not found. This approach maintains compatibility without compromising standards compliance.\n\n⚠️ **Pitfall: Header Value Whitespace Handling**\nRFC 7230 permits optional whitespace around header values (e.g., \"Content-Length: 1234\" vs \"Content-Length:1234\"), but naive parsing may include leading/trailing spaces in header values. This causes string comparison failures when looking for specific header values or parsing numeric headers like Content-Length. Always trim leading and trailing whitespace from header values during parsing, but preserve internal whitespace which may be significant. Use a trimming function that removes spaces and tabs but stops at other whitespace characters.\n\n⚠️ **Pitfall: Buffer Overflow on Long Request Lines**\nHTTP requests can contain extremely long URLs or header values that exceed fixed buffer sizes. Parsing without length checking can cause buffer overflows, memory corruption, and security vulnerabilities. Each parsing step must validate input length against available buffer space before copying data. Implement bounds checking by tracking remaining buffer space and comparing against input length before each copy operation. Return HTTP 414 URI Too Long or HTTP 431 Request Header Fields Too Large for oversized components.\n\n⚠️ **Pitfall: Incomplete Content-Length Processing**\nWhen Content-Length header is present, the parser must verify that sufficient data exists in the input buffer before setting the body pointer. Failure to validate available data length can cause the body pointer to reference memory beyond the buffer end, leading to crashes when the file handler attempts to read body content. Always compare Content-Length value against remaining buffer length after header parsing completes. Return HTTP 400 Bad Request if insufficient body data is available.\n\n⚠️ **Pitfall: Method Case Sensitivity Issues**\nHTTP methods like GET, POST, PUT are case-sensitive per RFC 7230, but some parsers incorrectly accept lowercase variants like \"get\" or \"post\". This creates compatibility issues with strict servers and reinforces incorrect HTTP understanding. Validate that method names match exact case requirements and reject requests with incorrect casing. Provide clear error messages that specify the expected case format to help developers correct client implementations.\n\n⚠️ **Pitfall: Missing Null Termination**\nWhen copying strings from the input buffer into request structure fields, failure to null-terminate the copied strings can cause string functions to read beyond buffer boundaries. This occurs frequently when using functions like `strncpy` that don't guarantee null termination. Always ensure copied strings are null-terminated by either using `snprintf` for copying or manually adding null terminators after `strncpy`. Reserve one byte in each string field for the null terminator.\n\n⚠️ **Pitfall: Header Name Duplicate Handling**\nHTTP allows multiple headers with the same name (like multiple Cookie headers), but simple parsers may overwrite earlier values when encountering duplicates. This loses important request information and can break applications that depend on multiple header values. Implement duplicate header handling by either concatenating values with comma separation (per RFC 7230) or storing only the first occurrence with a warning. Document the chosen behavior clearly for API users.\n\n⚠️ **Pitfall: Integer Overflow in Content-Length**\nContent-Length header values are parsed as integers, but extremely large values can cause integer overflow in languages with fixed-size integer types. This can result in negative content lengths or wrap-around to small positive values, bypassing security checks. Validate Content-Length values against reasonable maximum sizes before parsing to integer form. Use appropriate integer types that can handle expected maximum request sizes, and reject requests with Content-Length values exceeding implementation limits.\n\n### Implementation Guidance\n\n**A. Technology Recommendations Table:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| String Processing | Standard C string functions (strchr, strncpy, strcmp) | Custom parsing with explicit bounds checking |\n| Memory Management | Stack-allocated request structures | Memory pools for zero-allocation parsing |\n| Error Handling | Integer return codes with predefined constants | Structured error types with detailed context |\n| Header Storage | Fixed arrays with linear search | Hash tables for O(1) header lookup |\n| Line Ending Detection | Check for both \\\\r\\\\n and \\\\n patterns | Configurable line ending modes |\n\n**B. Recommended File/Module Structure:**\n\n```\nproject-root/\n  src/\n    http_parser.h              ← parser interface declarations\n    http_parser.c              ← main parsing implementation\n    http_parser_internal.h     ← internal parsing state definitions\n    http_utils.c               ← string utilities and helper functions\n  test/\n    test_http_parser.c         ← comprehensive parser test suite\n    test_requests/             ← sample HTTP request files\n      valid_get_request.txt\n      malformed_header.txt\n      missing_version.txt\n  include/\n    http_types.h               ← HTTPRequest and HTTPResponse definitions\n```\n\n**C. Infrastructure Starter Code (COMPLETE, ready to use):**\n\n```c\n// http_utils.c - String processing utilities for HTTP parsing\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n\n// Trims leading and trailing whitespace from a string in-place\nchar* trim_whitespace(char* str) {\n    char* end;\n    \n    // Trim leading space\n    while(isspace((unsigned char)*str)) str++;\n    \n    if(*str == 0) return str;  // All spaces?\n    \n    // Trim trailing space\n    end = str + strlen(str) - 1;\n    while(end > str && isspace((unsigned char)*end)) end--;\n    \n    // Write new null terminator\n    end[1] = '\\0';\n    \n    return str;\n}\n\n// Case-insensitive string comparison for header names\nint strcasecmp_http(const char* s1, const char* s2) {\n    while (*s1 && *s2) {\n        char c1 = tolower((unsigned char)*s1);\n        char c2 = tolower((unsigned char)*s2);\n        if (c1 != c2) return c1 - c2;\n        s1++;\n        s2++;\n    }\n    return tolower((unsigned char)*s1) - tolower((unsigned char)*s2);\n}\n\n// Find line ending (CRLF or LF) and return pointer to start of next line\nconst char* find_line_end(const char* start, const char* buffer_end, size_t* line_length) {\n    const char* pos = start;\n    \n    while (pos < buffer_end) {\n        if (*pos == '\\r' && pos + 1 < buffer_end && *(pos + 1) == '\\n') {\n            // Found CRLF\n            *line_length = pos - start;\n            return pos + 2;  // Skip past CRLF\n        } else if (*pos == '\\n') {\n            // Found LF only\n            *line_length = pos - start;\n            return pos + 1;  // Skip past LF\n        }\n        pos++;\n    }\n    \n    // No line ending found\n    return NULL;\n}\n\n// Safely copy string with bounds checking and null termination\nint safe_string_copy(char* dest, size_t dest_size, const char* src, size_t src_length) {\n    if (src_length >= dest_size) {\n        return -1;  // Source too large for destination\n    }\n    \n    strncpy(dest, src, src_length);\n    dest[src_length] = '\\0';\n    return 0;\n}\n```\n\n**D. Core Logic Skeleton Code (signature + TODOs only):**\n\n```c\n// http_parser.c - Main HTTP request parsing implementation\n\n#include \"http_parser.h\"\n#include \"http_utils.h\"\n#include <string.h>\n#include <stdlib.h>\n\n// Parses complete HTTP request from raw bytes into structured request object\n// Returns 0 on success, HTTP error code on failure\nint parse_http_request(const char* raw_data, size_t data_length, HTTPRequest* request) {\n    // TODO 1: Initialize request structure with safe defaults using init_http_request()\n    // TODO 2: Validate input parameters (non-null pointers, reasonable data_length)\n    // TODO 3: Find request line boundary using find_line_end() helper\n    // TODO 4: Parse request line (method, path, version) using parse_request_line()\n    // TODO 5: Parse headers line by line until empty line found\n    // TODO 6: Check for Content-Length header and process body if present\n    // TODO 7: Validate complete request format using validate_request_format()\n    // Hint: Track current position in buffer to avoid re-parsing same data\n    // Hint: Return specific HTTP error codes (400, 414, etc.) for different failures\n}\n\n// Extracts method, path, and version from HTTP request line\n// Example input: \"GET /index.html HTTP/1.1\"\nint parse_request_line(const char* line, HTTPRequest* request) {\n    // TODO 1: Find first space to separate method from path\n    // TODO 2: Copy method to request->method with bounds checking\n    // TODO 3: Find second space to separate path from version\n    // TODO 4: Copy path to request->path with bounds checking\n    // TODO 5: Copy version to request->version with bounds checking\n    // TODO 6: Validate method is non-empty and contains valid characters\n    // TODO 7: Validate path starts with '/' and doesn't contain null bytes\n    // TODO 8: Validate version matches \"HTTP/1.0\" or \"HTTP/1.1\" format\n    // Hint: Use safe_string_copy() helper to prevent buffer overflows\n    // Hint: Return 400 for malformed request line, 405 for invalid method\n}\n\n// Parses single header line and adds to request header collection\n// Example input: \"Content-Length: 1234\"\nint parse_header_line(const char* line, HTTPRequest* request) {\n    // TODO 1: Find colon separator between header name and value\n    // TODO 2: Validate header name is non-empty and contains valid characters\n    // TODO 3: Extract header name (everything before colon)\n    // TODO 4: Extract header value (everything after colon)\n    // TODO 5: Trim whitespace from header value using trim_whitespace()\n    // TODO 6: Check if header_count exceeds MAX_HEADERS limit\n    // TODO 7: Store header name and value in request->headers array\n    // TODO 8: Increment request->header_count\n    // Hint: Header names are case-insensitive but preserve original case\n    // Hint: Return 431 if too many headers, 400 for malformed header format\n}\n\n// Processes message body content based on Content-Length header\nint parse_message_body(const char* body_start, size_t available_bytes, HTTPRequest* request) {\n    // TODO 1: Look up Content-Length header using get_request_header()\n    // TODO 2: Parse Content-Length value to integer (handle parsing errors)\n    // TODO 3: Validate Content-Length is non-negative and reasonable size\n    // TODO 4: Check if available_bytes >= content_length\n    // TODO 5: Set request->body pointer to body_start location\n    // TODO 6: Set request->body_length to parsed content_length value\n    // Hint: Content-Length of 0 is valid (empty body)\n    // Hint: Return 400 for invalid Content-Length, 413 if body too large\n}\n\n// Retrieves header value by name (case-insensitive search)\nconst char* get_request_header(const HTTPRequest* request, const char* header_name) {\n    // TODO 1: Iterate through request->headers array up to header_count\n    // TODO 2: Compare each header name using strcasecmp_http() for case-insensitivity\n    // TODO 3: Return pointer to header value when match found\n    // TODO 4: Return NULL if header not found\n    // Hint: Use strcasecmp_http() helper for proper case-insensitive comparison\n}\n```\n\n**E. Language-Specific Hints:**\n\n- **String Safety**: Use `strncpy()` instead of `strcpy()` to prevent buffer overflows, but remember that `strncpy()` doesn't guarantee null termination. Always manually add null terminators or use `snprintf()` for safer string copying.\n\n- **Memory Layout**: The `HTTPRequest` structure uses fixed-size arrays to avoid dynamic allocation. This means stack allocation is safe and cleanup is automatic, but you must respect buffer boundaries.\n\n- **Header Processing**: HTTP header names are case-insensitive, so \"Content-Length\", \"content-length\", and \"CONTENT-LENGTH\" should all match. Implement case-insensitive comparison using `tolower()` character by character.\n\n- **Integer Parsing**: Use `strtol()` for parsing Content-Length values, and always check the return value and `errno` for parsing errors. Reject negative values and values exceeding reasonable limits.\n\n- **Line Ending Handling**: Real HTTP requests may use CRLF (\\\\r\\\\n) or just LF (\\\\n). Check for CRLF first, then fall back to LF to maintain broad compatibility.\n\n**F. Milestone Checkpoint:**\n\nAfter implementing the HTTP parser component, verify functionality with these tests:\n\n**Test Command:**\n```bash\ngcc -o test_parser test_http_parser.c http_parser.c http_utils.c -I../include\n./test_parser\n```\n\n**Expected Behavior:**\n- Parser correctly extracts \"GET\", \"/index.html\", \"HTTP/1.1\" from request line\n- Headers like \"Host: localhost\" are stored as separate name/value pairs\n- Case-insensitive header lookup finds \"content-length\" when searching for \"Content-Length\"\n- Malformed requests return appropriate HTTP error codes (400, 405, 414)\n- Parser handles both CRLF and LF line endings without errors\n\n**Manual Testing with Sample Request:**\nCreate a file `test_request.txt`:\n```\nGET /test.html HTTP/1.1\nHost: localhost:8080\nUser-Agent: TestClient/1.0\nContent-Length: 0\n\n```\n\nThe parser should extract method=\"GET\", path=\"/test.html\", version=\"HTTP/1.1\", and three headers. Test with your parsing function to verify correct field population.\n\n**G. Debugging Tips:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Parser crashes on valid requests | Buffer overflow in string copying | Use debugger to check buffer boundaries | Implement proper bounds checking in all string operations |\n| Headers contain extra whitespace | Not trimming header values | Print header values with quotes to see whitespace | Apply trim_whitespace() to all header values |\n| Case-sensitive header matching fails | Using strcmp instead of strcasecmp | Test with \"content-length\" vs \"Content-Length\" | Use case-insensitive comparison for header names |\n| Parser accepts malformed requests | Missing validation steps | Test with intentionally bad requests | Add validation for each parsing step |\n| Body parsing fails with Content-Length | Integer parsing or bounds checking error | Check Content-Length parsing and available buffer size | Validate Content-Length parsing and buffer bounds |\n\n\n## File Handler Component\n\n> **Milestone(s):** Milestone 3 (Static File Serving) - maps URL paths to filesystem paths and serves static content with proper security validation and MIME type detection\n\n### File Serving Mental Model: Filing Cabinet Analogy\n\nThink of the file handler component as a corporate filing cabinet system with a security guard. When someone requests a document, they don't walk directly to the filing cabinet - they submit a request to the security guard at the front desk. The security guard performs several critical checks before retrieving any document.\n\nFirst, the guard validates that the requested document exists within the authorized filing system boundaries. They check the person's access badge (similar to validating the URL path stays within the document root). The guard ensures the request isn't trying to access restricted areas like the executive filing room or the basement archives (preventing directory traversal attacks). Once security validation passes, the guard locates the correct filing cabinet, opens the appropriate drawer, and retrieves the requested document.\n\nThe guard also knows what type of document they're handing over - whether it's a text memo, a PDF report, or a spreadsheet - and attaches the appropriate handling instructions (setting the correct Content-Type header). If the document doesn't exist, the guard politely informs the requester with a standardized \"Document Not Found\" response rather than revealing internal filing system details.\n\nThis mental model captures the three essential responsibilities of the file handler: **path security validation**, **file content retrieval**, and **metadata detection**. The security guard represents the validation logic that stands between external requests and the filesystem, ensuring that only authorized access occurs within defined boundaries.\n\nThe filing cabinet system also illustrates why **path resolution** must happen in a controlled manner. Just as the security guard follows established procedures for locating documents rather than allowing requesters to wander the filing room, the file handler must resolve paths through a secure, predictable process that prevents unauthorized access to system files or confidential data outside the document root.\n\n### File Handler Interface\n\nThe file handler component exposes a clean interface that separates security validation, file operations, and response generation into distinct responsibilities. This separation allows the HTTP parser component to focus on message structure while delegating filesystem concerns to a specialized handler.\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `validate_and_resolve_path` | `document_root char*`, `request_path char*`, `resolved_path char*`, `max_path_len size_t` | `int` (0 success, -1 error) | Validates request path against directory traversal attacks and resolves to absolute filesystem path within document root boundaries |\n| `detect_mime_type` | `file_path char*`, `mime_type char*`, `max_mime_len size_t` | `int` (0 success, -1 error) | Determines MIME type based on file extension and sets Content-Type header value for HTTP response |\n| `serve_file_content` | `resolved_path char*`, `response HTTPResponse*` | `int` (0 success, -1 file not found, -2 read error) | Reads file contents into response body and sets appropriate Content-Length header |\n| `handle_directory_request` | `resolved_path char*`, `response HTTPResponse*` | `int` (0 success, -1 error) | Generates directory listing HTML when request path maps to a directory rather than a file |\n| `generate_error_response` | `status_code int`, `error_message char*`, `response HTTPResponse*` | `void` | Creates standardized HTTP error response with appropriate status code and minimal error details |\n| `check_file_permissions` | `file_path char*` | `int` (0 readable, -1 permission denied) | Verifies that the server process has read permissions for the requested file |\n\nThe interface design emphasizes **defensive programming** by requiring callers to provide pre-allocated buffers for path resolution and MIME type detection. This approach prevents memory allocation failures during request processing and ensures predictable memory usage patterns. Buffer sizes are validated through the `max_path_len` and `max_mime_len` parameters, providing protection against buffer overflow attacks.\n\nThe return codes follow a consistent pattern where zero indicates success and negative values indicate specific error conditions. This allows the HTTP parser component to translate file handler errors into appropriate HTTP status codes without requiring detailed knowledge of filesystem error semantics.\n\n**Path Validation Interface Details:**\n\nThe `validate_and_resolve_path` method performs the most security-critical operation in the entire HTTP server. It accepts a user-provided `request_path` (extracted from the HTTP request URL) and transforms it into a `resolved_path` that points to a real filesystem location. The validation process ensures that the resolved path remains within the `document_root` directory tree, preventing directory traversal attacks that could expose system files or sensitive data.\n\n| Validation Step | Purpose | Example Input | Example Output |\n|-----------------|---------|---------------|----------------|\n| URL decode | Convert percent-encoded characters | `/docs/file%20name.txt` | `/docs/file name.txt` |\n| Path normalization | Remove `.` and `..` components | `/docs/../admin/secret.txt` | `/admin/secret.txt` |\n| Root boundary check | Ensure path stays within document root | `/admin/secret.txt` with root `/var/www` | **REJECT** - outside boundary |\n| Absolute path construction | Build complete filesystem path | `/index.html` with root `/var/www` | `/var/www/index.html` |\n\n**MIME Type Detection Interface:**\n\nThe `detect_mime_type` method provides content type detection based on file extensions. While production web servers often use more sophisticated methods like magic number detection or libmagic integration, the educational implementation focuses on extension-based mapping for simplicity and predictability.\n\n| File Extension | MIME Type | Description |\n|----------------|-----------|-------------|\n| `.html`, `.htm` | `text/html` | HTML documents |\n| `.css` | `text/css` | Cascading Style Sheets |\n| `.js` | `application/javascript` | JavaScript files |\n| `.json` | `application/json` | JSON data |\n| `.txt` | `text/plain` | Plain text files |\n| `.png` | `image/png` | PNG images |\n| `.jpg`, `.jpeg` | `image/jpeg` | JPEG images |\n| `.gif` | `image/gif` | GIF images |\n| (unknown) | `application/octet-stream` | Binary data fallback |\n\n### File Serving Algorithm\n\nThe file serving algorithm implements a multi-stage process that prioritizes security validation before performing any filesystem operations. This approach ensures that malicious requests are rejected early in the process, minimizing resource consumption and potential attack vectors.\n\n**Stage 1: Request Path Validation**\n\n1. **Extract the path component** from the HTTP request URL, handling query parameters and fragment identifiers by truncating at the first `?` or `#` character\n2. **Perform URL decoding** to convert percent-encoded characters back to their original form, handling special characters like spaces (`%20`) and non-ASCII characters\n3. **Normalize the path** by resolving `.` (current directory) and `..` (parent directory) components using a stack-based algorithm that processes each path segment\n4. **Validate path boundaries** by ensuring the normalized path, when combined with the document root, produces an absolute path that remains within the document root directory tree\n5. **Check for null bytes** and other control characters that could indicate path injection attacks or malformed input data\n6. **Construct the resolved absolute path** by concatenating the document root with the validated relative path using appropriate path separator characters\n\n**Stage 2: Filesystem Verification**\n\n7. **Check file existence** using the `access()` system call or equivalent to determine if the resolved path corresponds to an actual filesystem entry\n8. **Determine entry type** by calling `stat()` to distinguish between regular files, directories, symbolic links, and other filesystem objects\n9. **Verify read permissions** to ensure the server process has appropriate access rights to read the requested file or directory contents\n10. **Handle symbolic links** by either following them (if policy allows) or treating them as regular files, depending on security configuration\n\n**Stage 3: Content Delivery**\n\n11. **For regular files**: Open the file, determine its size, detect the MIME type based on the file extension, and read the contents into the response body buffer\n12. **For directories**: Generate an HTML directory listing showing available files and subdirectories, or serve a default index file (`index.html`) if present\n13. **Set response headers** including `Content-Type`, `Content-Length`, and `Last-Modified` based on file metadata and detected content type\n14. **Handle large files** by implementing chunked reading to avoid loading entire files into memory, particularly important for binary content like images or videos\n\n> **Design Insight**: The algorithm's security-first approach means that path validation errors result in immediate rejection with a 400 Bad Request response, while filesystem errors (like permission denied or file not found) generate appropriate 4xx error responses. This distinction helps legitimate clients understand whether their request was malformed or simply requested a non-existent resource.\n\n**Error Handling Throughout the Algorithm:**\n\nAt each stage, specific error conditions require different responses and cleanup actions. Path validation errors typically indicate malicious requests and should be logged for security monitoring. Filesystem errors might represent temporary conditions (like permission changes) or legitimate requests for non-existent resources.\n\n| Error Condition | Detection Point | HTTP Status | Response Action |\n|-----------------|-----------------|-------------|-----------------|\n| Invalid URL encoding | Stage 1, Step 2 | 400 Bad Request | Log security warning, minimal error details |\n| Directory traversal attempt | Stage 1, Step 4 | 400 Bad Request | Log security alert, block request |\n| File not found | Stage 2, Step 7 | 404 Not Found | Standard not found page |\n| Permission denied | Stage 2, Step 9 | 403 Forbidden | Access denied message |\n| File read error | Stage 3, Step 11 | 500 Internal Server Error | Generic error, log details |\n\n### Architecture Decision Records\n\n> **Decision: Path Security Validation Strategy**\n> - **Context**: The file handler must prevent directory traversal attacks while allowing legitimate file access within the document root. Attackers commonly use `../` sequences to access system files outside the intended serving directory.\n> - **Options Considered**: 1) Simple string matching to reject `..` patterns, 2) Filesystem-based validation using realpath(), 3) Stack-based path normalization with boundary checking\n> - **Decision**: Implement stack-based path normalization combined with absolute path boundary validation\n> - **Rationale**: String matching is easily bypassed with encoded characters or alternate representations. Realpath() requires filesystem access and may have race conditions. Stack-based normalization handles all `..` variations while boundary checking prevents any escape from the document root.\n> - **Consequences**: Provides robust security against directory traversal attacks but requires more complex implementation than simple string matching. Performance impact is minimal since path validation occurs once per request.\n\n| Option | Security Level | Performance | Implementation Complexity | Chosen? |\n|--------|---------------|-------------|---------------------------|---------|\n| String matching | Low - easily bypassed | High | Low | No |\n| Realpath() validation | Medium - race conditions | Medium | Medium | No |\n| Stack-based normalization | High - handles all cases | High | High | **Yes** |\n\n> **Decision: MIME Type Detection Method**\n> - **Context**: HTTP responses must include accurate Content-Type headers to enable proper browser rendering and security policies. Different detection methods offer varying accuracy and performance characteristics.\n> - **Options Considered**: 1) File extension mapping, 2) Magic number detection from file contents, 3) External library integration (libmagic)\n> - **Decision**: Implement file extension mapping with a comprehensive MIME type table\n> - **Rationale**: Extension mapping provides predictable, fast results suitable for educational purposes. Magic number detection requires reading file contents and adds complexity. Library integration introduces dependencies and may be overkill for a learning project.\n> - **Consequences**: Fast, predictable MIME type detection with minimal resource usage. May incorrectly classify files with wrong extensions, but this is acceptable for educational static file serving.\n\n| Option | Accuracy | Performance | Dependencies | Complexity | Chosen? |\n|--------|----------|-------------|--------------|------------|---------|\n| Extension mapping | Medium | High | None | Low | **Yes** |\n| Magic numbers | High | Medium | None | High | No |\n| libmagic integration | Highest | Medium | External library | Medium | No |\n\n> **Decision: Large File Handling Strategy**\n> - **Context**: Static file servers must handle files of varying sizes, from small text files to large images or videos. Loading entire files into memory can cause resource exhaustion and poor performance.\n> - **Options Considered**: 1) Load complete files into memory, 2) Stream files with fixed-size chunks, 3) Memory-mapped file access\n> - **Decision**: Implement streaming with 8KB fixed-size chunks for files larger than 64KB\n> - **Rationale**: Complete memory loading causes resource exhaustion with large files. Streaming provides predictable memory usage and good performance. Memory mapping adds complexity and platform-specific code.\n> - **Consequences**: Controlled memory usage regardless of file size, but requires more complex response generation logic. Small files still load completely for optimal performance.\n\n| Option | Memory Usage | Performance | Complexity | Scalability | Chosen? |\n|--------|--------------|-------------|------------|-------------|---------|\n| Complete memory load | Unpredictable | High for small files | Low | Poor | No |\n| Fixed-size streaming | Predictable | Good for all sizes | Medium | Excellent | **Yes** |\n| Memory mapping | Low | Highest | High | Excellent | No |\n\n> **Decision: Directory Listing Generation**\n> - **Context**: When a request maps to a directory rather than a file, the server must decide how to respond. Options include serving default files, generating listings, or returning errors.\n> - **Options Considered**: 1) Always return 404 for directory requests, 2) Serve index.html if present otherwise 404, 3) Generate HTML directory listings\n> - **Decision**: Serve index.html if present, otherwise generate basic HTML directory listing\n> - **Rationale**: This matches conventional web server behavior and provides useful functionality for development and testing. Directory listings help developers verify file placement and organization.\n> - **Consequences**: Adds complexity to handle directory traversal and HTML generation, but provides valuable development functionality. Security risk is minimal since listings only show files within the document root.\n\n| Option | Developer Utility | Security Risk | Implementation Complexity | Chosen? |\n|--------|------------------|---------------|---------------------------|---------|\n| Always 404 | Low | None | Low | No |\n| Index.html only | Medium | None | Medium | No |\n| Generated listings | High | Low | High | **Yes** |\n\n### Common File Serving Pitfalls\n\n⚠️ **Pitfall: Directory Traversal Vulnerability**\n\nThe most critical security vulnerability in static file servers occurs when path validation fails to prevent directory traversal attacks. Attackers use sequences like `../` to escape the document root and access system files like `/etc/passwd` or application configuration files containing sensitive data.\n\n**Why it's dangerous**: A successful directory traversal attack can expose any file readable by the server process, including system configuration, application secrets, or user data stored outside the web root. This represents a complete compromise of server confidentiality.\n\n**Common mistakes**: Implementing path validation with simple string matching (`if (strstr(path, \"..\"))`) that can be bypassed with URL encoding (`%2e%2e%2f`), Unicode normalization attacks, or alternate path representations. Another mistake is validating the request path but not the resolved absolute path.\n\n**How to fix**: Implement comprehensive path normalization using a stack-based algorithm that processes each path component individually. After normalization, construct the absolute path and verify it begins with the document root path. Always validate the final resolved path, not intermediate representations.\n\n```c\n// WRONG - easily bypassed\nif (strstr(request_path, \"..\")) {\n    return -1; // reject\n}\n\n// CORRECT - normalize then validate final path\nchar* normalized = normalize_path_components(request_path);\nchar* absolute = combine_paths(document_root, normalized);\nif (!path_starts_with(absolute, document_root)) {\n    return -1; // reject - outside boundary\n}\n```\n\n⚠️ **Pitfall: Binary File Corruption**\n\nStatic file servers must handle both text and binary content correctly. A common mistake is treating all files as text and applying transformations like line ending conversion or character encoding changes that corrupt binary data like images, executables, or compressed files.\n\n**Why it's wrong**: Binary file corruption makes images unreadable, breaks downloadable software, and causes unpredictable application behavior. Modern web applications rely heavily on binary assets that must be delivered bit-for-bit identical to their stored versions.\n\n**Detection signs**: Images appear broken in browsers, PDF downloads are corrupted, or binary files have different checksums after serving compared to their original versions stored on disk.\n\n**How to fix**: Always read files in binary mode using appropriate flags (`\"rb\"` for fopen() or `O_BINARY` for open()). Never apply text transformations to file contents. Set appropriate Content-Type headers to help browsers handle binary content correctly.\n\n⚠️ **Pitfall: Inadequate Error Information Disclosure**\n\nFile serving errors require careful balance between helpful debugging information and security. Revealing too much information in error responses helps attackers understand the server's internal structure and identify potential attack vectors.\n\n**Why it's wrong**: Detailed error messages like \"Permission denied accessing /var/www/admin/secret.txt\" reveal internal filesystem structure and confirm the existence of potentially sensitive directories. This information helps attackers refine their attacks.\n\n**How to fix**: Generate standardized error responses that provide sufficient information for legitimate debugging without revealing internal details. Log detailed error information on the server side for administrator review while sending minimal information to clients.\n\n| Error Condition | Bad Response | Good Response |\n|-----------------|--------------|---------------|\n| File not found | \"File /var/www/docs/secret.txt not found\" | \"404 Not Found\" |\n| Permission denied | \"Permission denied: /etc/passwd\" | \"403 Forbidden\" |\n| Read error | \"I/O error reading /home/user/.ssh/id_rsa\" | \"500 Internal Server Error\" |\n\n⚠️ **Pitfall: Inefficient Large File Handling**\n\nLoading entire files into memory before sending responses causes memory exhaustion when serving large files or handling multiple concurrent requests for substantial content. This creates denial of service vulnerabilities and poor performance characteristics.\n\n**Why it's wrong**: A 100MB video file loaded completely into memory for each concurrent request quickly exhausts available RAM. Multiple simultaneous requests for large files can crash the server or trigger out-of-memory kills by the operating system.\n\n**Detection signs**: Memory usage spikes correlating with large file requests, server crashes when serving substantial content, or extremely slow response times for large files due to memory pressure and swapping.\n\n**How to fix**: Implement streaming file delivery using fixed-size buffers (typically 4-8KB). Read chunks from the file and write them directly to the network socket without accumulating the entire file in memory. This provides predictable memory usage regardless of file size.\n\n⚠️ **Pitfall: Race Conditions in File Operations**\n\nFile serving involves multiple filesystem operations (stat, open, read) that can create race conditions if files are modified, deleted, or have permissions changed between operations. This can lead to serving partially updated content or crashing due to unexpected file states.\n\n**Why it's wrong**: A file might exist during the stat() check but be deleted before open(), causing the server to crash or return confusing errors. Similarly, files being written by other processes might be served in incomplete states, delivering corrupted content to clients.\n\n**How to fix**: Use atomic file operations where possible and implement proper error handling for all filesystem calls. Consider using file locking for critical operations, though this may impact performance. Design the serving logic to gracefully handle files that become unavailable between checks.\n\n⚠️ **Pitfall: Missing Content-Length Headers**\n\nHTTP responses should include Content-Length headers to enable proper connection handling and download progress indication. Omitting this header forces chunked transfer encoding or connection closing, reducing performance and compatibility.\n\n**Why it's wrong**: Browsers cannot display download progress without Content-Length headers. HTTP/1.1 keep-alive connections may not work properly, forcing new TCP connections for each request and significantly impacting performance.\n\n**How to fix**: Always determine file size using stat() before beginning content delivery and include the Content-Length header in the HTTP response. For chunked file reading, calculate the total size upfront rather than omitting the header.\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Path manipulation | Manual string operations with bounds checking | Path normalization library (realpath, canonicalize_file_name) |\n| MIME detection | Static extension-to-type mapping table | libmagic integration for content-based detection |\n| File I/O | Standard C file operations (fopen, fread, fclose) | Memory-mapped files with mmap() for large content |\n| Directory listing | Simple opendir/readdir with manual HTML generation | Template engine for customizable directory pages |\n| Security validation | Custom path normalization with stack algorithm | chroot() jail for complete filesystem isolation |\n\n#### Recommended File Structure\n\nThe file handler component integrates into the HTTP server project as a dedicated module responsible for all filesystem operations and security validation:\n\n```\nproject-root/\n├── src/\n│   ├── server.c              ← main server loop and TCP handling\n│   ├── http_parser.c         ← HTTP request/response parsing\n│   ├── file_handler.c        ← this component - file serving logic\n│   ├── file_handler.h        ← public interface definitions\n│   └── mime_types.c          ← MIME type mapping table\n├── include/\n│   ├── http_server.h         ← shared type definitions\n│   └── file_handler.h        ← file handler interface\n├── config/\n│   ├── mime.types            ← MIME type configuration file\n│   └── server.conf           ← server configuration\n├── www/                      ← default document root\n│   ├── index.html           \n│   ├── css/\n│   └── images/\n└── tests/\n    ├── test_file_handler.c   ← unit tests for file operations\n    └── test_security.c       ← security validation tests\n```\n\nThis structure separates file handling concerns from network and HTTP parsing logic while providing a clear interface for integration with the overall server architecture.\n\n#### Infrastructure Starter Code\n\n**Complete MIME Type Detection System:**\n\n```c\n// mime_types.h\n#ifndef MIME_TYPES_H\n#define MIME_TYPES_H\n\ntypedef struct {\n    const char* extension;\n    const char* mime_type;\n} MimeTypeMapping;\n\n// Initialize MIME type system\nint init_mime_types(void);\n\n// Get MIME type by file extension\nconst char* get_mime_type(const char* file_path);\n\n// Cleanup MIME type resources\nvoid cleanup_mime_types(void);\n\n#endif\n\n// mime_types.c - Complete implementation ready to use\n#include \"mime_types.h\"\n#include <string.h>\n#include <ctype.h>\n\nstatic MimeTypeMapping mime_mappings[] = {\n    {\".html\", \"text/html\"},\n    {\".htm\", \"text/html\"},\n    {\".css\", \"text/css\"},\n    {\".js\", \"application/javascript\"},\n    {\".json\", \"application/json\"},\n    {\".txt\", \"text/plain\"},\n    {\".png\", \"image/png\"},\n    {\".jpg\", \"image/jpeg\"},\n    {\".jpeg\", \"image/jpeg\"},\n    {\".gif\", \"image/gif\"},\n    {\".svg\", \"image/svg+xml\"},\n    {\".pdf\", \"application/pdf\"},\n    {\".zip\", \"application/zip\"},\n    {NULL, NULL}  // Sentinel\n};\n\nint init_mime_types(void) {\n    // MIME system initialized with static table\n    return 0;\n}\n\nconst char* get_mime_type(const char* file_path) {\n    if (!file_path) return \"application/octet-stream\";\n    \n    // Find last dot in filename\n    const char* dot = strrchr(file_path, '.');\n    if (!dot) return \"application/octet-stream\";\n    \n    // Convert extension to lowercase for comparison\n    char ext_lower[32];\n    int i = 0;\n    while (dot[i] && i < 31) {\n        ext_lower[i] = tolower(dot[i]);\n        i++;\n    }\n    ext_lower[i] = '\\0';\n    \n    // Search mapping table\n    for (int j = 0; mime_mappings[j].extension; j++) {\n        if (strcmp(ext_lower, mime_mappings[j].extension) == 0) {\n            return mime_mappings[j].mime_type;\n        }\n    }\n    \n    return \"application/octet-stream\";\n}\n\nvoid cleanup_mime_types(void) {\n    // Static table requires no cleanup\n}\n```\n\n**Complete Path Utility Functions:**\n\n```c\n// path_utils.h\n#ifndef PATH_UTILS_H\n#define PATH_UTILS_H\n\n#include <stddef.h>\n\n// URL decode a path string in-place\nint url_decode(char* path);\n\n// Check if path contains directory traversal attempts\nint has_directory_traversal(const char* path);\n\n// Normalize path by removing . and .. components\nint normalize_path(const char* input, char* output, size_t output_size);\n\n// Check if resolved path is within document root\nint is_path_within_root(const char* document_root, const char* resolved_path);\n\n#endif\n\n// path_utils.c - Complete implementation\n#include \"path_utils.h\"\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n\nint url_decode(char* path) {\n    char* read = path;\n    char* write = path;\n    \n    while (*read) {\n        if (*read == '%' && read[1] && read[2]) {\n            // Convert hex digits to character\n            char hex[3] = {read[1], read[2], '\\0'};\n            char* endptr;\n            long value = strtol(hex, &endptr, 16);\n            if (*endptr == '\\0' && value >= 0 && value <= 255) {\n                *write = (char)value;\n                read += 3;\n            } else {\n                *write = *read;\n                read++;\n            }\n        } else if (*read == '+') {\n            *write = ' ';\n            read++;\n        } else {\n            *write = *read;\n            read++;\n        }\n        write++;\n    }\n    *write = '\\0';\n    return 0;\n}\n\nint has_directory_traversal(const char* path) {\n    // Look for .. components\n    const char* pos = path;\n    while ((pos = strstr(pos, \"..\")) != NULL) {\n        // Check if .. is a complete path component\n        int is_component = 1;\n        if (pos > path && pos[-1] != '/' && pos[-1] != '\\\\') {\n            is_component = 0;\n        }\n        if (pos[2] != '\\0' && pos[2] != '/' && pos[2] != '\\\\') {\n            is_component = 0;\n        }\n        if (is_component) {\n            return 1; // Found directory traversal\n        }\n        pos += 2;\n    }\n    return 0;\n}\n\n// Additional utility functions with complete implementations...\n```\n\n#### Core Logic Skeleton Code\n\n**Main File Handler Interface:**\n\n```c\n// file_handler.h - Core interfaces for learner implementation\n#include \"http_server.h\"\n\n// Primary file serving function - learners implement this\nint serve_static_file(const HTTPRequest* request, HTTPResponse* response, \n                     const ServerConfig* config) {\n    // TODO 1: Extract path from request URL, handling query parameters\n    // TODO 2: Validate and resolve path against document root using validate_and_resolve_path()\n    // TODO 3: Check if resolved path exists and get file stats using stat()\n    // TODO 4: Handle directory requests - look for index.html or generate listing\n    // TODO 5: For regular files, detect MIME type and set Content-Type header\n    // TODO 6: Read file contents and populate response body\n    // TODO 7: Set Content-Length header based on file size\n    // TODO 8: Handle all error cases with appropriate HTTP status codes\n    // Hint: Use the infrastructure functions for path validation and MIME detection\n}\n\n// Path security validation - learners implement core logic\nint validate_and_resolve_path(const char* document_root, const char* request_path,\n                             char* resolved_path, size_t max_path_len) {\n    // TODO 1: Create working copy of request_path for manipulation\n    // TODO 2: Perform URL decoding using url_decode() utility function\n    // TODO 3: Check for directory traversal patterns using has_directory_traversal()\n    // TODO 4: Normalize path components to resolve . and .. using normalize_path()\n    // TODO 5: Construct absolute path by combining document_root + normalized_path\n    // TODO 6: Verify final path stays within document_root boundaries\n    // TODO 7: Check for null bytes or other control characters in path\n    // TODO 8: Copy validated path to resolved_path output buffer\n    // Hint: Reject immediately if any security check fails\n}\n\n// File content reading with streaming support - learners implement\nint read_file_content(const char* file_path, HTTPResponse* response) {\n    // TODO 1: Open file in binary mode for reading\n    // TODO 2: Get file size using fstat() or stat()\n    // TODO 3: Allocate response body buffer or set up streaming\n    // TODO 4: For small files (< 64KB), read entire content into memory\n    // TODO 5: For large files, implement chunked reading with 8KB buffers\n    // TODO 6: Set response->body_length to actual bytes read\n    // TODO 7: Handle read errors and clean up file descriptor\n    // TODO 8: Return appropriate error codes for different failure modes\n    // Hint: Always close file descriptor in error cases\n}\n\n// Directory listing generation - learners implement\nint generate_directory_listing(const char* dir_path, const char* url_path,\n                              HTTPResponse* response) {\n    // TODO 1: Open directory using opendir()\n    // TODO 2: Read directory entries with readdir() in a loop\n    // TODO 3: Filter out hidden files (starting with .) if desired\n    // TODO 4: Sort entries alphabetically for consistent presentation\n    // TODO 5: Generate HTML page with proper DOCTYPE and headers\n    // TODO 6: Create table or list showing filenames, sizes, and modification times\n    // TODO 7: Make filenames clickable links with proper URL encoding\n    // TODO 8: Set Content-Type to text/html and calculate Content-Length\n    // Hint: Include parent directory link (..) except for document root\n}\n```\n\n#### Language-Specific Hints for C Implementation\n\n**File System Operations:**\n- Use `stat()` or `fstat()` to get file information including size, type, and permissions\n- Open files with `fopen(path, \"rb\")` to ensure binary mode for all file types\n- Check `errno` after failed system calls to determine specific error conditions\n- Use `access(path, R_OK)` to verify read permissions before attempting file operations\n\n**Memory Management:**\n- Always validate buffer sizes before string operations to prevent buffer overflows\n- Use `strncpy()` and `snprintf()` instead of `strcpy()` and `sprintf()` for bounds checking\n- Free allocated memory in all code paths, including error handling branches\n- Consider using stack-allocated buffers for path manipulation to avoid malloc/free overhead\n\n**Security Considerations:**\n- Validate all user input including URL paths, query parameters, and header values\n- Use `realpath()` on systems that support it for canonical path resolution\n- Be careful with signed/unsigned integer comparisons when checking buffer bounds\n- Always null-terminate strings after manipulation to prevent buffer over-reads\n\n**Performance Tips:**\n- Cache file statistics for recently accessed files to avoid repeated stat() calls\n- Use `sendfile()` on Linux or equivalent zero-copy mechanisms for large file transfers\n- Consider `mmap()` for files accessed frequently, but handle mapping failures gracefully\n- Implement proper error logging to help diagnose filesystem permission or availability issues\n\n#### Milestone Checkpoint\n\nAfter implementing the file handler component, verify the functionality with these specific tests:\n\n**Basic File Serving Test:**\n```bash\n# Start your HTTP server on port 8080\n./http_server --port 8080 --docroot ./www\n\n# Test basic file serving\ncurl -v http://localhost:8080/index.html\n# Expected: 200 OK response with HTML content and proper Content-Type header\n\n# Test CSS file serving  \ncurl -v http://localhost:8080/css/style.css\n# Expected: 200 OK with Content-Type: text/css\n\n# Test image serving\ncurl -v http://localhost:8080/images/logo.png\n# Expected: 200 OK with Content-Type: image/png and binary content\n```\n\n**Security Validation Test:**\n```bash\n# Test directory traversal prevention\ncurl -v \"http://localhost:8080/../etc/passwd\"\n# Expected: 400 Bad Request or 404 Not Found (never file contents)\n\n# Test encoded traversal attempts\ncurl -v \"http://localhost:8080/%2e%2e%2f%2e%2e%2fetc%2fpasswd\" \n# Expected: 400 Bad Request (should be caught by URL decoding + validation)\n\n# Test file not found\ncurl -v http://localhost:8080/nonexistent.html\n# Expected: 404 Not Found with standard error page\n```\n\n**Directory Handling Test:**\n```bash\n# Test directory listing\ncurl -v http://localhost:8080/images/\n# Expected: 200 OK with HTML directory listing or index.html if present\n\n# Test root directory\ncurl -v http://localhost:8080/\n# Expected: index.html content or directory listing of document root\n```\n\n**Signs of Correct Implementation:**\n- All responses include proper `Content-Type` and `Content-Length` headers\n- Binary files (images) display correctly in web browsers  \n- Directory traversal attempts are rejected with 4xx status codes\n- File not found generates 404 responses, not server errors\n- Directory requests show listings or serve index files appropriately\n\n**Signs Something is Wrong:**\n- Images appear corrupted or broken in browsers → binary file handling issue\n- Server crashes on directory traversal attempts → path validation missing\n- All files served as `text/plain` → MIME type detection not working\n- Memory usage grows continuously → file descriptor or memory leaks\n- Slow response times for large files → not implementing streaming properly\n\n![Request Processing Sequence](./diagrams/request-processing-flow.svg)\n\n![File Serving Security Flow](./diagrams/file-serving-flow.svg)\n\n\n## Concurrency Management Component\n\n> **Milestone(s):** Milestone 4 (Concurrent Connections) - handles multiple simultaneous client connections using different concurrency models to prevent blocking and enable scalable request processing\n\n### Concurrency Mental Model: Restaurant Service Models\n\nThink of an HTTP server handling concurrent connections like a restaurant serving multiple customers simultaneously. Just as restaurants have different service models to handle varying numbers of diners, HTTP servers employ different concurrency strategies to manage multiple client connections efficiently.\n\nThe **thread-per-connection model** resembles a high-end restaurant where each table gets a dedicated waiter for the entire meal. When customers arrive, the host (main server thread) seats them and assigns a personal waiter (spawns a new thread) who handles all their needs from start to finish. This provides excellent individual attention - each table gets immediate, personalized service without waiting for other tables to finish. However, this model becomes expensive with many tables since you need to hire more waiters (create more threads), and each waiter consumes resources even when just standing around waiting for the customers to decide what they want (thread overhead during I/O operations).\n\nThe **thread pool model** works like a restaurant with a fixed number of waiters who serve multiple tables. When customers arrive, the host seats them and assigns the next available waiter from the existing staff. If all waiters are busy, new customers wait in line until someone becomes free. This prevents the restaurant from hiring unlimited staff during rush hours (prevents thread exhaustion) and maintains consistent service quality. The trade-off is that some customers might wait longer during peak times, but the restaurant operates more efficiently overall.\n\nThe **event-driven model** resembles a fast-casual restaurant with a single highly efficient coordinator who manages all orders simultaneously. Instead of assigning dedicated waiters, this coordinator continuously monitors all tables - taking orders when customers are ready, delivering food when the kitchen calls out orders, and processing payments when customers signal they're done. This coordinator never stands idle waiting for one table while others need attention. This model can handle many more customers with fewer staff members, but requires the coordinator to be exceptionally organized and efficient at task-switching.\n\nEach model has distinct trade-offs in terms of resource usage, scalability, complexity, and responsiveness. The choice depends on expected load patterns, available system resources, and performance requirements - just as a restaurant's service model depends on its target clientele, budget constraints, and dining style.\n\n### Concurrency Manager Interface\n\nThe concurrency management component provides a unified interface for handling multiple simultaneous client connections regardless of the underlying concurrency model. This abstraction allows the server to switch between different concurrency strategies without changing the core HTTP processing logic.\n\nThe primary interface centers around connection dispatching, resource management, and lifecycle control. The concurrency manager accepts new client connections from the TCP server component and routes them to available processing resources according to the chosen concurrency model.\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `init_concurrency_manager` | `config: ServerConfig*, model: ConcurrencyModel` | `ConcurrencyManager*` | Initializes concurrency manager with specified model and configuration limits |\n| `start_connection_handler` | `manager: ConcurrencyManager*, client_fd: int, client_addr: sockaddr_in` | `int` | Dispatches new client connection to available handler based on concurrency model |\n| `wait_for_completion` | `manager: ConcurrencyManager*` | `void` | Blocks until all active connections complete processing (used during shutdown) |\n| `get_active_connection_count` | `manager: ConcurrencyManager*` | `int` | Returns number of currently active client connections being processed |\n| `shutdown_concurrency_manager` | `manager: ConcurrencyManager*, graceful: int` | `void` | Initiates shutdown sequence, optionally waiting for active connections to complete |\n| `cleanup_concurrency_manager` | `manager: ConcurrencyManager*` | `void` | Releases all resources including thread pools, connection tracking structures |\n\nThe concurrency manager maintains internal state to track active connections, available resources, and configuration limits. This state enables proper resource management and prevents system overload during high traffic periods.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `model` | `ConcurrencyModel` | Active concurrency model (thread-per-connection, pool, or event-driven) |\n| `max_connections` | `int` | Maximum simultaneous connections allowed before rejecting new clients |\n| `max_threads` | `int` | Maximum threads in pool model, ignored for other models |\n| `active_connections` | `ConnectionContext*` | Array tracking all currently active client connections |\n| `connection_count` | `int` | Current number of active connections being processed |\n| `thread_pool` | `pthread_t*` | Thread pool array for pool-based concurrency model |\n| `connection_queue` | `ConnectionQueue*` | Queue of pending connections awaiting thread assignment in pool model |\n| `shutdown_requested` | `volatile int` | Flag indicating graceful shutdown has been initiated |\n| `connection_mutex` | `pthread_mutex_t` | Protects connection tracking data structures from concurrent access |\n\nThe interface design separates concurrency concerns from HTTP processing logic. The HTTP parser, file handler, and response generation components remain unchanged regardless of concurrency model. This separation enables testing different concurrency approaches without rewriting core functionality.\n\nConnection lifecycle management follows a consistent pattern across all models. The concurrency manager receives a client file descriptor and address from the TCP server, creates a `ConnectionContext` structure to track the connection state, dispatches the connection to an available processor, and ensures proper cleanup when processing completes.\n\n> **Key Design Insight**: The concurrency manager acts as a resource allocation layer between the TCP server and HTTP processing components. By abstracting concurrency model details, we can optimize for different deployment scenarios (high-throughput vs. low-latency, resource-constrained vs. resource-abundant) without changing the core HTTP server logic.\n\n### Concurrency Model Options\n\nThe HTTP server supports three distinct concurrency models, each optimized for different scenarios and resource constraints. Understanding the trade-offs between these models is crucial for selecting the appropriate approach based on expected traffic patterns and system capabilities.\n\n![Concurrency Model Comparison](./diagrams/concurrency-models.svg)\n\n#### Thread-Per-Connection Model\n\nThe thread-per-connection model creates a dedicated thread for each incoming client connection. When the TCP server accepts a new connection, the concurrency manager immediately spawns a new thread and passes the client file descriptor to that thread for complete request processing.\n\nThis model provides excellent isolation between client connections - a slow or problematic client cannot block processing for other clients since each operates in its own thread. The implementation is straightforward since each thread can use blocking I/O operations without affecting other connections. Error handling is simplified because thread-local failures don't propagate to other client connections.\n\nHowever, thread-per-connection has significant scalability limitations. Each thread consumes system memory for its stack (typically 8MB on Linux), and thread creation overhead becomes substantial under high connection rates. The operating system's thread scheduler becomes a bottleneck when managing hundreds or thousands of concurrent threads. Many threads spend most of their time blocked on I/O operations, leading to inefficient resource utilization.\n\nThe processing algorithm for thread-per-connection follows these steps:\n\n1. Main server thread accepts new client connection from TCP listener\n2. Concurrency manager checks current connection count against `max_connections` limit\n3. If limit not exceeded, manager calls `pthread_create` to spawn new handler thread\n4. New thread receives client file descriptor and address as startup parameters\n5. Thread calls `init_connection_context` to establish per-connection state tracking\n6. Thread enters complete HTTP request-response processing cycle independently\n7. Thread handles request parsing, file serving, and response transmission\n8. Upon completion or error, thread calls connection cleanup and terminates\n9. Main thread decrements active connection counter when notified of thread completion\n\nThis model works best for scenarios with moderate connection concurrency (under 100 simultaneous connections) where simplicity and connection isolation are more important than maximum throughput.\n\n#### Thread Pool Model\n\nThe thread pool model pre-creates a fixed number of worker threads that share responsibility for processing client connections. Instead of creating threads dynamically, the concurrency manager maintains a pool of persistent threads that pull work from a shared connection queue.\n\nThis approach eliminates thread creation overhead since worker threads are reused across multiple connections. The fixed thread count prevents system resource exhaustion even under heavy load, providing predictable performance characteristics. Thread pool size can be tuned based on available CPU cores and expected workload patterns.\n\nThe trade-off is increased complexity in work distribution and resource sharing. Multiple threads must safely access shared data structures, requiring proper synchronization. Connection processing becomes less isolated since threads are reused, potentially allowing state from one connection to affect another if cleanup is incomplete.\n\nThe thread pool processing algorithm coordinates work distribution among fixed resources:\n\n1. Server initialization creates `max_threads` worker threads in blocked state\n2. Each worker thread enters loop calling `dequeue_connection` on shared work queue\n3. Main server thread accepts new client connections as usual\n4. Concurrency manager adds new connections to work queue instead of creating threads\n5. Next available worker thread dequeues connection and processes complete request-response cycle\n6. Worker thread performs connection cleanup and returns to queue waiting state\n7. If work queue fills beyond capacity, new connections are rejected with appropriate error\n8. During shutdown, manager signals all worker threads to exit after completing current work\n\nQueue management requires careful synchronization to prevent race conditions. The connection queue uses mutex protection and condition variables to coordinate between the main thread adding work and worker threads removing work.\n\n| Queue Operation | Synchronization | Behavior |\n|-----------------|-----------------|----------|\n| `enqueue_connection` | Acquire queue mutex | Add connection to tail, signal waiting workers |\n| `dequeue_connection` | Acquire queue mutex | Remove connection from head, block if empty |\n| `queue_full` | Acquire queue mutex | Check if queue size exceeds configured limit |\n| `shutdown_queue` | Acquire queue mutex | Mark queue closed, wake all waiting workers |\n\nThread pool size tuning depends on workload characteristics. CPU-bound workloads benefit from thread count matching CPU core count. I/O-bound workloads (typical for file serving) can benefit from higher thread counts since threads spend time blocked on disk operations. Monitoring connection queue depth and thread utilization helps optimize pool size for specific deployment scenarios.\n\n#### Event-Driven Model\n\nThe event-driven model uses a single thread with non-blocking I/O and I/O multiplexing to handle multiple connections simultaneously. Instead of dedicating threads to connections, this model monitors all active file descriptors using `select` or `poll` system calls and processes whichever connections have data ready.\n\nThis approach achieves excellent scalability since it eliminates thread overhead entirely. A single event loop can handle thousands of simultaneous connections with minimal memory footprint. Context switching overhead is eliminated since only one thread runs, and the model naturally prioritizes connections with available data over blocked connections.\n\nThe complexity trade-off is substantial. All I/O operations must be non-blocking, requiring careful state machine management to handle partial reads and writes. Application logic must be structured to avoid blocking operations, since any blocking call stalls processing for all connections. Error handling becomes more complex since connection failures must be managed within the shared event loop.\n\nThe event-driven processing algorithm manages multiple connection states within a single thread:\n\n1. Server initialization sets all client sockets to non-blocking mode using `fcntl`\n2. Main event loop calls `select` or `poll` with all active file descriptors\n3. System call blocks until at least one file descriptor has data ready\n4. Event loop iterates through ready file descriptors to determine required processing\n5. For server socket readiness, loop accepts new connection and adds to monitoring set\n6. For client socket readiness, loop determines connection state and processes next step\n7. Connection processing advances state machine: reading request, parsing, serving file, writing response\n8. Partial operations save state and yield control back to event loop for next iteration\n9. Completed connections are cleaned up and removed from monitoring set\n10. Loop continues until shutdown signal received\n\nConnection state management requires tracking progress through the HTTP request-response cycle:\n\n| Connection State | Next Action | Success Transition | Error Transition |\n|------------------|-------------|-------------------|------------------|\n| `STATE_READING_REQUEST` | `read_complete_request` non-blocking | `STATE_PARSING_REQUEST` | `STATE_ERROR_CLEANUP` |\n| `STATE_PARSING_REQUEST` | `parse_http_request` | `STATE_SERVING_FILE` | `STATE_ERROR_RESPONSE` |\n| `STATE_SERVING_FILE` | `serve_static_file` | `STATE_WRITING_RESPONSE` | `STATE_ERROR_RESPONSE` |\n| `STATE_WRITING_RESPONSE` | `send` response non-blocking | `STATE_COMPLETE_CLEANUP` | `STATE_ERROR_CLEANUP` |\n| `STATE_ERROR_RESPONSE` | Generate and send error | `STATE_COMPLETE_CLEANUP` | `STATE_ERROR_CLEANUP` |\n\nThe event-driven model excels for high-concurrency scenarios with many simultaneous connections, particularly when most connections involve small file transfers or when memory usage must be minimized.\n\n### Architecture Decision Records\n\nThe concurrency management component involves several critical design decisions that significantly impact the server's scalability, complexity, and resource usage characteristics.\n\n> **Decision: Primary Concurrency Model Selection**\n> - **Context**: The server must handle multiple simultaneous client connections efficiently while remaining suitable for educational purposes. Different concurrency models have varying complexity, performance, and resource usage characteristics.\n> - **Options Considered**: Thread-per-connection for simplicity, thread pool for balanced scalability, event-driven for maximum performance\n> - **Decision**: Implement thread-per-connection as the primary model with thread pool as an advanced option\n> - **Rationale**: Thread-per-connection provides the clearest learning progression from single-connection handling to concurrent processing. The blocking I/O model matches earlier milestones and doesn't require restructuring HTTP processing logic. Thread pool can be added incrementally to demonstrate resource management concepts.\n> - **Consequences**: Initial implementation will have limited scalability (hundreds vs thousands of connections) but will be easier to debug and understand. Students can observe resource exhaustion directly and understand why more sophisticated models exist.\n\n| Concurrency Model | Learning Value | Implementation Complexity | Scalability | Resource Usage |\n|-------------------|----------------|---------------------------|-------------|----------------|\n| Thread-per-connection | High - clear progression | Low - familiar blocking I/O | Low - hundreds of connections | High - thread overhead |\n| Thread pool | Medium - resource management | Medium - queue synchronization | Medium - thousands of connections | Medium - fixed thread count |\n| Event-driven | Low - requires restructuring | High - state machine complexity | High - tens of thousands | Low - single thread |\n\n> **Decision: Connection Limit Enforcement**\n> - **Context**: Unbounded connection acceptance can lead to resource exhaustion and system instability. The server needs protection against connection flooding while maintaining acceptable service for legitimate clients.\n> - **Options Considered**: No limits (simplest), hard connection limit (reject new connections), connection queuing with timeout\n> - **Decision**: Implement hard connection limit with immediate rejection of excess connections\n> - **Rationale**: Hard limits provide predictable resource usage and prevent system overload. Immediate rejection gives clear feedback to clients and doesn't consume server resources on queued connections. This approach is easier to implement correctly than timeout-based queuing.\n> - **Consequences**: Some legitimate clients may be rejected during traffic spikes, but server stability is guaranteed. Students learn about capacity planning and graceful degradation under load.\n\n> **Decision: Graceful Shutdown Strategy**\n> - **Context**: Server shutdown should complete in-flight requests when possible to avoid client errors and data corruption. However, shutdown cannot wait indefinitely for slow or malicious clients.\n> - **Options Considered**: Immediate shutdown (close all connections), graceful with timeout (wait limited time), graceful without timeout (wait indefinitely)\n> - **Decision**: Graceful shutdown with configurable timeout\n> - **Rationale**: Graceful shutdown demonstrates proper resource cleanup and client consideration. Timeout prevents infinite waiting on problematic connections. Configurable timeout allows tuning based on expected request processing time.\n> - **Consequences**: Shutdown sequence becomes more complex but more robust. Students learn about lifecycle management and the trade-offs between responsiveness and correctness.\n\n> **Decision: Thread Safety Approach**\n> - **Context**: Multiple threads accessing shared server state (configuration, connection counters, logging) require synchronization to prevent data corruption and race conditions.\n> - **Options Considered**: No shared state (fully isolated), fine-grained locking (per-data-structure mutexes), coarse-grained locking (single server mutex)\n> - **Decision**: Minimal shared state with fine-grained locking for specific data structures\n> - **Rationale**: Reducing shared state minimizes synchronization complexity and potential deadlock scenarios. Fine-grained locking allows better concurrency than coarse-grained approaches while remaining understandable for educational purposes.\n> - **Consequences**: Each shared data structure requires careful analysis for thread safety requirements. Students learn about concurrent programming principles and common synchronization patterns.\n\n![TCP Connection Lifecycle](./diagrams/connection-lifecycle.svg)\n\n### Common Concurrency Pitfalls\n\nConcurrent programming introduces subtle bugs and resource management issues that are particularly challenging for developers new to multi-threaded systems. Understanding these common pitfalls helps avoid frustrating debugging sessions and system instability.\n\n⚠️ **Pitfall: Thread Resource Leaks**\n\nThe most common issue in thread-per-connection implementations is failing to properly clean up thread resources when connections terminate. Each `pthread_create` call allocates system resources that must be explicitly released through `pthread_join` or `pthread_detach`. Failing to do so causes thread handles to accumulate in the kernel, eventually exhausting system thread limits.\n\nThe symptom appears as the server initially handling connections correctly, then gradually becoming unable to create new threads. Error messages like \"Resource temporarily unavailable\" from `pthread_create` indicate thread handle exhaustion. This problem is insidious because it may not manifest during light testing but causes failures after handling hundreds or thousands of connections.\n\nThe correct approach is to create threads in detached state using `pthread_detach` immediately after creation, or to use `pthread_attr_setdetachstate` with `PTHREAD_CREATE_DETACHED` when calling `pthread_create`. Detached threads automatically release their resources when they terminate, eliminating the need for explicit joining.\n\n```c\n// WRONG: Thread handle leaks\npthread_t thread_id;\npthread_create(&thread_id, NULL, handle_client, client_context);\n// Thread handle never cleaned up - resource leak!\n\n// CORRECT: Detached thread cleans up automatically\npthread_t thread_id;\npthread_create(&thread_id, NULL, handle_client, client_context);\npthread_detach(thread_id);  // Thread will clean up when it exits\n```\n\n⚠️ **Pitfall: Race Conditions in Connection Counting**\n\nTracking the number of active connections requires careful synchronization since multiple threads modify the connection counter simultaneously. A common mistake is using non-atomic operations to increment and decrement the counter, leading to race conditions where the count becomes inaccurate.\n\nInaccurate connection counting can cause the server to accept more connections than intended (potentially causing resource exhaustion) or to reject connections when capacity is actually available (reducing throughput unnecessarily). The race condition typically manifests as connection counts that drift from the true value over time.\n\nProper connection counting requires mutex protection around all counter modifications or use of atomic operations. The counter must be incremented when connections are accepted and decremented when connections complete, with both operations protected by the same synchronization mechanism.\n\n⚠️ **Pitfall: Deadlock in Shutdown Sequence**\n\nGraceful shutdown sequences can create deadlock scenarios when the main thread waits for worker threads to complete while worker threads wait for shared resources that the main thread holds. This commonly occurs when the main thread holds a mutex while signaling shutdown, and worker threads need that same mutex to complete their cleanup.\n\nThe symptom is a server that appears to hang during shutdown - it stops accepting new connections but never fully terminates. Worker threads block waiting for resources, while the main thread blocks waiting for worker threads to finish.\n\nThe solution is to carefully order shutdown operations: first stop accepting new connections, then release any shared resources, then signal worker threads to shut down, and finally wait for worker thread completion. Never hold locks while waiting for thread completion.\n\n⚠️ **Pitfall: Buffer Ownership Confusion**\n\nIn concurrent servers, multiple threads may reference the same buffer memory for request data, response content, or configuration strings. Confusion about which thread owns (is responsible for freeing) shared buffers leads to either memory leaks or double-free errors.\n\nMemory ownership should be clearly defined and documented. The safest approach is to avoid sharing buffers between threads - each thread should work with its own copy of data. When sharing is necessary for performance reasons, use reference counting or clear ownership transfer protocols.\n\n⚠️ **Pitfall: Non-Reentrant Function Usage**\n\nMany standard library functions are not thread-safe and cannot be called simultaneously from multiple threads. Common examples include `strtok` (use `strtok_r` instead), `gethostbyname` (use `getaddrinfo`), and global variable access in error handling functions like `errno`.\n\nUsing non-reentrant functions in multi-threaded code can cause data corruption, incorrect results, or crashes that are difficult to reproduce since they depend on thread scheduling timing. These bugs often appear intermittently and may not manifest during development but cause failures in production.\n\nAlways use the reentrant (_r suffix) versions of standard library functions when available, or protect non-reentrant functions with mutexes. Check function documentation for thread safety guarantees before using them in multi-threaded contexts.\n\n⚠️ **Pitfall: Blocking Operations in Event-Driven Model**\n\nWhen implementing event-driven concurrency, any blocking operation (file I/O, DNS lookups, logging to slow storage) stalls the entire event loop and prevents processing of all other connections. This defeats the primary advantage of the event-driven model and can cause connection timeouts for clients that would otherwise be served successfully.\n\nSymptoms include good performance with few connections that degrades dramatically as connection count increases, or periodic freezes where all connections stop responding simultaneously. These issues often correlate with slow file system operations or network lookups.\n\nEvent-driven implementations must use non-blocking I/O for all operations or delegate potentially blocking work to background threads. File operations should use `O_NONBLOCK` flags, and functions like `gethostbyname` should be replaced with asynchronous alternatives or offloaded to worker threads.\n\n### Implementation Guidance\n\nThe concurrency management component bridges the gap between single-threaded HTTP processing and production-ready multi-client handling. This implementation guidance provides the necessary infrastructure and patterns to implement robust concurrent connection handling.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Threading | POSIX pthread library with basic create/join | Thread pool with condition variables |\n| Synchronization | pthread_mutex for shared data | pthread_rwlock for read-heavy data |\n| I/O Multiplexing | select() for basic event handling | epoll (Linux) or kqueue (BSD) for high performance |\n| Connection Tracking | Fixed-size arrays with linear search | Dynamic hash table with connection IDs |\n| Work Queuing | Simple array with mutex protection | Lock-free queue with atomic operations |\n\n#### Recommended File Structure\n\nThe concurrency management component integrates with existing server structure while maintaining clear separation of concerns:\n\n```\nhttp-server/\n  src/\n    main.c                     ← server startup and shutdown coordination\n    tcp_server.c               ← existing TCP connection acceptance\n    http_parser.c              ← existing HTTP request parsing  \n    file_handler.c             ← existing static file serving\n    concurrency_manager.c      ← NEW: connection dispatching and resource management\n    concurrency_manager.h      ← NEW: concurrency interface definitions\n    connection_context.c       ← NEW: per-connection state management\n    connection_context.h       ← NEW: connection tracking structures\n    thread_pool.c             ← NEW: worker thread management (optional)\n    thread_pool.h             ← NEW: thread pool interface (optional)\n  tests/\n    test_concurrency.c        ← concurrency-specific test cases\n    test_integration.c        ← multi-client integration tests\n  config/\n    server.conf               ← concurrency tuning parameters\n```\n\nThis structure keeps concurrency concerns separate from HTTP processing logic while providing clear integration points for connection handling.\n\n#### Infrastructure Starter Code\n\n**Complete Connection Context Management** (connection_context.c):\n```c\n#include \"connection_context.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\nvoid init_connection_context(ConnectionContext* context, int client_fd, sockaddr_in addr) {\n    memset(context, 0, sizeof(ConnectionContext));\n    context->client_fd = client_fd;\n    context->client_addr = addr;\n    context->connect_time = time(NULL);\n    context->thread_id = pthread_self();\n}\n\nvoid cleanup_connection_context(ConnectionContext* context) {\n    if (context->client_fd >= 0) {\n        close(context->client_fd);\n        context->client_fd = -1;\n    }\n    // Clear sensitive data\n    memset(context, 0, sizeof(ConnectionContext));\n}\n\n// Thread-safe connection counter for resource tracking\nstatic int active_connection_count = 0;\nstatic pthread_mutex_t connection_count_mutex = PTHREAD_MUTEX_INITIALIZER;\n\nint increment_connection_count(void) {\n    pthread_mutex_lock(&connection_count_mutex);\n    int new_count = ++active_connection_count;\n    pthread_mutex_unlock(&connection_count_mutex);\n    return new_count;\n}\n\nint decrement_connection_count(void) {\n    pthread_mutex_lock(&connection_count_mutex);\n    int new_count = --active_connection_count;\n    pthread_mutex_unlock(&connection_count_mutex);\n    return new_count;\n}\n\nint get_active_connection_count(void) {\n    pthread_mutex_lock(&connection_count_mutex);\n    int count = active_connection_count;\n    pthread_mutex_unlock(&connection_count_mutex);\n    return count;\n}\n```\n\n**Complete Thread-Safe Logging Utility** (logger.c):\n```c\n#include <stdio.h>\n#include <time.h>\n#include <pthread.h>\n#include <stdarg.h>\n\nstatic pthread_mutex_t log_mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic FILE* log_file = NULL;\n\nint init_logger(const char* log_filename) {\n    pthread_mutex_lock(&log_mutex);\n    log_file = fopen(log_filename, \"a\");\n    pthread_mutex_unlock(&log_mutex);\n    return (log_file != NULL) ? 0 : -1;\n}\n\nvoid log_message(const char* level, const char* format, ...) {\n    pthread_mutex_lock(&log_mutex);\n    \n    time_t now = time(NULL);\n    char time_str[64];\n    strftime(time_str, sizeof(time_str), \"%Y-%m-%d %H:%M:%S\", localtime(&now));\n    \n    FILE* output = log_file ? log_file : stderr;\n    fprintf(output, \"[%s] [%s] [Thread %lu] \", time_str, level, pthread_self());\n    \n    va_list args;\n    va_start(args, format);\n    vfprintf(output, format, args);\n    va_end(args);\n    \n    fprintf(output, \"\\n\");\n    fflush(output);\n    \n    pthread_mutex_unlock(&log_mutex);\n}\n\nvoid cleanup_logger(void) {\n    pthread_mutex_lock(&log_mutex);\n    if (log_file) {\n        fclose(log_file);\n        log_file = NULL;\n    }\n    pthread_mutex_unlock(&log_mutex);\n}\n```\n\n#### Core Logic Skeleton Code\n\n**Concurrency Manager Implementation** (concurrency_manager.c):\n```c\n#include \"concurrency_manager.h\"\n#include \"connection_context.h\"\n#include \"http_parser.h\"\n#include \"file_handler.h\"\n#include <pthread.h>\n#include <stdlib.h>\n#include <unistd.h>\n\ntypedef struct {\n    ConcurrencyModel model;\n    int max_connections;\n    int max_threads;\n    volatile int shutdown_requested;\n    pthread_mutex_t manager_mutex;\n} ConcurrencyManager;\n\n// Thread entry point for handling individual client connections\nvoid* handle_client_connection(void* arg) {\n    ConnectionContext* context = (ConnectionContext*)arg;\n    \n    // TODO 1: Initialize HTTP request and response structures using init_http_request/init_http_response\n    \n    // TODO 2: Read complete HTTP request from client socket using read_complete_request\n    // Handle partial reads and network timeouts appropriately\n    \n    // TODO 3: Parse HTTP request using parse_http_request, handle parsing errors\n    \n    // TODO 4: Serve static file content using serve_static_file from file_handler component\n    \n    // TODO 5: Send HTTP response back to client, handle partial writes\n    \n    // TODO 6: Clean up request/response structures and connection context\n    \n    // TODO 7: Decrement active connection count and log connection completion\n    \n    // TODO 8: For detached threads, perform final cleanup and return NULL\n    \n    return NULL;\n}\n\nConcurrencyManager* init_concurrency_manager(ServerConfig* config, ConcurrencyModel model) {\n    // TODO 1: Allocate ConcurrencyManager structure and initialize fields from config\n    \n    // TODO 2: Initialize mutex for protecting shared manager state\n    \n    // TODO 3: Set concurrency model and resource limits from ServerConfig\n    \n    // TODO 4: If model is THREAD_POOL, initialize worker thread pool and work queue\n    // Use pthread_create to spawn config->max_threads worker threads\n    \n    // TODO 5: If model is EVENT_DRIVEN, initialize file descriptor sets and event tracking\n    \n    // TODO 6: Initialize connection tracking data structures\n    \n    // TODO 7: Return initialized manager or NULL on failure\n}\n\nint start_connection_handler(ConcurrencyManager* manager, int client_fd, sockaddr_in client_addr) {\n    // TODO 1: Check if shutdown has been requested, reject new connections if so\n    \n    // TODO 2: Check current connection count against max_connections limit\n    // If limit exceeded, send HTTP 503 Service Unavailable and close client_fd\n    \n    // TODO 3: Create and initialize ConnectionContext for this client\n    // Use init_connection_context with client_fd and client_addr\n    \n    // TODO 4: Increment active connection count using thread-safe counter\n    \n    // TODO 5: Dispatch connection based on concurrency model:\n    // - THREAD_PER_CONNECTION: Create detached thread with handle_client_connection\n    // - THREAD_POOL: Add connection to work queue for worker threads\n    // - EVENT_DRIVEN: Add client_fd to monitored file descriptor set\n    \n    // TODO 6: Log successful connection acceptance with client address\n    \n    // TODO 7: Return 0 on success, -1 on failure (cleanup connection on failure)\n}\n\nvoid shutdown_concurrency_manager(ConcurrencyManager* manager, int graceful) {\n    // TODO 1: Set shutdown_requested flag to prevent new connection acceptance\n    \n    // TODO 2: If graceful shutdown requested, wait for active connections to complete\n    // Use configurable timeout to prevent infinite waiting\n    \n    // TODO 3: For THREAD_POOL model, signal worker threads to exit and join them\n    \n    // TODO 4: For EVENT_DRIVEN model, close event loop and cleanup file descriptor sets\n    \n    // TODO 5: Close any remaining client connections and cleanup resources\n    \n    // TODO 6: Log shutdown completion with final connection statistics\n}\n```\n\n#### Language-Specific Hints\n\n**POSIX Thread Management:**\n- Use `pthread_create` with `PTHREAD_CREATE_DETACHED` attribute to avoid thread handle leaks\n- Always check `pthread_create` return value - thread creation can fail under high load\n- Use `pthread_self()` for logging and debugging thread-specific operations\n- Mutex initialization with `PTHREAD_MUTEX_INITIALIZER` is simpler than `pthread_mutex_init`\n\n**Socket Configuration for Concurrency:**\n- Set `SO_REUSEADDR` on server socket to allow quick restart during development\n- Consider `TCP_NODELAY` for reducing latency on small HTTP responses\n- Use `fcntl(fd, F_SETFL, O_NONBLOCK)` for event-driven model socket configuration\n- Monitor `EMFILE` and `ENFILE` errors which indicate file descriptor exhaustion\n\n**Memory Management in Multithreaded Context:**\n- Each thread needs its own request/response buffers to avoid sharing conflicts\n- Use `malloc`/`free` carefully - consider memory pools for high-frequency allocation\n- Clear sensitive data from buffers before freeing to prevent information leaks\n- Consider using `valgrind --tool=helgrind` to detect thread safety issues\n\n#### Milestone Checkpoint\n\nAfter implementing thread-per-connection concurrency:\n\n**Verification Command:**\n```bash\n# Terminal 1: Start server\n./http_server -p 8080 -r ./www -c 10\n\n# Terminal 2: Test concurrent connections\nfor i in {1..5}; do\n  curl -s http://localhost:8080/test.html &\ndone\nwait\n```\n\n**Expected Behavior:**\n- Server accepts all 5 simultaneous connections without blocking\n- Each connection receives complete HTTP response with correct content\n- Server logs show multiple thread IDs handling concurrent requests\n- Connection count increases to 5 then decreases back to 0\n- No resource leaks or error messages about thread creation failures\n\n**Signs of Problems:**\n- Connections hang or timeout: Check for blocking I/O operations\n- \"Resource temporarily unavailable\" errors: Thread cleanup issues or limits exceeded  \n- Inconsistent responses: Race conditions in shared data structures\n- Server crashes under load: Buffer overflows or memory corruption\n\n**Advanced Testing:**\nUse `ab` (Apache Bench) for stress testing: `ab -n 100 -c 10 http://localhost:8080/`\nMonitor with `ps -eLf | grep http_server` to observe thread creation patterns\n\n\n## Interactions and Data Flow\n\n> **Milestone(s):** Integrates all Milestones 1-4 - describes how TCP server, HTTP parser, file handler, and concurrency manager work together to process complete client requests\n\nThe interactions and data flow section reveals how our HTTP server's four main components orchestrate together to transform raw TCP connections into complete HTTP responses. Think of this as watching the backstage choreography of a theater production - while audiences see a seamless performance, the magic happens through precise coordination between lighting, sound, props, and actors, each playing their role at exactly the right moment with perfect timing.\n\nUnderstanding component interactions is crucial because distributed systems fail most often at the boundaries between components, not within individual components themselves. A TCP connection might succeed, HTTP parsing might work perfectly, file serving might execute flawlessly, and concurrency management might handle threading correctly, yet the system could still fail if these components don't communicate properly or if data transformations between them introduce errors.\n\n![HTTP Server System Overview](./diagrams/system-overview.svg)\n\nThe interaction patterns we'll explore demonstrate three fundamental distributed systems principles: **separation of concerns** (each component has a single, well-defined responsibility), **loose coupling** (components interact through clean interfaces rather than tight dependencies), and **error isolation** (failures in one component don't cascade uncontrollably to others). These principles become especially important as we scale from handling a single client to managing hundreds of concurrent connections.\n\n### Component Communication Patterns\n\nThink of component communication like a hospital emergency room - when a patient arrives, there's a well-established protocol for how information flows between triage, doctors, nurses, lab technicians, and administrators. Each role has specific responsibilities, clear communication channels, and standardized handoff procedures. No single person needs to understand every other role in detail, but everyone must know exactly how to receive information, what to do with it, and where to send the results.\n\nOur HTTP server follows similar communication patterns, with each component serving as a specialist that receives structured input, performs its specific function, and produces structured output for the next component in the chain. This design enables us to test, debug, and modify components independently while maintaining system-wide coherence.\n\n#### Primary Communication Flow\n\nThe primary communication pattern follows a **request-response pipeline** where data flows sequentially through components, with each component adding value and structure to the information stream. Unlike event-driven architectures where components communicate through asynchronous messages, our HTTP server uses **synchronous handoffs** - each component completes its work before passing control to the next component.\n\n| Source Component | Target Component | Data Passed | Communication Method | Error Handling |\n|------------------|------------------|-------------|---------------------|----------------|\n| TCP Server | Concurrency Manager | `client_fd`, `client_addr` | Function call with `ConnectionContext*` | Returns error code, caller handles cleanup |\n| Concurrency Manager | HTTP Parser | `client_fd`, raw request buffer | Thread function parameter | Exception/return code propagates to thread handler |\n| HTTP Parser | File Handler | `HTTPRequest*` with parsed fields | Struct pointer parameter | Parser sets error flags, handler checks validity |\n| File Handler | HTTP Response | `HTTPResponse*` with content | Struct modification in-place | Handler sets appropriate HTTP status codes |\n| HTTP Response | TCP Server | Response bytes, content length | Buffer pointer and size | TCP write errors trigger connection cleanup |\n\nThe **ownership transfer model** governs memory management and resource responsibility as data flows between components. When the TCP server accepts a connection, it owns the client file descriptor and must ensure it gets closed. When it hands the connection to the concurrency manager, ownership transfers - the concurrency manager becomes responsible for cleanup. Similarly, when the HTTP parser allocates memory for request body content, it owns that memory until the request processing completes.\n\n#### Secondary Communication Patterns\n\nBeyond the primary request-response pipeline, components use several secondary communication patterns for configuration, monitoring, and resource management:\n\n**Configuration Propagation**: The `ServerConfig` structure flows downward from the main server loop to each component, providing runtime parameters like document root, thread limits, and timeout values. This follows an **immutable configuration** pattern - once the server starts, configuration values don't change, eliminating the need for complex synchronization.\n\n**Resource Status Reporting**: Components report their resource usage back to the concurrency manager through atomic counters and status flags. The concurrency manager tracks active connection counts, thread pool utilization, and memory usage to make scheduling decisions and prevent resource exhaustion.\n\n**Error Signal Propagation**: When components encounter non-recoverable errors, they use a combination of return codes and shared error state to signal problems upstream. This enables graceful degradation - if the file handler can't read a requested file, it generates a 404 response rather than crashing the entire connection.\n\n> **Decision: Synchronous Pipeline vs. Asynchronous Event-Driven Communication**\n> - **Context**: Components need to coordinate request processing while maintaining clear boundaries and error handling\n> - **Options Considered**: \n>   1. Synchronous function calls with direct data passing\n>   2. Asynchronous message queues between components  \n>   3. Shared memory with event notifications\n> - **Decision**: Synchronous function calls with structured data passing\n> - **Rationale**: Synchronous calls provide simpler error handling, easier debugging, and clearer resource ownership semantics for an educational project. Asynchronous approaches add complexity without significant benefits at this scale.\n> - **Consequences**: Enables straightforward testing and debugging but limits scalability compared to fully asynchronous designs\n\n| Communication Pattern | Pros | Cons | Used For |\n|----------------------|------|------|----------|\n| Synchronous Pipeline | Simple error handling, clear ownership, easy debugging | Blocking behavior, limited scalability | Primary request processing |\n| Shared Configuration | Consistent settings, no synchronization needed | Requires server restart for changes | Runtime parameters |\n| Status Reporting | Real-time resource monitoring, automatic throttling | Additional complexity, potential contention | Resource management |\n| Error Propagation | Graceful degradation, localized failure recovery | Complex error code hierarchy | Failure handling |\n\n### Complete Request-Response Cycle\n\n![Request Processing Sequence](./diagrams/request-processing-flow.svg)\n\nThe complete request-response cycle represents the journey of a single HTTP request from the moment a TCP connection arrives until the response bytes are sent back to the client and the connection is cleaned up. Think of this like tracking a letter through the postal system - from the moment it's dropped in a mailbox, through sorting facilities, delivery routes, and final delivery, with each step adding information and moving the letter closer to its destination.\n\nUnderstanding this complete cycle is essential for debugging because most HTTP server issues manifest as problems in the handoffs between stages rather than within individual stages. A request might fail because the TCP server doesn't read enough bytes, because the HTTP parser mishandles headers, because the file handler can't resolve paths, or because the concurrency manager runs out of threads.\n\n#### Stage 1: Connection Establishment and Acceptance\n\nThe request-response cycle begins when a client establishes a TCP connection to our server. The TCP server component, running in its main event loop, detects the incoming connection through the `accept()` system call and creates the foundational data structures that will carry information through the entire request processing pipeline.\n\n**Detailed Connection Acceptance Process:**\n\n1. **Socket Event Detection**: The main server loop calls `accept()` on the listening socket `server_fd`, which blocks until a client attempts to connect. When `accept()` returns, it provides a new `client_fd` representing the specific client connection and a `sockaddr_in` structure containing the client's IP address and port.\n\n2. **Connection Context Creation**: The server calls `init_connection_context()` to create a `ConnectionContext` structure that will track this connection's lifecycle. This context includes the client file descriptor, client address information, connection timestamp, and eventually thread identification for debugging purposes.\n\n3. **Resource Availability Check**: Before proceeding with request processing, the server checks whether accepting this connection would exceed configured limits. It queries the concurrency manager's active connection count and compares it against `MAX_CONNECTIONS` from the `ServerConfig`.\n\n4. **Connection Handoff**: If resources are available, the server passes the `ConnectionContext` to the concurrency manager via `start_connection_handler()`. This transfer of ownership is critical - from this point forward, the concurrency manager becomes responsible for the client file descriptor and must ensure it gets closed even if errors occur.\n\n5. **Failure Recovery**: If resource limits are exceeded or if connection handoff fails, the TCP server immediately closes the `client_fd` and logs the failure. This prevents file descriptor leaks and ensures the client receives a connection refused error rather than hanging indefinitely.\n\n**Data Structures at Connection Establishment:**\n\n| Structure | Field | Value | Purpose |\n|-----------|-------|-------|---------|\n| `ConnectionContext` | `client_fd` | Result of `accept()` call | Socket for client communication |\n| `ConnectionContext` | `client_addr` | Client's `sockaddr_in` | Source IP and port for logging |\n| `ConnectionContext` | `connect_time` | `time(NULL)` | Connection timestamp for timeout detection |\n| `ConnectionContext` | `thread_id` | Initially 0 | Will be set by concurrency manager |\n\n#### Stage 2: Concurrency Dispatching and Resource Allocation\n\nOnce the concurrency manager receives the connection context, it must decide how to handle the new connection based on the configured concurrency model. This stage is where our server's scalability characteristics are determined - poor decisions here can lead to resource exhaustion, thread thrashing, or connection starvation.\n\n**Thread-per-Connection Model Processing:**\n\n1. **Thread Creation**: The concurrency manager calls `pthread_create()` to spawn a new thread with `handle_client_connection()` as the entry point and the `ConnectionContext*` as the parameter. The new thread receives a copy of the connection context and begins executing independently.\n\n2. **Resource Tracking**: The manager increments its active connection counter using atomic operations to prevent race conditions. This counter is checked by the TCP server before accepting new connections and is used for resource limit enforcement.\n\n3. **Thread Configuration**: The newly created thread is configured as detached using `pthread_detach()` so that it automatically cleans up its resources when the connection processing completes. This prevents the need for explicit `pthread_join()` calls.\n\n4. **Error Recovery**: If thread creation fails due to system resource limits, the concurrency manager immediately closes the `client_fd`, decrements any counters that were incremented, and returns an error code to the TCP server.\n\n**Thread Pool Model Processing:**\n\n1. **Work Queue Insertion**: Instead of creating a new thread, the concurrency manager calls `enqueue_connection()` to add the connection context to a shared work queue protected by a mutex. Worker threads continuously poll this queue for new work.\n\n2. **Worker Thread Notification**: After enqueuing the connection, the manager signals a condition variable to wake up sleeping worker threads. This ensures that connections don't sit in the queue longer than necessary.\n\n3. **Queue Overflow Handling**: If the work queue is full, indicating that all worker threads are busy and the queue has reached its maximum capacity, the manager can either block waiting for space or immediately reject the connection based on configuration.\n\n**Resource State Tracking:**\n\n| Resource Type | Counter Variable | Limit Check | Cleanup Responsibility |\n|---------------|------------------|-------------|------------------------|\n| Active Connections | `active_connection_count` | Against `max_connections` | Connection thread |\n| Worker Threads | `thread_pool_size` | Against `max_threads` | Concurrency manager |\n| Work Queue Entries | `queue->size` | Against `queue->capacity` | Worker thread |\n| File Descriptors | System-level tracking | Against `ulimit -n` | Connection thread |\n\n#### Stage 3: HTTP Request Reading and Buffering\n\nOnce a worker thread (or dedicated connection thread) begins processing the connection, its first responsibility is reading the complete HTTP request from the client socket. This stage is more complex than it initially appears because TCP provides a byte stream, not message boundaries, and HTTP requests can arrive in multiple TCP segments or be split across several `read()` operations.\n\n**Request Reading Algorithm:**\n\n1. **Buffer Initialization**: The connection handler allocates a request buffer of `MAX_REQUEST_SIZE` bytes (typically 8192) and initializes reading state variables including bytes read so far, buffer remaining, and completion status.\n\n2. **Partial Read Loop**: The handler calls `read_complete_request()` in a loop, which internally uses `recv()` to read bytes from `client_fd`. Each call to `recv()` may return fewer bytes than requested, requiring multiple iterations to read the complete request.\n\n3. **Request Boundary Detection**: As bytes are read, the handler scans for the HTTP request boundary, which is indicated by a blank line (two consecutive CRLF sequences: `\\r\\n\\r\\n`). For requests with message bodies, additional reading may be required based on the `Content-Length` header.\n\n4. **Timeout Handling**: Each read operation is performed with a socket timeout to prevent connections from hanging indefinitely. If the timeout expires before a complete request is received, the handler generates a 408 Request Timeout response.\n\n5. **Buffer Overflow Protection**: The handler continuously checks that the total bytes read doesn't exceed `MAX_REQUEST_SIZE`. If the request is too large, it generates a 413 Request Entity Too Large response and closes the connection.\n\n**Request Buffer Management:**\n\n```\nRequest Buffer Layout:\n[HTTP Request Line]\\r\\n\n[Header1: Value1]\\r\\n  \n[Header2: Value2]\\r\\n\n...\n[HeaderN: ValueN]\\r\\n\n\\r\\n\n[Message Body (if present)]\n\nBuffer State Variables:\n- buffer_start: Points to beginning of allocated buffer\n- write_position: Current position for writing new bytes  \n- bytes_available: Remaining space in buffer\n- request_complete: Boolean indicating full request received\n```\n\nThe critical challenge in this stage is handling **partial reads** correctly. Network conditions, TCP window sizes, and operating system buffering can cause HTTP requests to arrive in fragments. A robust implementation must accumulate these fragments while detecting request boundaries and preventing buffer overflows.\n\n#### Stage 4: HTTP Request Parsing and Validation\n\nAfter the complete HTTP request is buffered, the connection handler passes the raw request data to the HTTP parser component. This stage transforms the unstructured byte stream into the structured `HTTPRequest` data structure that subsequent components can process safely.\n\n**Parsing Process Flow:**\n\n1. **Request Structure Initialization**: The handler calls `init_http_request()` to create an `HTTPRequest` structure with safe default values and null pointers. This ensures that cleanup functions work correctly even if parsing fails partway through.\n\n2. **Request Line Parsing**: The parser calls `parse_request_line()` to extract the HTTP method, requested URL path, and protocol version from the first line of the request. This involves finding space characters that separate these three components and validating that each component contains legal characters.\n\n3. **Header Parsing Loop**: The parser enters a loop calling `parse_header_line()` for each subsequent line until it encounters the blank line that separates headers from the message body. Each header line is split on the first colon character, with header names normalized to lowercase and header values trimmed of whitespace.\n\n4. **Message Body Handling**: If the request includes a `Content-Length` header, the parser calls `parse_message_body()` to copy the specified number of bytes into the request's body buffer. This stage must handle cases where the content length is larger than remaining buffer space.\n\n5. **Request Validation**: After parsing completes, the parser performs semantic validation: checking that the HTTP method is supported, that the URL path doesn't contain illegal characters, and that required headers are present.\n\n**Parsing State Validation:**\n\n| Validation Check | Condition | Error Response | Recovery Action |\n|------------------|-----------|----------------|-----------------|\n| Method Validity | Method in allowed list | 405 Method Not Allowed | Close connection |\n| Path Format | No null bytes, valid UTF-8 | 400 Bad Request | Close connection |\n| Header Format | Contains colon separator | 400 Bad Request | Skip invalid header |\n| Content Length | Numeric, non-negative | 400 Bad Request | Close connection |\n| Protocol Version | HTTP/1.0 or HTTP/1.1 | 505 HTTP Version Not Supported | Close connection |\n\nThe parsing stage must be extremely robust because it processes untrusted input directly from network clients. Malformed requests, overly long headers, binary content in text fields, and other anomalies are common and must be handled gracefully without crashing the server or enabling security vulnerabilities.\n\n#### Stage 5: File Path Resolution and Security Validation\n\nWith a valid `HTTPRequest` structure in hand, the connection handler passes control to the file handler component. The file handler's primary responsibility is translating the HTTP request's URL path into a safe filesystem path within the configured document root, while preventing directory traversal attacks and other path-based security vulnerabilities.\n\n**Path Resolution Algorithm:**\n\n1. **URL Decoding**: The file handler calls `url_decode()` to convert percent-encoded characters in the request path back to their original form. For example, `%20` becomes a space character, and `%2F` becomes a forward slash.\n\n2. **Path Normalization**: The handler calls `normalize_path()` to resolve relative path components like `.` (current directory) and `..` (parent directory). This step is crucial for security because it prevents clients from using sequences like `../../../etc/passwd` to escape the document root.\n\n3. **Security Validation**: The handler calls `validate_and_resolve_path()` to ensure that the normalized path, when combined with the document root, doesn't reference any location outside the configured document root directory.\n\n4. **Filesystem Path Construction**: If validation succeeds, the handler constructs the complete filesystem path by concatenating the document root with the normalized request path.\n\n5. **File Existence and Permission Checks**: The handler uses `stat()` to check whether the resolved path exists and whether the server process has read permissions. It also determines whether the path points to a regular file or a directory.\n\n**Security Validation Details:**\n\n| Security Check | Purpose | Implementation | Failure Response |\n|----------------|---------|----------------|------------------|\n| Directory Traversal | Prevent access outside document root | Check resolved path starts with document root | 403 Forbidden |\n| Symbolic Link Following | Prevent link-based escapes | Use `lstat()` and validate link targets | 403 Forbidden |\n| Hidden File Access | Respect Unix hidden file convention | Check for filenames starting with '.' | 404 Not Found |\n| Permission Validation | Ensure server can read file | Use `access()` with R_OK flag | 403 Forbidden |\n| Path Length Limits | Prevent buffer overflow attacks | Check total path length against limits | 414 URI Too Long |\n\n> The path resolution stage implements the principle of **defense in depth** - multiple independent security checks that each provide protection against different attack vectors. Even if one check fails, the others should still prevent unauthorized access.\n\n#### Stage 6: File Content Reading and Response Generation\n\nOnce the file handler has validated the request path and confirmed that the requested resource exists and is accessible, it moves to the content serving phase. This stage reads the file contents, determines appropriate HTTP headers, and constructs the complete HTTP response structure.\n\n**Content Serving Process:**\n\n1. **MIME Type Detection**: The handler calls `detect_mime_type()` to examine the file extension and determine the appropriate `Content-Type` header. This ensures that browsers handle different file types correctly - serving HTML files with `text/html`, images with `image/jpeg`, and so forth.\n\n2. **File Size Calculation**: The handler uses the `stat()` result from the previous stage to determine the file size, which becomes the `Content-Length` header value. This allows clients to display download progress and detect truncated responses.\n\n3. **Response Structure Initialization**: The handler calls `init_http_response()` to create an `HTTPResponse` structure with appropriate default values, then sets the status code to 200 OK for successful requests.\n\n4. **Response Header Population**: The handler calls `add_response_header()` multiple times to populate standard HTTP headers including `Content-Type`, `Content-Length`, `Last-Modified`, and `Server`. Each header addition is bounds-checked to prevent buffer overflows.\n\n5. **File Content Reading**: The handler calls `serve_file_content()` to read the file contents into the response body buffer. For large files, this may involve chunked reading to avoid memory exhaustion.\n\n**Response Generation for Different Resource Types:**\n\n| Resource Type | Detection Method | Response Generation | Special Handling |\n|---------------|------------------|---------------------|------------------|\n| Regular File | `S_ISREG()` macro on stat result | Read file contents into response body | Binary file detection, streaming for large files |\n| Directory | `S_ISDIR()` macro on stat result | Generate HTML directory listing | Sort entries, format sizes, security filtering |\n| Missing Resource | `stat()` returns -1 with `ENOENT` | Generate 404 Not Found response | Include helpful error message |\n| Permission Denied | `stat()` returns -1 with `EACCES` | Generate 403 Forbidden response | Log access attempt for security monitoring |\n\n**Directory Listing Generation**: When the requested path maps to a directory rather than a file, the handler generates an HTML directory listing by calling `generate_directory_listing()`. This function reads directory entries, sorts them alphabetically, and formats them as clickable links within a basic HTML page structure.\n\n#### Stage 7: HTTP Response Transmission and Connection Cleanup\n\nThe final stage of the request-response cycle involves serializing the `HTTPResponse` structure into the HTTP wire format and transmitting it back to the client through the TCP connection. This stage must handle partial writes, connection errors, and proper resource cleanup regardless of whether transmission succeeds or fails.\n\n**Response Transmission Process:**\n\n1. **Response Serialization**: The connection handler constructs the complete HTTP response by formatting the status line, serializing all response headers, and appending the message body. The result is a single buffer containing the complete response in HTTP wire format.\n\n2. **Partial Write Loop**: The handler calls `send()` in a loop to transmit the response buffer to the client. Like reading, writing to TCP sockets can result in partial writes where only some bytes are sent in each operation.\n\n3. **Write Timeout Handling**: Each write operation is performed with a timeout to prevent connections from hanging if the client stops reading data. If a write timeout occurs, the handler logs the event and proceeds to connection cleanup.\n\n4. **Connection State Management**: After successful response transmission, the handler determines whether to keep the connection open for additional requests (HTTP keep-alive) or close it immediately. For this educational server, we typically close connections after each response.\n\n5. **Resource Cleanup**: The handler calls cleanup functions for all allocated resources: `cleanup_http_request()` for the parsed request, `cleanup_http_response()` for the response structure, `close()` for the client file descriptor, and `cleanup_connection_context()` for connection tracking.\n\n**Cleanup Sequence and Error Recovery:**\n\n| Cleanup Stage | Resources Released | Error Handling | Consequences of Failure |\n|---------------|-------------------|----------------|-------------------------|\n| HTTP Request Cleanup | Request body buffer, header storage | Always performed, errors logged | Memory leak for single connection |\n| HTTP Response Cleanup | Response body buffer, header storage | Always performed, errors logged | Memory leak for single connection |\n| Socket Closure | Client file descriptor | Check return value, log errors | File descriptor leak |\n| Connection Context Cleanup | Context structure, thread resources | Always performed | Memory leak, thread resource leak |\n| Concurrency Manager Notification | Active connection count decrement | Always performed | Resource limit tracking error |\n\n> **Critical Insight**: The cleanup sequence must be performed in **reverse dependency order** - resources that depend on others must be cleaned up first. For example, the response body buffer must be freed before the response structure itself, and the socket must be closed before the connection context is cleaned up.\n\nThe connection handler implements **exception safety** by using a cleanup pattern that works correctly even if errors occur during response transmission. All resource cleanup operations are designed to be **idempotent** - calling them multiple times or with already-cleaned resources produces safe, predictable results.\n\n### Error Propagation Between Components\n\nError propagation in distributed systems is like a hospital's emergency response system - when something goes wrong, information about the problem must flow quickly and accurately to the right people who can take appropriate action. A misdiagnosed symptom or a communication failure between departments can turn a manageable situation into a crisis.\n\n![Error Handling and Recovery](./diagrams/error-handling-flow.svg)\n\nIn our HTTP server, errors can originate from multiple sources: network problems (connection timeouts, socket errors), parsing failures (malformed HTTP requests, invalid headers), filesystem issues (missing files, permission denials), and concurrency problems (thread creation failures, resource exhaustion). Each type of error requires different handling strategies and generates different types of HTTP responses to clients.\n\nThe error propagation design follows the principle of **failing fast and failing safely** - when components detect problems they can't handle locally, they immediately signal the error to calling components rather than attempting incomplete or potentially dangerous recovery. This prevents error conditions from cascading into more serious failures or security vulnerabilities.\n\n#### Error Classification and Response Mapping\n\nOur HTTP server categorizes errors into distinct classes based on their source and severity, with each class mapped to appropriate HTTP status codes and recovery strategies. This classification enables consistent error handling across components and ensures that clients receive meaningful error responses rather than generic failure messages.\n\n**System-Level Error Categories:**\n\n| Error Category | Source Components | HTTP Status Mapping | Recovery Strategy | Example Scenarios |\n|----------------|-------------------|---------------------|-------------------|------------------|\n| Network Errors | TCP Server, Connection Handler | 500 Internal Server Error | Close connection, log error | Socket creation failure, connection reset |\n| Protocol Errors | HTTP Parser | 400 Bad Request, 405 Method Not Allowed | Send error response, close connection | Malformed request line, unsupported method |\n| Resource Errors | File Handler | 404 Not Found, 403 Forbidden | Send error response, continue connection | Missing file, permission denied |\n| Capacity Errors | Concurrency Manager | 503 Service Unavailable | Reject connection or queue request | Thread pool exhausted, connection limit reached |\n| Security Errors | File Handler, HTTP Parser | 403 Forbidden, 400 Bad Request | Send error response, log security event | Directory traversal attempt, oversized request |\n\n**Error Severity Levels:**\n\nThe server distinguishes between different severity levels to determine appropriate logging, alerting, and recovery actions:\n\n- **Fatal Errors**: System-level failures that prevent the server from accepting new connections (port binding failures, memory exhaustion)\n- **Connection Errors**: Problems that affect individual connections but don't impact overall server operation (client disconnections, parsing failures)  \n- **Request Errors**: Issues with specific requests that can be handled with appropriate HTTP error responses (file not found, method not allowed)\n- **Warning Conditions**: Unusual but manageable situations that should be logged for monitoring (approaching resource limits, slow client connections)\n\n#### Component Error Interfaces\n\nEach component in our HTTP server implements a consistent error reporting interface that enables upstream components to understand what went wrong and how to respond appropriately. This interface combines traditional C error codes with structured error information that can be used to generate detailed HTTP error responses.\n\n**TCP Server Error Interface:**\n\n| Function | Success Return | Error Return | Error Information | Cleanup Required |\n|----------|---------------|---------------|-------------------|------------------|\n| `create_server_socket()` | Valid file descriptor (>= 0) | -1 | `errno` set to specific error | None |\n| `server_main_loop()` | Does not return | void | Logs fatal errors before exit | Close server socket |\n| `read_complete_request()` | Bytes read (> 0) | -1 for errors, 0 for EOF | `errno` or connection state | Close client connection |\n\n**HTTP Parser Error Interface:**\n\n| Function | Success Return | Error Return | Error Information | Cleanup Required |\n|----------|---------------|---------------|-------------------|------------------|\n| `parse_http_request()` | 0 | Error code constant | Sets error fields in request structure | Call `cleanup_http_request()` |\n| `parse_request_line()` | 0 | `PARSE_ERROR_INVALID_METHOD`, `PARSE_ERROR_INVALID_PATH` | Error details in parser state | None |\n| `parse_header_line()` | 0 | `PARSE_ERROR_MALFORMED_HEADER` | Line number and content in error state | None |\n| `parse_message_body()` | 0 | `PARSE_ERROR_BODY_TOO_LARGE` | Content length and buffer size in error state | Free partial body allocation |\n\n**File Handler Error Interface:**\n\n| Function | Success Return | Error Return | Error Information | Cleanup Required |\n|----------|---------------|---------------|-------------------|------------------|\n| `validate_and_resolve_path()` | 0 | `PATH_ERROR_TRAVERSAL`, `PATH_ERROR_TOO_LONG` | Path details in error structure | None |\n| `serve_file_content()` | 0 | `FILE_ERROR_NOT_FOUND`, `FILE_ERROR_PERMISSION` | File path and system error in response | Close file handle if opened |\n| `detect_mime_type()` | 0 | Non-zero for unknown types | Uses default MIME type | None |\n\n> **Decision: Structured Error Codes vs. Exception-Style Error Handling**\n> - **Context**: Components need to communicate detailed error information while maintaining C compatibility and performance\n> - **Options Considered**:\n>   1. Simple integer return codes with global error state\n>   2. Structured error objects with detailed context\n>   3. Exception-style error handling (not available in C)\n> - **Decision**: Structured error codes with component-specific error information\n> - **Rationale**: Provides detailed error context for generating appropriate HTTP responses while maintaining C compatibility and avoiding global state that complicates threading\n> - **Consequences**: Requires more complex error handling code but enables better error responses and debugging\n\n#### Error Response Generation Pipeline\n\nWhen any component detects an error condition, it must be transformed into an appropriate HTTP response that provides useful information to the client while avoiding information disclosure that could aid attackers. The error response generation pipeline ensures consistent error formatting and appropriate security filtering.\n\n**Error-to-Response Transformation Process:**\n\n1. **Error Context Collection**: The component detecting the error collects relevant context information including error type, severity, affected resource, and any client-safe details that might help with debugging.\n\n2. **Security Filtering**: The error pipeline calls security filtering functions to remove sensitive information like internal file paths, system error messages that might reveal server configuration, and other implementation details.\n\n3. **HTTP Status Code Selection**: Based on the error category and specific error type, the pipeline selects the most appropriate HTTP status code from the standard set (400 Bad Request, 403 Forbidden, 404 Not Found, 500 Internal Server Error, etc.).\n\n4. **Error Response Construction**: The pipeline calls `generate_error_response()` to create a complete `HTTPResponse` structure with the appropriate status code, standard error headers, and a formatted error message body.\n\n5. **Error Logging**: Before returning the error response to the client, the pipeline logs the complete error details (including sensitive information) to the server's error log for debugging and security monitoring.\n\n**Standard Error Response Format:**\n\n```\nHTTP/1.1 [Status Code] [Status Text]\nContent-Type: text/html\nContent-Length: [Body Length]\nConnection: close\n\n<!DOCTYPE html>\n<html>\n<head><title>[Status Code] [Status Text]</title></head>\n<body>\n<h1>[Status Code] [Status Text]</h1>\n<p>[Client-safe error description]</p>\n<hr>\n<p>[Server identification]</p>\n</body>\n</html>\n```\n\n**Error Response Examples by Category:**\n\n| Error Source | Status Code | Client Message | Internal Log Message |\n|--------------|-------------|----------------|---------------------|\n| Path traversal attempt | 403 Forbidden | \"Access to the requested resource is forbidden\" | \"Directory traversal attempt: /app/docs/../../../etc/passwd from 192.168.1.100\" |\n| File not found | 404 Not Found | \"The requested resource could not be found\" | \"File not found: /var/www/html/missing.html (resolved from /missing.html)\" |\n| Request too large | 413 Request Entity Too Large | \"Request size exceeds server limits\" | \"Request size 16384 exceeds MAX_REQUEST_SIZE 8192 from 192.168.1.100\" |\n| Resource exhaustion | 503 Service Unavailable | \"Server temporarily unable to handle request\" | \"Thread pool exhausted: 10/10 threads active, connection queue full\" |\n\n#### Error Recovery and Connection State Management\n\nError recovery in our HTTP server follows different strategies depending on the error severity and the stage of request processing where the error occurred. The goal is to maintain system stability while providing useful feedback to clients and maintaining clear resource cleanup responsibilities.\n\n**Connection State During Error Recovery:**\n\n| Error Stage | Connection State | Recovery Action | Resource Cleanup Required |\n|-------------|------------------|-----------------|---------------------------|\n| Pre-request (TCP connection) | Connection established but no request received | Send 408 Request Timeout, close connection | Close client socket, free connection context |\n| Request parsing | Partial request received, parsing failed | Send 400 Bad Request, close connection | Free request buffers, close socket |\n| File handling | Valid request, file operation failed | Send appropriate 4xx/5xx error, keep connection open | Free response buffers, but keep connection |\n| Response transmission | Response generated, send failed | Log error, close connection | Free all response resources, close socket |\n\n**Graceful Degradation Strategies:**\n\nWhen the server encounters resource exhaustion or other capacity-related errors, it implements graceful degradation rather than hard failures:\n\n1. **Connection Queuing**: When the thread pool is full, new connections can be queued for a limited time rather than immediately rejected.\n\n2. **Reduced Functionality**: Under high load, the server might disable non-essential features like directory listings or detailed error messages to conserve resources.\n\n3. **Request Prioritization**: Static file requests for small resources might be prioritized over large file downloads during capacity constraints.\n\n4. **Circuit Breaker Pattern**: If filesystem errors reach a threshold, the server might temporarily return 503 Service Unavailable for all requests to prevent cascading failures.\n\n**Error Propagation Chain Example:**\n\nConsider a request for `/documents/../../../etc/passwd` and how the error propagates through the system:\n\n1. **HTTP Parser**: Successfully parses the request, creates valid `HTTPRequest` structure with path `/documents/../../../etc/passwd`\n2. **File Handler**: Calls `normalize_path()` which resolves to `/etc/passwd`, then `validate_and_resolve_path()` detects this is outside document root\n3. **Security Error Generation**: File handler creates security error with type `PATH_ERROR_TRAVERSAL` and context information\n4. **Error Response Pipeline**: Maps security error to 403 Forbidden status, generates safe client message\n5. **Security Logging**: Logs full attack details including client IP, requested path, and resolved path to security log\n6. **Connection Continuation**: Returns error response to client but keeps connection open for additional requests\n\nThis error propagation chain demonstrates how security errors are handled with appropriate response codes while maintaining detailed internal logging for security monitoring and attack detection.\n\n### Implementation Guidance\n\nThe interactions and data flow implementation requires careful orchestration of multiple components working together. This section provides the infrastructure and patterns needed to coordinate TCP server, HTTP parser, file handler, and concurrency manager components effectively.\n\n#### Technology Recommendations\n\n| Component Integration | Simple Option | Advanced Option |\n|----------------------|---------------|-----------------|\n| Inter-component Communication | Direct function calls with error codes | Message passing with error queues |\n| Error Handling | Return codes with errno-style error state | Structured error objects with context |\n| Resource Management | Manual cleanup with goto error handling | RAII-style cleanup with cleanup functions |\n| Data Flow Monitoring | Simple printf debugging | Structured logging with request tracing |\n\n#### Recommended File Structure\n\n```\nhttp-server/\n  src/\n    main.c                      ← Main server loop and component coordination\n    connection_handler.c         ← Complete request-response cycle implementation\n    error_handling.c            ← Error response generation and propagation\n    \n  include/\n    server_types.h              ← All data structure definitions\n    component_interfaces.h      ← Function signatures for component communication\n    error_codes.h               ← Error type definitions and response mappings\n    \n  components/\n    tcp_server/                 ← TCP server component (from previous sections)\n    http_parser/                ← HTTP parser component  \n    file_handler/               ← File handler component\n    concurrency_manager/        ← Concurrency management component\n    \n  tests/\n    integration_tests.c         ← Full request-response cycle tests\n    error_handling_tests.c      ← Error propagation and recovery tests\n```\n\n#### Infrastructure Starter Code\n\n**Complete Error Response Generation System** (ready to use):\n\n```c\n// error_handling.c - Complete error response infrastructure\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include \"server_types.h\"\n#include \"error_codes.h\"\n\n// Error code to HTTP status mapping\nstatic const struct {\n    int error_code;\n    int http_status;\n    const char* status_text;\n    const char* client_message;\n} error_mappings[] = {\n    {PATH_ERROR_TRAVERSAL, 403, \"Forbidden\", \"Access to the requested resource is forbidden\"},\n    {PATH_ERROR_TOO_LONG, 414, \"URI Too Long\", \"The requested URI is too long\"},\n    {FILE_ERROR_NOT_FOUND, 404, \"Not Found\", \"The requested resource could not be found\"},\n    {FILE_ERROR_PERMISSION, 403, \"Forbidden\", \"Access to the requested resource is forbidden\"},\n    {PARSE_ERROR_INVALID_METHOD, 405, \"Method Not Allowed\", \"The request method is not supported\"},\n    {PARSE_ERROR_INVALID_PATH, 400, \"Bad Request\", \"The request path contains invalid characters\"},\n    {PARSE_ERROR_MALFORMED_HEADER, 400, \"Bad Request\", \"The request contains malformed headers\"},\n    {PARSE_ERROR_BODY_TOO_LARGE, 413, \"Request Entity Too Large\", \"Request size exceeds server limits\"},\n    {CAPACITY_ERROR_THREAD_POOL, 503, \"Service Unavailable\", \"Server temporarily unable to handle request\"},\n    {CAPACITY_ERROR_CONNECTION_LIMIT, 503, \"Service Unavailable\", \"Server connection limit reached\"},\n    {0, 500, \"Internal Server Error\", \"An internal server error occurred\"} // Default\n};\n\nvoid generate_error_response(int error_code, const char* error_context, HTTPResponse* response) {\n    // Find appropriate error mapping\n    const struct error_mapping* mapping = &error_mappings[0]; // Default to last entry\n    for (int i = 0; error_mappings[i].error_code != 0; i++) {\n        if (error_mappings[i].error_code == error_code) {\n            mapping = &error_mappings[i];\n            break;\n        }\n    }\n    \n    // Initialize response structure\n    init_http_response(response);\n    response->status_code = mapping->http_status;\n    strncpy(response->status_text, mapping->status_text, sizeof(response->status_text) - 1);\n    \n    // Add standard headers\n    add_response_header(response, \"Content-Type\", \"text/html\");\n    add_response_header(response, \"Connection\", \"close\");\n    \n    // Generate HTML error page\n    char error_body[1024];\n    snprintf(error_body, sizeof(error_body),\n        \"<!DOCTYPE html>\\n\"\n        \"<html>\\n\"\n        \"<head><title>%d %s</title></head>\\n\"\n        \"<body>\\n\"\n        \"<h1>%d %s</h1>\\n\"\n        \"<p>%s</p>\\n\"\n        \"<hr>\\n\"\n        \"<p>HTTP Server/1.0</p>\\n\"\n        \"</body>\\n\"\n        \"</html>\\n\",\n        mapping->http_status, mapping->status_text,\n        mapping->http_status, mapping->status_text,\n        mapping->client_message);\n    \n    // Set response body\n    response->body_length = strlen(error_body);\n    response->body = malloc(response->body_length + 1);\n    if (response->body) {\n        strcpy(response->body, error_body);\n        \n        // Add Content-Length header\n        char content_length[32];\n        snprintf(content_length, sizeof(content_length), \"%zu\", response->body_length);\n        add_response_header(response, \"Content-Length\", content_length);\n    }\n}\n\n// Security event logging\nvoid log_security_event(const char* event_type, const char* client_ip, \n                       const char* request_path, const char* details) {\n    time_t now = time(NULL);\n    char timestamp[32];\n    strftime(timestamp, sizeof(timestamp), \"%Y-%m-%d %H:%M:%S\", localtime(&now));\n    \n    fprintf(stderr, \"[%s] SECURITY %s: client=%s path=%s details=%s\\n\",\n            timestamp, event_type, client_ip, request_path, details);\n}\n\n// Request context for error tracking\ntypedef struct {\n    ConnectionContext* connection;\n    HTTPRequest* request;\n    char client_ip[INET_ADDRSTRLEN];\n    time_t start_time;\n} RequestContext;\n\nvoid init_request_context(RequestContext* ctx, ConnectionContext* conn, HTTPRequest* req) {\n    ctx->connection = conn;\n    ctx->request = req;\n    ctx->start_time = time(NULL);\n    \n    // Convert client address to string for logging\n    inet_ntop(AF_INET, &conn->client_addr.sin_addr, ctx->client_ip, sizeof(ctx->client_ip));\n}\n```\n\n**Complete Connection Lifecycle Management** (ready to use):\n\n```c\n// connection_handler.c - Request-response cycle coordination\n#include \"server_types.h\"\n#include \"component_interfaces.h\"\n#include \"error_codes.h\"\n\n// Resource cleanup with error safety\ntypedef struct {\n    HTTPRequest* request;\n    HTTPResponse* response; \n    ConnectionContext* connection;\n    int client_fd;\n    int cleanup_flags;\n} ResourceCleanupContext;\n\n#define CLEANUP_REQUEST  (1 << 0)\n#define CLEANUP_RESPONSE (1 << 1)\n#define CLEANUP_CONNECTION (1 << 2)\n#define CLEANUP_SOCKET (1 << 3)\n\nvoid cleanup_request_resources(ResourceCleanupContext* cleanup) {\n    if (cleanup->cleanup_flags & CLEANUP_REQUEST && cleanup->request) {\n        cleanup_http_request(cleanup->request);\n        free(cleanup->request);\n        cleanup->request = NULL;\n    }\n    \n    if (cleanup->cleanup_flags & CLEANUP_RESPONSE && cleanup->response) {\n        cleanup_http_response(cleanup->response);\n        free(cleanup->response);\n        cleanup->response = NULL;\n    }\n    \n    if (cleanup->cleanup_flags & CLEANUP_SOCKET && cleanup->client_fd >= 0) {\n        close(cleanup->client_fd);\n        cleanup->client_fd = -1;\n    }\n    \n    if (cleanup->cleanup_flags & CLEANUP_CONNECTION && cleanup->connection) {\n        cleanup_connection_context(cleanup->connection);\n        free(cleanup->connection);\n        cleanup->connection = NULL;\n    }\n}\n\n// Connection state machine for error recovery\ntypedef enum {\n    CONNECTION_READING_REQUEST,\n    CONNECTION_PARSING_REQUEST,\n    CONNECTION_HANDLING_REQUEST,\n    CONNECTION_SENDING_RESPONSE,\n    CONNECTION_CLEANUP,\n    CONNECTION_ERROR\n} ConnectionState;\n\nconst char* connection_state_names[] = {\n    \"READING_REQUEST\", \"PARSING_REQUEST\", \"HANDLING_REQUEST\",\n    \"SENDING_RESPONSE\", \"CLEANUP\", \"ERROR\"\n};\n```\n\n#### Core Logic Skeleton Code\n\n**Main Request-Response Orchestration** (implement the TODOs):\n\n```c\n// Main connection handling thread function\nvoid* handle_client_connection(void* arg) {\n    ConnectionContext* conn_ctx = (ConnectionContext*)arg;\n    ResourceCleanupContext cleanup = {0};\n    RequestContext req_ctx = {0};\n    ConnectionState state = CONNECTION_READING_REQUEST;\n    int error_code = 0;\n    \n    // Initialize cleanup context\n    cleanup.connection = conn_ctx;\n    cleanup.client_fd = conn_ctx->client_fd;\n    cleanup.cleanup_flags = CLEANUP_CONNECTION | CLEANUP_SOCKET;\n    \n    // TODO 1: Set socket timeout options for client_fd\n    // Use setsockopt() with SO_RCVTIMEO and SO_SNDTIMEO\n    // Set both receive and send timeouts to request_timeout_sec from ServerConfig\n    \n    // TODO 2: Allocate HTTPRequest and HTTPResponse structures\n    // Use malloc() and set cleanup flags appropriately\n    // Call init_http_request() and init_http_response() for safe defaults\n    \n    // TODO 3: Initialize request context for error tracking\n    // Call init_request_context() with connection and request pointers\n    // This enables detailed logging if errors occur\n    \n    // Main request processing state machine\n    while (state != CONNECTION_CLEANUP && state != CONNECTION_ERROR) {\n        switch (state) {\n            case CONNECTION_READING_REQUEST: {\n                // TODO 4: Read complete HTTP request from socket\n                // Call read_complete_request() with appropriate buffer and size limits\n                // Handle partial reads by calling in loop until complete request received\n                // Set error_code and state = CONNECTION_ERROR if reading fails\n                \n                if (/* request reading succeeded */) {\n                    state = CONNECTION_PARSING_REQUEST;\n                } else {\n                    // TODO 5: Generate 408 Request Timeout or 400 Bad Request response\n                    // Use generate_error_response() with appropriate error code\n                    // Set state = CONNECTION_SENDING_RESPONSE to send error back to client\n                }\n                break;\n            }\n            \n            case CONNECTION_PARSING_REQUEST: {\n                // TODO 6: Parse raw request data into HTTPRequest structure\n                // Call parse_http_request() with raw buffer and HTTPRequest pointer\n                // Handle parsing errors by checking return code and setting error_code\n                \n                if (/* parsing succeeded */) {\n                    state = CONNECTION_HANDLING_REQUEST;\n                } else {\n                    // TODO 7: Generate appropriate parsing error response (400, 405, etc.)\n                    // Use error_code returned from parser to select correct HTTP status\n                    // Log security events for suspicious requests (oversized, malformed)\n                }\n                break;\n            }\n            \n            case CONNECTION_HANDLING_REQUEST: {\n                // TODO 8: Process request through file handler\n                // Call serve_static_file() with request, response, and server config\n                // Handle file serving errors (404, 403) by checking return codes\n                \n                if (/* file serving succeeded */) {\n                    state = CONNECTION_SENDING_RESPONSE;\n                } else {\n                    // TODO 9: File handler should have populated error response\n                    // Verify response structure contains appropriate error status code\n                    // Log file access attempts for security monitoring\n                }\n                break;\n            }\n            \n            case CONNECTION_SENDING_RESPONSE: {\n                // TODO 10: Send complete HTTP response back to client\n                // Serialize response structure into wire format (status line + headers + body)\n                // Handle partial writes by calling send() in loop until all bytes transmitted\n                // Set appropriate error codes if transmission fails\n                \n                state = CONNECTION_CLEANUP;\n                break;\n            }\n        }\n    }\n    \n    // TODO 11: Perform cleanup based on cleanup context flags\n    // Call cleanup_request_resources() to release all allocated resources\n    // Ensure cleanup happens even if errors occurred during processing\n    // Log connection completion with timing and status information\n    \n    // TODO 12: Notify concurrency manager of connection completion\n    // Call decrement_connection_count() to update resource tracking\n    // Enable server to accept new connections if limits were reached\n    \n    return NULL;\n}\n```\n\n**Error Propagation Integration Points** (implement the TODOs):\n\n```c\n// Component error handling integration\nint process_request_with_error_handling(HTTPRequest* request, HTTPResponse* response, \n                                       ServerConfig* config, RequestContext* req_ctx) {\n    int result = 0;\n    \n    // TODO 1: Attempt file serving with comprehensive error capture\n    // Call serve_static_file() and capture both return code and any error context\n    // Check for security violations (directory traversal, permission issues)\n    \n    if (/* serve_static_file succeeded */) {\n        return 0; // Success\n    }\n    \n    // TODO 2: Classify error type and severity\n    // Map component-specific error codes to error categories\n    // Determine if error requires security logging or just standard error response\n    \n    switch (/* error classification */) {\n        case SECURITY_ERROR:\n            // TODO 3: Log security event with full context\n            // Include client IP, requested path, attack type, timestamp\n            // Use log_security_event() with appropriate event classification\n            break;\n            \n        case RESOURCE_ERROR:\n            // TODO 4: Log resource access issue\n            // Include file path (sanitized), permission details, filesystem error\n            // Check if this indicates a configuration problem\n            break;\n            \n        case CAPACITY_ERROR:\n            // TODO 5: Update server health metrics\n            // Track resource exhaustion events for monitoring\n            // Consider implementing backpressure or rate limiting\n            break;\n    }\n    \n    // TODO 6: Generate appropriate error response for client\n    // Use generate_error_response() with error code and safe context information\n    // Ensure response includes appropriate HTTP status and client-safe message\n    \n    return result;\n}\n```\n\n#### Milestone Checkpoints\n\n**After implementing component integration:**\n- **Command**: `./http-server 8080 /var/www/html`\n- **Test**: `curl -v http://localhost:8080/index.html`\n- **Expected**: Complete HTTP response with headers, body content, proper connection handling\n- **Debug**: Check that all cleanup functions are called, no file descriptors leaked\n\n**After implementing error handling:**\n- **Command**: `curl -v http://localhost:8080/../../../etc/passwd`\n- **Expected**: 403 Forbidden response, security event logged, connection remains open\n- **Debug**: Verify security logging captures attack attempts with client IP and details\n\n**After implementing complete request-response cycle:**\n- **Concurrent Test**: Run multiple `curl` commands simultaneously\n- **Expected**: All requests complete successfully, proper resource cleanup\n- **Debug**: Monitor with `lsof` to verify no file descriptor leaks under load\n\n\n## Error Handling and Edge Cases\n\n> **Milestone(s):** All Milestones 1-4 - provides comprehensive error handling strategy that spans TCP connections, HTTP parsing, file system operations, and concurrent request management\n\nRobust error handling forms the backbone of any production-quality HTTP server. Think of error handling as the hospital's emergency response system - when things go wrong, there must be clear protocols for diagnosis, treatment, and recovery that prevent cascading failures from bringing down the entire system. Just as a hospital has different response procedures for minor injuries versus life-threatening emergencies, our HTTP server must classify errors by severity and respond appropriately.\n\nThe challenge in HTTP server error handling lies in the distributed nature of failures. Errors can originate from network connectivity issues, malformed client requests, filesystem problems, resource exhaustion, or concurrent access conflicts. Each error source requires different detection mechanisms, recovery strategies, and user-facing responses. The server must maintain service availability for healthy connections while gracefully handling problematic ones.\n\n### Error Categories\n\nUnderstanding error classification provides the foundation for systematic error handling. Different error categories require different detection methods, recovery strategies, and HTTP status code mappings. This classification system enables consistent error handling across all server components.\n\n**Network Layer Errors** represent the most fundamental category since they affect the basic communication channel between client and server. These errors occur during socket operations, connection management, and data transmission. Network errors often indicate external conditions beyond the server's control, such as client disconnections, network timeouts, or system resource limitations.\n\n**Protocol Layer Errors** emerge during HTTP message parsing and protocol compliance checking. These errors indicate malformed requests, unsupported HTTP features, or protocol violations by clients. Unlike network errors, protocol errors usually result from client implementation problems or malicious requests rather than infrastructure issues.\n\n**Application Layer Errors** occur during request processing, specifically file system operations and path resolution. These errors indicate problems with the requested resources, security violations, or server configuration issues. Application errors often require detailed logging for security monitoring since they may indicate attack attempts.\n\n**Resource Management Errors** arise from system resource exhaustion, memory allocation failures, or concurrency limits being exceeded. These errors indicate server capacity issues and often require immediate load shedding or graceful degradation to maintain service for existing connections.\n\n**Security Errors** represent a special category that spans multiple layers but requires elevated attention due to their potential security implications. Directory traversal attempts, permission violations, and suspicious request patterns fall into this category and trigger additional logging and monitoring.\n\n| Error Category | Typical Causes | Detection Method | Immediate Response | Recovery Strategy |\n|---|---|---|---|---|\n| Network Layer | Connection drops, socket errors, timeouts | System call return codes, errno values | Close connection, cleanup resources | Retry for transient errors, log persistent issues |\n| Protocol Layer | Malformed requests, invalid headers, unsupported methods | Parser state machine errors, validation failures | Generate 4xx error response | Continue processing other connections |\n| Application Layer | File not found, permission denied, path resolution failures | File system API errors, security validation | Generate 4xx/5xx error response | Log security events, continue serving |\n| Resource Management | Memory exhaustion, thread pool full, file descriptor limits | Resource allocation failures, capacity checks | Reject new connections, return 503 responses | Implement backpressure, graceful degradation |\n| Security | Directory traversal, suspicious patterns, access violations | Path validation, pattern detection | Block request, log security event | Update security rules, potential IP blocking |\n\nThe error category determines the appropriate logging level, response generation strategy, and resource cleanup requirements. Network layer errors typically require connection termination and resource cleanup but minimal logging since they're often transient. Protocol layer errors generate HTTP error responses and moderate logging for debugging purposes. Application layer errors trigger detailed request logging for troubleshooting. Resource management errors initiate capacity management procedures and high-priority alerts. Security errors activate comprehensive logging and monitoring workflows.\n\n> **Critical Design Insight**: Error classification must happen as early as possible in the request processing pipeline. Early classification enables appropriate resource allocation for error handling and prevents resource waste on requests that will ultimately fail. The classification also determines whether the error represents a recoverable condition or requires connection termination.\n\n### HTTP Error Response Generation\n\nConverting internal system errors into appropriate HTTP status codes and error responses requires a systematic mapping strategy. The HTTP specification provides standardized status codes that communicate error conditions to clients in a universally understood format. However, the mapping between internal error states and HTTP responses must balance informativeness with security considerations.\n\n**Status Code Selection Strategy** follows HTTP semantic conventions while considering security implications. The server must provide enough information for legitimate clients to understand and potentially retry requests, while avoiding information disclosure that could assist attackers. This balance influences both status code selection and error message content.\n\nThe `generate_error_response` function serves as the central error response factory, ensuring consistent formatting and appropriate security filtering across all error conditions. This centralized approach prevents inconsistent error handling and ensures security policies apply uniformly.\n\n| Internal Error Type | HTTP Status Code | Status Text | Response Body Strategy | Security Considerations |\n|---|---|---|---|---|\n| `FILE_ERROR_NOT_FOUND` | 404 | Not Found | Generic \"Resource not found\" message | Never reveal internal path structure |\n| `FILE_ERROR_PERMISSION` | 403 | Forbidden | Generic \"Access denied\" message | Don't distinguish between non-existent and forbidden |\n| `PATH_ERROR_TRAVERSAL` | 400 | Bad Request | Generic \"Invalid request\" message | Don't reveal security validation details |\n| `PATH_ERROR_TOO_LONG` | 414 | Request-URI Too Long | Standard HTTP message | Safe to be specific about length limits |\n| `PARSE_ERROR_INVALID_METHOD` | 405 | Method Not Allowed | Include Allow header with supported methods | Include proper Allow header for compliance |\n| `PARSE_ERROR_MALFORMED_HEADER` | 400 | Bad Request | Generic \"Malformed request\" message | Don't reveal parsing implementation details |\n| `CAPACITY_ERROR_THREAD_POOL` | 503 | Service Unavailable | Include Retry-After header | Indicate temporary condition to encourage retry |\n| Socket read/write errors | 500 | Internal Server Error | Generic server error message | Never expose internal error details |\n| Memory allocation failures | 500 | Internal Server Error | Generic server error message | Resource exhaustion details are internal |\n\nThe error response generation process follows a structured approach to ensure consistency and security compliance. First, the error classification determines the appropriate HTTP status code family (4xx for client errors, 5xx for server errors). Second, the specific status code selection considers both HTTP semantics and security implications. Third, the response body generation applies security filtering to prevent information disclosure while providing actionable information for legitimate clients.\n\n**Error Response Structure** maintains consistency across all error conditions. Every error response includes standard HTTP headers, properly formatted status lines, and sanitized response bodies. The response structure includes security headers that apply regardless of error type, ensuring consistent security posture.\n\n```c\ntypedef struct {\n    int status_code;           // HTTP status code (400-599 range)\n    char status_text[64];      // Standard HTTP reason phrase\n    char error_type[32];       // Internal error classification\n    char sanitized_message[256]; // Security-filtered user message\n    int include_retry_after;   // Whether to include Retry-After header\n    int retry_seconds;         // Retry-After header value\n} ErrorResponse;\n```\n\nThe error response generation algorithm ensures consistent processing while allowing customization for specific error types:\n\n1. **Error Classification**: Determine the error category and internal error type from the failure condition\n2. **Status Code Mapping**: Apply the status code mapping table to select the appropriate HTTP response code\n3. **Message Sanitization**: Filter the error message to remove internal implementation details and potential security information\n4. **Header Generation**: Include standard error response headers plus any error-specific headers like Retry-After or Allow\n5. **Response Assembly**: Construct the complete HTTP response with proper formatting and content length calculation\n6. **Security Header Injection**: Add security-related headers that apply to all error responses\n7. **Logging Coordination**: Ensure error logging occurs with appropriate detail level before response transmission\n\n> **Decision: Centralized Error Response Generation**\n> - **Context**: Error responses must be consistent across all server components while maintaining security filtering and proper HTTP compliance\n> - **Options Considered**: Component-specific error handling, centralized error factory, hybrid approach with component customization\n> - **Decision**: Centralized error response factory with configurable message templates\n> - **Rationale**: Centralized generation ensures consistent security filtering, HTTP compliance, and response formatting while allowing customization through error type classification\n> - **Consequences**: All components must use the central error factory, but this ensures security policies apply uniformly and reduces code duplication\n\n**Security-Aware Error Messaging** prevents information disclosure while providing actionable feedback. The error message generation process applies multiple filtering layers to remove sensitive information that could assist attackers or reveal implementation details. Internal error messages contain full diagnostic information for logging and debugging, while external error messages provide only sanitized, user-appropriate information.\n\nThe message sanitization process removes file system paths, internal error codes, memory addresses, configuration details, and other implementation-specific information from user-facing error messages. This filtering happens automatically in the `generate_error_response` function, ensuring consistent security posture regardless of which component detected the error.\n\n![Error Handling and Recovery](./diagrams/error-handling-flow.svg)\n\n### Resource Cleanup Strategies\n\nProper resource cleanup becomes critical when errors occur, as failed request processing can leave allocated resources in an inconsistent state. Think of resource cleanup like the closing procedures at a restaurant - when something goes wrong during service, there must be clear protocols for clearing tables, returning borrowed items, and resetting the space for the next customer. Without systematic cleanup, resources accumulate and eventually exhaust system capacity.\n\nThe challenge in error-time resource cleanup lies in maintaining consistency across multiple resource types while handling partial failures. A single request may involve socket file descriptors, heap-allocated memory, temporary buffers, file handles, thread resources, and connection context structures. When an error occurs partway through processing, some resources may be allocated while others remain uninitialized, requiring careful tracking and conditional cleanup.\n\n**Resource Ownership Tracking** establishes clear responsibility for resource lifecycle management. Each resource must have a single owner responsible for both allocation and deallocation. The `ResourceCleanupContext` structure provides a centralized tracking mechanism that records resource allocation and coordinates cleanup activities across error conditions.\n\n| Resource Type | Allocation Owner | Cleanup Trigger | Cleanup Method | Failure Handling |\n|---|---|---|---|---|\n| Client Socket FD | TCP Server Component | Connection termination | `close()` system call | Log error, continue cleanup |\n| Request Memory | HTTP Parser Component | Request processing completion | `free()` heap memory | Mark as freed, continue |\n| Response Memory | File Handler Component | Response transmission completion | `free()` heap memory | Mark as freed, continue |\n| File Handles | File Handler Component | File serving completion | `fclose()` file descriptor | Log error, continue cleanup |\n| Thread Resources | Concurrency Manager | Thread termination | `pthread_detach()` or `pthread_join()` | Mark thread as orphaned |\n| Connection Context | Connection Manager | Connection lifecycle end | `cleanup_connection_context()` | Free partial state |\n\nThe `ResourceCleanupContext` structure maintains comprehensive resource tracking throughout request processing. This tracking enables systematic cleanup even when errors occur at any point in the request handling pipeline. The cleanup context uses bit flags to indicate which resources require cleanup, allowing the cleanup process to skip unallocated resources safely.\n\n```c\ntypedef struct {\n    HTTPRequest* request;           // NULL if not allocated\n    HTTPResponse* response;         // NULL if not allocated  \n    ConnectionContext* connection;  // NULL if not allocated\n    int client_fd;                 // -1 if not allocated\n    int cleanup_flags;             // Bitmask indicating allocated resources\n    time_t error_time;             // When error occurred for timeout tracking\n    char error_context[256];       // Description of error location\n} ResourceCleanupContext;\n```\n\nThe cleanup flags use bit manipulation to efficiently track resource allocation status. This approach provides O(1) checking for resource status and enables atomic updates to allocation state. The flag definitions correspond to the major resource categories that require explicit cleanup.\n\n| Cleanup Flag | Resource Indicates | Set When | Cleared When | Used By |\n|---|---|---|---|---|\n| `CLEANUP_REQUEST` | HTTPRequest allocated | `init_http_request()` succeeds | `cleanup_http_request()` completes | HTTP Parser Component |\n| `CLEANUP_RESPONSE` | HTTPResponse allocated | `init_http_response()` succeeds | `cleanup_http_response()` completes | File Handler Component |\n| `CLEANUP_CONNECTION` | ConnectionContext allocated | `init_connection_context()` succeeds | `cleanup_connection_context()` completes | Connection Manager |\n| `CLEANUP_SOCKET` | Client socket open | `accept()` succeeds | `close()` completes | TCP Server Component |\n\n**Cleanup Sequencing** ensures resources are released in the correct order to avoid dependency violations and potential crashes. Some resources depend on others remaining valid during cleanup, requiring careful ordering of deallocation operations. The cleanup sequence follows the reverse order of allocation, ensuring dependencies remain valid throughout the cleanup process.\n\nThe systematic cleanup algorithm processes resources in dependency order while handling partial cleanup failures gracefully:\n\n1. **Error Detection and Context Initialization**: When an error occurs, initialize a `ResourceCleanupContext` structure with the current resource allocation state and error details\n2. **Response Resource Cleanup**: If response resources were allocated, call `cleanup_http_response()` to free response body memory and reset response structure\n3. **Request Resource Cleanup**: If request resources were allocated, call `cleanup_http_request()` to free request body memory and header storage\n4. **File Handle Cleanup**: If file handles remain open from file serving operations, close them and log any cleanup failures\n5. **Connection Context Cleanup**: If connection context was allocated, call `cleanup_connection_context()` to free connection-specific memory and reset state\n6. **Socket Cleanup**: If the client socket remains open, close the file descriptor and log the connection termination\n7. **Thread Resource Cleanup**: If thread-specific resources were allocated, detach or join threads as appropriate for the concurrency model\n8. **Cleanup Verification**: Verify all resources marked for cleanup have been properly released and log any cleanup failures for debugging\n\n> **Decision: RAII-Style Cleanup with Explicit Context**\n> - **Context**: C lacks automatic resource management, requiring explicit cleanup coordination across error paths\n> - **Options Considered**: Manual cleanup at each error site, cleanup callback registration, centralized cleanup context\n> - **Decision**: Centralized cleanup context with explicit resource tracking and ordered cleanup\n> - **Rationale**: Centralized context ensures consistent cleanup across all error paths while explicit tracking prevents double-free errors and resource leaks\n> - **Consequences**: All resource allocation must update the cleanup context, but this ensures systematic cleanup regardless of error location\n\n**Error Recovery vs. Connection Termination** requires careful consideration of error severity and recovery feasibility. Some errors allow request processing to continue with degraded functionality, while others require immediate connection termination to prevent further problems. The decision depends on error type, resource state, and potential impact on other connections.\n\n**Recoverable Error Conditions** allow the connection to remain open for additional requests after appropriate error response generation. Protocol-level errors like malformed headers or unsupported methods can generate error responses without affecting the underlying connection. File system errors like missing files or permission problems also allow connection reuse since they don't indicate connection-level problems.\n\n**Non-Recoverable Error Conditions** require immediate connection termination to prevent cascading failures or security breaches. Network-level errors like socket read failures or connection timeouts indicate unreliable communication channels. Resource exhaustion errors suggest system-wide problems that may affect all connections. Security errors like directory traversal attempts may indicate malicious clients requiring immediate disconnection.\n\n| Error Condition | Recovery Strategy | Connection Fate | Resource Priority | Logging Level |\n|---|---|---|---|---|\n| Malformed HTTP headers | Generate 400 response | Keep connection open | Normal cleanup | INFO |\n| File not found | Generate 404 response | Keep connection open | Normal cleanup | DEBUG |\n| Socket read failure | Immediate cleanup | Terminate connection | Emergency cleanup | WARN |\n| Memory allocation failure | Generate 503 response | Terminate connection | Emergency cleanup | ERROR |\n| Directory traversal attempt | Generate 400 response | Terminate connection | Normal cleanup + security log | SECURITY |\n| Thread pool exhaustion | Generate 503 response | Queue for later processing | Delayed cleanup | WARN |\n\nThe recovery strategy selection process considers both immediate error handling and long-term system stability. Recoverable errors focus on providing appropriate client feedback while maintaining connection state for future requests. Non-recoverable errors prioritize system stability and security, sacrificing the individual connection to protect overall server health.\n\n**Emergency Cleanup Procedures** handle situations where normal cleanup processes may fail or take too long. When system resources are critically low or security events require immediate response, emergency cleanup bypasses normal cleanup verification and focuses on rapidly releasing critical resources. Emergency cleanup trades thoroughness for speed, accepting some resource leakage to prevent system-wide failure.\n\nThe emergency cleanup process prioritizes file descriptors and memory over cleanup verification, since these resources most directly impact system capacity. Connection context and thread resources receive lower priority since their leakage has less immediate system impact. Emergency cleanup includes aggressive timeout handling to prevent cleanup operations from blocking system recovery.\n\n### Common Error Handling Pitfalls\n\nUnderstanding typical error handling mistakes helps developers avoid subtle bugs that can cause resource leaks, security vulnerabilities, or service disruption. These pitfalls often arise from the complexity of coordinating cleanup across multiple system components and the edge cases that occur under error conditions.\n\n⚠️ **Pitfall: Double-Close of File Descriptors**\n\nOne of the most common resource management errors involves closing the same file descriptor multiple times. This occurs when error handling code closes a socket or file handle, but subsequent cleanup code attempts to close the same descriptor again. The second close operation may succeed silently, close an unrelated file descriptor that was allocated after the first close, or generate an error that disrupts cleanup of other resources.\n\nThe problem manifests when cleanup code doesn't properly track whether resources have already been released. Multiple code paths may each attempt to close the same descriptor, especially when error handling interrupts normal cleanup sequences. File descriptor reuse by the operating system means the second close may affect a completely different resource, leading to difficult-to-debug corruption.\n\nTo prevent double-close errors, always set file descriptors to -1 after closing them and check for -1 before attempting to close. The cleanup functions should verify descriptor validity and update resource tracking immediately after successful close operations.\n\n⚠️ **Pitfall: Incomplete Error Information in Log Messages**\n\nError log messages often lack sufficient context for effective debugging, making it difficult to reproduce problems or understand their root causes. Generic error messages like \"request failed\" or \"file error\" provide little actionable information when troubleshooting server problems. Missing context information like client IP addresses, request paths, or error timing makes it nearly impossible to correlate errors with specific client behaviors or system conditions.\n\nThis problem occurs when error handling code focuses on resource cleanup without capturing diagnostic information at the error site. By the time cleanup completes, much of the context that would help identify the error cause has been deallocated or overwritten. Error messages that only include system error codes without application-specific context force debugging efforts to rely on external log correlation.\n\nEffective error logging captures error context at the detection site before cleanup begins. Include client identification, request details, system state, and precise error location in all error log entries. Use structured logging formats that enable automated analysis and correlation across multiple error events.\n\n⚠️ **Pitfall: Resource Cleanup Failures Blocking Shutdown**\n\nCleanup operations themselves can fail, potentially blocking server shutdown or causing resource accumulation. When cleanup code encounters errors like filesystem permission problems or network timeouts, it may block indefinitely waiting for cleanup operations to complete. This blocking can prevent graceful shutdown and force administrators to kill server processes, potentially causing data loss or corruption.\n\nThe problem becomes critical during high error rates when many cleanup operations execute simultaneously. If cleanup operations have unbounded timeouts or lack failure handling, a cascade of cleanup failures can overwhelm system resources and prevent recovery. Cleanup code that retries operations indefinitely can consume excessive CPU and memory resources even when the underlying problems are unrecoverable.\n\nImplement timeout-based cleanup with failure tolerance to prevent cleanup operations from blocking system recovery. Cleanup operations should have strict time limits and continue with partial cleanup when individual operations fail. Log cleanup failures for debugging but don't allow them to prevent overall resource release.\n\n⚠️ **Pitfall: Security Information Disclosure in Error Messages**\n\nError messages that include internal system information can provide attackers with valuable reconnaissance data about server implementation, filesystem structure, or security mechanisms. Error messages containing file paths, internal error codes, memory addresses, or configuration details help attackers understand system internals and identify potential attack vectors.\n\nThis information disclosure often occurs when development-focused error messages reach production environments without proper filtering. Database error messages, filesystem paths, stack traces, and internal function names all provide implementation details that assist in attack planning. Even seemingly innocent information like exact file locations or error timing can reveal system structure to determined attackers.\n\nThe solution requires systematic message sanitization that removes internal details while preserving actionable information for legitimate users. Implement separate error message systems for internal logging and external client communication, ensuring sensitive details never reach client-facing error responses.\n\n⚠️ **Pitfall: Memory Leaks During Error Conditions**\n\nMemory allocated during request processing may not be properly freed when errors interrupt normal execution flow. This problem is particularly common in C where manual memory management requires explicit free operations for every malloc. Error conditions that cause early return from functions can skip cleanup code, leading to gradual memory consumption that eventually exhausts system resources.\n\nThe issue compounds during high error rates when many requests encounter problems simultaneously. Each leaked allocation is typically small, making the problem difficult to detect during normal testing. However, sustained error conditions can accumulate significant memory usage that impacts overall system performance and stability.\n\nImplement systematic memory tracking using the cleanup context pattern to ensure all allocations are tracked and freed regardless of error conditions. Use tools like valgrind during development to detect memory leaks and verify cleanup code paths execute properly under error conditions.\n\n### Implementation Guidance\n\nThe error handling implementation requires careful coordination across all server components to ensure consistent behavior and proper resource management. The following guidance provides complete implementations for infrastructure components and detailed skeletons for core error handling logic.\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|---|---|---|\n| Error Logging | Standard C printf to stderr | Structured logging with syslog integration |\n| Resource Tracking | Manual bit flags in cleanup context | Automated RAII-style wrappers |\n| Error Response Generation | Template-based string formatting | JSON-based error response with schema validation |\n\n**Recommended File Structure:**\n```\nsrc/\n  error_handling.h          ← Error types, cleanup context, function declarations\n  error_handling.c          ← Core error handling and cleanup implementation\n  http_errors.h            ← HTTP status code mappings and response generation\n  http_errors.c            ← HTTP error response implementation\n  logging.h                ← Logging interface and security event handling\n  logging.c                ← Logging implementation with different output targets\n  tests/\n    test_error_handling.c   ← Unit tests for error classification and cleanup\n    test_http_errors.c      ← Integration tests for error response generation\n```\n\n**Complete Error Type Infrastructure:**\n```c\n// error_handling.h - Complete error type system ready for use\n\n#include <errno.h>\n#include <time.h>\n#include <pthread.h>\n\n// Error category definitions for systematic classification\ntypedef enum {\n    ERROR_CATEGORY_NETWORK,     // Socket and TCP connection errors\n    ERROR_CATEGORY_PROTOCOL,    // HTTP parsing and protocol violations  \n    ERROR_CATEGORY_APPLICATION, // File system and request processing errors\n    ERROR_CATEGORY_RESOURCE,    // Memory, threads, and capacity errors\n    ERROR_CATEGORY_SECURITY     // Security violations and suspicious activity\n} ErrorCategory;\n\n// Specific error codes within each category\ntypedef enum {\n    // Network layer errors\n    NETWORK_ERROR_CONNECTION_LOST,\n    NETWORK_ERROR_SOCKET_READ,\n    NETWORK_ERROR_SOCKET_WRITE,\n    NETWORK_ERROR_TIMEOUT,\n    \n    // Protocol layer errors  \n    PROTOCOL_ERROR_MALFORMED_REQUEST,\n    PROTOCOL_ERROR_INVALID_METHOD,\n    PROTOCOL_ERROR_UNSUPPORTED_VERSION,\n    PROTOCOL_ERROR_HEADER_TOO_LONG,\n    \n    // Application layer errors\n    APP_ERROR_FILE_NOT_FOUND,\n    APP_ERROR_PERMISSION_DENIED,\n    APP_ERROR_PATH_TRAVERSAL,\n    APP_ERROR_PATH_TOO_LONG,\n    \n    // Resource management errors\n    RESOURCE_ERROR_MEMORY_ALLOCATION,\n    RESOURCE_ERROR_THREAD_POOL_FULL,\n    RESOURCE_ERROR_FD_EXHAUSTION,\n    \n    // Security errors\n    SECURITY_ERROR_SUSPICIOUS_PATH,\n    SECURITY_ERROR_RATE_LIMIT,\n    SECURITY_ERROR_BLOCKED_IP\n} SpecificErrorCode;\n\n// Complete error information structure\ntypedef struct {\n    ErrorCategory category;           // High-level error classification\n    SpecificErrorCode specific_code;  // Detailed error identification\n    int system_errno;                 // System error code if applicable\n    time_t timestamp;                 // When error occurred\n    char client_ip[INET_ADDRSTRLEN];  // Client identification\n    char context_info[256];           // Detailed error context\n    char internal_message[512];       // Full diagnostic information\n    char external_message[256];       // Sanitized user-facing message\n} ErrorInfo;\n\n// Resource cleanup context with comprehensive tracking\ntypedef struct {\n    HTTPRequest* request;\n    HTTPResponse* response;  \n    ConnectionContext* connection;\n    int client_fd;\n    int cleanup_flags;\n    time_t error_time;\n    char error_context[256];\n    pthread_mutex_t cleanup_mutex;    // Thread safety for cleanup\n} ResourceCleanupContext;\n\n// Infrastructure function declarations\nErrorInfo* create_error_info(ErrorCategory category, SpecificErrorCode code, \n                            const char* context);\nvoid log_error_with_context(const ErrorInfo* error);\nvoid log_security_event(const char* event_type, const char* client_ip,\n                        const char* details);\nint cleanup_request_resources(ResourceCleanupContext* cleanup);\nint emergency_cleanup(ResourceCleanupContext* cleanup, int timeout_sec);\n```\n\n**Complete HTTP Error Response Infrastructure:**\n```c\n// http_errors.c - Complete HTTP error response system\n\n#include \"http_errors.h\"\n#include <string.h>\n#include <time.h>\n\n// Status code mapping table - complete and ready to use\ntypedef struct {\n    SpecificErrorCode error_code;\n    int http_status;\n    const char* status_text;\n    const char* template_message;\n    int include_retry_after;\n} ErrorMapping;\n\nstatic const ErrorMapping error_mappings[] = {\n    {APP_ERROR_FILE_NOT_FOUND, 404, \"Not Found\", \"The requested resource was not found\", 0},\n    {APP_ERROR_PERMISSION_DENIED, 403, \"Forbidden\", \"Access to the requested resource is forbidden\", 0},\n    {APP_ERROR_PATH_TRAVERSAL, 400, \"Bad Request\", \"The request contains invalid path information\", 0},\n    {PROTOCOL_ERROR_INVALID_METHOD, 405, \"Method Not Allowed\", \"The request method is not supported\", 0},\n    {PROTOCOL_ERROR_MALFORMED_REQUEST, 400, \"Bad Request\", \"The request is malformed\", 0},\n    {RESOURCE_ERROR_THREAD_POOL_FULL, 503, \"Service Unavailable\", \"The server is temporarily overloaded\", 1},\n    {RESOURCE_ERROR_MEMORY_ALLOCATION, 500, \"Internal Server Error\", \"An internal server error occurred\", 0},\n    {NETWORK_ERROR_TIMEOUT, 408, \"Request Timeout\", \"The request timed out\", 0}\n};\n\n// Complete HTTP error response generation - ready to use\nvoid generate_error_response(int status_code, const char* error_message, HTTPResponse* response) {\n    // Initialize response structure\n    init_http_response(response);\n    \n    // Set status information\n    response->status_code = status_code;\n    \n    // Find appropriate status text\n    const char* status_text = \"Unknown Error\";\n    for (int i = 0; i < sizeof(error_mappings) / sizeof(ErrorMapping); i++) {\n        if (error_mappings[i].http_status == status_code) {\n            status_text = error_mappings[i].status_text;\n            break;\n        }\n    }\n    strncpy(response->status_text, status_text, sizeof(response->status_text) - 1);\n    \n    // Create HTML error page body\n    char html_body[1024];\n    snprintf(html_body, sizeof(html_body),\n        \"<!DOCTYPE html>\\n\"\n        \"<html><head><title>%d %s</title></head>\\n\"\n        \"<body><h1>%d %s</h1>\\n\"\n        \"<p>%s</p>\\n\"\n        \"<hr><p>HTTP Server</p></body></html>\\n\",\n        status_code, status_text, status_code, status_text, error_message);\n    \n    // Allocate and copy response body\n    response->body_length = strlen(html_body);\n    response->body = malloc(response->body_length + 1);\n    if (response->body) {\n        strcpy(response->body, html_body);\n    }\n    \n    // Add standard error response headers\n    add_response_header(response, \"Content-Type\", \"text/html; charset=utf-8\");\n    add_response_header(response, \"Connection\", \"close\");\n    \n    // Add Content-Length header\n    char content_length[32];\n    snprintf(content_length, sizeof(content_length), \"%zu\", response->body_length);\n    add_response_header(response, \"Content-Length\", content_length);\n    \n    // Add security headers\n    add_response_header(response, \"X-Content-Type-Options\", \"nosniff\");\n    add_response_header(response, \"X-Frame-Options\", \"DENY\");\n}\n```\n\n**Core Error Handling Skeleton:**\n```c\n// error_handling.c - Core logic to implement\n\n// Error classification function - implement this\nErrorCategory classify_error(int system_errno, const char* context) {\n    // TODO 1: Check for network-related errno values (ECONNRESET, EPIPE, ETIMEDOUT)\n    //         Return ERROR_CATEGORY_NETWORK for connection issues\n    \n    // TODO 2: Check for file system errno values (ENOENT, EACCES, EPERM)  \n    //         Return ERROR_CATEGORY_APPLICATION for file access issues\n    \n    // TODO 3: Check for resource errno values (ENOMEM, EAGAIN, EMFILE)\n    //         Return ERROR_CATEGORY_RESOURCE for capacity issues\n    \n    // TODO 4: Analyze context string for security indicators\n    //         Look for \"..\" patterns, suspicious characters\n    //         Return ERROR_CATEGORY_SECURITY for potential attacks\n    \n    // TODO 5: Default to ERROR_CATEGORY_PROTOCOL for parsing/HTTP issues\n    //         This handles cases not covered by system errno\n    \n    return ERROR_CATEGORY_PROTOCOL; // Placeholder\n}\n\n// Complete error information creation - implement this  \nErrorInfo* create_error_info(ErrorCategory category, SpecificErrorCode code, const char* context) {\n    // TODO 1: Allocate ErrorInfo structure with malloc, check for NULL return\n    \n    // TODO 2: Set category, specific_code, and current timestamp\n    //         Use time() function for timestamp\n    \n    // TODO 3: Copy context string to context_info field with bounds checking\n    //         Use strncpy to prevent buffer overflow\n    \n    // TODO 4: Set system_errno to current errno value\n    //         Save errno immediately since other calls may modify it\n    \n    // TODO 5: Generate internal_message with full diagnostic details\n    //         Include errno string using strerror(), context, timestamp\n    \n    // TODO 6: Generate external_message with sanitized information  \n    //         Remove internal paths, error codes, implementation details\n    //         Use security-safe generic messages for external consumption\n    \n    return NULL; // Placeholder - return allocated ErrorInfo*\n}\n\n// Resource cleanup with error handling - implement this\nint cleanup_request_resources(ResourceCleanupContext* cleanup) {\n    if (!cleanup) return -1;\n    \n    int cleanup_errors = 0;\n    \n    // TODO 1: Lock cleanup mutex for thread safety\n    //         Use pthread_mutex_lock with error checking\n    \n    // TODO 2: Check CLEANUP_RESPONSE flag and call cleanup_http_response()\n    //         Clear flag after successful cleanup\n    //         Increment cleanup_errors if cleanup fails\n    \n    // TODO 3: Check CLEANUP_REQUEST flag and call cleanup_http_request()\n    //         Clear flag after successful cleanup  \n    //         Increment cleanup_errors if cleanup fails\n    \n    // TODO 4: Check CLEANUP_CONNECTION flag and call cleanup_connection_context()\n    //         Clear flag after successful cleanup\n    //         Increment cleanup_errors if cleanup fails\n    \n    // TODO 5: Check CLEANUP_SOCKET flag and close client_fd if valid (>= 0)\n    //         Set client_fd to -1 after successful close\n    //         Clear CLEANUP_SOCKET flag\n    //         Increment cleanup_errors if close fails\n    \n    // TODO 6: Unlock cleanup mutex\n    //         Use pthread_mutex_unlock\n    \n    // TODO 7: Return 0 for complete success, positive value for partial failures\n    //         Log cleanup errors for debugging but don't fail overall cleanup\n    \n    return cleanup_errors;\n}\n```\n\n**Security Event Logging Infrastructure:**\n```c\n// logging.c - Complete security logging system\n\n#include <syslog.h>\n#include <stdio.h>\n\n// Initialize logging system - complete implementation\nvoid init_logging_system(const char* server_name) {\n    openlog(server_name, LOG_PID | LOG_CONS, LOG_DAEMON);\n}\n\n// Security event logging with context - complete implementation  \nvoid log_security_event(const char* event_type, const char* client_ip, \n                       const char* request_path, const char* details) {\n    char log_message[1024];\n    time_t now = time(NULL);\n    char timestamp[32];\n    strftime(timestamp, sizeof(timestamp), \"%Y-%m-%d %H:%M:%S\", localtime(&now));\n    \n    snprintf(log_message, sizeof(log_message),\n        \"SECURITY_EVENT: %s | Time: %s | Client: %s | Path: %s | Details: %s\",\n        event_type, timestamp, client_ip ? client_ip : \"unknown\", \n        request_path ? request_path : \"none\", details ? details : \"none\");\n    \n    // Log to syslog for centralized security monitoring\n    syslog(LOG_WARNING, \"%s\", log_message);\n    \n    // Also log to stderr for development/debugging\n    fprintf(stderr, \"[SECURITY] %s\\n\", log_message);\n}\n\n// Error logging with full context - complete implementation\nvoid log_error_with_context(const ErrorInfo* error) {\n    if (!error) return;\n    \n    const char* category_names[] = {\n        \"NETWORK\", \"PROTOCOL\", \"APPLICATION\", \"RESOURCE\", \"SECURITY\"\n    };\n    \n    char timestamp[32];\n    strftime(timestamp, sizeof(timestamp), \"%Y-%m-%d %H:%M:%S\", \n             localtime(&error->timestamp));\n    \n    // Determine log level based on category\n    int log_level = LOG_INFO;\n    switch (error->category) {\n        case ERROR_CATEGORY_SECURITY: log_level = LOG_WARNING; break;\n        case ERROR_CATEGORY_RESOURCE: log_level = LOG_ERR; break;\n        case ERROR_CATEGORY_NETWORK: log_level = LOG_INFO; break;\n        default: log_level = LOG_INFO; break;\n    }\n    \n    syslog(log_level, \"ERROR: %s | Time: %s | Client: %s | Context: %s | Details: %s\",\n           category_names[error->category], timestamp, error->client_ip,\n           error->context_info, error->internal_message);\n}\n```\n\n**Milestone Checkpoints:**\n\nAfter implementing error handling:\n\n1. **Test Error Classification**: Create test requests that trigger each error category. Verify correct status codes:\n   ```bash\n   # Test file not found\n   curl -v http://localhost:8080/nonexistent.html\n   # Should return 404 Not Found\n   \n   # Test directory traversal  \n   curl -v http://localhost:8080/../etc/passwd\n   # Should return 400 Bad Request and log security event\n   \n   # Test malformed request\n   echo -e \"INVALID HTTP REQUEST\\r\\n\\r\\n\" | nc localhost 8080\n   # Should return 400 Bad Request\n   ```\n\n2. **Verify Resource Cleanup**: Use process monitoring to confirm no resource leaks:\n   ```bash\n   # Monitor file descriptor usage\n   lsof -p $(pgrep http_server) | wc -l\n   # Count should remain stable under error conditions\n   \n   # Check memory usage under error load\n   ps -p $(pgrep http_server) -o pid,vsz,rss\n   # Memory should not grow continuously during error tests\n   ```\n\n3. **Check Security Logging**: Verify security events appear in logs:\n   ```bash\n   # Check syslog for security events\n   tail -f /var/log/syslog | grep SECURITY_EVENT\n   \n   # Trigger directory traversal and verify logging\n   curl http://localhost:8080/../../../../etc/passwd\n   # Should see security event logged with client IP and path\n   ```\n\n**Debugging Tips:**\n\n| Symptom | Likely Cause | Diagnosis | Fix |\n|---|---|---|---|\n| Server crashes on error | Double-free or NULL pointer access | Run with valgrind, check cleanup order | Add NULL checks, fix cleanup sequence |\n| Memory usage grows over time | Resource leaks in error paths | Use valgrind --leak-check=full | Implement cleanup context tracking |\n| Clients receive generic errors | Error message sanitization too aggressive | Check error mapping table | Add specific but safe error messages |\n| Security events not logged | Logging initialization missing | Check syslog configuration | Call init_logging_system() at startup |\n| Cleanup hangs during shutdown | Cleanup operations blocking indefinitely | Add timeout monitoring | Implement emergency_cleanup() with timeouts |\n\n\n## Testing Strategy\n\n> **Milestone(s):** All Milestones 1-4 - provides verification approach for TCP server basics, HTTP request parsing, static file serving, and concurrent connections with specific test scenarios and expected behaviors\n\nThe testing strategy for an HTTP server requires a systematic approach that verifies functionality at each development milestone while building confidence in the system's reliability and correctness. Think of testing an HTTP server like quality assurance in a restaurant kitchen - you need to verify each station (prep, cooking, plating) works correctly in isolation, then test how they coordinate during a busy dinner rush. Each milestone represents a different level of complexity, from basic socket operations to handling multiple simultaneous diners (clients) with different dietary requirements (HTTP requests).\n\nThe testing approach must balance thorough verification with practical implementation constraints. Unlike production web servers that undergo extensive automated testing suites, this educational HTTP server focuses on milestone-driven verification that builds understanding while ensuring correctness. The testing strategy emphasizes hands-on verification using standard tools that developers commonly use for HTTP server testing and debugging.\n\n### Milestone Verification Checkpoints\n\nEach milestone represents a significant functional capability that must be thoroughly verified before proceeding to the next development phase. The checkpoint approach ensures that fundamental issues are caught early, preventing compound problems that become difficult to diagnose in later milestones. Think of these checkpoints like safety inspections at each floor of a building under construction - you must verify the foundation before adding the framework, and the framework before installing utilities.\n\n#### Milestone 1: TCP Server Basics Verification\n\nThe first milestone verification focuses on the fundamental networking capabilities that form the foundation for all HTTP functionality. At this stage, the server should demonstrate proper socket management, connection handling, and basic request-response cycles without any HTTP protocol awareness.\n\n**Socket Creation and Binding Verification:**\n\nThe initial test verifies that the server can create and configure a listening socket correctly. Start the server and verify it binds to the specified port without errors. Use the `netstat` command to confirm the server socket is in the LISTEN state:\n\n```bash\nnetstat -tlnp | grep :8080\n```\n\nExpected output should show a TCP socket in LISTEN state bound to port 8080. The server should accept the `SO_REUSEADDR` socket option, allowing rapid restart without encountering \"Address already in use\" errors. If binding fails, common causes include port conflicts with other services or insufficient privileges for ports below 1024.\n\n**Connection Acceptance Testing:**\n\nTest the server's ability to accept incoming TCP connections by establishing a raw TCP connection using telnet. This test verifies the accept loop and basic connection handling without HTTP protocol concerns:\n\n```bash\ntelnet localhost 8080\n```\n\nUpon successful connection, telnet should report \"Connected to localhost\" and provide a command prompt. The server should accept the connection without blocking or crashing. Multiple sequential connections should work correctly, demonstrating proper cleanup of previous connections.\n\n**Basic Request-Response Cycle:**\n\nSend a simple string through the telnet connection and verify the server reads the data and responds with a hardcoded HTTP response. At this milestone, the server doesn't need to understand HTTP format - it should read any incoming data and respond with a fixed HTTP-formatted message:\n\nExpected response format:\n```\nHTTP/1.1 200 OK\nContent-Type: text/plain\nContent-Length: 13\n\nHello, World!\n```\n\nThe server should close the connection after sending the response, and telnet should indicate the connection was closed by the remote host.\n\n**Resource Management Verification:**\n\nTest proper cleanup by establishing multiple sequential connections and monitoring file descriptors. Use the `lsof` command to verify the server doesn't leak file descriptors:\n\n```bash\nlsof -p <server_process_id> | grep TCP\n```\n\nAfter each connection closes, the client file descriptor should disappear from the lsof output, indicating proper cleanup.\n\n**Error Handling at TCP Level:**\n\nTest error conditions specific to TCP operations:\n- Start two server instances on the same port - the second should fail gracefully with an appropriate error message\n- Kill the server process and attempt connection - clients should receive connection refused\n- Send data to the server and immediately close the client connection - server should handle the disconnection without crashing\n\n#### Milestone 2: HTTP Request Parsing Verification\n\nThe second milestone verification focuses on the server's ability to parse HTTP requests correctly and respond based on the parsed information. This represents a significant complexity increase from basic TCP handling to protocol-aware request processing.\n\n**HTTP Request Line Parsing:**\n\nTest the server's ability to extract method, path, and version from various HTTP request formats. Use curl to send requests with different methods and paths:\n\n```bash\ncurl -v http://localhost:8080/test/path\ncurl -v -X POST http://localhost:8080/api/endpoint\ncurl -v -X HEAD http://localhost:8080/\n```\n\nThe server should correctly parse each request and potentially log the extracted components. Even if file serving isn't implemented yet, the server should demonstrate it understands the differences between GET, POST, and HEAD requests and can extract the requested path.\n\n**HTTP Header Parsing Testing:**\n\nSend requests with various header configurations to test header parsing robustness:\n\n```bash\ncurl -H \"Host: example.com\" -H \"User-Agent: TestClient/1.0\" http://localhost:8080/\ncurl -H \"Content-Type: application/json\" http://localhost:8080/\n```\n\nThe server should parse headers into key-value pairs and handle common HTTP headers correctly. Test edge cases like headers with extra whitespace around values and headers spanning multiple lines (if supported).\n\n**Malformed Request Handling:**\n\nTest the server's response to malformed HTTP requests using telnet to send malformed data:\n\n- Send incomplete request line: `GET /path` (missing HTTP version)\n- Send malformed headers: `InvalidHeader without colon`\n- Send requests with invalid methods: `INVALID /path HTTP/1.1`\n\nThe server should respond with appropriate HTTP error codes (400 Bad Request) rather than crashing or hanging.\n\n**Content-Length and Body Handling:**\n\nIf body parsing is implemented, test POST requests with message bodies:\n\n```bash\ncurl -X POST -d \"test data\" -H \"Content-Type: text/plain\" http://localhost:8080/\n```\n\nThe server should read the exact number of bytes specified in the Content-Length header and not attempt to read beyond the message body.\n\n#### Milestone 3: Static File Serving Verification\n\nThe third milestone verification tests the server's ability to serve files from the filesystem safely and correctly, implementing the core functionality expected from a static web server.\n\n**Basic File Serving:**\n\nCreate a test directory structure with various file types:\n\n```\ndocument_root/\n  index.html\n  style.css\n  script.js\n  images/\n    logo.png\n    background.jpg\n  documents/\n    readme.txt\n```\n\nTest file retrieval with curl:\n\n```bash\ncurl -v http://localhost:8080/index.html\ncurl -v http://localhost:8080/style.css\ncurl -v http://localhost:8080/images/logo.png\n```\n\nVerify that:\n- Files are served with correct Content-Type headers based on file extensions\n- Content-Length headers match actual file sizes\n- Binary files (images) are served without corruption\n- File contents in the response body match the actual file contents exactly\n\n**Directory Listing Testing:**\n\nTest directory requests to verify directory listing functionality:\n\n```bash\ncurl -v http://localhost:8080/images/\ncurl -v http://localhost:8080/\n```\n\nIf directory listings are implemented, verify they include:\n- Links to all files and subdirectories\n- Proper HTML formatting\n- Parent directory navigation (..)\n- File size and modification time information\n\n**404 Error Handling:**\n\nTest requests for non-existent files:\n\n```bash\ncurl -v http://localhost:8080/nonexistent.html\ncurl -v http://localhost:8080/missing/path/file.txt\n```\n\nThe server should respond with:\n- HTTP 404 Not Found status code\n- Appropriate error page content\n- Proper Content-Type header for the error response\n\n**Security Validation Testing:**\n\nTest directory traversal attack prevention:\n\n```bash\ncurl -v http://localhost:8080/../../../etc/passwd\ncurl -v http://localhost:8080/./../../sensitive_file\ncurl -v \"http://localhost:8080/%2e%2e%2f%2e%2e%2fpasswd\"\n```\n\nThe server should reject these requests with 403 Forbidden or 400 Bad Request responses, never serving files outside the document root directory.\n\n**MIME Type Detection Verification:**\n\nTest various file types to verify correct MIME type detection:\n\n| File Extension | Expected MIME Type | Test Command |\n|---|---|---|\n| .html | text/html | `curl -I http://localhost:8080/test.html` |\n| .css | text/css | `curl -I http://localhost:8080/style.css` |\n| .js | application/javascript | `curl -I http://localhost:8080/script.js` |\n| .png | image/png | `curl -I http://localhost:8080/image.png` |\n| .jpg | image/jpeg | `curl -I http://localhost:8080/photo.jpg` |\n| .txt | text/plain | `curl -I http://localhost:8080/readme.txt` |\n\n#### Milestone 4: Concurrent Connections Verification\n\nThe fourth milestone verification tests the server's ability to handle multiple simultaneous client connections without blocking or corrupting responses. This represents the most complex testing scenario, requiring coordination of multiple clients and verification of correct concurrent behavior.\n\n**Sequential Connection Handling:**\n\nBefore testing true concurrency, verify that multiple sequential connections work correctly:\n\n```bash\nfor i in {1..10}; do\n  curl -s http://localhost:8080/index.html > /dev/null\n  echo \"Request $i completed\"\ndone\n```\n\nAll requests should complete successfully without errors or connection failures.\n\n**Basic Concurrent Connection Testing:**\n\nTest multiple simultaneous connections using background processes:\n\n```bash\nfor i in {1..5}; do\n  curl -s http://localhost:8080/index.html > response_$i.html &\ndone\nwait\n```\n\nVerify that all response files contain identical, correct content and no responses are corrupted or incomplete due to concurrent access.\n\n**Connection Limit Testing:**\n\nTest the server's behavior when the maximum connection limit is reached:\n\n```bash\n# Create connections that stay open briefly\nfor i in {1..20}; do\n  (sleep 2; curl -s http://localhost:8080/) &\ndone\n```\n\nThe server should either queue additional connections (thread pool model) or reject excess connections gracefully rather than crashing or hanging.\n\n**Resource Management Under Load:**\n\nMonitor server resource usage during concurrent load:\n\n```bash\n# Monitor file descriptors\nwatch \"lsof -p <server_pid> | wc -l\"\n\n# Monitor threads (if using threading)\nwatch \"ps -T -p <server_pid>\"\n```\n\nVerify that:\n- File descriptor count returns to baseline after connections close\n- Thread count remains within configured limits\n- Memory usage doesn't grow unboundedly\n- No zombie processes are created\n\n### Testing Tools and Techniques\n\nThe testing strategy relies on a combination of standard HTTP client tools, low-level networking utilities, and custom testing scripts to verify functionality across all complexity levels. Each tool serves specific purposes in the verification process, from basic connectivity testing to detailed HTTP protocol validation.\n\n#### Command-Line HTTP Clients\n\n**curl - Primary HTTP Testing Tool:**\n\ncurl serves as the primary HTTP testing client due to its comprehensive HTTP protocol support and detailed output capabilities. The verbose flag (`-v`) provides essential debugging information including request headers, response headers, and connection details.\n\nCommon curl usage patterns for HTTP server testing:\n\n| Test Purpose | curl Command | Key Flags Explained |\n|---|---|---|\n| Basic request | `curl -v http://localhost:8080/` | `-v` shows request/response headers |\n| HEAD request | `curl -I http://localhost:8080/` | `-I` sends HEAD instead of GET |\n| Custom headers | `curl -H \"Host: test.com\" http://localhost:8080/` | `-H` adds custom header |\n| POST request | `curl -X POST -d \"data\" http://localhost:8080/` | `-X` specifies method, `-d` sends data |\n| Follow redirects | `curl -L http://localhost:8080/redirect` | `-L` follows Location headers |\n| Timeout control | `curl --max-time 5 http://localhost:8080/` | Prevents hanging on slow responses |\n| Save response | `curl -o output.html http://localhost:8080/` | `-o` saves response to file |\n| Show timing | `curl -w \"@curl-format.txt\" http://localhost:8080/` | Custom timing format |\n\n**wget - Alternative HTTP Client:**\n\nwget provides different capabilities useful for testing file download scenarios and recursive retrieval:\n\n```bash\n# Download files recursively\nwget -r --no-parent http://localhost:8080/\n\n# Test resume capability (if implemented)\nwget -c http://localhost:8080/large-file.zip\n\n# Mirror directory structure\nwget -m http://localhost:8080/\n```\n\n#### Low-Level Network Testing Tools\n\n**telnet - Raw TCP Connection Testing:**\n\ntelnet enables direct TCP connection testing without HTTP protocol formatting, essential for testing TCP server basics and debugging connection issues:\n\n```bash\n# Basic connection test\ntelnet localhost 8080\n\n# Test connection timeout\ntimeout 5 telnet localhost 8080\n\n# Scripted telnet for automated testing\necho -e \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\" | telnet localhost 8080\n```\n\n**netcat (nc) - Advanced Network Testing:**\n\nnetcat provides more flexibility than telnet for network testing scenarios:\n\n```bash\n# Send HTTP request via netcat\necho -e \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\" | nc localhost 8080\n\n# Test UDP (if server supports it)\necho \"test\" | nc -u localhost 8080\n\n# Port scanning to verify server is listening\nnc -z localhost 8080\n```\n\n**openssl s_client - HTTPS Testing:**\n\nIf HTTPS support is added in future extensions:\n\n```bash\n# Test HTTPS connection\nopenssl s_client -connect localhost:8443 -servername localhost\n\n# Test certificate validation\nopenssl s_client -connect localhost:8443 -verify_return_error\n```\n\n#### Browser Testing Strategies\n\n**Interactive Browser Testing:**\n\nReal browser testing provides essential validation of HTTP server behavior with actual web clients, revealing issues that command-line tools might miss:\n\n1. **Basic Functionality Testing:** Open `http://localhost:8080/` in multiple browsers (Chrome, Firefox, Safari) to verify cross-browser compatibility\n2. **Developer Tools Inspection:** Use browser developer tools (F12) to examine:\n   - Network tab: Request/response headers, timing, status codes\n   - Console tab: JavaScript errors if serving HTML with scripts\n   - Sources tab: Verify file contents load correctly\n3. **Cache Behavior Testing:** Use Ctrl+F5 (force refresh) to test cache headers and ensure proper cache validation\n\n**Browser-Specific Testing Scenarios:**\n\n| Test Scenario | Browser Action | Expected Behavior |\n|---|---|---|\n| Favicon request | Load any page | Server should handle `/favicon.ico` gracefully |\n| Multiple tabs | Open same URL in multiple tabs | All tabs should load correctly |\n| File download | Click download link | File should download without corruption |\n| Image loading | Page with multiple images | All images load without broken links |\n| Large file handling | Request large files | Download progresses without timeout |\n\n#### Automated Testing Scripts\n\n**Bash Testing Scripts:**\n\nCreate reusable test scripts for consistent verification across development iterations:\n\n```bash\n#!/bin/bash\n# http_server_test.sh - Comprehensive server testing\n\nSERVER_URL=\"http://localhost:8080\"\nTEST_DIR=\"test_files\"\n\n# Test basic connectivity\ntest_connectivity() {\n    echo \"Testing basic connectivity...\"\n    if curl -s --max-time 5 \"$SERVER_URL/\" > /dev/null; then\n        echo \"✓ Server is reachable\"\n    else\n        echo \"✗ Server connectivity failed\"\n        return 1\n    fi\n}\n\n# Test file serving\ntest_file_serving() {\n    echo \"Testing file serving...\"\n    for file in \"$TEST_DIR\"/*.html \"$TEST_DIR\"/*.css \"$TEST_DIR\"/*.js; do\n        filename=$(basename \"$file\")\n        if curl -s \"$SERVER_URL/$filename\" | diff - \"$file\" > /dev/null; then\n            echo \"✓ $filename served correctly\"\n        else\n            echo \"✗ $filename content mismatch\"\n        fi\n    done\n}\n\n# Test concurrent connections\ntest_concurrency() {\n    echo \"Testing concurrent connections...\"\n    for i in {1..10}; do\n        curl -s \"$SERVER_URL/\" > \"/tmp/response_$i\" &\n    done\n    wait\n    \n    # Verify all responses are identical\n    if diff /tmp/response_1 /tmp/response_2 > /dev/null; then\n        echo \"✓ Concurrent responses are consistent\"\n    else\n        echo \"✗ Concurrent responses differ\"\n    fi\n}\n\n# Run all tests\nmain() {\n    test_connectivity || exit 1\n    test_file_serving\n    test_concurrency\n    echo \"Testing completed\"\n}\n\nmain \"$@\"\n```\n\n### Concurrency Testing\n\nConcurrency testing represents the most complex verification challenge, requiring careful coordination of multiple clients and observation of server behavior under simultaneous load. Think of concurrency testing like stress-testing a restaurant during the dinner rush - you need to simulate multiple customers arriving simultaneously, ordering different items, and verify that each customer receives their correct order without delays caused by kitchen coordination issues.\n\n#### Thread-Per-Connection Model Testing\n\nThe thread-per-connection concurrency model creates a dedicated thread for each client connection, making it relatively straightforward to test but important to verify proper thread management and resource cleanup.\n\n**Basic Thread Creation Verification:**\n\nTest that the server creates threads correctly for multiple connections:\n\n```bash\n# Monitor thread creation in real-time\nwatch \"ps -T -p $(pgrep http_server) | wc -l\"\n\n# Create multiple connections and observe thread count\nfor i in {1..5}; do\n    (sleep 10; curl http://localhost:8080/) &\ndone\n```\n\nExpected behavior: Thread count should increase as connections are accepted and decrease as they complete. Total thread count should not exceed the number of active connections plus the main thread.\n\n**Thread Resource Management Testing:**\n\nVerify that threads are properly cleaned up and don't accumulate over time:\n\n```bash\n# Baseline thread count\nBASELINE=$(ps -T -p $(pgrep http_server) | wc -l)\n\n# Create and complete many connections\nfor round in {1..10}; do\n    for i in {1..5}; do\n        curl -s http://localhost:8080/ > /dev/null &\n    done\n    wait\n    sleep 1\ndone\n\n# Check final thread count\nFINAL=$(ps -T -p $(pgrep http_server) | wc -l)\n\nif [ $FINAL -eq $BASELINE ]; then\n    echo \"✓ Thread cleanup working correctly\"\nelse\n    echo \"✗ Thread leak detected: $BASELINE -> $FINAL\"\nfi\n```\n\n**Thread Safety Validation:**\n\nTest that concurrent threads don't interfere with each other's request processing:\n\n```bash\n# Create files with unique content\nmkdir -p test_content\nfor i in {1..10}; do\n    echo \"Unique content for file $i - $(date)\" > \"test_content/file$i.txt\"\ndone\n\n# Request all files simultaneously\nfor i in {1..10}; do\n    curl -s \"http://localhost:8080/file$i.txt\" > \"response$i.txt\" &\ndone\nwait\n\n# Verify each response matches its expected content\nfor i in {1..10}; do\n    if diff \"test_content/file$i.txt\" \"response$i.txt\" > /dev/null; then\n        echo \"✓ File $i content correct\"\n    else\n        echo \"✗ File $i content corrupted or swapped\"\n    fi\ndone\n```\n\n#### Thread Pool Model Testing\n\nThe thread pool model maintains a fixed number of worker threads that handle connections from a queue, requiring different testing approaches focused on queue management and worker coordination.\n\n**Thread Pool Size Verification:**\n\nTest that the server maintains the configured number of worker threads:\n\n```bash\n# Server should maintain exactly N worker threads plus main thread\nEXPECTED_THREADS=$((THREAD_POOL_SIZE + 1))\nACTUAL_THREADS=$(ps -T -p $(pgrep http_server) | wc -l)\n\nif [ $ACTUAL_THREADS -eq $EXPECTED_THREADS ]; then\n    echo \"✓ Thread pool size correct: $ACTUAL_THREADS threads\"\nelse\n    echo \"✗ Thread pool size incorrect: expected $EXPECTED_THREADS, got $ACTUAL_THREADS\"\nfi\n```\n\n**Queue Overflow Testing:**\n\nTest server behavior when more connections arrive than the thread pool can handle immediately:\n\n```bash\n# Create more simultaneous connections than thread pool size\nCONNECTIONS=$((THREAD_POOL_SIZE * 3))\n\necho \"Creating $CONNECTIONS simultaneous connections...\"\nfor i in $(seq 1 $CONNECTIONS); do\n    (\n        # Add delay to keep connections active\n        curl -s --max-time 30 \"http://localhost:8080/?delay=5\" > \"pool_response_$i\" &\n        echo $! > \"pool_pid_$i\"\n    ) &\ndone\n\n# Wait for all connections\nwait\n\n# Verify all connections completed successfully\nSUCCESS_COUNT=0\nfor i in $(seq 1 $CONNECTIONS); do\n    if [ -s \"pool_response_$i\" ]; then\n        SUCCESS_COUNT=$((SUCCESS_COUNT + 1))\n    fi\ndone\n\necho \"Successful connections: $SUCCESS_COUNT/$CONNECTIONS\"\n```\n\n**Worker Thread Load Distribution:**\n\nVerify that work is distributed among thread pool workers rather than handled by a single thread:\n\n```bash\n# Enable thread ID logging in server (if available)\n# Send requests and check logs for thread distribution\n\nfor i in {1..20}; do\n    curl -s \"http://localhost:8080/worker-test-$i\" > /dev/null\ndone\n\n# Analyze server logs to verify multiple thread IDs handled requests\n# This requires the server to log thread IDs for verification\n```\n\n#### Event-Driven Model Testing\n\nThe event-driven (select/poll) model uses a single thread with non-blocking I/O to handle multiple connections, requiring specialized testing to verify proper multiplexing behavior.\n\n**Non-Blocking Behavior Verification:**\n\nTest that the server doesn't block on slow clients:\n\n```bash\n# Create a slow client that sends data gradually\n{\n    echo \"GET / HTTP/1.1\"\n    sleep 5\n    echo \"Host: localhost\"\n    sleep 5\n    echo \"\"\n    echo \"\"\n} | nc localhost 8080 &\n\nSLOW_PID=$!\n\n# While slow client is active, send fast requests\nfor i in {1..5}; do\n    curl -s http://localhost:8080/ > \"fast_response_$i\" &\ndone\nwait\n\n# Verify fast requests completed despite slow client\nkill $SLOW_PID 2>/dev/null\n```\n\n**Connection Multiplexing Testing:**\n\nVerify that a single thread can handle multiple simultaneous connections:\n\n```bash\n# Verify server uses only one main thread\nTHREAD_COUNT=$(ps -T -p $(pgrep http_server) | wc -l)\nif [ $THREAD_COUNT -gt 2 ]; then  # Main thread + perhaps one helper\n    echo \"✗ Event-driven server should not create multiple threads\"\nelse\n    echo \"✓ Server using event-driven single-thread model\"\nfi\n\n# Create many simultaneous connections\nfor i in {1..50}; do\n    (echo -e \"GET /test$i HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\" | nc localhost 8080 > \"event_response_$i\") &\ndone\nwait\n\n# Count successful responses\nSUCCESS_COUNT=$(ls event_response_* 2>/dev/null | wc -l)\necho \"Event-driven model handled $SUCCESS_COUNT/50 connections\"\n```\n\n#### Load Testing and Stress Testing\n\n**Progressive Load Testing:**\n\nGradually increase the load to identify the server's capacity limits:\n\n```bash\n#!/bin/bash\n# progressive_load_test.sh\n\ntest_load() {\n    local connections=$1\n    local duration=10\n    local success=0\n    \n    echo \"Testing with $connections concurrent connections...\"\n    \n    for i in $(seq 1 $connections); do\n        timeout $duration curl -s http://localhost:8080/ > /dev/null && success=$((success + 1)) &\n    done\n    wait\n    \n    local success_rate=$((success * 100 / connections))\n    echo \"Success rate: $success_rate% ($success/$connections)\"\n    \n    return $success_rate\n}\n\n# Test increasing loads\nfor load in 10 25 50 100 200 500; do\n    test_load $load\n    sleep 5  # Recovery time\ndone\n```\n\n**Memory and Resource Monitoring:**\n\nMonitor server resource usage during concurrent load:\n\n```bash\n# Start resource monitoring\n{\n    while true; do\n        echo \"$(date): $(ps -o pid,vsz,rss,pcpu,pmem,nlwp -p $(pgrep http_server))\"\n        sleep 1\n    done\n} > resource_usage.log &\n\nMONITOR_PID=$!\n\n# Generate load\nfor i in {1..100}; do\n    curl -s http://localhost:8080/large-file.html > /dev/null &\ndone\nwait\n\n# Stop monitoring\nkill $MONITOR_PID\n\n# Analyze resource usage\necho \"Peak memory usage:\"\nsort -k3 -nr resource_usage.log | head -1\n```\n\n#### Failure Recovery Testing\n\n**Connection Interruption Handling:**\n\nTest server resilience when clients disconnect unexpectedly:\n\n```bash\n# Create connections that disconnect abruptly\nfor i in {1..10}; do\n    {\n        echo \"GET / HTTP/1.1\"\n        echo \"Host: localhost\"\n        # Disconnect without completing request\n    } | timeout 0.1 nc localhost 8080 &\ndone\n\n# Immediately send normal requests\nsleep 0.5\nfor i in {1..5}; do\n    curl -s http://localhost:8080/ > \"recovery_test_$i\" &\ndone\nwait\n\n# Verify normal requests succeeded despite connection failures\nSUCCESS=0\nfor i in {1..5}; do\n    if [ -s \"recovery_test_$i\" ]; then\n        SUCCESS=$((SUCCESS + 1))\n    fi\ndone\n\necho \"Recovery test: $SUCCESS/5 requests succeeded\"\n```\n\n**Graceful Shutdown Testing:**\n\nTest that the server handles shutdown signals correctly while serving active connections:\n\n```bash\n# Start long-running requests\nfor i in {1..5}; do\n    curl -s \"http://localhost:8080/?delay=10\" > \"shutdown_test_$i\" &\ndone\n\nsleep 2  # Let requests start processing\n\n# Send shutdown signal\nkill -TERM $(pgrep http_server)\n\n# Wait for requests to complete\nwait\n\n# Verify existing requests completed successfully\nCOMPLETED=0\nfor i in {1..5}; do\n    if [ -s \"shutdown_test_$i\" ]; then\n        COMPLETED=$((COMPLETED + 1))\n    fi\ndone\n\necho \"Graceful shutdown: $COMPLETED/5 requests completed\"\n```\n\n### Implementation Guidance\n\nThe testing strategy implementation requires creating a comprehensive test suite that can be executed at each milestone to verify functionality and catch regressions. The testing approach combines automated scripts with manual verification procedures to ensure thorough coverage.\n\n#### Technology Recommendations\n\n| Testing Component | Simple Option | Advanced Option |\n|---|---|---|\n| HTTP Client Testing | curl command-line scripts | Python requests library with unittest |\n| Load Testing | Bash scripts with background processes | Apache Bench (ab) or wrk load tester |\n| Resource Monitoring | ps/lsof command-line tools | Custom monitoring with htop/iotop |\n| Automated Testing | Shell scripts with basic assertions | Python pytest with HTTP test fixtures |\n| Concurrency Testing | Manual curl with background jobs | Custom multi-threaded test client |\n\n#### Recommended File Structure\n\n```\nproject-root/\n  tests/\n    milestone1/\n      test_tcp_basics.sh           ← TCP socket functionality\n      test_connection_handling.sh  ← Connection accept/close\n    milestone2/\n      test_http_parsing.sh         ← HTTP request parsing\n      test_error_responses.sh      ← Malformed request handling\n      sample_requests/             ← Test HTTP request files\n    milestone3/\n      test_file_serving.sh         ← Static file serving\n      test_security.sh             ← Directory traversal tests\n      test_content/                ← Test files and directories\n        index.html\n        style.css\n        images/\n          test.png\n    milestone4/\n      test_concurrency.sh          ← Concurrent connection tests\n      test_load.sh                 ← Load testing scripts\n      test_resource_limits.sh      ← Resource management tests\n    tools/\n      http_test_client.c           ← Custom test client\n      monitor_resources.sh         ← Resource monitoring utilities\n      test_runner.sh               ← Master test execution script\n  test_results/                    ← Test output and logs\n    milestone1_results.txt\n    milestone2_results.txt\n    resource_usage.log\n```\n\n#### Infrastructure Testing Code\n\n**Complete HTTP Test Client Implementation:**\n\n```c\n// tools/http_test_client.c - Complete HTTP testing client\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <time.h>\n#include <pthread.h>\n\n#define MAX_RESPONSE_SIZE 8192\n#define MAX_CONCURRENT_CLIENTS 100\n\ntypedef struct {\n    char* server_host;\n    int server_port;\n    char* request_path;\n    int client_id;\n    int* success_count;\n    pthread_mutex_t* count_mutex;\n} ClientConfig;\n\n// Send HTTP request and receive response\nint send_http_request(const char* host, int port, const char* path, char* response, size_t max_response) {\n    int sockfd;\n    struct sockaddr_in server_addr;\n    char request[1024];\n    ssize_t bytes_received;\n    \n    // Create socket\n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        perror(\"socket creation failed\");\n        return -1;\n    }\n    \n    // Configure server address\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (inet_pton(AF_INET, host, &server_addr.sin_addr) <= 0) {\n        perror(\"invalid address\");\n        close(sockfd);\n        return -1;\n    }\n    \n    // Connect to server\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        perror(\"connection failed\");\n        close(sockfd);\n        return -1;\n    }\n    \n    // Send HTTP request\n    snprintf(request, sizeof(request), \n             \"GET %s HTTP/1.1\\r\\nHost: %s\\r\\nConnection: close\\r\\n\\r\\n\", \n             path, host);\n    \n    if (send(sockfd, request, strlen(request), 0) < 0) {\n        perror(\"send failed\");\n        close(sockfd);\n        return -1;\n    }\n    \n    // Receive response\n    bytes_received = recv(sockfd, response, max_response - 1, 0);\n    if (bytes_received < 0) {\n        perror(\"recv failed\");\n        close(sockfd);\n        return -1;\n    }\n    \n    response[bytes_received] = '\\0';\n    close(sockfd);\n    return bytes_received;\n}\n\n// Thread function for concurrent testing\nvoid* client_thread(void* arg) {\n    ClientConfig* config = (ClientConfig*)arg;\n    char response[MAX_RESPONSE_SIZE];\n    \n    int result = send_http_request(config->server_host, config->server_port, \n                                   config->request_path, response, MAX_RESPONSE_SIZE);\n    \n    if (result > 0) {\n        pthread_mutex_lock(config->count_mutex);\n        (*config->success_count)++;\n        pthread_mutex_unlock(config->count_mutex);\n        printf(\"Client %d: SUCCESS (%d bytes)\\n\", config->client_id, result);\n    } else {\n        printf(\"Client %d: FAILED\\n\", config->client_id);\n    }\n    \n    return NULL;\n}\n\nint main(int argc, char* argv[]) {\n    if (argc < 4) {\n        fprintf(stderr, \"Usage: %s <host> <port> <path> [concurrent_clients]\\n\", argv[0]);\n        return 1;\n    }\n    \n    char* host = argv[1];\n    int port = atoi(argv[2]);\n    char* path = argv[3];\n    int concurrent_clients = (argc > 4) ? atoi(argv[4]) : 1;\n    \n    if (concurrent_clients == 1) {\n        // Single request mode\n        char response[MAX_RESPONSE_SIZE];\n        int result = send_http_request(host, port, path, response, MAX_RESPONSE_SIZE);\n        \n        if (result > 0) {\n            printf(\"Response received (%d bytes):\\n\", result);\n            printf(\"%s\\n\", response);\n            return 0;\n        } else {\n            printf(\"Request failed\\n\");\n            return 1;\n        }\n    } else {\n        // Concurrent testing mode\n        pthread_t threads[MAX_CONCURRENT_CLIENTS];\n        ClientConfig configs[MAX_CONCURRENT_CLIENTS];\n        int success_count = 0;\n        pthread_mutex_t count_mutex = PTHREAD_MUTEX_INITIALIZER;\n        \n        if (concurrent_clients > MAX_CONCURRENT_CLIENTS) {\n            concurrent_clients = MAX_CONCURRENT_CLIENTS;\n        }\n        \n        printf(\"Starting %d concurrent clients...\\n\", concurrent_clients);\n        \n        // Start concurrent clients\n        for (int i = 0; i < concurrent_clients; i++) {\n            configs[i].server_host = host;\n            configs[i].server_port = port;\n            configs[i].request_path = path;\n            configs[i].client_id = i + 1;\n            configs[i].success_count = &success_count;\n            configs[i].count_mutex = &count_mutex;\n            \n            if (pthread_create(&threads[i], NULL, client_thread, &configs[i]) != 0) {\n                perror(\"pthread_create failed\");\n                return 1;\n            }\n        }\n        \n        // Wait for all threads to complete\n        for (int i = 0; i < concurrent_clients; i++) {\n            pthread_join(threads[i], NULL);\n        }\n        \n        printf(\"Concurrent test completed: %d/%d clients succeeded\\n\", \n               success_count, concurrent_clients);\n        \n        return (success_count == concurrent_clients) ? 0 : 1;\n    }\n}\n```\n\n**Complete Resource Monitoring Script:**\n\n```bash\n#!/bin/bash\n# tools/monitor_resources.sh - Complete resource monitoring utility\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nLOG_DIR=\"$SCRIPT_DIR/../test_results\"\nSERVER_NAME=\"http_server\"\n\n# Ensure log directory exists\nmkdir -p \"$LOG_DIR\"\n\n# Get server process ID\nget_server_pid() {\n    pgrep -f \"$SERVER_NAME\" | head -1\n}\n\n# Monitor server resources\nmonitor_resources() {\n    local duration=$1\n    local interval=${2:-1}\n    local output_file=\"$LOG_DIR/resource_monitor_$(date +%Y%m%d_%H%M%S).log\"\n    \n    echo \"Monitoring server resources for ${duration}s (interval: ${interval}s)\"\n    echo \"Output: $output_file\"\n    echo \"Timestamp,PID,VSZ_KB,RSS_KB,CPU_PCT,MEM_PCT,THREADS,FD_COUNT\" > \"$output_file\"\n    \n    local start_time=$(date +%s)\n    local end_time=$((start_time + duration))\n    \n    while [ $(date +%s) -lt $end_time ]; do\n        local server_pid=$(get_server_pid)\n        \n        if [ -n \"$server_pid\" ]; then\n            # Get process statistics\n            local ps_info=$(ps -o pid,vsz,rss,pcpu,pmem,nlwp -p \"$server_pid\" --no-headers 2>/dev/null)\n            \n            if [ -n \"$ps_info\" ]; then\n                # Count file descriptors\n                local fd_count=$(ls /proc/$server_pid/fd 2>/dev/null | wc -l)\n                \n                # Format output\n                local timestamp=$(date '+%Y-%m-%d %H:%M:%S')\n                echo \"$timestamp,$ps_info,$fd_count\" | tr -s ' ' ',' >> \"$output_file\"\n            else\n                echo \"$(date '+%Y-%m-%d %H:%M:%S'),SERVER_NOT_FOUND,,,,,,\" >> \"$output_file\"\n            fi\n        else\n            echo \"$(date '+%Y-%m-%d %H:%M:%S'),PID_NOT_FOUND,,,,,,\" >> \"$output_file\"\n        fi\n        \n        sleep \"$interval\"\n    done\n    \n    echo \"Monitoring completed. Results saved to: $output_file\"\n    \n    # Generate summary\n    if [ -s \"$output_file\" ]; then\n        echo \"Resource Usage Summary:\"\n        echo \"======================\"\n        echo \"Peak VSZ (KB): $(tail -n +2 \"$output_file\" | cut -d',' -f3 | sort -nr | head -1)\"\n        echo \"Peak RSS (KB): $(tail -n +2 \"$output_file\" | cut -d',' -f4 | sort -nr | head -1)\"\n        echo \"Peak Threads: $(tail -n +2 \"$output_file\" | cut -d',' -f6 | sort -nr | head -1)\"\n        echo \"Peak FDs: $(tail -n +2 \"$output_file\" | cut -d',' -f7 | sort -nr | head -1)\"\n    fi\n}\n\n# Test connection limits\ntest_connection_limits() {\n    local max_connections=$1\n    local server_pid=$(get_server_pid)\n    \n    if [ -z \"$server_pid\" ]; then\n        echo \"Server not running\"\n        return 1\n    fi\n    \n    echo \"Testing connection limits (max: $max_connections)\"\n    \n    # Start monitoring\n    monitor_resources 60 1 &\n    local monitor_pid=$!\n    \n    # Create connections gradually\n    local success_count=0\n    for i in $(seq 1 $max_connections); do\n        if timeout 10 \"$SCRIPT_DIR/../tools/http_test_client\" localhost 8080 / >/dev/null 2>&1; then\n            success_count=$((success_count + 1))\n            echo -n \".\"\n        else\n            echo -n \"x\"\n        fi\n        \n        # Brief delay between connections\n        sleep 0.1\n    done\n    \n    echo \"\"\n    echo \"Connection test completed: $success_count/$max_connections successful\"\n    \n    # Stop monitoring\n    kill $monitor_pid 2>/dev/null\n    wait $monitor_pid 2>/dev/null\n}\n\n# Main function\nmain() {\n    case \"${1:-help}\" in\n        \"monitor\")\n            monitor_resources \"${2:-30}\" \"${3:-1}\"\n            ;;\n        \"limits\")\n            test_connection_limits \"${2:-100}\"\n            ;;\n        \"help\"|*)\n            echo \"Usage: $0 <command> [options]\"\n            echo \"Commands:\"\n            echo \"  monitor <duration> [interval]  - Monitor resources for duration seconds\"\n            echo \"  limits <max_connections>       - Test connection limits\"\n            echo \"  help                          - Show this help\"\n            ;;\n    esac\n}\n\nmain \"$@\"\n```\n\n#### Core Testing Logic Skeletons\n\n**Master Test Runner:**\n\n```bash\n#!/bin/bash\n# tests/test_runner.sh - Master test execution script\n\n# TODO 1: Set up test environment - create test directories, compile test tools\n# TODO 2: Start server in background and wait for it to be ready\n# TODO 3: Execute milestone 1 tests - TCP server basics\n# TODO 4: Execute milestone 2 tests - HTTP request parsing  \n# TODO 5: Execute milestone 3 tests - static file serving\n# TODO 6: Execute milestone 4 tests - concurrent connections\n# TODO 7: Run load testing and resource monitoring\n# TODO 8: Generate comprehensive test report\n# TODO 9: Clean up test environment and stop server\n# TODO 10: Return appropriate exit code based on test results\n\nrun_milestone_tests() {\n    local milestone=$1\n    # TODO: Execute all tests for specified milestone\n    # TODO: Collect results and update overall test status\n    # TODO: Log detailed results to milestone-specific log file\n}\n\nsetup_test_environment() {\n    # TODO: Create necessary test directories and files\n    # TODO: Compile custom test clients and utilities\n    # TODO: Verify required testing tools are available\n}\n\ncleanup_test_environment() {\n    # TODO: Remove temporary test files\n    # TODO: Kill any remaining background processes\n    # TODO: Restore original system state\n}\n\ngenerate_test_report() {\n    # TODO: Combine results from all milestone tests\n    # TODO: Create HTML or text report with pass/fail summary\n    # TODO: Include performance metrics and resource usage\n}\n```\n\n#### Milestone Checkpoints\n\n**Milestone 1 Verification Script:**\n\n```bash\n#!/bin/bash\n# tests/milestone1/test_tcp_basics.sh\n\necho \"=== Milestone 1: TCP Server Basics Testing ===\"\n\n# Test 1: Server starts and binds to port\ntest_server_startup() {\n    echo \"Testing server startup and port binding...\"\n    \n    # TODO: Start server in background\n    # TODO: Wait for server to be ready (check port binding)\n    # TODO: Verify server is listening on correct port using netstat\n    # TODO: Test that server accepts basic TCP connections\n    # Expected: Server binds to port 8080 and shows LISTEN state\n}\n\n# Test 2: Connection acceptance\ntest_connection_acceptance() {\n    echo \"Testing connection acceptance...\"\n    \n    # TODO: Use telnet to connect to server\n    # TODO: Verify connection is accepted (telnet shows \"Connected\")\n    # TODO: Send simple string and verify server reads it\n    # TODO: Verify server sends hardcoded HTTP response\n    # Expected: Connection accepted, response received, connection closed\n}\n```\n\n**Milestone 4 Concurrent Testing:**\n\n```bash\n#!/bin/bash  \n# tests/milestone4/test_concurrency.sh\n\n# Test concurrent request handling\ntest_concurrent_requests() {\n    echo \"Testing concurrent request handling...\"\n    \n    # TODO: Create multiple background curl processes\n    # TODO: Monitor that all requests complete successfully\n    # TODO: Verify response content is consistent across all requests\n    # TODO: Check that no responses are corrupted or mixed up\n    # Expected: All concurrent requests succeed with correct content\n}\n\n# Test resource limits\ntest_resource_limits() {\n    echo \"Testing resource limits...\"\n    \n    # TODO: Create connections exceeding configured limits\n    # TODO: Verify server handles excess connections gracefully\n    # TODO: Monitor file descriptor and thread usage\n    # TODO: Ensure no resource leaks after connections close\n    # Expected: Server enforces limits without crashing\n}\n\n```\n\n\n## Debugging Guide\n\n> **Milestone(s):** All Milestones 1-4 - provides systematic troubleshooting for TCP server basics, HTTP request parsing, static file serving, and concurrent connections with specific diagnostic techniques\n\n### Debugging Mental Model: The Detective's Toolkit\n\nThink of debugging an HTTP server like being a detective investigating a crime scene. Just as detectives use systematic methods to gather evidence, interview witnesses, and piece together what happened, server debugging requires a methodical approach to collecting symptoms, examining evidence, and forming hypotheses. The server's logs are like witness statements, network packet captures are like security footage, and debugger traces are like forensic analysis. A good detective doesn't jump to conclusions but follows the evidence methodically, and a good server debugger applies the same systematic thinking to isolate and resolve issues.\n\nThe debugging process for HTTP servers involves three critical phases: symptom identification (what is the observable behavior), evidence collection (gathering diagnostic data from multiple sources), and root cause analysis (correlating evidence to identify the underlying problem). Just as a detective considers multiple theories and tests each one against the evidence, effective server debugging requires considering multiple potential causes and systematically eliminating possibilities through targeted investigation.\n\n### Symptom-Based Diagnosis Table\n\nThe following comprehensive diagnosis table organizes common HTTP server issues by observable symptoms, providing a systematic approach to troubleshooting. Each symptom includes multiple potential causes because server problems often manifest in similar ways but have different underlying roots.\n\n| **Symptom** | **Likely Causes** | **Diagnostic Techniques** | **Investigation Commands** |\n|-------------|------------------|--------------------------|---------------------------|\n| **Server fails to start** | Port already in use; Permission denied for port binding; Invalid configuration values; Missing document root directory | Check port availability; Verify user permissions; Validate configuration; Check filesystem permissions | `netstat -tlnp \\| grep 8080`; `sudo lsof -i :8080`; `ls -la /path/to/document/root`; `id` (check user) |\n| **Clients cannot connect** | Firewall blocking connections; Server not listening on correct interface; DNS resolution issues; Network connectivity problems | Verify server listening state; Test local vs remote connections; Check firewall rules; Test network path | `ss -tlnp \\| grep :8080`; `telnet localhost 8080`; `curl -v http://server:8080/`; `iptables -L` |\n| **Connection accepted but no response** | Server hanging in request reading; Infinite loop in request processing; Deadlock in thread synchronization; Process crashed after accept | Monitor server process state; Check thread states; Examine system resources; Look for core dumps | `ps aux \\| grep server`; `top -H -p <pid>`; `strace -p <pid>`; `gdb -p <pid>` |\n| **Request parsing fails** | Malformed HTTP request format; Line ending issues (CRLF vs LF); Buffer overflow in parsing; Invalid characters in headers | Capture raw request data; Examine line endings; Check buffer boundaries; Validate character encoding | `tcpdump -i lo -A port 8080`; `xxd request.txt`; `strace -e read,write -p <pid>` |\n| **File not found errors** | Incorrect path mapping; Directory traversal protection; Case sensitivity issues; Permission denied access | Trace path resolution; Check filesystem permissions; Verify document root mapping; Test file accessibility | `ls -la /document/root/requested/path`; `sudo -u www-data cat /path/to/file`; `realpath /document/root/../etc/passwd` |\n| **Slow response times** | Disk I/O bottleneck; Thread pool exhaustion; Memory allocation delays; Network congestion | Monitor system performance; Check thread utilization; Profile memory usage; Measure network latency | `iostat -x 1`; `sar -u 1`; `valgrind --tool=massif ./server`; `iftop` |\n| **High CPU usage** | Infinite loop in request processing; Excessive string operations; Inefficient parsing algorithms; Busy-wait conditions | Profile CPU usage; Trace function calls; Examine parsing logic; Check synchronization primitives | `perf top -p <pid>`; `strace -c -p <pid>`; `gdb -p <pid> -ex bt` |\n| **Memory leaks** | Missing `cleanup_http_request()` calls; Unreleased connection contexts; Thread resource leaks; File descriptor leaks | Track memory allocation; Monitor file descriptor count; Check cleanup sequences; Analyze heap growth | `valgrind --leak-check=full ./server`; `lsof -p <pid> \\| wc -l`; `pmap <pid>` |\n| **Concurrent connection issues** | Race conditions in shared data; Thread pool deadlock; Resource limit exceeded; Improper thread synchronization | Test under load; Check thread states; Monitor resource limits; Examine synchronization code | `siege -c 100 -t 30s http://localhost:8080/`; `ulimit -a`; `ps -eLf \\| grep server` |\n| **Partial responses** | Early connection termination; Buffer size limitations; Network timeout issues; Incomplete file reads | Monitor connection lifecycle; Check buffer sizes; Measure transfer times; Verify file integrity | `curl -v --max-time 30 http://localhost:8080/large.file`; `nc localhost 8080 < request.txt` |\n| **Security vulnerabilities** | Directory traversal attacks; Path injection; Buffer overflow; Insufficient input validation | Test path traversal; Inject malformed input; Check boundary conditions; Verify input sanitization | `curl \"http://localhost:8080/../../../etc/passwd\"`; `python -c \"print('A'*10000)\" \\| nc localhost 8080` |\n\n> **Critical Insight**: Many HTTP server issues present with similar symptoms but have completely different root causes. Systematic evidence collection prevents misdiagnosis and reduces debugging time significantly. Always start with the simplest possible cause before investigating complex scenarios.\n\n### Debugging Tools and Techniques\n\nEffective HTTP server debugging requires a multi-layered approach using different tools to examine behavior at the network, system, and application levels. Each tool provides a different perspective on server operation, and combining insights from multiple tools leads to faster problem resolution.\n\n#### Network-Level Debugging\n\nNetwork-level debugging examines the raw TCP connections and HTTP message flow between clients and servers. This level reveals issues with connection establishment, protocol compliance, and message formatting that may not be visible at higher abstraction levels.\n\n**Packet Capture and Analysis:**\nThe `tcpdump` utility captures raw network traffic, allowing examination of actual bytes transmitted between client and server. This technique reveals protocol violations, malformed messages, and connection timing issues that application-level logging might miss.\n\n| **Tool** | **Purpose** | **Key Commands** | **What to Look For** |\n|----------|-------------|-----------------|----------------------|\n| `tcpdump` | Capture raw network packets | `tcpdump -i lo -A -s 0 port 8080` | Connection establishment, HTTP message format, connection termination |\n| `wireshark` | GUI packet analysis | `wireshark -i lo -f \"port 8080\"` | Protocol violations, timing issues, malformed headers |\n| `netcat` | Manual connection testing | `nc localhost 8080` then type HTTP request | Server response to hand-crafted requests |\n| `telnet` | Basic connectivity testing | `telnet localhost 8080` | Whether TCP connection can be established |\n\n**Connection State Monitoring:**\nUnderstanding the current state of TCP connections helps identify stuck connections, resource leaks, and capacity issues. Different connection states indicate different phases of the request-response cycle.\n\n```bash\n# Monitor active connections and their states\nss -tuln | grep :8080                    # Check if server is listening\nss -tpn | grep :8080                     # Show active connections with process info\nnetstat -an | grep :8080 | grep ESTABLISHED  # Count active client connections\nlsof -i TCP:8080                         # Show processes using port 8080\n```\n\n#### System-Level Debugging\n\nSystem-level debugging examines resource usage, process behavior, and operating system interactions. This perspective reveals issues with memory management, file descriptor usage, and system call patterns that impact server performance and stability.\n\n**Process and Thread Monitoring:**\nUnderstanding how the server process and its threads behave under different conditions helps identify concurrency issues, resource exhaustion, and performance bottlenecks.\n\n| **Tool** | **Purpose** | **Key Commands** | **Diagnostic Information** |\n|----------|-------------|-----------------|---------------------------|\n| `ps` | Process state monitoring | `ps -eLf | grep server` | Thread count, CPU usage, memory usage |\n| `top` | Real-time resource monitoring | `top -H -p <pid>` | Per-thread CPU usage, memory growth |\n| `strace` | System call tracing | `strace -p <pid> -e trace=network,file` | Network operations, file access patterns |\n| `ltrace` | Library call tracing | `ltrace -p <pid> -e malloc,free` | Memory allocation patterns |\n| `pmap` | Memory mapping analysis | `pmap -x <pid>` | Memory layout, shared libraries |\n\n**Resource Limit Investigation:**\nSystem resource limits can cause mysterious server failures that don't generate clear error messages. Checking both soft and hard limits helps identify capacity constraints.\n\n```bash\n# Check resource limits for server process\ncat /proc/<pid>/limits                   # Current limits for process\nulimit -a                               # Limits for current shell\nsysctl fs.file-max                      # System-wide file descriptor limit\ncat /proc/sys/net/core/somaxconn        # TCP listen backlog limit\n```\n\n#### Application-Level Debugging\n\nApplication-level debugging uses debuggers and profiling tools to examine the server's internal state, variable values, and execution flow. This level provides the most detailed view of program behavior but requires understanding of the server's implementation.\n\n**Interactive Debugging with GDB:**\nThe GNU Debugger allows real-time examination of server state, including variable values, call stacks, and execution flow. This technique is essential for investigating deadlocks, infinite loops, and logic errors.\n\n| **GDB Command** | **Purpose** | **When to Use** |\n|-----------------|-------------|-----------------|\n| `gdb -p <pid>` | Attach to running server | Server appears hung or behaving unexpectedly |\n| `bt` | Show call stack | Identify where server is stuck |\n| `thread apply all bt` | Show all thread call stacks | Investigate deadlocks and thread states |\n| `p variable_name` | Print variable value | Check request parsing state, connection context |\n| `info threads` | List all threads | See thread count and current activity |\n\n**Memory Debugging with Valgrind:**\nValgrind detects memory leaks, buffer overflows, and invalid memory access patterns that can cause crashes or security vulnerabilities. Running the server under Valgrind during testing reveals memory management issues.\n\n```bash\n# Run server with comprehensive memory checking\nvalgrind --leak-check=full \\\n         --show-leak-kinds=all \\\n         --track-origins=yes \\\n         --verbose \\\n         ./http_server --port 8080 --root /var/www\n\n# Monitor for specific error types\nvalgrind --tool=memcheck \\\n         --track-fds=yes \\\n         ./http_server  # Track file descriptor leaks\n```\n\n**Performance Profiling:**\nUnderstanding where the server spends its execution time helps identify performance bottlenecks and optimization opportunities.\n\n| **Tool** | **Purpose** | **Usage** | **Output Analysis** |\n|----------|-------------|-----------|-------------------|\n| `perf` | CPU profiling | `perf record -p <pid>; perf report` | Function call frequency, CPU hotspots |\n| `gprof` | Function profiling | Compile with `-pg`, run server, analyze `gmon.out` | Function execution time, call graph |\n| `time` | Basic timing | `time ./http_server` | Overall execution time breakdown |\n\n### Milestone-Specific Issues\n\nEach milestone introduces specific types of problems based on the functionality being implemented. Understanding common issues for each milestone helps focus debugging efforts and provides targeted solutions.\n\n#### Milestone 1: TCP Server Basics Issues\n\nThe TCP server foundation presents networking-specific challenges related to socket programming, connection management, and basic protocol handling. These issues often manifest as connection failures or server startup problems.\n\n**Socket Creation and Binding Problems:**\n\n⚠️ **Pitfall: Port Already in Use**\nWhen the server fails to start with \"Address already in use\" errors, another process is likely using the target port. This commonly happens when a previous server instance didn't terminate cleanly or when system services are using standard ports.\n\n| **Symptom** | **Cause** | **Diagnosis** | **Solution** |\n|-------------|-----------|---------------|-------------|\n| `bind()` fails with `EADDRINUSE` | Another process using port | `netstat -tlnp \\| grep 8080` | Kill existing process or use different port |\n| Server starts but clients can't connect | Binding to localhost only | `ss -tlnp \\| grep 8080` | Bind to `INADDR_ANY` instead of localhost |\n| Permission denied on port binding | Non-root user binding privileged port | `id; echo $PORT` | Use port > 1024 or run with sudo |\n\n⚠️ **Pitfall: Incorrect Socket Options**\nForgetting to set `SO_REUSEADDR` causes server restart failures when connections are in TIME_WAIT state. This is especially problematic during development when restarting the server frequently.\n\n```c\n// Missing socket option setup\nint server_fd = socket(AF_INET, SOCK_STREAM, 0);\n// bind() will fail if previous connections are in TIME_WAIT\n\n// Correct approach with socket options\nint server_fd = socket(AF_INET, SOCK_STREAM, 0);\nint opt = 1;\nsetsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n```\n\n**Connection Acceptance Issues:**\n\n⚠️ **Pitfall: Blocking Accept Loop**\nUsing a simple `accept()` loop without proper signal handling or shutdown logic can create servers that cannot be stopped gracefully. The server continues accepting new connections even when shutdown is requested.\n\n| **Problem** | **Symptom** | **Investigation** | **Fix** |\n|-------------|-------------|-------------------|---------|\n| Server cannot be stopped | Process ignores SIGTERM | `kill -TERM <pid>; ps aux \\| grep server` | Add signal handler for graceful shutdown |\n| Accept loop consumes 100% CPU | Server spins without blocking | `strace -p <pid>` shows rapid `accept()` calls | Check `accept()` error handling |\n| Client connections dropped | `accept()` failing silently | `strace -e accept -p <pid>` | Add error logging for failed accepts |\n\n**File Descriptor Management:**\n\n⚠️ **Pitfall: File Descriptor Leaks**\nFailing to close client sockets after processing requests leads to file descriptor exhaustion. This typically manifests as the server stopping accepting new connections after handling a certain number of requests.\n\n```bash\n# Monitor file descriptor usage\nwatch \"lsof -p <server_pid> | wc -l\"     # Total FDs in use\nls /proc/<pid>/fd/ | wc -l               # Count open file descriptors\ncat /proc/<pid>/limits | grep \"Max open files\"  # Check FD limit\n```\n\n#### Milestone 2: HTTP Request Parsing Issues\n\nHTTP parsing introduces complexity around message format compliance, buffer management, and protocol error handling. These issues often manifest as parsing failures or protocol violations.\n\n**Request Line Parsing Problems:**\n\n⚠️ **Pitfall: Line Ending Confusion**\nHTTP specifies CRLF (`\\r\\n`) line endings, but clients sometimes send only LF (`\\n`). Parsers that expect exact CRLF sequences fail on otherwise valid requests.\n\n| **Symptom** | **Client Type** | **Line Ending** | **Parser Behavior** |\n|-------------|-----------------|-----------------|-------------------|\n| Parsing fails on curl requests | curl on Unix | LF only | `find_line_end()` doesn't find CRLF |\n| Browser requests fail | Some web browsers | CRLF | Parser works correctly |\n| Telnet testing fails | Manual telnet session | Mixed endings | Inconsistent parsing results |\n\n**Buffer Overflow Protection:**\n\n⚠️ **Pitfall: Unbounded Buffer Reads**\nReading request data into fixed-size buffers without bounds checking can cause buffer overflows when clients send large requests or malicious input designed to exploit buffer boundaries.\n\n```c\n// Dangerous approach - no bounds checking\nchar buffer[1024];\nread(client_fd, buffer, 2048);  // Can overflow buffer!\n\n// Safe approach with bounds checking\nchar buffer[MAX_REQUEST_SIZE];\nssize_t bytes_read = read_complete_request(client_fd, buffer, sizeof(buffer));\nif (bytes_read >= sizeof(buffer)) {\n    // Request too large - send 413 Entity Too Large\n}\n```\n\n**Header Parsing Edge Cases:**\n\n⚠️ **Pitfall: Header Value Whitespace**\nHTTP headers can have leading and trailing whitespace around values that must be trimmed. Failing to handle this correctly causes header matching failures and incorrect behavior.\n\n| **Header Format** | **Raw Value** | **Trimmed Value** | **Impact if Not Trimmed** |\n|-------------------|---------------|-------------------|---------------------------|\n| `Host: localhost:8080` | `localhost:8080` | `localhost:8080` | No issue |\n| `Host:   localhost:8080   ` | `  localhost:8080   ` | `localhost:8080` | Host matching fails |\n| `Content-Type: text/html` | ` text/html` | `text/html` | MIME type detection fails |\n\n#### Milestone 3: Static File Serving Issues\n\nFile serving introduces security concerns, filesystem interaction complexity, and content type handling challenges. These issues often manifest as security vulnerabilities or incorrect content delivery.\n\n**Path Traversal Security:**\n\n⚠️ **Pitfall: Directory Traversal Attacks**\nFailing to properly validate and canonicalize request paths allows attackers to access files outside the document root using `../` sequences. This is a critical security vulnerability.\n\n| **Attack Vector** | **Request Path** | **Resolved Path** | **Security Impact** |\n|-------------------|------------------|-------------------|-------------------|\n| Basic traversal | `/../../../etc/passwd` | `/etc/passwd` | System file access |\n| URL encoded | `/%2E%2E/%2E%2E/etc/passwd` | `/../etc/passwd` | Bypass basic filters |\n| Mixed encoding | `/..%2F..%2Fetc%2Fpasswd` | `/../etc/passwd` | Bypass simple validation |\n\n```c\n// Proper path validation sequence\nint validate_and_resolve_path(const char* document_root, \n                             const char* request_path, \n                             char* resolved_path, \n                             size_t max_path_len) {\n    // 1. URL decode the request path\n    // 2. Normalize path (remove . and .. components)\n    // 3. Prepend document root\n    // 4. Canonicalize using realpath()\n    // 5. Verify result stays within document root\n}\n```\n\n**MIME Type Detection Issues:**\n\n⚠️ **Pitfall: Incorrect Content-Type Headers**\nSending files without proper `Content-Type` headers causes browsers to misinterpret content, leading to security issues (MIME sniffing attacks) or display problems.\n\n| **File Extension** | **MIME Type** | **Browser Behavior Without Correct Type** |\n|--------------------|---------------|-------------------------------------------|\n| `.html` | `text/html` | May display as plain text |\n| `.css` | `text/css` | Stylesheet not applied |\n| `.js` | `application/javascript` | Script not executed |\n| `.pdf` | `application/pdf` | Downloaded instead of displayed |\n| `.jpg` | `image/jpeg` | May not display inline |\n\n**File Permission and Access Issues:**\n\n⚠️ **Pitfall: Permission Denied Errors**\nServer processes running under restricted user accounts may not have read permissions for files in the document root. This causes 403 Forbidden errors instead of 404 Not Found errors.\n\n```bash\n# Check file permissions for server user\nsudo -u www-data ls -la /var/www/html/requested-file.txt\nsudo -u www-data cat /var/www/html/requested-file.txt\n\n# Fix permission issues\nsudo chown -R www-data:www-data /var/www/html/\nsudo chmod -R 644 /var/www/html/*.txt\nsudo chmod -R 755 /var/www/html/  # Directories need execute permission\n```\n\n#### Milestone 4: Concurrent Connections Issues\n\nConcurrency introduces complex issues around thread safety, resource contention, and synchronization. These problems often appear only under load or in specific timing conditions.\n\n**Thread Safety Violations:**\n\n⚠️ **Pitfall: Shared Data Race Conditions**\nMultiple threads accessing shared data structures without proper synchronization leads to data corruption, crashes, and unpredictable behavior that only appears under concurrent load.\n\n| **Shared Resource** | **Race Condition** | **Symptom** | **Solution** |\n|--------------------|--------------------|-------------|-------------|\n| Connection counter | Increment/decrement without mutex | Incorrect active count | Use atomic operations or mutex |\n| Configuration data | Modification during request processing | Inconsistent behavior | Make configuration read-only |\n| Log files | Concurrent writes | Interleaved log messages | Use per-thread buffers or mutex |\n| File handle cache | Cache updates | File corruption | Synchronize cache operations |\n\n**Thread Pool Exhaustion:**\n\n⚠️ **Pitfall: Uncontrolled Thread Creation**\nCreating unlimited threads for incoming connections leads to resource exhaustion and system instability under high load. The system runs out of memory or reaches thread limits.\n\n```c\n// Dangerous approach - unlimited thread creation\nvoid handle_connection(int server_fd) {\n    int client_fd = accept(server_fd, NULL, NULL);\n    pthread_t thread;\n    pthread_create(&thread, NULL, handle_client_connection, &client_fd);\n    pthread_detach(thread);  // Creates unlimited threads!\n}\n\n// Safe approach with connection limits\nConcurrencyManager* manager = init_concurrency_manager(config, THREAD_POOL);\nif (get_active_connection_count(manager) >= config->max_connections) {\n    send_503_service_unavailable(client_fd);\n    close(client_fd);\n    return;\n}\n```\n\n**Deadlock Detection:**\n\n⚠️ **Pitfall: Lock Ordering Deadlocks**\nMultiple threads acquiring locks in different orders can create deadlock situations where threads wait for each other indefinitely. This causes the server to hang completely.\n\n| **Thread A** | **Thread B** | **Deadlock Scenario** | **Prevention** |\n|--------------|--------------|----------------------|----------------|\n| Lock mutex1, then mutex2 | Lock mutex2, then mutex1 | Both threads wait forever | Consistent lock ordering |\n| Lock connection_mutex, then stats_mutex | Lock stats_mutex, then connection_mutex | Circular wait condition | Lock hierarchy |\n\n**Resource Cleanup Issues:**\n\n⚠️ **Pitfall: Incomplete Thread Cleanup**\nFailing to properly clean up thread resources on connection termination leads to memory leaks and resource exhaustion over time. Resources accumulate until the server becomes unstable.\n\n```bash\n# Monitor thread resource usage\nps -eLf | grep server | wc -l           # Count total threads\ncat /proc/<pid>/status | grep Threads   # Thread count from kernel\nls /proc/<pid>/task/ | wc -l            # Another way to count threads\n\n# Check for resource leaks over time\nwatch \"ps -o pid,ppid,tid,tty,time,cmd -L -p <pid>\"\n```\n\n### Implementation Guidance\n\n#### Technology Recommendations Table\n\n| **Component** | **Simple Option** | **Advanced Option** |\n|---------------|-------------------|-------------------|\n| Debugging Tools | `printf()` debugging + `gdb` | `valgrind` + `perf` + automated testing |\n| Log Analysis | `grep` + manual inspection | `logrotate` + structured logging |\n| Network Testing | `curl` + `telnet` | `siege` + `ab` (Apache Bench) |\n| Memory Debugging | `valgrind --leak-check=simple` | `valgrind --leak-check=full` + heap profiling |\n| Performance Testing | Single client testing | Multi-threaded load testing |\n\n#### Recommended File Structure\n\n```\nproject-root/\n  debug/\n    debug.h                  ← Debug macros and logging utilities\n    debug.c                  ← Debug implementation\n    test_client.c           ← Simple client for testing\n    load_test.c             ← Concurrent load testing tool\n  logs/\n    server.log              ← Application log output\n    access.log              ← HTTP request logging\n    error.log               ← Error-specific logging\n  tools/\n    monitor.sh              ← System resource monitoring script\n    test_suite.sh           ← Automated test runner\n    debug_server.sh         ← Script to start server with debugging\n```\n\n#### Infrastructure Starter Code\n\n**Debug Logging Utility (`debug/debug.h`):**\n```c\n#ifndef DEBUG_H\n#define DEBUG_H\n\n#include <stdio.h>\n#include <time.h>\n#include <sys/types.h>\n\n// Debug levels\ntypedef enum {\n    DEBUG_ERROR = 0,\n    DEBUG_WARN = 1,\n    DEBUG_INFO = 2,\n    DEBUG_DEBUG = 3,\n    DEBUG_TRACE = 4\n} DebugLevel;\n\n// Debug configuration\nextern DebugLevel current_debug_level;\nextern FILE* debug_output;\n\n// Initialize debugging system\nvoid init_debug_system(const char* log_file, DebugLevel level);\nvoid cleanup_debug_system(void);\n\n// Logging macros with file, line, and timestamp\n#define DEBUG_LOG(level, fmt, ...) \\\n    do { \\\n        if (level <= current_debug_level) { \\\n            time_t now = time(NULL); \\\n            struct tm* tm_info = localtime(&now); \\\n            fprintf(debug_output, \"[%04d-%02d-%02d %02d:%02d:%02d] [%s] %s:%d: \" fmt \"\\n\", \\\n                    tm_info->tm_year + 1900, tm_info->tm_mon + 1, tm_info->tm_mday, \\\n                    tm_info->tm_hour, tm_info->tm_min, tm_info->tm_sec, \\\n                    level_to_string(level), __FILE__, __LINE__, ##__VA_ARGS__); \\\n            fflush(debug_output); \\\n        } \\\n    } while(0)\n\n#define ERROR(fmt, ...)   DEBUG_LOG(DEBUG_ERROR, fmt, ##__VA_ARGS__)\n#define WARN(fmt, ...)    DEBUG_LOG(DEBUG_WARN, fmt, ##__VA_ARGS__)\n#define INFO(fmt, ...)    DEBUG_LOG(DEBUG_INFO, fmt, ##__VA_ARGS__)\n#define DEBUG(fmt, ...)   DEBUG_LOG(DEBUG_DEBUG, fmt, ##__VA_ARGS__)\n#define TRACE(fmt, ...)   DEBUG_LOG(DEBUG_TRACE, fmt, ##__VA_ARGS__)\n\n// Performance timing helpers\ntypedef struct {\n    struct timespec start_time;\n    const char* operation_name;\n} PerfTimer;\n\nvoid start_perf_timer(PerfTimer* timer, const char* operation);\nvoid end_perf_timer(PerfTimer* timer);\n\n// Memory debugging helpers\nvoid* debug_malloc(size_t size, const char* file, int line);\nvoid debug_free(void* ptr, const char* file, int line);\n\n#ifdef DEBUG_MEMORY\n#define malloc(size) debug_malloc(size, __FILE__, __LINE__)\n#define free(ptr) debug_free(ptr, __FILE__, __LINE__)\n#endif\n\n// Network debugging helpers\nvoid dump_http_request(const HTTPRequest* request);\nvoid dump_http_response(const HTTPResponse* response);\nvoid dump_connection_context(const ConnectionContext* context);\nvoid log_connection_event(const ConnectionContext* context, const char* event);\n\n// Resource monitoring\nvoid log_resource_usage(pid_t server_pid);\nvoid check_file_descriptor_leaks(pid_t server_pid);\n\n#endif // DEBUG_H\n```\n\n**Test Client Utility (`debug/test_client.c`):**\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <pthread.h>\n#include <time.h>\n#include \"debug.h\"\n\ntypedef struct {\n    char server_host[256];\n    int server_port;\n    char request_path[1024];\n    int client_id;\n    int* success_count;\n    pthread_mutex_t* count_mutex;\n} ClientConfig;\n\n// Complete test client implementation for concurrent testing\nint send_http_request(const char* host, int port, const char* path, \n                     char* response, size_t max_response) {\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        ERROR(\"Failed to create socket: %s\", strerror(errno));\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    \n    if (inet_pton(AF_INET, host, &server_addr.sin_addr) <= 0) {\n        ERROR(\"Invalid address: %s\", host);\n        close(sockfd);\n        return -1;\n    }\n\n    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        ERROR(\"Connection failed: %s\", strerror(errno));\n        close(sockfd);\n        return -1;\n    }\n\n    // Send HTTP request\n    char request[1024];\n    snprintf(request, sizeof(request),\n             \"GET %s HTTP/1.1\\r\\n\"\n             \"Host: %s:%d\\r\\n\"\n             \"Connection: close\\r\\n\"\n             \"\\r\\n\",\n             path, host, port);\n\n    ssize_t sent = send(sockfd, request, strlen(request), 0);\n    if (sent < 0) {\n        ERROR(\"Failed to send request: %s\", strerror(errno));\n        close(sockfd);\n        return -1;\n    }\n\n    // Receive response\n    ssize_t received = recv(sockfd, response, max_response - 1, 0);\n    if (received < 0) {\n        ERROR(\"Failed to receive response: %s\", strerror(errno));\n        close(sockfd);\n        return -1;\n    }\n    response[received] = '\\0';\n\n    close(sockfd);\n    return 0;\n}\n\nvoid* client_thread(void* arg) {\n    ClientConfig* config = (ClientConfig*)arg;\n    char response[MAX_RESPONSE_SIZE];\n    \n    INFO(\"Client %d starting request to %s:%d%s\", \n         config->client_id, config->server_host, config->server_port, config->request_path);\n\n    int result = send_http_request(config->server_host, config->server_port, \n                                  config->request_path, response, sizeof(response));\n    \n    if (result == 0) {\n        // Check for successful HTTP response\n        if (strstr(response, \"HTTP/1.1 200\") != NULL) {\n            pthread_mutex_lock(config->count_mutex);\n            (*config->success_count)++;\n            pthread_mutex_unlock(config->count_mutex);\n            INFO(\"Client %d received successful response\", config->client_id);\n        } else {\n            WARN(\"Client %d received error response: %.100s\", config->client_id, response);\n        }\n    } else {\n        ERROR(\"Client %d failed to send request\", config->client_id);\n    }\n\n    return NULL;\n}\n\n// Main function for concurrent client testing\nint main(int argc, char* argv[]) {\n    if (argc != 5) {\n        printf(\"Usage: %s <host> <port> <path> <num_clients>\\n\", argv[0]);\n        return 1;\n    }\n\n    init_debug_system(\"test_client.log\", DEBUG_INFO);\n\n    const char* host = argv[1];\n    int port = atoi(argv[2]);\n    const char* path = argv[3];\n    int num_clients = atoi(argv[4]);\n\n    pthread_t threads[MAX_CONCURRENT_CLIENTS];\n    ClientConfig configs[MAX_CONCURRENT_CLIENTS];\n    int success_count = 0;\n    pthread_mutex_t count_mutex = PTHREAD_MUTEX_INITIALIZER;\n\n    if (num_clients > MAX_CONCURRENT_CLIENTS) {\n        ERROR(\"Too many clients requested. Maximum is %d\", MAX_CONCURRENT_CLIENTS);\n        return 1;\n    }\n\n    INFO(\"Starting concurrent test with %d clients\", num_clients);\n    time_t start_time = time(NULL);\n\n    // Create client threads\n    for (int i = 0; i < num_clients; i++) {\n        strncpy(configs[i].server_host, host, sizeof(configs[i].server_host) - 1);\n        configs[i].server_port = port;\n        strncpy(configs[i].request_path, path, sizeof(configs[i].request_path) - 1);\n        configs[i].client_id = i;\n        configs[i].success_count = &success_count;\n        configs[i].count_mutex = &count_mutex;\n\n        if (pthread_create(&threads[i], NULL, client_thread, &configs[i]) != 0) {\n            ERROR(\"Failed to create client thread %d\", i);\n            return 1;\n        }\n    }\n\n    // Wait for all clients to complete\n    for (int i = 0; i < num_clients; i++) {\n        pthread_join(threads[i], NULL);\n    }\n\n    time_t end_time = time(NULL);\n    INFO(\"Test completed: %d/%d requests succeeded in %ld seconds\", \n         success_count, num_clients, end_time - start_time);\n\n    cleanup_debug_system();\n    return (success_count == num_clients) ? 0 : 1;\n}\n```\n\n#### Core Logic Skeleton Code\n\n**Debug Integration Points (`debug/debug.c`):**\n```c\n#include \"debug.h\"\n#include \"../http_server.h\"  // Include main server headers\n\n// TODO 1: Implement debug level configuration from command line or config file\n// TODO 2: Add rotation support for log files to prevent disk space issues\n// TODO 3: Implement performance counters for requests per second, average response time\n// TODO 4: Add memory leak detection hooks that track malloc/free pairs\n// TODO 5: Implement network event logging for connection accept, close, error events\n\nvoid init_debug_system(const char* log_file, DebugLevel level) {\n    // TODO: Open log file with error checking\n    // TODO: Set up signal handlers for log rotation (SIGUSR1)\n    // TODO: Initialize performance monitoring structures\n    // TODO: Set debug level and validate range\n}\n\nvoid log_request_processing(const HTTPRequest* request, const ConnectionContext* context) {\n    // TODO 1: Log request line (method, path, version) with client IP\n    // TODO 2: Log important headers (Host, Content-Length, User-Agent)\n    // TODO 3: Record request timestamp for performance measurement\n    // TODO 4: Assign unique request ID for tracking through processing pipeline\n    // TODO 5: Log any security-relevant information (potential attacks)\n}\n\nvoid log_response_generation(const HTTPResponse* response, const ConnectionContext* context) {\n    // TODO 1: Log response status code and reason phrase\n    // TODO 2: Log response size (Content-Length) for bandwidth monitoring\n    // TODO 3: Calculate and log request processing time\n    // TODO 4: Log any errors that occurred during request processing\n    // TODO 5: Update performance counters (total requests, success rate)\n}\n\nvoid debug_connection_state(const ConnectionContext* context, ConnectionState state) {\n    // TODO 1: Log state transition with timestamp and connection ID\n    // TODO 2: Track connection duration in each state for performance analysis\n    // TODO 3: Detect stuck connections that stay in same state too long\n    // TODO 4: Log thread ID handling this connection for concurrency debugging\n    // TODO 5: Record any error conditions that triggered state changes\n}\n\nvoid monitor_server_health(pid_t server_pid) {\n    // TODO 1: Read /proc/<pid>/stat to get CPU usage, memory usage, thread count\n    // TODO 2: Count open file descriptors in /proc/<pid>/fd/ directory\n    // TODO 3: Check listening socket status and connection queue depth\n    // TODO 4: Monitor for memory leaks by tracking heap size growth\n    // TODO 5: Alert if resource usage exceeds configurable thresholds\n    // Hint: Use /proc filesystem for detailed process information\n}\n```\n\n#### Language-Specific Hints\n\n**GDB Debugging Techniques:**\n- Use `set follow-fork-mode child` to debug worker threads in thread-per-connection model\n- Create `.gdbinit` file with custom commands for examining server structures\n- Use `thread apply all bt` to see all thread call stacks when investigating deadlocks\n- Set conditional breakpoints: `break handle_client_connection if client_fd == 7`\n\n**Valgrind Memory Debugging:**\n- Compile with `-g -O0` for better stack traces in Valgrind output\n- Use `--track-origins=yes` to see where uninitialized memory came from\n- Set `--leak-check=full --show-leak-kinds=all` for comprehensive leak detection\n- Use suppressions file to ignore false positives from system libraries\n\n**System Call Tracing:**\n- Use `strace -e trace=network,file` to see only networking and file operations\n- Add `-f` flag to trace child processes and threads\n- Use `-o trace.log` to capture output to file for analysis\n- Filter specific operations: `strace -e trace=read,write,accept,close`\n\n#### Milestone Checkpoint\n\n**After Implementing Debug Infrastructure:**\n```bash\n# Compile server with debug support\ngcc -DDEBUG_MEMORY -g -O0 -o http_server *.c -lpthread\n\n# Start server with debug logging\n./http_server --debug-level=3 --log-file=debug.log --port=8080\n\n# Test with concurrent clients\n./test_client localhost 8080 /index.html 10\n\n# Check for resource leaks\nvalgrind --leak-check=full ./http_server --port=8081 &\nsleep 5\n./test_client localhost 8081 / 5\nkill %1\n```\n\n**Expected Debug Output:**\n- Connection accept and close events with timestamps\n- Request parsing progress with validation results\n- File serving operations with path resolution details\n- Thread creation and cleanup events\n- Performance timing for each request phase\n- Resource usage summaries (memory, file descriptors, threads)\n\n**Signs of Issues:**\n- Missing cleanup log entries indicate resource leaks\n- Increasing response times suggest performance degradation\n- Error logs with stack traces indicate crash conditions\n- File descriptor counts that don't decrease indicate leaks\n\n\n## Future Extensions\n\n> **Milestone(s):** Beyond Milestones 1-4 - explores potential enhancements and architectural considerations for evolving the HTTP server into a production-quality system\n\nThe future extensions section serves as our **roadmap for growth** - examining how the current educational HTTP server can evolve into a production-ready system while maintaining its architectural foundations. Think of this like **planning the expansion of a successful small business**: we need to understand which parts of our current structure will scale gracefully, which components will need fundamental redesign, and how to prioritize improvements based on real-world usage patterns.\n\nThe beauty of a well-designed educational project lies not just in what it teaches initially, but in how it **grows with the learner**. Our current HTTP server implementation provides a solid foundation of networking, HTTP protocol handling, and concurrency management concepts. However, the gap between an educational server and a production system involves numerous considerations around performance, security, standards compliance, and operational requirements.\n\nThis section explores three major categories of extensions: **HTTP protocol enhancements** that expand our standards compliance and feature set, **performance optimizations** that enable the server to handle production-scale loads efficiently, and **security enhancements** that protect against real-world threats. Each category represents a different dimension of system evolution, and understanding their interactions helps guide prioritization decisions.\n\nThe architectural decisions we made during the initial implementation - particularly around component separation, data structure design, and error handling patterns - directly impact how easily these extensions can be integrated. Well-designed extensibility points become **force multipliers** for future development, while architectural technical debt creates **friction and complexity** that slows enhancement efforts.\n\n### HTTP Protocol Extensions\n\nThe HTTP protocol landscape extends far beyond the basic GET request handling implemented in our educational server. Modern web applications require support for additional HTTP methods, transfer encoding mechanisms, and protocol versions that enable richer client-server interactions and improved performance characteristics.\n\n#### Mental Model: Library Service Expansion\n\nThink of HTTP protocol extensions like **expanding a library's services**. Our current server is like a basic reference desk that can find and deliver books (static files). Adding POST support is like adding a **suggestion box** where patrons can submit new information. Implementing chunked encoding is like allowing **serialized novel delivery** - sending a long book chapter by chapter rather than making patrons wait for the complete volume. Upgrading to HTTP/2 is like **revolutionizing the entire library system** - allowing multiple simultaneous book requests, prioritized delivery, and compressed catalog information.\n\nEach protocol extension builds upon our existing foundation while adding new capabilities that serve different use cases and performance requirements.\n\n#### POST Request Support\n\nAdding POST request support represents the most fundamental HTTP protocol extension, transforming our server from a **read-only content delivery system** into a **bidirectional communication platform**. This enhancement primarily impacts our HTTP parser component and requires new data handling patterns throughout the request processing pipeline.\n\nThe POST method differs significantly from GET requests in several key aspects. POST requests typically include substantial **message body content** that must be parsed, validated, and processed according to the specified Content-Type header. Unlike GET requests where all parameters are encoded in the URL path and query string, POST requests can carry **arbitrary payload data** ranging from form submissions to JSON API calls to file uploads.\n\nOur current `HTTPRequest` structure already includes `body` and `body_length` fields designed to accommodate POST request handling, but the parser implementation focuses exclusively on GET request scenarios. Extending POST support requires enhancing the `parse_message_body` function to handle different encoding types and implementing new request processing logic throughout the system.\n\n| POST Implementation Component | Current State | Required Enhancement | Complexity Level |\n|-------------------------------|---------------|---------------------|------------------|\n| Request Body Parsing | Placeholder implementation | Full Content-Length and Content-Type handling | Medium |\n| Form Data Processing | Not implemented | URL-encoded and multipart parsing | High |\n| JSON Payload Handling | Not implemented | JSON parsing and validation | Medium |\n| File Upload Support | Not implemented | Multipart form processing with file boundaries | High |\n| Request Routing | Path-based only | Method-based routing with POST endpoints | Low |\n| Response Generation | Static content only | Dynamic response creation based on POST data | Medium |\n\nThe most straightforward POST enhancement involves implementing **application/x-www-form-urlencoded** form processing, where the message body contains key-value pairs encoded similar to URL query parameters. This builds directly on existing URL parsing concepts while introducing message body handling patterns.\n\nMore sophisticated POST implementations require supporting **multipart/form-data** encoding for file uploads, which introduces complex parsing logic for boundary detection and multiple content sections within a single request. The multipart parsing challenge involves state machine logic similar to our existing HTTP header parsing but with additional complexity around binary data handling and content boundary recognition.\n\n> **Key Design Insight**: POST request support fundamentally changes the server's role from a passive content delivery system to an active data processing system, requiring careful consideration of data validation, storage, and security implications.\n\n**Architecture Decision Record for POST Implementation Strategy:**\n\n> **Decision: Form-First POST Implementation**\n> - **Context**: Multiple POST payload types have different complexity levels and use cases, requiring prioritization of implementation order\n> - **Options Considered**: 1) JSON-first API server approach, 2) Form-first web application approach, 3) Generic payload processor\n> - **Decision**: Implement form-encoded POST requests first, followed by JSON, then multipart file uploads\n> - **Rationale**: Form encoding builds naturally on existing URL parsing logic, provides immediate value for web applications, and establishes message body processing patterns for more complex formats\n> - **Consequences**: Creates a natural progression from simple to complex POST handling while maintaining compatibility with existing GET-focused architecture\n\n#### Chunked Transfer Encoding\n\nChunked transfer encoding addresses a fundamental limitation in our current static file serving approach: the requirement to know the complete response size before sending the HTTP headers. This encoding mechanism enables **streaming response delivery** where content can be generated and transmitted incrementally without buffering the entire response in memory.\n\nThe current file serving implementation uses the `serve_file_content` function to read complete files into memory and set the Content-Length header before transmission. This approach works well for small static files but creates **memory pressure** and **response latency** issues for large files or dynamically generated content.\n\nChunked encoding transforms the HTTP response format by removing the Content-Length header and instead sending the message body as a series of **size-prefixed chunks** terminated by a zero-length chunk. Each chunk includes a hexadecimal size indicator followed by the actual data bytes, enabling the client to reconstruct the complete response without knowing the total size in advance.\n\n| Chunked Encoding Component | Implementation Requirements | Integration Points |\n|-----------------------------|----------------------------|-------------------|\n| Response Header Modification | Replace Content-Length with Transfer-Encoding: chunked | `add_response_header` function |\n| Chunk Size Calculation | Determine optimal chunk sizes for different content types | File reading and response generation |\n| Chunk Formatting | Hex size prefix + CRLF + data + CRLF formatting | Socket writing functions |\n| Stream Processing | Read-process-send pipeline instead of read-all-send | `serve_file_content` redesign |\n| Error Handling | Partial chunk transmission and recovery scenarios | Connection cleanup procedures |\n| Client Compatibility | HTTP/1.1 compliance and graceful fallback | Request parsing and negotiation |\n\nThe implementation challenge centers around **transforming our file serving pipeline** from a buffer-based approach to a streaming approach. Instead of calling `read_file_content` to load an entire file, the chunked implementation requires a `stream_file_content` function that reads fixed-size chunks, formats them according to the chunked encoding specification, and sends them immediately.\n\nChunked encoding particularly benefits scenarios involving **large static files** (videos, archives, datasets) and **dynamic content generation** (server-side rendering, API responses based on database queries). The memory usage remains constant regardless of response size, and clients can begin processing received data before the complete response arrives.\n\nThe error handling implications of chunked encoding extend beyond simple file reading failures. Network interruptions during chunk transmission create **partially transmitted responses** that require careful cleanup and potential retry logic. Unlike fixed-length responses where clients can easily detect incomplete transmissions, chunked responses require proper termination with a zero-length chunk to signal completion.\n\n> **Performance Consideration**: Chunked encoding trades CPU overhead (chunk formatting) for memory efficiency and reduced latency, making it particularly valuable for resource-constrained servers handling large files or high concurrency loads.\n\n#### HTTP/2 Protocol Support\n\nHTTP/2 represents the most significant protocol enhancement, introducing **multiplexed streams**, **header compression**, **server push**, and **binary framing** that fundamentally change client-server communication patterns. This upgrade provides substantial performance benefits but requires extensive architectural modifications throughout our server implementation.\n\nThe current HTTP server operates on HTTP/1.1 assumptions: **one request per connection**, **text-based headers**, and **sequential request processing**. HTTP/2 transforms each TCP connection into a **multiplexed stream container** where multiple requests and responses can be interleaved, prioritized, and processed concurrently.\n\n**Key HTTP/2 Features and Implementation Challenges:**\n\n| HTTP/2 Feature | Description | Implementation Complexity | Architectural Impact |\n|----------------|-------------|---------------------------|---------------------|\n| Binary Framing | Replace text-based protocol with binary frame format | High | Complete parser rewrite |\n| Stream Multiplexing | Multiple requests per connection with stream IDs | Very High | Concurrency model redesign |\n| Header Compression (HPACK) | Stateful header compression across requests | High | New compression state management |\n| Server Push | Proactive resource delivery before client requests | Medium | New response generation patterns |\n| Flow Control | Per-stream and connection-level flow control | High | New backpressure handling |\n| Stream Prioritization | Client-specified request priority handling | Medium | Scheduler implementation |\n\nThe **binary framing layer** represents the foundation of HTTP/2 implementation, requiring a complete replacement of our text-based HTTP parser with a binary frame parser that handles different frame types (DATA, HEADERS, SETTINGS, WINDOW_UPDATE, etc.). This change affects every component that currently processes HTTP messages.\n\n**Stream multiplexing** introduces the most significant architectural challenge: transforming our connection-based concurrency model into a **stream-based model**. Instead of dedicating threads or event handlers to individual connections, HTTP/2 requires managing multiple concurrent streams within each connection while maintaining proper flow control and prioritization.\n\nThe HPACK header compression algorithm maintains **connection-specific compression state** that must be synchronized between client and server across all streams within a connection. This stateful compression provides significant bandwidth savings for repeated headers but introduces complexity around state management and error recovery.\n\n**HTTP/2 Architecture Decision Record:**\n\n> **Decision: HTTP/2 as Separate Server Implementation**\n> - **Context**: HTTP/2 requires extensive architectural changes that conflict with educational clarity of current HTTP/1.1 implementation\n> - **Options Considered**: 1) Extend current server with HTTP/2 support, 2) Create separate HTTP/2 server, 3) Implement HTTP/2 proxy layer\n> - **Decision**: Implement HTTP/2 as a separate server that shares file handling and configuration components\n> - **Rationale**: Maintains educational clarity of HTTP/1.1 implementation while allowing HTTP/2 exploration without architectural compromises\n> - **Consequences**: Requires code duplication for shared functionality but preserves learning progression and enables focused HTTP/2 study\n\nHTTP/2 server push capabilities enable **proactive resource delivery** where the server anticipates client needs and sends resources before explicit requests. For static file servers, this might involve automatically pushing CSS and JavaScript files when serving HTML pages, reducing overall page load times.\n\nThe implementation complexity of full HTTP/2 support suggests treating it as a **separate learning project** rather than an extension of the current server. The concepts learned from HTTP/1.1 implementation provide essential background for understanding HTTP/2 benefits and trade-offs, but the implementation approaches differ significantly enough to warrant dedicated focus.\n\n### Performance Optimizations\n\nPerformance optimization transforms our educational HTTP server from a **learning demonstration** into a **production-capable system** by addressing efficiency bottlenecks, resource utilization patterns, and scalability limitations inherent in the straightforward implementation approach.\n\n#### Mental Model: Restaurant Efficiency Improvements\n\nThink of performance optimizations like **improving restaurant operations**. Our current server is like a small family restaurant that prepares each order individually from scratch - functional but inefficient under load. Adding caching is like **preparing popular dishes in advance** and keeping them warm. Connection pooling is like **seating arrangements** that minimize table turnover time. Asynchronous I/O is like **optimizing kitchen workflow** so cooks don't wait idle while ingredients are being prepared.\n\nEach optimization addresses specific bottlenecks while maintaining the core functionality and correctness of the original system.\n\n#### Response Caching System\n\nResponse caching addresses the fundamental inefficiency of **repeatedly reading and processing identical static files** for multiple client requests. Our current implementation calls `serve_file_content` for every request, resulting in redundant file system operations, memory allocations, and response formatting work.\n\nA well-designed caching system maintains **pre-processed response data** in memory for frequently requested files, eliminating file system access latency and reducing CPU overhead for duplicate requests. The caching implementation requires careful consideration of memory usage, cache invalidation policies, and thread safety for concurrent access patterns.\n\n**Cache Architecture Components:**\n\n| Cache Component | Responsibility | Design Considerations |\n|-----------------|---------------|----------------------|\n| Cache Storage | In-memory response data storage | Memory limits, eviction policies, data structure efficiency |\n| Cache Keys | Unique identifiers for cached responses | File path normalization, query parameter handling |\n| Cache Validation | Determining when cached data is stale | File modification time tracking, TTL policies |\n| Cache Population | Loading and formatting responses for storage | Background vs. on-demand loading strategies |\n| Cache Eviction | Removing entries when memory limits reached | LRU, LFU, or size-based eviction algorithms |\n| Thread Safety | Concurrent access protection | Read-write locks, atomic operations |\n\nThe cache key generation strategy directly impacts both **correctness** and **performance**. Simple file path keys work for basic static serving but require enhancement for scenarios involving query parameters, range requests, or content negotiation. Cache keys must account for all factors that influence response content while remaining efficient to compute and compare.\n\n**Cache Validation Mechanisms:**\n\n| Validation Approach | Implementation | Pros | Cons |\n|---------------------|---------------|------|------|\n| File Modification Time | Compare cached mtime with current file mtime | Simple, automatic invalidation | Requires stat() system call per request |\n| Time-To-Live (TTL) | Expire entries after fixed time period | Minimal overhead, predictable memory usage | May serve stale content, requires tuning |\n| Manual Invalidation | Administrative cache clearing commands | Precise control over freshness | Requires operational procedures |\n| Content Hashing | Hash file contents for change detection | Accurate change detection | CPU overhead for large files |\n\nMemory management becomes critical for caching systems serving diverse content types and sizes. **Large file caching** can quickly exhaust available memory, while **many small files** create overhead from cache entry bookkeeping. Effective cache implementations require **adaptive policies** that balance memory usage against cache hit rates.\n\nThe thread safety requirements for caching introduce **reader-writer lock patterns** where multiple threads can simultaneously read cached responses but cache updates require exclusive access. High-performance implementations might use **lock-free data structures** or **per-thread cache partitions** to minimize synchronization overhead.\n\n> **Cache Design Insight**: The optimal cache strategy depends heavily on access patterns - a few frequently requested files benefit from simple LRU caching, while many equally popular files require more sophisticated memory management and eviction policies.\n\n**Architecture Decision Record for Cache Implementation:**\n\n> **Decision: Two-Tier Cache with Size-Based Eviction**\n> - **Context**: Static file servers exhibit varied access patterns from hot index pages to diverse asset files, requiring different caching strategies\n> - **Options Considered**: 1) Simple LRU cache, 2) TTL-based cache, 3) Two-tier cache with hot/warm separation\n> - **Decision**: Implement small hot cache for most frequent files plus larger warm cache with size-based eviction\n> - **Rationale**: Hot cache ensures best performance for critical files, warm cache handles diverse access patterns without excessive memory usage\n> - **Consequences**: Increased implementation complexity but better performance characteristics across different usage patterns\n\n#### Connection Pooling and Keep-Alive\n\nConnection pooling optimizations address the **TCP connection establishment overhead** that becomes significant under high request loads. Our current implementation follows a **connection-per-request** pattern where each HTTP request requires complete TCP handshake, processing, and teardown cycles.\n\nHTTP/1.1 keep-alive functionality enables **connection reuse** where a single TCP connection can handle multiple sequential HTTP requests, eliminating repeated connection establishment costs. This optimization particularly benefits scenarios with **multiple small requests** from the same client, such as web pages loading numerous CSS, JavaScript, and image assets.\n\n**Keep-Alive Implementation Requirements:**\n\n| Keep-Alive Component | Current Implementation | Required Changes |\n|---------------------|----------------------|------------------|\n| Connection State Tracking | Single request per connection | Multi-request connection lifecycle management |\n| Request Parsing | Read once and close | Continuous parsing loop with request boundaries |\n| Response Headers | Connection: close default | Connection: keep-alive header management |\n| Timeout Handling | Simple request timeout | Idle connection timeout and cleanup |\n| Resource Management | Per-request cleanup | Connection-level resource management |\n| Error Recovery | Close on any error | Graceful error handling with connection preservation |\n\nThe keep-alive implementation transforms our **connection handling loop** from a single request processor into a **multi-request state machine**. After sending each response, the server must determine whether to close the connection or continue listening for additional requests on the same socket.\n\nConnection timeout management becomes more sophisticated with keep-alive support. Instead of simple request processing timeouts, the server must track **idle connection time** and implement policies for closing connections that remain unused beyond acceptable limits. This prevents **connection resource exhaustion** from clients that establish connections but send no additional requests.\n\n**Connection Pooling Architecture:**\n\n| Pool Component | Functionality | Implementation Considerations |\n|----------------|---------------|------------------------------|\n| Active Connection Registry | Track all open keep-alive connections | Thread-safe connection list management |\n| Idle Timeout Monitor | Close connections exceeding idle time limits | Background cleanup thread or event-driven expiration |\n| Connection Limits | Enforce maximum concurrent connection counts | Per-client and global connection limits |\n| Graceful Shutdown | Complete in-flight requests before closing | Coordinated shutdown across pooled connections |\n\nThe connection pooling system must **balance resource utilization** against performance benefits. Keeping too many idle connections consumes file descriptors and memory, while aggressive connection closing eliminates performance advantages. Effective implementations use **adaptive timeout policies** that adjust based on server load and connection usage patterns.\n\nError handling complexity increases with connection pooling because errors can occur **between requests** rather than just during request processing. Network errors, client disconnections, and protocol violations must be detected and handled gracefully while preserving other active connections within the pool.\n\n> **Performance Trade-off**: Keep-alive connections reduce latency and CPU overhead for multiple requests but increase memory usage and complexity around connection lifecycle management and error recovery.\n\n#### Asynchronous I/O and Event-Driven Processing\n\nAsynchronous I/O represents the most significant architectural optimization, transforming our **thread-based concurrency model** into an **event-driven model** that can handle thousands of concurrent connections with minimal resource overhead. This optimization addresses the fundamental scalability limitation of thread-per-connection architectures.\n\nOur current threading implementation creates **OS threads** for each client connection, leading to substantial memory overhead (typically 2-8MB per thread for stack space) and **context switching costs** as the number of concurrent connections increases. Event-driven architectures use a **single thread with I/O multiplexing** to handle many connections efficiently.\n\n**Event-Driven Architecture Components:**\n\n| Component | Thread-Based Current | Event-Driven Alternative | Benefits |\n|-----------|---------------------|-------------------------|----------|\n| Connection Management | Thread per connection | Single event loop with connection registry | Reduced memory overhead |\n| I/O Operations | Blocking reads and writes | Non-blocking I/O with event notifications | Eliminate thread blocking |\n| Request Processing | Sequential within thread | State machine with event callbacks | Handle partial operations efficiently |\n| Concurrency Control | Thread synchronization | Single-threaded with cooperative scheduling | Eliminate race conditions |\n| Resource Usage | Scales with thread count | Constant regardless of connection count | Improved scalability |\n\nThe **event loop** becomes the core architectural component, continuously polling for I/O events across all active connections and dispatching appropriate handlers based on event types (readable, writable, error conditions). This requires transforming our **sequential request processing logic** into a **state machine** that can handle partial operations and resume processing when I/O operations complete.\n\n**State Machine for Event-Driven Request Processing:**\n\n| Connection State | Event Trigger | Next State | Actions Performed |\n|------------------|---------------|------------|-------------------|\n| `CONNECTION_READING_REQUEST` | Socket readable | `CONNECTION_PARSING_REQUEST` | Read available data, check for complete request |\n| `CONNECTION_PARSING_REQUEST` | Request complete | `CONNECTION_HANDLING_REQUEST` | Parse HTTP request, validate headers |\n| `CONNECTION_HANDLING_REQUEST` | File I/O complete | `CONNECTION_SENDING_RESPONSE` | Generate response, prepare for transmission |\n| `CONNECTION_SENDING_RESPONSE` | Socket writable | `CONNECTION_READING_REQUEST` or cleanup | Send response data, handle partial writes |\n| `CONNECTION_ERROR` | Any error condition | Connection cleanup | Log error, close socket, free resources |\n\nThe **file I/O handling** presents particular challenges for event-driven architectures because traditional file operations are **inherently blocking**. Reading large files can stall the entire event loop, negating the benefits of asynchronous networking. Advanced implementations require **thread pools for blocking operations** or **asynchronous file I/O** using system-specific interfaces like Linux's `io_uring` or POSIX AIO.\n\n**Non-Blocking I/O Considerations:**\n\n| I/O Operation | Blocking Behavior | Event-Driven Solution |\n|---------------|-------------------|----------------------|\n| Socket Accept | May block if no connections pending | Use `select`/`poll`/`epoll` to check readiness |\n| Socket Read | May block if no data available | Read only when socket is readable, handle partial reads |\n| Socket Write | May block if send buffer full | Write only when socket is writable, queue remaining data |\n| File Read | Always blocks until data available | Use thread pool or async file I/O interfaces |\n| File Stat | May block for network filesystems | Cache stat results or use background threads |\n\nMemory management patterns change significantly in event-driven architectures. Instead of **per-thread stack allocation**, all connection state must be **heap-allocated** and managed explicitly. This requires careful attention to memory leaks and proper cleanup when connections close unexpectedly.\n\n**Architecture Decision Record for Asynchronous I/O:**\n\n> **Decision: Hybrid Event-Driven with Thread Pool for Blocking Operations**\n> - **Context**: Pure event-driven architecture conflicts with educational clarity while pure threading doesn't scale effectively\n> - **Options Considered**: 1) Pure event-driven with async file I/O, 2) Thread-per-connection with optimizations, 3) Hybrid approach\n> - **Decision**: Event-driven networking with dedicated thread pool for file operations\n> - **Rationale**: Provides scalability benefits of event-driven I/O while maintaining comprehensible file handling logic\n> - **Consequences**: More complex architecture but realistic performance characteristics for production deployment\n\nThe debugging and development complexity of event-driven systems significantly exceeds threaded implementations. **State transitions** must be carefully managed, **partial operations** must be handled correctly, and **error conditions** can occur at any point in the state machine. However, the scalability benefits often justify this complexity for production systems.\n\n### Security Enhancements\n\nSecurity enhancements transform our educational HTTP server from a **trusted environment demonstration** into a **production-hardened system** capable of safely handling untrusted client requests and operating in hostile network environments. These enhancements address authentication, authorization, encryption, and attack prevention mechanisms essential for real-world deployment.\n\n#### Mental Model: Bank Security Systems\n\nThink of security enhancements like **progressively fortifying a bank**. Our current server is like a **friendly neighborhood credit union** - functional and trustworthy within a known community but lacking defenses against sophisticated threats. Adding HTTPS is like **installing bulletproof glass** and **encrypted communication channels**. Implementing authentication is like **requiring ID verification** and **access badges**. Additional security headers are like **alarm systems** and **surveillance cameras** that detect and deter various attack patterns.\n\nEach security layer addresses specific threat categories while maintaining the core functionality of the underlying system.\n\n#### HTTPS and TLS Implementation\n\nHTTPS support addresses the fundamental security vulnerability of **unencrypted communication** between clients and servers. Our current HTTP implementation transmits all data in plaintext, making it vulnerable to **eavesdropping**, **man-in-the-middle attacks**, and **content tampering** by network intermediaries.\n\nTLS (Transport Layer Security) provides **cryptographic protection** through authentication, encryption, and integrity verification. The TLS handshake establishes a secure channel between client and server using certificate-based server authentication and negotiated encryption algorithms.\n\n**TLS Integration Architecture:**\n\n| TLS Component | Integration Point | Implementation Requirements |\n|---------------|-------------------|----------------------------|\n| Certificate Management | Server startup and configuration | X.509 certificate loading, private key handling, certificate chain validation |\n| TLS Handshake | TCP connection acceptance | Protocol version negotiation, cipher suite selection, certificate presentation |\n| Encrypted I/O | Socket read/write operations | TLS record layer encryption/decryption, MAC verification |\n| Session Management | Connection lifecycle | Session resumption, renegotiation, graceful termination |\n| Error Handling | Connection and protocol errors | TLS-specific error codes, certificate validation failures |\n\nThe **certificate management system** requires handling X.509 certificates, private keys, and certificate authority chains. Production deployments need **automated certificate renewal** integration with services like Let's Encrypt, certificate validation procedures, and secure private key storage.\n\n**TLS Handshake Process Integration:**\n\n| Handshake Phase | Server Responsibilities | Implementation Considerations |\n|-----------------|------------------------|------------------------------|\n| ClientHello Processing | Parse supported cipher suites and extensions | Version compatibility, cipher suite selection policies |\n| Certificate Presentation | Send server certificate chain | Certificate chain validation, intermediate CA handling |\n| Key Exchange | Generate and exchange cryptographic keys | RSA, ECDHE, or other key exchange algorithms |\n| Finished Messages | Verify handshake integrity | MAC computation and verification |\n| Application Data | Begin encrypted HTTP processing | Seamless transition to normal HTTP request handling |\n\nThe **performance implications** of TLS encryption include CPU overhead for cryptographic operations, memory requirements for TLS state, and additional network round-trips for handshake completion. Modern servers use **hardware acceleration** for cryptographic operations and **session resumption** to amortize handshake costs across multiple connections.\n\n**TLS Library Integration Options:**\n\n| TLS Library | Implementation Approach | Pros | Cons |\n|-------------|------------------------|------|------|\n| OpenSSL | Direct library integration | Full feature support, widely used | Complex API, large dependency |\n| mbedTLS | Embedded-focused TLS library | Smaller footprint, cleaner API | Less community support |\n| LibreSSL | OpenSSL fork with security focus | Improved security, simplified API | Compatibility considerations |\n| Native OS TLS | Platform-specific TLS APIs | OS integration, automatic updates | Platform-specific implementation |\n\nThe integration challenge involves **replacing standard socket operations** with TLS-aware equivalents throughout our connection handling code. The `read_complete_request` and response sending functions must use TLS library calls instead of direct socket I/O while maintaining identical semantics for the higher-level HTTP processing logic.\n\n> **Security Consideration**: TLS configuration requires careful attention to cipher suite selection, protocol version support, and certificate validation policies to prevent downgrade attacks and ensure strong cryptographic protection.\n\n**Architecture Decision Record for HTTPS Implementation:**\n\n> **Decision: TLS Termination at HTTP Server Level**\n> - **Context**: HTTPS support can be implemented at the HTTP server level or handled by a reverse proxy in front of our server\n> - **Options Considered**: 1) Integrate TLS directly into HTTP server, 2) Use reverse proxy for TLS termination, 3) Support both deployment modes\n> - **Decision**: Implement TLS integration directly in HTTP server with configuration option to disable for proxy deployments\n> - **Rationale**: Educational value of understanding TLS integration while maintaining flexibility for production deployment patterns\n> - **Consequences**: Increased complexity but comprehensive understanding of HTTPS implementation details\n\n#### Authentication and Authorization Framework\n\nAuthentication and authorization mechanisms enable **identity verification** and **access control** for protected resources, transforming our public file server into a **controlled access system** with user management and permission enforcement capabilities.\n\nAuthentication addresses the question **\"who is this user?\"** through credential verification mechanisms like username/password combinations, API keys, or cryptographic certificates. Authorization answers **\"what can this user access?\"** through permission systems that control resource access based on verified identity and assigned roles.\n\n**Authentication Mechanisms for HTTP Servers:**\n\n| Authentication Method | Implementation Requirements | Security Characteristics | Use Cases |\n|-----------------------|----------------------------|-------------------------|-----------|\n| HTTP Basic Authentication | Base64 credential encoding, credential verification | Simple but requires HTTPS for security | Development, simple applications |\n| HTTP Digest Authentication | Challenge-response with cryptographic hashes | More secure than basic, complex implementation | Legacy compatibility |\n| Bearer Token Authentication | Token generation, validation, and management | Flexible, supports various token formats | API access, modern web applications |\n| Certificate-Based Authentication | Client certificate verification during TLS handshake | Strong security, complex PKI requirements | High-security environments |\n| Session-Based Authentication | Session token management with server-side storage | Traditional web application pattern | User-facing web applications |\n\n**HTTP Basic Authentication** provides the simplest starting point, requiring minimal protocol changes while demonstrating fundamental authentication concepts. The client sends credentials in an Authorization header, and the server validates them against a user database or configuration file.\n\n**Basic Authentication Implementation Components:**\n\n| Component | Functionality | Integration Points |\n|-----------|---------------|-------------------|\n| Credential Storage | User database with hashed passwords | Configuration system, user management |\n| Header Parsing | Extract and decode Authorization header | HTTP parser component |\n| Credential Verification | Compare provided credentials against stored values | Request processing pipeline |\n| Challenge Generation | Send WWW-Authenticate header for unauthorized requests | Error response generation |\n| Protected Resource Identification | Determine which paths require authentication | File handler component |\n\nThe **authorization framework** builds upon authentication to implement **role-based access control** (RBAC) or **access control lists** (ACLs) that define resource-specific permissions. This requires extending our path resolution logic to check user permissions before serving files.\n\n**Authorization Policy Examples:**\n\n| Resource Pattern | Permission Model | Implementation Approach |\n|------------------|------------------|------------------------|\n| `/public/*` | Open access | No authentication required |\n| `/private/*` | Authenticated users only | Require valid authentication |\n| `/admin/*` | Administrative users only | Role-based permission check |\n| `/user/{username}/*` | Owner access only | Path-based ownership validation |\n| `/api/v1/*` | API key authentication | Token-based authentication |\n\nThe **session management** aspect of authentication involves maintaining user state across multiple requests. This requires **secure session token generation**, **server-side session storage**, and **session timeout policies** to balance security and usability.\n\n**Session Management Architecture:**\n\n| Session Component | Responsibilities | Security Considerations |\n|-------------------|------------------|------------------------|\n| Session Token Generation | Create cryptographically secure session identifiers | Use sufficient entropy, avoid predictable patterns |\n| Session Storage | Maintain server-side session data | Memory management, persistence options |\n| Session Validation | Verify session tokens on each request | Constant-time comparison, timeout enforcement |\n| Session Cleanup | Remove expired sessions | Background cleanup processes, memory management |\n| Session Security | Protect against session-based attacks | CSRF protection, secure cookie attributes |\n\n> **Authentication Design Principle**: Authentication systems must balance security requirements with usability concerns - overly complex authentication reduces adoption while insufficient security creates vulnerability to compromise.\n\n#### Security Headers and Attack Prevention\n\nSecurity headers provide **defense-in-depth protection** against common web application attacks by instructing browsers and other clients to enforce additional security policies. These headers complement server-side security measures with **client-side protection mechanisms**.\n\n**Essential Security Headers:**\n\n| Header Name | Protection Purpose | Configuration Considerations |\n|-------------|-------------------|----------------------------|\n| `Strict-Transport-Security` (HSTS) | Enforce HTTPS connections, prevent protocol downgrade | Max-age policy, subdomain inclusion |\n| `Content-Security-Policy` (CSP) | Prevent XSS attacks through content source restrictions | Policy complexity, compatibility requirements |\n| `X-Frame-Options` | Prevent clickjacking attacks | Deny vs. SAMEORIGIN policy choice |\n| `X-Content-Type-Options` | Prevent MIME-type sniffing attacks | nosniff directive for all content |\n| `Referrer-Policy` | Control referrer information disclosure | Privacy vs. functionality balance |\n| `Permissions-Policy` | Control browser feature access | Feature-specific policy configuration |\n\n**Content Security Policy (CSP)** represents the most sophisticated security header, enabling fine-grained control over resource loading and script execution. For static file servers, CSP policies must balance security restrictions with legitimate content requirements.\n\n**CSP Policy Examples for Static File Server:**\n\n| Content Type | CSP Directive | Policy Recommendation | Rationale |\n|--------------|---------------|----------------------|-----------|\n| Scripts | `script-src` | `'self'` for same-origin scripts | Prevent inline scripts and external script injection |\n| Stylesheets | `style-src` | `'self' 'unsafe-inline'` if needed | Allow legitimate styles while blocking malicious CSS |\n| Images | `img-src` | `'self' data:` | Permit same-origin and data URL images |\n| Media | `media-src` | `'self'` | Restrict audio/video sources |\n| Fonts | `font-src` | `'self'` | Control font loading sources |\n| Default | `default-src` | `'self'` | Fallback policy for unspecified resource types |\n\n**Attack Prevention Mechanisms:**\n\n| Attack Vector | Prevention Approach | Implementation Location | Effectiveness |\n|---------------|-------------------|------------------------|---------------|\n| Directory Traversal | Path validation and normalization | File handler component | High |\n| Request Smuggling | Strict HTTP parsing and validation | HTTP parser component | High |\n| Denial of Service | Rate limiting and resource constraints | Connection management | Medium |\n| Buffer Overflow | Bounds checking and safe string operations | All input processing | High |\n| Injection Attacks | Input validation and sanitization | Request processing pipeline | High |\n| Information Disclosure | Error message sanitization | Error handling system | Medium |\n\n**Rate limiting** mechanisms protect against **denial of service attacks** and **resource exhaustion** by limiting the request rate from individual clients or IP addresses. This requires tracking client request patterns and implementing **sliding window** or **token bucket** algorithms for rate enforcement.\n\n**Rate Limiting Implementation Architecture:**\n\n| Rate Limiting Component | Functionality | Design Considerations |\n|-------------------------|---------------|----------------------|\n| Request Tracking | Monitor requests per client/IP address | Memory usage, cleanup policies |\n| Rate Calculation | Compute current request rates | Sliding window vs. fixed window algorithms |\n| Limit Enforcement | Block or throttle excessive requests | HTTP 429 response generation |\n| Configuration Management | Adjustable rate limits per resource | Per-path limits, global limits |\n| Persistence | Optional rate limit state persistence | Recovery after server restart |\n\n**Input validation** and **output encoding** prevent various injection attacks by ensuring that user-provided data cannot be interpreted as executable code or control characters. For HTTP servers, this primarily involves **header validation**, **URL encoding verification**, and **safe error message generation**.\n\n> **Security Design Insight**: Effective security requires defense-in-depth approaches where multiple independent mechanisms provide overlapping protection against different attack vectors and failure modes.\n\n**Architecture Decision Record for Security Implementation Approach:**\n\n> **Decision: Graduated Security Implementation with Configuration Control**\n> - **Context**: Security requirements vary significantly between development, staging, and production environments\n> - **Options Considered**: 1) Maximum security by default, 2) Minimal security with opt-in features, 3) Configurable security levels\n> - **Decision**: Implement tiered security levels (development, staging, production) with clear configuration options\n> - **Rationale**: Enables appropriate security for each deployment context while maintaining educational clarity and flexibility\n> - **Consequences**: Increased configuration complexity but realistic security posture for different deployment scenarios\n\nThe integration of security enhancements requires careful **performance impact assessment** since security operations (encryption, authentication, header processing) add computational overhead to request processing. Production deployments must balance security requirements against performance characteristics and resource utilization constraints.\n\n### Implementation Guidance\n\nThe future extensions described above represent significant undertakings that transform our educational HTTP server into a production-ready system. This implementation guidance provides practical approaches for tackling these enhancements systematically while maintaining code quality and educational value.\n\n#### Technology Recommendations\n\n| Extension Category | Simple Option | Advanced Option |\n|--------------------|---------------|-----------------|\n| POST Request Support | Form-encoded parsing with fixed-size buffers | Streaming parser with configurable size limits |\n| Chunked Encoding | Fixed-size chunks with simple formatting | Adaptive chunk sizing based on content type |\n| HTTP/2 Implementation | Separate server using existing libraries | Custom implementation for learning |\n| Response Caching | In-memory hash table with LRU eviction | Multi-tier cache with persistence options |\n| Connection Pooling | Basic keep-alive with fixed timeouts | Adaptive timeout policies with health monitoring |\n| Asynchronous I/O | Event-driven with thread pool for file I/O | Pure async with io_uring or IOCP |\n| HTTPS Support | OpenSSL integration with basic configuration | Full TLS configuration management |\n| Authentication | HTTP Basic with file-based user storage | Token-based with database integration |\n| Security Headers | Static header configuration | Dynamic policy generation based on content |\n\n#### Recommended Project Structure for Extensions\n\n```\nhttp-server-extended/\n├── cmd/\n│   ├── http-server/main.c           ← Original HTTP/1.1 server\n│   ├── http2-server/main.c          ← Separate HTTP/2 implementation  \n│   └── config-tool/main.c           ← Configuration management utility\n├── src/\n│   ├── core/                        ← Shared core components\n│   │   ├── http_parser.c/h          ← Enhanced parser with POST support\n│   │   ├── file_handler.c/h         ← File serving with caching\n│   │   ├── connection_manager.c/h   ← Connection pooling and lifecycle\n│   │   └── config.c/h               ← Configuration management\n│   ├── extensions/                  ← Extension implementations\n│   │   ├── cache/                   ← Response caching system\n│   │   │   ├── cache_manager.c/h\n│   │   │   ├── lru_eviction.c/h\n│   │   │   └── cache_stats.c/h\n│   │   ├── security/                ← Security enhancements\n│   │   │   ├── tls_integration.c/h\n│   │   │   ├── auth_handler.c/h\n│   │   │   ├── security_headers.c/h\n│   │   │   └── rate_limiter.c/h\n│   │   ├── performance/             ← Performance optimizations\n│   │   │   ├── async_io.c/h\n│   │   │   ├── connection_pool.c/h\n│   │   │   └── chunked_encoding.c/h\n│   │   └── http2/                   ← HTTP/2 implementation\n│   │       ├── frame_parser.c/h\n│   │       ├── stream_manager.c/h\n│   │       ├── hpack_compression.c/h\n│   │       └── multiplexer.c/h\n│   └── utils/                       ← Shared utilities\n│       ├── memory_pool.c/h          ← Memory management\n│       ├── thread_pool.c/h          ← Thread pool implementation\n│       ├── event_loop.c/h           ← Event-driven I/O support\n│       └── crypto_utils.c/h         ← Cryptographic helpers\n├── tests/\n│   ├── unit/                        ← Component unit tests\n│   ├── integration/                 ← Full system integration tests\n│   ├── performance/                 ← Load and stress testing\n│   └── security/                    ← Security verification tests\n├── config/\n│   ├── server.conf                  ← Server configuration\n│   ├── mime.types                   ← MIME type mappings\n│   ├── users.conf                   ← User authentication data\n│   └── security.conf                ← Security policy configuration\n└── docs/\n    ├── extensions/                  ← Extension-specific documentation\n    ├── deployment/                  ← Production deployment guides\n    └── performance/                 ← Performance tuning guides\n```\n\n#### Cache Implementation Starter Code\n\n**Complete Cache Manager Infrastructure:**\n\n```c\n// cache_manager.h\n#ifndef CACHE_MANAGER_H\n#define CACHE_MANAGER_H\n\n#include <stdint.h>\n#include <time.h>\n#include <pthread.h>\n\n#define MAX_CACHE_ENTRIES 1000\n#define MAX_CACHED_FILE_SIZE (1024 * 1024)  // 1MB max per file\n#define CACHE_KEY_LENGTH 256\n\ntypedef struct CacheEntry {\n    char key[CACHE_KEY_LENGTH];\n    char* response_data;\n    size_t response_length;\n    time_t created_time;\n    time_t last_access;\n    uint64_t access_count;\n    struct CacheEntry* next;\n    struct CacheEntry* prev;\n} CacheEntry;\n\ntypedef struct CacheManager {\n    CacheEntry* entries[MAX_CACHE_ENTRIES];  // Hash table buckets\n    CacheEntry* lru_head;                    // LRU list head\n    CacheEntry* lru_tail;                    // LRU list tail\n    size_t total_memory;                     // Current memory usage\n    size_t max_memory;                       // Memory limit\n    uint64_t hits;                           // Cache hit statistics\n    uint64_t misses;                         // Cache miss statistics\n    pthread_rwlock_t cache_lock;             // Reader-writer lock\n} CacheManager;\n\n// Initialize cache manager with memory limits\nCacheManager* init_cache_manager(size_t max_memory_bytes);\n\n// Store response in cache with automatic eviction if needed\nint cache_store_response(CacheManager* cache, const char* key, \n                        const char* response_data, size_t response_length);\n\n// Retrieve cached response, returns NULL if not found or expired\nchar* cache_get_response(CacheManager* cache, const char* key, \n                        size_t* response_length);\n\n// Generate cache key from request path and relevant headers\nvoid generate_cache_key(const char* file_path, const char* query_string,\n                       char* cache_key, size_t key_length);\n\n// Remove expired entries and enforce memory limits\nvoid cache_cleanup_expired(CacheManager* cache, time_t max_age_seconds);\n\n// Get cache statistics for monitoring\nvoid get_cache_statistics(CacheManager* cache, uint64_t* hits, uint64_t* misses,\n                         size_t* memory_used, size_t* entry_count);\n\n// Cleanup and free cache resources\nvoid cleanup_cache_manager(CacheManager* cache);\n\n#endif // CACHE_MANAGER_H\n```\n\n#### Authentication Framework Skeleton\n\n**HTTP Basic Authentication Core Logic:**\n\n```c\n// Basic authentication handler - learner implements credential verification\nint handle_basic_authentication(HTTPRequest* request, HTTPResponse* response) {\n    // TODO 1: Extract Authorization header from request\n    const char* auth_header = get_request_header(request, \"Authorization\");\n    if (!auth_header) {\n        // TODO 2: Generate 401 response with WWW-Authenticate header\n        // Hint: Use generate_error_response with status 401\n        // Add header: WWW-Authenticate: Basic realm=\"Restricted Area\"\n        return 0; // Authentication required\n    }\n    \n    // TODO 3: Verify Authorization header starts with \"Basic \"\n    // TODO 4: Extract and decode base64 credentials\n    // Hint: Use base64_decode function to decode credentials\n    \n    // TODO 5: Split decoded credentials into username:password\n    // TODO 6: Verify credentials against user database\n    // Hint: Use verify_user_credentials function\n    \n    // TODO 7: Set authentication context for authorized requests\n    // Store username in request context for access control\n    \n    return 1; // Authentication successful\n}\n\n// User credential verification - implement based on storage choice\nint verify_user_credentials(const char* username, const char* password) {\n    // TODO 1: Load user database (file, memory, etc.)\n    // TODO 2: Find user entry by username\n    // TODO 3: Compare password hash using secure comparison\n    // Hint: Use constant-time comparison to prevent timing attacks\n    // TODO 4: Return 1 for valid credentials, 0 for invalid\n}\n```\n\n#### TLS Integration Framework\n\n**TLS Socket Wrapper for HTTPS Support:**\n\n```c\n// tls_socket.h - TLS wrapper around standard sockets\n#ifndef TLS_SOCKET_H\n#define TLS_SOCKET_H\n\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n\ntypedef struct TLSContext {\n    SSL_CTX* ssl_ctx;\n    SSL* ssl;\n    int socket_fd;\n    int is_server;\n} TLSContext;\n\n// Initialize TLS context with certificate and key files\nTLSContext* init_tls_server_context(const char* cert_file, const char* key_file);\n\n// Accept TLS connection on server socket\nint tls_accept_connection(TLSContext* server_ctx, int client_fd, TLSContext** client_ctx);\n\n// TLS-aware versions of standard socket operations\nssize_t tls_read(TLSContext* ctx, void* buffer, size_t length);\nssize_t tls_write(TLSContext* ctx, const void* buffer, size_t length);\nint tls_close(TLSContext* ctx);\n\n// Cleanup TLS resources\nvoid cleanup_tls_context(TLSContext* ctx);\n\n#endif // TLS_SOCKET_H\n```\n\n#### Milestone Checkpoints for Extensions\n\n**POST Request Support Milestone:**\n1. **Command**: `curl -X POST -d \"name=test&value=hello\" http://localhost:8080/echo`\n2. **Expected Response**: HTTP 200 with request body echoed back\n3. **Verification**: Check that Content-Length header is correctly parsed and body data is accessible\n4. **Common Issues**: Incomplete body reading, missing Content-Type handling, buffer overflow on large posts\n\n**Caching System Milestone:**\n1. **Command**: `ab -n 1000 -c 10 http://localhost:8080/index.html`\n2. **Expected Behavior**: Significant performance improvement on repeated requests\n3. **Verification**: Cache hit rate > 90% for repeated file access, memory usage within configured limits\n4. **Monitoring**: Check cache statistics show hits/misses, verify LRU eviction under memory pressure\n\n**HTTPS Support Milestone:**\n1. **Setup**: Generate self-signed certificate: `openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes`\n2. **Command**: `curl -k https://localhost:8443/index.html`\n3. **Expected Response**: Same content as HTTP version but over encrypted connection\n4. **Verification**: Use `openssl s_client -connect localhost:8443` to verify TLS handshake\n5. **Common Issues**: Certificate loading failures, cipher suite compatibility, port binding conflicts\n\n#### Performance Testing and Optimization\n\n**Load Testing Framework:**\n\n```bash\n#!/bin/bash\n# performance_test.sh - Comprehensive server performance testing\n\necho \"Starting HTTP Server Performance Test Suite\"\n\n# Test 1: Concurrent connection handling\necho \"Test 1: Concurrent Connections\"\nab -n 10000 -c 100 http://localhost:8080/index.html\n\n# Test 2: Large file transfer\necho \"Test 2: Large File Performance\" \ncurl -w \"@curl-format.txt\" http://localhost:8080/large-file.dat\n\n# Test 3: Keep-alive connection reuse\necho \"Test 3: Keep-Alive Performance\"\nab -k -n 5000 -c 50 http://localhost:8080/small-file.txt\n\n# Test 4: Cache effectiveness\necho \"Test 4: Cache Hit Rate\"\n# Send same request multiple times and measure response time improvement\n\n# Test 5: Memory usage under load\necho \"Test 5: Memory Usage Monitoring\"\n# Monitor server memory usage during high concurrent load\n```\n\n#### Security Testing Verification\n\n**Security Audit Checklist:**\n\n| Security Feature | Verification Method | Expected Result |\n|------------------|-------------------|-----------------|\n| HTTPS Encryption | `nmap --script ssl-enum-ciphers -p 8443 localhost` | Strong cipher suites only |\n| Authentication | `curl -u invalid:credentials https://localhost:8443/private/` | 401 Unauthorized response |\n| Directory Traversal | `curl https://localhost:8443/../../../etc/passwd` | 400 Bad Request or 403 Forbidden |\n| Security Headers | `curl -I https://localhost:8443/` | HSTS, CSP, X-Frame-Options present |\n| Rate Limiting | Rapid request script | 429 Too Many Requests after threshold |\n| Input Validation | Malformed HTTP requests | Graceful error handling, no crashes |\n\nThese extensions transform the educational HTTP server into a comprehensive web server implementation suitable for production deployment while maintaining the architectural clarity that makes the codebase an effective learning tool. Each extension builds upon the foundational concepts established in the original implementation, demonstrating how systems evolve to meet real-world requirements.\n\n\n## Glossary\n\n> **Milestone(s):** All Milestones 1-4 - provides essential terminology definitions used across TCP server basics, HTTP request parsing, static file serving, and concurrent connections\n\nThe glossary serves as your technical compass throughout the HTTP server implementation journey. Think of it as a specialized dictionary that translates between the abstract concepts described in this design document and the concrete technical terminology you'll encounter in networking documentation, HTTP specifications, and systems programming resources. Just as a traveler needs a phrasebook to navigate a foreign country, you need this glossary to navigate the interconnected domains of network programming, HTTP protocol implementation, and concurrent systems design.\n\nThis glossary organizes terminology into logical groupings that mirror the architectural components of our HTTP server. Each definition provides not just the meaning but also the contextual significance within our specific implementation. The terminology here bridges the gap between theoretical computer science concepts and practical systems programming, helping you understand not just what each term means but why it matters for building a robust HTTP server.\n\n### Networking and TCP Fundamentals\n\nThe networking layer forms the foundation of our HTTP server, requiring precise understanding of how TCP connections operate at the system level.\n\n| Term | Definition | Context in HTTP Server |\n|------|------------|------------------------|\n| **Address Family** | Protocol family identifier specifying address format and addressing scheme | `AF_INET` specifies IPv4 addressing for our server socket configuration |\n| **Bind Operation** | System call associating a socket with a specific local address and port | Our server binds to configured port (default 8080) to accept incoming connections |\n| **Client Socket** | Network endpoint representing the client side of a TCP connection | Each accepted connection creates a client socket for bidirectional communication |\n| **Connection Establishment** | Three-way handshake process (SYN, SYN-ACK, ACK) creating a TCP connection | Happens automatically when clients connect to our listening server socket |\n| **File Descriptor** | Integer handle representing an open file or socket in the operating system | Our server manages multiple file descriptors for server socket and client connections |\n| **File Descriptor Leak** | Programming error where file descriptors are not properly closed, causing resource exhaustion | Critical bug pattern in our server - must close client sockets after handling requests |\n| **Listen Backlog** | Maximum number of pending connections that can wait for acceptance | Configured during socket setup to handle burst of simultaneous connection attempts |\n| **Listen Operation** | System call marking a socket as passive, ready to accept incoming connections | Transitions our server socket from active to passive state for connection acceptance |\n| **Network Byte Order** | Big-endian byte ordering used in network protocols for multi-byte values | Port numbers must be converted using `htons()` for proper network transmission |\n| **Partial Read** | Network read operation returning fewer bytes than requested due to buffering | Common in TCP - our server must handle incomplete HTTP requests with multiple read calls |\n| **Partial Write** | Network write operation sending fewer bytes than requested due to buffering | HTTP responses may require multiple write calls to send complete data |\n| **Server Socket** | Network endpoint configured to accept incoming client connections | Primary socket bound to server port, never used for actual data transmission |\n| **Socket Address Structure** | Data structure containing address family, port, and IP address information | `sockaddr_in` structure configures server binding and tracks client connection details |\n| **Socket Options** | Configuration parameters controlling socket behavior and features | `SO_REUSEADDR` allows immediate port reuse after server restart during development |\n| **TCP Connection** | Reliable, ordered, bidirectional communication channel between client and server | Foundation for HTTP request-response exchange with guaranteed delivery and ordering |\n| **TCP Connection Lifecycle** | Complete sequence from socket creation through data exchange to connection termination | Our server manages: create → bind → listen → accept → read → write → close |\n\n### HTTP Protocol Terminology\n\nHTTP protocol implementation requires understanding of message structure, parsing challenges, and protocol semantics.\n\n| Term | Definition | Context in HTTP Server |\n|------|------------|------------------------|\n| **Content-Length Header** | HTTP header specifying the exact size of the message body in bytes | Critical for reading request body completely and setting response body size |\n| **Content-Type Header** | HTTP header indicating the media type of the request or response body | Our server sets this based on file extension to help browsers handle served files |\n| **CRLF Line Endings** | Carriage Return + Line Feed (`\\r\\n`) sequence required by HTTP specification | HTTP standard mandates CRLF, but our parser handles both CRLF and LF for robustness |\n| **HTTP Header** | Key-value pair providing metadata about the request or response message | Parsed into our header array structure with case-insensitive key matching |\n| **HTTP Message Body** | Optional payload data following the headers in an HTTP message | For requests: form data or file uploads; for responses: file content or error pages |\n| **HTTP Method** | Verb indicating the desired action to be performed on the identified resource | Our server primarily handles GET requests, with basic support for HEAD and OPTIONS |\n| **HTTP Request** | Client message containing method, path, headers, and optional body | Parsed into our `HTTPRequest` structure with validated method, path, and header collection |\n| **HTTP Request Line** | First line of HTTP request containing method, path, and protocol version | Format: `GET /index.html HTTP/1.1` - parsed to extract three components |\n| **HTTP Response** | Server message containing status code, headers, and optional body content | Generated using our `HTTPResponse` structure with appropriate status and content headers |\n| **HTTP Status Code** | Three-digit code indicating the result of the server's attempt to process the request | 200 OK for successful file serving, 404 Not Found for missing files, 500 for errors |\n| **HTTP Version** | Protocol version identifier indicating capabilities and message format requirements | Our server supports HTTP/1.1 with basic connection handling and header processing |\n| **Host Header** | HTTP/1.1 required header specifying the domain name and port of the server | Used for virtual host routing, though our basic implementation serves single document root |\n| **Request Path** | URL path component specifying the requested resource location on the server | Validated for security (no directory traversal) and mapped to filesystem paths |\n| **Request Parsing** | Process of converting raw HTTP message bytes into structured data representation | Critical parsing phase handling malformed requests, invalid headers, and protocol violations |\n| **Response Generation** | Process of creating properly formatted HTTP response messages from server data | Includes status line construction, header addition, and body content formatting |\n| **Status Line** | First line of HTTP response containing protocol version, status code, and reason phrase | Format: `HTTP/1.1 200 OK` - automatically generated based on request processing results |\n\n### File System and Security\n\nStatic file serving requires careful handling of filesystem operations and security validation.\n\n| Term | Definition | Context in HTTP Server |\n|------|------------|------------------------|\n| **Binary File Handling** | Special processing required for non-text files to preserve exact byte content | Our server must avoid text-mode I/O operations that could corrupt binary file data |\n| **Directory Listing** | HTML page displaying the contents of a directory when no index file exists | Generated dynamically when request path maps to directory rather than specific file |\n| **Directory Traversal** | Security attack using relative path components (`../`) to access files outside document root | Prevented by path normalization and validation before filesystem access |\n| **Document Root** | Base directory on the filesystem from which files are served to clients | Security boundary - all served files must reside within this directory tree |\n| **File Extension** | Suffix portion of filename used to determine file type and appropriate handling | Used for MIME type detection to set proper Content-Type header in responses |\n| **File Permission** | Operating system access control determining read, write, and execute capabilities | Server process must have read permission for all files intended for serving |\n| **MIME Type** | Standard identifier indicating the nature and format of file content | Mapped from file extensions to Content-Type headers (e.g., `.html` → `text/html`) |\n| **Path Normalization** | Process of removing redundant path components (`.`, `..`) to create canonical paths | Security measure preventing directory traversal attacks through path manipulation |\n| **Path Resolution** | Process of mapping URL paths to corresponding filesystem paths within document root | Core file serving operation that must validate security constraints before file access |\n| **Path Validation** | Security checks ensuring requested paths don't escape document root boundaries | Combines path normalization with boundary checking to prevent unauthorized file access |\n| **Static Content** | Pre-existing files served without server-side processing or dynamic generation | HTML, CSS, JavaScript, images - served directly from filesystem with appropriate headers |\n| **URL Decoding** | Process of converting percent-encoded characters in URLs back to original form | Handles encoded characters like `%20` (space) in filenames and paths |\n\n### Concurrency and Threading\n\nConcurrent connection handling requires understanding of different concurrency models and their trade-offs.\n\n| Term | Definition | Context in HTTP Server |\n|------|------------|------------------------|\n| **Asynchronous I/O** | Non-blocking I/O operations with event notification for completion | Alternative to threading - single thread handles multiple connections with I/O multiplexing |\n| **Connection Context** | Per-connection state structure tracking client information and processing status | `ConnectionContext` structure maintaining client socket, address, timing, and thread information |\n| **Connection Multiplexing** | Single thread handling multiple simultaneous connections through event-driven programming | Achieved using `select()` or `poll()` to monitor multiple sockets for activity |\n| **Connection Pooling** | Reusing TCP connections across multiple HTTP requests to reduce connection overhead | Optimization for keep-alive connections, though not implemented in our basic server |\n| **Deadlock** | Circular waiting condition where two or more threads block each other indefinitely | Avoided through consistent lock ordering and avoiding nested lock acquisition |\n| **Detached Thread** | Thread that automatically releases its resources when it terminates | Created with `PTHREAD_CREATE_DETACHED` attribute to avoid memory leaks from unjoined threads |\n| **Event-Driven Model** | Concurrency approach using single thread with I/O multiplexing to handle multiple connections | Alternative to threading - uses `select()` or `epoll()` to monitor socket events |\n| **Graceful Shutdown** | Shutdown process that allows in-flight requests to complete before stopping the server | Prevents client connection errors during server restart by finishing active request processing |\n| **Mutex** | Mutual exclusion primitive protecting shared data from concurrent access | `pthread_mutex_t` used to protect connection counters and shared server state |\n| **Non-blocking I/O** | I/O operations that return immediately rather than waiting for completion | Socket option `O_NONBLOCK` allows event-driven handling without thread blocking |\n| **Race Condition** | Bug where program behavior depends on timing of concurrent operations | Prevented by proper synchronization around shared data like connection counters |\n| **Resource Exhaustion** | System running out of threads, memory, or file descriptors under high load | Prevented by connection limits, thread pool sizing, and proper resource cleanup |\n| **Thread Pool** | Fixed number of worker threads sharing the workload of processing client connections | Limits resource usage compared to thread-per-connection while maintaining concurrency |\n| **Thread Safety** | Property that code functions correctly when accessed by multiple threads simultaneously | Achieved through mutex synchronization and avoiding shared mutable state where possible |\n| **Thread-per-connection** | Concurrency model creating dedicated thread for each client connection | Simplest approach but resource-intensive - each connection consumes thread stack memory |\n\n### Error Handling and Debugging\n\nRobust error handling requires understanding of error categories, propagation patterns, and recovery strategies.\n\n| Term | Definition | Context in HTTP Server |\n|------|------------|------------------------|\n| **Cleanup Sequence** | Ordered process of releasing resources when connections complete or fail | Ensures sockets are closed, memory freed, and threads properly terminated |\n| **Error Classification** | Categorizing errors by source (network, protocol, application) and severity level | Helps determine appropriate HTTP status codes and recovery actions |\n| **Error Propagation** | Flow of error information between system components to appropriate handlers | Network errors become HTTP 500, file not found becomes HTTP 404 |\n| **Graceful Degradation** | System continuing to function with reduced capability under stress or failure | Server remains responsive even when some requests fail or resources are limited |\n| **Memory Ownership** | Clear responsibility for allocating and freeing dynamically allocated memory | Prevents memory leaks by defining which component owns and cleans up each allocation |\n| **Resource Cleanup** | Process of properly releasing system resources (sockets, files, memory) after use | Critical for preventing resource leaks that would eventually crash the server |\n| **Security Event Logging** | Recording security-relevant events (access attempts, blocked requests) for monitoring | Logs directory traversal attempts, permission denials, and suspicious request patterns |\n\n### Performance and Testing\n\nUnderstanding performance characteristics and testing approaches for validating server behavior.\n\n| Term | Definition | Context in HTTP Server |\n|------|------------|------------------------|\n| **Cache Eviction** | Removal of entries from cache storage due to memory limits or age | LRU (Least Recently Used) policy removes oldest entries when cache reaches capacity |\n| **Cache Hit** | Successful retrieval of requested data from cache storage | Avoids expensive file I/O operations by serving content from memory |\n| **Connection Limits** | Maximum number of simultaneous connections the server will accept | Prevents resource exhaustion by rejecting connections beyond configured threshold |\n| **Load Testing** | Testing system behavior under expected operational load conditions | Verifies server handles target number of concurrent connections without degradation |\n| **Performance Monitoring** | Tracking system metrics like response time, throughput, and resource usage | Measures request processing time, concurrent connection count, and memory usage |\n| **Stress Testing** | Testing system limits and failure modes under extreme load | Determines maximum connection capacity and validates graceful failure behavior |\n\n### Advanced Features and Extensions\n\nTerminology for potential future enhancements beyond the basic HTTP server implementation.\n\n| Term | Definition | Context in HTTP Server |\n|------|------------|------------------------|\n| **Authentication** | Identity verification process for user credentials | HTTP Basic Authentication validates username/password for access control |\n| **Authorization** | Access control based on verified user identity | Determines which authenticated users can access specific resources |\n| **Certificate Management** | Handling X.509 certificates and private keys for HTTPS | Required for TLS-enabled servers to prove identity to clients |\n| **Chunked Encoding** | HTTP transfer encoding for streaming responses without predetermined Content-Length | Allows serving dynamically generated content of unknown size |\n| **Keep-Alive** | HTTP connection reuse mechanism for multiple requests over single TCP connection | Reduces connection establishment overhead for clients making multiple requests |\n| **Rate Limiting** | Restricting request frequency from clients to prevent abuse | Protects server resources from denial-of-service attacks |\n| **Security Headers** | HTTP headers providing client-side security policies | Headers like `X-Content-Type-Options` and `X-Frame-Options` enhance browser security |\n| **TLS Handshake** | Cryptographic negotiation process establishing secure HTTPS connection | Establishes encryption keys and validates server certificate before application data |\n\n### System Programming Concepts\n\nLow-level systems programming concepts essential for robust HTTP server implementation.\n\n| Term | Definition | Context in HTTP Server |\n|------|------------|------------------------|\n| **Buffer Overflow Protection** | Programming techniques preventing writes beyond allocated memory boundaries | Critical for parsing HTTP headers and handling file paths safely |\n| **Endianness** | Byte ordering for multi-byte values in memory and network transmission | Network byte order (big-endian) differs from host byte order on little-endian systems |\n| **Process Management** | Operating system concepts for creating, monitoring, and terminating processes | Understanding daemon processes and signal handling for production deployment |\n| **Signal Handling** | Mechanism for asynchronous notification of events to running processes | SIGTERM and SIGINT handling for graceful shutdown, SIGPIPE handling for broken connections |\n| **System Call Interface** | Operating system API for network operations, file I/O, and process management | Socket operations, file operations, and threading primitives used throughout server |\n\n> **Implementation Note**: This glossary provides the foundational vocabulary needed to understand the HTTP server design and implementation. Each term connects to specific code elements, data structures, or algorithms described in the component sections. When encountering unfamiliar terminology in networking documentation or HTTP specifications, refer back to these definitions to maintain context within our specific server architecture.\n\nThe terminology here bridges multiple technical domains - from low-level socket programming to high-level HTTP protocol semantics. Understanding these connections helps you see how abstract protocol concepts translate into concrete programming tasks and data structures.\n\n### Implementation Guidance\n\nThis section provides practical guidance for understanding and using the terminology throughout your HTTP server implementation.\n\n#### Terminology Usage Patterns\n\nThe terminology in this glossary follows specific patterns that map to our implementation structure:\n\n**Component-Specific Terms**: Terms like \"TCP Connection Lifecycle\" and \"HTTP Request Parsing\" map directly to component responsibilities. When implementing the TCP Server Component, focus on networking terms. When building the HTTP Parser Component, emphasize protocol terminology.\n\n**Data Structure Mapping**: Many terms correspond directly to fields in our data structures. \"HTTP Method\" maps to the `method` field in `HTTPRequest`. \"Connection Context\" is embodied by the `ConnectionContext` structure. \"MIME Type\" relates to the `MimeTypeMapping` structure.\n\n**Error Category Alignment**: Error-related terminology aligns with our `ErrorCategory` enumeration. \"Network\" errors include \"Partial Read\" and \"File Descriptor Leak\". \"Protocol\" errors encompass \"HTTP Request Parsing\" failures and malformed headers.\n\n#### Cross-Reference Guide\n\n| Implementation Area | Key Terms | Primary Data Structures |\n|-------------------|-----------|------------------------|\n| Socket Programming | Network Byte Order, File Descriptor, TCP Connection Lifecycle | `sockaddr_in`, `ConnectionContext` |\n| HTTP Processing | Request Parsing, Status Code, Content-Type Header | `HTTPRequest`, `HTTPResponse` |\n| File Operations | Directory Traversal, Path Validation, MIME Type | `ServerConfig`, `MimeTypeMapping` |\n| Concurrency | Thread Safety, Mutex, Resource Exhaustion | `ConcurrencyManager`, `ConnectionQueue` |\n| Error Handling | Error Classification, Cleanup Sequence, Error Propagation | `ErrorInfo`, `ResourceCleanupContext` |\n\n#### Common Term Confusion\n\nSeveral terms are frequently confused during implementation:\n\n**\"Connection\" vs \"Socket\"**: A TCP connection represents the logical communication channel, while a socket is the programming interface. Our server socket accepts connections, creating client sockets for communication.\n\n**\"Request Parsing\" vs \"Message Parsing\"**: Request parsing specifically handles the HTTP request structure, while message parsing could apply to both requests and responses.\n\n**\"Thread Pool\" vs \"Connection Pool\"**: Thread pools manage worker threads, while connection pools would manage reusable TCP connections (not implemented in our basic server).\n\n**\"Graceful Shutdown\" vs \"Graceful Degradation\"**: Shutdown refers to stopping the server cleanly, while degradation means continuing operation with reduced functionality.\n\n#### Debugging Vocabulary\n\nWhen troubleshooting issues, these terms help communicate problems precisely:\n\n- **\"Partial Read\"** indicates incomplete HTTP request reception\n- **\"Directory Traversal\"** signals a security validation failure  \n- **\"Race Condition\"** suggests thread synchronization problems\n- **\"Resource Exhaustion\"** points to connection or thread limit issues\n- **\"File Descriptor Leak\"** means sockets aren't being closed properly\n\nUnderstanding this vocabulary accelerates both independent debugging and communication with others when seeking help.\n"}