{"html":"<h1 id=\"infrastructure-as-code-engine-design-document\">Infrastructure as Code Engine: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>This system parses declarative infrastructure configurations, computes the difference from the current state, builds a safe execution plan, and applies changes to cloud resources. The key architectural challenge is managing state, dependencies, and idempotent operations across distributed, eventually consistent cloud APIs.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<h2 id=\"context-and-problem-statement\">Context and Problem Statement</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section provides foundational context for all milestones, setting the stage for the entire Infrastructure as Code engine.</p>\n</blockquote>\n<p>Managing infrastructure manually—clicking through cloud consoles, running ad-hoc scripts, and keeping manual documentation—is a recipe for inconsistency, configuration drift, and operational risk. The modern approach is <strong>Infrastructure as Code (IaC)</strong>, treating servers, networks, and databases as declarative specifications that can be versioned, reviewed, and applied programmatically. This project is about building the engine that powers such a system: a tool that reads a desired state, compares it with reality, and safely orchestrates the necessary changes.</p>\n<p>The core challenge lies in bridging the <strong>declarative intent</strong> of the user (&quot;I want a web server with this configuration&quot;) with the <strong>imperative actions</strong> of cloud APIs (&quot;create a VM, then attach a disk, then configure a firewall rule&quot;), while maintaining a reliable record of what was actually built. This requires sophisticated state management, dependency analysis, and robust error handling in an environment of eventual consistency and rate-limited APIs.</p>\n<h3 id=\"mental-model-the-master-blueprint-and-site-manager\">Mental Model: The Master Blueprint and Site Manager</h3>\n<p>Imagine you are constructing a building. You start with a <strong>master blueprint</strong> (the IaC configuration)—a detailed, declarative document specifying every component: walls, electrical wiring, plumbing, and their exact properties. This blueprint is written in a specialized language (like HCL) that describes the <em>what</em>, not the <em>how</em>.</p>\n<p>You have a <strong>site manager</strong> (the IaC engine) whose job is to make the real site match the blueprint. On their first day, they survey the empty lot (current state: nothing) and create a detailed <strong>work order</strong> (execution plan) listing every task: pour foundation, erect frame, install wiring. They must figure out the correct order—you can&#39;t install drywall before running electrical conduit (dependency resolution).</p>\n<p>Once construction begins, the site manager keeps a meticulous <strong>logbook</strong> (state file) of what has been completed. For each item in the blueprint, they record the real-world identifier (e.g., &quot;Wall Section A: constructed at coordinates X,Y,Z&quot;). This logbook is crucial. When the blueprint is updated (e.g., &quot;add a window to Wall Section A&quot;), the manager consults the logbook to see what&#39;s already built, figures out the diff (add a window), and creates a new work order.</p>\n<p>Crucially, the site manager uses <strong>specialized subcontractors</strong> (providers) for different tasks. An electrician (AWS provider) handles wiring, while a plumber (GCP provider) handles pipes. The manager communicates with each using their own terminology and processes (cloud APIs).</p>\n<p>This mental model captures the essence of our IaC engine:</p>\n<ul>\n<li><strong>Blueprint</strong> = Declarative configuration (<code>.tf</code> files)</li>\n<li><strong>Site Manager</strong> = The core engine (Parser, Planner, Executor)</li>\n<li><strong>Logbook</strong> = State file</li>\n<li><strong>Work Order</strong> = Execution Plan</li>\n<li><strong>Subcontractors</strong> = Providers (AWS, GCP, Azure plugins)</li>\n</ul>\n<blockquote>\n<p>The key insight is that the logbook (state) is the source of truth for the <em>real world</em>, while the blueprint (configuration) is the source of truth for the <em>desired world</em>. The engine&#39;s job is to reconcile the two safely and efficiently.</p>\n</blockquote>\n<h3 id=\"the-core-problem-declarative-to-imperative-with-state\">The Core Problem: Declarative to Imperative with State</h3>\n<p>Translating a static declaration of desired infrastructure into a dynamic set of API calls, while maintaining correctness and safety, involves several intertwined technical challenges:</p>\n<ol>\n<li><p><strong>State Reconciliation and Idempotency:</strong> The engine must know what currently exists to decide what needs to be created, updated, or destroyed. Simply re-running the blueprint from scratch every time is not feasible—it would destroy and recreate everything, causing downtime. The engine must perform a <strong>three-way diff</strong> between the desired configuration, the last known state, and (in some cases) the actual live infrastructure. All operations must be <strong>idempotent</strong>: applying the same configuration multiple times should result in the same final state, regardless of intermediate failures or partial applies.</p>\n</li>\n<li><p><strong>Dependency and Ordering Management:</strong> Infrastructure resources have complex relationships. A virtual machine depends on a network subnet, which depends on a virtual network. The engine must automatically infer these dependencies from the configuration (e.g., <code>subnet_id = aws_subnet.main.id</code> creates an implicit link) and allow explicit overrides (<code>depends_on</code>). It must then build a <strong>Directed Acyclic Graph (DAG)</strong> and execute changes in a correct order: creates in dependency order, updates with similar constraints, and destroys in reverse dependency order. Cycles in dependencies must be detected and rejected.</p>\n</li>\n<li><p><strong>Concurrency Control and Safety:</strong> In a team setting, two engineers might try to apply different configurations to the same infrastructure simultaneously. This could lead to race conditions and corrupted state. The engine needs a <strong>state locking mechanism</strong> to ensure only one apply operation proceeds at a time. The locking must be robust to process crashes (avoiding stuck locks) and work across distributed environments (remote teams).</p>\n</li>\n<li><p><strong>Provider Abstraction and Heterogeneity:</strong> Cloud APIs are diverse and ever-changing. The engine needs a clean <strong>plugin architecture</strong> that abstracts the specifics of AWS, Google Cloud, Azure, and even on-premise systems behind a uniform interface for Create, Read, Update, and Delete (CRUD) operations. Providers must handle authentication, rate limiting, retries with backoff, and the eventual consistency semantics of their respective clouds.</p>\n</li>\n<li><p><strong>Configuration Language and Expressivity:</strong> Users need a language to declare resources, define variables, reuse modules, and output useful values. This language must be parsed, validated, and transformed into an internal representation. <strong>Variable interpolation</strong> (e.g., <code>${var.region}</code>) and <strong>module composition</strong> add layers of complexity, requiring multi-pass resolution and scope management.</p>\n</li>\n</ol>\n<p>The following table summarizes the core transformation the engine must perform at each stage:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Stage</th>\n<th align=\"left\">Input</th>\n<th align=\"left\">Core Challenge</th>\n<th align=\"left\">Output</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Parse &amp; Resolve</strong></td>\n<td align=\"left\">HCL/YAML config files</td>\n<td align=\"left\">Handling variables, modules, and complex expressions without infinite loops</td>\n<td align=\"left\">A normalized, concrete graph of <code>Resource</code> objects with all references resolved.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>State Diff</strong></td>\n<td align=\"left\">Desired Resources + Last Known State</td>\n<td align=\"left\">Computing minimal, correct change set in the face of nested/computed attributes</td>\n<td align=\"left\">A set of proposed <code>PlanAction</code> objects (Create, Update, Delete, No-op).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Plan</strong></td>\n<td align=\"left\">Desired Resources + State Diff + Dependencies</td>\n<td align=\"left\">Ordering actions safely (no broken dependencies) and presenting a preview</td>\n<td align=\"left\">An <code>ExecutionPlan</code> (DAG of <code>PlanAction</code> nodes) ready for application.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Apply</strong></td>\n<td align=\"left\">ExecutionPlan + Live Cloud APIs</td>\n<td align=\"left\">Managing concurrency, retries, timeouts, and partial failures while preserving state consistency</td>\n<td align=\"left\">Updated infrastructure and a new, accurate <code>StateFile</code>.</td>\n</tr>\n</tbody></table>\n<p><strong>Decision: State as the Source of Truth</strong></p>\n<ul>\n<li><strong>Context</strong>: We need a reliable record of what the engine has provisioned to enable safe updates and deletes.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Pure Declarative (No State)</strong>: Re-parse configuration and query all cloud APIs on every run to discover current state. This is simple but slow, expensive (API costs), and unreliable (APIs may not expose all attributes, transient resources may be missed).</li>\n<li><strong>State-First</strong>: Maintain a persistent, versioned state file that records the resource IDs and attributes after each apply. The state is the primary input for computing diffs.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: <strong>State-First</strong>.</li>\n<li><strong>Rationale</strong>: A state file provides a fast, deterministic, and complete record of managed resources. It allows the engine to work offline (planning) and reduces reliance on potentially flaky or rate-limited cloud APIs for baseline discovery. It&#39;s the established pattern used by Terraform and other mature tools, proven at scale.</li>\n<li><strong>Consequences</strong>: We must now design robust state storage, locking, and serialization. The state file becomes a critical asset—corruption or loss can sever the link between configuration and real resources. We must also implement state refresh mechanisms to detect and reconcile &quot;drift&quot; (changes made outside the IaC tool).</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Option</th>\n<th align=\"left\">Pros</th>\n<th align=\"left\">Cons</th>\n<th align=\"left\">Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Pure Declarative</strong></td>\n<td align=\"left\">No state to manage or corrupt; always queries live infrastructure.</td>\n<td align=\"left\">Very slow; API rate limits; cannot detect resources deleted via API; requires perfect API idempotency.</td>\n<td align=\"left\">❌</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>State-First</strong></td>\n<td align=\"left\">Fast planning; clear audit trail; enables advanced features like move, taint, and targeted operations.</td>\n<td align=\"left\">State file is a singleton bottleneck; requires locking; risk of state drift if not refreshed.</td>\n<td align=\"left\">✅</td>\n</tr>\n</tbody></table>\n<h3 id=\"existing-approaches-and-trade-offs\">Existing Approaches and Trade-offs</h3>\n<p>The IaC landscape offers several established tools, each embodying different design philosophies that inform our own architectural choices.</p>\n<p><strong>Decision: Terraform-like Declarative Model vs. Pulumi-like Imperative SDK</strong></p>\n<ul>\n<li><strong>Context</strong>: We must choose the core paradigm for how users define infrastructure.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Declarative DSL (Terraform)</strong>: Users write configuration in a domain-specific language (HCL) or YAML/JSON. The engine is entirely responsible for planning and execution.</li>\n<li><strong>Imperative SDK (Pulumi, CDK)</strong>: Users write full-fledged programs (Python, Go, TypeScript) that call SDK functions to declare resources. The program&#39;s execution <em>is</em> the planning phase.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: <strong>Declarative DSL</strong>.</li>\n<li><strong>Rationale</strong>: For an educational engine focused on the core challenges of reconciliation and planning, a declarative model cleanly separates <em>intent</em> from <em>execution</em>. It forces us to build a sophisticated planner and state manager. An imperative SDK pushes more complexity into the user&#39;s code and the runtime, making the engine&#39;s job different (more about snapshotting and diffing program output). The declarative approach is also more accessible for beginners and aligns with the &quot;blueprint&quot; mental model.</li>\n<li><strong>Consequences</strong>: We must build a parser and interpreter for a configuration language. Users lose the flexibility of loops and conditionals from general-purpose languages unless we replicate them in our DSL (e.g., <code>count</code> and <code>for_each</code>).</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Option</th>\n<th align=\"left\">Pros</th>\n<th align=\"left\">Cons</th>\n<th align=\"left\">Representative Tool</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Declarative DSL</strong></td>\n<td align=\"left\">Clear separation of intent/execution; easy to analyze, validate, and plan; simple config files.</td>\n<td align=\"left\">Limited expressiveness; custom language to learn; requires complex engine.</td>\n<td align=\"left\"><strong>Terraform</strong>, CloudFormation, Ansible</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Imperative SDK</strong></td>\n<td align=\"left\">Full power of a programming language; familiar syntax; easier abstraction and reuse.</td>\n<td align=\"left\">Harder to reason about desired state; program execution required for planning; can be overkill.</td>\n<td align=\"left\"><strong>Pulumi</strong>, AWS CDK, Crossplane</td>\n</tr>\n</tbody></table>\n<p><strong>Terraform</strong> is the canonical model for our project. It uses a custom HCL, maintains a state file (<code>terraform.tfstate</code>), has a rich provider ecosystem, and performs a planning stage. Its architecture directly inspires our component breakdown: Parser (config load), State (backend), Graph (terraform graph), and Provider plugins. However, Terraform&#39;s codebase is large and complex. Our goal is to distill its core concepts into a manageable, educational implementation.</p>\n<p><strong>AWS CloudFormation</strong> takes a more centralized, cloud-vendor-controlled approach. Templates are JSON/YAML, and state is managed entirely by the AWS service. This simplifies the client but creates vendor lock-in and lacks the multi-cloud provider abstraction we aim to build. Its &quot;change sets&quot; are analogous to our execution plan.</p>\n<p><strong>Pulumi</strong> represents the &quot;imperative SDK&quot; approach. It allows infrastructure to be defined in real code, which is then evaluated to produce a desired state graph. Pulumi then uses a Terraform-like engine (often the Terraform engine itself via bridged providers) to plan and apply. For our project, adopting this model would mean focusing on capturing and diffing program snapshots rather than parsing a DSL.</p>\n<blockquote>\n<p>The trade-off is fundamentally about <strong>control vs. flexibility</strong>. A declarative engine (like Terraform) maintains tight control over the planning process, ensuring predictable and safe operations. An imperative SDK (like Pulumi) offers maximal flexibility to the user but places more trust in the user&#39;s code to correctly define the desired end state.</p>\n</blockquote>\n<p>Our design will follow the <strong>Terraform architectural pattern</strong> but with significant simplifications for clarity and educational value:</p>\n<ul>\n<li>We will support a subset of HCL or a simpler YAML configuration for faster parsing.</li>\n<li>Our state management will start with a local file and a simple lock, later extending to remote backends.</li>\n<li>Our provider interface will be similar to Terraform&#39;s plugin system but less complex, focusing on the core CRUD lifecycle.</li>\n</ul>\n<p>This approach gives us a well-trodden path to explore all the fascinating problems of IaC—parsing, state, graphs, and plugins—without getting lost in the intricacies of a full, production-grade language or SDK runtime.</p>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section sets the scope for the entire project and is relevant to all milestones.</p>\n</blockquote>\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<p>This section clearly defines the project&#39;s boundaries, separating what the IaC engine will accomplish from what it deliberately omits. A well-defined scope is critical for managing complexity and ensuring the core value proposition — a reliable, understandable, and extensible engine for managing infrastructure declaratively — is delivered successfully.</p>\n<blockquote>\n<p><strong>Architectural Principle:</strong> A system&#39;s boundaries are defined as much by what it chooses <em>not</em> to do as by what it does. Explicit non-goals prevent scope creep and allow focused effort on the core, differentiating capabilities.</p>\n</blockquote>\n<h3 id=\"goals\">Goals</h3>\n<p>The primary goal is to build a functional, educational IaC engine that demonstrates the fundamental patterns and challenges of reconciling desired state with actual state in a cloud environment. The following table enumerates the specific capabilities the system must deliver.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Goal</th>\n<th align=\"left\">Description</th>\n<th align=\"left\">Rationale &amp; Key Capabilities</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Declarative Configuration</strong></td>\n<td align=\"left\">Accept user-defined configuration files that describe the <em>desired</em> end-state of infrastructure, not the steps to create it.</td>\n<td align=\"left\">This is the foundational philosophy of IaC. The engine must parse a configuration DSL (HCL-like syntax or YAML), resolve variables and modules, and produce a normalized set of <code>Resource</code> objects representing the intended infrastructure.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>State Management</strong></td>\n<td align=\"left\">Maintain a persistent, mutable record of the <em>actual</em> state of deployed infrastructure, enabling idempotent operations and change detection.</td>\n<td align=\"left\">State is the engine&#39;s memory. Without it, every <code>apply</code> would be a blind creation. The system must store attribute values and resource IDs, support safe concurrent access via locking, and reliably compute the difference between desired and actual state.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Dependency-Aware Planning</strong></td>\n<td align=\"left\">Analyze resource relationships to build an execution order (a Directed Acyclic Graph) and generate a safe, previewable plan of changes.</td>\n<td align=\"left\">Infrastructure resources depend on each other (e.g., a subnet must exist before a VM placed in it). The planner must infer these dependencies, detect cycles, topologically sort resources, and produce a sequence of <code>PlanAction</code> items (CREATE, UPDATE, DELETE, NOOP) that can be reviewed before execution.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Provider Plugin Abstraction</strong></td>\n<td align=\"left\">Define a clean interface (<code>BaseProvider</code>) that abstracts the specific CRUD operations of various cloud platforms (AWS, GCP, Azure) or services.</td>\n<td align=\"left\">The engine cannot hardcode support for every cloud API. A plugin architecture allows the core logic to remain stable while providers for new services are developed independently. Each provider implements the lifecycle operations for its resource types.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Safe, Idempotent Apply</strong></td>\n<td align=\"left\">Execute the plan against real infrastructure in a controlled manner, handling API failures, retries, and ensuring operations are idempotent where possible.</td>\n<td align=\"left\">The <code>Executor</code> must coordinate with providers, manage concurrency, implement retry logic with backoff, and update the state file only upon successful completion of operations. This ensures the system is robust against transient failures and avoids duplicate resources.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Educational Codebase</strong></td>\n<td align=\"left\">Produce a codebase that is readable, well-structured, and illustrative of distributed systems and compiler design patterns.</td>\n<td align=\"left\">The implementation should prioritize clarity over excessive optimization. The architecture should be modular, with clear interfaces and data flow, making it a valuable learning tool for understanding how tools like Terraform work under the hood.</td>\n</tr>\n</tbody></table>\n<h3 id=\"non-goals\">Non-Goals</h3>\n<p>Equally important are the features and responsibilities the system will <em>not</em> undertake. These exclusions keep the project focused and manageable, often delegating complexity to external systems or defining them as future extensions.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Non-Goal</th>\n<th align=\"left\">Why It&#39;s Out of Scope</th>\n<th align=\"left\">Recommended Alternative / Note</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>A Complete, Production-Grade HCL Parser</strong></td>\n<td align=\"left\">Implementing the full HCL 2.x syntax with all expressions, functions, and blocks is a massive undertaking distinct from the core IaC reconciliation engine.</td>\n<td align=\"left\">Use a simplified, HCL-<em>like</em> syntax or YAML as the configuration language. For a more realistic parser, leverage an existing library (e.g., Python&#39;s <code>pyhcl</code> or Go&#39;s <code>hcl</code> package) in the <strong>Implementation Guidance</strong>, but the core design document will describe a simpler, custom parser for educational clarity.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Built-in Providers for All Cloud Services</strong></td>\n<td align=\"left\">The engine is a platform, not a comprehensive cloud management tool. Building and maintaining providers for hundreds of resource types across multiple clouds is a separate, vast project.</td>\n<td align=\"left\">The design includes a provider SDK (<code>BaseProvider</code> interface). The implementation will include one or two sample providers (e.g., a mock provider and a simple AWS EC2 provider) to demonstrate the pattern. Support for additional providers is left as an exercise or extension.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Web-Based UI or Dashboard</strong></td>\n<td align=\"left\">The primary interface is the command line. Building a graphical interface is a significant front-end project that does not contribute to the core learning objectives of state management, planning, and provider abstraction.</td>\n<td align=\"left\">The CLI provides all necessary functionality (<code>plan</code>, <code>apply</code>). A UI could be built as a separate, consuming application that calls the engine&#39;s core libraries.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Continuous Drift Detection &amp; Remediation</strong></td>\n<td align=\"left\">Automatically detecting and correcting configuration drift on a schedule is an operational feature that builds upon the core <code>plan</code>/<code>apply</code> mechanics. It introduces scheduling, eventing, and policy decision complexity.</td>\n<td align=\"left\">Drift detection can be simulated by running <code>plan</code> periodically (e.g., via cron). Automatic remediation would require an automated <code>apply</code>, which is a security/policy decision beyond the engine&#39;s responsibility.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Advanced Policy-as-Code (e.g., OPA/Sentinel)</strong></td>\n<td align=\"left\">Integrating policy checks that validate plans against security, compliance, or cost rules is a critical enterprise feature but adds significant complexity in policy language, evaluation engine, and enforcement hooks.</td>\n<td align=\"left\">The <code>plan</code> output can be piped to external policy tools. The architecture could be extended later with a validation webhook between planning and execution.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Team Collaboration Features (RBAC, Audit Logging)</strong></td>\n<td align=\"left\">Managing user permissions, audit trails, and approval workflows is essential for team use but belongs in a surrounding CI/CD or orchestration layer, not the core state reconciliation engine.</td>\n<td align=\"left\">Use the engine with a CI/CD system (like the one built in the prerequisite project) which handles authentication, authorization, and logging of who ran which plans.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Multi-Cloud Dependency Resolution</strong></td>\n<td align=\"left\">The engine does not need to handle dependencies <em>between</em> different cloud providers (e.g., an AWS resource depending on a GCP resource). This is an extreme edge case that vastly complicates authentication and state storage.</td>\n<td align=\"left\">Assume a single cloud provider context per configuration/state file. Cross-provider setups can be managed by using the engine separately for each provider and passing outputs manually or via a wrapper script.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Native Support for Imperative Scripts</strong></td>\n<td align=\"left\">The engine is declarative. While it may need to execute provisioning scripts <em>as a resource action</em> (e.g., via a <code>local_exec</code> provider), it will not parse or execute general-purpose imperative orchestration scripts as its primary config.</td>\n<td align=\"left\">Use a declarative resource provided by a custom provider to wrap imperative scripts if absolutely necessary, acknowledging that this breaks idempotency guarantees.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight:</strong> The distinction between goals and non-goals is not about importance, but about layering. The engine aims to be an excellent <em>platform</em> for declarative infrastructure reconciliation. Features like UI, collaboration, and policy are best built <em>on top</em> of this platform, not baked into its core.</p>\n</blockquote>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section provides a system-wide overview and is relevant to all milestones (1, 2, 3, 4).</p>\n</blockquote>\n<p>This section presents the bird&#39;s-eye view of the Infrastructure as Code (IaC) engine. Before diving into individual component details, it&#39;s crucial to understand how the system fits together as a cohesive whole. We&#39;ll first introduce the five core components and their responsibilities, then describe the recommended project structure to organize this architecture in code.</p>\n<h3 id=\"component-overview-and-responsibilities\">Component Overview and Responsibilities</h3>\n<p>Think of the IaC engine as a <strong>construction project management office</strong>. A project begins with architectural blueprints (configuration files). The office has specialists who interpret these blueprints, check what&#39;s already built, figure out the build order, and finally coordinate with various construction crews (cloud APIs) to execute the work. Our system decomposes this workflow into five specialized components.</p>\n<p>Each component has a single, well-defined responsibility and communicates with others through clear interfaces. This separation of concerns allows for independent development, testing, and potential replacement of individual parts (e.g., swapping the parser from HCL to YAML).</p>\n<p><img src=\"/api/project/infrastructure-as-code/architecture-doc/asset?path=diagrams%2Fsys-component.svg\" alt=\"System Component Diagram\"></p>\n<p>The five core components are:</p>\n<ol>\n<li><p><strong>Configuration Parser</strong>: The <strong>Interpreter and Expander</strong>. This component consumes human-written declarative configuration files (HCL or YAML). Its job is to read the raw text, resolve all variables and module references, and produce a complete, normalized, in-memory representation of the desired infrastructure—a collection of <code>Resource</code> objects with concrete attribute values. It handles the complexity of the Domain-Specific Language (DSL) so the rest of the system can work with simple data structures.</p>\n</li>\n<li><p><strong>State Manager</strong>: The <strong>Ledger and Lock</strong>. This component is the system&#39;s memory. It persistently stores the last known state of the deployed infrastructure in a <strong>state file</strong>. More importantly, it manages concurrent access to this state via a <strong>lock</strong>, preventing two simultaneous <code>apply</code> operations from corrupting each other&#39;s work. It can also compute the difference (diff) between the desired state (from the Parser) and the current state (from the ledger), which is the foundation of planning.</p>\n</li>\n<li><p><strong>Planner (Dependency Graph &amp; Planning)</strong>: The <strong>Project Manager and Gantt Chart</strong>. This component takes the normalized resources from the Parser and the current state from the State Manager. It analyzes the resources to build a <strong>Directed Acyclic Graph (DAG)</strong> based on their dependencies (e.g., a subnet must exist before a virtual machine placed within it). Using this graph and the state diff, it generates a safe, ordered <strong>execution plan</strong>—a list of <code>PlanAction</code> objects specifying precisely what needs to be created, updated, deleted, or left unchanged. This plan can be previewed by the user before any changes are made.</p>\n</li>\n<li><p><strong>Provider Abstraction (SDK)</strong>: The <strong>Universal Remote Control Interface</strong>. This is not a single component but an abstraction layer. It defines a standard <code>BaseProvider</code> interface with <strong>CRUD</strong> operations (<code>create</code>, <code>read</code>, <code>update</code>, <code>delete</code>). Concrete implementations (like <code>AwsProvider</code>, <code>GoogleCloudProvider</code>) act as plugins that translate these generic calls into specific API calls for their respective cloud platforms. This design allows the engine to support multiple clouds without changing its core logic.</p>\n</li>\n<li><p><strong>Executor</strong>: The <strong>Foreman and Dispatcher</strong>. This component takes the validated execution plan from the Planner and makes it happen. It is responsible for carrying out the plan by calling the appropriate methods on the configured <code>BaseProvider</code> implementations. It manages the execution flow: respecting the dependency order, handling concurrency for independent resources, implementing retry logic with exponential backoff for transient API failures, and reporting progress and outcomes back to the State Manager to update the ledger.</p>\n</li>\n</ol>\n<p>The table below summarizes each component&#39;s key responsibility, its primary inputs, and its primary outputs.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Component</th>\n<th align=\"left\">Primary Responsibility</th>\n<th align=\"left\">Key Inputs</th>\n<th align=\"left\">Key Outputs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Configuration Parser</strong></td>\n<td align=\"left\">Transforms declarative config files into a normalized set of concrete resources.</td>\n<td align=\"left\">HCL/YAML configuration files, variable values, module sources.</td>\n<td align=\"left\">A collection of resolved <code>Resource</code> objects.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>State Manager</strong></td>\n<td align=\"left\">Persists the known state of infrastructure and manages safe, concurrent access to it.</td>\n<td align=\"left\">Desired <code>Resource</code> collection, current state file, lock request.</td>\n<td align=\"left\"><code>StateRecord</code> collection, state diff, lock token.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Planner</strong></td>\n<td align=\"left\">Analyzes dependencies and state differences to produce a safe, ordered execution plan.</td>\n<td align=\"left\">Desired <code>Resource</code> collection, current <code>StateRecord</code> collection.</td>\n<td align=\"left\"><code>DependencyGraph</code>, ordered list of <code>PlanAction</code> objects (the plan).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Provider SDK</strong></td>\n<td align=\"left\">Defines the interface for cloud-specific operations and provides plugin implementations.</td>\n<td align=\"left\"><code>PlanAction</code> (via Executor), provider configuration (credentials, region).</td>\n<td align=\"left\">Real cloud resource ID and attributes (on success) or error.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Executor</strong></td>\n<td align=\"left\">Orchestrates the execution of a plan by calling provider methods and managing state updates.</td>\n<td align=\"left\">Ordered <code>PlanAction</code> list, configured <code>BaseProvider</code> instances.</td>\n<td align=\"left\">Updated <code>StateRecord</code> collection (written back via State Manager), execution result summary.</td>\n</tr>\n</tbody></table>\n<p><strong>Data Flow and Interactions:</strong> The components interact in a specific sequence during the two primary workflows: <code>plan</code> and <code>apply</code>. During a <code>plan</code>, data flows from left to right in the diagram: Config → Parser → Planner. The Planner also reads from the State Manager. The final plan is output to the user. During an <code>apply</code>, the loop is closed: the Executor takes the plan, interacts with Providers to change the real infrastructure, and then writes the new state back through the State Manager. The State Manager&#39;s lock is acquired at the start of <code>apply</code> and released at the end, ensuring isolation.</p>\n<h3 id=\"recommended-file-and-module-structure\">Recommended File and Module Structure</h3>\n<p>A well-organized codebase mirrors the architectural separation. The following structure is recommended for the Python implementation. It uses a clear separation between the core engine, provider plugins, and command-line interface, following Python packaging best practices.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>infra-as-code-engine/\n├── pyproject.toml                     # Project metadata and dependencies\n├── README.md\n├── src/\n│   └── iac_engine/                    # Main package\n│       ├── __init__.py\n│       ├── cli.py                     # Command-line interface (plan, apply, destroy)\n│       │\n│       ├── core/                      # The core engine components\n│       │   ├── __init__.py\n│       │   ├── parser.py              # Configuration Parser component\n│       │   ├── state_manager.py       # State Manager component\n│       │   ├── planner.py             # Planner component\n│       │   ├── executor.py            # Executor component\n│       │   └── models.py              # Core data types: Resource, StateRecord, etc.\n│       │\n│       ├── providers/                 # Provider Abstraction SDK and plugins\n│       │   ├── __init__.py\n│       │   ├── base.py                # BaseProvider abstract class\n│       │   ├── aws/                   # AWS provider implementation\n│       │   │   ├── __init__.py\n│       │   │   ├── provider.py        # AwsProvider class\n│       │   │   └── resources/         # AWS-specific resource implementations\n│       │   │       ├── ec2_instance.py\n│       │   │       └── s3_bucket.py\n│       │   ├── google/                # Google Cloud provider\n│       │   └── mock/                  # Mock provider for testing\n│       │\n│       └── utils/                     # Shared utilities\n│           ├── __init__.py\n│           ├── file_lock.py           # Locking implementation\n│           ├── retry.py               # Retry with exponential backoff\n│           └── graph.py               # Generic DAG utilities\n│\n├── tests/                             # Comprehensive test suite\n│   ├── unit/\n│   │   ├── test_parser.py\n│   │   ├── test_state_manager.py\n│   │   └── ...\n│   ├── integration/\n│   └── e2e/\n│\n├── examples/                          # Example configuration files\n│   ├── simple-webapp/\n│   │   ├── main.hcl\n│   │   └── variables.yaml\n│   └── multi-cloud/\n│\n└── docs/                              # Design docs, ADRs\n    └── architecture_decisions.md</code></pre></div>\n\n<p><strong>Key Rationale for This Structure:</strong></p>\n<ul>\n<li><strong><code>src/</code> layout</strong>: Using a <code>src</code> directory helps avoid common issues with Python imports, ensuring the package is always imported correctly, whether in development or after installation.</li>\n<li><strong>Clear namespace</strong>: The main package <code>iac_engine</code> provides a clear namespace for all engine-related code.</li>\n<li><strong>Component isolation</strong>: Each core component (<code>parser.py</code>, <code>state_manager.py</code>, etc.) lives in the <code>core/</code> module, making dependencies between them explicit and preventing circular imports.</li>\n<li><strong>Plugin architecture</strong>: The <code>providers/</code> directory is structured to easily add new providers as sub-packages. The <code>base.py</code> defines the contract that all plugins must follow.</li>\n<li><strong>Shared utilities</strong>: Common patterns like locking, retries, and graph algorithms are factored out into <code>utils/</code> to avoid duplication and ensure consistency.</li>\n<li><strong>Separation of tests</strong>: Tests mirror the source structure, making it easy to locate tests for a specific module.</li>\n</ul>\n<p>This structure scales well. As the project grows—adding more providers, utility functions, or complex examples—new directories and files can be added within the existing logical framework without major restructuring.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This subsection provides concrete, actionable guidance for implementing the high-level architecture described above in Python.</p>\n<p><strong>A. Technology Recommendations Table</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Component</th>\n<th align=\"left\">Simple Option (Recommended for Learning)</th>\n<th align=\"left\">Advanced Option (For Production Readiness)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Configuration Parsing</strong></td>\n<td align=\"left\">Use <code>pyhcl2</code> (HCL2 parser) or <code>pyyaml</code> for YAML. Manual variable interpolation.</td>\n<td align=\"left\">Implement a full recursive-descent parser for a custom DSL with advanced expression evaluation.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>State Serialization</strong></td>\n<td align=\"left\">JSON files for local state. Simple file-based locking.</td>\n<td align=\"left\">Protocol Buffers or MessagePack for compact binary format. Distributed lock via DynamoDB or Consul.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Dependency Graph</strong></td>\n<td align=\"left\">Python&#39;s <code>networkx</code> library for graph operations, or a custom <code>dict</code>-based adjacency list.</td>\n<td align=\"left\">Custom incremental graph with persistent indexing for fast dependency queries on large state.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Provider SDK</strong></td>\n<td align=\"left\">Abstract Base Classes (<code>abc.ABC</code>) for interface definition. <code>boto3</code> for AWS, <code>google-cloud-*</code> libraries for GCP.</td>\n<td align=\"left\">gRPC service definitions for a plugin system where providers run as separate processes.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Concurrency &amp; Retries</strong></td>\n<td align=\"left\"><code>concurrent.futures.ThreadPoolExecutor</code> for parallel applies. Custom retry decorator.</td>\n<td align=\"left\"><code>asyncio</code> with <code>aiohttp</code> for async I/O. Circuit breaker pattern (e.g., <code>pybreaker</code>) for API failure handling.</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File and Module Structure (Detailed)</strong></p>\n<p>The following Python code establishes the foundational modules and data models. Create these files in the <code>src/iac_engine/</code> directory as shown in the structure above.</p>\n<p><strong>1. Core Data Models (<code>src/iac_engine/core/models.py</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Core data models for the IaC engine.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, Dict, List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ActionType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"The type of change to be performed on a resource.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CREATE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"create\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    UPDATE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"update\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DELETE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"delete\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    NOOP</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"no-op\"</span><span style=\"color:#6A737D\">  # No operation needed</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Resource</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"A desired infrastructure resource as defined in configuration.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    id</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # Unique identifier within the config (e.g., \"aws_instance.web\")</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    type</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # Provider resource type (e.g., \"aws_instance\")</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # Local name (e.g., \"web\")</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    attributes: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Configuration attributes</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> StateRecord</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"A record of a resource as it exists in the deployed infrastructure.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resource_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # Matches Resource.id</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resource_type: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resource_name: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    attributes: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Last known attributes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dependencies: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># IDs of resources this depends on</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PlanAction</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"A proposed change to bring reality in line with configuration.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    action_type: ActionType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resource: Resource  </span><span style=\"color:#6A737D\"># The desired resource state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    prior_state: Optional[StateRecord] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # The state before the action (for UPDATE/DELETE)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_state: Optional[StateRecord] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # The expected state after the action</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DependencyGraphNode</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"A node in the resource dependency graph.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resource_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    depends_on: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Outgoing edges</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    required_by: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Incoming edges (for efficient traversal)</span></span></code></pre></div>\n\n<p><strong>2. Provider Base Interface (<code>src/iac_engine/providers/base.py</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Abstract base class for all infrastructure providers.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> abc </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> ABC</span><span style=\"color:#E1E4E8\">, abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, Dict, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..core.models </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Resource, StateRecord</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BaseProvider</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">ABC</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Interface that all concrete providers must implement.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create</span><span style=\"color:#E1E4E8\">(self, resource: Resource) -> StateRecord:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create a new resource.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            resource: The desired resource configuration.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            A StateRecord representing the newly created resource, including its</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            server-assigned ID and final attributes.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ProviderError: If creation fails.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> read</span><span style=\"color:#E1E4E8\">(self, resource_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, resource_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[StateRecord]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Read the current state of a resource from the provider.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            resource_id: The unique identifier of the resource.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            resource_type: The type of resource.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            A StateRecord if the resource exists, None if it does not.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ProviderError: If the read operation fails (e.g., network error).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> update</span><span style=\"color:#E1E4E8\">(self, resource: Resource, prior_state: StateRecord) -> StateRecord:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Update an existing resource.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            resource: The new desired configuration.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            prior_state: The state of the resource before the update.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            A StateRecord representing the updated resource.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ProviderError: If update fails or the resource cannot be updated in-place.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> delete</span><span style=\"color:#E1E4E8\">(self, resource_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, resource_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, prior_state: StateRecord) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Delete an existing resource.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            resource_id: The unique identifier of the resource.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            resource_type: The type of resource.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            prior_state: The last known state of the resource.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ProviderError: If deletion fails.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_credentials</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate that the provider is properly configured and credentials work.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            True if credentials are valid, False otherwise.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code</strong></p>\n<p><strong>1. Atomic File Operations Utility (<code>src/iac_engine/utils/atomic_file.py</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Utilities for atomic file writes to prevent corruption.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> os</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> tempfile</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> shutil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> pathlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> write_atomic_json</span><span style=\"color:#E1E4E8\">(filepath: Path, data: Any) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Write JSON data to a file atomically.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Writes to a temporary file in the same directory, then renames it</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    to the target filepath. This prevents partial writes if the process</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    crashes during write.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        filepath: The destination file path.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        data: Serializable data to write as JSON.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    filepath.parent.mkdir(</span><span style=\"color:#FFAB70\">parents</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">exist_ok</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Create a temporary file in the same directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    with</span><span style=\"color:#E1E4E8\"> tempfile.NamedTemporaryFile(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        mode</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'w'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        dir</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">filepath.parent,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        prefix</span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\".</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">filepath.name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">.tmp.\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        delete</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> tmp_file:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        json.dump(data, tmp_file, </span><span style=\"color:#FFAB70\">indent</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tmp_path </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Path(tmp_file.name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Atomic rename (POSIX guarantees this is atomic)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tmp_path.rename(filepath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # If rename fails, clean up the temporary file</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tmp_path.unlink(</span><span style=\"color:#FFAB70\">missing_ok</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> read_json_with_backup</span><span style=\"color:#E1E4E8\">(filepath: Path) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Read JSON file, with automatic fallback to a backup if present.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        filepath: The primary file path to read.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        The parsed JSON data.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        FileNotFoundError: If neither the file nor its backup exists.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        json.JSONDecodeError: If the file contains invalid JSON.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    backup_path </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> filepath.with_suffix(filepath.suffix </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \".backup\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> path </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> [filepath, backup_path]:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> path.exists():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                with</span><span style=\"color:#79B8FF\"> open</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#9ECBFF\">'r'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> f:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    return</span><span style=\"color:#E1E4E8\"> json.load(f)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#E1E4E8\"> json.JSONDecodeError:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # If the main file is corrupt, try the backup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> path </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> filepath </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> backup_path.exists():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    continue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    raise</span><span style=\"color:#79B8FF\"> FileNotFoundError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"State file not found: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">filepath</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code</strong></p>\n<p><strong>1. Main CLI Entry Point (<code>src/iac_engine/cli.py</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Command-line interface for the IaC engine.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> argparse</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> pathlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Import the core components once implemented</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># from .core.parser import ConfigurationParser</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># from .core.state_manager import StateManager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># from .core.planner import Planner</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># from .core.executor import Executor</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> plan_command</span><span style=\"color:#E1E4E8\">(config_path: Path, state_path: Path, var_file: Optional[Path]) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Generate and show an execution plan.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        config_path: Path to the main configuration file.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        state_path: Path to the state file.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        var_file: Optional path to a file containing variable values.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Planning for config: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">config_path</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize the ConfigurationParser and parse the config file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # parser = ConfigurationParser()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # desired_resources = parser.parse_file(config_path, var_file)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Initialize the StateManager and read the current state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # state_manager = StateManager(state_path)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # current_state = state_manager.read_state()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Initialize the Planner, build the dependency graph, and generate plan</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # planner = Planner()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # execution_plan = planner.generate_plan(desired_resources, current_state)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Display the plan in a human-readable format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # print(execution_plan.summary())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Plan command not yet implemented.\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> apply_command</span><span style=\"color:#E1E4E8\">(config_path: Path, state_path: Path, var_file: Optional[Path], auto_approve: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Apply the changes required to reach the desired state.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        config_path: Path to the main configuration file.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        state_path: Path to the state file.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        var_file: Optional path to a file containing variable values.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        auto_approve: If True, skip interactive approval.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Applying config: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">config_path</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement apply workflow</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Apply command not yet implemented.\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Parse command line arguments and dispatch to appropriate function.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parser </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> argparse.ArgumentParser(</span><span style=\"color:#FFAB70\">description</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"Infrastructure as Code Engine\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    subparsers </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parser.add_subparsers(</span><span style=\"color:#FFAB70\">dest</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'command'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">required</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Plan command</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    plan_parser </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> subparsers.add_parser(</span><span style=\"color:#9ECBFF\">'plan'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">help</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'Generate an execution plan'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    plan_parser.add_argument(</span><span style=\"color:#9ECBFF\">'config'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">Path, </span><span style=\"color:#FFAB70\">help</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'Path to configuration file'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    plan_parser.add_argument(</span><span style=\"color:#9ECBFF\">'--state'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">Path, </span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">Path(</span><span style=\"color:#9ECBFF\">\"./terraform.tfstate\"</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">help</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'Path to state file'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    plan_parser.add_argument(</span><span style=\"color:#9ECBFF\">'--var-file'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">Path, </span><span style=\"color:#FFAB70\">help</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'Path to variable definitions file'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Apply command</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    apply_parser </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> subparsers.add_parser(</span><span style=\"color:#9ECBFF\">'apply'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">help</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'Apply the execution plan'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    apply_parser.add_argument(</span><span style=\"color:#9ECBFF\">'config'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">Path, </span><span style=\"color:#FFAB70\">help</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'Path to configuration file'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    apply_parser.add_argument(</span><span style=\"color:#9ECBFF\">'--state'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">Path, </span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">Path(</span><span style=\"color:#9ECBFF\">\"./terraform.tfstate\"</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">help</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'Path to state file'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    apply_parser.add_argument(</span><span style=\"color:#9ECBFF\">'--var-file'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">Path, </span><span style=\"color:#FFAB70\">help</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'Path to variable definitions file'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    apply_parser.add_argument(</span><span style=\"color:#9ECBFF\">'--auto-approve'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">action</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'store_true'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">help</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'Skip interactive approval'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    args </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parser.parse_args()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> args.command </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'plan'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        plan_command(args.config, args.state, args.var_file)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    elif</span><span style=\"color:#E1E4E8\"> args.command </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'apply'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        apply_command(args.config, args.state, args.var_file, args.auto_approve)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> __name__</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#9ECBFF\"> \"__main__\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    main()</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints</strong></p>\n<ul>\n<li><strong>Data Classes:</strong> Use <code>@dataclass</code> from the <code>dataclasses</code> module (as shown) for the core models. They provide a clean, boilerplate-free way to define data structures with type hints.</li>\n<li><strong>Path Management:</strong> Use <code>pathlib.Path</code> instead of string paths for all file operations. It provides a more object-oriented and cross-platform API.</li>\n<li><strong>Type Hints:</strong> Make extensive use of Python type hints (<code>from typing import ...</code>). They serve as documentation and enable static type checking with tools like <code>mypy</code>, catching many errors early.</li>\n<li><strong>Abstract Base Classes:</strong> The <code>abc</code> module is perfect for defining the <code>BaseProvider</code> interface. Use <code>@abstractmethod</code> to enforce implementation in subclasses.</li>\n<li><strong>Serialization:</strong> For the state file, <code>json</code> is simple and human-readable. Use <code>json.dump</code> with <code>indent=2</code> for debugging. For production, consider adding a schema validation step before writing.</li>\n</ul>\n<p><strong>F. Milestone Checkpoint</strong></p>\n<p>After setting up the project structure and the skeleton code above, you should be able to:</p>\n<ol>\n<li>Create a virtual environment and install basic dependencies (e.g., <code>pip install pyyaml</code>).</li>\n<li>Run the CLI with <code>python -m src.iac_engine.cli plan ./examples/simple-webapp/main.hcl</code> and see the &quot;not yet implemented&quot; message.</li>\n<li>Verify that the core data models can be imported and instantiated correctly by writing a simple test script:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">    from</span><span style=\"color:#E1E4E8\"> iac_engine.core.models </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Resource, ActionType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    r </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Resource(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"test.vm\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"mock_instance\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"vm\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">attributes</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"size\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"large\"</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(r)  </span><span style=\"color:#6A737D\"># Should print a readable representation</span></span></code></pre></div>\n<p>This confirms the foundational project setup is correct before diving into component-specific implementation in the following milestones.</p>\n<h2 id=\"data-model\">Data Model</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section defines the foundational data structures used throughout the entire IaC engine and is relevant to all milestones (1, 2, 3, 4).</p>\n</blockquote>\n<p>The <strong>Data Model</strong> serves as the common language spoken by all components of the IaC engine. It defines the core entities—resources, state records, plan actions, and dependency nodes—that flow through the system as infrastructure configurations are transformed from declarative intent into actual deployed resources. A consistent, well-defined data model is crucial because it ensures that the parser, state manager, planner, and executor can communicate without ambiguity, even as each component performs vastly different operations. This section provides the complete specification for these data structures and maps their lifecycle transformations.</p>\n<h3 id=\"mental-model-the-recipe-the-pantry-inventory-the-shopping-list-and-the-cooking-steps\">Mental Model: The Recipe, the Pantry Inventory, the Shopping List, and the Cooking Steps</h3>\n<p>Imagine you&#39;re preparing a complex meal:</p>\n<ol>\n<li><strong>The Recipe (<code>Resource</code>):</strong> This is your desired end state—a list of ingredients and instructions. &quot;2 tomatoes, 1 onion, sauté for 10 minutes.&quot; It&#39;s declarative: you specify <em>what</em> you want, not the imperative steps to get it if ingredients are missing.</li>\n<li><strong>The Pantry Inventory (<code>StateRecord</code>):</strong> This is a snapshot of what you currently have. &quot;Pantry contains 1 tomato, 0 onions.&quot; It&#39;s a record of reality at a specific point in time.</li>\n<li><strong>The Shopping List (<code>PlanAction</code>):</strong> By comparing the recipe to your pantry, you generate a list of actions needed: &quot;BUY 1 tomato, BUY 1 onion.&quot; This is the <strong>execution plan</strong>—a set of imperative changes to bridge the gap between desired state (recipe) and current state (pantry).</li>\n<li><strong>The Cooking Dependency Chart (<code>DependencyGraphNode</code>):</strong> Some steps depend on others. You must chop the onion (Resource A) before you can sauté it with the tomatoes (Resource B). This chart defines the order in which actions must be executed.</li>\n</ol>\n<p>In our IaC engine, the <strong>Parser</strong> reads the recipe (HCL/YAML config). The <strong>State Manager</strong> maintains the pantry inventory (state file). The <strong>Planner</strong> compares the two to create the shopping list (execution plan) and consults the dependency chart to put the list in the correct order. Finally, the <strong>Executor</strong> goes to the store and cooks (applies the plan via providers).</p>\n<h3 id=\"key-types-and-structures\">Key Types and Structures</h3>\n<p>The following tables define the primary data structures. All components must use these exact definitions to ensure interoperability. The fields are designed to carry all necessary information through each stage of the pipeline, from configuration parsing to final state persistence.</p>\n<h4 id=\"resource-the-declarative-intent\"><code>Resource</code>: The Declarative Intent</h4>\n<p>A <code>Resource</code> represents a single infrastructure object as declared in the configuration file. It is the desired state specification before any runtime or state information is attached.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field Name</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>id</code></td>\n<td align=\"left\"><code>string</code></td>\n<td align=\"left\"><strong>A unique, immutable identifier for the resource <em>within the configuration</em>.</strong> This is typically constructed by the parser as <code>{resource_type}.{resource_name}</code> (e.g., <code>aws_instance.web_server</code>). It is used as the primary key for referencing resources in dependencies and within the state file. It is distinct from a cloud provider&#39;s runtime ID (e.g., <code>i-0abc123def456</code>).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>type</code></td>\n<td align=\"left\"><code>string</code></td>\n<td align=\"left\"><strong>The type of cloud resource.</strong> This maps directly to a provider&#39;s resource type. Examples: <code>aws_instance</code>, <code>google_compute_instance</code>, <code>kubernetes_deployment</code>. The provider interface uses this field to route CRUD operations to the correct implementation.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>name</code></td>\n<td align=\"left\"><code>string</code></td>\n<td align=\"left\"><strong>The logical name given to the resource by the user in the configuration.</strong> This is the local identifier within a configuration file or module. Example: In <code>resource &quot;aws_instance&quot; &quot;web_server&quot; { ... }</code>, the <code>name</code> is <code>&quot;web_server&quot;</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>attributes</code></td>\n<td align=\"left\"><code>map[string]any</code></td>\n<td align=\"left\"><strong>The complete set of configuration properties for the resource.</strong> This is a key-value map where keys are attribute names (e.g., <code>ami</code>, <code>instance_type</code>, <code>tags</code>) and values are the fully resolved, interpolated values after variable and module processing. The structure of this map must conform to the schema expected by the corresponding provider.</td>\n</tr>\n</tbody></table>\n<p><strong>Example:</strong> A resource block <code>resource &quot;aws_s3_bucket&quot; &quot;data_lake&quot; { bucket = &quot;my-unique-name&quot; }</code> would be parsed into a <code>Resource</code> object with:</p>\n<ul>\n<li><code>id</code>: <code>&quot;aws_s3_bucket.data_lake&quot;</code></li>\n<li><code>type</code>: <code>&quot;aws_s3_bucket&quot;</code></li>\n<li><code>name</code>: <code>&quot;data_lake&quot;</code></li>\n<li><code>attributes</code>: <code>{&quot;bucket&quot;: &quot;my-unique-name&quot;, &quot;acl&quot;: null, ...}</code> (including default or omitted attributes).</li>\n</ul>\n<h4 id=\"staterecord-the-known-reality\"><code>StateRecord</code>: The Known Reality</h4>\n<p>A <code>StateRecord</code> is a snapshot of an infrastructure resource as it exists (or is believed to exist) in the real world. It is persisted to the <strong>state file</strong> and serves as the system&#39;s &quot;memory&quot; of what it has previously created or managed.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field Name</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>resource_id</code></td>\n<td align=\"left\"><code>string</code></td>\n<td align=\"left\"><strong>The unique identifier of the resource, matching the <code>Resource.id</code> from configuration.</strong> This creates the link between a configuration declaration and its recorded state.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>resource_type</code></td>\n<td align=\"left\"><code>string</code></td>\n<td align=\"left\"><strong>The type of the resource.</strong> Duplicated from the corresponding <code>Resource.type</code> for convenience and integrity checks.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>resource_name</code></td>\n<td align=\"left\"><code>string</code></td>\n<td align=\"left\"><strong>The logical name of the resource.</strong> Duplicated from the corresponding <code>Resource.name</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>attributes</code></td>\n<td align=\"left\"><code>map[string]any</code></td>\n<td align=\"left\"><strong>The actual attribute values as reported by the cloud provider&#39;s API during the last successful <code>read</code> or <code>apply</code> operation.</strong> This includes <strong>all</strong> provider-output attributes, not just those set in configuration (e.g., a VM&#39;s <code>public_ip</code> assigned by the cloud, or a database&#39;s <code>arn</code>). This map is the source of truth for calculating diffs.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>dependencies</code></td>\n<td align=\"left\"><code>list[string]</code></td>\n<td align=\"left\"><strong>A list of <code>resource_id</code> values that this resource depends on.</strong> This is persisted to avoid the need to re-compute the dependency graph from configuration on every run, which is critical for operations like <code>destroy</code> where the configuration may no longer be available. It captures both explicit (<code>depends_on</code>) and implicit (attribute reference) dependencies.</td>\n</tr>\n</tbody></table>\n<p><strong>Example:</strong> After creating the S3 bucket above, a <code>StateRecord</code> might be:</p>\n<ul>\n<li><code>resource_id</code>: <code>&quot;aws_s3_bucket.data_lake&quot;</code></li>\n<li><code>resource_type</code>: <code>&quot;aws_s3_bucket&quot;</code></li>\n<li><code>resource_name</code>: <code>&quot;data_lake&quot;</code></li>\n<li><code>attributes</code>: <code>{&quot;bucket&quot;: &quot;my-unique-name&quot;, &quot;arn&quot;: &quot;arn:aws:s3:::my-unique-name&quot;, &quot;region&quot;: &quot;us-east-1&quot;, ...}</code></li>\n<li><code>dependencies</code>: <code>[]</code></li>\n</ul>\n<h4 id=\"planaction-the-proposed-change\"><code>PlanAction</code>: The Proposed Change</h4>\n<p>A <code>PlanAction</code> represents a single discrete change that needs to be applied to the infrastructure to align reality with the desired state. An <strong>execution plan</strong> is an ordered list of <code>PlanAction</code> objects.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field Name</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>action_type</code></td>\n<td align=\"left\"><code>enum(ActionType)</code></td>\n<td align=\"left\"><strong>The type of change to perform.</strong> The possible values are: <br>- <code>ActionType.CREATE</code>: The resource does not exist in state and must be created.<br>- <code>ActionType.UPDATE</code>: The resource exists, but one or more of its <code>attributes</code> have changed.<br>- <code>ActionType.DELETE</code>: The resource exists in state but is no longer present in the configuration.<br>- <code>ActionType.NOOP</code>: The resource exists and its configuration matches the state; no action is required.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>resource</code></td>\n<td align=\"left\"><code>Resource</code></td>\n<td align=\"left\"><strong>The desired state of the resource after the action completes.</strong> For <code>CREATE</code> and <code>UPDATE</code>, this is the target configuration. For <code>DELETE</code>, this field contains the resource&#39;s last known configuration (useful for provider operations). For <code>NOOP</code>, it&#39;s the current configuration.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>prior_state</code></td>\n<td align=\"left\"><code>StateRecord</code> (optional)</td>\n<td align=\"left\"><strong>The state of the resource before the action, if it exists.</strong> This is <code>null</code> for <code>CREATE</code> actions. For <code>UPDATE</code> and <code>DELETE</code>, it holds the <code>StateRecord</code> read from the state file. It is used by the provider&#39;s <code>update</code> method to compute a partial update and by the executor for rollback information.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>new_state</code></td>\n<td align=\"left\"><code>StateRecord</code> (optional)</td>\n<td align=\"left\"><strong>The expected state of the resource after the action succeeds.</strong> This is populated by the <strong>Planner</strong> as a <em>prediction</em> and is later updated by the <strong>Executor</strong> with the <em>actual</em> results from the provider. It starts with the <code>attributes</code> from <code>resource</code> and will be merged with provider-output attributes after a successful <code>create</code> or <code>update</code>.</td>\n</tr>\n</tbody></table>\n<p><strong>Example:</strong> If you change the S3 bucket&#39;s <code>acl</code> attribute from <code>private</code> to <code>public-read</code>, the planner generates a <code>PlanAction</code> with:</p>\n<ul>\n<li><code>action_type</code>: <code>ActionType.UPDATE</code></li>\n<li><code>resource</code>: <code>Resource{id: &quot;aws_s3_bucket.data_lake&quot;, attributes: {&quot;bucket&quot;: &quot;my-unique-name&quot;, &quot;acl&quot;: &quot;public-read&quot;, ...}}</code></li>\n<li><code>prior_state</code>: <code>StateRecord{...attributes: {&quot;acl&quot;: &quot;private&quot;, ...}}</code></li>\n<li><code>new_state</code>: <code>StateRecord{...attributes: {&quot;acl&quot;: &quot;public-read&quot;, ...}}</code> (predicted)</li>\n</ul>\n<h4 id=\"dependencygraphnode-the-ordering-constraint\"><code>DependencyGraphNode</code>: The Ordering Constraint</h4>\n<p>A <code>DependencyGraphNode</code> is a vertex in the <strong>Directed Acyclic Graph (DAG)</strong> that encodes the order dependencies between resources. The graph is built by the <strong>Planner</strong> and is used to topologically sort the <code>PlanAction</code> list.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field Name</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>resource_id</code></td>\n<td align=\"left\"><code>string</code></td>\n<td align=\"left\"><strong>The identifier of the resource this node represents.</strong> Matches <code>Resource.id</code> and <code>StateRecord.resource_id</code>. This is the node&#39;s unique key in the graph.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>depends_on</code></td>\n<td align=\"left\"><code>list[string]</code></td>\n<td align=\"left\"><strong>List of <code>resource_id</code> values that <em>this</em> resource depends on.</strong> These are the outgoing edges. For example, if a subnet must exist before a VM can be created in it, the VM&#39;s node will have the subnet&#39;s <code>resource_id</code> in its <code>depends_on</code> list.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>required_by</code></td>\n<td align=\"left\"><code>list[string]</code></td>\n<td align=\"left\"><strong>List of <code>resource_id</code> values that depend on <em>this</em> resource.</strong> These are the incoming edges. This field is often derived for convenience during graph traversal and topological sorting (it is the inverse of <code>depends_on</code> relationships across the graph).</td>\n</tr>\n</tbody></table>\n<p><strong>Example:</strong> A network interface (<code>aws_network_interface.main</code>) depends on a subnet (<code>aws_subnet.main</code>). Their graph nodes would be:</p>\n<ul>\n<li>Subnet Node: <code>resource_id: &quot;aws_subnet.main&quot;, depends_on: [], required_by: [&quot;aws_network_interface.main&quot;]</code></li>\n<li>Interface Node: <code>resource_id: &quot;aws_network_interface.main&quot;, depends_on: [&quot;aws_subnet.main&quot;], required_by: []</code></li>\n</ul>\n<h4 id=\"supporting-enum-actiontype\">Supporting Enum: <code>ActionType</code></h4>\n<p>This enumeration defines the four fundamental operations in a plan.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Constant</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>ActionType.CREATE</code></td>\n<td align=\"left\">The resource must be created. Corresponds to the provider&#39;s <code>create</code> method.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ActionType.UPDATE</code></td>\n<td align=\"left\">The resource must be updated in-place. Corresponds to the provider&#39;s <code>update</code> method.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ActionType.DELETE</code></td>\n<td align=\"left\">The resource must be destroyed. Corresponds to the provider&#39;s <code>delete</code> method.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ActionType.NOOP</code></td>\n<td align=\"left\">No operation is needed. The resource is already in sync.</td>\n</tr>\n</tbody></table>\n<h3 id=\"type-relationships-and-lifecycle\">Type Relationships and Lifecycle</h3>\n<p>The data structures do not exist in isolation; they undergo a series of transformations as they move through the IaC engine&#39;s workflow. Understanding this lifecycle is key to understanding how the system maintains consistency and safety.</p>\n<h4 id=\"lifecycle-stages-and-transformations\">Lifecycle Stages and Transformations</h4>\n<p>The journey from configuration to deployed infrastructure involves three primary states for each resource, represented by our core types:</p>\n<ol>\n<li><strong>Desired State (<code>Resource</code>):</strong> Defined by the user in HCL/YAML.</li>\n<li><strong>Proposed Change (<code>PlanAction</code>):</strong> Calculated by comparing Desired State with Known State.</li>\n<li><strong>Known State (<code>StateRecord</code>):</strong> Persisted after successful application of a change.</li>\n</ol>\n<p>The following diagram illustrates the relationships and transformations:\n<img src=\"/api/project/infrastructure-as-code/architecture-doc/asset?path=diagrams%2Fdata-model-class.svg\" alt=\"Data Model Relationships\"></p>\n<p><strong>1. Configuration Parsing (Milestone 1)</strong>\nThe <strong>Parser</strong> reads raw configuration files (HCL/YAML) and, after resolving variables, modules, and interpolations, produces a flat list of <code>Resource</code> objects. This list represents the complete desired state of the system. At this stage, <code>Resource.attributes</code> contain the final, user-specified values.</p>\n<blockquote>\n<p><strong>Example Transformation:</strong> The parser encounters <code>instance_type = &quot;${var.instance_size}&quot;</code>. It resolves <code>var.instance_size</code> to <code>&quot;t3.micro&quot;</code> and stores <code>&quot;t3.micro&quot;</code> in the <code>Resource.attributes</code> map under the key <code>instance_type</code>.</p>\n</blockquote>\n<p><strong>2. State Loading and Diff Calculation (Milestone 2)</strong>\nThe <strong>State Manager</strong> loads the previous <code>StateRecord</code> for each <code>Resource</code> from the state file (keyed by <code>resource_id</code>). For each resource, the system now holds two representations:</p>\n<ul>\n<li><strong>Desired (<code>Resource</code>):</strong> <code>{id: &quot;a&quot;, attributes: {&quot;size&quot;: &quot;large&quot;}}</code></li>\n<li><strong>Actual (<code>StateRecord</code>):</strong> <code>{resource_id: &quot;a&quot;, attributes: {&quot;size&quot;: &quot;medium&quot;}}</code></li>\n</ul>\n<p>The <strong>Planner</strong> performs a diff between these two representations. The diff logic must be aware of provider-specific semantics (e.g., some attributes are immutable and force a <code>DELETE</code>+<code>CREATE</code> instead of an <code>UPDATE</code>). The output of this diff is a <strong>draft</strong> <code>PlanAction</code> for the resource.</p>\n<blockquote>\n<p><strong>Decision: Diffing Strategy</strong></p>\n<ul>\n<li><strong>Context:</strong> We need to determine what constitutes a change worthy of an <code>UPDATE</code> action. A naive comparison of the entire <code>attributes</code> map is insufficient because the state contains read-only/computed fields (like ARNs, IDs) that are not present in the configuration.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Full Deep Diff:</strong> Compare all keys in both <code>Resource.attributes</code> and <code>StateRecord.attributes</code>, flagging any difference.</li>\n<li><strong>Config-Key-Only Diff:</strong> Only compare keys that are present in <code>Resource.attributes</code>. Ignore keys that only exist in <code>StateRecord.attributes</code> (computed fields).</li>\n<li><strong>Schema-Aware Diff:</strong> Use the provider&#39;s resource schema to classify attributes as &quot;configurable&quot; (requires update if changed) or &quot;computed&quot; (ignore for diff).</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Option 2, <strong>Config-Key-Only Diff</strong>.</li>\n<li><strong>Rationale:</strong> It is simple to implement and correct for the majority of cases. Computed fields are outputs from the provider and should not trigger updates. While Option 3 is more robust, it requires integrating complex schema information at the planning stage, which is a significant increase in complexity for a learning project.</li>\n<li><strong>Consequences:</strong> This approach may incorrectly flag a change if a user removes a configurable attribute from their configuration (as the diff will see a mismatch between <code>config[attr]=None</code> and <code>state[attr]=value</code>). We must treat a <code>None</code> in config as &quot;use default or remove,&quot; which requires special handling per attribute. This is a known simplification.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Option</th>\n<th align=\"left\">Pros</th>\n<th align=\"left\">Cons</th>\n<th align=\"left\">Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Full Deep Diff</td>\n<td align=\"left\">Simple, catches all changes.</td>\n<td align=\"left\">Incorrectly triggers updates on computed/immutable fields, leading to failed applies.</td>\n<td align=\"left\">❌</td>\n</tr>\n<tr>\n<td align=\"left\">Config-Key-Only Diff</td>\n<td align=\"left\">Avoids noise from computed fields. Simple logic.</td>\n<td align=\"left\">Requires careful handling of <code>null</code>/absent values. May miss force-new updates on immutable fields.</td>\n<td align=\"left\">✅</td>\n</tr>\n<tr>\n<td align=\"left\">Schema-Aware Diff</td>\n<td align=\"left\">Most accurate. Can handle immutable fields correctly.</td>\n<td align=\"left\">Complex. Requires tight coupling with provider schemas early in the pipeline.</td>\n<td align=\"left\">❌</td>\n</tr>\n</tbody></table>\n<p><strong>3. Dependency Graph Construction and Plan Finalization (Milestone 3)</strong>\nThe <strong>Planner</strong> builds a <code>DependencyGraph</code> from the list of resources. Each node is a <code>DependencyGraphNode</code>. Edges are created by analyzing <code>Resource</code> attribute values for references (e.g., <code>subnet_id = aws_subnet.main.id</code> creates a dependency from the referencing resource to <code>aws_subnet.main</code>) and processing explicit <code>depends_on</code> directives.</p>\n<p>The draft <code>PlanAction</code> list is then <strong>topologically sorted</strong> based on this graph. <code>CREATE</code> actions are ordered from dependencies to dependents. <code>DELETE</code> actions are ordered in the <strong>reverse</strong> direction (dependents before dependencies). This sorted list becomes the final <strong>execution plan</strong>.</p>\n<p><strong>4. Plan Execution and State Persistence (Milestone 4)</strong>\nThe <strong>Executor</strong> iterates through the sorted <code>PlanAction</code> list. For each action:</p>\n<ul>\n<li>It calls the appropriate CRUD method on the <code>BaseProvider</code> (e.g., <code>create(resource)</code> for <code>ActionType.CREATE</code>).</li>\n<li>Upon success, it calls the provider&#39;s <code>read</code> method to obtain the <em>actual</em> new attributes from the cloud API.</li>\n<li>It constructs a new <code>StateRecord</code> using these read attributes and the persisted dependency list.</li>\n<li>It updates the <code>PlanAction.new_state</code> field with this record.</li>\n<li>After all actions for a resource are complete, the <strong>Executor</strong> sends the updated <code>StateRecord</code> to the <strong>State Manager</strong>, which atomically writes it to the state file, replacing the old <code>StateRecord</code>.</li>\n</ul>\n<p>This last step closes the loop: the <code>StateRecord</code> generated from execution becomes the new &quot;known state&quot; for the next run.</p>\n<h4 id=\"walk-through-a-complete-resource-lifecycle\">Walk-Through: A Complete Resource Lifecycle</h4>\n<p>Let&#39;s trace a single resource, <code>aws_instance.app_server</code>, through a typical create-update-delete scenario.</p>\n<ol>\n<li><p><strong>Initial Run (Create):</strong></p>\n<ul>\n<li><strong>Config:</strong> <code>resource &quot;aws_instance&quot; &quot;app_server&quot; { ami = &quot;ami-123&quot; }</code></li>\n<li><strong>Parser Output:</strong> <code>Resource{id=&quot;aws_instance.app_server&quot;, type=&quot;aws_instance&quot;, name=&quot;app_server&quot;, attributes={&quot;ami&quot;: &quot;ami-123&quot;}}</code></li>\n<li><strong>State File:</strong> No existing <code>StateRecord</code> for <code>aws_instance.app_server</code>.</li>\n<li><strong>Planner Diff:</strong> <code>prior_state</code> is <code>null</code>, <code>action_type</code> = <code>CREATE</code>.</li>\n<li><strong>PlanAction:</strong> <code>{action_type: CREATE, resource: Resource{...}, prior_state: null, new_state: StateRecord{predicted...}}</code></li>\n<li><strong>Executor:</strong> Calls <code>provider.create(...)</code>. Gets actual instance ID <code>i-abc123</code> from cloud.</li>\n<li><strong>New State:</strong> <code>StateRecord{resource_id: &quot;aws_instance.app_server&quot;, attributes: {&quot;ami&quot;: &quot;ami-123&quot;, &quot;id&quot;: &quot;i-abc123&quot;, &quot;public_ip&quot;: &quot;1.2.3.4&quot;}, dependencies: []}</code> is written to state file.</li>\n</ul>\n</li>\n<li><p><strong>Second Run (Update):</strong></p>\n<ul>\n<li><strong>Config Changed:</strong> <code>ami = &quot;ami-456&quot;</code></li>\n<li><strong>Parser Output:</strong> <code>Resource{attributes={&quot;ami&quot;: &quot;ami-456&quot;}}</code></li>\n<li><strong>State Loaded:</strong> The <code>StateRecord</code> from step 1.</li>\n<li><strong>Planner Diff:</strong> <code>ami</code> differs (<code>&quot;ami-456&quot;</code> vs <code>&quot;ami-123&quot;</code>). <code>action_type</code> = <code>UPDATE</code>.</li>\n<li><strong>PlanAction:</strong> <code>{action_type: UPDATE, resource: Resource{...ami-456}, prior_state: StateRecord{...ami-123}, new_state: StateRecord{predicted...}}</code></li>\n<li><strong>Executor:</strong> Calls <code>provider.update(...)</code>. Cloud replaces the instance (new ID <code>i-def456</code>).</li>\n<li><strong>New State:</strong> <code>StateRecord{attributes: {&quot;ami&quot;: &quot;ami-456&quot;, &quot;id&quot;: &quot;i-def456&quot;, &quot;public_ip&quot;: &quot;5.6.7.8&quot;}, ...}</code> overwrites the old record.</li>\n</ul>\n</li>\n<li><p><strong>Third Run (Delete):</strong></p>\n<ul>\n<li><strong>Config:</strong> The <code>aws_instance.app_server</code> block is removed.</li>\n<li><strong>Parser Output:</strong> No <code>Resource</code> with id <code>aws_instance.app_server</code>.</li>\n<li><strong>State Loaded:</strong> The <code>StateRecord</code> from step 2 still exists.</li>\n<li><strong>Planner Diff:</strong> Resource missing in config but present in state. <code>action_type</code> = <code>DELETE</code>.</li>\n<li><strong>PlanAction:</strong> <code>{action_type: DELETE, resource: Resource{last known config}, prior_state: StateRecord{...}, new_state: null}</code></li>\n<li><strong>Executor:</strong> Calls <code>provider.delete(prior_state)</code>. Cloud destroys instance <code>i-def456</code>.</li>\n<li><strong>State Updated:</strong> The <code>StateRecord</code> for <code>aws_instance.app_server</code> is removed from the state file.</li>\n</ul>\n</li>\n</ol>\n<p>This predictable lifecycle, governed by the clear transformation between <code>Resource</code>, <code>PlanAction</code>, and <code>StateRecord</code>, is what enables the IaC engine to be idempotent and safe.</p>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Confusing <code>Resource.id</code> with Cloud Provider ID</strong></p>\n<ul>\n<li><strong>The Mistake:</strong> Storing the cloud-assigned identifier (e.g., <code>i-0abc123</code>) in the <code>Resource.id</code> field or using it as the key in the state file.</li>\n<li><strong>Why It&#39;s Wrong:</strong> The <code>Resource.id</code> is a logical identifier from configuration. It must be immutable and known before any API call. The cloud ID is an <em>output</em> of the create operation and belongs in <code>StateRecord.attributes</code>. Using the cloud ID as a key would break state tracking if the resource is recreated (new cloud ID).</li>\n<li><strong>The Fix:</strong> Always use the structured <code>{type}.{name}</code> format for <code>Resource.id</code> and <code>StateRecord.resource_id</code>. Store the cloud provider ID as a plain attribute (e.g., <code>attributes[&quot;id&quot;]</code>) within the <code>StateRecord</code>.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Storing Unresolved Variables or References in <code>Resource.attributes</code></strong></p>\n<ul>\n<li><strong>The Mistake:</strong> The Parser puts raw interpolated strings like <code>&quot;${var.region}&quot;</code> or references like <code>&quot;aws_vpc.main.id&quot;</code> into the <code>Resource.attributes</code> map.</li>\n<li><strong>Why It&#39;s Wrong:</strong> The Planner&#39;s diff logic and the Provider&#39;s CRUD methods cannot work with unresolved references. They need concrete values (like <code>&quot;us-east-1&quot;</code>) or opaque IDs (like <code>&quot;vpc-123&quot;</code>).</li>\n<li><strong>The Fix:</strong> Ensure the <strong>Parser</strong> fully resolves all variable interpolations and module outputs <em>before</em> creating the final <code>Resource</code> objects. References to other resources should be resolved to their <em>state</em> values (e.g., the actual VPC ID) by the Planner when building the dependency graph, and these concrete values should be placed in a copy of the <code>Resource</code> used for planning.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Forgetting to Update <code>dependencies</code> in <code>StateRecord</code></strong></p>\n<ul>\n<li><strong>The Mistake:</strong> The <code>StateRecord</code> written after an apply contains an empty or outdated <code>dependencies</code> list.</li>\n<li><strong>Why It&#39;s Wrong:</strong> The dependency graph is needed for <code>destroy</code> operations and for targeted plans. If the configuration is deleted, the system cannot rebuild the graph from source. An outdated list can lead to incorrect destroy order (trying to delete a subnet before deleting VMs inside it).</li>\n<li><strong>The Fix:</strong> When the Planner builds the dependency graph, ensure the resulting <code>depends_on</code> list for each resource is captured and stored in the <code>StateRecord</code> that gets persisted after a successful apply.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>A. Technology Recommendations Table</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Component</th>\n<th align=\"left\">Simple Option (Recommended for Learning)</th>\n<th align=\"left\">Advanced Option (For Production)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Data Serialization</td>\n<td align=\"left\"><strong>Python&#39;s <code>json</code> module</strong> (built-in, simple). Use <code>json.dumps</code> for writing and <code>json.loads</code> for reading.</td>\n<td align=\"left\"><strong>Pydantic models</strong> with validation. Provides automatic type coercion, validation, and serialization.</td>\n</tr>\n<tr>\n<td align=\"left\">In-Memory Data Structures</td>\n<td align=\"left\"><strong>Python dictionaries (<code>dict</code>) and lists.</strong> Directly map to JSON structures. Use <code>dataclasses</code> or simple classes for type hints.</td>\n<td align=\"left\"><strong>TypedDict</strong> (Python 3.8+) for stricter dictionary shape validation. <code>@dataclass</code> for mutable objects.</td>\n</tr>\n<tr>\n<td align=\"left\">Enum Implementation</td>\n<td align=\"left\"><strong>Python <code>enum.Enum</code> class.</strong> Provides clear names for <code>ActionType</code>.</td>\n<td align=\"left\"><strong><code>str</code>-based enums</strong> (<code>enum.Enum</code> with mixin) for easier JSON serialization.</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure</strong></p>\n<p>Place the core data model definitions in a central module that all other components can import.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>infrastructure-as-code-engine/\n├── iac/\n│   ├── __init__.py\n│   ├── models/                  # Data model definitions\n│   │   ├── __init__.py\n│   │   ├── resource.py          # Resource class\n│   │   ├── state.py             # StateRecord class &amp; StateFile container\n│   │   ├── plan.py              # PlanAction class &amp; ActionType enum\n│   │   └── graph.py             # DependencyGraphNode &amp; Graph class\n│   ├── parser/                  # Milestone 1\n│   ├── state/                   # Milestone 2\n│   ├── planner/                 # Milestone 3\n│   └── executor/                # Milestone 4\n└── pyproject.toml</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code (COMPLETE, ready to use)</strong></p>\n<p><strong>1. Base Model Helper (JSON Serialization):</strong> Create a mixin class to easily convert our models to/from dictionaries for JSON serialization.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># iac/models/__init__.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, Dict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> abc </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> ABC</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> JsonSerializable</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">ABC</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Mixin class to provide to_dict and from_dict methods.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_dict</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert the object to a dictionary suitable for JSON serialization.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # This simple implementation works for dataclasses and simple classes.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # For complex objects, override this method in the subclass.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">__dict__</span><span style=\"color:#E1E4E8\">.copy()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_dict</span><span style=\"color:#E1E4E8\">(cls, data: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create an instance of the class from a dictionary.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> cls</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">data)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_json</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Serialize the object to a JSON string.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> json.dumps(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.to_dict(), </span><span style=\"color:#FFAB70\">indent</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_json</span><span style=\"color:#E1E4E8\">(cls, json_str: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Deserialize the object from a JSON string.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> json.loads(json_str)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> cls</span><span style=\"color:#E1E4E8\">.from_dict(data)</span></span></code></pre></div>\n\n<p><strong>2. Atomic File Operations Helper:</strong> Use this for safe reading/writing of state and lock files.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># iac/utils/file.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> os</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> tempfile</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> pathlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> write_atomic_json</span><span style=\"color:#E1E4E8\">(filepath: Path, data: Any) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Write JSON data to a file atomically to prevent corruption.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Writes to a temporary file in the same directory then renames it.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    filepath </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Path(filepath)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Create a temporary file in the same directory for atomic rename</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    with</span><span style=\"color:#E1E4E8\"> tempfile.NamedTemporaryFile(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        mode</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'w'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        dir</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">filepath.parent,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        prefix</span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\".</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">filepath.name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">.tmp.\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        delete</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> tmp:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        json.dump(data, tmp, </span><span style=\"color:#FFAB70\">indent</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tmp.flush()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        os.fsync(tmp.fileno())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tmp_path </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Path(tmp.name)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Atomic rename (POSIX systems guarantee this is atomic)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        os.rename(tmp_path, filepath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Clean up temp file if rename fails</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tmp_path.unlink(</span><span style=\"color:#FFAB70\">missing_ok</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> read_json_with_backup</span><span style=\"color:#E1E4E8\">(filepath: Path) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Read JSON file, with automatic fallback to a backup if present.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns the parsed data or raises FileNotFoundError if neither exists.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    filepath </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Path(filepath)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    backup_path </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> filepath.with_suffix(filepath.suffix </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> '.backup'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    last_error </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Try main file first</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> filepath.exists():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            with</span><span style=\"color:#79B8FF\"> open</span><span style=\"color:#E1E4E8\">(filepath, </span><span style=\"color:#9ECBFF\">'r'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> f:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> json.load(f)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#E1E4E8\"> (json.JSONDecodeError, </span><span style=\"color:#79B8FF\">OSError</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            last_error </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> e</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Main file corrupted, try backup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> backup_path.exists():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    with</span><span style=\"color:#79B8FF\"> open</span><span style=\"color:#E1E4E8\">(backup_path, </span><span style=\"color:#9ECBFF\">'r'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> f:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> json.load(f)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Backup was good, restore it</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    write_atomic_json(filepath, data)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                except</span><span style=\"color:#E1E4E8\"> (json.JSONDecodeError, </span><span style=\"color:#79B8FF\">OSError</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> backup_error:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    last_error </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> backup_error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    data </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    elif</span><span style=\"color:#E1E4E8\"> backup_path.exists():</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # No main file, but backup exists (e.g., after a crash)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            with</span><span style=\"color:#79B8FF\"> open</span><span style=\"color:#E1E4E8\">(backup_path, </span><span style=\"color:#9ECBFF\">'r'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> f:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> json.load(f)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Restore from backup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            write_atomic_json(filepath, data)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#E1E4E8\"> (json.JSONDecodeError, </span><span style=\"color:#79B8FF\">OSError</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            last_error </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> e</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            data </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> data </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> FileNotFoundError</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            f</span><span style=\"color:#9ECBFF\">\"Could not read valid JSON from </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">filepath</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> or backup. Last error: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">last_error</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> data</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code</strong></p>\n<p><strong>1. Data Model Definitions (<code>Resource</code>, <code>StateRecord</code>, <code>PlanAction</code>, <code>DependencyGraphNode</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># iac/models/resource.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, Dict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..models </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> JsonSerializable</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Resource</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JsonSerializable</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents a desired infrastructure resource from configuration.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    id</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # Format: \"resource_type.resource_name\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    type</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # e.g., \"aws_instance\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # Logical name from config</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    attributes: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __post_init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Basic validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.id:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Resource id cannot be empty\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#9ECBFF\"> '.'</span><span style=\"color:#F97583\"> not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.id:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Resource id should be in format 'type.name', got: </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.id</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># iac/models/state.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, Dict, List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..models </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> JsonSerializable</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> StateRecord</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JsonSerializable</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Snapshot of a deployed resource's actual state.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resource_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resource_type: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resource_name: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    attributes: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dependencies: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># List of resource_ids this depends on</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __post_init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.resource_id:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"StateRecord.resource_id cannot be empty\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># iac/models/plan.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .resource </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Resource</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .state </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> StateRecord</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..models </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> JsonSerializable</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ActionType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">enum</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"The type of change to perform on a resource.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CREATE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"create\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    UPDATE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"update\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DELETE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"delete\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    NOOP</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"noop\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.value</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PlanAction</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JsonSerializable</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"A proposed change to bring reality in line with desired state.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    action_type: ActionType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resource: Resource</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    prior_state: Optional[StateRecord] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_state: Optional[StateRecord] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_dict</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Custom serialization to handle Enums and nested objects</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"action_type\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.action_type.value,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"resource\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.resource.to_dict(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"prior_state\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.prior_state.to_dict() </span><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.prior_state </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"new_state\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.new_state.to_dict() </span><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.new_state </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> data</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_dict</span><span style=\"color:#E1E4E8\">(cls, data: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> </span><span style=\"color:#9ECBFF\">'PlanAction'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Custom deserialization</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> cls</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            action_type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">ActionType(data[</span><span style=\"color:#9ECBFF\">\"action_type\"</span><span style=\"color:#E1E4E8\">]),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            resource</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">Resource.from_dict(data[</span><span style=\"color:#9ECBFF\">\"resource\"</span><span style=\"color:#E1E4E8\">]),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            prior_state</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">StateRecord.from_dict(data[</span><span style=\"color:#9ECBFF\">\"prior_state\"</span><span style=\"color:#E1E4E8\">]) </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> data.get(</span><span style=\"color:#9ECBFF\">\"prior_state\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            new_state</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">StateRecord.from_dict(data[</span><span style=\"color:#9ECBFF\">\"new_state\"</span><span style=\"color:#E1E4E8\">]) </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> data.get(</span><span style=\"color:#9ECBFF\">\"new_state\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># iac/models/graph.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Set</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..models </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> JsonSerializable</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DependencyGraphNode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JsonSerializable</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"A node in the resource dependency graph.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resource_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    depends_on: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Outgoing edges</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    required_by: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Incoming edges (derived)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DependencyGraph</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"A directed graph representing resource dependencies.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.nodes: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, DependencyGraphNode] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> add_node</span><span style=\"color:#E1E4E8\">(self, resource_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add a node for the given resource_id if it doesn't exist.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if node with resource_id already exists in self.nodes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If not, create a new DependencyGraphNode with that resource_id</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Store it in self.nodes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> add_dependency</span><span style=\"color:#E1E4E8\">(self, from_resource_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, to_resource_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Add a dependency edge: from_resource depends on to_resource.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        This means from_resource -> to_resource (from must be created after to).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Ensure both nodes exist (call add_node for each)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add to_resource_id to from_resource.depends_on list (if not already present)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Add from_resource_id to to_resource.required_by list (if not already present)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> topological_sort</span><span style=\"color:#E1E4E8\">(self) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Return a list of resource_ids in topological order (dependencies first).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises ValueError if a cycle is detected.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create a copy of the graph's dependency information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Find all nodes with zero in-degree (empty depends_on)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: While there are zero in-degree nodes:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3a: Remove one and add it to result list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3b: For each node that required it, remove the dependency edge</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3c: Update zero in-degree list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If result list length != total nodes, there's a cycle → raise ValueError</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return the result list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> reverse_topological_sort</span><span style=\"color:#E1E4E8\">(self) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Return a list of resource_ids in reverse topological order (dependents first).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Useful for destroy operations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Get topological sort</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Return it reversed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints</strong></p>\n<ol>\n<li><strong>Use <code>@dataclass</code></strong>: They automatically generate <code>__init__</code>, <code>__repr__</code>, and <code>__eq__</code> methods, making your data models clean and Pythonic.</li>\n<li><strong>Type Hints</strong>: Use them everywhere. They don&#39;t affect runtime but help with IDE autocompletion and catching bugs early with tools like <code>mypy</code>.</li>\n<li><strong>JSON Serialization for Enums</strong>: The built-in <code>json</code> module doesn&#39;t serialize <code>Enum</code> objects by default. Our <code>PlanAction.to_dict()</code> method manually converts the <code>ActionType</code> enum to its string value. Alternatively, you could write a custom JSON encoder.</li>\n<li><strong>Default Factories</strong>: Use <code>field(default_factory=list)</code> instead of <code>field(default=[])</code> for mutable defaults to avoid shared list instances across instances.</li>\n</ol>\n<p><strong>F. Milestone Checkpoint</strong></p>\n<p>After implementing the data models, verify they work correctly by creating a simple test script:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># test_models.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> iac.models </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Resource, StateRecord, ActionType, PlanAction</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Create a Resource</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">r </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Resource(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"aws_instance.web\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"aws_instance\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"web\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">attributes</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"ami\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"ami-123\"</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Resource: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">r</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Resource JSON: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">r.to_json()</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Create a StateRecord</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">s </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> StateRecord(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    resource_id</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"aws_instance.web\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    resource_type</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"aws_instance\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    resource_name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"web\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    attributes</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"id\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"i-abc123\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"ami\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"ami-123\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    dependencies</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">[]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">StateRecord: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">s</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Create a PlanAction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">p </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PlanAction(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    action_type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">ActionType.</span><span style=\"color:#79B8FF\">UPDATE</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    resource</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">r,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    prior_state</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">s,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    new_state</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">PlanAction: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">p</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"PlanAction JSON: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">p.to_json()</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test round-trip serialization</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">p2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PlanAction.from_json(p.to_json())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> p2.action_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> p.action_type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> p2.resource.id </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> p.resource.id</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">✅ Round-trip serialization works!\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p>Run this script. Expected output should show the objects and their JSON representations without errors, confirming your basic data model is functional.</p>\n<h2 id=\"component-design-configuration-parser\">Component Design: Configuration Parser</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 1</p>\n</blockquote>\n<p>The <strong>Configuration Parser</strong> is the entry point of the IaC engine, responsible for translating human-readable configuration files into a normalized, machine-processable representation of desired infrastructure. It must comprehend a domain-specific language (like HCL or YAML), resolve dynamic expressions, assemble reusable modules, and produce a complete collection of <code>Resource</code> objects—the &quot;desired state&quot; that subsequent components will compare against reality. This component&#39;s accuracy is foundational; any misinterpretation here leads to incorrect plans and potentially destructive infrastructure changes.</p>\n<h3 id=\"mental-model-the-interpreter-and-expander\">Mental Model: The Interpreter and Expander</h3>\n<p>Imagine you are given a construction blueprint written in a mix of standard notations and custom shorthand. Your job is to produce a single, unambiguous, and fully detailed set of instructions for the construction crew. The original blueprint might have placeholders like &quot;use the <code>main_color</code> specified in the <code>branding</code> folder,&quot; and it might reference entire pre-drawn sections from other blueprint files labeled &quot;standard office module.&quot; You, as the interpreter, must:</p>\n<ol>\n<li><strong>Parse the Syntax:</strong> Understand the meaning of each symbol and notation (e.g., a box labeled &quot;VM&quot; means to provision a virtual machine).</li>\n<li><strong>Expand Templates:</strong> Find the definition of <code>main_color</code> (perhaps in a separate <code>variables.tf</code> file) and replace every placeholder with the concrete value &quot;Deep Blue.&quot;</li>\n<li><strong>Combine Chapters:</strong> Locate the &quot;standard office module&quot; file, interpret its contents, and integrate its defined resources (desks, chairs, network jacks) into the main plan, possibly customizing them for this specific building.</li>\n</ol>\n<p>In this analogy, the original HCL/YAML files are the blueprint with shorthand and references. The Parser acts as the <strong>Interpreter and Expander</strong>. It reads the raw text, understands the structure (parsing), fills in the blanks (variable interpolation), and pulls in external definitions (module resolution) to output one comprehensive, flat list of concrete <code>Resource</code> definitions—the final, unambiguous construction plan. This process is visualized in the parsing flowchart: <img src=\"/api/project/infrastructure-as-code/architecture-doc/asset?path=diagrams%2Fflowchart-parser.svg\" alt=\"Flowchart: Configuration Parsing and Resolution\"></p>\n<h3 id=\"interface-and-public-methods\">Interface and Public Methods</h3>\n<p>The Parser&#39;s public API is designed for a straightforward workflow: load a root configuration file and receive a complete set of resolved resources. Its core interface consists of the following methods.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Method Name</th>\n<th align=\"left\">Parameters</th>\n<th align=\"left\">Returns</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>parse_file</code></td>\n<td align=\"left\"><code>file_path: Path</code></td>\n<td align=\"left\"><code>dict</code> (Raw AST)</td>\n<td align=\"left\">Reads a single configuration file from disk and parses it into a raw, unprocessed abstract syntax tree (AST) represented as a Python dictionary. This is a low-level method that does not perform resolution.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>resolve_variables</code></td>\n<td align=\"left\"><code>ast: dict, variable_files: List[Path], cli_vars: dict</code></td>\n<td align=\"left\"><code>dict</code> (Resolved AST)</td>\n<td align=\"left\">Takes a raw AST and a set of variable values (from files and command-line overrides) and recursively replaces all variable interpolation expressions (e.g., <code>${var.name}</code>) with their concrete values. Returns a new AST with values resolved.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>load_module</code></td>\n<td align=\"left\"><code>module_call: dict, parent_dir: Path</code></td>\n<td align=\"left\"><code>dict</code> (Module AST)</td>\n<td align=\"left\">Given a module block definition (from the AST) and the directory of the parent configuration, locates the module&#39;s source (local path), parses its files, recursively resolves its own variables and sub-modules, and returns the fully resolved AST for that module.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>process_configuration</code></td>\n<td align=\"left\"><code>root_file: Path, variable_files: List[Path], cli_vars: dict</code></td>\n<td align=\"left\"><code>List[Resource]</code></td>\n<td align=\"left\"><strong>Primary entry point.</strong> Orchestrates the full parsing pipeline. Parses the root file, resolves all variables, recursively loads all referenced modules, flattens the structure, and converts the final resolved AST into a list of <code>Resource</code> objects ready for the Planner.</td>\n</tr>\n</tbody></table>\n<p>The <code>Resource</code> type produced by <code>process_configuration</code> is a core data structure of the entire system. Its fields are detailed below.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field Name</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>id</code></td>\n<td align=\"left\"><code>string</code></td>\n<td align=\"left\">A unique, deterministic identifier for the resource within the configuration. Typically formed as <code>&lt;resource_type&gt;.&lt;resource_name&gt;</code> (e.g., <code>aws_instance.web_server</code>).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>type</code></td>\n<td align=\"left\"><code>string</code></td>\n<td align=\"left\">The type of infrastructure resource, which maps to a specific provider and API (e.g., <code>aws_instance</code>, <code>google_sql_database_instance</code>).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>name</code></td>\n<td align=\"left\"><code>string</code></td>\n<td align=\"left\">The logical name given to this resource instance within the configuration, unique within its type scope.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>attributes</code></td>\n<td align=\"left\"><code>map[string]any</code></td>\n<td align=\"left\">A key-value map of all configuration arguments for the resource. These are the fully resolved, concrete values (e.g., <code>{&quot;ami&quot;: &quot;ami-12345&quot;, &quot;instance_type&quot;: &quot;t3.micro&quot;}</code>).</td>\n</tr>\n</tbody></table>\n<h3 id=\"internal-behavior-and-algorithm\">Internal Behavior and Algorithm</h3>\n<p>The <code>process_configuration</code> method implements a multi-stage pipeline to transform text files into <code>Resource</code> objects. The following numbered algorithm details each step.</p>\n<ol>\n<li><p><strong>Load and Parse Root Configuration:</strong> Read the primary configuration file (e.g., <code>main.tf</code>) from disk. Pass its content through a syntax parser (for HCL or YAML) to produce a <strong>raw AST</strong>. This AST is a hierarchical dictionary mirroring the configuration&#39;s structure, containing unresolved blocks, expressions, and references.</p>\n</li>\n<li><p><strong>Extract and Merge Variable Values:</strong> Gather variable definitions from all sources, following a precedence order (lowest to highest): default values in variable declarations, values from variable files (e.g., <code>terraform.tfvars</code>), and finally values provided via command-line flags (<code>-var</code>). Merge them into a single <code>variables</code> dictionary, with higher-priority sources overriding lower ones.</p>\n</li>\n<li><p><strong>Resolve Variable Interpolation:</strong> Perform a depth-first traversal of the raw AST. For every string value encountered, check for the interpolation pattern <code>${...}</code>.</p>\n<ol>\n<li>If the pattern matches <code>var.&lt;name&gt;</code>, look up the concrete value in the merged <code>variables</code> dictionary and replace the entire expression with that value.</li>\n<li>If the pattern matches a more complex expression (e.g., <code>function.call</code>, <code>resource.attr</code>), tag it for later resolution by the Planner. For this milestone, we focus only on <code>var</code> references.</li>\n<li>Recursively process the updated value in case interpolation returns another string with nested expressions.</li>\n</ol>\n</li>\n<li><p><strong>Resolve Module Blocks:</strong> Traverse the resolved AST to find all <code>module</code> blocks. For each module block:</p>\n<ol>\n<li>Extract the <code>source</code> attribute (a local file path).</li>\n<li>Compute the absolute source directory relative to the parent configuration&#39;s directory.</li>\n<li>Recursively call the parsing pipeline (<code>process_configuration</code>) on the module&#39;s own root file (e.g., <code>./modules/vpc/main.tf</code>), passing down any variables defined in the module block&#39;s <code>inputs</code>.</li>\n<li>The recursive call returns a list of <code>Resource</code> objects defined within that module.</li>\n<li><strong>Namespace the module&#39;s resources:</strong> To avoid ID collisions, prepend the module&#39;s logical name to each returned resource&#39;s <code>id</code> and <code>name</code>. For example, a <code>vpc</code> module containing a resource <code>aws_vpc.main</code> becomes <code>module.vpc.aws_vpc.main</code>.</li>\n</ol>\n</li>\n<li><p><strong>Flatten and Convert to Resources:</strong> After processing all modules, you have a collection of resolved resource blocks from the root and all nested modules. Convert each resource block into a <code>Resource</code> object.</p>\n<ol>\n<li>The <code>type</code> is the block label (e.g., <code>aws_instance</code>).</li>\n<li>The <code>name</code> is the user-defined label for that resource block.</li>\n<li>The <code>attributes</code> are the key-value pairs inside the block, now with all <code>var.*</code> interpolations resolved.</li>\n<li>The <code>id</code> is generated as a concatenation of <code>type</code> and <code>name</code> (and module prefix if applicable).</li>\n</ol>\n</li>\n<li><p><strong>Output Resource List:</strong> Return the final, flat list of all <code>Resource</code> objects. This list represents the complete desired state of the infrastructure as declared in the configuration.</p>\n</li>\n</ol>\n<p>This sequence is part of the larger <code>plan</code> command workflow, as shown in the sequence diagram: <img src=\"/api/project/infrastructure-as-code/architecture-doc/asset?path=diagrams%2Fplan-sequence.svg\" alt=\"Sequence Diagram: Plan Command\"></p>\n<h3 id=\"adr-abstract-syntax-tree-vs-direct-dict\">ADR: Abstract Syntax Tree vs. Direct Dict</h3>\n<blockquote>\n<p><strong>Decision: Use a Lightweight Dict-based AST</strong></p>\n<ul>\n<li><strong>Context:</strong> We need an in-memory representation of the configuration&#39;s structure after parsing but before resolution. This representation must be easy to traverse, manipulate, and serialize. We must choose between building a formal Abstract Syntax Tree (AST) with dedicated node classes or using the native data structures (dicts, lists, strings) returned by the parser.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Formal AST Classes:</strong> Define Python classes for each node type (e.g., <code>BlockNode</code>, <code>AttributeNode</code>, <code>VariableExprNode</code>). Each class has defined fields and methods for traversal and manipulation.</li>\n<li><strong>Lightweight Dict/List Structure:</strong> Use the nested dictionaries and lists produced directly by the parser (e.g., PyHCL&#39;s output). Treat the structure generically.</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> We will use the lightweight dict/list structure (Option 2).</li>\n<li><strong>Rationale:</strong><ul>\n<li><strong>Simplicity and Development Speed:</strong> The dict structure requires no upfront class design. It maps directly to JSON, simplifying debugging and serialization for tests. For an educational project, this reduces cognitive load and lets us focus on the resolution algorithms.</li>\n<li><strong>Parser Agnosticism:</strong> Different parsers (for HCL, YAML, JSON) naturally output dicts. A generic dict interface allows us to swap or support multiple parsers without changing the resolution logic.</li>\n<li><strong>Sufficient for Needs:</strong> Our resolution algorithms (tree traversal, string replacement) are structurally simple. They don&#39;t require the type safety or encapsulation benefits of a full class hierarchy at this stage.</li>\n</ul>\n</li>\n<li><strong>Consequences:</strong><ul>\n<li><strong>Pros:</strong> Faster to implement, easier to debug (<code>print(json.dumps(ast, indent=2))</code>), flexible for different input formats.</li>\n<li><strong>Cons:</strong> Loss of type safety—the code must defensively check for expected keys and structures. Less self-documenting than a class-based model. Complex transformations in future extensions might become harder to manage.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>The comparison table below summarizes the trade-offs.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Option</th>\n<th align=\"left\">Pros</th>\n<th align=\"left\">Cons</th>\n<th align=\"left\">Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Formal AST Classes</strong></td>\n<td align=\"left\">Type-safe, self-documenting, enables visitor pattern for complex operations, compile-time checks possible.</td>\n<td align=\"left\">Higher upfront design cost, more boilerplate code, tightly coupled to a specific parser&#39;s output structure.</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Lightweight Dict/List</strong></td>\n<td align=\"left\">Rapid prototyping, easy serialization/debugging, parser-agnostic, less code to maintain.</td>\n<td align=\"left\">No type checking, reliance on string keys, potential for runtime errors due to malformed structure.</td>\n<td align=\"left\"><strong>Yes</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Infinite Loop in Variable Resolution</strong></p>\n<ul>\n<li><strong>Description:</strong> A variable&#39;s value is defined by referencing another variable, which in turn references the first, either directly (<code>var.a -&gt; var.b -&gt; var.a</code>) or through a longer chain. During the <code>resolve_variables</code> traversal, the parser gets stuck in an endless loop.</li>\n<li><strong>Why it&#39;s Wrong:</strong> The algorithm will never terminate, consuming CPU and hanging the IaC engine. This violates the requirement for predictable execution.</li>\n<li><strong>How to Fix:</strong> Implement a <strong>dependency graph for variables</strong> before resolution. Before replacing values, analyze all variable expressions to build a graph of <code>var.a</code> depends on <code>var.b</code>. Run a cycle detection algorithm (like Depth-First Search with coloring). If a cycle is found, abort with a clear error message pointing to the involved variables.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: The <code>count</code>/<code>for_each</code> Interpolation Chicken-Egg Problem</strong></p>\n<ul>\n<li><strong>Description:</strong> The <code>count</code> meta-argument determines how many instances of a resource are created. If <code>count</code> itself uses a variable interpolation (e.g., <code>count = var.num_servers</code>), but that variable&#39;s value is derived from the output attribute of another resource (e.g., <code>num_servers = length(aws_autoscaling_group.web.instances)</code>), you have a paradoxical dependency. You need the resource&#39;s output to know how many of it to create.</li>\n<li><strong>Why it&#39;s Wrong:</strong> This creates a circular dependency that cannot be resolved at parse time. The parser cannot resolve <code>var.num_servers</code> because its value is unknown until <em>after</em> some infrastructure is provisioned.</li>\n<li><strong>How to Fix:</strong> Recognize that <code>count</code> and <code>for_each</code> are <strong>runtime evaluations</strong>. The parser should leave interpolations within these meta-arguments unresolved during the initial parsing phase. They become <strong>dynamic references</strong> that are evaluated by the Planner <em>after</em> the dependency graph is built, using values from the state file or from outputs of already-applied resources during the <code>apply</code> phase.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Module Source Path Ambiguity</strong></p>\n<ul>\n<li><strong>Description:</strong> A module&#39;s <code>source</code> attribute is specified as a relative path like <code>../modules/vpc</code>. If the parser does not properly resolve this path relative to the calling configuration&#39;s directory, it may load the wrong files or fail to find them.</li>\n<li><strong>Why it&#39;s Wrong:</strong> Leads to <code>FileNotFoundError</code> or, worse, silently loading an unrelated configuration, resulting in a plan that doesn&#39;t match the user&#39;s intent.</li>\n<li><strong>How to Fix:</strong> Always resolve module source paths to absolute paths as early as possible. Use the parent configuration file&#39;s directory (<code>parent_dir</code>) as the base. The rule is: <code>abs_source = (parent_dir / source).resolve()</code>. Document this resolution strategy clearly.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>A. Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Component</th>\n<th align=\"left\">Simple Option (Recommended for Learning)</th>\n<th align=\"left\">Advanced Option (For Production)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>HCL Parser</strong></td>\n<td align=\"left\"><code>pyhcl2</code> (a Python port of HCL 2) - Pure Python, easier to install and debug.</td>\n<td align=\"left\"><code>python-hcl2</code> - Another popular parser. For maximum fidelity, use the official <strong>HashiCorp Go libraries</strong> via a subprocess or CFFI, but this adds complexity.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>YAML Parser</strong></td>\n<td align=\"left\">Python&#39;s built-in <code>yaml</code> module (<code>PyYAML</code> if not installed).</td>\n<td align=\"left\">Use a schema validator like <code>yamale</code> alongside parsing to enforce structure.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Data Structure</strong></td>\n<td align=\"left\">Nested <code>dict</code> and <code>list</code> objects.</td>\n<td align=\"left\">Use <code>dataclasses</code> or <code>pydantic</code> models for the final <code>Resource</code> list, while keeping the intermediate AST as dicts.</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure</strong>\nPlace the parser logic in a dedicated module. Separate concerns for file I/O, syntax parsing, and resolution logic.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>iac-engine/\n├── iac_engine/\n│   ├── __init__.py\n│   ├── cli.py                      # CLI commands (plan_command, apply_command)\n│   ├── parser/                     # Configuration Parser Component\n│   │   ├── __init__.py\n│   │   ├── core.py                 # Parser class with main interface methods\n│   │   ├── resolvers.py            # Variable and module resolution logic\n│   │   ├── file_loader.py          # Safe file loading utilities (starter code below)\n│   │   └── exceptions.py           # Parser-specific exceptions (e.g., ParseError, CyclicVariableError)\n│   ├── models.py                   # Shared data models (Resource, StateRecord, etc.)\n│   └── ... (other components)\n├── configs/                        # Example configurations for testing\n│   ├── main.tf\n│   └── variables.tfvars\n├── pyproject.toml\n└── README.md</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code</strong></p>\n<p>The following is a complete, reusable utility for safely reading configuration files with basic error handling. It should be placed in <code>parser/file_loader.py</code>.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Safe file loading utilities for the configuration parser.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> pathlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, Union</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> yaml</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hcl2  </span><span style=\"color:#6A737D\"># Requires: pip install pyhcl2</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> FileLoaderError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base exception for file loading failures.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> safe_read_file</span><span style=\"color:#E1E4E8\">(filepath: Path) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Read a text file safely with explicit error handling.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        filepath: Path to the file.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        The file content as a string.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        FileLoaderError: If the file cannot be read (does not exist, permission denied, etc.).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> filepath.read_text(</span><span style=\"color:#FFAB70\">encoding</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">FileNotFoundError</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">PermissionError</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">IsADirectoryError</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">UnicodeDecodeError</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> FileLoaderError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Failed to read file '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">filepath</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">': </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> e</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> load_config_file</span><span style=\"color:#E1E4E8\">(filepath: Path) -> </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Load and parse a configuration file based on its extension.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Supports .tf (HCL), .tf.json (JSON), .yaml, .yml.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        filepath: Path to the configuration file.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        A dictionary representing the parsed configuration (raw AST).</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        FileLoaderError: If the file cannot be parsed or has an unsupported extension.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    content </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> safe_read_file(filepath)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    suffix </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> filepath.suffix.lower()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> suffix </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '.tf'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Parse HCL using pyhcl2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> hcl2.loads(content)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> suffix </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '.json'</span><span style=\"color:#F97583\"> or</span><span style=\"color:#E1E4E8\"> filepath.name.endswith(</span><span style=\"color:#9ECBFF\">'.tf.json'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> json.loads(content)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> suffix </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">'.yaml'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'.yml'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Using SafeLoader by default to avoid arbitrary code execution</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> yaml.safe_load(content)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> FileLoaderError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Unsupported configuration file extension: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">suffix</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#E1E4E8\"> (hcl2.HCL2Error, json.JSONDecodeError, yaml.YAMLError) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> FileLoaderError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Failed to parse '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">filepath</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">': </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> e</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code</strong></p>\n<p>The main parsing logic resides in <code>parser/core.py</code>. Below is the skeleton for the primary <code>Parser</code> class with detailed TODO comments that map directly to the algorithm steps described earlier.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Core configuration parser implementing the parsing pipeline.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> pathlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..models </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Resource</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> . </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> resolvers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .file_loader </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> load_config_file, FileLoaderError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Parser</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Orchestrates the parsing of IaC configuration files.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse_file</span><span style=\"color:#E1E4E8\">(self, file_path: Path) -> </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Parse a single configuration file into a raw AST (dict).</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            file_path: Path to the .tf, .yaml, or .json file.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            A dictionary representing the raw, unprocessed AST.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Use the `load_config_file` utility to load and parse the file.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Return the parsed dictionary.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> resolve_variables</span><span style=\"color:#E1E4E8\">(self, ast: </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">, variable_files: List[Path], cli_vars: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Resolve variable interpolations within an AST.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ast: The raw AST dictionary.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            variable_files: List of paths to variable definition files (.tfvars, .json, .yaml).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            cli_vars: Dictionary of variable values provided via command line.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            A new AST dictionary with variable references replaced by concrete values.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract default variable declarations from the 'variable' blocks in the AST.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Load variable values from each file in `variable_files` (using load_config_file).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Merge values: defaults &#x3C; file values &#x3C; cli_vars (highest priority).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Perform a depth-first traversal of the AST.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: For each string value found, check for the pattern ${var.&#x3C;name>}.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Look up the variable name in the merged values dictionary.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Replace the entire interpolation expression with the concrete value.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: (Advanced) Detect circular dependencies between variables and raise an error.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use a recursive function or a stack for traversal.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> load_module</span><span style=\"color:#E1E4E8\">(self, module_call: </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">, parent_dir: Path) -> List[Resource]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Load and fully resolve a module, returning its resources.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            module_call: The AST of the 'module' block (contains 'source', 'inputs', etc.).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            parent_dir: The directory of the configuration file containing this module call.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            A list of Resource objects defined within the module, with names prefixed.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract the 'source' attribute from module_call. Raise error if missing.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Resolve the source path to an absolute directory relative to parent_dir.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Find the main configuration file within the module directory (e.g., main.tf).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Call `self.process_configuration` on that main file, passing the 'inputs' as cli_vars.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: For each Resource returned, prepend the module's logical name to its `id` and `name`.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Example: module name = \"vpc\", resource id = \"aws_vpc.main\" -> \"module.vpc.aws_vpc.main\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return the list of prefixed resources.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> process_configuration</span><span style=\"color:#E1E4E8\">(self, root_file: Path,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                              variable_files: Optional[List[Path]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                              cli_vars: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> List[Resource]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Main entry point: parse a root configuration and all its modules.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            root_file: Path to the root configuration file.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            variable_files: Optional list of variable definition files.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            cli_vars: Optional dictionary of command-line variable overrides.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            A flat list of all Resource objects from the root and nested modules.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize variable_files and cli_vars to empty lists/dicts if None.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Parse the root file using `self.parse_file`.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Resolve variables in the root AST using `self.resolve_variables`.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Initialize an empty list `all_resources`.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Traverse the resolved AST to find 'resource' blocks at the root level.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: For each root resource block, convert it to a Resource and add to all_resources.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Traverse the resolved AST to find 'module' blocks.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: For each module block, call `self.load_module` and extend all_resources with the result.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Return the complete list of resources.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints</strong></p>\n<ul>\n<li><strong>Recursive Traversal:</strong> When implementing <code>resolve_variables</code>, a recursive helper function that handles dictionaries, lists, and strings is simpler than managing an explicit stack for this use case.</li>\n<li><strong>Path Handling:</strong> Always use <code>pathlib.Path</code> objects instead of string concatenation for file paths. Use <code>/</code> operator to join paths (e.g., <code>parent_dir / &quot;modules/vpc&quot;</code>).</li>\n<li><strong>Module Discovery:</strong> A simple heuristic for finding a module&#39;s main file is to look for <code>main.tf</code>, then <code>variables.tf</code>, then any <code>.tf</code> file in the module directory.</li>\n<li><strong>Error Messages:</strong> When raising exceptions, include the file name, line number (if available from the parser), and the specific problematic construct (e.g., &quot;Undefined variable &#39;region&#39; in main.tf&quot;).</li>\n</ul>\n<p><strong>F. Milestone Checkpoint</strong></p>\n<p>After implementing the <code>Parser</code> class, you should be able to run the following verification steps:</p>\n<ol>\n<li><strong>Unit Test:</strong> Create a simple test configuration.</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">    # test_parser.py (simplified example)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    from</span><span style=\"color:#E1E4E8\"> iac_engine.parser.core </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Parser</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    from</span><span style=\"color:#E1E4E8\"> pathlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Path</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parser </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Parser()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resources </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parser.process_configuration(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        root_file</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">Path(</span><span style=\"color:#9ECBFF\">\"configs/main.tf\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        variable_files</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">[Path(</span><span style=\"color:#9ECBFF\">\"configs/terraform.tfvars\"</span><span style=\"color:#E1E4E8\">)],</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        cli_vars</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"instance_count\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Parsed </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(resources)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> resources\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> resources:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"  - </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">r.id</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">r.attributes</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><p><strong>Expected Behavior:</strong> Given a valid configuration, the script should print a list of <code>Resource</code> objects with fully resolved attribute values (no <code>${var...}</code> placeholders). Module resources should have IDs prefixed with <code>module.&lt;name&gt;.</code>.</p>\n</li>\n<li><p><strong>Signs of Trouble:</strong></p>\n<ul>\n<li><strong><code>FileLoaderError</code>:</strong> Check file paths and ensure the parser&#39;s working directory is correct.</li>\n<li><strong>Variable not resolved:</strong> Verify the variable merging logic and the traversal/replacement in <code>resolve_variables</code>.</li>\n<li><strong>Module resources missing:</strong> Ensure <code>load_module</code> is being called and that it correctly recurses into subdirectories.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"component-design-state-manager\">Component Design: State Manager</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 2</p>\n</blockquote>\n<p>The <strong>State Manager</strong> is the system of record for the IaC engine, maintaining a persistent, authoritative snapshot of what infrastructure currently exists according to the system&#39;s knowledge. It bridges the declarative world of configuration files and the imperative reality of cloud resources by storing the last known state after each successful operation. Beyond simple persistence, it ensures safe concurrent access through locking mechanisms and provides the critical diffing logic that determines what changes are needed.</p>\n<h3 id=\"mental-model-the-ledger-and-lock\">Mental Model: The Ledger and Lock</h3>\n<p>Think of the State Manager as a combination of a <strong>bank ledger</strong> and a <strong>safety deposit box lock</strong>. The ledger (the state file) is a meticulously kept record of every resource the system has deployed: its unique cloud identifier, its current attributes, and how resources are connected. This ledger allows the system to answer the fundamental question: &quot;What do I already have?&quot;</p>\n<p>The safety deposit box lock (the state lock) protects this ledger during updates. Imagine multiple people (or automated processes) trying to update the same bank ledger simultaneously—chaos would ensue. The lock ensures only one &quot;teller&quot; can modify the ledger at a time, preventing conflicting updates that could corrupt the record or cause duplicate resource creation. When a teller starts an update, they take the key (acquire the lock), make their changes, and then return the key (release the lock) for the next person.</p>\n<p>This dual role—persistent record-keeping and concurrent access control—makes the State Manager a critical linchpin for safety and correctness in any multi-user or automated IaC environment.</p>\n<h3 id=\"interface-and-public-methods\">Interface and Public Methods</h3>\n<p>The State Manager exposes a clean interface centered around four core operations: reading/writing state, acquiring/releasing locks, and computing the difference between states. The following table details the public contract.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>read_state</code></td>\n<td><code>state_path: Path</code></td>\n<td><code>Dict[str, StateRecord]</code></td>\n<td>Loads the state file from the given path, parsing its JSON content into an in-memory dictionary keyed by resource address (e.g., <code>&quot;aws_instance.web&quot;</code>). Handles missing files (returns empty dict) and corrupted content (attempts recovery from backup).</td>\n</tr>\n<tr>\n<td><code>write_state</code></td>\n<td><code>state_path: Path</code>, <code>state_data: Dict[str, StateRecord]</code></td>\n<td><code>None</code></td>\n<td>Persists the in-memory state dictionary to disk at the specified path. Performs an <strong>atomic write</strong> to prevent corruption: writes to a temporary file, syncs to disk, then renames to the target path. Optionally creates a backup of the previous state file.</td>\n</tr>\n<tr>\n<td><code>acquire_lock</code></td>\n<td><code>lock_path: Path</code>, <code>timeout_seconds: int = 30</code>, <code>heartbeat_interval: int = 10</code></td>\n<td><code>LockHandle</code></td>\n<td>Attempts to acquire an exclusive lock for the state. Creates a lock file containing process metadata (PID, hostname, timestamp). If the lock already exists, checks if it&#39;s stale (older than timeout). Returns a handle object that must be used to release the lock. Starts a background heartbeat thread to periodically update the lock timestamp, preventing it from becoming stale during long operations.</td>\n</tr>\n<tr>\n<td><code>release_lock</code></td>\n<td><code>lock_handle: LockHandle</code></td>\n<td><code>None</code></td>\n<td>Releases the lock represented by the given handle. Stops the heartbeat thread and deletes the lock file. Must be called even if errors occur during apply to prevent deadlocks.</td>\n</tr>\n<tr>\n<td><code>compute_diff</code></td>\n<td><code>current_state: Dict[str, StateRecord]</code>, <code>desired_resources: List[Resource]</code></td>\n<td><code>Dict[str, PlanAction]</code></td>\n<td>The core diffing engine. Compares the current deployed state (from <code>read_state</code>) with the desired state (from the Parser). For each desired resource, determines if it needs to be created, updated, deleted, or left alone (<code>NOOP</code>). Returns a dictionary of actions keyed by resource address.</td>\n</tr>\n<tr>\n<td><code>get_resource_address</code></td>\n<td><code>resource: Resource</code></td>\n<td><code>str</code></td>\n<td>Helper method that generates a unique address string for a resource, following the convention <code>&quot;{resource_type}.{resource_name}&quot;</code>. This address is used as the key in the state dictionary and for dependency tracking.</td>\n</tr>\n</tbody></table>\n<p><strong>Supporting Data Types:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Type Name</th>\n<th>Fields</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>StateRecord</code></td>\n<td><code>resource_id: str</code>, <code>resource_type: str</code>, <code>resource_name: str</code>, <code>attributes: Dict[str, Any]</code>, <code>dependencies: List[str]</code></td>\n<td>A snapshot of a resource as it exists in the cloud. The <code>resource_id</code> is the unique identifier assigned by the cloud provider (e.g., AWS instance ID <code>i-12345</code>). <code>attributes</code> are the <em>actual</em> values read from the cloud API at the last refresh. <code>dependencies</code> is a list of resource addresses this resource depends on, used for graph construction.</td>\n</tr>\n<tr>\n<td><code>LockHandle</code></td>\n<td><code>lock_path: Path</code>, <code>process_id: int</code>, <code>lock_id: str</code> (UUID), <code>heartbeat_thread: Optional[Thread]</code>, <code>stop_event: Event</code></td>\n<td>An opaque object representing an acquired lock. It holds references to the lock file path, the current process&#39;s ID, a unique lock identifier for verification, and the background heartbeat thread with its stop signal. The caller should not modify this object.</td>\n</tr>\n<tr>\n<td><code>PlanAction</code></td>\n<td><code>action_type: ActionType</code>, <code>resource: Resource</code>, <code>prior_state: Optional[StateRecord]</code>, <code>new_state: Optional[StateRecord]</code></td>\n<td>The output of <code>compute_diff</code>. Describes a change to be made. For <code>CREATE</code>, <code>prior_state</code> is <code>None</code>. For <code>DELETE</code>, <code>new_state</code> is <code>None</code>. For <code>UPDATE</code>, both are populated with the old and new states.</td>\n</tr>\n</tbody></table>\n<h3 id=\"internal-behavior-and-algorithm\">Internal Behavior and Algorithm</h3>\n<p>The State Manager&#39;s internal logic can be decomposed into three primary algorithms: atomic state persistence, lock management with heartbeats, and state diff calculation.</p>\n<h4 id=\"1-atomic-state-persistence-with-write_atomic_json\">1. Atomic State Persistence with <code>write_atomic_json</code></h4>\n<p>To guarantee the state file is never left in a partially written, corrupted state, the write operation follows an <strong>atomic rename pattern</strong>. This is implemented in the helper function <code>write_atomic_json</code>, which the <code>write_state</code> method calls.</p>\n<ol>\n<li><strong>Serialize to JSON</strong>: Convert the state dictionary (containing <code>StateRecord</code> objects) into a JSON string. Use a consistent indentation for readability.</li>\n<li><strong>Create Temporary File</strong>: Generate a temporary file path in the same directory as the target state file, using a prefix (e.g., <code>.terraform_state.tmp-</code>) and a random suffix to avoid collisions.</li>\n<li><strong>Write and Sync</strong>: Open the temporary file in write mode (<code>&#39;w&#39;</code>). Write the JSON string. Call <code>os.fsync()</code> on the file descriptor to ensure the data is flushed to physical disk, not just the OS cache.</li>\n<li><strong>Create Backup (Optional)</strong>: If the target state file already exists, rename it to a backup file (e.g., <code>.terraform_state.backup</code>) before the next step. This provides a recovery point.</li>\n<li><strong>Atomic Rename</strong>: Perform an atomic filesystem rename operation (<code>os.rename</code>) to move the temporary file to the final state file path. On POSIX systems, rename is atomic even in the face of crashes: the target path will point either to the old file or the new file, never a mixture.</li>\n<li><strong>Cleanup</strong>: If the backup file exists and the rename succeeded, the old backup (if any) can be removed. If any step fails, the temporary file is cleaned up, leaving the original state file intact.</li>\n</ol>\n<h4 id=\"2-lock-acquisition-with-heartbeat\">2. Lock Acquisition with Heartbeat</h4>\n<p>The locking mechanism prevents concurrent modifications. It uses a simple file-based lock with a heartbeat to handle long-running operations and process crashes.</p>\n<ol>\n<li><strong>Check for Existing Lock</strong>: When <code>acquire_lock</code> is called, it first checks if a lock file exists at <code>lock_path</code>.</li>\n<li><strong>Stale Lock Detection</strong>: If a lock file exists, read its JSON content (containing <code>process_id</code>, <code>hostname</code>, <code>timestamp</code>, and <code>lock_id</code>). Calculate the age of the lock (current time minus <code>timestamp</code>). If the age exceeds the <code>timeout_seconds</code> parameter, the lock is considered <strong>stale</strong> (likely from a crashed process). Log a warning and proceed to steal the lock. Otherwise, wait and retry (with a backoff) until the lock is released or becomes stale.</li>\n<li><strong>Create New Lock</strong>: If no lock exists or the existing lock is stale, create a new lock file. Write a JSON object with the current process&#39;s PID, the machine&#39;s hostname, the current timestamp, and a newly generated UUID (<code>lock_id</code>). Perform an atomic write (similar to state writes) to ensure the lock file is created completely.</li>\n<li><strong>Start Heartbeat Thread</strong>: Create a background daemon thread that will periodically (every <code>heartbeat_interval</code> seconds) update the lock file&#39;s timestamp to the current time. This &quot;refreshes&quot; the lock, preventing it from appearing stale during a long <code>apply</code> operation. The thread runs until a stop event is set.</li>\n<li><strong>Return Handle</strong>: Package the lock file path, PID, <code>lock_id</code>, and references to the heartbeat thread and stop event into a <code>LockHandle</code> object and return it.</li>\n</ol>\n<h4 id=\"3-computing-the-state-diff\">3. Computing the State Diff</h4>\n<p>The <code>compute_diff</code> algorithm is the brain of the planning phase. It determines the set of actions required to converge the current state to the desired state.</p>\n<ol>\n<li><strong>Index Current State</strong>: Build a dictionary mapping resource addresses (<code>type.name</code>) to their <code>StateRecord</code> objects from the <code>current_state</code> input.</li>\n<li><strong>Index Desired Resources</strong>: Build a similar dictionary for the <code>desired_resources</code> list, using the <code>get_resource_address</code> helper.</li>\n<li><strong>Initialize Action Dictionary</strong>: Create an empty dictionary to hold <code>PlanAction</code> objects, keyed by resource address.</li>\n<li><strong>Iterate Over Desired Resources</strong>: For each resource in the desired resources dictionary:<ul>\n<li><strong>Address Lookup</strong>: Look up the resource&#39;s address in the current state index.</li>\n<li><strong>No Current State (<code>CREATE</code>)</strong>: If not found, the resource does not exist. Create a <code>PlanAction</code> with <code>action_type=ActionType.CREATE</code>, the <code>resource</code> set to the desired resource, <code>prior_state=None</code>, and <code>new_state</code> set to a <code>StateRecord</code> populated from the desired resource (but with <code>resource_id</code> initially empty).</li>\n<li><strong>Current State Exists</strong>: If found, compare the desired resource&#39;s attributes with the current state&#39;s attributes. Perform a <strong>deep, semantic comparison</strong>. For complex nested structures (like security group rules), order may not matter. If any attribute differs (considering provider-specific semantics), mark the resource for <code>UPDATE</code>. Create a <code>PlanAction</code> with the changed resource and both states. If no attributes differ, mark as <code>NOOP</code>.</li>\n</ul>\n</li>\n<li><strong>Identify Resources to Delete</strong>: Find all resources in the current state index that are <em>not</em> present in the desired resources index. For each, create a <code>PlanAction</code> with <code>action_type=ActionType.DELETE</code>, <code>resource</code> constructed from the <code>StateRecord</code> (type and name), <code>prior_state</code> set to the record, and <code>new_state=None</code>.</li>\n<li><strong>Return Actions</strong>: Return the populated action dictionary.</li>\n</ol>\n<blockquote>\n<p><strong>Key Design Insight:</strong> The diff algorithm must be <strong>idempotent</strong>. Running <code>plan</code> twice on the same configuration and state should produce an identical plan (ideally empty after an apply). This requires the comparison logic to ignore transient or read-only fields (like <code>arn</code> in AWS, which is derived from the ID) and to handle default values that the provider may inject.</p>\n</blockquote>\n<h3 id=\"adr-pessimistic-file-locking-vs-optimistic-concurrency\">ADR: Pessimistic File Locking vs. Optimistic Concurrency</h3>\n<blockquote>\n<p><strong>Decision: Use Pessimistic File Locking for State Modification</strong></p>\n<ul>\n<li><strong>Context</strong>: The state file is a shared resource that must be modified by concurrent <code>apply</code> commands (from multiple users or CI/CD jobs). Without coordination, simultaneous writes could corrupt the file or cause race conditions where one process overwrites another&#39;s changes, leading to resource duplication or orphaned resources.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Pessimistic File Locking (Chosen)</strong>: Acquire an exclusive lock (via a lock file) before reading the state, hold it throughout the <code>plan</code> and <code>apply</code> workflow, and release only after the new state is written. This ensures serializability.</li>\n<li><strong>Optimistic Concurrency Control (OCC)</strong>: Read the state without a lock, perform the plan and apply, then attempt to write the new state only if the state file&#39;s content hasn&#39;t changed since the initial read (using a version stamp or checksum). If it has changed, abort and retry from the beginning.</li>\n<li><strong>Distributed Lock Service</strong>: Use an external service like Redis, etcd, or a database to manage distributed locks, which is more robust in highly concurrent, multi-host environments.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement a simple <strong>pessimistic file lock</strong> using a lock file with a heartbeat mechanism and stale lock detection.</li>\n<li><strong>Rationale</strong>:<ul>\n<li><strong>Simplicity and Educational Value</strong>: File locks are easier to understand and implement correctly for a learning project. The concepts of atomic file operations, lock files, and heartbeats are fundamental.</li>\n<li><strong>Deterministic Behavior</strong>: Pessimistic locking provides a clear, linear workflow: acquire lock → plan → apply → write → release. There&#39;s no need for complex retry loops or merge conflict resolution logic.</li>\n<li><strong>Adequate for Common Use Case</strong>: For many small to medium teams, serializing <code>apply</code> operations is acceptable and even desirable to prevent unexpected interactions.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li><strong>Positive</strong>: Implementation is relatively straightforward. Provides strong consistency guarantees. Lock file and heartbeat logic are reusable patterns.</li>\n<li><strong>Negative</strong>: Can cause bottlenecks if many <code>apply</code> operations are queued. Requires careful handling of process crashes to avoid stale locks (addressed via timeout+heartbeat). Not suitable for distributed workflows across multiple machines without a shared filesystem.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Pessimistic File Locking</td>\n<td>Simple to implement; strong consistency; clear workflow; good for learning</td>\n<td>Can bottleneck throughput; requires shared filesystem for team; stale lock handling needed</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Optimistic Concurrency Control</td>\n<td>Allows parallel planning; no waiting for locks; better for high concurrency</td>\n<td>Complex retry/merge logic; &quot;plan&quot; may be invalidated, wasting work; harder to debug</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Distributed Lock Service</td>\n<td>Robust for distributed teams; no shared filesystem requirement; advanced features (leases)</td>\n<td>Introduces external dependency; operational overhead; more complex to implement</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Partial Write Corrupts State File</strong></p>\n<ul>\n<li><strong>Description</strong>: If the system crashes or is killed while writing the state file (e.g., during a power loss), the file may be left with partially written JSON, making it unreadable.</li>\n<li><strong>Why It&#39;s Wrong</strong>: A corrupted state file breaks the entire system. The engine can no longer determine what resources it manages, leading to potential resource orphanage or attempted duplicate creation.</li>\n<li><strong>How to Fix</strong>: Always use the <strong>atomic rename pattern</strong> (<code>write_atomic_json</code>). Write the complete new state to a temporary file, <code>fsync</code> it, then rename it over the old state file. The rename is an atomic operation at the filesystem level. Additionally, keep a backup of the previous state file to allow manual recovery.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Stale Lock Blocks All Operations</strong></p>\n<ul>\n<li><strong>Description</strong>: A process acquires a lock and then crashes (or is killed) before releasing it. The lock file remains on disk, preventing any other process from acquiring the lock, effectively halting all deployments.</li>\n<li><strong>Why It&#39;s Wrong</strong>: This creates a single point of failure. Manual intervention (deleting the lock file) is required to resume operations, which is error-prone and may lead to concurrent applies if done incorrectly.</li>\n<li><strong>How to Fix</strong>: Implement <strong>stale lock detection</strong>. Store a timestamp in the lock file and have processes check the lock&#39;s age. If a lock is older than a configurable timeout (e.g., 30 minutes), a new process can assume the owner is dead, log a warning, and &quot;break&quot; the stale lock. Complement this with a <strong>heartbeat</strong> for long-running operations, where the lock owner periodically updates the timestamp to signal it&#39;s still alive.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Remote State Race Condition (Read-Modify-Write)</strong></p>\n<ul>\n<li><strong>Description</strong>: When using a remote backend (like S3), two processes might concurrently read the same state file (version 1). Both compute plans based on version 1. The first process applies changes and writes back state version 2. The second process, unaware of the update, applies its (now possibly invalid) changes and overwrites with a state derived from version 1, obliterating the first process&#39;s changes.</li>\n<li><strong>Why It&#39;s Wrong</strong>: This is a classic lost update problem. It can cause resource conflicts, configuration rollback, or hidden dependencies being broken.</li>\n<li><strong>How to Fix</strong>: For remote backends, you <strong>must</strong> implement optimistic concurrency control or use the remote system&#39;s locking capabilities. Use a version identifier (ETag in S3, conditional writes) in the state metadata. On write, include a condition that the remote object&#39;s version must match what was read. If the condition fails, abort and require the user to retry with the updated state. <em>Note: Our initial implementation uses local files, but this pitfall is critical for the &quot;Remote State Backend&quot; deliverable.</em></li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>A. Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Recommended)</th>\n<th>Advanced Option (Future)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>State Serialization</td>\n<td>JSON via Python&#39;s <code>json</code> module (human-readable, debuggable)</td>\n<td>Protocol Buffers or CBOR (smaller, faster, binary)</td>\n</tr>\n<tr>\n<td>Atomic File Writes</td>\n<td><code>tempfile.NamedTemporaryFile</code> + <code>os.replace</code> (Python 3.3+)</td>\n<td>Platform-specific syscalls (<code>fsync</code>, <code>rename</code>)</td>\n</tr>\n<tr>\n<td>Locking</td>\n<td>File-based lock with <code>fcntl</code> (Unix) / <code>msvcrt.locking</code> (Windows)</td>\n<td>Distributed lock via Redis/etcd API</td>\n</tr>\n<tr>\n<td>Remote Backend</td>\n<td>AWS S3 with Boto3, using versioned buckets</td>\n<td>Custom HTTP backend with auth, caching</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>iac_engine/\n├── iac_engine/\n│   ├── __init__.py\n│   ├── cli.py                      # plan_command, apply_command\n│   ├── parser/                     # Milestone 1\n│   ├── state/                      # State Manager (this component)\n│   │   ├── __init__.py\n│   │   ├── manager.py              # StateManager class (main logic)\n│   │   ├── locking.py              # LockHandle, file locking utilities\n│   │   ├── backends/               # For remote state (local, s3, http)\n│   │   │   ├── __init__.py\n│   │   │   ├── local.py\n│   │   │   └── s3.py\n│   │   └── serialization.py        # StateRecord helper methods (to/from dict)\n│   ├── planner/                    # Milestone 3\n│   ├── executor/                   # Milestone 4\n│   └── providers/                  # Milestone 4\n└── tests/\n    └── state/\n        ├── test_manager.py\n        └── test_locking.py</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code</strong></p>\n<p>Below is complete, reusable code for atomic file operations and a simple lockfile implementation. Learners should place these in <code>state/serialization.py</code> and <code>state/locking.py</code> respectively.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># iac_engine/state/serialization.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Utilities for atomic file operations and JSON serialization.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> os</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> tempfile</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> pathlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> write_atomic_json</span><span style=\"color:#E1E4E8\">(filepath: Path, data: Any) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Write JSON data to a file atomically to prevent corruption.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        filepath: The target file path.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        data: Any JSON-serializable Python object.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        OSError: If file operations fail.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        TypeError: If data is not JSON serializable.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Create a temporary file in the same directory for atomic rename</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    temp_fd, temp_path </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tempfile.mkstemp(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        prefix</span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">filepath.name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">.tmp.\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        suffix</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\".json\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        dir</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">filepath.parent,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        text</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#E1E4E8\"> os.fdopen(temp_fd, </span><span style=\"color:#9ECBFF\">'w'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> f:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            json.dump(data, f, </span><span style=\"color:#FFAB70\">indent</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            f.flush()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            os.fsync(f.fileno())  </span><span style=\"color:#6A737D\"># Force write to disk</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Atomic rename (replace if exists, works cross-platform)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        os.replace(temp_path, filepath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Clean up temp file on any error</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            os.unlink(temp_path)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> OSError</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> read_json_with_backup</span><span style=\"color:#E1E4E8\">(filepath: Path) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Read JSON file, with automatic fallback to a backup if present.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        filepath: The primary state file path.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        The parsed JSON data (typically a dict). Returns an empty dict</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        if neither the primary nor backup file exists.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        json.JSONDecodeError: If both primary and backup files contain</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            invalid JSON (after attempting to read backup).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    backup_path </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> filepath.parent </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">filepath.name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">.backup\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> path </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> [filepath, backup_path]:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> path.exists():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                with</span><span style=\"color:#79B8FF\"> open</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#9ECBFF\">'r'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> f:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    return</span><span style=\"color:#E1E4E8\"> json.load(f)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#E1E4E8\"> json.JSONDecodeError:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Log warning but try backup if available</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Warning: Corrupted JSON in </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">path</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">, trying backup...\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                continue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Neither file exists or both are corrupt</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> {}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># iac_engine/state/locking.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"File-based locking with stale lock detection and heartbeat.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> os</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> threading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> uuid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> pathlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LockHandle</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents an acquired lock.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, lock_path: Path, lock_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.lock_path </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> lock_path</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.lock_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> lock_id  </span><span style=\"color:#6A737D\"># UUID to verify we own the lock</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.heartbeat_thread: Optional[threading.Thread] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.stop_event </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> threading.Event()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> FileLock</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Manages acquisition and release of a file-based lock.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, lock_path: Path, timeout_seconds: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 300</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.lock_path </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> lock_path</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.timeout_seconds </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> timeout_seconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> acquire</span><span style=\"color:#E1E4E8\">(self, heartbeat_interval: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30</span><span style=\"color:#E1E4E8\">) -> LockHandle:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Acquire an exclusive lock, with stale lock detection.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            heartbeat_interval: How often (seconds) to refresh the lock timestamp.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            A LockHandle that must be used to release the lock.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            TimeoutError: If unable to acquire lock within timeout.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lock_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> str</span><span style=\"color:#E1E4E8\">(uuid.uuid4())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> time.time() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start_time </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.timeout_seconds:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.lock_path.exists():</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # No lock file, try to create it</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._create_lock_file(lock_id):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    handle </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> LockHandle(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.lock_path, lock_id)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                    self</span><span style=\"color:#E1E4E8\">._start_heartbeat(handle, heartbeat_interval)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    return</span><span style=\"color:#E1E4E8\"> handle</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Lock exists, check if stale</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            lock_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._read_lock_file()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> lock_data:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                lock_age </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> lock_data[</span><span style=\"color:#9ECBFF\">'timestamp'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> lock_age </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.timeout_seconds:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Warning: Breaking stale lock from </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">lock_data.get(</span><span style=\"color:#9ECBFF\">'hostname'</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Stale lock, break it and try to acquire</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                    self</span><span style=\"color:#E1E4E8\">.lock_path.unlink(</span><span style=\"color:#FFAB70\">missing_ok</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Lock is held by another active process, wait and retry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            time.sleep(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> TimeoutError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Could not acquire lock </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.lock_path</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> within timeout\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _create_lock_file</span><span style=\"color:#E1E4E8\">(self, lock_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Atomically create lock file with current process info.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            lock_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'pid'</span><span style=\"color:#E1E4E8\">: os.getpid(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'hostname'</span><span style=\"color:#E1E4E8\">: os.uname().nodename </span><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> hasattr</span><span style=\"color:#E1E4E8\">(os, </span><span style=\"color:#9ECBFF\">'uname'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">else</span><span style=\"color:#9ECBFF\"> 'unknown'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'timestamp'</span><span style=\"color:#E1E4E8\">: time.time(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'lock_id'</span><span style=\"color:#E1E4E8\">: lock_id</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Use atomic write from serialization module</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            from</span><span style=\"color:#E1E4E8\"> .serialization </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> write_atomic_json</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            write_atomic_json(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.lock_path, lock_data)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">OSError</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">IOError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _read_lock_file</span><span style=\"color:#E1E4E8\">(self) -> Optional[</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Read and parse lock file, return None if invalid/missing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            with</span><span style=\"color:#79B8FF\"> open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.lock_path, </span><span style=\"color:#9ECBFF\">'r'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> f:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> json.load(f)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">FileNotFoundError</span><span style=\"color:#E1E4E8\">, json.JSONDecodeError):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _start_heartbeat</span><span style=\"color:#E1E4E8\">(self, handle: LockHandle, interval: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Start background thread to periodically refresh lock timestamp.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        def</span><span style=\"color:#B392F0\"> heartbeat</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            while</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> handle.stop_event.wait(interval):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.lock_path.exists():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    break</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                lock_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._read_lock_file()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> lock_data </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> lock_data.get(</span><span style=\"color:#9ECBFF\">'lock_id'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> handle.lock_id:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    lock_data[</span><span style=\"color:#9ECBFF\">'timestamp'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        from</span><span style=\"color:#E1E4E8\"> .serialization </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> write_atomic_json</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        write_atomic_json(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.lock_path, lock_data)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    except</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">OSError</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">IOError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        break</span><span style=\"color:#6A737D\">  # Couldn't refresh, lock may be broken</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        handle.heartbeat_thread </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> threading.Thread(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            target</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">heartbeat,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            daemon</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            name</span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"lock-heartbeat-</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">handle.lock_id[:</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        handle.heartbeat_thread.start()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> release</span><span style=\"color:#E1E4E8\">(self, handle: LockHandle):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Release the lock represented by the handle.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> handle.heartbeat_thread:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            handle.stop_event.set()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            handle.heartbeat_thread.join(</span><span style=\"color:#FFAB70\">timeout</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Verify we still own the lock before deleting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lock_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._read_lock_file()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> lock_data </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> lock_data.get(</span><span style=\"color:#9ECBFF\">'lock_id'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> handle.lock_id:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.lock_path.unlink(</span><span style=\"color:#FFAB70\">missing_ok</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code</strong></p>\n<p>The main <code>StateManager</code> class integrates the above utilities. Learners should implement the <code>compute_diff</code> method following the algorithm outlined earlier.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># iac_engine/state/manager.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Main State Manager component.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> pathlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> asdict</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..models </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Resource, StateRecord, PlanAction, ActionType</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .locking </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> FileLock, LockHandle</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .serialization </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> write_atomic_json, read_json_with_backup</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> StateManager</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Manages persistent infrastructure state and concurrent access.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, state_path: Path):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            state_path: Path to the main state file (e.g., terraform.tfstate).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.state_path </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> state_path</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.lock_path </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> state_path.parent </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">state_path.name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">.lock\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.file_lock </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> FileLock(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.lock_path)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> read_state</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, StateRecord]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Loads the state file into memory.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Dictionary mapping resource addresses to StateRecord objects.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Returns empty dict if state file doesn't exist or is corrupt.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Use read_json_with_backup to load raw JSON from self.state_path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If result is empty dict, return empty dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Convert the raw JSON dict into a dict of StateRecord objects</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         The JSON keys are resource addresses (e.g., \"aws_instance.web\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Each value should be converted using StateRecord.from_dict()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return the dictionary of StateRecord objects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> write_state</span><span style=\"color:#E1E4E8\">(self, state_data: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, StateRecord]):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Persists the state dictionary to disk atomically.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            state_data: Dictionary mapping resource addresses to StateRecord objects.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Convert the state_data dictionary to a JSON-serializable dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Use StateRecord.to_dict() for each record</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Call write_atomic_json with self.state_path and the serialized data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: (Optional) Create a backup of the previous state file before writing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> acquire_lock</span><span style=\"color:#E1E4E8\">(self, timeout_seconds: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 300</span><span style=\"color:#E1E4E8\">) -> LockHandle:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Acquire an exclusive lock for the state.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            timeout_seconds: Maximum time to wait for lock acquisition.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            A LockHandle that MUST be passed to release_lock.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Call self.file_lock.acquire() with appropriate heartbeat interval</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Return the LockHandle</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> release_lock</span><span style=\"color:#E1E4E8\">(self, lock_handle: LockHandle):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Release a previously acquired lock.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            lock_handle: The handle returned by acquire_lock.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Call self.file_lock.release(lock_handle)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> compute_diff</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current_state: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, StateRecord],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        desired_resources: List[Resource]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, PlanAction]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Compare current state with desired resources to determine needed changes.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            current_state: Output from read_state().</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            desired_resources: List of Resource objects from the parser.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Dictionary of PlanAction objects keyed by resource address.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        actions </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Build index of desired resources by address</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        desired_index </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> resource </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> desired_resources:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            address </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.get_resource_address(resource)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            desired_index[address] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> resource</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Iterate through desired resources (desired_index)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For each desired resource, check if it exists in current_state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If NOT in current_state -> CREATE action</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - prior_state = None</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - new_state = StateRecord from resource (resource_id=\"\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If EXISTS in current_state -> compare attributes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - Use _compare_attributes() helper for deep comparison</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - If different -> UPDATE action (both states populated)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - If same -> NOOP action</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: After processing desired resources, find resources in current_state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         that are NOT in desired_index -> DELETE action</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - resource = Resource from StateRecord (type and name)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - prior_state = the StateRecord, new_state = None</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Add each action to actions dict keyed by resource address</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Return actions dict</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> actions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_resource_address</span><span style=\"color:#E1E4E8\">(self, resource: Resource) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Generate a unique address string for a resource.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            resource: A Resource object.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            String in format \"{resource.type}.{resource.name}\".</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Return f\"{resource.type}.{resource.name}\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _compare_attributes</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        desired_attrs: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">any</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current_attrs: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">any</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Deep compare resource attributes, handling provider-specific semantics.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            desired_attrs: Attributes from configuration.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            current_attrs: Attributes from cloud API (StateRecord).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            True if attributes are effectively equal, False if changes are needed.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Implement a recursive comparison that handles:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - Lists where order may not matter (e.g., security group rules)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - Ignoring read-only/computed fields (like 'arn', 'id')</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - Type coercion (string \"10\" vs integer 10)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - Nested dictionaries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Return True if equal, False if any meaningful difference found</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints (Python)</strong></p>\n<ul>\n<li>Use <code>pathlib.Path</code> for all file path operations—it&#39;s more readable and cross-platform than <code>os.path</code>.</li>\n<li>The <code>json</code> module&#39;s <code>default=str</code> parameter in <code>json.dump</code> handles non-serializable types (like <code>datetime</code>) by converting them to strings.</li>\n<li>For atomic file replacement, <code>os.replace()</code> (Python 3.3+) is the most reliable cross-platform method.</li>\n<li>When implementing the heartbeat thread, use <code>threading.Event</code> for clean shutdown rather than checking a boolean flag.</li>\n<li>In <code>_compare_attributes</code>, consider using a &quot;schema&quot; per resource type to know which fields are computed/read-only and should be ignored during diff.</li>\n</ul>\n<p><strong>F. Milestone Checkpoint</strong>\nAfter implementing the State Manager, verify its functionality:</p>\n<ol>\n<li><strong>Test Atomic Writes</strong>: Create a test that writes a state file, simulates a crash (delete temp file mid-write), and ensures the original state remains uncorrupted.</li>\n<li><strong>Test Locking</strong>: Run two Python scripts simultaneously that try to acquire the same lock. The second should wait (or timeout) until the first releases it.</li>\n<li><strong>Test Diff Logic</strong>: Write unit tests for <code>compute_diff</code> with various scenarios: new resource, changed attribute, deleted resource, identical resource (<code>NOOP</code>).</li>\n<li><strong>Integration Test</strong>: Run <code>plan_command</code> on a simple configuration. It should read state (or start with empty), compute a diff, and output a plan showing <code>CREATE</code> actions.</li>\n</ol>\n<p><strong>Expected Behavior</strong>:</p>\n<ul>\n<li>State file is created at <code>terraform.tfstate</code> after first successful apply.</li>\n<li>A lock file (<code>terraform.tfstate.lock</code>) appears during <code>plan</code>/<code>apply</code> and disappears afterward.</li>\n<li>Running <code>plan</code> twice on the same configuration (without apply) should show the same changes (idempotent diff).</li>\n</ul>\n<p><strong>Signs of Trouble</strong>:</p>\n<ul>\n<li>&quot;State file is corrupted&quot; errors: Check <code>write_atomic_json</code> is being used and temp files are cleaned up.</li>\n<li>&quot;Lock never released&quot;: Check heartbeat thread is daemon and <code>stop_event</code> is set in <code>release_lock</code>. Look for orphaned <code>.lock</code> files.</li>\n<li>&quot;Plan shows no changes when resources exist&quot;: Verify <code>compute_diff</code> attribute comparison logic, especially for nested structures.</li>\n</ul>\n<hr>\n<h2 id=\"component-design-planner-dependency-graph-amp-planning\">Component Design: Planner (Dependency Graph &amp; Planning)</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 3</p>\n</blockquote>\n<p>The <strong>Planner</strong> is the strategic brain of the IaC engine, responsible for transforming a collection of resources (from the parser) and the current state (from the state manager) into a safe, ordered execution plan. It determines <strong>what</strong> needs to change and, critically, <strong>in what order</strong> those changes must be applied to respect dependencies and avoid system failures.</p>\n<p><img src=\"/api/project/infrastructure-as-code/architecture-doc/asset?path=diagrams%2Fflowchart-graph.svg\" alt=\"Flowchart: Dependency Graph and Topological Sort\"></p>\n<h3 id=\"mental-model-the-project-manager-and-gantt-chart\">Mental Model: The Project Manager and Gantt Chart</h3>\n<p>Think of the Planner as a <strong>project manager</strong> preparing to renovate a house. The project manager receives:</p>\n<ol>\n<li><strong>The Blueprint:</strong> The desired configuration from the parser (like the architect&#39;s new plans).</li>\n<li><strong>The As-Built Drawings:</strong> The current state from the state manager (what&#39;s actually constructed today).</li>\n</ol>\n<p>The manager&#39;s job is to compare these two documents and create a <strong>detailed work plan (execution plan)</strong> for the construction crew. To do this, they must:</p>\n<ul>\n<li><strong>Identify Task Dependencies (Build the Dependency Graph):</strong> They analyze which tasks depend on others. You cannot install light fixtures until the electrical wiring is run. You cannot pour the foundation until the site is excavated. These dependencies form a <strong>Directed Acyclic Graph (DAG)</strong> of tasks. A cycle (e.g., &quot;Task A needs B, but B also needs A&quot;) indicates a planning error and must be caught.</li>\n<li><strong>Sequence the Work (Topological Sort):</strong> Using the DAG, the manager creates a <strong>Gantt chart</strong> – a linear sequence of tasks where all dependencies are satisfied before a task begins. This is the topological sort.</li>\n<li><strong>Determine Action Types (Compute the Diff):</strong> For each task (resource), the manager decides if it&#39;s a <strong>new addition (CREATE)</strong>, a <strong>modification (UPDATE)</strong>, something to be <strong>removed (DELETE)</strong>, or if it&#39;s already correct and needs <strong>no action (NOOP)</strong>.</li>\n<li><strong>Plan for Teardown (Reverse Destroy Order):</strong> If removing parts of the house, the manager knows to work in reverse: remove light fixtures <em>before</em> removing the wiring, and remove the wiring <em>before</em> removing the wall it&#39;s in. The Planner ensures <strong>destroy operations follow the reverse dependency order</strong>.</li>\n</ul>\n<p>This mental model emphasizes the Planner&#39;s core responsibilities: <strong>dependency analysis, ordering, and change calculation</strong> to produce a safe, actionable plan.</p>\n<h3 id=\"interface-and-public-methods\">Interface and Public Methods</h3>\n<p>The Planner component exposes a clean interface focused on graph construction and plan generation. Its primary client is the CLI layer when executing the <code>plan_command</code>.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Method Name</th>\n<th align=\"left\">Parameters</th>\n<th align=\"left\">Returns</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>build_graph</code></td>\n<td align=\"left\"><code>resources: List[Resource]</code>, <code>state_records: Dict[str, StateRecord]</code></td>\n<td align=\"left\"><code>Dict[str, DependencyGraphNode]</code></td>\n<td align=\"left\">Constructs a dependency graph from the provided resources and existing state. Extracts both implicit (attribute reference) and explicit (<code>depends_on</code>) dependencies. Returns a dictionary mapping resource addresses to their graph node.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>validate_acyclic</code></td>\n<td align=\"left\"><code>graph: Dict[str, DependencyGraphNode]</code></td>\n<td align=\"left\"><code>bool</code></td>\n<td align=\"left\">Validates that the dependency graph contains no cycles. Returns <code>True</code> if the graph is acyclic; raises a <code>CycleDetectionError</code> with details of the detected cycle if not.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>topological_sort</code></td>\n<td align=\"left\"><code>graph: Dict[str, DependencyGraphNode]</code></td>\n<td align=\"left\"><code>List[str]</code></td>\n<td align=\"left\">Performs a topological sort on the validated DAG. Returns an ordered list of resource addresses where each resource appears <strong>after</strong> all its dependencies.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>generate_plan</code></td>\n<td align=\"left\"><code>sorted_resources: List[str]</code>, <code>desired_resources: Dict[str, Resource]</code>, <code>current_state: Dict[str, StateRecord]</code></td>\n<td align=\"left\"><code>Dict[str, PlanAction]</code></td>\n<td align=\"left\">The core planning algorithm. Iterates through resources in topological order, comparing each desired <code>Resource</code> against its corresponding <code>StateRecord</code> to produce a <code>PlanAction</code>. Returns a dictionary of actions keyed by resource address.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>plan_command</code> <em>(CLI)</em></td>\n<td align=\"left\"><code>config_path: Path</code>, <code>state_path: Path</code>, <code>var_file: Optional[Path]</code></td>\n<td align=\"left\"><code>None</code></td>\n<td align=\"left\">The orchestrating CLI command. Calls the parser (<code>process_configuration</code>), reads state (<code>read_state</code>), calls the planner&#39;s methods (<code>build_graph</code>, <code>validate_acyclic</code>, <code>topological_sort</code>, <code>generate_plan</code>), and prints a human-readable summary of the execution plan.</td>\n</tr>\n</tbody></table>\n<h3 id=\"internal-behavior-and-algorithm\">Internal Behavior and Algorithm</h3>\n<p>The Planner&#39;s internal logic is a multi-stage pipeline. Each stage transforms data, progressively refining the raw configuration and state into a precise execution plan.</p>\n<h4 id=\"1-dependency-graph-construction-build_graph\">1. Dependency Graph Construction (<code>build_graph</code>)</h4>\n<p>This algorithm builds the <code>DependencyGraphNode</code> for each resource. A <code>DependencyGraphNode</code> tracks what a resource <strong>depends on</strong> (<code>depends_on</code>) and what <strong>depends on it</strong> (<code>required_by</code>).</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>resource_id</code></td>\n<td align=\"left\"><code>str</code></td>\n<td align=\"left\">The unique address of the resource (e.g., <code>aws_instance.web_server</code>).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>depends_on</code></td>\n<td align=\"left\"><code>List[str]</code></td>\n<td align=\"left\">List of resource addresses that <strong>this resource</strong> depends on. Populated during dependency extraction.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>required_by</code></td>\n<td align=\"left\"><code>List[str]</code></td>\n<td align=\"left\">List of resource addresses that depend on <strong>this resource</strong>. Populated as edges are added, creating the reverse link for efficient traversal.</td>\n</tr>\n</tbody></table>\n<p><strong>Algorithm Steps:</strong></p>\n<ol>\n<li><strong>Initialize Graph:</strong> Create an empty dictionary <code>graph: Dict[str, DependencyGraphNode]</code>. For each resource in <code>resources</code> and each existing resource in <code>state_records</code>, create a node with empty <code>depends_on</code> and <code>required_by</code> lists.</li>\n<li><strong>Extract Explicit Dependencies:</strong> For each resource, check for an explicit <code>depends_on</code> attribute in its <code>attributes</code> map. If present, validate that each referenced resource address exists in the combined set of desired and existing resources. For each valid reference, add the dependency to the current resource&#39;s <code>depends_on</code> list.</li>\n<li><strong>Extract Implicit Dependencies:</strong> This is the most complex step. For each resource, recursively scan all values in its <code>attributes</code> map (including nested maps and lists) for <strong>interpolation references</strong>. A reference pattern is <code>${&lt;reference&gt;}</code>. We are interested in references to other resources, which typically follow patterns like <code>${aws_security_group.my_sg.id}</code> or <code>${module.vpc.subnet_id}</code>.<ul>\n<li><strong>Parse the Reference:</strong> Extract the referenced path (e.g., <code>aws_security_group.my_sg.id</code>).</li>\n<li><strong>Resolve to Resource Address:</strong> The core of the path before the first dot (<code>.</code>) or opening bracket (<code>[</code>) is the <strong>resource address</strong> (e.g., <code>aws_security_group.my_sg</code>). You may need to handle module outputs (e.g., <code>module.vpc.subnet_id</code> resolves to a resource inside the <code>vpc</code> module). The Planner relies on the Parser having already <strong>flattened</strong> module resources and resolved their addresses to global, unique strings.</li>\n<li><strong>Add Dependency Edge:</strong> If the resolved resource address exists in the graph, add an edge from the current resource (dependent) to the referenced resource (dependency). This means adding the dependency&#39;s address to the current resource&#39;s <code>depends_on</code> list and adding the current resource&#39;s address to the dependency&#39;s <code>required_by</code> list.</li>\n</ul>\n</li>\n<li><strong>Return Graph:</strong> Return the completed <code>graph</code> dictionary.</li>\n</ol>\n<h4 id=\"2-cycle-detection-validate_acyclic\">2. Cycle Detection (<code>validate_acyclic</code>)</h4>\n<p>A cycle in the dependency graph means no valid execution order exists (e.g., Resource A needs B created first, but B needs A created first). We must detect and report this before proceeding.</p>\n<p><strong>Algorithm Steps (Kahn&#39;s Algorithm or DFS):</strong></p>\n<ol>\n<li>Use <strong>Depth-First Search (DFS)</strong> with coloring:<ul>\n<li><code>WHITE</code> = Unvisited node</li>\n<li><code>GREY</code> = Currently visiting (in the DFS stack)</li>\n<li><code>BLACK</code> = Fully processed</li>\n</ul>\n</li>\n<li>For each node in the graph, if it&#39;s <code>WHITE</code>, start a DFS.</li>\n<li>When entering a node, mark it <code>GREY</code>.</li>\n<li>For each dependency in the node&#39;s <code>depends_on</code> list:<ul>\n<li>If the dependency node is <code>GREY</code>, a cycle has been found. Construct an error message tracing the cycle path and raise a <code>CycleDetectionError</code>.</li>\n<li>If the dependency node is <code>WHITE</code>, recursively visit it.</li>\n</ul>\n</li>\n<li>After processing all dependencies, mark the node <code>BLACK</code>.</li>\n<li>If the DFS completes for all nodes without finding a <code>GREY</code> dependency, the graph is acyclic.</li>\n</ol>\n<h4 id=\"3-topological-sort-topological_sort\">3. Topological Sort (<code>topological_sort</code>)</h4>\n<p>Given an acyclic graph, we produce a linear execution order. <strong>Kahn&#39;s Algorithm</strong> is intuitive and efficient.</p>\n<p><strong>Algorithm Steps:</strong></p>\n<ol>\n<li><strong>Compute In-Degree:</strong> For each node in the graph, compute its &quot;in-degree&quot; – the count of resources that depend on it (the length of its <code>required_by</code> list). You can derive this from the <code>graph</code> structure.</li>\n<li><strong>Initialize Queue:</strong> Create a queue (or list) and add all nodes with an in-degree of <code>0</code>. These are resources with no dependencies and can be executed first.</li>\n<li><strong>Process Queue:</strong> While the queue is not empty:\na.  Remove a node <code>n</code> from the queue.\nb.  Append <code>n.resource_id</code> to the result list <code>sorted_order</code>.\nc.  For each node <code>m</code> that <code>n</code> depends on (i.e., for each node in <code>n.depends_on</code>), decrement the in-degree of <code>m</code> by <code>1</code>.\nd.  If the in-degree of <code>m</code> becomes <code>0</code>, add <code>m</code> to the queue.</li>\n<li><strong>Check for Cycles (Again):</strong> After the queue is empty, if the length of <code>sorted_order</code> is less than the total number of nodes in the graph, it indicates a cycle (though <code>validate_acyclic</code> should have caught this). This is a final sanity check.</li>\n<li><strong>Return Order:</strong> Return the <code>sorted_order</code> list.</li>\n</ol>\n<h4 id=\"4-plan-generation-generate_plan\">4. Plan Generation (<code>generate_plan</code>)</h4>\n<p>This function translates the desired state, current state, and execution order into concrete <code>PlanAction</code> objects. It must handle the four fundamental action types.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>action_type</code></td>\n<td align=\"left\"><code>ActionType</code> (Enum)</td>\n<td align=\"left\">One of: <code>CREATE</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>NOOP</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>resource</code></td>\n<td align=\"left\"><code>Resource</code></td>\n<td align=\"left\">The desired <code>Resource</code> object. For <code>DELETE</code> actions, this is the resource <em>as it exists in the current state</em> (or a placeholder).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>prior_state</code></td>\n<td align=\"left\"><code>Optional[StateRecord]</code></td>\n<td align=\"left\">The state of the resource before the action. Present for <code>UPDATE</code> and <code>DELETE</code>; <code>None</code> for <code>CREATE</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>new_state</code></td>\n<td align=\"left\"><code>Optional[StateRecord]</code></td>\n<td align=\"left\">The expected state of the resource after the action. Present for <code>CREATE</code> and <code>UPDATE</code>; <code>None</code> for <code>DELETE</code>.</td>\n</tr>\n</tbody></table>\n<p><strong>Algorithm Steps:</strong></p>\n<ol>\n<li><strong>Initialize Plan:</strong> Create an empty dictionary <code>plan: Dict[str, PlanAction]</code>.</li>\n<li><strong>Iterate in Sorted Order:</strong> Loop through each <code>resource_id</code> in the <code>sorted_resources</code> list.</li>\n<li><strong>Retrieve States:</strong> Get the <code>desired_resource</code> from <code>desired_resources</code> dict and the <code>current_record</code> from <code>current_state</code> dict for this <code>resource_id</code>. One may be <code>None</code>.</li>\n<li><strong>Determine Action Type:</strong><ul>\n<li>If <code>desired_resource</code> exists and <code>current_record</code> is <code>None</code> → <code>ActionType.CREATE</code></li>\n<li>If <code>desired_resource</code> exists and <code>current_record</code> exists → Compare their <code>attributes</code>. If any attribute differs (deep comparison), → <code>ActionType.UPDATE</code>. If identical → <code>ActionType.NOOP</code>.</li>\n<li>If <code>desired_resource</code> is <code>None</code> and <code>current_record</code> exists → <code>ActionType.DELETE</code></li>\n</ul>\n</li>\n<li><strong>Construct PlanAction:</strong><ul>\n<li>For <code>CREATE</code>: <code>action_type=CREATE</code>, <code>resource=desired_resource</code>, <code>prior_state=None</code>, <code>new_state=a StateRecord derived from desired_resource</code>.</li>\n<li>For <code>UPDATE</code>: <code>action_type=UPDATE</code>, <code>resource=desired_resource</code>, <code>prior_state=current_record</code>, <code>new_state=a StateRecord derived from desired_resource</code>.</li>\n<li>For <code>DELETE</code>: <code>action_type=DELETE</code>, <code>resource=a Resource constructed from current_record</code>, <code>prior_state=current_record</code>, <code>new_state=None</code>.</li>\n<li>For <code>NOOP</code>: <code>action_type=NOOP</code>, <code>resource=desired_resource</code>, <code>prior_state=current_record</code>, <code>new_state=current_record</code>.</li>\n</ul>\n</li>\n<li><strong>Store Action:</strong> Add the <code>PlanAction</code> to the <code>plan</code> dictionary keyed by <code>resource_id</code>.</li>\n<li><strong>Return Plan:</strong> After processing all resources, return the <code>plan</code>.</li>\n</ol>\n<blockquote>\n<p><strong>Key Design Insight:</strong> The plan is generated <strong>in dependency order</strong>, but the <code>PlanAction</code> objects themselves are stored in a dictionary for easy lookup by the Executor. The Executor will later use the same topological order (or its reverse for destroy) to sequence operations.</p>\n</blockquote>\n<h3 id=\"adr-implicit-vs-explicit-dependency-detection\">ADR: Implicit vs. Explicit Dependency Detection</h3>\n<blockquote>\n<p><strong>Decision: Implement Both Implicit and Explicit Dependency Detection</strong></p>\n<ul>\n<li><strong>Context:</strong> Resources in an IaC configuration can depend on each other in two ways: 1) <strong>Explicitly</strong> via a <code>depends_on</code> directive, and 2) <strong>Implicitly</strong> via attribute references (e.g., using another resource&#39;s ID in a configuration string). We must decide which types of dependencies the Planner will recognize to build an accurate and safe execution graph.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Explicit-Only Detection:</strong> Only process the <code>depends_on</code> attribute. This is simple and fast but fails to catch the majority of real-world dependencies expressed through interpolation, leading to runtime failures when a resource references an attribute of another resource that hasn&#39;t been created yet.</li>\n<li><strong>Implicit-Only Detection:</strong> Only parse attribute values for interpolation references. This catches the most common dependency patterns but forces users to understand the engine&#39;s reference parsing logic. It may also miss dependencies expressed through complex, indirect means not caught by the parser.</li>\n<li><strong>Hybrid Detection (Explicit + Implicit):</strong> Process both <code>depends_on</code> and interpolated references. This provides robustness and user flexibility. Explicit <code>depends_on</code> can be used to force an ordering when implicit detection fails or is unclear.</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Implement <strong>Hybrid Detection (Option 3)</strong>. The Planner will scan for and process both explicit <code>depends_on</code> directives and implicit references found in attribute values.</li>\n<li><strong>Rationale:</strong> The primary goal of the Planner is to guarantee a safe apply order. Relying solely on explicit dependencies places too much burden on the user and is error-prone. Relying solely on implicit detection is complex and may have blind spots. The hybrid approach offers a safety net: implicit detection handles the common cases automatically, while explicit <code>depends_on</code> allows users to override or clarify dependencies when necessary (e.g., for resources managed by a provider that don&#39;t expose useful attributes, or for meta-dependencies not expressed in configuration).</li>\n<li><strong>Consequences:</strong><ul>\n<li><strong>Increased Complexity:</strong> The dependency extraction logic must handle two distinct patterns and resolve interpolated strings to resource addresses. This requires a well-defined reference syntax and a robust parsing step.</li>\n<li><strong>Potential for Over-Specification:</strong> Users might add unnecessary <code>depends_on</code> statements, which clutter the config but do not cause harm.</li>\n<li><strong>Accurate Graphs:</strong> The resulting dependency graph more closely reflects the true operational dependencies of the infrastructure, leading to more reliable <code>apply</code> operations.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Option</th>\n<th align=\"left\">Pros</th>\n<th align=\"left\">Cons</th>\n<th align=\"left\">Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Explicit-Only</strong></td>\n<td align=\"left\">Simple to implement and understand.</td>\n<td align=\"left\">Fragile; misses most real dependencies, causing apply failures.</td>\n<td align=\"left\">❌</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Implicit-Only</strong></td>\n<td align=\"left\">Catches common patterns automatically; reduces config clutter.</td>\n<td align=\"left\">Complex to implement; may miss edge cases; no user override.</td>\n<td align=\"left\">❌</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Hybrid</strong></td>\n<td align=\"left\">Robust; provides safety net with user override; mirrors industry standards (Terraform).</td>\n<td align=\"left\">More complex implementation; requires parsing interpolation.</td>\n<td align=\"left\">✅</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Uncaught Circular Dependencies</strong></p>\n<ul>\n<li><strong>Description:</strong> A configuration where Resource A depends on B, and B depends on A (directly or indirectly) creates a cycle. If the cycle detection algorithm fails (e.g., only checks explicit <code>depends_on</code> but not implicit references), the topological sort will either fail silently or produce an invalid order.</li>\n<li><strong>Why it&#39;s Wrong:</strong> Applying such a plan is impossible. The engine would be stuck trying to create A before B and B before A. In practice, this can lead to infinite loops, partial applies, or corrupted state.</li>\n<li><strong>How to Fix:</strong> Implement robust cycle detection using DFS coloring on the <strong>full hybrid graph</strong>. When a cycle is detected, <strong>fail fast</strong> with a clear error message listing the resources involved in the cycle. Do not attempt to generate a plan.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Missed Implicit Dependencies from Complex Interpolation</strong></p>\n<ul>\n<li><strong>Description:</strong> The implicit reference scanner only looks for simple <code>${type.name.attr}</code> patterns. It might miss dependencies hidden within string concatenation (<code>&quot;prefix-${var.sg_id}&quot;</code>), complex functions (<code>md5(&quot;${aws_instance.a.id}-salt&quot;)</code>), or conditional logic (<code>count = var.create ? 1 : 0</code>).</li>\n<li><strong>Why it&#39;s Wrong:</strong> The execution plan will be missing critical edges. During apply, a resource may try to reference an attribute from another resource that hasn&#39;t been created yet, causing a provider API error.</li>\n<li><strong>How to Fix:</strong> 1) Document the limitation and encourage use of explicit <code>depends_on</code> for complex cases. 2) Implement a more sophisticated expression evaluator in the Parser that can resolve variable and resource references <em>statically</em> and export a list of referenced resources for the Planner. For Milestone 3, a best-effort scanner for common patterns is acceptable, with <code>depends_on</code> as the escape hatch.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Destroy Operations in Incorrect Order</strong></p>\n<ul>\n<li><strong>Description:</strong> Applying a plan that deletes resources using the same order as creation (topological sort). This tries to delete a resource (e.g., a database instance) before deleting resources that depend on it (e.g., a firewall rule pointing to that instance), which will fail because the provider API will reject the deletion of the dependent resource.</li>\n<li><strong>Why it&#39;s Wrong:</strong> Destruction must respect dependency order in <strong>reverse</strong>. The dependent resource must be removed before the resource it depends on.</li>\n<li><strong>How to Fix:</strong> When generating a plan that contains <code>DELETE</code> actions, the Executor (covered in the next section) must <strong>reverse the topological order</strong> for the destroy portion of the plan. The Planner&#39;s <code>topological_sort</code> provides the create/update order. The reverse of that order is the safe destroy order.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Component</th>\n<th align=\"left\">Simple Option (Recommended)</th>\n<th align=\"left\">Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Graph Data Structure</td>\n<td align=\"left\">Python dictionaries and lists: <code>Dict[str, DependencyGraphNode]</code>. Use <code>List[str]</code> for <code>depends_on</code> and <code>required_by</code>.</td>\n<td align=\"left\">NetworkX library for professional-grade graph algorithms and visualization.</td>\n</tr>\n<tr>\n<td align=\"left\">Cycle Detection &amp; Topological Sort</td>\n<td align=\"left\">Implement Kahn&#39;s Algorithm or DFS manually (good learning exercise).</td>\n<td align=\"left\">Use <code>networkx.is_directed_acyclic_graph</code> and <code>networkx.topological_sort</code>.</td>\n</tr>\n<tr>\n<td align=\"left\">Deep Comparison for Diffs</td>\n<td align=\"left\">Python&#39;s <code>==</code> operator with <code>json.dumps</code> serialization or recursive dictionary comparison.</td>\n<td align=\"left\">Use a library like <code>deepdiff</code> for detailed diff reporting.</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<p>Add the Planner component to the established project layout.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>iac_engine/\n├── cmd/\n│   └── cli.py              # CLI commands: `plan_command`, `apply_command`\n├── core/                   # Core data types and interfaces\n│   ├── __init__.py\n│   ├── models.py           # Resource, StateRecord, PlanAction, DependencyGraphNode, ActionType Enum\n│   └── provider.py         # BaseProvider interface\n├── parser/                 # Milestone 1\n│   └── ...\n├── state/                  # Milestone 2\n│   └── ...\n├── planner/                # Milestone 3 (THIS COMPONENT)\n│   ├── __init__.py\n│   ├── builder.py          # build_graph, dependency extraction logic\n│   ├── graph_utils.py      # validate_acyclic, topological_sort, CycleDetectionError\n│   ├── plan_generator.py   # generate_plan\n│   └── errors.py           # Planner-specific exceptions\n├── executor/               # Milestone 4\n│   └── ...\n└── providers/              # Milestone 4\n    └── ...</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p><strong>Complete <code>DependencyGraphNode</code> and <code>CycleDetectionError</code>:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># File: core/models.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ... (existing Resource, StateRecord, PlanAction definitions) ...</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ActionType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CREATE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"create\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    UPDATE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"update\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DELETE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"delete\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    NOOP</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"noop\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DependencyGraphNode</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents a node in the resource dependency DAG.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resource_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    depends_on: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    required_by: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> add_dependency</span><span style=\"color:#E1E4E8\">(self, dep_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Adds a dependency edge from this node to dep_id.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> dep_id </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.depends_on:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.depends_on.append(dep_id)</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># File: planner/errors.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CycleDetectionError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when a circular dependency is detected in the resource graph.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, cycle_path: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.cycle_path </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cycle_path</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        message </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"Circular dependency detected: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#9ECBFF\">' -> '</span><span style=\"color:#E1E4E8\">.join(cycle_path)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span></code></pre></div>\n\n<p><strong>Generic Graph Utilities Skeleton:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># File: planner/graph_utils.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> CycleDetectionError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> core.models </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> DependencyGraphNode</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_acyclic</span><span style=\"color:#E1E4E8\">(graph: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, DependencyGraphNode]) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Validates that the graph contains no cycles using DFS with coloring.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns True if acyclic, raises CycleDetectionError otherwise.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    WHITE</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">GREY</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">BLACK</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    color: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {node_id: </span><span style=\"color:#79B8FF\">WHITE</span><span style=\"color:#F97583\"> for</span><span style=\"color:#E1E4E8\"> node_id </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> graph}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stack: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> dfs</span><span style=\"color:#E1E4E8\">(node_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        color[node_id] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> GREY</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stack.append(node_id)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> dep_id </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> graph[node_id].depends_on:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> dep_id </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> color:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Dependency not in graph (maybe from a module not included). Ignore or handle.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                continue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> color[dep_id] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> GREY</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Cycle found! The cycle is from dep_id to the node_id in the stack.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                cycle_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> stack.index(dep_id)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                cycle </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> stack[cycle_start:] </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> [dep_id]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#E1E4E8\"> CycleDetectionError(cycle)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> color[dep_id] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> WHITE</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                dfs(dep_id)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stack.pop()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        color[node_id] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> BLACK</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> node_id </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> graph:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> color[node_id] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> WHITE</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            dfs(node_id)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> topological_sort</span><span style=\"color:#E1E4E8\">(graph: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, DependencyGraphNode]) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Performs a topological sort on a validated DAG using Kahn's Algorithm.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns a list of resource IDs in execution order.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    from</span><span style=\"color:#E1E4E8\"> collections </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> deque</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # 1. Compute in-degree for each node</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    in_degree: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {node_id: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#F97583\"> for</span><span style=\"color:#E1E4E8\"> node_id </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> graph}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> node </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> graph.values():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> dep_id </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> node.depends_on:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> dep_id </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> in_degree:  </span><span style=\"color:#6A737D\"># Only count dependencies present in the graph</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                in_degree[dep_id] </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # 2. Initialize queue with nodes having zero in-degree</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queue </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> deque([node_id </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> node_id, deg </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> in_degree.items() </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> deg </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sorted_order: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # 3. Process queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> queue:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        node_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> queue.popleft()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sorted_order.append(node_id)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> dep_id </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> graph[node_id].depends_on:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> dep_id </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> in_degree:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            in_degree[dep_id] </span><span style=\"color:#F97583\">-=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> in_degree[dep_id] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                queue.append(dep_id)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # 4. Check for cycles (should not happen if validate_acyclic was called)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(sorted_order) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(graph):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        missing </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> set</span><span style=\"color:#E1E4E8\">(graph.keys()) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> set</span><span style=\"color:#E1E4E8\">(sorted_order)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> CycleDetectionError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Graph has cycle(s) involving: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">missing</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> sorted_order</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong>Dependency Graph Builder:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># File: planner/builder.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> pathlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> core.models </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Resource, StateRecord, DependencyGraphNode</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Simple pattern to find interpolation references: ${...}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># This is a simplified version. A real implementation would need a proper HCL expression parser.</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">REF_PATTERN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> re.compile(</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#85E89D;font-weight:bold\">\\$\\{</span><span style=\"color:#79B8FF\">([</span><span style=\"color:#F97583\">^</span><span style=\"color:#79B8FF\">}]</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">)</span><span style=\"color:#85E89D;font-weight:bold\">\\}</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> extract_resource_address_from_ref</span><span style=\"color:#E1E4E8\">(ref: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Attempts to extract a resource address from an interpolation reference.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Example: 'aws_security_group.my_sg.id' -> 'aws_security_group.my_sg'</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">             'module.vpc.subnet_id' -> 'module.vpc' (module resources are flattened by parser)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    This is a heuristic and may need refinement.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Split by '.' and take the first two parts if it looks like a resource reference.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parts </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ref.split(</span><span style=\"color:#9ECBFF\">'.'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(parts) </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Check if the first part is a resource type or 'module'</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> parts[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">'module'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'data'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">or</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> parts[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].startswith(</span><span style=\"color:#9ECBFF\">'var'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">parts[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">parts[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # If we can't parse it, return the original ref. The caller will filter it out.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ref</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> find_references_in_value</span><span style=\"color:#E1E4E8\">(value: Any) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Recursively traverses a value (which can be dict, list, str, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    and extracts all interpolation reference strings.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    refs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(value, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        matches </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> REF_PATTERN</span><span style=\"color:#E1E4E8\">.findall(value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        refs.extend(matches)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    elif</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(value, </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> value.values():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            refs.extend(find_references_in_value(v))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    elif</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(value, </span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> item </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> value:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            refs.extend(find_references_in_value(item))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> refs</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> build_graph</span><span style=\"color:#E1E4E8\">(resources: List[Resource],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                state_records: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, StateRecord]) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, DependencyGraphNode]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Builds a dependency graph from desired resources and existing state records.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    graph: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, DependencyGraphNode] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create nodes for all resources and existing state records.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   For each resource in `resources`, create a DependencyGraphNode with resource_id = get_resource_address(resource).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   For each record in `state_records`, also create a node if one doesn't already exist.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   Add all nodes to the `graph` dict keyed by resource_id.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Process explicit dependencies (depends_on).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   For each resource in `resources`:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #       Check its attributes for a key named 'depends_on'. The value is likely a list of strings.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #       For each dependency string in that list:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #           Validate the dependency exists in the `graph`.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #           Add the dependency to the current resource's node.depends_on list.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #           Add the current resource to the dependency node's required_by list.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Process implicit dependencies (interpolation references).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   For each resource in `resources`:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #       Recursively find all interpolation references in its attributes using `find_references_in_value`.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #       For each reference found:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #           Attempt to resolve it to a resource address using `extract_resource_address_from_ref`.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #           If the resolved address exists in the `graph` and is NOT the resource itself:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #               Add an implicit dependency edge (same as step 2).</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return the completed graph.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> graph</span></span></code></pre></div>\n\n<p><strong>Plan Generator:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># File: planner/plan_generator.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> core.models </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Resource, StateRecord, PlanAction, ActionType, get_resource_address</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> generate_plan</span><span style=\"color:#E1E4E8\">(sorted_resource_ids: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                  desired_resources: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Resource],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                  current_state: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, StateRecord]) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, PlanAction]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Generates a PlanAction for each resource based on desired vs current state.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    plan: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, PlanAction] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Iterate through each resource_id in the sorted_resource_ids list.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For each resource_id, retrieve:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   desired = desired_resources.get(resource_id)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   current = current_state.get(resource_id)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Determine the action type based on the presence of desired and current.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   Use the logic described in the \"Plan Generation\" algorithm.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   For UPDATE, you need to compare attributes. A simple way is:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #       import json; is_update = json.dumps(desired.attributes) != json.dumps(current.attributes)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Construct the appropriate PlanAction object.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   Remember to set prior_state and new_state correctly for each action type.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   For CREATE, new_state should be a StateRecord created from the desired Resource.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   For DELETE, the PlanAction's 'resource' field should be derived from the current_state.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Add the PlanAction to the plan dictionary with resource_id as the key.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: After the loop, return the plan dictionary.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> plan</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ul>\n<li>Use Python&#39;s <code>@dataclass</code> decorator from the <code>dataclasses</code> module for clean model definitions like <code>DependencyGraphNode</code>. It automatically generates <code>__init__</code>, <code>__repr__</code>, and <code>__eq__</code> methods.</li>\n<li>For recursive search in <code>find_references_in_value</code>, using <code>isinstance()</code> checks for <code>dict</code>, <code>list</code>, and <code>str</code> is a straightforward approach. Be mindful of recursion depth for very large configurations.</li>\n<li>When comparing attribute dictionaries for updates, serializing to JSON with <code>json.dumps</code> and comparing strings is a simple, order-insensitive way to perform a deep equality check. For more complex comparisons (e.g., ignoring certain fields), consider using the <code>deepdiff</code> library.</li>\n<li>The <code>re</code> module is sufficient for basic interpolation pattern matching. For a production-grade parser, you would integrate with the actual expression AST from the Parser component.</li>\n</ul>\n<h2 id=\"component-design-provider-abstraction-amp-executor\">Component Design: Provider Abstraction &amp; Executor</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 4</p>\n</blockquote>\n<p>The <strong>Provider Abstraction &amp; Executor</strong> represents the &quot;muscle&quot; of the IaC engine. While previous components understand <em>what</em> needs to change, this component actually <em>makes</em> those changes by interacting with external cloud platforms through a clean plugin architecture. The <strong>Executor</strong> orchestrates the safe application of the execution plan, while the <strong>Provider Abstraction</strong> defines the uniform interface that all cloud-specific implementations must follow.</p>\n<h3 id=\"mental-model-the-universal-remote-control\">Mental Model: The Universal Remote Control</h3>\n<p>Imagine you have a universal remote control that can operate any brand of TV. The remote has a standard set of buttons: Power, Volume Up/Down, Channel Change. However, each TV manufacturer requires different infrared codes to execute these same actions. The universal remote solves this by having a collection of &quot;device codes&quot; – each code translates the standard button press into the specific signals that a particular TV model understands.</p>\n<p>In this analogy:</p>\n<ul>\n<li>The <strong><code>BaseProvider</code> interface</strong> is the standard set of buttons (CRUD operations) that every remote must have.</li>\n<li>Each <strong>provider implementation</strong> (AWS, Azure, GCP) is a specific device code that translates those standard operations into the exact HTTP API calls, authentication mechanisms, and error handling for that cloud.</li>\n<li>The <strong>Executor</strong> is the person holding the remote, who knows <em>when</em> to press which buttons and in what order, based on the execution plan (the &quot;channel guide&quot;).</li>\n</ul>\n<p>This separation achieves <strong>polymorphism</strong>: the Executor can orchestrate infrastructure changes without knowing the details of any specific cloud API. When we need to support a new cloud, we simply add a new &quot;device code&quot; (provider implementation) without modifying the orchestration logic.</p>\n<h3 id=\"interface-and-public-methods\">Interface and Public Methods</h3>\n<p>The Provider Abstraction is defined by a Python abstract base class (ABC) that all concrete providers must implement. The Executor is a separate class that consumes this interface to apply changes.</p>\n<h4 id=\"baseprovider-interface\">BaseProvider Interface</h4>\n<p>All providers must implement these CRUD lifecycle methods plus configuration validation.</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>create</code></td>\n<td><code>resource: Resource</code></td>\n<td><code>Resource</code></td>\n<td>Creates a new cloud resource. Takes a <code>Resource</code> with desired attributes, calls the cloud API, and returns a <code>Resource</code> populated with the actual created resource&#39;s attributes (including its cloud-assigned ID). Must be idempotent.</td>\n</tr>\n<tr>\n<td><code>read</code></td>\n<td><code>resource_id: str, resource_type: str</code></td>\n<td><code>Optional[Resource]</code></td>\n<td>Reads the current state of a resource from the cloud API using its unique identifier. Returns a <code>Resource</code> if the resource exists, or <code>None</code> if it does not. Used for state refresh and validation.</td>\n</tr>\n<tr>\n<td><code>update</code></td>\n<td><code>resource_id: str, resource: Resource</code></td>\n<td><code>Resource</code></td>\n<td>Updates an existing cloud resource. Compares current attributes (from <code>read</code>) with desired attributes, makes necessary API calls, and returns the updated <code>Resource</code>. Must handle partial updates and be idempotent.</td>\n</tr>\n<tr>\n<td><code>delete</code></td>\n<td><code>resource_id: str, resource_type: str</code></td>\n<td><code>bool</code></td>\n<td>Deletes a cloud resource. Returns <code>True</code> if deletion succeeded or the resource was already absent, <code>False</code> on unrecoverable failure. Must be idempotent (deleting a non-existent resource is a success).</td>\n</tr>\n<tr>\n<td><code>validate_credentials</code></td>\n<td><code>config: dict</code></td>\n<td><code>bool</code></td>\n<td>Validates that the provider configuration (credentials, region, etc.) is correct and can authenticate with the cloud API. Returns <code>True</code> on success, raises a descriptive exception on failure.</td>\n</tr>\n<tr>\n<td><code>get_schema</code></td>\n<td><code>resource_type: str</code></td>\n<td><code>dict</code></td>\n<td>(Optional) Returns the attribute schema for a given resource type, used for validation. Includes required vs. optional fields, data types, and allowed values.</td>\n</tr>\n</tbody></table>\n<h4 id=\"executor-class\">Executor Class</h4>\n<p>The Executor applies a plan by calling provider methods in the correct order, with safety mechanisms.</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>apply_plan</code></td>\n<td><code>plan: Dict[str, PlanAction], providers: Dict[str, BaseProvider], max_concurrency: int = 1</code></td>\n<td><code>Dict[str, ApplyResult]</code></td>\n<td>Main entry point. Applies the execution plan using the provided provider instances. Respects dependency ordering (plan already topologically sorted). Supports limited concurrency for independent resources. Returns a dictionary mapping resource addresses to <code>ApplyResult</code> objects (success/failure, new state, errors).</td>\n</tr>\n<tr>\n<td><code>refresh_state</code></td>\n<td><code>resource: Resource, provider: BaseProvider</code></td>\n<td><code>Optional[Resource]</code></td>\n<td>Helper method that calls <code>provider.read</code> to get the current cloud state of a single resource. Used before updates and after creates to populate the state file with accurate attributes.</td>\n</tr>\n<tr>\n<td><code>_execute_action</code></td>\n<td><code>action: PlanAction, provider: BaseProvider</code></td>\n<td><code>ApplyResult</code></td>\n<td>Internal method that executes a single <code>PlanAction</code> (CREATE, UPDATE, DELETE) by calling the corresponding provider method. Wraps the call with retry logic, timeout, and error handling.</td>\n</tr>\n</tbody></table>\n<p><strong>Supporting Data Structures:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Type Name</th>\n<th>Fields</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ApplyResult</code></td>\n<td><code>resource_address: str</code>, <code>success: bool</code>, <code>new_state: Optional[Resource]</code>, <code>error: Optional[str]</code>, <code>retries: int</code></td>\n<td>Captures the outcome of applying a single <code>PlanAction</code>. Used to report success/failure back to the Executor and ultimately the user.</td>\n</tr>\n<tr>\n<td><code>ProviderConfig</code></td>\n<td><code>provider_type: str</code>, <code>config: dict</code></td>\n<td>Holder for provider-specific configuration (e.g., AWS region, access keys). Loaded from configuration files and passed to provider factory functions.</td>\n</tr>\n</tbody></table>\n<h3 id=\"internal-behavior-and-algorithm\">Internal Behavior and Algorithm</h3>\n<p>The Executor&#39;s primary algorithm is the <code>apply_plan</code> method, which transforms a set of planned actions into actual cloud resources. The algorithm must be robust to partial failures, API rate limits, and eventual consistency.</p>\n<h4 id=\"algorithm-executing-an-infrastructure-plan\">Algorithm: Executing an Infrastructure Plan</h4>\n<ol>\n<li><p><strong>Input Validation &amp; Setup</strong></p>\n<ul>\n<li>Verify that for every <code>PlanAction</code> in the plan, a corresponding <code>BaseProvider</code> instance exists in the <code>providers</code> dictionary (keyed by provider type, e.g., &quot;aws&quot;).</li>\n<li>Initialize an empty results dictionary to track <code>ApplyResult</code> for each resource.</li>\n<li>If <code>max_concurrency &gt; 1</code>, initialize a thread pool or async task queue. For simplicity, our reference implementation will use sequential execution (<code>max_concurrency = 1</code>).</li>\n</ul>\n</li>\n<li><p><strong>Sequential Execution Following Topological Order</strong></p>\n<ul>\n<li>The <code>plan</code> dictionary is assumed to be already ordered by the Planner via topological sort (keys are resource addresses in execution order).</li>\n<li>For each resource address in the sorted order:\na. Retrieve the <code>PlanAction</code> for this resource.\nb. Retrieve the appropriate <code>BaseProvider</code> instance based on the resource&#39;s type (e.g., &quot;aws_instance&quot; → &quot;aws&quot; provider).\nc. Call <code>_execute_action(action, provider)</code>.\nd. Store the resulting <code>ApplyResult</code> in the results dictionary.\ne. <strong>Critical: Update In-Memory State Immediately.</strong> If the action succeeded, update an in-memory copy of the state with the <code>new_state</code> from the result. This ensures subsequent actions that depend on this resource see the updated state (e.g., a created resource&#39;s ID for reference).</li>\n</ul>\n</li>\n<li><p><strong>Single Action Execution (<code>_execute_action</code>)</strong>\nFor a given <code>PlanAction</code> and <code>BaseProvider</code>:</p>\n<ol>\n<li>Determine the operation from <code>action.action_type</code>:<ul>\n<li><code>ActionType.CREATE</code>:<ul>\n<li>Call <code>provider.create(action.resource)</code> with retry logic (see ADR below).</li>\n<li>After successful creation, call <code>provider.read</code> to refresh and capture all server-generated attributes (e.g., cloud IDs, timestamps).</li>\n<li>Return an <code>ApplyResult</code> with <code>success=True</code> and the refreshed resource as <code>new_state</code>.</li>\n</ul>\n</li>\n<li><code>ActionType.UPDATE</code>:<ul>\n<li>First, call <code>provider.read</code> to get the current actual state from the cloud.</li>\n<li>Compare attributes with <code>action.resource</code> to compute the minimal update delta (some providers require full replacement).</li>\n<li>Call <code>provider.update(resource_id, action.resource)</code> with retry logic.</li>\n<li>Call <code>provider.read</code> again to refresh state.</li>\n<li>Return <code>ApplyResult</code> with the refreshed resource.</li>\n</ul>\n</li>\n<li><code>ActionType.DELETE</code>:<ul>\n<li>Call <code>provider.delete(resource_id, resource_type)</code> with retry logic.</li>\n<li>Verify deletion by calling <code>provider.read</code>; it should return <code>None</code>.</li>\n<li>Return <code>ApplyResult</code> with <code>success=True</code> and <code>new_state=None</code>.</li>\n</ul>\n</li>\n<li><code>ActionType.NOOP</code>: Return a successful <code>ApplyResult</code> with the existing state.</li>\n</ul>\n</li>\n<li><strong>Retry &amp; Error Handling Wrapper:</strong><ul>\n<li>Wrap each provider call in a retry decorator implementing exponential backoff with jitter.</li>\n<li>Catch transient errors (network timeouts, rate limit exceedances, 5xx status codes) and retry.</li>\n<li>On permanent errors (invalid credentials, unsupported resource type, validation errors), fail immediately and return an <code>ApplyResult</code> with <code>success=False</code> and the error message.</li>\n</ul>\n</li>\n<li><strong>Timeout Protection:</strong><ul>\n<li>Each provider call should have a configurable timeout (e.g., 300 seconds for long operations).</li>\n<li>If a timeout occurs, treat it as a transient error and retry (up to the retry limit).</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p><strong>Post-Application State Persistence</strong></p>\n<ul>\n<li>After all actions are completed (or upon early failure if we decide to stop), the Executor returns the results dictionary to the caller (typically the CLI).</li>\n<li>The caller (CLI) is responsible for writing the updated in-memory state to the state file using <code>write_state</code>, but only if the overall apply was successful (or partially successful with a flag to save). This ensures the state file only reflects changes that actually occurred.</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p><strong>Key Insight:</strong> The Executor must update its internal state representation <em>immediately</em> after each successful action, not just at the very end. This is because subsequent resources in the dependency order may reference attributes (like an ID) of a resource just created. If we don&#39;t update the internal view, those references would be pointing to stale or non-existent data.</p>\n</blockquote>\n<h4 id=\"state-machine-resource-lifecycle-during-apply\">State Machine: Resource Lifecycle During Apply</h4>\n<p>The following table describes the states a resource transitions through during the <code>apply_plan</code> operation, corresponding to the <img src=\"/api/project/infrastructure-as-code/architecture-doc/asset?path=diagrams%2Fstate-machine-resource.svg\" alt=\"State Machine: Resource Lifecycle\"> diagram.</p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Event</th>\n<th>Next State</th>\n<th>Action Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Pending</td>\n<td><code>execute_action</code> called (CREATE)</td>\n<td>Creating</td>\n<td>Call <code>provider.create</code> with retry wrapper; start timeout timer.</td>\n</tr>\n<tr>\n<td>Creating</td>\n<td><code>provider.create</code> succeeds</td>\n<td>Created</td>\n<td>Call <code>provider.read</code> to refresh; store new state in memory; mark success.</td>\n</tr>\n<tr>\n<td>Creating</td>\n<td><code>provider.create</code> fails (permanent error)</td>\n<td>Error</td>\n<td>Store error in <code>ApplyResult</code>; do not update in-memory state.</td>\n</tr>\n<tr>\n<td>Creating</td>\n<td>Timeout or transient error (with retries exhausted)</td>\n<td>Error</td>\n<td>Store timeout/error; do not update state.</td>\n</tr>\n<tr>\n<td>Pending</td>\n<td><code>execute_action</code> called (UPDATE)</td>\n<td>Updating</td>\n<td>Call <code>provider.read</code> → <code>provider.update</code> with retry wrapper.</td>\n</tr>\n<tr>\n<td>Updating</td>\n<td><code>provider.update</code> succeeds</td>\n<td>Created</td>\n<td>Call <code>provider.read</code> to refresh; update in-memory state.</td>\n</tr>\n<tr>\n<td>Updating</td>\n<td><code>provider.update</code> fails or timeout</td>\n<td>Error</td>\n<td>Store error; keep prior state in memory.</td>\n</tr>\n<tr>\n<td>Pending</td>\n<td><code>execute_action</code> called (DELETE)</td>\n<td>Deleting</td>\n<td>Call <code>provider.delete</code> with retry wrapper; verify with <code>provider.read</code>.</td>\n</tr>\n<tr>\n<td>Deleting</td>\n<td><code>provider.delete</code> succeeds (resource gone)</td>\n<td>Deleted</td>\n<td>Remove resource from in-memory state; mark success.</td>\n</tr>\n<tr>\n<td>Deleting</td>\n<td><code>provider.delete</code> fails (permanent)</td>\n<td>Error</td>\n<td>Store error; resource remains in state (manual intervention needed).</td>\n</tr>\n<tr>\n<td>Any state</td>\n<td>User interrupt (Ctrl+C)</td>\n<td>Interrupted</td>\n<td>Attempt graceful cancellation of ongoing API call; mark as interrupted.</td>\n</tr>\n</tbody></table>\n<h3 id=\"adr-retry-logic-strategy\">ADR: Retry Logic Strategy</h3>\n<blockquote>\n<p><strong>Decision: Exponential Backoff with Jitter for Transient Failures</strong></p>\n</blockquote>\n<ul>\n<li><p><strong>Context</strong>: Cloud APIs are distributed systems that experience transient failures: network timeouts, rate limiting (429), internal server errors (5xx), and eventual consistency delays. The IaC engine must be resilient to these temporary issues without requiring user intervention, while also avoiding retry storms that exacerbate problems.</p>\n</li>\n<li><p><strong>Options Considered</strong>:</p>\n<ol>\n<li><strong>No retries</strong> – Fail immediately on any error. Simplest to implement but not resilient, leading to frequent apply failures from transient issues.</li>\n<li><strong>Fixed-interval retries</strong> – Retry a fixed number of times with a constant delay (e.g., 5 seconds). Better than no retries, but can create synchronized retry bursts that overwhelm recovering services.</li>\n<li><strong>Exponential backoff with jitter</strong> – Increase wait times exponentially between retries (e.g., 1s, 2s, 4s, 8s) and add random variation (jitter) to spread retry attempts across time.</li>\n</ol>\n</li>\n<li><p><strong>Decision</strong>: Implement <strong>exponential backoff with jitter</strong> as the default retry strategy for all provider API calls.</p>\n</li>\n<li><p><strong>Rationale</strong>:</p>\n<ul>\n<li>Exponential backoff respects the cloud provider&#39;s potential overload by progressively reducing retry pressure, aligning with the TCP congestion control principle.</li>\n<li>Jitter (randomization) prevents thundering herd problems where many failed requests all retry at the same time, which is especially important in multi-tenant or parallel apply scenarios.</li>\n<li>This pattern is a well-established best practice for distributed system clients (AWS SDKs, Google Cloud libraries, and Terraform itself use it).</li>\n<li>The additional implementation complexity is modest (a decorator or wrapper function) and pays off in dramatically improved robustness.</li>\n</ul>\n</li>\n<li><p><strong>Consequences</strong>:</p>\n<ul>\n<li><strong>Positive</strong>: The IaC engine becomes significantly more resilient to transient cloud issues without user intervention.</li>\n<li><strong>Positive</strong>: Retry logic is centralized in one place (the Executor&#39;s wrapper), ensuring consistent behavior across all providers.</li>\n<li><strong>Negative</strong>: Apply operations may take longer to complete when retries occur (but this is preferable to failure).</li>\n<li><strong>Negative</strong>: Requires careful configuration of maximum retry attempts and maximum delay to avoid excessively long hangs (e.g., cap total retry time at 5-10 minutes).</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>No retries</td>\n<td>Simple; fails fast</td>\n<td>Not resilient; frequent user intervention needed</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Fixed-interval retries</td>\n<td>Some resilience; simple</td>\n<td>Can cause retry synchronization; not adaptive</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Exponential backoff with jitter</td>\n<td>Highly resilient; avoids retry storms; industry standard</td>\n<td>Slightly more complex to implement</td>\n<td><strong>Yes</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Rate Limit Ignorance Leads to Global API Ban</strong></p>\n<ul>\n<li><strong>Description</strong>: Implementing retries without respect to cloud API rate limits (e.g., AWS throttling) can cause the provider to temporarily ban your account&#39;s API key if you send too many requests too quickly.</li>\n<li><strong>Why it&#39;s wrong</strong>: The retry logic itself becomes a denial-of-service attack on the cloud API, triggering stricter rate limits or temporary suspensions.</li>\n<li><strong>Fix</strong>: Always inspect error responses for rate limit headers (e.g., <code>Retry-After</code>, <code>X-RateLimit-Reset</code>). When a 429 (Too Many Requests) is received, extract the recommended wait time and honor it. Additionally, implement client-side rate limiting (token bucket) for each provider to stay below known limits.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Read-After-Create Race with Eventual Consistency</strong></p>\n<ul>\n<li><strong>Description</strong>: After a <code>create</code> call returns successfully, immediately calling <code>read</code> to refresh state might return a 404 (Not Found) because the cloud&#39;s internal consistency model hasn&#39;t propagated the resource existence to all regions or servers.</li>\n<li><strong>Why it&#39;s wrong</strong>: The Executor may incorrectly assume the create failed, or may populate the state file with incomplete data, causing downstream errors.</li>\n<li><strong>Fix</strong>: In the <code>create</code> flow, wrap the post-creation <code>read</code> call in its own retry loop with a short delay, specifically handling 404s as transient errors for a limited time (e.g., up to 30 seconds). This is separate from the general retry logic for the <code>create</code> itself.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Zombie Resources from Partial Apply Failures</strong></p>\n<ul>\n<li><strong>Description</strong>: If the <code>apply_plan</code> fails halfway through (e.g., network partition), some resources may have been created in the cloud but not recorded in the updated state file because the overall apply wasn&#39;t committed.</li>\n<li><strong>Why it&#39;s wrong</strong>: On the next plan, the engine sees a discrepancy: the cloud has resources the state file doesn&#39;t know about, leading to confusion (should they be imported or deleted?). This is a form of state drift.</li>\n<li><strong>Fix</strong>: Implement a two-phase approach: 1) Perform all operations, collecting results, but don&#39;t persist state yet. 2) If <em>any</em> operation failed critically, attempt to roll back created resources (in reverse dependency order) before returning. If rollback succeeds, state remains unchanged. If rollback fails, alert the user about orphaned resources that require manual cleanup. For simplicity in the learning project, we may accept this risk and document it, requiring manual <code>import</code> for orphaned resources.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Assuming Idempotency Without Validation</strong></p>\n<ul>\n<li><strong>Description</strong>: Assuming that a cloud API&#39;s <code>delete</code> operation is idempotent (returns success for a non-existent resource) without verifying it, leading to errors when a provider behaves differently.</li>\n<li><strong>Why it&#39;s wrong</strong>: Not all cloud APIs are perfectly idempotent. Some may return 404 on delete of a non-existent resource, which should be treated as success but might be flagged as an error by naive error detection.</li>\n<li><strong>Fix</strong>: In the <code>delete</code> implementation, catch specific &quot;not found&quot; error codes and treat them as success. Document idempotency expectations as part of the <code>BaseProvider</code> contract, and test each provider implementation to ensure they comply.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"a-technology-recommendations\">A. Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Provider Interface</td>\n<td>Python <code>abc.ABC</code> with abstract methods</td>\n<td>Protocol classes (structural subtyping) with <code>typing.Protocol</code></td>\n</tr>\n<tr>\n<td>HTTP Client for Cloud APIs</td>\n<td><code>requests</code> library with session management</td>\n<td><code>httpx</code> with async/await support for concurrent operations</td>\n</tr>\n<tr>\n<td>Retry Logic</td>\n<td>Custom decorator with <code>time.sleep</code></td>\n<td><code>tenacity</code> library (rich feature set) or <code>backoff</code></td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>JSON/YAML files via <code>pyyaml</code></td>\n<td>Dynamic loading with environment variable interpolation</td>\n</tr>\n<tr>\n<td>Concurrency</td>\n<td>Sequential execution (simpler)</td>\n<td><code>concurrent.futures.ThreadPoolExecutor</code> for parallel independent resources</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>iac_engine/\n├── providers/               # Provider abstraction and implementations\n│   ├── __init__.py\n│   ├── base.py             # BaseProvider abstract class, ProviderConfig\n│   ├── aws/                # AWS-specific provider\n│   │   ├── __init__.py\n│   │   ├── provider.py     # AWSProvider class\n│   │   └── resources/      # Resource-specific modules (ec2, s3, etc.)\n│   ├── azure/              # Azure provider (similar structure)\n│   └── mock/               # Mock provider for testing\n├── executor.py             # Executor class, ApplyResult\n├── retry.py                # Retry decorator utility\n├── state_manager.py        # (From Milestone 2)\n├── planner.py              # (From Milestone 3)\n└── cli.py                  # CLI commands (plan_command, apply_command)</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p><strong>Complete Retry Decorator (<code>retry.py</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> random</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Callable, Any, Type, Tuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> functools </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> wraps</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> retry_with_backoff</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_retries: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    base_delay: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_delay: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30.0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    jitter: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    retry_on_exceptions: Tuple[Type[</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">...</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">,)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Decorator that retries a function with exponential backoff and jitter.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        max_retries: Maximum number of retry attempts (total calls = max_retries + 1)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        base_delay: Base delay in seconds for exponential backoff (e.g., 1.0 for 1s, 2s, 4s...)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        max_delay: Maximum delay between retries in seconds</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        jitter: If True, add random jitter to avoid thundering herd</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        retry_on_exceptions: Tuple of exception types to retry on (others will propagate immediately)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> decorator</span><span style=\"color:#E1E4E8\">(func: Callable) -> Callable:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        @wraps</span><span style=\"color:#E1E4E8\">(func)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        def</span><span style=\"color:#B392F0\"> wrapper</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            retries </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            while</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    return</span><span style=\"color:#E1E4E8\"> func(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                except</span><span style=\"color:#E1E4E8\"> retry_on_exceptions </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    retries </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#E1E4E8\"> retries </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> max_retries:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        raise</span><span style=\"color:#6A737D\">  # Re-raise the last exception after exhausting retries</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Calculate delay with exponential backoff</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    delay </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> min</span><span style=\"color:#E1E4E8\">(base_delay </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\"> **</span><span style=\"color:#E1E4E8\"> (retries </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)), max_delay)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Add jitter (randomize between 0.5*delay and 1.5*delay)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#E1E4E8\"> jitter:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        delay </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> delay </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">0.5</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> random.random())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Wait before retrying</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    time.sleep(delay)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> wrapper</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> decorator</span></span></code></pre></div>\n\n<p><strong>Mock Provider for Testing (<code>providers/mock/provider.py</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..base </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> BaseProvider, Resource</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MockProvider</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">BaseProvider</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Mock provider that stores resources in memory for testing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, config: </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.config </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> config</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.resources: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Resource] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}  </span><span style=\"color:#6A737D\"># resource_id -> Resource</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_credentials</span><span style=\"color:#E1E4E8\">(self, config: </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#6A737D\">  # Mock always validates</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create</span><span style=\"color:#E1E4E8\">(self, resource: Resource) -> Resource:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Generate a mock ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        resource.attributes[</span><span style=\"color:#9ECBFF\">\"id\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"mock-</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">resource.type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">-</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">resource.name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        resource_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> resource.attributes[</span><span style=\"color:#9ECBFF\">\"id\"</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Store in memory</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.resources[resource_id] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> resource</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> resource</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> read</span><span style=\"color:#E1E4E8\">(self, resource_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, resource_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[Resource]:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.resources.get(resource_id)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> update</span><span style=\"color:#E1E4E8\">(self, resource_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, resource: Resource) -> Resource:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> resource_id </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.resources:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Resource </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">resource_id</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> not found\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Update attributes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.resources[resource_id]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current.attributes.update(resource.attributes)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> current</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> delete</span><span style=\"color:#E1E4E8\">(self, resource_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, resource_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> resource_id </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.resources:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            del</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.resources[resource_id]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#6A737D\">  # Idempotent: deleting non-existent is success</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong>BaseProvider Abstract Class (<code>providers/base.py</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> abc </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> ABC</span><span style=\"color:#E1E4E8\">, abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Resource  </span><span style=\"color:#6A737D\"># Assuming Resource is defined elsewhere</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ProviderConfig</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    provider_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # e.g., \"aws\", \"azure\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]  </span><span style=\"color:#6A737D\"># provider-specific configuration</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BaseProvider</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">ABC</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Abstract base class that all cloud providers must implement.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_credentials</span><span style=\"color:#E1E4E8\">(self, config: </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Validate that the provider configuration is correct.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            True if credentials are valid, raises an exception otherwise.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create</span><span style=\"color:#E1E4E8\">(self, resource: Resource) -> Resource:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Create a new resource in the cloud.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            resource: Resource object with desired attributes.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Resource object with actual created attributes (including ID).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ProviderError: If creation fails permanently.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> read</span><span style=\"color:#E1E4E8\">(self, resource_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, resource_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[Resource]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Read the current state of a resource from the cloud.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            resource_id: Unique identifier of the resource in the cloud.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            resource_type: Type of the resource (e.g., 'aws_instance').</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Resource object if found, None if the resource does not exist.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> update</span><span style=\"color:#E1E4E8\">(self, resource_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, resource: Resource) -> Resource:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Update an existing resource in the cloud.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            resource_id: Unique identifier of the resource to update.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            resource: Resource object with desired attributes.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Updated Resource object with actual attributes.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> delete</span><span style=\"color:#E1E4E8\">(self, resource_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, resource_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Delete a resource from the cloud.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            resource_id: Unique identifier of the resource to delete.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            resource_type: Type of the resource.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            True if deletion succeeded or resource was already absent.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            False on unrecoverable failure.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Executor Class (<code>executor.py</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .retry </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> retry_with_backoff</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> PlanAction, ActionType, Resource</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .providers.base </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> BaseProvider</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ApplyResult</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resource_address: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    success: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_state: Optional[Resource]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    error: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    retries: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Executor</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Orchestrates the application of an execution plan using providers.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, max_concurrency: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.max_concurrency </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> max_concurrency</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._state_snapshot: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Resource] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}  </span><span style=\"color:#6A737D\"># In-memory state during apply</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> apply_plan</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        plan: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, PlanAction],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        providers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, BaseProvider],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        state_before: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Resource]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, ApplyResult]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Apply the execution plan to reach desired infrastructure state.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            plan: Dictionary mapping resource addresses to PlanAction objects.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                 Assumed to be topologically sorted by the Planner.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            providers: Dictionary mapping provider type strings to BaseProvider instances.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            state_before: The state as it was before apply (from state file).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Dictionary mapping resource addresses to ApplyResult objects.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        results </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize in-memory state snapshot with state_before</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Iterate through plan items in order (already sorted by dependencies)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For each PlanAction, extract provider type from resource.type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Get the appropriate provider from providers dictionary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Call _execute_action(action, provider)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: If action succeeded, update in-memory state snapshot with new_state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Store result in results dictionary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: If any action failed critically, consider stopping early (optional)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Return results dictionary</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> results</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _execute_action</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        action: PlanAction,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        provider: BaseProvider</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> ApplyResult:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Execute a single PlanAction with retry logic and error handling.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            action: The PlanAction to execute.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            provider: The provider instance to use.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ApplyResult indicating success/failure.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        resource_address </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">action.resource.type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">action.resource.name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        @retry_with_backoff</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">max_retries</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">base_delay</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        def</span><span style=\"color:#B392F0\"> _call_with_retry</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Based on action.action_type, call appropriate provider method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            #   - CREATE: provider.create(action.resource)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            #   - UPDATE: provider.read() then provider.update()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            #   - DELETE: provider.delete()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            #   - NOOP: return existing state (from prior_state or read)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For CREATE and UPDATE, call provider.read() after to refresh state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return the resulting Resource (or None for DELETE)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Call _call_with_retry() and capture result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return ApplyResult with success=True and new_state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Handle specific exception types:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            #   - Transient errors (network, rate limit): should have been retried</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            #   - Permanent errors: capture in ApplyResult with success=False</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Return ApplyResult with success=False and error message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span></code></pre></div>\n\n<p><strong>Sample AWS Provider Skeleton (<code>providers/aws/provider.py</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> boto3</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..base </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> BaseProvider</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ...data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Resource</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AWSProvider</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">BaseProvider</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"AWS cloud provider implementation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, config: </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.config </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> config</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.session </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> boto3.Session(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            aws_access_key_id</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">config.get(</span><span style=\"color:#9ECBFF\">\"access_key\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            aws_secret_access_key</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">config.get(</span><span style=\"color:#9ECBFF\">\"secret_key\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            region_name</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">config.get(</span><span style=\"color:#9ECBFF\">\"region\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"us-east-1\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Initialize service clients (ec2, s3, etc.) as needed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_credentials</span><span style=\"color:#E1E4E8\">(self, config: </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Attempt a lightweight API call (e.g., sts:GetCallerIdentity)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Return True if successful, raise exception with details if not</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create</span><span style=\"color:#E1E4E8\">(self, resource: Resource) -> Resource:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        resource_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> resource.type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Dispatch to appropriate resource-specific create method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Example: if resource_type == \"aws_instance\": return self._create_ec2_instance(resource)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Extract parameters from resource.attributes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Call AWS API (e.g., ec2.run_instances)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Extract cloud-assigned ID from response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return updated Resource with ID and other attributes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> read</span><span style=\"color:#E1E4E8\">(self, resource_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, resource_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[Resource]:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Parse resource_type to determine AWS service and method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Call appropriate describe/GET API</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If resource exists, map API response to Resource attributes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If resource not found (404/InvalidParameter), return None</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Similar skeletons for update() and delete()</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ul>\n<li><strong>Abstract Base Classes</strong>: Use Python&#39;s <code>abc</code> module to define <code>BaseProvider</code>. Decorate methods with <code>@abstractmethod</code> to enforce implementation in subclasses.</li>\n<li><strong>Error Handling</strong>: Define a custom exception hierarchy: <code>ProviderError</code> as base, with subclasses like <code>TransientProviderError</code> (retryable) and <code>PermanentProviderError</code>.</li>\n<li><strong>Type Hints</strong>: Use <code>typing</code> module extensively for better IDE support and documentation (e.g., <code>Optional[Resource]</code>, <code>Dict[str, BaseProvider]</code>).</li>\n<li><strong>Configuration Management</strong>: Use <code>pydantic</code> for validation if advanced configuration schemas are needed, but simple <code>dict</code> is acceptable for the learning project.</li>\n<li><strong>Dependency Injection</strong>: Pass provider instances to the Executor rather than having it instantiate them. This makes testing easier (you can pass mock providers).</li>\n</ul>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p>To verify Milestone 4 (Provider Abstraction &amp; Executor) is complete:</p>\n<ol>\n<li><strong>Create a test configuration</strong> with a simple resource (e.g., a mock &quot;file&quot; resource that creates a local file).</li>\n<li><strong>Run the plan command</strong>: <code>python cli.py plan config.yaml</code>. It should show a plan to create the resource.</li>\n<li><strong>Apply the plan</strong>: <code>python cli.py apply config.yaml --auto-approve</code>. The console should output:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   Applying plan...\n   file.example: Creating... (success after 0.2s)\n   Apply complete! Resources: 1 added, 0 changed, 0 destroyed.</code></pre></div>\n<ol start=\"4\">\n<li><strong>Verify the resource was created</strong>: Check that the mock resource (e.g., a file on disk) exists with the expected attributes.</li>\n<li><strong>Run plan again</strong>: Should show &quot;No changes&quot; because the state matches the configuration.</li>\n<li><strong>Test error handling</strong>: Temporarily break the provider&#39;s credentials or network connection and verify that appropriate error messages are shown (not stack traces).</li>\n</ol>\n<p><strong>Expected Behavior</strong>: The Executor calls provider methods in dependency order, respects retry logic, updates the state file upon successful completion, and provides clear feedback about what succeeded or failed.</p>\n<h2 id=\"interactions-and-data-flow\">Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 3, 4</p>\n</blockquote>\n<p>This section describes the orchestration between components for the two primary workflows in the IaC engine: generating an execution plan (<code>plan</code>) and applying that plan to actual infrastructure (<code>apply</code>). Understanding these workflows is critical because they represent the main value proposition of the system—transforming declarative configuration into safe, ordered operations on cloud resources.</p>\n<p>The mental model for these workflows is that of a <strong>construction project management office</strong>. The <code>plan</code> command is the project planning phase: architects review blueprints, check what&#39;s already built, and create a detailed work order. The <code>apply</code> command is the construction phase: site managers lock the site, hand work orders to specialized crews (providers), and update the building log as work completes.</p>\n<h3 id=\"sequence-the-planning-workflow\">Sequence: The Planning Workflow</h3>\n<p>The <code>plan</code> workflow answers the question: &quot;What changes would be made if I applied this configuration right now?&quot; It performs a <strong>dry-run analysis</strong> without modifying any infrastructure, which is crucial for safety and review. This workflow combines the <strong>Parser</strong>, <strong>State Manager</strong>, and <strong>Planner</strong> components to produce a human-readable diff of proposed changes.</p>\n<p><img src=\"/api/project/infrastructure-as-code/architecture-doc/asset?path=diagrams%2Fplan-sequence.svg\" alt=\"Sequence Diagram: Plan Command\"></p>\n<p>The workflow begins when a user runs <code>plan_command(config_path, state_path, var_file)</code> from the CLI. Here&#39;s the step-by-step sequence:</p>\n<ol>\n<li><p><strong>Configuration Loading and Parsing</strong></p>\n<ul>\n<li>The CLI calls <code>process_configuration(root_file, variable_files, cli_vars)</code>, which orchestrates the Parser component.</li>\n<li>Internally, <code>parse_file</code> reads the root HCL/YAML file and produces a raw abstract syntax tree (AST).</li>\n<li><code>resolve_variables</code> walks the AST, replacing <code>${var.name}</code> references with actual values from variable files and CLI arguments.</li>\n<li>For each module block found, <code>load_module</code> is called recursively to load and resolve the module&#39;s resources, flattening them into a single list.</li>\n<li>The final output is a normalized <code>List[Resource]</code> representing the <strong>desired state</strong>—what the infrastructure should look like.</li>\n</ul>\n</li>\n<li><p><strong>Current State Loading</strong></p>\n<ul>\n<li>The CLI calls <code>read_state(state_path)</code> on the State Manager.</li>\n<li>This loads the persistent state file from disk (or remote backend) into a <code>Dict[str, StateRecord]</code> dictionary keyed by resource address.</li>\n<li>If no state file exists, an empty dictionary is returned, representing a &quot;clean slate&quot; with no existing infrastructure.</li>\n</ul>\n</li>\n<li><p><strong>Dependency Graph Construction</strong></p>\n<ul>\n<li>The CLI passes both the desired resources and current state to the Planner via <code>build_graph(resources, state_records)</code>.</li>\n<li>The algorithm extracts dependencies from two sources:<ul>\n<li><strong>Explicit dependencies</strong>: From <code>depends_on</code> attributes in resource configurations.</li>\n<li><strong>Implicit dependencies</strong>: By analyzing attribute references (e.g., when Resource B&#39;s <code>vpc_id</code> references <code>aws_vpc.main.id</code>, a dependency edge is created from B → A).</li>\n</ul>\n</li>\n<li>The function returns a <code>Dict[str, DependencyGraphNode]</code> where each node contains <code>depends_on</code> and <code>required_by</code> lists.</li>\n<li><code>validate_acyclic(graph)</code> ensures no circular dependencies exist (which would make topological sorting impossible).</li>\n</ul>\n</li>\n<li><p><strong>Topological Sorting and Plan Generation</strong></p>\n<ul>\n<li>If the graph is acyclic, <code>topological_sort(graph)</code> produces a linear ordering where dependencies come before dependents.</li>\n<li>This sorted list is passed to <code>generate_plan(sorted_resources, desired_resources, current_state)</code>.</li>\n<li>For each resource address, the function compares the desired <code>Resource</code> against the current <code>StateRecord</code> (if any) to determine the appropriate <code>ActionType</code>:<ul>\n<li><strong>CREATE</strong>: No state record exists for this resource.</li>\n<li><strong>UPDATE</strong>: State record exists but attributes differ (and update is supported).</li>\n<li><strong>DELETE</strong>: State record exists but no corresponding desired resource (resource was removed from config).</li>\n<li><strong>NOOP</strong>: State matches desired configuration exactly.</li>\n</ul>\n</li>\n<li>The function assembles these into a <code>Dict[str, PlanAction]</code>—the <strong>execution plan</strong>.</li>\n</ul>\n</li>\n<li><p><strong>Plan Presentation</strong></p>\n<ul>\n<li>The CLI formats the plan for human consumption, typically showing:<ul>\n<li>Summary counts of creates, updates, deletes.</li>\n<li>Detailed diff for each resource showing attribute changes.</li>\n<li>Visual indication of dependency order.</li>\n</ul>\n</li>\n<li>The plan is printed to stdout but <strong>not persisted</strong>—it&#39;s ephemeral and tied to the current state snapshot.</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p><strong>Critical Insight:</strong> The plan is a <strong>point-in-time snapshot</strong> based on the state file at the moment of reading. If the state changes between planning and applying (e.g., another engineer applies changes), the plan becomes stale and potentially dangerous to execute. This is why the <code>apply</code> workflow includes locking.</p>\n</blockquote>\n<p><strong>Common Scenario Walkthrough:</strong> Consider adding a new web server behind an existing load balancer. The configuration defines an <code>aws_instance.web</code> (new) and an <code>aws_lb_listener.http</code> (modified to point to the new instance). The planning workflow would:</p>\n<ol>\n<li>Parse both resources, noting that the listener references the instance&#39;s ID via interpolation.</li>\n<li>Load current state showing the listener exists but the instance doesn&#39;t.</li>\n<li>Build a graph with edge: listener → instance (due to the ID reference).</li>\n<li>Topologically sort: [instance, listener] (instance must be created first so its ID is available).</li>\n<li>Generate plan: CREATE for instance, UPDATE for listener.</li>\n<li>Display: &quot;Plan: 1 to add, 1 to change, 0 to destroy.&quot;</li>\n</ol>\n<h3 id=\"sequence-the-apply-workflow\">Sequence: The Apply Workflow</h3>\n<p>The <code>apply</code> workflow executes the planned changes against real infrastructure in a safe, ordered manner. This is the <strong>moment of truth</strong> where the IaC engine interacts with cloud APIs to create, modify, or destroy resources. It coordinates the <strong>State Manager</strong>, <strong>Executor</strong>, and <strong>Provider</strong> components while maintaining safety through locking and idempotent operations.</p>\n<p><img src=\"/api/project/infrastructure-as-code/architecture-doc/asset?path=diagrams%2Fapply-sequence.svg\" alt=\"Sequence Diagram: Apply Command\"></p>\n<p>The workflow begins when a user runs <code>apply_command(config_path, state_path, var_file, auto_approve)</code>. If <code>auto_approve</code> is false, the system first displays the plan and prompts for confirmation. Once approved:</p>\n<ol>\n<li><p><strong>State Lock Acquisition</strong></p>\n<ul>\n<li>Before any changes, <code>acquire_lock(lock_path)</code> is called to obtain an exclusive lock on the state.</li>\n<li>This implements <strong>pessimistic concurrency control</strong>: only one apply operation can proceed at a time.</li>\n<li>The lock includes a heartbeat mechanism to detect and release stale locks from crashed processes.</li>\n<li>If locking fails (e.g., timeout or another process holds the lock), the apply aborts immediately.</li>\n</ul>\n</li>\n<li><p><strong>Fresh State Read and Plan Regeneration</strong></p>\n<ul>\n<li>With the lock held, <code>read_state(state_path)</code> loads the <strong>current state</strong> again.</li>\n<li>The configuration is reparsed (same as planning phase) to get fresh desired resources.</li>\n<li><code>generate_plan</code> is called again with the freshly loaded state and desired resources.</li>\n<li>This <strong>re-planning</strong> ensures the execution plan reflects the absolute latest state, guarding against the &quot;stale plan&quot; problem.</li>\n<li>If the regenerated plan differs significantly from the originally shown plan (beyond a threshold), some systems ask for reconfirmation.</li>\n</ul>\n</li>\n<li><p><strong>Plan Execution Orchestration</strong></p>\n<ul>\n<li>The plan and provider configurations are passed to <code>apply_plan(plan, providers, max_concurrency)</code>.</li>\n<li>The Executor processes resources in <strong>topological order</strong> (dependencies before dependents), but within independent branches, it can execute concurrently up to <code>max_concurrency</code>.</li>\n<li>For each <code>PlanAction</code>, the Executor:<ol>\n<li>Identifies the appropriate provider based on resource type (e.g., <code>aws_instance</code> → AWS provider).</li>\n<li>Calls <code>_execute_action(action, provider)</code> which delegates to the provider&#39;s CRUD methods:<ul>\n<li><strong>CREATE</strong>: <code>provider.create(resource)</code> → returns actual resource with cloud-assigned IDs.</li>\n<li><strong>UPDATE</strong>: <code>provider.update(resource_id, resource)</code> → returns updated resource.</li>\n<li><strong>DELETE</strong>: <code>provider.delete(resource_id, resource_type)</code> → returns success/failure.</li>\n</ul>\n</li>\n<li>Implements <strong>retry logic</strong> with exponential backoff for transient failures (rate limits, network issues).</li>\n<li>Handles <strong>eventual consistency</strong> by polling <code>provider.read()</code> after mutations until desired state is observed.</li>\n</ol>\n</li>\n<li>Each action result is captured in an <code>ApplyResult</code> tracking success/failure, error messages, and retry counts.</li>\n</ul>\n</li>\n<li><p><strong>State Persistence and Lock Release</strong></p>\n<ul>\n<li>As resources are successfully created/updated, their new attributes are recorded in an <strong>in-memory state dictionary</strong>.</li>\n<li>For deletions, the corresponding state records are removed.</li>\n<li>Once all actions complete (or fail), <code>write_state(state_path, state_data)</code> atomically writes the updated state to disk.</li>\n<li>The atomic write (via rename) ensures state file integrity even if the process crashes during write.</li>\n<li>Finally, <code>release_lock(lock_handle)</code> releases the lock, allowing other operations to proceed.</li>\n</ul>\n</li>\n<li><p><strong>Result Reporting</strong></p>\n<ul>\n<li>The CLI summarizes the apply results: counts of successful/errored resources.</li>\n<li>For failures, it displays error details and may suggest remediation steps.</li>\n<li>The updated state file now reflects the actual infrastructure, making subsequent plans accurate.</li>\n</ul>\n</li>\n</ol>\n<p><strong>Error Handling During Apply:</strong> The Executor must handle partial failures gracefully. The strategy is <strong>&quot;fail-fast within dependency chain, continue across independent chains&quot;</strong>:</p>\n<ul>\n<li>If a resource creation fails, all resources that depend on it cannot be created (marked as failed).</li>\n<li>Resources in independent dependency chains continue processing.</li>\n<li>The state is only updated for <strong>successfully applied resources</strong>—failed resources remain in their previous state.</li>\n<li>This ensures the state file never reflects partially created dependency chains.</li>\n</ul>\n<p><strong>Common Scenario Walkthrough:</strong> Continuing the web server example, the apply workflow would:</p>\n<ol>\n<li>Acquire lock on the state file.</li>\n<li>Re-read state and regenerate plan (same as before if no concurrent changes).</li>\n<li>Execute in order:<ul>\n<li><strong>Instance creation</strong>: Call AWS EC2 API, wait for instance to reach <code>running</code> state, capture <code>instance_id</code>.</li>\n<li><strong>Listener update</strong>: Call AWS ELB API to update listener with the new instance&#39;s ID.</li>\n</ul>\n</li>\n<li>Update state: Add instance record, update listener record with new attributes.</li>\n<li>Release lock and report: &quot;Apply complete! Resources: 1 added, 1 changed, 0 destroyed.&quot;</li>\n</ol>\n<h3 id=\"key-data-flow-transformations\">Key Data Flow Transformations</h3>\n<p>Throughout these workflows, data transforms through specific stages:</p>\n<table>\n<thead>\n<tr>\n<th>Stage</th>\n<th>Input</th>\n<th>Processing</th>\n<th>Output</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Parsing</strong></td>\n<td>HCL/YAML files + variables</td>\n<td>Lexical analysis, interpolation, module resolution</td>\n<td><code>List[Resource]</code> (desired state)</td>\n</tr>\n<tr>\n<td><strong>State Loading</strong></td>\n<td>State file bytes</td>\n<td>JSON deserialization, validation</td>\n<td><code>Dict[str, StateRecord]</code> (current state)</td>\n</tr>\n<tr>\n<td><strong>Diff Computation</strong></td>\n<td>Desired resources + current state</td>\n<td>Attribute-by-attribute comparison</td>\n<td><code>Dict[str, PlanAction]</code> (change set)</td>\n</tr>\n<tr>\n<td><strong>Graph Building</strong></td>\n<td>Resources + state</td>\n<td>Reference analysis, edge creation</td>\n<td><code>Dict[str, DependencyGraphNode]</code> (dependency DAG)</td>\n</tr>\n<tr>\n<td><strong>Plan Execution</strong></td>\n<td>Plan + providers</td>\n<td>CRUD API calls, retry logic</td>\n<td><code>Dict[str, ApplyResult]</code> (execution outcomes)</td>\n</tr>\n<tr>\n<td><strong>State Update</strong></td>\n<td>Current state + execution results</td>\n<td>Record addition/modification/removal</td>\n<td>Updated <code>Dict[str, StateRecord]</code> (new state)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Architecture Insight:</strong> The separation between planning and applying is not just organizational—it enables critical safety properties. The planning phase is <strong>pure and deterministic</strong> (no side effects), making it safe to run frequently for review. The applying phase is <strong>transactional</strong> with locking and atomic writes, ensuring consistency despite concurrent access and partial failures.</p>\n</blockquote>\n<h3 id=\"common-integration-pitfalls\">Common Integration Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Plan-Apply Race Conditions</strong></p>\n<ul>\n<li><strong>Description:</strong> User A runs <code>plan</code>, then user B applies changes before user A applies. User A&#39;s plan is now stale and applying it could overwrite B&#39;s changes.</li>\n<li><strong>Why it&#39;s wrong:</strong> The state has changed since the plan was generated, making the plan&#39;s assumptions invalid.</li>\n<li><strong>Fix:</strong> The <code>apply</code> workflow always re-reads state and re-plans after acquiring the lock, ensuring it acts on current reality.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Locking Granularity Issues</strong></p>\n<ul>\n<li><strong>Description:</strong> Locking the entire state file for a small change (one resource) blocks all other operations unnecessarily.</li>\n<li><strong>Why it&#39;s wrong:</strong> Reduces system throughput and creates contention.</li>\n<li><strong>Fix:</strong> In advanced implementations, consider fine-grained locking per resource or dependency subgraph. For our educational context, whole-state locking is acceptable.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Missing Rollback on Partial Failure</strong></p>\n<ul>\n<li><strong>Description:</strong> If the apply fails midway, some resources are created but others aren&#39;t, leaving infrastructure in an inconsistent state.</li>\n<li><strong>Why it&#39;s wrong:</strong> The user&#39;s configuration doesn&#39;t match reality, and dependencies may be broken.</li>\n<li><strong>Fix:</strong> Implement <strong>reverse execution</strong> for failed chains: if CREATE fails, delete any successfully created dependencies in reverse order. Alternatively, adopt a transactional approach where all changes are staged and committed atomically (complex for cloud APIs).</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides concrete implementation patterns for orchestrating the workflows described above.</p>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Workflow Orchestration</td>\n<td>Sequential function calls in CLI</td>\n<td>State machine with async/await</td>\n</tr>\n<tr>\n<td>Concurrency Control</td>\n<td><code>threading.Thread</code> for parallel execution</td>\n<td><code>asyncio</code> with semaphores</td>\n</tr>\n<tr>\n<td>Retry Logic</td>\n<td>Simple loop with <code>time.sleep()</code></td>\n<td><code>tenacity</code> library with backoff strategies</td>\n</tr>\n<tr>\n<td>Lock Heartbeat</td>\n<td>Separate daemon thread</td>\n<td><code>asyncio</code> background task</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>iac_engine/\n├── cli/\n│   ├── __init__.py\n│   ├── commands.py           # plan_command, apply_command implementations\n│   └── formatters.py         # Pretty output for plans and results\n├── workflows/\n│   ├── __init__.py\n│   ├── planner.py            # Orchestrates planning workflow\n│   ├── applier.py            # Orchestrates apply workflow\n│   └── lock_manager.py       # Lock acquisition/release helpers\n├── parser/                   # Milestone 1\n├── state/                    # Milestone 2  \n├── planner/                  # Milestone 3\n├── providers/                # Milestone 4\n└── executor.py               # Executor component</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p><strong>Workflow Orchestration Helper:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># workflows/lock_manager.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> threading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> pathlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> os</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LockHandle</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lock_path: Path</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    process_id: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lock_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    heartbeat_thread: Optional[threading.Thread]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stop_event: threading.Event</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LockManager</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Helper for acquiring and releasing locks with heartbeat.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> acquire_lock</span><span style=\"color:#E1E4E8\">(lock_path: Path, timeout_seconds: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                     heartbeat_interval: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">) -> LockHandle:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Attempts to acquire an exclusive lock with stale detection.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            lock_path: Path to lock file</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            timeout_seconds: Maximum time to wait for lock</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            heartbeat_interval: How often to update lock timestamp</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            LockHandle if acquired, raises TimeoutError otherwise</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lock_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">os.getpid()</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">-</span><span style=\"color:#79B8FF\">{int</span><span style=\"color:#E1E4E8\">(time.time())</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> time.time() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start_time </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> timeout_seconds:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Try to create lock file atomically</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                with</span><span style=\"color:#79B8FF\"> open</span><span style=\"color:#E1E4E8\">(lock_path, </span><span style=\"color:#9ECBFF\">'x'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> f:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    lock_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                        \"process_id\"</span><span style=\"color:#E1E4E8\">: os.getpid(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                        \"lock_id\"</span><span style=\"color:#E1E4E8\">: lock_id,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                        \"timestamp\"</span><span style=\"color:#E1E4E8\">: time.time(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                        \"heartbeat_interval\"</span><span style=\"color:#E1E4E8\">: heartbeat_interval</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    json.dump(lock_data, f)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Start heartbeat thread</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                stop_event </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> threading.Event()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                heartbeat_thread </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> threading.Thread(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    target</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">LockManager._heartbeat_worker,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    args</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">(lock_path, lock_id, heartbeat_interval, stop_event),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    daemon</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                heartbeat_thread.start()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> LockHandle(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    lock_path</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">lock_path,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    process_id</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">os.getpid(),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    lock_id</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">lock_id,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    heartbeat_thread</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">heartbeat_thread,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    stop_event</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">stop_event</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#79B8FF\"> FileExistsError</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Lock exists, check if stale</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    with</span><span style=\"color:#79B8FF\"> open</span><span style=\"color:#E1E4E8\">(lock_path, </span><span style=\"color:#9ECBFF\">'r'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> f:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        existing_lock </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> json.load(f)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    lock_age </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> existing_lock[</span><span style=\"color:#9ECBFF\">\"timestamp\"</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    max_age </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> existing_lock[</span><span style=\"color:#9ECBFF\">\"heartbeat_interval\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#E1E4E8\"> lock_age </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> max_age:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                        # Stale lock, remove it and retry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        os.remove(lock_path)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                except</span><span style=\"color:#E1E4E8\"> (json.JSONDecodeError, </span><span style=\"color:#79B8FF\">KeyError</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">IOError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Corrupt lock file, remove it</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        os.remove(lock_path)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    except</span><span style=\"color:#79B8FF\"> OSError</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            time.sleep(</span><span style=\"color:#79B8FF\">0.5</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Brief pause before retry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> TimeoutError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Could not acquire lock within </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">timeout_seconds</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> seconds\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _heartbeat_worker</span><span style=\"color:#E1E4E8\">(lock_path: Path, lock_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                         interval: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, stop_event: threading.Event):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Background thread that updates lock timestamp.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> stop_event.is_set():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                with</span><span style=\"color:#79B8FF\"> open</span><span style=\"color:#E1E4E8\">(lock_path, </span><span style=\"color:#9ECBFF\">'r'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> f:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    lock_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> json.load(f)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Only update if we still own the lock</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> lock_data.get(</span><span style=\"color:#9ECBFF\">\"lock_id\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> lock_id:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    lock_data[</span><span style=\"color:#9ECBFF\">\"timestamp\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    with</span><span style=\"color:#79B8FF\"> open</span><span style=\"color:#E1E4E8\">(lock_path, </span><span style=\"color:#9ECBFF\">'w'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> f:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        json.dump(lock_data, f)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">IOError</span><span style=\"color:#E1E4E8\">, json.JSONDecodeError):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            stop_event.wait(interval)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> release_lock</span><span style=\"color:#E1E4E8\">(handle: LockHandle):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Releases a previously acquired lock.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        handle.stop_event.set()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> handle.heartbeat_thread:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            handle.heartbeat_thread.join(</span><span style=\"color:#FFAB70\">timeout</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Verify we still own the lock before removing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            with</span><span style=\"color:#79B8FF\"> open</span><span style=\"color:#E1E4E8\">(handle.lock_path, </span><span style=\"color:#9ECBFF\">'r'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> f:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                lock_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> json.load(f)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> lock_data.get(</span><span style=\"color:#9ECBFF\">\"lock_id\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> handle.lock_id:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                os.remove(handle.lock_path)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">IOError</span><span style=\"color:#E1E4E8\">, json.JSONDecodeError):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Lock file may already be gone</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong>Plan Command Implementation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># cli/commands.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> pathlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Dict, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> iac_engine.parser </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> process_configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> iac_engine.state </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> read_state, compute_diff</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> iac_engine.planner </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> build_graph, validate_acyclic, topological_sort, generate_plan</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> iac_engine.workflows.planner </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> generate_plan_summary</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> plan_command</span><span style=\"color:#E1E4E8\">(config_path: Path, state_path: Path, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 var_file: Optional[Path] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    CLI command to generate and show an execution plan.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        config_path: Path to root configuration file</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        state_path: Path to state file</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        var_file: Optional path to variable definitions file</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Collect variable values from var_file and environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Parse var_file if provided (could be JSON, YAML, or .tfvars)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Also check environment variables with TF_VAR_ prefix</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Combine into a single variables dictionary</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Parse configuration with variables</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Call process_configuration(root_file, variable_files, cli_vars)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - This returns List[Resource] representing desired state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Load current state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Call read_state(state_path)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Returns Dict[str, StateRecord] (empty dict if file doesn't exist)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Build dependency graph</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Call build_graph(desired_resources, current_state)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Call validate_acyclic(graph) - raise error if cycles detected</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Generate execution plan</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Call topological_sort(graph) to get execution order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Convert desired_resources to dict keyed by address</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Call generate_plan(sorted_order, desired_dict, current_state)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Display plan to user</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Call generate_plan_summary(plan_dict) for human-readable output</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Show counts: + add, ~ change, - destroy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Show detailed diff for each resource</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   - Color code output (green for add, yellow for change, red for destroy)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p><strong>Apply Command Implementation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># cli/commands.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> iac_engine.workflows.lock_manager </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LockManager, LockHandle</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> iac_engine.executor </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> apply_plan</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> iac_engine.state </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> write_state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> iac_engine.workflows.planner </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> confirm_plan</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> apply_command</span><span style=\"color:#E1E4E8\">(config_path: Path, state_path: Path,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                  var_file: Optional[Path] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                  auto_approve: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    CLI command to apply changes to reach desired state.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        config_path: Path to root configuration file</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        state_path: Path to state file  </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        var_file: Optional path to variable definitions file</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        auto_approve: Skip confirmation prompt</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lock_handle: Optional[LockHandle] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Generate plan (same as plan_command)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Parse config, load state, build graph, generate plan</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - This plan is for display/confirmation only</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Show plan and request confirmation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Unless auto_approve is True, display plan and ask \"Do you want to perform these actions?\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Use confirm_plan(plan_dict) helper</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - If user rejects, exit immediately</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Acquire state lock</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Determine lock file path (typically state_path + \".lock\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Call LockManager.acquire_lock(lock_path, timeout_seconds=30)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Store returned LockHandle</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Re-plan with fresh state (critical!)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - With lock held, re-read state using read_state(state_path)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Re-parse configuration (variables might have changed)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Re-generate plan with fresh state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Compare with original plan - if significant differences, warn user</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Execute plan</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Load provider configurations from parsed config</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Initialize provider instances (AWS, GCP, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Call apply_plan(plan, providers, max_concurrency=5)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - This returns Dict[str, ApplyResult] for each resource</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Update state with successful changes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Start with copy of original state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - For each successful CREATE/UPDATE: add/update StateRecord</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - For each successful DELETE: remove StateRecord</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - For failed actions: leave state unchanged (resource stays as-is)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Call write_state(state_path, updated_state) atomically</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Release lock</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Call LockManager.release_lock(lock_handle)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Report results</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Show summary: X created, Y updated, Z destroyed, W failed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - For failures: show error messages and suggest fixes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Cleanup on error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - If lock_handle exists, release it</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Print error message with stack trace in debug mode</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Exit with non-zero code</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Executor Core Logic:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># executor.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> concurrent.futures</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> random</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ApplyResult</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resource_address: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    success: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_state: Optional[Resource]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    error: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    retries: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Executor</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Orchestrates plan execution using providers.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, max_concurrency: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.max_concurrency </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> max_concurrency</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> apply_plan</span><span style=\"color:#E1E4E8\">(self, plan: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, PlanAction], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                   providers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, BaseProvider],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                   ) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, ApplyResult]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Applies execution plan using providers.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            plan: Dictionary of PlanActions keyed by resource address</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            providers: Dictionary mapping provider types to provider instances</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Dictionary of ApplyResults keyed by resource address</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        results </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Group actions by dependency level</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Create a dependency graph from the plan</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Group resources that can be executed in parallel (same dependency depth)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Process groups sequentially, resources within group in parallel</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - For each dependency level (in topological order):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Create ThreadPoolExecutor with max_concurrency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Submit _execute_single_action for each resource in level</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Wait for all in level to complete before proceeding to next</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle resource execution with retries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Each _execute_single_action should:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     1. Identify correct provider from resource type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     2. For CREATE: call provider.create() with exponential backoff</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     3. For UPDATE: call provider.update() with exponential backoff  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     4. For DELETE: call provider.delete() with exponential backoff</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     5. Capture result in ApplyResult structure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Propagate failures to dependents</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - If a resource fails, mark all its dependents as \"failed due to dependency\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Skip execution for those dependents</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Collect and return results</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> results</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _execute_single_action</span><span style=\"color:#E1E4E8\">(self, action: PlanAction, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                               provider: BaseProvider) -> ApplyResult:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Internal method to execute single PlanAction with retry logic.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Implement exponential backoff with jitter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Base delay: 1 second, multiplier: 2, max delay: 30 seconds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Add random jitter (±10%) to avoid thundering herd</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For CREATE actions:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Call provider.create(action.resource)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - If successful, return ApplyResult with new_state from provider</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - If rate limited (429), wait and retry with backoff</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - If other error, mark as failed after max retries</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For UPDATE actions:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Call provider.update(action.prior_state.resource_id, action.resource)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Handle eventual consistency: read after update until attributes match</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: For DELETE actions:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Call provider.delete(action.prior_state.resource_id, action.resource.type)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Verify deletion by reading until resource not found</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Track retry count and include in ApplyResult</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> ApplyResult(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            resource_address</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">get_resource_address(action.resource),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            success</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            new_state</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            error</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"Not implemented\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            retries</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ul>\n<li><strong>Concurrent Execution:</strong> Use <code>concurrent.futures.ThreadPoolExecutor</code> for parallel execution within dependency levels. Remember that I/O-bound operations (API calls) benefit from threading in Python despite the GIL.</li>\n<li><strong>Atomic Writes:</strong> Implement <code>write_atomic_json</code> using <code>tempfile.NamedTemporaryFile</code> with <code>delete=False</code>, writing to the temp file, then <code>os.replace()</code> to atomically replace the target file.</li>\n<li><strong>Retry Logic:</strong> Consider using the <code>tenacity</code> library for robust retry patterns: <code>@retry(stop=stop_after_attempt(5), wait=wait_exponential(multiplier=1, min=1, max=30))</code>.</li>\n<li><strong>Provider Loading:</strong> Use Python&#39;s <code>importlib</code> to dynamically load provider modules based on configuration: <code>importlib.import_module(f&quot;providers.{provider_type}&quot;)</code>.</li>\n</ul>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p>After implementing both workflows, verify with this test scenario:</p>\n<ol>\n<li><strong>Setup test configuration:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">hcl</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # test.tf</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   resource</span><span style=\"color:#79B8FF\"> \"aws_vpc\"</span><span style=\"color:#79B8FF\"> \"main\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     cidr_block</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"10.0.0.0/16\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   resource</span><span style=\"color:#79B8FF\"> \"aws_subnet\"</span><span style=\"color:#79B8FF\"> \"example\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     vpc_id</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> aws_vpc</span><span style=\"color:#F97583\">.</span><span style=\"color:#E1E4E8\">main</span><span style=\"color:#F97583\">.</span><span style=\"color:#E1E4E8\">id</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     cidr_block</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"10.0.1.0/24\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Run planning workflow:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> iac_engine.cli</span><span style=\"color:#9ECBFF\"> plan</span><span style=\"color:#9ECBFF\"> test.tf</span><span style=\"color:#79B8FF\"> --state</span><span style=\"color:#9ECBFF\"> state.json</span></span></code></pre></div>\n<p>   <strong>Expected:</strong> Plan shows 2 resources to create, with subnet depending on VPC.</p>\n<ol start=\"3\">\n<li><strong>Run apply workflow (with mock provider):</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> iac_engine.cli</span><span style=\"color:#9ECBFF\"> apply</span><span style=\"color:#9ECBFF\"> test.tf</span><span style=\"color:#79B8FF\"> --state</span><span style=\"color:#9ECBFF\"> state.json</span><span style=\"color:#79B8FF\"> --auto-approve</span></span></code></pre></div>\n<p>   <strong>Expected:</strong> Resources created in correct order, state file updated with resource IDs.</p>\n<ol start=\"4\">\n<li><strong>Verify state:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   cat</span><span style=\"color:#9ECBFF\"> state.json</span></span></code></pre></div>\n<p>   <strong>Expected:</strong> JSON file containing both resources with mock IDs and attributes.</p>\n<p><strong>Signs of problems:</strong></p>\n<ul>\n<li>&quot;Cycle detected&quot; error when no cycles exist → Dependency extraction is buggy.</li>\n<li>Resources created in wrong order → Topological sort is incorrect.</li>\n<li>State file empty after apply → Atomic write failed or exceptions occurred.</li>\n<li>Lock never released → Heartbeat thread not stopping properly.</li>\n</ul>\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Plan shows no changes when changes exist</td>\n<td>State diff logic buggy</td>\n<td>Add debug logging to <code>compute_diff</code>, compare attribute dictionaries</td>\n<td>Ensure diff compares all attributes, not just top-level</td>\n</tr>\n<tr>\n<td>Apply hangs forever</td>\n<td>Deadlock in dependency chain or stuck provider</td>\n<td>Check which resource is currently executing, provider logs</td>\n<td>Implement timeouts for provider operations</td>\n</tr>\n<tr>\n<td>State file corrupted after crash</td>\n<td>Partial write during crash</td>\n<td>Check for <code>.tmp</code> files near state file</td>\n<td>Ensure <code>write_atomic_json</code> uses temp file + rename</td>\n</tr>\n<tr>\n<td>&quot;Lock already held&quot; when no other process running</td>\n<td>Stale lock file from crashed process</td>\n<td>Check lock file timestamp and process ID</td>\n<td>Implement stale lock detection in <code>acquire_lock</code></td>\n</tr>\n<tr>\n<td>Resources created but dependencies broken</td>\n<td>Execution order incorrect despite correct plan</td>\n<td>Log dependency graph and execution order</td>\n<td>Verify topological sort respects all edges</td>\n</tr>\n<tr>\n<td>Rate limiting errors even with retries</td>\n<td>Retry logic too aggressive</td>\n<td>Check retry delay values and jitter</td>\n<td>Increase initial delay, add jitter, respect Retry-After headers</td>\n</tr>\n</tbody></table>\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 2, 3, 4</p>\n</blockquote>\n<p>A robust Infrastructure as Code engine must anticipate and gracefully handle failures that can occur at every stage of its operation—from parsing invalid configuration to dealing with unreliable cloud APIs. Unlike traditional applications where errors often stem from internal logic bugs, an IaC engine operates in a <strong>distributed, eventually consistent, and adversarial environment</strong> where external systems can fail independently, network connections can drop, and users can modify infrastructure outside the IaC workflow. This section provides a systematic framework for categorizing these failures and implementing appropriate recovery strategies, ensuring the system remains predictable and safe even when things go wrong.</p>\n<h3 id=\"mental-model-the-fault-tolerant-construction-site\">Mental Model: The Fault-Tolerant Construction Site</h3>\n<p>Imagine our construction site from earlier analogies, but now we must account for real-world complications:</p>\n<ul>\n<li><strong>Bad Blueprints:</strong> The architect&#39;s drawings contain contradictory instructions (configuration errors).</li>\n<li><strong>Missing Materials:</strong> Some building materials are out of stock (provider API failures).</li>\n<li><strong>Weather Delays:</strong> Sudden rain stops work temporarily (transient network issues).</li>\n<li><strong>Vandals:</strong> Someone modifies the building overnight without telling the site manager (external drift).</li>\n<li><strong>Partial Collapse:</strong> Halfway through rebuilding a wall, the scaffolding collapses (partial apply failure).</li>\n</ul>\n<p>The site manager (our IaC engine) needs procedures for each scenario: rejecting bad blueprints, waiting for materials, rescheduling delayed work, detecting and reconciling unauthorized changes, and safely recovering from partial failures without making things worse.</p>\n<h3 id=\"error-classification-and-recovery-strategy\">Error Classification and Recovery Strategy</h3>\n<p>Errors in an IaC system fall into distinct categories based on their source, persistence, and impact on system safety. Each category requires a different handling strategy:</p>\n<table>\n<thead>\n<tr>\n<th>Error Category</th>\n<th>Detection Point</th>\n<th>Common Causes</th>\n<th>Recovery Strategy</th>\n<th>Safety Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Configuration Errors</strong></td>\n<td>During parsing (<code>process_configuration</code>)</td>\n<td>Invalid HCL syntax, undefined variable references, circular dependencies in modules, invalid resource schemas</td>\n<td>Fail fast with clear error messages pointing to exact file and line. Never proceed with invalid config.</td>\n<td>High - Prevents deploying invalid infrastructure.</td>\n</tr>\n<tr>\n<td><strong>State Errors</strong></td>\n<td>During state read/write (<code>read_state</code>, <code>write_state</code>)</td>\n<td>Corrupted JSON, partial writes from crashed process, stale lock files, version incompatibility</td>\n<td>Automatic fallback to backup file, stale lock detection with forced break, human intervention for schema migration.</td>\n<td>Critical - Corrupted state can lead to destructive actions.</td>\n</tr>\n<tr>\n<td><strong>Planning Errors</strong></td>\n<td>During graph building (<code>build_graph</code>) or plan generation (<code>generate_plan</code>)</td>\n<td>Circular dependencies, unresolvable attribute references, provider schema mismatches</td>\n<td>Fail during planning with clear diagnostic output (e.g., &quot;Cycle detected: A → B → A&quot;). Never generate invalid plan.</td>\n<td>High - Invalid plans could cause unsafe execution order.</td>\n</tr>\n<tr>\n<td><strong>Provider Errors (Transient)</strong></td>\n<td>During CRUD operations in <code>_execute_action</code></td>\n<td>Network timeouts, rate limiting (429), temporary cloud service unavailability (5xx), eventual consistency delays</td>\n<td>Exponential backoff with jitter, circuit breaker pattern, retry with increasing delays up to configured maximum.</td>\n<td>Medium - May delay apply but preserves safety.</td>\n</tr>\n<tr>\n<td><strong>Provider Errors (Permanent)</strong></td>\n<td>During CRUD operations or <code>validate_credentials</code></td>\n<td>Invalid credentials, insufficient permissions, unsupported resource configuration, quota exceeded</td>\n<td>Fail fast with provider-specific error message. Roll back any in-progress changes in the current operation.</td>\n<td>High - Continuing would waste resources and fail anyway.</td>\n</tr>\n<tr>\n<td><strong>Partial Apply Failures</strong></td>\n<td>During <code>apply_plan</code> execution</td>\n<td>Resource creation succeeds but dependent resource fails, external modification during apply, provider bug leaves resource in zombie state</td>\n<td>Stop further execution (fail-fast), preserve intermediate state, provide clear error report with affected resources.</td>\n<td>Critical - Leaves infrastructure in inconsistent state.</td>\n</tr>\n<tr>\n<td><strong>Concurrency Conflicts</strong></td>\n<td>During <code>acquire_lock</code> or state read-modify-write</td>\n<td>Another process modifying same state simultaneously, S3 eventual consistency returning stale state</td>\n<td>Pessimistic locking with lease timeout, state checksum validation (optimistic concurrency), retry with fresh state read.</td>\n<td>Critical - Could cause conflicting modifications.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight:</strong> The safety principle of <strong>&quot;fail safe&quot;</strong> is paramount. When uncertain, the system should err on the side of doing nothing rather than risking destructive action. This is why configuration and planning errors cause immediate failure, while transient errors trigger retries rather than abandonment.</p>\n</blockquote>\n<h4 id=\"detailed-recovery-procedures\">Detailed Recovery Procedures</h4>\n<p>For each error category, we implement specific recovery logic:</p>\n<ol>\n<li><p><strong>Configuration Error Recovery</strong></p>\n<ul>\n<li><strong>Detection:</strong> Syntax validation in <code>parse_file</code>, reference resolution in <code>resolve_variables</code>, cycle detection in module loading</li>\n<li><strong>Action:</strong> Immediately raise a <code>ConfigurationError</code> with:<ul>\n<li>File path and line number (if available)</li>\n<li>Specific error description</li>\n<li>Suggested fix when possible</li>\n</ul>\n</li>\n<li><strong>State Preservation:</strong> No state modification occurs</li>\n</ul>\n</li>\n<li><p><strong>Transient Provider Error Recovery</strong></p>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">prose</span><pre class=\"arch-pre shiki-highlighted\"><code>   Algorithm: Exponential Backoff with Jitter\n   1. Initialize attempt counter = 1, base_delay = 1 second, max_delay = 60 seconds\n   2. Execute the provider operation (create/read/update/delete)\n   3. If success: return result\n   4. If failure is transient (timeout, 429, 5xx):\n      a. Calculate delay = min(base_delay * 2^(attempt-1) + random_jitter, max_delay)\n      b. Wait for delay\n      c. Increment attempt counter\n      d. If attempts &lt; max_attempts (default 5): goto step 2\n      e. Else: raise PermanentProviderError\n   5. If failure is permanent: raise immediately</code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Partial Apply Failure Recovery</strong><ul>\n<li><strong>Detection:</strong> <code>_execute_action</code> returns error for a resource in the middle of plan execution</li>\n<li><strong>Action:</strong> <ol>\n<li>Stop executing further actions (fail-fast)</li>\n<li>Record current progress in a <code>partial_failure_state</code> snapshot</li>\n<li>For all successfully applied resources, refresh their state from cloud</li>\n<li>Write combined state (original succeeded + refreshed new states) to disk</li>\n<li>Return detailed error report listing succeeded and failed resources</li>\n</ol>\n</li>\n<li><strong>User Recovery Path:</strong> User must fix underlying issue, then re-run <code>apply</code> (which will compute diff from the partially updated state)</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"key-edge-cases-and-mitigations\">Key Edge Cases and Mitigations</h3>\n<p>Beyond straightforward error categories, several subtle edge cases can undermine the system&#39;s correctness if not properly addressed.</p>\n<h4 id=\"edge-case-1-partial-apply-failures-with-dependency-chains\">Edge Case 1: Partial Apply Failures with Dependency Chains</h4>\n<p><strong>Scenario:</strong> Creating resource B depends on resource A. A creates successfully, but B fails. The infrastructure is now in an inconsistent state—A exists but B doesn&#39;t.</p>\n<p><strong>Mitigation Strategy:</strong></p>\n<ul>\n<li><strong>Fail-Fast Stop:</strong> Stop execution immediately when B fails, preventing creation of C, D, etc.</li>\n<li><strong>State Refresh &amp; Preservation:</strong> Refresh A&#39;s actual state from the cloud (in case cloud defaults differ from config), then write state file containing A (with actual attributes) and B (as desired but uncreated). This creates an <strong>intentional drift</strong> recorded in state.</li>\n<li><strong>Next Apply Safety:</strong> When user re-runs <code>apply</code> after fixing B&#39;s issue, the planner will:<ol>\n<li>Compare desired state (A, B) against current state (A exists, B missing)</li>\n<li>Generate <code>NOOP</code> for A (already exists with correct attributes)</li>\n<li>Generate <code>CREATE</code> for B (still needs creation)</li>\n<li>Execute only the missing B creation</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p><strong>Design Insight:</strong> The state file should always reflect <strong>reality as known to the IaC engine</strong>, not wishful thinking. Recording partial failures honestly enables safe recovery.</p>\n</blockquote>\n<h4 id=\"edge-case-2-external-resource-modification-state-drift\">Edge Case 2: External Resource Modification (State Drift)</h4>\n<p><strong>Scenario:</strong> A system administrator manually deletes a VM via cloud console that&#39;s managed by our IaC engine. The next <code>plan</code> should detect this drift and either recreate it or remove it from management.</p>\n<p><strong>Mitigation Strategy:</strong></p>\n<ul>\n<li><strong>Refresh Before Plan:</strong> The <code>plan_command</code> should optionally call <code>refresh_state</code> for all resources to detect external changes.</li>\n<li><strong>Drift Detection Algorithm:</strong><ol>\n<li>Read desired state from configuration</li>\n<li>Read recorded state from state file</li>\n<li>For each resource, call provider&#39;s <code>read</code> method to get actual cloud state</li>\n<li>Compare: <ul>\n<li>If actual == recorded: <code>NOOP</code></li>\n<li>If actual == desired but ≠ recorded: <code>UPDATE</code> state only (drift corrected externally)</li>\n<li>If actual ≠ desired and recorded == desired: <code>UPDATE</code> or <code>RECREATE</code> (external modification)</li>\n<li>If actual == null but recorded exists: <code>CREATE</code> (external deletion)</li>\n<li>If actual exists but recorded == null: <code>IMPORT</code> suggestion (external creation)</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><strong>User Notification:</strong> Clearly distinguish between &quot;changes to reach desired state&quot; and &quot;drift detection&quot; in plan output.</li>\n</ul>\n<h4 id=\"edge-case-3-zombie-resources-created-but-unrecorded\">Edge Case 3: Zombie Resources (Created but Unrecorded)</h4>\n<p><strong>Scenario:</strong> During a <code>create</code> operation, the provider API returns success but then crashes before returning the full resource attributes. The state file never gets updated with the new resource&#39;s ID, creating a &quot;zombie&quot; resource that exists in cloud but isn&#39;t managed.</p>\n<p><strong>Mitigation Strategy:</strong></p>\n<ul>\n<li><strong>Two-Phase Create:</strong> Implement create operations as:<ol>\n<li>Call provider <code>create</code> with desired configuration</li>\n<li>Immediately call provider <code>read</code> with the returned ID to get complete attributes</li>\n<li>Only if both succeed, record the <code>read</code> result in state</li>\n</ol>\n</li>\n<li><strong>Orphan Detection:</strong> Periodic cleanup job that:<ol>\n<li>Lists all resources in cloud for a given tag (e.g., <code>managed_by=our_iac</code>)</li>\n<li>Cross-references with state file</li>\n<li>Flags resources in cloud but not in state for manual review</li>\n</ol>\n</li>\n<li><strong>Transaction Boundary:</strong> Treat the entire <code>_execute_action</code> for a <code>CREATE</code> as atomic—either both create and state update succeed, or we retry/rollback.</li>\n</ul>\n<h4 id=\"edge-case-4-schema-evolution-and-version-compatibility\">Edge Case 4: Schema Evolution and Version Compatibility</h4>\n<p><strong>Scenario:</strong> After upgrading to a new version of a provider, resource attributes that were previously optional become required. Existing state files contain the old schema, causing validation errors.</p>\n<p><strong>Mitigation Strategy:</strong></p>\n<ul>\n<li><strong>State Versioning:</strong> Include a <code>schema_version</code> field in <code>StateRecord</code> and state file metadata.</li>\n<li><strong>Migration Hooks:</strong> Provider implementations can define migration functions that upgrade state from v1 → v2 → v3.</li>\n<li><strong>Backward Compatibility:</strong> When reading old state, apply migration before validation.</li>\n<li><strong>Forward Safety:</strong> Never automatically downgrade state; require explicit user action.</li>\n</ul>\n<h4 id=\"edge-case-5-circular-dependencies-with-implicit-references\">Edge Case 5: Circular Dependencies with Implicit References</h4>\n<p><strong>Scenario:</strong> Resource A references attribute of Resource B, while Resource B references attribute of Resource A, creating a circular dependency that&#39;s not explicitly declared with <code>depends_on</code>.</p>\n<p><strong>Mitigation Strategy:</strong></p>\n<ul>\n<li><strong>Static Analysis During Planning:</strong> <code>build_graph</code> must detect both explicit (<code>depends_on</code>) and implicit (attribute reference) dependencies.</li>\n<li><strong>Cycle Detection Algorithm:</strong> Use depth-first search with temporary marking to detect cycles in combined dependency graph.</li>\n<li><strong>Clear Error Messages:</strong> When cycle detected, output the cycle path: &quot;A → B → A&quot; and highlight the problematic attribute references.</li>\n<li><strong>Require Explicit Break:</strong> Force user to redesign configuration to eliminate cycle (e.g., by using <code>depends_on</code> to control order, or restructuring resources).</li>\n</ul>\n<h4 id=\"edge-case-6-provider-api-eventually-consistency\">Edge Case 6: Provider API Eventually Consistency</h4>\n<p><strong>Scenario:</strong> After successfully calling <code>create</code>, an immediate <code>read</code> returns &quot;not found&quot; because the cloud provider&#39;s replication hasn&#39;t completed.</p>\n<p><strong>Mitigation Strategy:</strong></p>\n<ul>\n<li><strong>Eventual Consistency Awareness:</strong> After mutating operations, implement progressive polling:<ol>\n<li>Initial read (may fail with &quot;not found&quot;)</li>\n<li>Wait 1 second, retry read</li>\n<li>Exponential backoff up to reasonable limit (e.g., 30 seconds for global resources)</li>\n<li>If still not found after max wait, treat as failure (may need recreate)</li>\n</ol>\n</li>\n<li><strong>Resource-Specific Timeouts:</strong> Different resource types have different propagation characteristics (e.g., global DNS vs. regional compute).</li>\n</ul>\n<h4 id=\"edge-case-7-concurrent-modification-by-multiple-engineers\">Edge Case 7: Concurrent Modification by Multiple Engineers</h4>\n<p><strong>Scenario:</strong> Two engineers run <code>apply</code> simultaneously on the same infrastructure, both using shared remote state (e.g., S3).</p>\n<p><strong>Mitigation Strategy:</strong></p>\n<ul>\n<li><strong>Pessimistic Locking:</strong> <code>acquire_lock</code> creates a lock file with process ID, timestamp, and owner.</li>\n<li><strong>Lock Heartbeat:</strong> Background thread periodically updates lock timestamp while operation in progress.</li>\n<li><strong>Stale Lock Detection:</strong> If lock exists but heartbeat is older than timeout (e.g., 10 minutes), assume previous process crashed and allow breaking lock.</li>\n<li><strong>State Checksum Validation:</strong> Before writing updated state, verify that the state hasn&#39;t changed since we read it (optimistic concurrency as backup).</li>\n</ul>\n<h4 id=\"edge-case-8-configuration-with-countfor_each-interpolation\">Edge Case 8: Configuration with Count/For_Each Interpolation</h4>\n<p><strong>Scenario:</strong> <code>count = length(${var.items})</code> creates chicken-and-egg problem: need variable value to know how many resources, but variables may reference resource attributes.</p>\n<p><strong>Mitigation Strategy:</strong></p>\n<ul>\n<li><strong>Multi-Pass Resolution:</strong> Implement variable resolution in phases:<ol>\n<li>Resolve all non-resource-dependent variables</li>\n<li>Create initial resource graph with unknown <code>count</code></li>\n<li>If <code>count</code> references unresolved value, error with &quot;cannot compute count before resources exist&quot;</li>\n<li>Require <code>count</code> to use only variables, not resource attributes</li>\n</ol>\n</li>\n<li><strong>Alternative:</strong> Support <code>for_each</code> with explicitly known collections rather than computed lengths.</li>\n</ul>\n<h3 id=\"adr-fail-fast-vs-continue-on-error-for-partial-apply\">ADR: Fail-Fast vs. Continue-on-Error for Partial Apply</h3>\n<blockquote>\n<p><strong>Decision: Fail-Fast on Partial Apply</strong></p>\n<ul>\n<li><strong>Context:</strong> When applying a plan with multiple resources, some may fail while others succeed. We must decide whether to continue applying unrelated resources or stop immediately.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Fail-Fast:</strong> Stop execution at first failure, preserve partial state, report error.</li>\n<li><strong>Continue-on-Error:</strong> Skip failed resource, continue with others, aggregate all errors at end.</li>\n<li><strong>Dependency-Aware Continue:</strong> Stop only if dependent resources will fail; continue with independent ones.</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Implement Fail-Fast strategy.</li>\n<li><strong>Rationale:</strong> <ul>\n<li><strong>Safety First:</strong> Continuing after unknown failure could compound problems (e.g., creating dependent resources that will fail anyway).</li>\n<li><strong>Predictability:</strong> Engineers get immediate feedback rather than discovering multiple failures buried in log.</li>\n<li><strong>Simpler Recovery:</strong> With fail-fast, the point of failure is clear and state reflects exactly what succeeded.</li>\n<li><strong>Industry Standard:</strong> Terraform and most production IaC tools use fail-fast for apply operations.</li>\n</ul>\n</li>\n<li><strong>Consequences:</strong><ul>\n<li>Engineers must fix errors and re-run apply more frequently.</li>\n<li>Requires careful dependency ordering to minimize cascading failures.</li>\n<li>Partial state must be accurately preserved for safe resume.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Why Not Chosen</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Fail-Fast</strong></td>\n<td>Safe, predictable, easier to debug, matches user expectations</td>\n<td>May stop early for non-critical failures, requires re-running apply</td>\n<td><strong>Chosen</strong> - Safety outweighs convenience</td>\n</tr>\n<tr>\n<td><strong>Continue-on-Error</strong></td>\n<td>Maximizes progress in single run, good for independent resources</td>\n<td>Can create inconsistent state, harder to debug multiple failures</td>\n<td>Risk of creating &quot;zombie&quot; resources with missing dependencies</td>\n</tr>\n<tr>\n<td><strong>Dependency-Aware</strong></td>\n<td>Intelligent compromise, minimizes unnecessary stops</td>\n<td>Complex to implement (need real-time dependency analysis), still risky</td>\n<td>Added complexity not justified for educational project</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Silent State Corruption</strong></p>\n<ul>\n<li><strong>Description:</strong> Writing state with <code>json.dump()</code> directly without atomic rename can result in partially written/corrupted state files if process crashes mid-write.</li>\n<li><strong>Why Wrong:</strong> Corrupted state file on next read causes parser errors or, worse, incorrect diffs leading to destructive actions.</li>\n<li><strong>Fix:</strong> Always use <code>write_atomic_json</code> which writes to temp file then atomically renames.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Infinite Retry Loop</strong></p>\n<ul>\n<li><strong>Description:</strong> Implementing retry logic without maximum attempts or circuit breaker for permanent failures.</li>\n<li><strong>Why Wrong:</strong> System hangs forever retrying impossible operations (e.g., invalid credentials), wasting resources.</li>\n<li><strong>Fix:</strong> Implement exponential backoff with jitter AND maximum attempt limit (e.g., 5 attempts). Add circuit breaker pattern to fail fast after repeated failures.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Ignoring Stale Locks</strong></p>\n<ul>\n<li><strong>Description:</strong> Checking only if lock file exists, not checking its timestamp/heartbeat.</li>\n<li><strong>Why Wrong:</strong> Crashed process leaves lock file forever, blocking all future operations.</li>\n<li><strong>Fix:</strong> Implement <code>acquire_lock</code> with stale detection (e.g., locks older than 10 minutes can be broken with warning).</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Not Refreshing State After Partial Apply</strong></p>\n<ul>\n<li><strong>Description:</strong> After resource A succeeds but B fails, writing state with A&#39;s <em>expected</em> attributes rather than <em>actual</em> attributes from cloud.</li>\n<li><strong>Why Wrong:</strong> Cloud may set default values different from config; next plan will see incorrect &quot;drift.&quot;</li>\n<li><strong>Fix:</strong> After each successful operation, immediately call <code>refresh_state</code> and use the returned actual state.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Assuming Immediate Consistency</strong></p>\n<ul>\n<li><strong>Description:</strong> Calling <code>read</code> immediately after <code>create</code> and treating &quot;not found&quot; as failure.</li>\n<li><strong>Why Wrong:</strong> Cloud providers have eventual consistency; resource may exist but not be immediately queryable.</li>\n<li><strong>Fix:</strong> Implement progressive polling with exponential backoff for read-after-write operations.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"a-technology-recommendations\">A. Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Error Classification</td>\n<td>Custom exception hierarchy with base <code>IaCError</code></td>\n<td>Structured error codes with machine-readable metadata</td>\n</tr>\n<tr>\n<td>Retry Logic</td>\n<td>Manual retry loops with <code>time.sleep()</code></td>\n<td><code>tenacity</code> library with decorators and multiple backoff strategies</td>\n</tr>\n<tr>\n<td>Circuit Breaker</td>\n<td>Simple counter tracking consecutive failures</td>\n<td><code>pybreaker</code> library with half-open state automation</td>\n</tr>\n<tr>\n<td>State Validation</td>\n<td>JSON Schema validation with <code>jsonschema</code></td>\n<td>Protocol Buffers with backward compatibility rules</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-file-structure\">B. Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>iac-engine/\n  errors/                    # Error hierarchy and utilities\n    __init__.py\n    exceptions.py           # Base IaCError and all subclasses\n    recovery.py             # Retry, circuit breaker utilities\n  state/                    # State management\n    lock.py                # LockHandle and acquisition logic\n    file_operations.py     # write_atomic_json, read_json_with_backup\n  providers/               # Provider implementations\n    base.py               # BaseProvider with error handling mixins\n    retry_decorators.py   # @retry_with_backoff decorator</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p><strong>Complete Retry Decorator with Exponential Backoff:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># errors/recovery.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> random</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Callable, Any, Type, Tuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> functools </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> wraps</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> retry_with_backoff</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_attempts: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    base_delay: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_delay: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 60.0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    jitter: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    exceptions: Tuple[Type[</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">...</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">,)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Decorator that retries a function with exponential backoff and jitter.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        max_attempts: Maximum number of attempts before giving up</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        base_delay: Base delay in seconds (will be doubled each retry)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        max_delay: Maximum delay in seconds</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        jitter: Whether to add random jitter to delays</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        exceptions: Tuple of exception types to catch and retry</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> decorator</span><span style=\"color:#E1E4E8\">(func: Callable) -> Callable:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        @wraps</span><span style=\"color:#E1E4E8\">(func)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        def</span><span style=\"color:#B392F0\"> wrapper</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            attempt </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            while</span><span style=\"color:#E1E4E8\"> attempt </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> max_attempts:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    return</span><span style=\"color:#E1E4E8\"> func(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                except</span><span style=\"color:#E1E4E8\"> exceptions </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Check if this is a permanent error (not transient)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#79B8FF\"> hasattr</span><span style=\"color:#E1E4E8\">(e, </span><span style=\"color:#9ECBFF\">'permanent'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> e.permanent:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        raise</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Permanent errors for certain status codes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#79B8FF\"> hasattr</span><span style=\"color:#E1E4E8\">(e, </span><span style=\"color:#9ECBFF\">'status_code'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        if</span><span style=\"color:#E1E4E8\"> e.status_code </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#79B8FF\">400</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">401</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">403</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">404</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">409</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                            raise</span><span style=\"color:#6A737D\">  # Don't retry client errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#E1E4E8\"> attempt </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> max_attempts:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        raise</span><span style=\"color:#6A737D\">  # Max attempts reached</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Calculate delay with exponential backoff</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    delay </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> min</span><span style=\"color:#E1E4E8\">(base_delay </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\"> **</span><span style=\"color:#E1E4E8\"> (attempt </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)), max_delay)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Add jitter (0.5 to 1.5 multiplier)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#E1E4E8\"> jitter:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        delay </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> delay </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">0.5</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> random.random())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    time.sleep(delay)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    attempt </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Should never reach here</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> RuntimeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Retry logic exhausted unexpectedly\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> wrapper</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> decorator</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CircuitBreaker</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Simple circuit breaker pattern implementation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, failure_threshold: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">, reset_timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 60.0</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.failure_threshold </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> failure_threshold</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.reset_timeout </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> reset_timeout</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.failure_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.last_failure_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"CLOSED\"</span><span style=\"color:#6A737D\">  # CLOSED, OPEN, HALF_OPEN</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> call</span><span style=\"color:#E1E4E8\">(self, func: Callable, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Check if circuit breaker is OPEN and reset timeout has passed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"OPEN\"</span><span style=\"color:#F97583\"> and</span><span style=\"color:#E1E4E8\"> current_time </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.last_failure_time </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.reset_timeout:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"HALF_OPEN\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Reject calls if circuit is OPEN</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"OPEN\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> CircuitOpenError(</span><span style=\"color:#9ECBFF\">\"Circuit breaker is OPEN\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> func(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Success - reset circuit if it was HALF_OPEN</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"HALF_OPEN\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"CLOSED\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">.failure_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.failure_count </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.last_failure_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current_time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Trip circuit if threshold reached</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.failure_count </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.failure_threshold:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"OPEN\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong>Error-Aware Execute Action:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># providers/base.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> errors.recovery </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> retry_with_backoff, CircuitBreaker</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Dict, Any</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ProviderError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base exception for all provider errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, resource_address: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, permanent: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.resource_address </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> resource_address</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.permanent </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> permanent</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TransientProviderError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ProviderError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Transient error that may succeed on retry.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, resource_address: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, resource_address, </span><span style=\"color:#FFAB70\">permanent</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PermanentProviderError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ProviderError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Permanent error that won't succeed with retry.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, resource_address: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, resource_address, </span><span style=\"color:#FFAB70\">permanent</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BaseProvider</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # ... other methods ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @retry_with_backoff</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">max_attempts</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">base_delay</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">max_delay</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">10.0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create</span><span style=\"color:#E1E4E8\">(self, resource: Resource) -> Resource:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Create a resource in the cloud with retry logic.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 1: Validate resource configuration matches provider schema</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 2: Call cloud API to create resource (may raise TransientProviderError)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 3: If API returns success but incomplete data, immediately call self.read()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 4: Return Resource with actual cloud attributes (not just desired)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 5: Handle specific error cases:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">               - Rate limiting (429) -> raise TransientProviderError</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">               - Invalid config (400) -> raise PermanentProviderError</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">               - Timeout -> raise TransientProviderError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 6: Ensure operation is idempotent (same call twice creates only one resource)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> read</span><span style=\"color:#E1E4E8\">(self, resource_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, resource_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[Resource]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Read current resource state from cloud with eventual consistency handling.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 1: Call cloud API to get resource</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 2: If resource not found, return None</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 3: If API returns 404 but resource was just created, implement progressive polling:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">               - Wait 1 second, retry</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">               - Exponential backoff up to 30 seconds</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">               - If still not found, assume creation failed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 4: Convert cloud API response to Resource object</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 5: Handle rate limiting and timeouts with retry decorator</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Partial Apply Recovery in Executor:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># executor/apply.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> errors.exceptions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> PartialApplyError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ApplyResult</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resource_address: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    success: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_state: Optional[Resource]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    error: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    retries: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> apply_plan</span><span style=\"color:#E1E4E8\">(plan: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, PlanAction], providers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, BaseProvider], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               max_concurrency: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, ApplyResult]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Apply execution plan with partial failure recovery.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 1: Group actions by provider for efficient API usage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 2: For each action in topological order (respecting dependencies):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            - Execute with _execute_action helper</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            - If success: refresh state from cloud, store in results</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            - If failure: </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                a. Stop execution (fail-fast)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                b. Refresh state for all succeeded resources</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                c. Compile partial state (original + succeeded refreshed)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                d. Write partial state to disk</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                e. Raise PartialApplyError with details</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 3: If all actions succeed: write complete new state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 4: Return ApplyResult for each resource</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    results </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    succeeded_resources </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Sort actions by dependency order from plan</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sorted_actions </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> topological_sort_actions(plan)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> resource_address, action </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> sorted_actions:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> _execute_action(action, providers)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            results[resource_address] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> result.success:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Refresh to get actual cloud state (not just expected)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                refreshed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> refresh_state(result.new_state, providers)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                succeeded_resources[resource_address] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> refreshed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Partial failure - stop execution</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#E1E4E8\"> PartialApplyError(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    message</span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Resource </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">resource_address</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> failed: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">result.error</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    succeeded</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">succeeded_resources,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    failed_resource</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">resource_address</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#E1E4E8\"> PartialApplyError:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Re-raise to outer handler</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Unexpected error - convert to PartialApplyError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> PartialApplyError(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                message</span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Unexpected error applying </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">resource_address</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{str</span><span style=\"color:#E1E4E8\">(e)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                succeeded</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">succeeded_resources,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                failed_resource</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">resource_address</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> results</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ul>\n<li><strong>Python Exception Chaining:</strong> Use <code>raise NewError(&quot;message&quot;) from original_error</code> to preserve stack trace.</li>\n<li><strong>Context Managers for Cleanup:</strong> Use <code>with</code> statements for lock acquisition and file operations to ensure cleanup even on error.</li>\n<li><strong>Typing for Error Metadata:</strong> Use <code>typing.TypedDict</code> or dataclasses for structured error return values.</li>\n<li><strong>Logging Structured Errors:</strong> Use <code>logging.exception()</code> with extra context dict for machine-parsable error logs.</li>\n</ul>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p><strong>After implementing error handling for Milestone 4:</strong></p>\n<ol>\n<li><strong>Test Configuration Errors:</strong> Run <code>plan_command</code> with invalid HCL syntax - should fail immediately with clear error message.</li>\n<li><strong>Test Transient Retry:</strong> Mock a provider that fails twice then succeeds - verify retry logic works.</li>\n<li><strong>Test Partial Apply:</strong> Create a plan where second resource fails - verify:<ul>\n<li>Execution stops after first failure</li>\n<li>State file contains only first resource (refreshed from cloud)</li>\n<li>Error message clearly indicates which resource failed</li>\n</ul>\n</li>\n<li><strong>Test Lock Recovery:</strong> Start an apply, kill process, verify lock is stale-detected after timeout.</li>\n</ol>\n<p><strong>Expected Behavior:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>$ python -m iac_engine plan invalid_config.hcl\nERROR: Configuration error in invalid_config.hcl:10\n  Undefined variable &quot;vpc_id&quot; referenced in resource &quot;aws_instance.web&quot;\n  Hint: Define variable in variables.tf or pass with -var flag</code></pre></div>\n\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Plan shows no changes</strong></td>\n<td>State file out of sync with actual cloud</td>\n<td>Run <code>refresh_state</code> on all resources, compare with state file</td>\n<td>Implement state refresh before planning</td>\n</tr>\n<tr>\n<td><strong>Lock never released</strong></td>\n<td>Process crashed without cleanup</td>\n<td>Check lock file timestamp, if &gt;10 min old</td>\n<td>Implement stale lock detection in <code>acquire_lock</code></td>\n</tr>\n<tr>\n<td><strong>Apply hangs forever</strong></td>\n<td>Infinite retry loop or waiting for consistency</td>\n<td>Check logs for repeated &quot;retrying&quot; messages</td>\n<td>Add max attempt limit, progressive polling timeout</td>\n</tr>\n<tr>\n<td><strong>State file corrupted</strong></td>\n<td>Process killed during write</td>\n<td>Check for <code>.tmp</code> files in state directory</td>\n<td>Use <code>write_atomic_json</code> with temp file + rename</td>\n</tr>\n<tr>\n<td><strong>Cycle detected error</strong></td>\n<td>Circular dependency in config</td>\n<td>Run <code>build_graph</code> with debug output</td>\n<td>Redesign config to break cycle, use explicit <code>depends_on</code></td>\n</tr>\n<tr>\n<td><strong>Resource disappears after create</strong></td>\n<td>Eventual consistency not handled</td>\n<td>Check timestamps: create succeeded but immediate read failed</td>\n<td>Implement read-after-write polling in <code>create</code> method</td>\n</tr>\n</tbody></table>\n<h2 id=\"testing-strategy\">Testing Strategy</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 1, 2, 3, 4</p>\n</blockquote>\n<p>A robust testing strategy is essential for an IaC engine due to the high stakes of infrastructure changes—a bug could cause service outages, security vulnerabilities, or costly cloud resource waste. This section outlines a comprehensive verification approach combining automated tests at multiple levels with manual verification checkpoints for each milestone. The goal is to build confidence that each component behaves correctly in isolation and that the integrated system safely orchestrates infrastructure changes.</p>\n<h3 id=\"testing-approaches-and-tools\">Testing Approaches and Tools</h3>\n<p>The testing strategy follows the <strong>testing pyramid</strong>, emphasizing many fast, isolated unit tests at the base, fewer integration tests in the middle, and a minimal number of slow, realistic end-to-end tests at the top. This balances thoroughness with execution speed, enabling rapid development cycles while catching complex interaction bugs.</p>\n<h4 id=\"unit-testing\">Unit Testing</h4>\n<p>Unit tests verify the behavior of individual functions and classes in isolation, mocking all external dependencies. They should be fast, deterministic, and cover edge cases.</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>What to Unit Test</th>\n<th>Mocking Strategy</th>\n<th>Tools/Patterns</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Parser</strong></td>\n<td>Variable interpolation logic, module resolution, syntax validation</td>\n<td>Mock file system I/O for config loading</td>\n<td><code>unittest.mock</code> for patching <code>open</code>, <code>os.path</code>; parameterized tests for different HCL patterns</td>\n</tr>\n<tr>\n<td><strong>State Manager</strong></td>\n<td>Atomic file write logic, lock acquisition/release, diff computation</td>\n<td>Mock file operations and system calls for locks</td>\n<td><code>tempfile</code> for isolated test directories; mock <code>fcntl</code> or <code>msvcrt</code> for platform-specific locking</td>\n</tr>\n<tr>\n<td><strong>Planner</strong></td>\n<td>Dependency graph construction, cycle detection, topological sort</td>\n<td>Provide synthetic resource lists with known dependencies</td>\n<td>Graph algorithm verification with known DAGs and cyclic graphs; property-based testing for sort invariants</td>\n</tr>\n<tr>\n<td><strong>Provider/Executor</strong></td>\n<td>Retry logic, circuit breaker state transitions, action execution flow</td>\n<td>Mock cloud API calls with controlled responses</td>\n<td><code>unittest.mock</code> for provider methods; simulate API rate limits and transient failures</td>\n</tr>\n</tbody></table>\n<p>For unit testing, Python&#39;s built-in <code>unittest</code> framework combined with <code>pytest</code> for richer fixtures and parameterization is recommended. Use <code>hypothesis</code> for property-based testing of complex algorithms like topological sort, where you can verify that for any arbitrary DAG, the sort order respects all dependencies.</p>\n<h4 id=\"integration-testing\">Integration Testing</h4>\n<p>Integration tests verify that components work correctly together, with real implementations of some internal dependencies but external systems (like cloud APIs) still mocked.</p>\n<table>\n<thead>\n<tr>\n<th>Integration Scope</th>\n<th>Test Focus</th>\n<th>Setup Required</th>\n<th>Validation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Parser → Planner</strong></td>\n<td>That parsed resources correctly feed into graph building</td>\n<td>Parse real config files from test fixtures</td>\n<td>Verify that implicit dependencies are extracted from attribute references</td>\n</tr>\n<tr>\n<td><strong>State Manager → Planner</strong></td>\n<td>That state diffs accurately reflect changes between configurations</td>\n<td>Create state files, modify configs, compute plan</td>\n<td>Plan actions should match expected CREATE/UPDATE/DELETE</td>\n</tr>\n<tr>\n<td><strong>Planner → Executor</strong></td>\n<td>That execution plan is correctly transformed into provider calls</td>\n<td>Mock providers, feed plan to executor</td>\n<td>Verify that provider methods are called in correct order with correct arguments</td>\n</tr>\n<tr>\n<td><strong>Full Pipeline (no cloud)</strong></td>\n<td>End-to-end flow from config to plan without actual provisioning</td>\n<td>All components with mocked providers</td>\n<td>Plan output should be predictable and safe (no unintended deletions)</td>\n</tr>\n</tbody></table>\n<p>A key integration testing pattern is the <strong>&quot;fake provider&quot;</strong>—a complete implementation of the <code>BaseProvider</code> interface that simulates a cloud API in memory. This allows testing the entire engine workflow without network calls or cloud costs. The fake provider maintains an in-memory resource store and can be programmed to simulate specific failures (timeouts, rate limits) to test error handling.</p>\n<h4 id=\"end-to-end-testing\">End-to-End Testing</h4>\n<p>End-to-end (E2E) tests run the actual engine against real cloud providers in a controlled, isolated environment (like a dedicated test cloud account). These tests are slow, expensive, and flaky due to cloud eventual consistency, so they should be minimal and focused on critical happy paths and failure recovery scenarios.</p>\n<table>\n<thead>\n<tr>\n<th>E2E Scenario</th>\n<th>Infrastructure Goal</th>\n<th>Success Criteria</th>\n<th>Cleanup</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Basic resource lifecycle</strong></td>\n<td>Create, update, delete a simple resource (e.g., S3 bucket)</td>\n<td>Resource exists with correct attributes after apply; gone after destroy</td>\n<td>Engine must destroy all test resources even if test fails</td>\n</tr>\n<tr>\n<td><strong>Dependency ordering</strong></td>\n<td>Create resources with dependencies (e.g., VPC before subnet)</td>\n<td>Resources created in correct order; deletion reverses order</td>\n<td>Verify deletion order via provider logs</td>\n</tr>\n<tr>\n<td><strong>Failure and recovery</strong></td>\n<td>Simulate partial apply failure (e.g., rate limit mid-operation)</td>\n<td>Engine stops gracefully; state is not corrupted; retry works</td>\n<td>Manual intervention may be needed for zombie resources</td>\n</tr>\n</tbody></table>\n<p>For E2E tests, use cloud provider sandbox accounts with tight budget controls and automatic cleanup via tagged resources. Run these tests only in the main branch or release candidates, not on every pull request.</p>\n<h4 id=\"mocking-cloud-apis\">Mocking Cloud APIs</h4>\n<p>Comprehensive mocking is essential for reliable, fast tests. Two complementary approaches are recommended:</p>\n<p><strong>1. Ad-hoc mocking with <code>unittest.mock</code>:</strong> Suitable for unit and integration tests where you control the exact sequence of calls. You can mock individual methods of a provider to return specific responses or raise exceptions.</p>\n<p><strong>2. Structured fake provider:</strong> A full in-memory implementation that mimics cloud API behavior, including:</p>\n<ul>\n<li>Resource storage with unique identifiers</li>\n<li>Basic validation (required attributes)</li>\n<li>Simulated eventual consistency (delayed visibility of updates)</li>\n<li>Configurable failure modes (error rates, latency)</li>\n</ul>\n<p>The fake provider can be shared across tests and even used as a teaching tool to understand how the engine interacts with providers.</p>\n<blockquote>\n<p><strong>Decision: Fake Provider over HTTP API Mock</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to test provider interactions without network calls. While HTTP mocks (like <code>responses</code> or <code>httpretty</code>) can intercept requests, they tie tests to specific HTTP details.</li>\n<li><strong>Options Considered</strong>: <ol>\n<li><strong>HTTP-level mocking</strong>: Intercept HTTP requests to cloud APIs.</li>\n<li><strong>Fake provider</strong>: Implement the <code>BaseProvider</code> interface with in-memory storage.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement a fake provider.</li>\n<li><strong>Rationale</strong>: The fake provider operates at the same abstraction level as real providers (the <code>BaseProvider</code> interface), making tests more resilient to changes in HTTP libraries or API endpoints. It&#39;s also faster (no network stack) and can simulate higher-level behaviors like eventual consistency more naturally.</li>\n<li><strong>Consequences</strong>: Tests are more portable and focused on business logic, but the fake provider must be maintained alongside real providers. It may not catch protocol-specific bugs (e.g., authentication headers).</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTP-level mocking (e.g., <code>responses</code>)</td>\n<td>Catches HTTP-level bugs; works with any HTTP client</td>\n<td>Tied to specific HTTP library; verbose to set up; misses interface logic</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Fake provider (in-memory)</td>\n<td>Matches abstraction level; fast; can simulate complex behaviors</td>\n<td>Requires maintenance; may drift from real provider behavior</td>\n<td>Yes</td>\n</tr>\n</tbody></table>\n<h3 id=\"milestone-checkpoints-and-verification\">Milestone Checkpoints and Verification</h3>\n<p>Each milestone has specific deliverables that should be verified through both automated tests and manual commands. Below are checkpoints for each milestone, including what to test, how to test it, and commands to run for verification.</p>\n<h4 id=\"milestone-1-configuration-parser\">Milestone 1: Configuration Parser</h4>\n<p>The parser must correctly interpret configuration files, resolve variables, and expand modules into a flat list of resources.</p>\n<p><strong>Automated Test Coverage:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Functionality</th>\n<th>Test Cases</th>\n<th>Expected Outcome</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Basic parsing</strong></td>\n<td>Simple HCL/YAML with one resource</td>\n<td>Returns list with one <code>Resource</code> with correct <code>type</code>, <code>name</code>, <code>attributes</code></td>\n</tr>\n<tr>\n<td><strong>Variable interpolation</strong></td>\n<td>Config with <code>${var.name}</code> references</td>\n<td>Variables replaced with actual values from var files or CLI</td>\n</tr>\n<tr>\n<td><strong>Module resolution</strong></td>\n<td>Config with <code>module &quot;x&quot;</code> block</td>\n<td>Module resources are loaded and merged into main resource list</td>\n</tr>\n<tr>\n<td><strong>Error handling</strong></td>\n<td>Invalid syntax, missing variables, circular module references</td>\n<td>Raises <code>ConfigurationError</code> with clear message</td>\n</tr>\n</tbody></table>\n<p><strong>Manual Verification Checklist:</strong></p>\n<ol>\n<li><strong>Create a test configuration</strong> (<code>test.tf</code>):</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">hcl</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   variable</span><span style=\"color:#79B8FF\"> \"instance_type\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     default</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"t2.micro\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   resource</span><span style=\"color:#79B8FF\"> \"aws_instance\"</span><span style=\"color:#79B8FF\"> \"web\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     instance_type</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> var</span><span style=\"color:#F97583\">.</span><span style=\"color:#E1E4E8\">instance_type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     ami</span><span style=\"color:#F97583\">           =</span><span style=\"color:#9ECBFF\"> \"ami-123456\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Run the parser from a Python shell or temporary script:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   from</span><span style=\"color:#E1E4E8\"> parser </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> process_configuration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   resources </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> process_configuration(Path(</span><span style=\"color:#9ECBFF\">\"test.tf\"</span><span style=\"color:#E1E4E8\">), [], {})</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">   print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Found </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(resources)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> resources\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   for</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> resources:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">       print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"  </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">r.type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">r.name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">r.attributes</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><p><strong>Verify output:</strong></p>\n<ul>\n<li>Should print exactly 1 resource: <code>aws_instance.web</code></li>\n<li>Attribute <code>instance_type</code> should be <code>&quot;t2.micro&quot;</code> (resolved variable)</li>\n<li>Attribute <code>ami</code> should be <code>&quot;ami-123456&quot;</code></li>\n</ul>\n</li>\n<li><p><strong>Test variable precedence:</strong> Pass a different <code>instance_type</code> via CLI variables dict and confirm it overrides the default.</p>\n</li>\n<li><p><strong>Test module loading:</strong> Create a module directory and reference it; verify its resources appear in the output.</p>\n</li>\n</ol>\n<p><strong>Command to run unit tests:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">pytest</span><span style=\"color:#9ECBFF\"> tests/unit/test_parser.py</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n<p>Expected: All tests pass, with &gt;80% line coverage for parser module.</p>\n<h4 id=\"milestone-2-state-manager\">Milestone 2: State Manager</h4>\n<p>The state manager must reliably read/write state files, handle locking, and compute accurate diffs.</p>\n<p><strong>Automated Test Coverage:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Functionality</th>\n<th>Test Cases</th>\n<th>Expected Outcome</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Atomic writes</strong></td>\n<td>Simulate crash during write (e.g., kill process)</td>\n<td>State file remains intact; backup is used for recovery</td>\n</tr>\n<tr>\n<td><strong>Locking</strong></td>\n<td>Concurrent lock attempts from different processes</td>\n<td>Only one acquires lock; others timeout or wait</td>\n</tr>\n<tr>\n<td><strong>Diff computation</strong></td>\n<td>Various desired vs. current state scenarios</td>\n<td>Correct <code>PlanAction</code> types (CREATE, UPDATE, DELETE, NOOP)</td>\n</tr>\n<tr>\n<td><strong>Remote backend</strong></td>\n<td>Mock S3/GCS operations</td>\n<td>State can be read from/written to remote location</td>\n</tr>\n</tbody></table>\n<p><strong>Manual Verification Checklist:</strong></p>\n<ol>\n<li><strong>Create an initial state file</strong> (<code>state.json</code>) with one resource:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">json</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">   {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     \"aws_instance.web\"</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">       \"resource_id\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"i-123456\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">       \"resource_type\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"aws_instance\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">       \"resource_name\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"web\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">       \"attributes\"</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#79B8FF\">\"instance_type\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"t2.micro\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">\"ami\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"ami-123456\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">       \"dependencies\"</span><span style=\"color:#E1E4E8\">: []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Test reading and writing:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   from</span><span style=\"color:#E1E4E8\"> state_manager </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> read_state, write_state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> read_state(Path(</span><span style=\"color:#9ECBFF\">\"state.json\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">   print</span><span style=\"color:#E1E4E8\">(state[</span><span style=\"color:#9ECBFF\">\"aws_instance.web\"</span><span style=\"color:#E1E4E8\">][</span><span style=\"color:#9ECBFF\">\"attributes\"</span><span style=\"color:#E1E4E8\">][</span><span style=\"color:#9ECBFF\">\"instance_type\"</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Modify</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   state[</span><span style=\"color:#9ECBFF\">\"aws_instance.web\"</span><span style=\"color:#E1E4E8\">][</span><span style=\"color:#9ECBFF\">\"attributes\"</span><span style=\"color:#E1E4E8\">][</span><span style=\"color:#9ECBFF\">\"instance_type\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"t2.small\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   write_state(Path(</span><span style=\"color:#9ECBFF\">\"state.json\"</span><span style=\"color:#E1E4E8\">), state)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Verify file updated atomically (check .bak file exists)</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><p><strong>Test locking:</strong> In two separate terminal sessions, attempt to acquire a lock on the same file. The first should succeed; the second should timeout after 30 seconds.</p>\n</li>\n<li><p><strong>Test diff:</strong> Create a desired resource list that changes the <code>instance_type</code> and adds a new resource. Call <code>compute_diff</code> and verify it returns an UPDATE for the instance and a CREATE for the new resource.</p>\n</li>\n</ol>\n<p><strong>Command to run unit tests:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">pytest</span><span style=\"color:#9ECBFF\"> tests/unit/test_state_manager.py</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n<p>Expected: Tests pass, including a test that verifies atomic write by simulating a power failure (writing a large state file and interrupting the process).</p>\n<h4 id=\"milestone-3-planner-dependency-graph-amp-planning\">Milestone 3: Planner (Dependency Graph &amp; Planning)</h4>\n<p>The planner must construct a correct DAG, detect cycles, and generate a safe execution plan.</p>\n<p><strong>Automated Test Coverage:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Functionality</th>\n<th>Test Cases</th>\n<th>Expected Outcome</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Graph construction</strong></td>\n<td>Resources with explicit <code>depends_on</code> and implicit references</td>\n<td>Graph edges created in both directions</td>\n</tr>\n<tr>\n<td><strong>Cycle detection</strong></td>\n<td>Resources with circular dependencies</td>\n<td><code>validate_acyclic</code> returns <code>False</code> or raises exception</td>\n</tr>\n<tr>\n<td><strong>Topological sort</strong></td>\n<td>Valid DAG with known dependency order</td>\n<td>Sort order respects all dependencies</td>\n</tr>\n<tr>\n<td><strong>Plan generation</strong></td>\n<td>Various state diffs</td>\n<td>Plan actions are in correct order (CREATE/UPDATE before DELETE when replacing)</td>\n</tr>\n</tbody></table>\n<p><strong>Manual Verification Checklist:</strong></p>\n<ol>\n<li><p><strong>Create a simple dependency scenario:</strong> Two resources where a subnet depends on a VPC (reference in attributes or explicit <code>depends_on</code>).</p>\n</li>\n<li><p><strong>Build graph and validate:</strong></p>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   from</span><span style=\"color:#E1E4E8\"> planner </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> build_graph, validate_acyclic, topological_sort</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   graph </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> build_graph(resources, current_state)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">   print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Graph has </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(graph)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> nodes\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   if</span><span style=\"color:#E1E4E8\"> validate_acyclic(graph):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       order </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> topological_sort(graph)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">       print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Execution order: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">order</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">       print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Cycle detected!\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><p><strong>Verify execution order:</strong> The VPC should appear before the subnet in the sorted list.</p>\n</li>\n<li><p><strong>Generate a plan:</strong> Use the diff from Milestone 2 and the sorted order to generate a plan. Print the plan and verify actions are in the correct order.</p>\n</li>\n<li><p><strong>Test cycle detection:</strong> Intentionally create a circular dependency (A depends on B, B depends on A). The validator should catch it.</p>\n</li>\n</ol>\n<p><strong>Command to run unit tests:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">pytest</span><span style=\"color:#9ECBFF\"> tests/unit/test_planner.py</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n<p>Expected: All tests pass, including a property-based test that for any random DAG, the topological sort produces a valid linear ordering.</p>\n<h4 id=\"milestone-4-provider-abstraction-amp-executor\">Milestone 4: Provider Abstraction &amp; Executor</h4>\n<p>The provider interface must be implemented correctly, and the executor must apply plans with retries and error handling.</p>\n<p><strong>Automated Test Coverage:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Functionality</th>\n<th>Test Cases</th>\n<th>Expected Outcome</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Provider CRUD</strong></td>\n<td>Mock API calls for each operation</td>\n<td>Methods return appropriate <code>Resource</code> or success indicator</td>\n</tr>\n<tr>\n<td><strong>Retry logic</strong></td>\n<td>Simulate transient failures (timeouts, 5xx errors)</td>\n<td>Operation retries with exponential backoff, eventually succeeds</td>\n</tr>\n<tr>\n<td><strong>Circuit breaker</strong></td>\n<td>Repeated provider failures</td>\n<td>Circuit opens after threshold, fails fast, resets after timeout</td>\n</tr>\n<tr>\n<td><strong>Executor flow</strong></td>\n<td>Plan with multiple actions, some failing</td>\n<td>Executor applies successful actions, updates state, reports partial failure</td>\n</tr>\n</tbody></table>\n<p><strong>Manual Verification Checklist:</strong></p>\n<ol>\n<li><p><strong>Implement a mock provider:</strong> Create a simple in-memory provider (e.g., <code>MockProvider</code>) that stores resources in a dict. Test each CRUD method.</p>\n</li>\n<li><p><strong>Test retry decorator:</strong> Apply <code>@retry_with_backoff</code> to a function that fails 3 times then succeeds. Verify it retries exactly 3 times with increasing delays.</p>\n</li>\n<li><p><strong>Test circuit breaker:</strong> Create a function that always fails. Use <code>CircuitBreaker</code> to call it; after N failures, subsequent calls should immediately raise <code>CircuitOpenError</code>.</p>\n</li>\n<li><p><strong>End-to-end integration test:</strong></p>\n<ul>\n<li>Parse a config.</li>\n<li>Read empty state (no resources).</li>\n<li>Generate a plan (should be all CREATEs).</li>\n<li>Execute the plan using the mock provider.</li>\n<li>Verify state file now contains the resources with correct IDs from the mock provider.</li>\n</ul>\n</li>\n</ol>\n<p><strong>Command to run unit tests:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">pytest</span><span style=\"color:#9ECBFF\"> tests/unit/test_provider.py</span><span style=\"color:#9ECBFF\"> tests/unit/test_executor.py</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n<p>Expected: All tests pass, including an integration test that runs a full <code>apply_command</code> with a mock provider and verifies the final state.</p>\n<h4 id=\"integrated-system-verification\">Integrated System Verification</h4>\n<p>After completing all milestones, run the full test suite and perform a manual smoke test:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run all unit and integration tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pytest</span><span style=\"color:#9ECBFF\"> tests/</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#79B8FF\"> --cov=iac_engine</span><span style=\"color:#79B8FF\"> --cov-report=html</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: >90% total coverage, all tests pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Smoke test: plan and apply a simple configuration</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> iac_engine</span><span style=\"color:#9ECBFF\"> plan</span><span style=\"color:#9ECBFF\"> test_configs/simple.tf</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> iac_engine</span><span style=\"color:#9ECBFF\"> apply</span><span style=\"color:#9ECBFF\"> test_configs/simple.tf</span><span style=\"color:#79B8FF\"> --auto-approve</span></span></code></pre></div>\n\n<p>The smoke test should show a plan with the expected changes and apply them successfully, updating the state file.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"a-technology-recommendations\">A. Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Testing Framework</td>\n<td><code>pytest</code> + <code>unittest.mock</code></td>\n<td><code>pytest</code> with <code>pytest-asyncio</code> for async tests</td>\n</tr>\n<tr>\n<td>HTTP Mocking</td>\n<td><code>requests-mock</code> for <code>requests</code>-based providers</td>\n<td><code>aioresponses</code> for async HTTP clients</td>\n</tr>\n<tr>\n<td>Property-based Testing</td>\n<td><code>hypothesis</code> for generating test cases</td>\n<td>Custom generators for complex resource graphs</td>\n</tr>\n<tr>\n<td>Coverage Reporting</td>\n<td><code>pytest-cov</code> for coverage reports</td>\n<td>Integrate with Codecov or Coveralls for CI</td>\n</tr>\n<tr>\n<td>End-to-End Testing</td>\n<td>Manual scripts with cleanup tags</td>\n<td>Automated using Terraform&#39;s testing framework as inspiration</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>iac_engine/\n  src/\n    iac_engine/\n      parser/           # Milestone 1\n        __init__.py\n        parser.py\n        resolver.py\n        module_loader.py\n      state/            # Milestone 2\n        __init__.py\n        manager.py\n        lock.py\n        backends.py\n      planner/          # Milestone 3\n        __init__.py\n        graph.py\n        plan.py\n      providers/        # Milestone 4\n        __init__.py\n        base.py\n        executor.py\n        retry.py\n        circuit_breaker.py\n        aws/            # Example provider implementation\n          __init__.py\n          ec2.py\n        mock/           # Fake provider for testing\n          __init__.py\n          provider.py\n      cli.py            # CLI entry point\n      exceptions.py     # IaCError and subclasses\n  tests/\n    unit/\n      test_parser.py\n      test_state_manager.py\n      test_planner.py\n      test_providers.py\n      test_executor.py\n    integration/\n      test_parser_integration.py\n      test_plan_generation.py\n      test_full_workflow.py\n    fixtures/           # Sample configs, state files\n      configs/\n        simple.tf\n        with_modules/\n      state/\n        empty.json\n        simple.json\n    conftest.py         # Shared pytest fixtures</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p><strong>Fake Provider for Testing (Complete Implementation):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tests/fake_provider.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> iac_engine.providers.base </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> BaseProvider, Resource</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> FakeProvider</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">BaseProvider</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"In-memory fake provider for testing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, provider_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.provider_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> provider_type</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.resources: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Resource] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}  </span><span style=\"color:#6A737D\"># resource_id -> Resource</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._next_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_credentials</span><span style=\"color:#E1E4E8\">(self, config: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Always valid for testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create</span><span style=\"color:#E1E4E8\">(self, resource: Resource) -> Resource:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Simulate creation with a generated ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        resource_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.provider_type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">-</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">._next_id</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._next_id </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Store the resource with its ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        resource.attributes[</span><span style=\"color:#9ECBFF\">\"id\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> resource_id</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.resources[resource_id] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> resource</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Simulate eventual consistency by not immediately returning</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # (in real tests, you might add a delay flag)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> resource</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> read</span><span style=\"color:#E1E4E8\">(self, resource_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, resource_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[Resource]:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.resources.get(resource_id)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> update</span><span style=\"color:#E1E4E8\">(self, resource_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, resource: Resource) -> Resource:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> resource_id </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.resources:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> KeyError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Resource </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">resource_id</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> not found\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Update attributes</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.resources[resource_id].attributes.update(resource.attributes)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.resources[resource_id]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> delete</span><span style=\"color:#E1E4E8\">(self, resource_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, resource_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> resource_id </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.resources:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            del</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.resources[resource_id]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> False</span></span></code></pre></div>\n\n<p><strong>Retry Decorator (Complete Implementation):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/iac_engine/providers/retry.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> random</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> functools </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> wraps</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Callable, Type, Tuple, Any</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> retry_with_backoff</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_attempts: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    base_delay: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_delay: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 10.0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    jitter: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    exceptions: Tuple[Type[</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">...</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">,)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Decorator that retries a function with exponential backoff.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        max_attempts: Maximum number of attempts (including first)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        base_delay: Base delay in seconds for exponential backoff</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        max_delay: Maximum delay in seconds</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        jitter: If True, add random jitter to delays</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        exceptions: Tuple of exception types to catch and retry on</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> decorator</span><span style=\"color:#E1E4E8\">(func: Callable) -> Callable:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        @wraps</span><span style=\"color:#E1E4E8\">(func)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        def</span><span style=\"color:#B392F0\"> wrapper</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            attempts </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            while</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    attempts </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    return</span><span style=\"color:#E1E4E8\"> func(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                except</span><span style=\"color:#E1E4E8\"> exceptions </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#E1E4E8\"> attempts </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> max_attempts:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        raise</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Calculate delay with exponential backoff</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    delay </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> min</span><span style=\"color:#E1E4E8\">(base_delay </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\"> **</span><span style=\"color:#E1E4E8\"> (attempts </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)), max_delay)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Add jitter (up to 25% of delay)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#E1E4E8\"> jitter:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        delay </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> delay </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">0.75</span><span style=\"color:#F97583\"> +</span><span style=\"color:#79B8FF\"> 0.25</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> random.random())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    time.sleep(delay)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> wrapper</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> decorator</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong>Test for Dependency Graph Construction:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tests/unit/test_planner.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> pytest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> iac_engine.planner.graph </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> build_graph, validate_acyclic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> iac_engine.parser </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Resource</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_build_graph_with_implicit_dependencies</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test that implicit dependencies are extracted from attribute references.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create two resources where resource B references resource A</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   resource_a = Resource(type=\"aws_vpc\", name=\"main\", attributes={\"id\": \"vpc-123\"})</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   resource_b = Resource(type=\"aws_subnet\", name=\"web\", attributes={\"vpc_id\": \"${aws_vpc.main.id}\"})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Build graph with these resources and empty state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify graph has two nodes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Verify edge exists from aws_subnet.web to aws_vpc.main</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   (subnet depends on vpc)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Validate graph is acyclic (should return True)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_cycle_detection</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test that circular dependencies are detected.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create three resources with circular dependency:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   A -> B (A depends on B)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   B -> C (B depends on C)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   C -> A (C depends on A)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Build graph</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Call validate_acyclic - should return False or raise exception</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Verify appropriate error message indicates cycle</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p><strong>Test for State Diff Computation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tests/unit/test_state_manager.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_compute_diff_scenarios</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test various diff scenarios: create, update, delete, noop.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Setup: Create a current_state dict with one resource</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Scenario CREATE: desired_resources has a new resource not in current_state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   Call compute_diff</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   Verify result contains PlanAction with action_type=CREATE for that resource</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Scenario UPDATE: desired_resources modifies an attribute of existing resource</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   Verify action_type=UPDATE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Scenario DELETE: desired_resources removes a resource present in current_state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   Verify action_type=DELETE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Scenario NOOP: resource identical in current and desired</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   Verify action_type=NOOP</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Edge case: resource with dependencies being deleted</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   Verify delete action includes proper dependency ordering consideration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ul>\n<li>Use <code>pytest.fixture</code> for shared test setup (e.g., temporary directories, mock providers).</li>\n<li>Use <code>@pytest.mark.parametrize</code> to test multiple input/output combinations for parsing functions.</li>\n<li>For testing file operations, use <code>tempfile.TemporaryDirectory()</code> to ensure cleanup.</li>\n<li>Mock time in tests involving retries or circuit breakers using <code>unittest.mock.patch(&#39;time.sleep&#39;)</code> and <code>unittest.mock.patch(&#39;time.time&#39;)</code>.</li>\n<li>Use <code>pytest.raises(Exception)</code> context manager to verify that expected exceptions are raised.</li>\n</ul>\n<h4 id=\"f-milestone-checkpoint-commands\">F. Milestone Checkpoint Commands</h4>\n<p>After implementing each milestone, run these commands to verify basic functionality:</p>\n<p><strong>Milestone 1:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run parser tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pytest</span><span style=\"color:#9ECBFF\"> tests/unit/test_parser.py</span><span style=\"color:#79B8FF\"> -xvs</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: All tests pass. If any fail, check:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Did you handle variable interpolation correctly? Use the resolver test.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Did you correctly parse nested blocks? Check the AST structure.</span></span></code></pre></div>\n\n<p><strong>Milestone 2:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run state manager tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pytest</span><span style=\"color:#9ECBFF\"> tests/unit/test_state_manager.py</span><span style=\"color:#79B8FF\"> -xvs</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Tests pass, including the atomic write test.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># If locking tests fail on Windows, you may need to adjust file locking implementation.</span></span></code></pre></div>\n\n<p><strong>Milestone 3:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run planner tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pytest</span><span style=\"color:#9ECBFF\"> tests/unit/test_planner.py</span><span style=\"color:#79B8FF\"> -xvs</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: All tests pass, including cycle detection.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># If topological sort fails, verify your graph construction first.</span></span></code></pre></div>\n\n<p><strong>Milestone 4:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run provider and executor tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pytest</span><span style=\"color:#9ECBFF\"> tests/unit/test_provider.py</span><span style=\"color:#9ECBFF\"> tests/unit/test_executor.py</span><span style=\"color:#79B8FF\"> -xvs</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Tests pass, including retry and circuit breaker tests.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># If executor tests fail, check that you're calling provider methods in correct order.</span></span></code></pre></div>\n\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Plan shows no changes when changes exist</strong></td>\n<td>Diff computation not detecting attribute changes</td>\n<td>Log desired vs. current attributes; check deep equality</td>\n<td>Ensure diff compares nested structures, not just top-level dict</td>\n</tr>\n<tr>\n<td><strong>Lock never released after crash</strong></td>\n<td>Heartbeat thread not stopped; lock file orphaned</td>\n<td>Check for stale <code>.lock</code> file; verify <code>LockHandle.cleanup()</code> called</td>\n<td>Implement lock stale detection; add timeout to lock acquisition</td>\n</tr>\n<tr>\n<td><strong>Cycle detected in valid config</strong></td>\n<td>Over-eager implicit dependency detection</td>\n<td>Log extracted references; visualize graph</td>\n<td>Limit implicit dependencies to actual attribute references, not all strings</td>\n</tr>\n<tr>\n<td><strong>Provider retries exhausting but shouldn&#39;t</strong></td>\n<td>Non-transient exception being caught</td>\n<td>Check exception hierarchy; log exception types</td>\n<td>Ensure <code>TransientProviderError</code> is raised for retryable errors only</td>\n</tr>\n<tr>\n<td><strong>State file corrupted after partial write</strong></td>\n<td>Non-atomic write interrupted</td>\n<td>Check for <code>.bak</code> file; verify <code>write_atomic_json</code> renames after write</td>\n<td>Use <code>tempfile.NamedTemporaryFile</code> with <code>os.replace</code> for atomicity</td>\n</tr>\n<tr>\n<td><strong>Executor creates resources in wrong order</strong></td>\n<td>Topological sort incorrect or graph edges reversed</td>\n<td>Print dependency graph and sort order; verify edges point from dependent to dependency</td>\n<td>Ensure <code>depends_on</code> and implicit refs create edge <code>dependent -&gt; dependency</code></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 1, 2, 3, 4 (cross-cutting)</p>\n</blockquote>\n<p>This section provides a comprehensive guide to diagnosing and resolving common issues you&#39;ll encounter while implementing the Infrastructure as Code engine. Debugging distributed infrastructure management requires systematic thinking—you need to understand where in the pipeline a failure occurred and how different components interact. Think of debugging as being a <strong>forensic investigator</strong> examining a crime scene: you collect evidence (logs, state files), reconstruct events (execution sequences), and identify the culprit (buggy code or unexpected conditions).</p>\n<h3 id=\"common-bugs-symptom-cause-fix\">Common Bugs: Symptom → Cause → Fix</h3>\n<p>The following table catalogs the most frequent issues you&#39;ll encounter during implementation, organized by component area. Each entry follows the pattern of observed symptom, root cause, and concrete fix.</p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Component</th>\n<th>Root Cause</th>\n<th>Diagnostic Steps</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>&quot;Plan shows no changes&quot;</strong> when resources should be created</td>\n<td>Planner or State Manager</td>\n<td>1. <strong>State file corruption</strong>: The state file contains invalid data that doesn&#39;t match the parsed resources.<br>2. <strong>Incorrect diff logic</strong>: <code>compute_diff</code> returns <code>ActionType.NOOP</code> for resources that differ.<br>3. <strong>Variable interpolation mismatch</strong>: Variables resolve differently between runs, causing different resource addresses.</td>\n<td>1. Examine the state file with <code>cat state.json</code> - look for missing or malformed <code>StateRecord</code> entries.<br>2. Add debug logging to <code>compute_diff</code> to compare <code>desired_attributes</code> vs <code>current_attributes</code>.<br>3. Run <code>process_configuration</code> in isolation and inspect the resolved <code>Resource.attributes</code>.</td>\n<td>1. Use <code>read_json_with_backup</code> to restore from backup if corruption is detected.<br>2. Ensure <code>compute_diff</code> compares all attributes, not just a subset.<br>3. Verify variable resolution produces consistent values across runs.</td>\n</tr>\n<tr>\n<td><strong>&quot;Cycle detected&quot;</strong> error during plan generation</td>\n<td>Planner</td>\n<td>1. <strong>Circular dependency</strong>: Resource A depends on B, and B depends on A via explicit <code>depends_on</code> or implicit references.<br>2. <strong>Self-reference</strong>: A resource references its own attribute (e.g., <code>name = &quot;${self.id}&quot;</code>).<br>3. <strong>Transitive cycle</strong>: A → B → C → A forms a three-way cycle.</td>\n<td>1. Run <code>validate_acyclic</code> with debug output to print the cycle.<br>2. Inspect the <code>DependencyGraphNode.depends_on</code> for each resource in the suspected cycle.<br>3. Check for implicit dependencies from attribute references that create unintended edges.</td>\n<td>1. Review configuration and break the cycle by removing unnecessary <code>depends_on</code>.<br>2. For implicit cycles, consider using <code>ignore_changes</code> meta-argument or restructure resources.<br>3. Implement cycle detection that suggests which dependency to remove.</td>\n</tr>\n<tr>\n<td><strong>&quot;Lock never released&quot;</strong> - subsequent operations hang</td>\n<td>State Manager</td>\n<td>1. <strong>Process crash without cleanup</strong>: The previous process acquired a lock but crashed before calling <code>release_lock</code>.<br>2. <strong>Heartbeat thread deadlock</strong>: The <code>heartbeat_thread</code> is blocked or not updating the lock timestamp.<br>3. <strong>Stale lock detection timeout too long</strong>: Default timeout (e.g., 300 seconds) hasn&#39;t expired yet.</td>\n<td>1. Check lock file timestamp: <code>stat -c %y .terraform.lock</code>.<br>2. Verify if the locking process is still running: <code>ps -p &lt;process_id&gt;</code>.<br>3. Examine lock file contents for <code>process_id</code> and <code>lock_id</code>.</td>\n<td>1. Implement stale lock detection in <code>acquire_lock</code> - if lock is older than timeout, forcibly acquire.<br>2. Ensure <code>LockHandle.heartbeat_thread</code> properly updates timestamp with file atomic writes.<br>3. Add a <code>force-unlock</code> CLI command to manually remove stale locks.</td>\n</tr>\n<tr>\n<td><strong>&quot;Variable not found&quot;</strong> during parsing</td>\n<td>Configuration Parser</td>\n<td>1. <strong>Variable defined in wrong scope</strong>: Variable defined in child module but referenced in parent.<br>2. <strong>Variable file not loaded</strong>: <code>-var-file</code> not passed or file missing.<br>3. <strong>Interpolation syntax error</strong>: <code>${var. name}</code> has extra space or malformed expression.</td>\n<td>1. Print the variable resolution stack trace during <code>resolve_variables</code>.<br>2. List all loaded variable files and CLI variables before resolution.<br>3. Check raw AST for variable block locations vs reference locations.</td>\n<td>1. Ensure variable resolution searches parent scopes for definitions.<br>2. Implement fallback to environment variables for missing variables.<br>3. Validate interpolation syntax during parsing, not just resolution.</td>\n</tr>\n<tr>\n<td><strong>&quot;Provider not found&quot;</strong> when applying plan</td>\n<td>Executor/Provider SDK</td>\n<td>1. <strong>Provider plugin not installed</strong>: The required provider (e.g., <code>aws</code>) isn&#39;t in the plugins directory.<br>2. <strong>Provider configuration missing</strong>: No <code>provider &quot;aws&quot;</code> block with required <code>region</code> and <code>access_key</code>.<br>3. <strong>Provider initialization error</strong>: <code>validate_credentials</code> fails due to invalid credentials.</td>\n<td>1. Check <code>ProviderConfig.provider_type</code> matches available provider classes.<br>2. Verify <code>ProviderConfig.config</code> contains all required fields.<br>3. Test credentials independently (e.g., <code>aws sts get-caller-identity</code>).</td>\n<td>1. Implement provider plugin discovery scanning a <code>plugins/</code> directory.<br>2. Validate provider configuration during parsing, not just at execution.<br>3. Provide clear error messages including which field is missing.</td>\n</tr>\n<tr>\n<td><strong>Resource stuck in &quot;Creating...&quot;</strong> forever</td>\n<td>Executor/Provider</td>\n<td>1. <strong>Eventual consistency delay</strong>: Cloud API returns success but resource isn&#39;t immediately available.<br>2. <strong>Missing async polling</strong>: Provider <code>create</code> doesn&#39;t wait for resource to reach ready state.<br>3. <strong>Timeout too short</strong>: The polling timeout (e.g., 5 minutes) is less than cloud provisioning time.</td>\n<td>1. Check provider logs for API response - look for <code>pending</code> or <code>in-progress</code> status.<br>2. Verify <code>refresh_state</code> is called after <code>create</code> and what state it returns.<br>3. Monitor cloud console manually to see actual resource status.</td>\n<td>1. Implement exponential backoff polling in provider <code>create</code> method.<br>2. Increase timeout for slow resources (databases, VPCs).<br>3. Add progress indicators showing polling attempts.</td>\n</tr>\n<tr>\n<td><strong>Partial apply failure leaves &quot;zombie resources&quot;</strong></td>\n<td>Executor</td>\n<td>1. <strong>State not updated on failure</strong>: Resource created successfully but error in subsequent step prevents <code>write_state</code>.<br>2. <strong>No rollback on error</strong>: The executor doesn&#39;t clean up successfully created resources when later resources fail.<br>3. <strong>Inconsistent state file</strong>: Partial write due to crash during <code>write_state</code>.</td>\n<td>1. Compare state file with actual cloud resources using provider <code>read</code>.<br>2. Check for <code>PartialApplyError.succeeded_resources</code> to see what was created.<br>3. Look for <code>write_atomic_json</code> temporary files left in directory.</td>\n<td>1. Implement two-phase state update: write intermediate state after each successful resource.<br>2. Add <code>-auto-approve=false</code> default to prevent accidental zombie creation.<br>3. Use backup state file that&#39;s only updated after full successful apply.</td>\n</tr>\n<tr>\n<td><strong>&quot;Invalid interpolation&quot;</strong> in count or for_each</td>\n<td>Configuration Parser</td>\n<td>1. <strong>Chicken-egg problem</strong>: Variable used in <code>count</code> references another resource attribute that doesn&#39;t exist yet.<br>2. <strong>Type mismatch</strong>: <code>count</code> expects a number but receives a string or list.<br>3. <strong>Circular reference in count</strong>: Two resources&#39; counts depend on each other.</td>\n<td>1. Evaluate interpolation expressions in isolation to see their resolved value.<br>2. Check the type of the resolved variable (number vs string).<br>3. Build dependency graph including count references as edges.</td>\n<td>1. Implement two-pass parsing: first resolve static variables, then resolve dynamic ones.<br>2. Add type validation for <code>count</code> and <code>for_each</code> arguments.<br>3. Detect and reject circular count dependencies during graph building.</td>\n</tr>\n<tr>\n<td><strong>Graph topological sort returns different order each run</strong></td>\n<td>Planner</td>\n<td>1. <strong>Non-deterministic iteration over dictionary</strong>: Python&#39;s <code>dict</code> iteration order affects graph construction.<br>2. <strong>Missing dependency edge</strong>: Some resources have no dependencies, creating multiple valid topological orders.<br>3. <strong>Graph nodes not sorted before algorithm</strong>: The algorithm picks arbitrary starting nodes.</td>\n<td>1. Print the adjacency list of the graph before sorting.<br>2. Run topological sort multiple times and compare outputs.<br>3. Check if all expected dependencies are captured (implicit vs explicit).</td>\n<td>1. Sort node IDs alphabetically before starting topological sort.<br>2. Ensure deterministic edge addition by sorting source and target nodes.<br>3. Document that multiple valid orders are possible when no dependencies exist.</td>\n</tr>\n<tr>\n<td><strong>Rate limit errors despite retry logic</strong></td>\n<td>Provider SDK</td>\n<td>1. <strong>No jitter in retry delays</strong>: All retries happen simultaneously across parallel requests.<br>2. <strong>Retry window too short</strong>: Exponential backoff max delay (e.g., 30s) less than rate limit window (e.g., 1 minute).<br>3. <strong>No circuit breaker</strong>: Repeated failures continue retrying indefinitely.</td>\n<td>1. Check timestamps of API calls in logs - are they evenly spaced?<br>2. Examine cloud provider rate limit headers (<code>Retry-After</code>, <code>X-RateLimit-Reset</code>).<br>3. Monitor circuit breaker state (open/closed/half-open).</td>\n<td>1. Add jitter to retry delays using <code>random.uniform(0.5 * delay, 1.5 * delay)</code>.<br>2. Respect <code>Retry-After</code> headers when present in error responses.<br>3. Implement circuit breaker that opens after N consecutive failures.</td>\n</tr>\n<tr>\n<td><strong>State file grows indefinitely with stale resources</strong></td>\n<td>State Manager</td>\n<td>1. <strong>No state compaction</strong>: Deleted resources remain in state as <code>tombstones</code> or with <code>ActionType.DELETE</code> records.<br>2. <strong>Multiple state versions kept</strong>: Backup mechanism never cleans up old backups.<br>3. <strong>Resource renaming creates duplicates</strong>: Old <code>Resource.id</code> remains while new one is added.</td>\n<td>1. Examine state file size over time - does it increase after each apply?<br>2. Count <code>StateRecord</code> entries for deleted resources (attributes null).<br>3. Check for duplicate resources with similar attributes.</td>\n<td>1. Implement state compaction after successful delete operations.<br>2. Add retention policy for backups (keep last N versions).<br>3. Add state validation that detects and removes orphaned resources.</td>\n</tr>\n<tr>\n<td><strong>Module source path resolution fails</strong></td>\n<td>Configuration Parser</td>\n<td>1. <strong>Relative path confusion</strong>: Module uses <code>../parent</code> but current working directory differs.<br>2. <strong>Git URL without ref</strong>: Module source is <code>github.com/org/module</code> without branch/tag.<br>3. <strong>Missing module cache</strong>: Module downloaded previously but cache cleared.</td>\n<td>1. Print the resolved absolute path for each module source.<br>2. Check if directory exists at the resolved path.<br>3. Verify module registry configuration (if using remote modules).</td>\n<td>1. Normalize all paths to absolute paths relative to configuration root.<br>2. Implement module cache with version locking (similar to Terraform&#39;s <code>.terraform/modules</code>).<br>3. Provide clear error including the resolved path that failed.</td>\n</tr>\n</tbody></table>\n<h3 id=\"debugging-techniques-and-tools\">Debugging Techniques and Tools</h3>\n<p>Effective debugging requires more than just reading error messages—you need a systematic approach to isolate issues. Think of these techniques as <strong>medical diagnostic tools</strong>: each reveals different aspects of the system&#39;s health.</p>\n<h4 id=\"strategic-logging-with-context-correlation\">Strategic Logging with Context Correlation</h4>\n<p>The most powerful debugging technique is comprehensive, structured logging. Instead of simple <code>print</code> statements, implement a logging system that:</p>\n<ol>\n<li><strong>Includes correlation IDs</strong>: Each operation (plan, apply) gets a unique ID logged with every message, making it easy to trace through components.</li>\n<li><strong>Uses log levels appropriately</strong>:<ul>\n<li><code>DEBUG</code>: Detailed internal state (attribute values, graph edges)</li>\n<li><code>INFO</code>: Major lifecycle events (resource created, plan generated)</li>\n<li><code>WARN</code>: Unexpected but recoverable conditions (falling back to default)</li>\n<li><code>ERROR</code>: Operation failures with stack traces</li>\n</ul>\n</li>\n<li><strong>Logs to structured formats</strong> (JSON) for machine parsing, with human-readable format for development.</li>\n</ol>\n<blockquote>\n<p><strong>Diagnostic Pattern</strong>: When you encounter an error, increase the log level to <code>DEBUG</code>, reproduce the issue, and search for the correlation ID in the log file. Follow the execution path through each component.</p>\n</blockquote>\n<h4 id=\"state-file-inspection-and-diffing\">State File Inspection and Diffing</h4>\n<p>The state file is the <strong>ground truth</strong> of your infrastructure. Learn to inspect it like a database:</p>\n<ol>\n<li><strong>Manual inspection</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Pretty-print the state</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   jq</span><span style=\"color:#9ECBFF\"> .</span><span style=\"color:#9ECBFF\"> terraform.tfstate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Count resources by type</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   jq</span><span style=\"color:#9ECBFF\"> '.resources | group_by(.type) | map({type: .[0].type, count: length})'</span><span style=\"color:#9ECBFF\"> terraform.tfstate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Find resources with specific attribute</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   jq</span><span style=\"color:#9ECBFF\"> '.resources[] | select(.attributes.name == \"web-server\")'</span><span style=\"color:#9ECBFF\"> terraform.tfstate</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>State diffs between runs</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Compare current state with backup</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   diff</span><span style=\"color:#79B8FF\"> -u</span><span style=\"color:#9ECBFF\"> &#x3C;(</span><span style=\"color:#B392F0\">jq</span><span style=\"color:#79B8FF\"> -S</span><span style=\"color:#9ECBFF\"> . terraform.tfstate)</span><span style=\"color:#9ECBFF\"> &#x3C;(</span><span style=\"color:#B392F0\">jq</span><span style=\"color:#79B8FF\"> -S</span><span style=\"color:#9ECBFF\"> . terraform.tfstate.backup)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Generate visual diff</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   git</span><span style=\"color:#9ECBFF\"> diff</span><span style=\"color:#79B8FF\"> --no-index</span><span style=\"color:#9ECBFF\"> terraform.tfstate.old</span><span style=\"color:#9ECBFF\"> terraform.tfstate.new</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>State validation script</strong>: Create a Python script that loads the state file and validates invariants (no duplicate IDs, all dependencies exist, attributes match schema).</li>\n</ol>\n<h4 id=\"graph-visualization-for-dependency-analysis\">Graph Visualization for Dependency Analysis</h4>\n<p>When dependency issues arise, visualize the graph to understand relationships:</p>\n<ol>\n<li><strong>Export graph to DOT format</strong> for Graphviz:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   def</span><span style=\"color:#B392F0\"> export_to_dot</span><span style=\"color:#E1E4E8\">(graph: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, DependencyGraphNode]) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">\"digraph G {\"</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       for</span><span style=\"color:#E1E4E8\"> node_id, node </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> graph.items():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">           for</span><span style=\"color:#E1E4E8\"> dep </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> node.depends_on:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               lines.append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">'  \"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">dep</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\" -> \"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">node_id</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\";'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       lines.append(</span><span style=\"color:#9ECBFF\">\"}\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       return</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">.join(lines)</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Render and view</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"from planner import build_graph; print(export_to_dot(graph))\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> graph.dot</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   dot</span><span style=\"color:#79B8FF\"> -Tpng</span><span style=\"color:#9ECBFF\"> graph.dot</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> graph.png</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   open</span><span style=\"color:#9ECBFF\"> graph.png</span><span style=\"color:#6A737D\">  # Or display on Linux</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Interactive visualization</strong> with network libraries (vis.js, D3.js) for complex graphs with 50+ nodes.</li>\n</ol>\n<h4 id=\"stepwise-execution-with-intermediate-dumps\">Stepwise Execution with Intermediate Dumps</h4>\n<p>When an algorithm fails (like topological sort), capture its intermediate state:</p>\n<ol>\n<li><strong>Add checkpoint debugging</strong> that saves state at key points:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   def</span><span style=\"color:#B392F0\"> topological_sort_with_debug</span><span style=\"color:#E1E4E8\">(graph):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       checkpoint </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       while</span><span style=\"color:#E1E4E8\"> nodes_with_zero_indegree:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           save_checkpoint(checkpoint, {</span><span style=\"color:#9ECBFF\">\"graph\"</span><span style=\"color:#E1E4E8\">: graph.copy(), </span><span style=\"color:#9ECBFF\">\"sorted\"</span><span style=\"color:#E1E4E8\">: sorted_nodes})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           checkpoint </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">           # ... algorithm continues</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Create a replay capability</strong> that loads checkpoint data and continues from that point, allowing you to test fixes without re-running the entire pipeline.</li>\n</ol>\n<h4 id=\"mock-provider-for-isolated-testing\">Mock Provider for Isolated Testing</h4>\n<p>When debugging provider issues, use a mock provider that simulates cloud APIs:</p>\n<ol>\n<li><strong>In-memory mock</strong> that stores resources in a dictionary, simulating eventual consistency with configurable delays.</li>\n<li><strong>Fault-injection mock</strong> that fails specific operations (create, update) at certain rates to test error handling.</li>\n<li><strong>Record/replay mock</strong> that captures real API calls during one run and replays them during tests, eliminating cloud dependencies.</li>\n</ol>\n<h4 id=\"time-travel-debugging-with-state-snapshots\">Time Travel Debugging with State Snapshots</h4>\n<p>For intermittent issues, implement a <strong>state snapshot</strong> system:</p>\n<ol>\n<li><strong>Automatic snapshots</strong> before each state-modifying operation.</li>\n<li><strong>Label snapshots</strong> with metadata (timestamp, operation ID, user).</li>\n<li><strong>Restore capability</strong> to roll back to any snapshot:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   iac-engine</span><span style=\"color:#9ECBFF\"> state</span><span style=\"color:#9ECBFF\"> restore</span><span style=\"color:#79B8FF\"> --snapshot-id</span><span style=\"color:#9ECBFF\"> plan-2023-10-05-14-30-00</span></span></code></pre></div>\n\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides concrete tools and code patterns to implement the debugging techniques described above.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Logging</strong></td>\n<td>Python <code>logging</code> module with JSON formatter</td>\n<td>Structured logging with <code>structlog</code> or <code>loguru</code> for context propagation</td>\n</tr>\n<tr>\n<td><strong>State Inspection</strong></td>\n<td><code>jq</code> command-line tool with Python wrapper</td>\n<td>Custom web UI with React + D3 for visual state exploration</td>\n</tr>\n<tr>\n<td><strong>Graph Visualization</strong></td>\n<td>Graphviz DOT format generation</td>\n<td>Interactive visualization with <code>pyvis</code> or <code>networkx</code> + <code>matplotlib</code></td>\n</tr>\n<tr>\n<td><strong>Debug UI</strong></td>\n<td>CLI with rich tables via <code>rich</code> or <code>textual</code></td>\n<td>Web dashboard with FastAPI + WebSocket for real-time updates</td>\n</tr>\n<tr>\n<td><strong>Snapshot Management</strong></td>\n<td>Directory of timestamped JSON files</td>\n<td>Dedicated versioned store with content-addressable hashing</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure-for-debugging-utilities\">Recommended File Structure for Debugging Utilities</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>iac-engine/\n  src/\n    iac/\n      debug/                    # Debugging utilities\n        __init__.py\n        logger.py               # Structured logging setup\n        state_inspector.py      # State file analysis tools\n        graph_exporter.py       # Graph visualization exports\n        snapshot_manager.py     # State snapshot management\n      cli/\n        commands/\n          debug.py              # Debug-specific CLI commands</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code-structured-logger\">Infrastructure Starter Code: Structured Logger</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/iac/debug/logger.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> uuid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, Dict, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> contextvars </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ContextVar</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Correlation ID for tracing requests across components</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">correlation_id: ContextVar[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ContextVar(</span><span style=\"color:#9ECBFF\">'correlation_id'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">''</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> JsonFormatter</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">logging</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Formatter</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Formats log records as JSON for machine parsing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> format</span><span style=\"color:#E1E4E8\">(self, record: logging.LogRecord) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        log_object </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'timestamp'</span><span style=\"color:#E1E4E8\">: datetime.utcfromtimestamp(record.created).isoformat() </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> 'Z'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'level'</span><span style=\"color:#E1E4E8\">: record.levelname,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'logger'</span><span style=\"color:#E1E4E8\">: record.name,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'message'</span><span style=\"color:#E1E4E8\">: record.getMessage(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'correlation_id'</span><span style=\"color:#E1E4E8\">: correlation_id.get(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'module'</span><span style=\"color:#E1E4E8\">: record.module,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'function'</span><span style=\"color:#E1E4E8\">: record.funcName,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'line'</span><span style=\"color:#E1E4E8\">: record.lineno,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Add extra fields if present</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> hasattr</span><span style=\"color:#E1E4E8\">(record, </span><span style=\"color:#9ECBFF\">'extra'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            log_object.update(record.extra)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Add exception info if present</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> record.exc_info:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            log_object[</span><span style=\"color:#9ECBFF\">'exception'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.formatException(record.exc_info)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> json.dumps(log_object)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> setup_logging</span><span style=\"color:#E1E4E8\">(level: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'INFO'</span><span style=\"color:#E1E4E8\">, json_format: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Configure logging for the IaC engine.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#9ECBFF\">'iac'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger.setLevel(</span><span style=\"color:#79B8FF\">getattr</span><span style=\"color:#E1E4E8\">(logging, level.upper()))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    handler </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.StreamHandler()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> json_format:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        handler.setFormatter(JsonFormatter())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Human-readable format for development</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        formatter </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.Formatter(</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            '</span><span style=\"color:#79B8FF\">%(asctime)s</span><span style=\"color:#9ECBFF\"> [</span><span style=\"color:#79B8FF\">%(correlation_id)s</span><span style=\"color:#9ECBFF\">] </span><span style=\"color:#79B8FF\">%(levelname)s</span><span style=\"color:#79B8FF\"> %(name)s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%(message)s</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            datefmt</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'%H:%M:%S'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        handler.setFormatter(formatter)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger.addHandler(handler)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Set correlation ID filter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    class</span><span style=\"color:#B392F0\"> CorrelationFilter</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">logging</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Filter</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        def</span><span style=\"color:#79B8FF\"> filter</span><span style=\"color:#E1E4E8\">(self, record: logging.LogRecord) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            record.correlation_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> correlation_id.get()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger.addFilter(CorrelationFilter())</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> log_operation</span><span style=\"color:#E1E4E8\">(operation: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">extra: Any) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Start a new operation with a correlation ID and log its beginning.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    op_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> str</span><span style=\"color:#E1E4E8\">(uuid.uuid4())[:</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    correlation_id.set(op_id)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#9ECBFF\">'iac'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger.info(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Starting </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">operation</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">extra</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">'operation'</span><span style=\"color:#E1E4E8\">: operation, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">extra})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> op_id</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Usage example:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># from iac.debug.logger import setup_logging, log_operation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># setup_logging(level='DEBUG')</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># op_id = log_operation('plan', config_path='main.tf')</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># # All subsequent logs will include this correlation_id</span></span></code></pre></div>\n\n<h4 id=\"infrastructure-starter-code-state-inspector\">Infrastructure Starter Code: State Inspector</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/iac/debug/state_inspector.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> pathlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> iac.state </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> StateRecord</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> StateReport</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Comprehensive analysis of a state file.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    total_resources: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resources_by_type: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    orphaned_resources: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#6A737D\"># Resources with missing dependencies</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    duplicate_addresses: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#6A737D\"># Multiple resources with same address</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    validation_errors: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_dict</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'total_resources'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.total_resources,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'resources_by_type'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.resources_by_type,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'orphaned_resources'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.orphaned_resources,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'duplicate_addresses'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.duplicate_addresses,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'validation_errors'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.validation_errors,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'is_valid'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.validation_errors) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> StateInspector</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Tools for analyzing and debugging state files.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> load_state</span><span style=\"color:#E1E4E8\">(state_path: Path) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Load state file with backup fallback.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        from</span><span style=\"color:#E1E4E8\"> iac.state </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> read_json_with_backup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> read_json_with_backup(state_path)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> analyze</span><span style=\"color:#E1E4E8\">(state_data: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> StateReport:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Perform comprehensive analysis of state data.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        resources </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> state_data.get(</span><span style=\"color:#9ECBFF\">'resources'</span><span style=\"color:#E1E4E8\">, [])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Count by type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        resources_by_type: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> resource </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> resources:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            rtype </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> resource.get(</span><span style=\"color:#9ECBFF\">'type'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'unknown'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            resources_by_type[rtype] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> resources_by_type.get(rtype, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Check for duplicates by address</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        addresses: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        duplicate_addresses: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> resource </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> resources:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">resource.get(</span><span style=\"color:#9ECBFF\">'type'</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">resource.get(</span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            addresses[addr] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> addresses.get(addr, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> addresses[addr] </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                duplicate_addresses.append(addr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Find orphaned resources (dependencies that don't exist)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        orphaned_resources: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        all_resource_addrs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">r.get(</span><span style=\"color:#9ECBFF\">'type'</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">r.get(</span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> for</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> resources}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> resource </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> resources:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            deps </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> resource.get(</span><span style=\"color:#9ECBFF\">'dependencies'</span><span style=\"color:#E1E4E8\">, [])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> dep </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> deps:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> dep </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> all_resource_addrs:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    orphaned_resources.append(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">resource.get(</span><span style=\"color:#9ECBFF\">'type'</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">resource.get(</span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> -> </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">dep</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Collect validation errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        validation_errors: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> duplicate_addresses:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            validation_errors.append(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                f</span><span style=\"color:#9ECBFF\">\"Duplicate resource addresses: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#9ECBFF\">', '</span><span style=\"color:#E1E4E8\">.join(</span><span style=\"color:#79B8FF\">set</span><span style=\"color:#E1E4E8\">(duplicate_addresses))</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> orphaned_resources:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            validation_errors.append(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                f</span><span style=\"color:#9ECBFF\">\"Resources with missing dependencies: </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(orphaned_resources)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> StateReport(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            total_resources</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(resources),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            resources_by_type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">resources_by_type,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            orphaned_resources</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">orphaned_resources,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            duplicate_addresses</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">set</span><span style=\"color:#E1E4E8\">(duplicate_addresses)),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            validation_errors</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">validation_errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> compare</span><span style=\"color:#E1E4E8\">(state_a: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any], state_b: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Compare two state files and return differences.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        resources_a </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">r[</span><span style=\"color:#9ECBFF\">'type'</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">r[</span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">: r </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> state_a.get(</span><span style=\"color:#9ECBFF\">'resources'</span><span style=\"color:#E1E4E8\">, [])}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        resources_b </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">r[</span><span style=\"color:#9ECBFF\">'type'</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">r[</span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">: r </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> state_b.get(</span><span style=\"color:#9ECBFF\">'resources'</span><span style=\"color:#E1E4E8\">, [])}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        all_addrs </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> set</span><span style=\"color:#E1E4E8\">(resources_a.keys()) </span><span style=\"color:#F97583\">|</span><span style=\"color:#79B8FF\"> set</span><span style=\"color:#E1E4E8\">(resources_b.keys())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        diff </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'added'</span><span style=\"color:#E1E4E8\">: [],</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'removed'</span><span style=\"color:#E1E4E8\">: [],</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'modified'</span><span style=\"color:#E1E4E8\">: [],</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'unchanged'</span><span style=\"color:#E1E4E8\">: []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> addr </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> all_addrs:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> addr </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> resources_a </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> addr </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> resources_b:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                diff[</span><span style=\"color:#9ECBFF\">'removed'</span><span style=\"color:#E1E4E8\">].append(addr)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            elif</span><span style=\"color:#E1E4E8\"> addr </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> resources_a </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> addr </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> resources_b:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                diff[</span><span style=\"color:#9ECBFF\">'added'</span><span style=\"color:#E1E4E8\">].append(addr)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            elif</span><span style=\"color:#E1E4E8\"> resources_a[addr] </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> resources_b[addr]:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                diff[</span><span style=\"color:#9ECBFF\">'unchanged'</span><span style=\"color:#E1E4E8\">].append(addr)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Deep compare attributes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                attrs_a </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> resources_a[addr].get(</span><span style=\"color:#9ECBFF\">'attributes'</span><span style=\"color:#E1E4E8\">, {})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                attrs_b </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> resources_b[addr].get(</span><span style=\"color:#9ECBFF\">'attributes'</span><span style=\"color:#E1E4E8\">, {})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Simple attribute comparison (could be enhanced)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> attrs_a </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> attrs_b:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    diff[</span><span style=\"color:#9ECBFF\">'modified'</span><span style=\"color:#E1E4E8\">].append({</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                        'address'</span><span style=\"color:#E1E4E8\">: addr,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                        'attributes_changed'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> diff</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># CLI command to inspect state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> inspect_state_command</span><span style=\"color:#E1E4E8\">(state_path: Path, output_format: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'text'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"CLI command for state inspection.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    from</span><span style=\"color:#E1E4E8\"> iac.debug.state_inspector </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> StateInspector, StateReport</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> StateInspector.load_state(state_path)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    report </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> StateInspector.analyze(state_data)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> output_format </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'json'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(json.dumps(report.to_dict(), </span><span style=\"color:#FFAB70\">indent</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"State File: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">state_path</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Total Resources: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">report.total_resources</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">Resources by Type:\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> rtype, count </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> report.resources_by_type.items():</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"  </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">rtype</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">count</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> report.duplicate_addresses:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">⚠️  Duplicate Addresses: </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(report.duplicate_addresses)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> addr </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> report.duplicate_addresses[:</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">]:  </span><span style=\"color:#6A737D\"># Show first 5</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"  </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">addr</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> report.orphaned_resources:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">⚠️  Orphaned Dependencies: </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(report.orphaned_resources)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> orphan </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> report.orphaned_resources[:</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"  </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">orphan</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> report.validation_errors:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">❌ Validation Errors:\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> error </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> report.validation_errors:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"  </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">error</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">✅ State file appears valid\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-graph-visualization-exporter\">Core Logic Skeleton: Graph Visualization Exporter</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/iac/debug/graph_exporter.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> iac.planner </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> DependencyGraphNode</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GraphExporter</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Exports dependency graphs to various visualization formats.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_dot</span><span style=\"color:#E1E4E8\">(graph: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, DependencyGraphNode], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               highlight_cycles: Optional[List[List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Export graph to Graphviz DOT format.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            graph: Dependency graph from build_graph</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            highlight_cycles: List of cycles to highlight in red</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            DOT format string for rendering with Graphviz</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize DOT string with digraph header and styling options</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Example: 'digraph G { rankdir=TB; node [shape=box];'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add all nodes with labels</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # For each node_id in graph.keys():</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Create node with label like \"type.name\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Format: '  \"aws_instance.web\" [label=\"aws_instance.web\"];'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Add all edges for dependencies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # For each node_id, node in graph.items():</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   For each dep in node.depends_on:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     Add edge: '  \"aws_vpc.main\" -> \"aws_instance.web\";'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If highlight_cycles provided, color cycle nodes and edges</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # For each cycle in highlight_cycles:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   For node_id in cycle:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     Add node attribute: '  \"node_id\" [color=red, penwidth=2];'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   For edges within cycle:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     Add edge attribute: '  \"a\" -> \"b\" [color=red, penwidth=2];'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Close the graph and return complete DOT string</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_mermaid</span><span style=\"color:#E1E4E8\">(graph: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, DependencyGraphNode]) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Export graph to Mermaid.js format for web display.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Mermaid graph definition string</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Start with 'graph TD' for top-down layout</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add all nodes with sanitized IDs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Mermaid IDs can't contain dots, so convert 'aws_instance.web' to 'aws_instance_web'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Add all edges using Mermaid arrow syntax</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Format: 'aws_vpc_main --> aws_instance_web;'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Add click handlers for interactive debugging</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Format: 'click aws_instance_web callback \"show_resource_details\"'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> find_cycles</span><span style=\"color:#E1E4E8\">(graph: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, DependencyGraphNode]) -> List[List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Find all cycles in the graph using DFS.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            List of cycles, where each cycle is a list of node IDs</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize visited set, recursion stack, and cycle list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Implement recursive DFS with cycle detection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Use standard algorithm: white/gray/black sets for unvisited/visiting/visited</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: When back edge found (node in gray set), reconstruct cycle path</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return list of unique cycles (avoid duplicates)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"debug-cli-command-skeleton\">Debug CLI Command Skeleton</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/iac/cli/commands/debug.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> click</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> pathlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@click.group</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"debug\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> debug_cli</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Debugging commands for the IaC engine.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@debug_cli.command</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"state\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@click.argument</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"state_path\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">click.Path(</span><span style=\"color:#FFAB70\">exists</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">path_type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">Path))</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@click.option</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"--format\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">click.Choice([</span><span style=\"color:#9ECBFF\">\"text\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"json\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"html\"</span><span style=\"color:#E1E4E8\">]), </span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"text\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> state_inspect</span><span style=\"color:#E1E4E8\">(state_path: Path, format: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Inspect and validate a state file.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    from</span><span style=\"color:#E1E4E8\"> iac.debug.state_inspector </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> inspect_state_command</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inspect_state_command(state_path, </span><span style=\"color:#79B8FF\">format</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@debug_cli.command</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"graph\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@click.argument</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"config_path\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">click.Path(</span><span style=\"color:#FFAB70\">exists</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">path_type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">Path))</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@click.option</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"--output\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"-o\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">click.Path(</span><span style=\"color:#FFAB70\">path_type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">Path), </span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"graph.png\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@click.option</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"--format\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">click.Choice([</span><span style=\"color:#9ECBFF\">\"dot\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"mermaid\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"png\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"svg\"</span><span style=\"color:#E1E4E8\">]), </span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"png\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> graph_export</span><span style=\"color:#E1E4E8\">(config_path: Path, output: Path, format: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Export dependency graph to visualization format.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Parse configuration using process_configuration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Load state if exists</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Build graph using build_graph</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Export using GraphExporter based on format</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: If format is png/svg, call Graphviz to render</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   import subprocess</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #   subprocess.run([\"dot\", \"-Tpng\", \"graph.dot\", \"-o\", output])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    click.echo(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Graph exported to </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">output</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@debug_cli.command</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"replay\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@click.argument</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"snapshot_id\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@click.option</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"--step\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"-s\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">help</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"Execute only up to this step\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> replay_snapshot</span><span style=\"color:#E1E4E8\">(snapshot_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, step: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Replay execution from a saved snapshot.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Load snapshot by ID from snapshot manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Restore state to snapshot state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If step provided, execute only up to that step</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Provide interactive prompt to continue or inspect</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    click.echo(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Replaying snapshot </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">snapshot_id</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Register with main CLI</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># In main cli.py: cli.add_command(debug_cli)</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints-for-python\">Language-Specific Hints for Python</h4>\n<ol>\n<li><strong>Use <code>pdb</code> or <code>ipdb</code> for interactive debugging</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   import</span><span style=\"color:#E1E4E8\"> ipdb; ipdb.set_trace()  </span><span style=\"color:#6A737D\"># Add breakpoint</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Then inspect variables, step through code</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Leverage <code>inspect</code> module for runtime introspection</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   import</span><span style=\"color:#E1E4E8\"> inspect</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">   print</span><span style=\"color:#E1E4E8\">(inspect.getsource(compute_diff))  </span><span style=\"color:#6A737D\"># View function source</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">   print</span><span style=\"color:#E1E4E8\">(inspect.signature(plan_command))  </span><span style=\"color:#6A737D\"># View parameter signature</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Use <code>traceback</code> for better error context</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   import</span><span style=\"color:#E1E4E8\"> traceback</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       apply_plan(plan, providers)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       traceback.print_exc()  </span><span style=\"color:#6A737D\"># Full stack trace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       logger.error(</span><span style=\"color:#9ECBFF\">\"Apply failed\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">exc_info</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Include in logs</span></span></code></pre></div>\n\n<ol start=\"4\">\n<li><strong>Profile performance bottlenecks</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   import</span><span style=\"color:#E1E4E8\"> cProfile</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   pr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cProfile.Profile()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   pr.enable()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   plan_command(config_path, state_path)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   pr.disable()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   pr.print_stats(</span><span style=\"color:#FFAB70\">sort</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'cumtime'</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint-debugging-readiness\">Milestone Checkpoint: Debugging Readiness</h4>\n<p>After implementing the debugging utilities, verify they work:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test structured logging</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"from iac.debug.logger import setup_logging; setup_logging('DEBUG'); import logging; logging.getLogger('iac').info('Test log')\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test state inspection</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> src/iac/cli/main.py</span><span style=\"color:#9ECBFF\"> debug</span><span style=\"color:#9ECBFF\"> state</span><span style=\"color:#9ECBFF\"> terraform.tfstate</span><span style=\"color:#79B8FF\"> --format=json</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test graph export (requires Graphviz installed)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> src/iac/cli/main.py</span><span style=\"color:#9ECBFF\"> debug</span><span style=\"color:#9ECBFF\"> graph</span><span style=\"color:#9ECBFF\"> main.tf</span><span style=\"color:#79B8FF\"> --output=dependency.png</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected outputs:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Logs appear in JSON format with correlation IDs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - State inspection shows resource counts and validation results</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - dependency.png file created showing visual graph</span></span></code></pre></div>\n\n<p><strong>Signs something is wrong:</strong></p>\n<ul>\n<li>Logs don&#39;t appear: Check logging level and handler configuration</li>\n<li>State inspection crashes: State file may be malformed - add try/except</li>\n<li>Graph export fails: Graphviz may not be installed (<code>brew install graphviz</code> or <code>apt-get install graphviz</code>)</li>\n</ul>\n<p>Remember: debugging is iterative. Start with logging, then add visualization, then build interactive tools as needed. The goal is to make the system&#39;s internal state as transparent as possible.</p>\n<h2 id=\"future-extensions\">Future Extensions</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section describes potential enhancements that build upon the core system and are relevant to all milestones (1, 2, 3, 4).</p>\n</blockquote>\n<p>The foundational IaC engine we&#39;ve designed provides a robust, extensible platform for managing infrastructure declaratively. By adhering to clean abstractions—particularly the separation between configuration, planning, and execution—the architecture can accommodate numerous enhancements without requiring fundamental redesign. This section explores several valuable extensions that could be built upon the existing components, each addressing a real-world operational need that mature IaC tools typically provide.</p>\n<h3 id=\"possible-enhancements\">Possible Enhancements</h3>\n<p>The following enhancements represent natural evolution paths for the system, organized by the operational challenge they solve.</p>\n<h4 id=\"validation-webhook-pre-apply-policy-enforcement\">Validation Webhook (Pre-Apply Policy Enforcement)</h4>\n<p><strong>Mental Model: The Building Inspector</strong></p>\n<blockquote>\n<p>Think of this enhancement as adding a building inspector who must approve the blueprints (execution plan) before any construction begins. The inspector reviews the plan against a set of safety codes (policies) and can either grant a permit (allow the apply) or require revisions (reject the plan).</p>\n</blockquote>\n<p>A validation webhook allows external systems to inspect and approve or reject an execution plan before it&#39;s applied. This is crucial for enforcing organizational policies (e.g., &quot;no S3 buckets can be publicly readable,&quot; &quot;all compute instances must have specific tags&quot;) in an automated, non-bypassable way.</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Modification Required</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Executor</code></td>\n<td>New <code>validate_plan</code> method</td>\n<td>Instead of proceeding directly to <code>apply_plan</code>, the executor would first serialize the plan and send it to a configured webhook URL.</td>\n</tr>\n<tr>\n<td><code>PlanAction</code></td>\n<td>None (serialization already exists via <code>JsonSerializable</code>)</td>\n<td>The plan&#39;s <code>to_dict()</code> or <code>to_json()</code> would be used to create the payload.</td>\n</tr>\n<tr>\n<td>New: <code>WebhookValidator</code></td>\n<td>Entire new component</td>\n<td>Handles HTTP communication, retries, timeout, and response parsing. Integrates with the <code>Executor</code>.</td>\n</tr>\n</tbody></table>\n<p><strong>Architecture Decision: Synchronous vs. Asynchronous Validation</strong></p>\n<blockquote>\n<p><strong>Decision: Synchronous Validation with Timeout</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to guarantee policy enforcement before any resources are modified. The apply operation must wait for a definitive allow/deny decision.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Synchronous HTTP call</strong>: The <code>apply_command</code> blocks, sends the plan to the webhook, and proceeds only after receiving an <code>APPROVE</code> response.</li>\n<li><strong>Asynchronous approval ticket</strong>: The system creates a ticket (e.g., in a queue or issue tracker) and pauses. A separate human or automated process reviews and approves later, after which the apply resumes.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement synchronous validation for fully automated pipelines, with a configurable timeout (e.g., 30 seconds).</li>\n<li><strong>Rationale</strong>: Synchronous validation provides immediate feedback and fits seamlessly into CI/CD pipelines where the entire workflow must pass or fail in a single run. The timeout prevents the system from hanging indefinitely if the webhook is unresponsive.</li>\n<li><strong>Consequences</strong>: Adds a critical dependency on the webhook service&#39;s availability. A down webhook will block all applies unless the feature is explicitly disabled. This can be mitigated with circuit breaker patterns in the <code>WebhookValidator</code>.</li>\n</ul>\n</blockquote>\n<p><strong>Integration Point</strong>:\nThe <code>apply_command</code> would be extended with a new step between acquiring the state lock and beginning execution. A high-level algorithm would be:</p>\n<ol>\n<li>Generate the execution plan as usual.</li>\n<li>If a webhook URL is configured in the environment or config:\na. Serialize the plan and current state snapshot.\nb. POST to the webhook with a correlation ID.\nc. Wait for response (with timeout and retry for network errors).\nd. If response contains <code>{&quot;result&quot;: &quot;REJECTED&quot;, &quot;reason&quot;: &quot;...&quot;}</code>, abort the apply, release the lock, and output the rejection reason.\ne. If response is <code>{&quot;result&quot;: &quot;APPROVED&quot;}</code>, proceed to apply.</li>\n<li>If the webhook times out or returns an unexpected error, follow a configurable policy (fail open or fail closed).</li>\n</ol>\n<h4 id=\"policy-as-code-integration\">Policy-as-Code Integration</h4>\n<p><strong>Mental Model: The Automated Rulebook</strong></p>\n<blockquote>\n<p>This enhancement embeds a rulebook (policy engine) directly into the planning phase. Imagine a rulebook that automatically flags any blueprint line that violates company policy, similar to a spell-checker for infrastructure configurations.</p>\n</blockquote>\n<p>While a validation webhook is external, Policy-as-Code integrates policy evaluation directly into the engine, typically as a library (like Open Policy Agent - OPA). Policies are written in a dedicated language and evaluate the planned changes against rules that can be more complex than simple webhook checks (e.g., &quot;if the resource is in production, it must have at least two replicas&quot;).</p>\n<table>\n<thead>\n<tr>\n<th>Integration Point</th>\n<th>Design Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Policy Evaluation Time</strong></td>\n<td>During planning, after <code>generate_plan</code> but before output. Could also run during parsing for early syntax validation.</td>\n</tr>\n<tr>\n<td><strong>Policy Scope</strong></td>\n<td>Can evaluate the entire config (<code>List[Resource]</code>), the computed diff (<code>Dict[str, PlanAction]</code>), or individual resources.</td>\n</tr>\n<tr>\n<td><strong>Policy Language</strong></td>\n<td>Embed a generic engine (e.g., OPA Rego) or define a custom DSL. The <code>BaseProvider</code> could also contribute resource-specific validation schemas.</td>\n</tr>\n</tbody></table>\n<p><strong>Common Pitfalls and Solutions</strong>:</p>\n<ul>\n<li>⚠️ <strong>Pitfall: Performance degradation on large plans</strong>.<ul>\n<li><strong>Why it&#39;s wrong</strong>: Evaluating complex policies against hundreds of resources can make the <code>plan</code> command unacceptably slow.</li>\n<li><strong>Fix</strong>: Implement policy filtering (only run certain policies on certain resource types) and caching of policy query results. Consider a parallel evaluation mode.</li>\n</ul>\n</li>\n<li>⚠️ <strong>Pitfall: Policy rules conflict with provider validation</strong>.<ul>\n<li><strong>Why it&#39;s wrong</strong>: A policy might reject a configuration that the cloud provider would actually accept, causing confusion.</li>\n<li><strong>Fix</strong>: Clearly document that policies are for <em>organizational</em> guardrails, not syntax validation. Layer policies: syntax (provider schema) → semantics (policy) → runtime (webhook).</li>\n</ul>\n</li>\n</ul>\n<p><strong>Example Workflow Addition</strong>:\nA new <code>validate_policies</code> function could be added to the <code>Planner</code> component or as a separate <code>PolicyEngine</code> class. The <code>plan_command</code> would then:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">plaintext</span><pre class=\"arch-pre shiki-highlighted\"><code>1. Parse config -&gt; desired resources.\n2. Read state.\n3. Build graph, compute diff, generate plan (as before).\n4. Call `policy_engine.validate(plan)`.\n5. If violations found, print them as warnings or errors (based on severity config) and optionally exit with a non-zero code.\n6. Continue to display plan.</code></pre></div>\n\n<p>This keeps the policy evaluation inside the planning phase, giving users immediate feedback.</p>\n<h4 id=\"drift-detection-scheduler\">Drift Detection Scheduler</h4>\n<p><strong>Mental Model: The Periodic Inventory Auditor</strong></p>\n<blockquote>\n<p>Imagine a warehouse manager who, every night, compares the official inventory log (state file) against a physical walkthrough of the shelves (actual cloud resources). Any discrepancies (drift) are recorded in a report for the morning shift.</p>\n</blockquote>\n<p>Drift detection is the process of periodically comparing the recorded state in the state file against the actual state in the cloud, identifying any changes made outside of the IaC tool (e.g., a console edit, CLI command, or another automation tool). Our architecture inherently supports this because the <code>Provider.read</code> method already knows how to fetch current state, and <code>compute_diff</code> can compare it to the recorded state.</p>\n<table>\n<thead>\n<tr>\n<th>New Component</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>DriftDetector</code></td>\n<td>Orchestrates periodic refresh and diff. Could be a long-running daemon or a cron-triggered script.</td>\n</tr>\n<tr>\n<td><code>DriftReport</code></td>\n<td>Extends <code>StateReport</code> with fields like <code>drifted_resources: List[Tuple[str, Dict[str, Any]]]</code> showing the resource address and the attributes that differ.</td>\n</tr>\n<tr>\n<td>Notification Integrations</td>\n<td>Plugins to send drift reports via email, Slack, or incident management systems.</td>\n</tr>\n</tbody></table>\n<p><strong>Design Considerations</strong>:</p>\n<ol>\n<li><strong>Detection Cadence</strong>: Should be configurable per-resource or per-provider. Some resources change frequently (auto-scaling group instance count) and might be ignored.</li>\n<li><strong>State Refresh Strategy</strong>: The <code>refresh_state</code> function (part of the executor) can be reused. However, a drift detection run should be <em>read-only</em> and must not acquire the state lock (or acquire it in shared read mode if implemented).</li>\n<li><strong>Handling Drift</strong>: The system could generate an alert, automatically create a corrective plan, or even apply it (in auto-remediate mode). The safest initial implementation is alert-only.</li>\n</ol>\n<p><strong>Algorithm for Drift Detection Run</strong>:</p>\n<ol>\n<li>For each provider configured, instantiate the provider with read-only credentials if possible.</li>\n<li>Load the state file (read-only, no lock).</li>\n<li>For each <code>StateRecord</code> in state:\na. Call <code>provider.read(resource_id, resource_type)</code>.\nb. Compare returned attributes with <code>StateRecord.attributes</code>.\nc. If any differences exist (ignoring certain metadata fields like timestamps), mark as drifted.</li>\n<li>Generate a <code>DriftReport</code> and trigger configured notifications.</li>\n<li>Optionally, if <code>auto_remediate: true</code>, call <code>plan_command</code> and <code>apply_command</code> with the current state and config to converge.</li>\n</ol>\n<p><strong>Integration with Existing Components</strong>:\nThe <code>StateInspector</code> component (from our debugging guide) could be extended with a <code>detect_drift</code> method, leveraging the <code>compute_diff</code> function but with the &quot;desired&quot; state being the recorded state and the &quot;current&quot; state being the freshly read cloud state. A <code>drift_command</code> CLI command could be added.</p>\n<h4 id=\"workspace-and-environment-management\">Workspace and Environment Management</h4>\n<p><strong>Mental Model: The Construction Site Blueprint Copies</strong></p>\n<blockquote>\n<p>Imagine you have one blueprint (configuration), but you need to build the same structure on three different construction sites (environments: dev, staging, prod). Each site has its own log of what&#39;s been built (state file) and slightly different characteristics (variables like size, location). The site manager needs to keep these contexts separate but use the same underlying plans.</p>\n</blockquote>\n<p>Our current design assumes a single state file path. In practice, teams manage multiple environments (dev/staging/prod) or multiple logical groupings (workspaces). This enhancement adds a layer of isolation, allowing the same configuration to be applied with different variable values and state files.</p>\n<table>\n<thead>\n<tr>\n<th>Concept</th>\n<th>Implementation Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Workspace</strong></td>\n<td>A named container for a distinct state file (e.g., <code>terraform.tfstate.d/dev/</code>). The workspace name becomes a prefix or suffix for the state file path.</td>\n</tr>\n<tr>\n<td><strong>Environment Variables</strong></td>\n<td>Variable resolution would prioritize workspace-specific variable files (e.g., <code>dev.tfvars</code>) over generic ones.</td>\n</tr>\n<tr>\n<td><strong>State Isolation</strong></td>\n<td>The <code>StateManager</code> would be extended to accept a <code>workspace</code> parameter, which it uses to construct the state and lock file paths (e.g., <code>terraform.tfstate.d/{workspace}/terraform.tfstate</code>).</td>\n</tr>\n</tbody></table>\n<p><strong>Required Changes</strong>:</p>\n<ul>\n<li><strong>CLI Commands</strong>: Add <code>workspace list</code>, <code>workspace new</code>, <code>workspace select</code> commands to manage workspaces.</li>\n<li><strong>State Manager</strong>: Modify <code>read_state</code>, <code>write_state</code>, and <code>acquire_lock</code> to incorporate a workspace-aware path.</li>\n<li><strong>Parser</strong>: Extend variable resolution to load workspace-specific var files.</li>\n</ul>\n<p><strong>Architecture Decision: State File Organization</strong></p>\n<blockquote>\n<p><strong>Decision: Directory-Based Workspace Isolation</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to store multiple state files for the same configuration root without conflict.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Directory per workspace</strong>: <code>state.d/&lt;workspace&gt;/terraform.tfstate</code>.</li>\n<li><strong>State file with prefix/suffix</strong>: <code>terraform-&lt;workspace&gt;.tfstate</code> in the same directory.</li>\n<li><strong>Database backend with workspace column</strong>: Store all states in a single database table, keyed by config path + workspace.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use a directory-based approach (<code>state.d/&lt;workspace&gt;/</code>).</li>\n<li><strong>Rationale</strong>: Simplicity and compatibility with file-based backup/restore tools. It mirrors Terraform&#39;s approach, making it familiar to users. Also, it works seamlessly with both local and remote (S3) backends using path prefixes.</li>\n<li><strong>Consequences</strong>: Requires filesystem support for directories. Remote backends must support path prefixes (S3 does). Workspace switching becomes a matter of changing the current working directory or setting an environment variable.</li>\n</ul>\n</blockquote>\n<h4 id=\"advanced-state-backends-and-encryption\">Advanced State Backends and Encryption</h4>\n<p><strong>Mental Model: The Bank Vault Upgrade</strong></p>\n<blockquote>\n<p>Initially, the ledger (state file) is kept in a filing cabinet (local disk). This enhancement moves it to a secure, replicated, access-controlled vault (remote backend with encryption and versioning).</p>\n</blockquote>\n<p>While Milestone 2 includes a remote backend (e.g., S3), advanced backends could include:</p>\n<ul>\n<li><strong>Versioned State</strong>: Every <code>write_state</code> creates a new version with a commit-like message, enabling rollback to previous states.</li>\n<li><strong>State Encryption</strong>: Encrypt the state file at rest using customer-managed keys (CMK) or a hardware security module (HSM) integration.</li>\n<li><strong>State Query API</strong>: Expose a read-only HTTP API for other tools to query the current state (e.g., &quot;list all EC2 instance IPs&quot;).</li>\n</ul>\n<p><strong>Design Extension</strong>: The <code>StateManager</code> would use a backend interface, similar to the <code>BaseProvider</code> pattern. Different backends (local, S3, HTTP API, database) would implement this interface. Encryption could be a wrapper backend that encrypts/decrypts data before passing it to the underlying backend.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">plaintext</span><pre class=\"arch-pre shiki-highlighted\"><code>interface StateBackend:\n    read_state(workspace: str) -&gt; Dict[str, StateRecord]\n    write_state(workspace: str, state_data: Dict[str, StateRecord], version_metadata: Optional[Dict]) -&gt; None\n    lock_state(workspace: str, info: Dict) -&gt; LockHandle\n    unlock_state(workspace: str, lock_handle: LockHandle) -&gt; None</code></pre></div>\n\n<p><strong>Integration Example</strong>: To add versioning, the <code>write_state</code> method would accept optional metadata (like a user, timestamp, and comment). The S3 backend could use S3 versioning, and also store metadata in a separate manifest file. The <code>state_inspect_command</code> could then list versions and show diffs between them.</p>\n<h4 id=\"resource-import-and-state-surgery\">Resource Import and State Surgery</h4>\n<p><strong>Mental Model: The Archaeologist&#39;s Catalog</strong></p>\n<blockquote>\n<p>When discovering ancient artifacts already in the ground, an archaeologist doesn&#39;t build them—they carefully catalog them and bring them into the museum&#39;s inventory system. Similarly, this feature allows bringing existing cloud resources under IaC management.</p>\n</blockquote>\n<p>Resource import is the process of taking an existing cloud resource that wasn&#39;t created by the IaC engine and adding it to the state file, so that future plans can manage it. This requires:</p>\n<ol>\n<li>Identifying the resource&#39;s cloud-side ID and attributes.</li>\n<li>Matching it to a resource block in the configuration.</li>\n<li>Writing a <code>StateRecord</code> for it without performing a create operation.</li>\n</ol>\n<p><strong>How the Architecture Supports It</strong>: The <code>Provider.read</code> method already fetches current attributes. We would add a new <code>import_resource</code> method to the <code>BaseProvider</code> interface that takes a resource address and cloud ID, reads the resource, and returns a <code>StateRecord</code>. The <code>StateManager</code> would then write this record. The tricky part is ensuring the configuration matches; a dry-run or validation step is needed.</p>\n<p><strong>New CLI Command</strong>: <code>import_command &lt;resource_address&gt; &lt;cloud_id&gt;</code> would:</p>\n<ol>\n<li>Parse config to find the resource definition.</li>\n<li>Call <code>provider.import_resource(resource_address, cloud_id)</code>.</li>\n<li>Add the returned <code>StateRecord</code> to the state (with a lock).</li>\n<li>Output a summary.</li>\n</ol>\n<p>This feature highlights the power of the clear separation between state and configuration: import only manipulates state, leaving the configuration unchanged.</p>\n<h4 id=\"advanced-execution-strategies\">Advanced Execution Strategies</h4>\n<p><strong>Mental Model: The Traffic Controller for Construction Crews</strong></p>\n<blockquote>\n<p>Instead of sending all construction crews to the site at once, a traffic controller staggers their arrival, monitors for accidents, and can reroute or pause new crews if problems arise.</p>\n</blockquote>\n<p>Our current <code>Executor</code> applies the plan in dependency order with basic concurrency. Advanced strategies could include:</p>\n<ul>\n<li><strong>Canary Apply</strong>: Apply changes to a small subset of resources first (e.g., one availability zone), verify health, then proceed to the rest.</li>\n<li><strong>Blue-Green Deployment</strong>: For resources like load balancers or ASGs, create a new parallel set of resources (green), switch traffic, then delete the old (blue).</li>\n<li><strong>Automatic Rollback on Failure</strong>: If a certain percentage of resources fail during apply, automatically revert the changes by applying the previous state.</li>\n</ul>\n<p><strong>Design Implications</strong>: These strategies require the <code>Executor</code> to have more sophisticated control flow, potentially grouping resources into stages and monitoring outcomes. The <code>PlanAction</code> might need additional metadata (like resource tags for canary grouping). The <code>apply_plan</code> algorithm would evolve from a simple loop to a state machine orchestrating stages.</p>\n<p>While these strategies are complex, the foundational building blocks—dependency graph, plan generation, and provider CRUD—remain the same. The enhancement would be a new <code>StrategicExecutor</code> that wraps or extends the basic <code>Executor</code>.</p>\n<h3 id=\"summary-of-architectural-flexibility\">Summary of Architectural Flexibility</h3>\n<p>The table below summarizes how the core architecture&#39;s design decisions enable these extensions:</p>\n<table>\n<thead>\n<tr>\n<th>Architectural Feature</th>\n<th>Enabled Extensions</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Provider Plugin Interface</strong> (<code>BaseProvider</code>)</td>\n<td>New cloud services, policy engines, state backends</td>\n<td>The interface abstraction allows new capabilities to be added via plugins without modifying core engine code.</td>\n</tr>\n<tr>\n<td><strong>Explicit State Serialization</strong> (<code>StateRecord</code>, <code>JsonSerializable</code>)</td>\n<td>Drift detection, versioning, import, webhook validation</td>\n<td>The state is a serializable, well-defined data structure that can be easily read, compared, and transmitted.</td>\n</tr>\n<tr>\n<td><strong>Declarative Resource Model</strong> (<code>Resource</code> vs. <code>StateRecord</code>)</td>\n<td>Policy-as-code, visualization, advanced planning</td>\n<td>The clear separation between desired (config) and actual (state) enables analysis and transformation at multiple points.</td>\n</tr>\n<tr>\n<td><strong>Dependency Graph as First-Class Construct</strong> (<code>DependencyGraphNode</code>)</td>\n<td>Execution strategies, visualization, impact analysis</td>\n<td>The explicit graph structure can be traversed, filtered, and displayed for various operational needs.</td>\n</tr>\n<tr>\n<td><strong>Modular Component Design</strong> (Parser, State, Planner, Executor)</td>\n<td>Workspace management, scheduler integration</td>\n<td>Components have clean interfaces, allowing them to be wrapped or extended independently (e.g., a scheduler that calls the parser and planner).</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight</strong>: The most valuable architectural decision for extensibility was enforcing a unidirectional data flow: Configuration → Resources → Plan → Execution → Updated State. This pipeline model allows &quot;middleware&quot; components (like policy checkers, webhooks, or drift detectors) to intercept and process data at clear stages without side-effects on other stages.</p>\n</blockquote>\n<p>By building upon these solid foundations, the IaC engine can evolve from a simple configuration applier to a comprehensive infrastructure governance platform, all while maintaining the core principles of safety, idempotency, and declarative intent that make IaC powerful.</p>\n<hr>\n<h2 id=\"glossary\">Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section defines key terminology used throughout the design document and is relevant to all milestones (1, 2, 3, 4).</p>\n</blockquote>\n<p>A shared vocabulary is essential for clear communication about a complex system. This glossary defines the key terms, acronyms, and domain-specific language used throughout this design document and the Infrastructure as Code (IaC) engine implementation.</p>\n<h3 id=\"term-definitions\">Term Definitions</h3>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Term</th>\n<th align=\"left\">Definition</th>\n<th align=\"left\">Related Concepts &amp; Notes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong><code>ActionType</code></strong></td>\n<td align=\"left\">An enumeration representing the four fundamental operations the engine can perform on a resource: <code>CREATE</code>, <code>UPDATE</code>, <code>DELETE</code>, and <code>NOOP</code>.</td>\n<td align=\"left\"><strong><code>PlanAction</code></strong> objects have an <code>action_type</code> field of this type. <code>NOOP</code> indicates the resource already matches the desired state.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>ApplyResult</code></strong></td>\n<td align=\"left\">A data structure (<code>ApplyResult</code>) returned by the executor for each resource action attempted during an apply operation. It records success/failure, the resulting state, any errors, and retry counts.</td>\n<td align=\"left\">Used for reporting and handling <strong>partial apply</strong> failures. Contains fields: <code>resource_address</code>, <code>success</code>, <code>new_state</code>, <code>error</code>, <code>retries</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Atomic Operation</strong></td>\n<td align=\"left\">An operation that either completes fully or not at all, with no observable intermediate state. In state management, <strong>atomic file writes</strong> (via rename) prevent <strong>state corruption</strong> from partial writes.</td>\n<td align=\"left\">Contrasts with non-atomic operations. Implemented via <code>write_atomic_json</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>BaseProvider</strong></td>\n<td align=\"left\">The core interface (<code>BaseProvider</code>) that all cloud provider plugins must implement. It defines the standard CRUD operations (<code>create</code>, <code>read</code>, <code>update</code>, <code>delete</code>) and configuration validation (<code>validate_credentials</code>).</td>\n<td align=\"left\">Enables <strong>polymorphism</strong>; the <strong>Executor</strong> interacts with all providers through this interface.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Circuit Breaker</strong></td>\n<td align=\"left\">A resilience pattern that stops calling a failing service after a threshold of failures is reached, allowing it time to recover. It fails fast (<strong>fail-fast</strong>) instead of wasting resources on likely failures.</td>\n<td align=\"left\">Implemented by the <code>CircuitBreaker</code> class. When open, calls result in a <code>CircuitOpenError</code>. Helps manage <strong>rate limiting</strong> and <strong>transient provider errors</strong>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>ConfigurationError</strong></td>\n<td align=\"left\">A subclass of <code>IaCError</code> raised when there is a problem with the user&#39;s configuration files, such as invalid syntax, undefined variables, or invalid resource schemas.</td>\n<td align=\"left\">Handled during the parsing and validation phase (<strong>Milestone 1</strong>).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Correlation ID</strong></td>\n<td align=\"left\">A unique identifier attached to a single operation (e.g., an <code>apply</code> command) and included in all logs and requests related to that operation. Enables tracing the flow of execution across components for debugging.</td>\n<td align=\"left\">Part of <strong>structured logging</strong> via <code>log_operation</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>CRUD</strong></td>\n<td align=\"left\">Acronym for <strong>Create, Read, Update, Delete</strong>—the four basic operations of persistent storage. The <code>BaseProvider</code> interface is a CRUD interface for cloud resources.</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>DAG (Directed Acyclic Graph)</strong></td>\n<td align=\"left\">A <strong>directed graph</strong> with no cycles, used to model resource dependencies. The <strong>Planner</strong> builds a DAG where nodes are resources and edges represent &quot;depends on&quot; relationships.</td>\n<td align=\"left\"><strong>Topological sort</strong> requires a DAG. <strong>Cycle detection</strong> is performed to ensure the graph is acyclic.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Declarative Configuration</strong></td>\n<td align=\"left\">An approach where the user specifies the <em>desired end state</em> of the infrastructure (what resources should exist and their properties), not the step-by-step commands to achieve it. The IaC engine&#39;s job is to figure out and execute the necessary changes.</td>\n<td align=\"left\">Contrasts with <em>imperative</em> or <em>procedural</em> approaches (e.g., scripts). Central philosophy of this project.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Dependency Graph</strong></td>\n<td align=\"left\">A graph representation of resource dependencies, built by the <strong>Planner</strong>. Implemented as a collection of <code>DependencyGraphNode</code> objects.</td>\n<td align=\"left\">Used to determine the correct order of operations during <code>apply</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>DependencyGraphNode</code></strong></td>\n<td align=\"left\">A data structure representing a single resource within the <strong>dependency graph</strong>. It contains the resource&#39;s unique address and lists of resources it <code>depends_on</code> and is <code>required_by</code>.</td>\n<td align=\"left\">Fields: <code>resource_id</code>, <code>depends_on</code>, <code>required_by</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Diff</strong></td>\n<td align=\"left\">The comparison between the <strong>desired state</strong> (derived from configuration) and the <strong>current state</strong> (from the state file) for a specific resource. The result of this comparison determines the <code>PlanAction</code> (<code>CREATE</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>NOOP</code>).</td>\n<td align=\"left\">Computed by <code>compute_diff</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Directed Acyclic Graph (DAG)</strong></td>\n<td align=\"left\">See <strong>DAG</strong>.</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Eventual Consistency</strong></td>\n<td align=\"left\">A property of many cloud APIs where a change (e.g., creating a resource) is not immediately reflected in all subsequent read requests. The system guarantees consistency only after an undefined period.</td>\n<td align=\"left\">A major challenge for providers; requires robust <strong>retry logic</strong> and <strong>state refresh</strong>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Execution Plan</strong></td>\n<td align=\"left\">The final output of the <code>plan</code> command: an ordered list of <code>PlanAction</code> objects specifying the precise create, update, and delete operations needed to converge current state to desired state.</td>\n<td align=\"left\">The &quot;what will happen&quot; preview shown to the user before <code>apply</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Executor</strong></td>\n<td align=\"left\">The component (<strong>Component Design: Provider Abstraction &amp; Executor</strong>) responsible for carrying out an <strong>execution plan</strong>. It orchestrates calls to <strong>providers</strong>, handles <strong>concurrency</strong>, <strong>retries</strong>, and updates the <strong>state</strong>.</td>\n<td align=\"left\">Calls <code>apply_plan</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Exponential Backoff</strong></td>\n<td align=\"left\">A retry strategy where the delay between retries increases exponentially (e.g., 1s, 2s, 4s, 8s). Often combined with <strong>jitter</strong> to prevent synchronized retry storms from multiple clients.</td>\n<td align=\"left\">Implemented via the <code>retry_with_backoff</code> decorator for handling <strong>transient provider errors</strong>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Fail-fast</strong></td>\n<td align=\"left\">A design approach where a system immediately reports an error condition rather than attempting to proceed in an invalid or degraded state. The <strong>circuit breaker</strong> pattern is a form of fail-fast for downstream service failures.</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Graph Visualization</strong></td>\n<td align=\"left\">The process of generating a visual diagram (e.g., DOT, Mermaid) of the <strong>dependency graph</strong> to aid in understanding and debugging resource relationships.</td>\n<td align=\"left\">The <code>GraphExporter</code> class provides methods like <code>to_dot</code> and <code>to_mermaid</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>HCL (HashiCorp Configuration Language)</strong></td>\n<td align=\"left\">A declarative configuration language created by HashiCorp, used by Terraform. It is a <strong>DSL</strong> designed for defining infrastructure. This project parses an HCL-like syntax.</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>IaC (Infrastructure as Code)</strong></td>\n<td align=\"left\">The practice of managing and provisioning computing infrastructure through machine-readable definition files, rather than physical hardware configuration or interactive configuration tools.</td>\n<td align=\"left\">The overarching domain of this project.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>IaCError</code></strong></td>\n<td align=\"left\">The base exception class for all errors thrown by the IaC engine. Specific error types like <code>ConfigurationError</code>, <code>StateError</code>, and <code>ProviderError</code> inherit from it.</td>\n<td align=\"left\">Allows for centralized error handling and logging.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Idempotent</strong></td>\n<td align=\"left\">An operation is idempotent if performing it multiple times has the same effect as performing it once. For example, issuing the same <code>CREATE</code> API call twice should result in one resource, not two. A core requirement for <strong>provider</strong> operations.</td>\n<td align=\"left\">Ensures safety of retries and re-running plans.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Jitter</strong></td>\n<td align=\"left\">Random variation added to retry delays (e.g., +/- 0.5 seconds). Prevents many clients from retrying simultaneously (a &quot;thundering herd&quot; problem) after a service outage, which could cause a new outage upon recovery.</td>\n<td align=\"left\">Used with <strong>exponential backoff</strong>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>JsonSerializable</code></strong></td>\n<td align=\"left\">A mixin class providing standard <code>to_dict</code>, <code>from_dict</code>, <code>to_json</code>, and <code>from_json</code> methods. Core data types like <code>Resource</code> and <code>StateRecord</code> inherit from it to simplify serialization for the <strong>state file</strong>.</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>LockHandle</code></strong></td>\n<td align=\"left\">An object returned by <code>acquire_lock</code> representing an acquired state lock. It contains metadata (lock path, process ID, lock ID) and manages a <strong>heartbeat thread</strong> to prevent the lock from becoming <strong>stale</strong>.</td>\n<td align=\"left\">Must be passed to <code>release_lock</code> to cleanly release the lock.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>PartialApplyError</code></strong></td>\n<td align=\"left\">A special exception raised when an <code>apply</code> operation completes for some resources but fails for others. It contains a dictionary of succeeded resources so the state can be partially updated.</td>\n<td align=\"left\">Prevents losing track of <strong>zombie resources</strong> created before the failure.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>PermanentProviderError</code></strong></td>\n<td align=\"left\">A subclass of <code>ProviderError</code> indicating a failure that is not retryable (e.g., invalid credentials, unsupported resource type, validation error). The engine should stop immediately.</td>\n<td align=\"left\">Contrast with <code>TransientProviderError</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>PlanAction</code></strong></td>\n<td align=\"left\">A data structure representing a single change to be made to a resource. It includes the <code>action_type</code> (<code>CREATE</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>NOOP</code>), the <code>resource</code> (desired state), and optionally the <code>prior_state</code> and <code>new_state</code>.</td>\n<td align=\"left\">The building block of an <strong>execution plan</strong>. Generated by <code>generate_plan</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Planner</strong></td>\n<td align=\"left\">The component (<strong>Component Design: Planner</strong>) responsible for building the <strong>dependency graph</strong>, performing <strong>topological sort</strong>, and generating the <strong>execution plan</strong>. It answers &quot;what needs to change and in what order?&quot;</td>\n<td align=\"left\">Key methods: <code>build_graph</code>, <code>validate_acyclic</code>, <code>topological_sort</code>, <code>generate_plan</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Provider</strong></td>\n<td align=\"left\">A plugin that translates the engine&#39;s generic CRUD operations into API calls for a specific cloud platform or service (e.g., AWS, Azure, Google Cloud). Implements the <code>BaseProvider</code> interface.</td>\n<td align=\"left\">The extensibility point of the system; new clouds are supported by writing new providers.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>ProviderConfig</code></strong></td>\n<td align=\"left\">A data structure holding configuration for a specific provider instance, such as credentials, region, and endpoint overrides.</td>\n<td align=\"left\">Fields: <code>provider_type</code>, <code>config</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>ProviderError</code></strong></td>\n<td align=\"left\">The base exception class for errors originating from a <strong>provider</strong> (e.g., API failures). Subclassed into <code>TransientProviderError</code> and <code>PermanentProviderError</code>.</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Rate Limiting</strong></td>\n<td align=\"left\">Restrictions imposed by cloud APIs on the frequency or volume of requests from a client. Exceeding limits results in throttling errors (HTTP 429).</td>\n<td align=\"left\">Must be handled by providers using <strong>exponential backoff</strong> and <strong>jitter</strong>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>Resource</code></strong></td>\n<td align=\"left\">The fundamental data structure representing a unit of infrastructure as defined in configuration (e.g., an AWS EC2 instance, a Google Cloud Storage bucket). It has a type, a unique name within that type, and a set of attributes.</td>\n<td align=\"left\">Fields: <code>id</code>, <code>type</code>, <code>name</code>, <code>attributes</code>. The <code>id</code> is initially empty and populated by the provider after creation.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>State Drift</strong></td>\n<td align=\"left\">The situation where the actual state of a resource in the cloud diverges from the state recorded in the <strong>state file</strong>. This can happen due to manual changes, direct API calls, or other IaC tools.</td>\n<td align=\"left\">The engine&#39;s <code>refresh_state</code> operation can detect drift by calling <code>provider.read</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>State File</strong></td>\n<td align=\"left\">A persistent file (typically JSON) that stores the last known state of all managed infrastructure as a dictionary of <code>StateRecord</code> objects, keyed by resource address. It is the <strong>single source of truth</strong> for what the engine believes is deployed.</td>\n<td align=\"left\">Managed by the <strong>State Manager</strong>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>State Inspection</strong></td>\n<td align=\"left\">The process of analyzing the <strong>state file</strong> for issues like orphaned resources, duplicates, or validation errors. Performed by the <code>StateInspector</code> class and the <code>inspect_state_command</code> CLI command.</td>\n<td align=\"left\">Useful for debugging and maintenance.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>StateInspector</code></strong></td>\n<td align=\"left\">A utility class providing methods to load, analyze, and compare state files.</td>\n<td align=\"left\">Methods: <code>load_state</code>, <code>analyze</code>, <code>compare</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>State Manager</strong></td>\n<td align=\"left\">The component (<strong>Component Design: State Manager</strong>) responsible for persisting and managing the <strong>state file</strong>, handling <strong>locking</strong> to prevent concurrent modifications, and computing <strong>diffs</strong> between states.</td>\n<td align=\"left\">Key methods: <code>read_state</code>, <code>write_state</code>, <code>acquire_lock</code>, <code>compute_diff</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>StateRecord</code></strong></td>\n<td align=\"left\">A data structure representing a snapshot of a <code>Resource</code> as it exists (or is believed to exist) in the cloud. It is what is stored in the <strong>state file</strong>. It includes the cloud-assigned <code>resource_id</code> and tracks <code>dependencies</code>.</td>\n<td align=\"left\">Fields: <code>resource_id</code>, <code>resource_type</code>, <code>resource_name</code>, <code>attributes</code>, <code>dependencies</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>StateReport</code></strong></td>\n<td align=\"left\">The output of a state inspection, containing statistics and identified issues.</td>\n<td align=\"left\">Fields: <code>total_resources</code>, <code>resources_by_type</code>, <code>orphaned_resources</code>, <code>duplicate_addresses</code>, <code>validation_errors</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Structured Logging</strong></td>\n<td align=\"left\">A logging practice where log messages are emitted in a machine-parsable format (like JSON) with consistent, named fields (e.g., <code>timestamp</code>, <code>level</code>, <code>correlation_id</code>, <code>component</code>, <code>message</code>). Greatly aids in debugging and log analysis.</td>\n<td align=\"left\">Configured via <code>setup_logging</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Topological Sort</strong></td>\n<td align=\"left\">A linear ordering of the nodes in a <strong>DAG</strong> such that for every directed edge from node <em>u</em> to node <em>v</em>, <em>u</em> appears before <em>v</em> in the ordering. This provides a safe execution order for resources.</td>\n<td align=\"left\">Implemented by the <code>topological_sort</code> function in the <strong>Planner</strong>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>TransientProviderError</code></strong></td>\n<td align=\"left\">A subclass of <code>ProviderError</code> indicating a failure that might be temporary and is worth retrying (e.g., network timeout, rate limit, internal server error). The engine will apply <strong>retry logic</strong>.</td>\n<td align=\"left\">Contrast with <code>PermanentProviderError</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Zombie Resource</strong></td>\n<td align=\"left\">A resource that exists in the cloud but is not recorded in the <strong>state file</strong>. This can happen if a resource is created (e.g., by a <strong>partial apply</strong> failure) but the state update fails. The engine loses the ability to manage it.</td>\n<td align=\"left\">Mitigated by <strong>atomic state updates</strong> and careful error recovery in the <strong>Executor</strong>.</td>\n</tr>\n</tbody></table>\n","toc":[{"level":1,"text":"Infrastructure as Code Engine: Design Document","id":"infrastructure-as-code-engine-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Context and Problem Statement","id":"context-and-problem-statement"},{"level":3,"text":"Mental Model: The Master Blueprint and Site Manager","id":"mental-model-the-master-blueprint-and-site-manager"},{"level":3,"text":"The Core Problem: Declarative to Imperative with State","id":"the-core-problem-declarative-to-imperative-with-state"},{"level":3,"text":"Existing Approaches and Trade-offs","id":"existing-approaches-and-trade-offs"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"Goals","id":"goals"},{"level":3,"text":"Non-Goals","id":"non-goals"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"Component Overview and Responsibilities","id":"component-overview-and-responsibilities"},{"level":3,"text":"Recommended File and Module Structure","id":"recommended-file-and-module-structure"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Data Model","id":"data-model"},{"level":3,"text":"Mental Model: The Recipe, the Pantry Inventory, the Shopping List, and the Cooking Steps","id":"mental-model-the-recipe-the-pantry-inventory-the-shopping-list-and-the-cooking-steps"},{"level":3,"text":"Key Types and Structures","id":"key-types-and-structures"},{"level":4,"text":"Resource: The Declarative Intent","id":"resource-the-declarative-intent"},{"level":4,"text":"StateRecord: The Known Reality","id":"staterecord-the-known-reality"},{"level":4,"text":"PlanAction: The Proposed Change","id":"planaction-the-proposed-change"},{"level":4,"text":"DependencyGraphNode: The Ordering Constraint","id":"dependencygraphnode-the-ordering-constraint"},{"level":4,"text":"Supporting Enum: ActionType","id":"supporting-enum-actiontype"},{"level":3,"text":"Type Relationships and Lifecycle","id":"type-relationships-and-lifecycle"},{"level":4,"text":"Lifecycle Stages and Transformations","id":"lifecycle-stages-and-transformations"},{"level":4,"text":"Walk-Through: A Complete Resource Lifecycle","id":"walk-through-a-complete-resource-lifecycle"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Component Design: Configuration Parser","id":"component-design-configuration-parser"},{"level":3,"text":"Mental Model: The Interpreter and Expander","id":"mental-model-the-interpreter-and-expander"},{"level":3,"text":"Interface and Public Methods","id":"interface-and-public-methods"},{"level":3,"text":"Internal Behavior and Algorithm","id":"internal-behavior-and-algorithm"},{"level":3,"text":"ADR: Abstract Syntax Tree vs. Direct Dict","id":"adr-abstract-syntax-tree-vs-direct-dict"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Component Design: State Manager","id":"component-design-state-manager"},{"level":3,"text":"Mental Model: The Ledger and Lock","id":"mental-model-the-ledger-and-lock"},{"level":3,"text":"Interface and Public Methods","id":"interface-and-public-methods"},{"level":3,"text":"Internal Behavior and Algorithm","id":"internal-behavior-and-algorithm"},{"level":4,"text":"1. Atomic State Persistence with write_atomic_json","id":"1-atomic-state-persistence-with-write_atomic_json"},{"level":4,"text":"2. Lock Acquisition with Heartbeat","id":"2-lock-acquisition-with-heartbeat"},{"level":4,"text":"3. Computing the State Diff","id":"3-computing-the-state-diff"},{"level":3,"text":"ADR: Pessimistic File Locking vs. Optimistic Concurrency","id":"adr-pessimistic-file-locking-vs-optimistic-concurrency"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Component Design: Planner (Dependency Graph &amp; Planning)","id":"component-design-planner-dependency-graph-amp-planning"},{"level":3,"text":"Mental Model: The Project Manager and Gantt Chart","id":"mental-model-the-project-manager-and-gantt-chart"},{"level":3,"text":"Interface and Public Methods","id":"interface-and-public-methods"},{"level":3,"text":"Internal Behavior and Algorithm","id":"internal-behavior-and-algorithm"},{"level":4,"text":"1. Dependency Graph Construction (build_graph)","id":"1-dependency-graph-construction-build_graph"},{"level":4,"text":"2. Cycle Detection (validate_acyclic)","id":"2-cycle-detection-validate_acyclic"},{"level":4,"text":"3. Topological Sort (topological_sort)","id":"3-topological-sort-topological_sort"},{"level":4,"text":"4. Plan Generation (generate_plan)","id":"4-plan-generation-generate_plan"},{"level":3,"text":"ADR: Implicit vs. Explicit Dependency Detection","id":"adr-implicit-vs-explicit-dependency-detection"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":2,"text":"Component Design: Provider Abstraction &amp; Executor","id":"component-design-provider-abstraction-amp-executor"},{"level":3,"text":"Mental Model: The Universal Remote Control","id":"mental-model-the-universal-remote-control"},{"level":3,"text":"Interface and Public Methods","id":"interface-and-public-methods"},{"level":4,"text":"BaseProvider Interface","id":"baseprovider-interface"},{"level":4,"text":"Executor Class","id":"executor-class"},{"level":3,"text":"Internal Behavior and Algorithm","id":"internal-behavior-and-algorithm"},{"level":4,"text":"Algorithm: Executing an Infrastructure Plan","id":"algorithm-executing-an-infrastructure-plan"},{"level":4,"text":"State Machine: Resource Lifecycle During Apply","id":"state-machine-resource-lifecycle-during-apply"},{"level":3,"text":"ADR: Retry Logic Strategy","id":"adr-retry-logic-strategy"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations","id":"a-technology-recommendations"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":2,"text":"Interactions and Data Flow","id":"interactions-and-data-flow"},{"level":3,"text":"Sequence: The Planning Workflow","id":"sequence-the-planning-workflow"},{"level":3,"text":"Sequence: The Apply Workflow","id":"sequence-the-apply-workflow"},{"level":3,"text":"Key Data Flow Transformations","id":"key-data-flow-transformations"},{"level":3,"text":"Common Integration Pitfalls","id":"common-integration-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"Mental Model: The Fault-Tolerant Construction Site","id":"mental-model-the-fault-tolerant-construction-site"},{"level":3,"text":"Error Classification and Recovery Strategy","id":"error-classification-and-recovery-strategy"},{"level":4,"text":"Detailed Recovery Procedures","id":"detailed-recovery-procedures"},{"level":3,"text":"Key Edge Cases and Mitigations","id":"key-edge-cases-and-mitigations"},{"level":4,"text":"Edge Case 1: Partial Apply Failures with Dependency Chains","id":"edge-case-1-partial-apply-failures-with-dependency-chains"},{"level":4,"text":"Edge Case 2: External Resource Modification (State Drift)","id":"edge-case-2-external-resource-modification-state-drift"},{"level":4,"text":"Edge Case 3: Zombie Resources (Created but Unrecorded)","id":"edge-case-3-zombie-resources-created-but-unrecorded"},{"level":4,"text":"Edge Case 4: Schema Evolution and Version Compatibility","id":"edge-case-4-schema-evolution-and-version-compatibility"},{"level":4,"text":"Edge Case 5: Circular Dependencies with Implicit References","id":"edge-case-5-circular-dependencies-with-implicit-references"},{"level":4,"text":"Edge Case 6: Provider API Eventually Consistency","id":"edge-case-6-provider-api-eventually-consistency"},{"level":4,"text":"Edge Case 7: Concurrent Modification by Multiple Engineers","id":"edge-case-7-concurrent-modification-by-multiple-engineers"},{"level":4,"text":"Edge Case 8: Configuration with Count/For_Each Interpolation","id":"edge-case-8-configuration-with-countfor_each-interpolation"},{"level":3,"text":"ADR: Fail-Fast vs. Continue-on-Error for Partial Apply","id":"adr-fail-fast-vs-continue-on-error-for-partial-apply"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations","id":"a-technology-recommendations"},{"level":4,"text":"B. Recommended File Structure","id":"b-recommended-file-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"Testing Strategy","id":"testing-strategy"},{"level":3,"text":"Testing Approaches and Tools","id":"testing-approaches-and-tools"},{"level":4,"text":"Unit Testing","id":"unit-testing"},{"level":4,"text":"Integration Testing","id":"integration-testing"},{"level":4,"text":"End-to-End Testing","id":"end-to-end-testing"},{"level":4,"text":"Mocking Cloud APIs","id":"mocking-cloud-apis"},{"level":3,"text":"Milestone Checkpoints and Verification","id":"milestone-checkpoints-and-verification"},{"level":4,"text":"Milestone 1: Configuration Parser","id":"milestone-1-configuration-parser"},{"level":4,"text":"Milestone 2: State Manager","id":"milestone-2-state-manager"},{"level":4,"text":"Milestone 3: Planner (Dependency Graph &amp; Planning)","id":"milestone-3-planner-dependency-graph-amp-planning"},{"level":4,"text":"Milestone 4: Provider Abstraction &amp; Executor","id":"milestone-4-provider-abstraction-amp-executor"},{"level":4,"text":"Integrated System Verification","id":"integrated-system-verification"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations","id":"a-technology-recommendations"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint Commands","id":"f-milestone-checkpoint-commands"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"Common Bugs: Symptom → Cause → Fix","id":"common-bugs-symptom-cause-fix"},{"level":3,"text":"Debugging Techniques and Tools","id":"debugging-techniques-and-tools"},{"level":4,"text":"Strategic Logging with Context Correlation","id":"strategic-logging-with-context-correlation"},{"level":4,"text":"State File Inspection and Diffing","id":"state-file-inspection-and-diffing"},{"level":4,"text":"Graph Visualization for Dependency Analysis","id":"graph-visualization-for-dependency-analysis"},{"level":4,"text":"Stepwise Execution with Intermediate Dumps","id":"stepwise-execution-with-intermediate-dumps"},{"level":4,"text":"Mock Provider for Isolated Testing","id":"mock-provider-for-isolated-testing"},{"level":4,"text":"Time Travel Debugging with State Snapshots","id":"time-travel-debugging-with-state-snapshots"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure for Debugging Utilities","id":"recommended-file-structure-for-debugging-utilities"},{"level":4,"text":"Infrastructure Starter Code: Structured Logger","id":"infrastructure-starter-code-structured-logger"},{"level":4,"text":"Infrastructure Starter Code: State Inspector","id":"infrastructure-starter-code-state-inspector"},{"level":4,"text":"Core Logic Skeleton: Graph Visualization Exporter","id":"core-logic-skeleton-graph-visualization-exporter"},{"level":4,"text":"Debug CLI Command Skeleton","id":"debug-cli-command-skeleton"},{"level":4,"text":"Language-Specific Hints for Python","id":"language-specific-hints-for-python"},{"level":4,"text":"Milestone Checkpoint: Debugging Readiness","id":"milestone-checkpoint-debugging-readiness"},{"level":2,"text":"Future Extensions","id":"future-extensions"},{"level":3,"text":"Possible Enhancements","id":"possible-enhancements"},{"level":4,"text":"Validation Webhook (Pre-Apply Policy Enforcement)","id":"validation-webhook-pre-apply-policy-enforcement"},{"level":4,"text":"Policy-as-Code Integration","id":"policy-as-code-integration"},{"level":4,"text":"Drift Detection Scheduler","id":"drift-detection-scheduler"},{"level":4,"text":"Workspace and Environment Management","id":"workspace-and-environment-management"},{"level":4,"text":"Advanced State Backends and Encryption","id":"advanced-state-backends-and-encryption"},{"level":4,"text":"Resource Import and State Surgery","id":"resource-import-and-state-surgery"},{"level":4,"text":"Advanced Execution Strategies","id":"advanced-execution-strategies"},{"level":3,"text":"Summary of Architectural Flexibility","id":"summary-of-architectural-flexibility"},{"level":2,"text":"Glossary","id":"glossary"},{"level":3,"text":"Term Definitions","id":"term-definitions"}],"title":"Infrastructure as Code Engine: Design Document","markdown":"# Infrastructure as Code Engine: Design Document\n\n\n## Overview\n\nThis system parses declarative infrastructure configurations, computes the difference from the current state, builds a safe execution plan, and applies changes to cloud resources. The key architectural challenge is managing state, dependencies, and idempotent operations across distributed, eventually consistent cloud APIs.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n## Context and Problem Statement\n\n> **Milestone(s):** This section provides foundational context for all milestones, setting the stage for the entire Infrastructure as Code engine.\n\nManaging infrastructure manually—clicking through cloud consoles, running ad-hoc scripts, and keeping manual documentation—is a recipe for inconsistency, configuration drift, and operational risk. The modern approach is **Infrastructure as Code (IaC)**, treating servers, networks, and databases as declarative specifications that can be versioned, reviewed, and applied programmatically. This project is about building the engine that powers such a system: a tool that reads a desired state, compares it with reality, and safely orchestrates the necessary changes.\n\nThe core challenge lies in bridging the **declarative intent** of the user (\"I want a web server with this configuration\") with the **imperative actions** of cloud APIs (\"create a VM, then attach a disk, then configure a firewall rule\"), while maintaining a reliable record of what was actually built. This requires sophisticated state management, dependency analysis, and robust error handling in an environment of eventual consistency and rate-limited APIs.\n\n### Mental Model: The Master Blueprint and Site Manager\n\nImagine you are constructing a building. You start with a **master blueprint** (the IaC configuration)—a detailed, declarative document specifying every component: walls, electrical wiring, plumbing, and their exact properties. This blueprint is written in a specialized language (like HCL) that describes the *what*, not the *how*.\n\nYou have a **site manager** (the IaC engine) whose job is to make the real site match the blueprint. On their first day, they survey the empty lot (current state: nothing) and create a detailed **work order** (execution plan) listing every task: pour foundation, erect frame, install wiring. They must figure out the correct order—you can't install drywall before running electrical conduit (dependency resolution).\n\nOnce construction begins, the site manager keeps a meticulous **logbook** (state file) of what has been completed. For each item in the blueprint, they record the real-world identifier (e.g., \"Wall Section A: constructed at coordinates X,Y,Z\"). This logbook is crucial. When the blueprint is updated (e.g., \"add a window to Wall Section A\"), the manager consults the logbook to see what's already built, figures out the diff (add a window), and creates a new work order.\n\nCrucially, the site manager uses **specialized subcontractors** (providers) for different tasks. An electrician (AWS provider) handles wiring, while a plumber (GCP provider) handles pipes. The manager communicates with each using their own terminology and processes (cloud APIs).\n\nThis mental model captures the essence of our IaC engine:\n*   **Blueprint** = Declarative configuration (`.tf` files)\n*   **Site Manager** = The core engine (Parser, Planner, Executor)\n*   **Logbook** = State file\n*   **Work Order** = Execution Plan\n*   **Subcontractors** = Providers (AWS, GCP, Azure plugins)\n\n> The key insight is that the logbook (state) is the source of truth for the *real world*, while the blueprint (configuration) is the source of truth for the *desired world*. The engine's job is to reconcile the two safely and efficiently.\n\n### The Core Problem: Declarative to Imperative with State\n\nTranslating a static declaration of desired infrastructure into a dynamic set of API calls, while maintaining correctness and safety, involves several intertwined technical challenges:\n\n1.  **State Reconciliation and Idempotency:** The engine must know what currently exists to decide what needs to be created, updated, or destroyed. Simply re-running the blueprint from scratch every time is not feasible—it would destroy and recreate everything, causing downtime. The engine must perform a **three-way diff** between the desired configuration, the last known state, and (in some cases) the actual live infrastructure. All operations must be **idempotent**: applying the same configuration multiple times should result in the same final state, regardless of intermediate failures or partial applies.\n\n2.  **Dependency and Ordering Management:** Infrastructure resources have complex relationships. A virtual machine depends on a network subnet, which depends on a virtual network. The engine must automatically infer these dependencies from the configuration (e.g., `subnet_id = aws_subnet.main.id` creates an implicit link) and allow explicit overrides (`depends_on`). It must then build a **Directed Acyclic Graph (DAG)** and execute changes in a correct order: creates in dependency order, updates with similar constraints, and destroys in reverse dependency order. Cycles in dependencies must be detected and rejected.\n\n3.  **Concurrency Control and Safety:** In a team setting, two engineers might try to apply different configurations to the same infrastructure simultaneously. This could lead to race conditions and corrupted state. The engine needs a **state locking mechanism** to ensure only one apply operation proceeds at a time. The locking must be robust to process crashes (avoiding stuck locks) and work across distributed environments (remote teams).\n\n4.  **Provider Abstraction and Heterogeneity:** Cloud APIs are diverse and ever-changing. The engine needs a clean **plugin architecture** that abstracts the specifics of AWS, Google Cloud, Azure, and even on-premise systems behind a uniform interface for Create, Read, Update, and Delete (CRUD) operations. Providers must handle authentication, rate limiting, retries with backoff, and the eventual consistency semantics of their respective clouds.\n\n5.  **Configuration Language and Expressivity:** Users need a language to declare resources, define variables, reuse modules, and output useful values. This language must be parsed, validated, and transformed into an internal representation. **Variable interpolation** (e.g., `${var.region}`) and **module composition** add layers of complexity, requiring multi-pass resolution and scope management.\n\nThe following table summarizes the core transformation the engine must perform at each stage:\n\n| Stage | Input | Core Challenge | Output |\n| :--- | :--- | :--- | :--- |\n| **Parse & Resolve** | HCL/YAML config files | Handling variables, modules, and complex expressions without infinite loops | A normalized, concrete graph of `Resource` objects with all references resolved. |\n| **State Diff** | Desired Resources + Last Known State | Computing minimal, correct change set in the face of nested/computed attributes | A set of proposed `PlanAction` objects (Create, Update, Delete, No-op). |\n| **Plan** | Desired Resources + State Diff + Dependencies | Ordering actions safely (no broken dependencies) and presenting a preview | An `ExecutionPlan` (DAG of `PlanAction` nodes) ready for application. |\n| **Apply** | ExecutionPlan + Live Cloud APIs | Managing concurrency, retries, timeouts, and partial failures while preserving state consistency | Updated infrastructure and a new, accurate `StateFile`. |\n\n**Decision: State as the Source of Truth**\n- **Context**: We need a reliable record of what the engine has provisioned to enable safe updates and deletes.\n- **Options Considered**:\n    1.  **Pure Declarative (No State)**: Re-parse configuration and query all cloud APIs on every run to discover current state. This is simple but slow, expensive (API costs), and unreliable (APIs may not expose all attributes, transient resources may be missed).\n    2.  **State-First**: Maintain a persistent, versioned state file that records the resource IDs and attributes after each apply. The state is the primary input for computing diffs.\n- **Decision**: **State-First**.\n- **Rationale**: A state file provides a fast, deterministic, and complete record of managed resources. It allows the engine to work offline (planning) and reduces reliance on potentially flaky or rate-limited cloud APIs for baseline discovery. It's the established pattern used by Terraform and other mature tools, proven at scale.\n- **Consequences**: We must now design robust state storage, locking, and serialization. The state file becomes a critical asset—corruption or loss can sever the link between configuration and real resources. We must also implement state refresh mechanisms to detect and reconcile \"drift\" (changes made outside the IaC tool).\n\n| Option | Pros | Cons | Chosen? |\n| :--- | :--- | :--- | :--- |\n| **Pure Declarative** | No state to manage or corrupt; always queries live infrastructure. | Very slow; API rate limits; cannot detect resources deleted via API; requires perfect API idempotency. | ❌ |\n| **State-First** | Fast planning; clear audit trail; enables advanced features like move, taint, and targeted operations. | State file is a singleton bottleneck; requires locking; risk of state drift if not refreshed. | ✅ |\n\n### Existing Approaches and Trade-offs\n\nThe IaC landscape offers several established tools, each embodying different design philosophies that inform our own architectural choices.\n\n**Decision: Terraform-like Declarative Model vs. Pulumi-like Imperative SDK**\n- **Context**: We must choose the core paradigm for how users define infrastructure.\n- **Options Considered**:\n    1.  **Declarative DSL (Terraform)**: Users write configuration in a domain-specific language (HCL) or YAML/JSON. The engine is entirely responsible for planning and execution.\n    2.  **Imperative SDK (Pulumi, CDK)**: Users write full-fledged programs (Python, Go, TypeScript) that call SDK functions to declare resources. The program's execution *is* the planning phase.\n- **Decision**: **Declarative DSL**.\n- **Rationale**: For an educational engine focused on the core challenges of reconciliation and planning, a declarative model cleanly separates *intent* from *execution*. It forces us to build a sophisticated planner and state manager. An imperative SDK pushes more complexity into the user's code and the runtime, making the engine's job different (more about snapshotting and diffing program output). The declarative approach is also more accessible for beginners and aligns with the \"blueprint\" mental model.\n- **Consequences**: We must build a parser and interpreter for a configuration language. Users lose the flexibility of loops and conditionals from general-purpose languages unless we replicate them in our DSL (e.g., `count` and `for_each`).\n\n| Option | Pros | Cons | Representative Tool |\n| :--- | :--- | :--- | :--- |\n| **Declarative DSL** | Clear separation of intent/execution; easy to analyze, validate, and plan; simple config files. | Limited expressiveness; custom language to learn; requires complex engine. | **Terraform**, CloudFormation, Ansible |\n| **Imperative SDK** | Full power of a programming language; familiar syntax; easier abstraction and reuse. | Harder to reason about desired state; program execution required for planning; can be overkill. | **Pulumi**, AWS CDK, Crossplane |\n\n**Terraform** is the canonical model for our project. It uses a custom HCL, maintains a state file (`terraform.tfstate`), has a rich provider ecosystem, and performs a planning stage. Its architecture directly inspires our component breakdown: Parser (config load), State (backend), Graph (terraform graph), and Provider plugins. However, Terraform's codebase is large and complex. Our goal is to distill its core concepts into a manageable, educational implementation.\n\n**AWS CloudFormation** takes a more centralized, cloud-vendor-controlled approach. Templates are JSON/YAML, and state is managed entirely by the AWS service. This simplifies the client but creates vendor lock-in and lacks the multi-cloud provider abstraction we aim to build. Its \"change sets\" are analogous to our execution plan.\n\n**Pulumi** represents the \"imperative SDK\" approach. It allows infrastructure to be defined in real code, which is then evaluated to produce a desired state graph. Pulumi then uses a Terraform-like engine (often the Terraform engine itself via bridged providers) to plan and apply. For our project, adopting this model would mean focusing on capturing and diffing program snapshots rather than parsing a DSL.\n\n> The trade-off is fundamentally about **control vs. flexibility**. A declarative engine (like Terraform) maintains tight control over the planning process, ensuring predictable and safe operations. An imperative SDK (like Pulumi) offers maximal flexibility to the user but places more trust in the user's code to correctly define the desired end state.\n\nOur design will follow the **Terraform architectural pattern** but with significant simplifications for clarity and educational value:\n*   We will support a subset of HCL or a simpler YAML configuration for faster parsing.\n*   Our state management will start with a local file and a simple lock, later extending to remote backends.\n*   Our provider interface will be similar to Terraform's plugin system but less complex, focusing on the core CRUD lifecycle.\n\nThis approach gives us a well-trodden path to explore all the fascinating problems of IaC—parsing, state, graphs, and plugins—without getting lost in the intricacies of a full, production-grade language or SDK runtime.\n\n\n> **Milestone(s):** This section sets the scope for the entire project and is relevant to all milestones.\n\n## Goals and Non-Goals\n\nThis section clearly defines the project's boundaries, separating what the IaC engine will accomplish from what it deliberately omits. A well-defined scope is critical for managing complexity and ensuring the core value proposition — a reliable, understandable, and extensible engine for managing infrastructure declaratively — is delivered successfully.\n\n> **Architectural Principle:** A system's boundaries are defined as much by what it chooses *not* to do as by what it does. Explicit non-goals prevent scope creep and allow focused effort on the core, differentiating capabilities.\n\n### Goals\n\nThe primary goal is to build a functional, educational IaC engine that demonstrates the fundamental patterns and challenges of reconciling desired state with actual state in a cloud environment. The following table enumerates the specific capabilities the system must deliver.\n\n| Goal | Description | Rationale & Key Capabilities |\n| :--- | :--- | :--- |\n| **Declarative Configuration** | Accept user-defined configuration files that describe the *desired* end-state of infrastructure, not the steps to create it. | This is the foundational philosophy of IaC. The engine must parse a configuration DSL (HCL-like syntax or YAML), resolve variables and modules, and produce a normalized set of `Resource` objects representing the intended infrastructure. |\n| **State Management** | Maintain a persistent, mutable record of the *actual* state of deployed infrastructure, enabling idempotent operations and change detection. | State is the engine's memory. Without it, every `apply` would be a blind creation. The system must store attribute values and resource IDs, support safe concurrent access via locking, and reliably compute the difference between desired and actual state. |\n| **Dependency-Aware Planning** | Analyze resource relationships to build an execution order (a Directed Acyclic Graph) and generate a safe, previewable plan of changes. | Infrastructure resources depend on each other (e.g., a subnet must exist before a VM placed in it). The planner must infer these dependencies, detect cycles, topologically sort resources, and produce a sequence of `PlanAction` items (CREATE, UPDATE, DELETE, NOOP) that can be reviewed before execution. |\n| **Provider Plugin Abstraction** | Define a clean interface (`BaseProvider`) that abstracts the specific CRUD operations of various cloud platforms (AWS, GCP, Azure) or services. | The engine cannot hardcode support for every cloud API. A plugin architecture allows the core logic to remain stable while providers for new services are developed independently. Each provider implements the lifecycle operations for its resource types. |\n| **Safe, Idempotent Apply** | Execute the plan against real infrastructure in a controlled manner, handling API failures, retries, and ensuring operations are idempotent where possible. | The `Executor` must coordinate with providers, manage concurrency, implement retry logic with backoff, and update the state file only upon successful completion of operations. This ensures the system is robust against transient failures and avoids duplicate resources. |\n| **Educational Codebase** | Produce a codebase that is readable, well-structured, and illustrative of distributed systems and compiler design patterns. | The implementation should prioritize clarity over excessive optimization. The architecture should be modular, with clear interfaces and data flow, making it a valuable learning tool for understanding how tools like Terraform work under the hood. |\n\n### Non-Goals\n\nEqually important are the features and responsibilities the system will *not* undertake. These exclusions keep the project focused and manageable, often delegating complexity to external systems or defining them as future extensions.\n\n| Non-Goal | Why It's Out of Scope | Recommended Alternative / Note |\n| :--- | :--- | :--- |\n| **A Complete, Production-Grade HCL Parser** | Implementing the full HCL 2.x syntax with all expressions, functions, and blocks is a massive undertaking distinct from the core IaC reconciliation engine. | Use a simplified, HCL-*like* syntax or YAML as the configuration language. For a more realistic parser, leverage an existing library (e.g., Python's `pyhcl` or Go's `hcl` package) in the **Implementation Guidance**, but the core design document will describe a simpler, custom parser for educational clarity. |\n| **Built-in Providers for All Cloud Services** | The engine is a platform, not a comprehensive cloud management tool. Building and maintaining providers for hundreds of resource types across multiple clouds is a separate, vast project. | The design includes a provider SDK (`BaseProvider` interface). The implementation will include one or two sample providers (e.g., a mock provider and a simple AWS EC2 provider) to demonstrate the pattern. Support for additional providers is left as an exercise or extension. |\n| **Web-Based UI or Dashboard** | The primary interface is the command line. Building a graphical interface is a significant front-end project that does not contribute to the core learning objectives of state management, planning, and provider abstraction. | The CLI provides all necessary functionality (`plan`, `apply`). A UI could be built as a separate, consuming application that calls the engine's core libraries. |\n| **Continuous Drift Detection & Remediation** | Automatically detecting and correcting configuration drift on a schedule is an operational feature that builds upon the core `plan`/`apply` mechanics. It introduces scheduling, eventing, and policy decision complexity. | Drift detection can be simulated by running `plan` periodically (e.g., via cron). Automatic remediation would require an automated `apply`, which is a security/policy decision beyond the engine's responsibility. |\n| **Advanced Policy-as-Code (e.g., OPA/Sentinel)** | Integrating policy checks that validate plans against security, compliance, or cost rules is a critical enterprise feature but adds significant complexity in policy language, evaluation engine, and enforcement hooks. | The `plan` output can be piped to external policy tools. The architecture could be extended later with a validation webhook between planning and execution. |\n| **Team Collaboration Features (RBAC, Audit Logging)** | Managing user permissions, audit trails, and approval workflows is essential for team use but belongs in a surrounding CI/CD or orchestration layer, not the core state reconciliation engine. | Use the engine with a CI/CD system (like the one built in the prerequisite project) which handles authentication, authorization, and logging of who ran which plans. |\n| **Multi-Cloud Dependency Resolution** | The engine does not need to handle dependencies *between* different cloud providers (e.g., an AWS resource depending on a GCP resource). This is an extreme edge case that vastly complicates authentication and state storage. | Assume a single cloud provider context per configuration/state file. Cross-provider setups can be managed by using the engine separately for each provider and passing outputs manually or via a wrapper script. |\n| **Native Support for Imperative Scripts** | The engine is declarative. While it may need to execute provisioning scripts *as a resource action* (e.g., via a `local_exec` provider), it will not parse or execute general-purpose imperative orchestration scripts as its primary config. | Use a declarative resource provided by a custom provider to wrap imperative scripts if absolutely necessary, acknowledging that this breaks idempotency guarantees. |\n\n> **Key Insight:** The distinction between goals and non-goals is not about importance, but about layering. The engine aims to be an excellent *platform* for declarative infrastructure reconciliation. Features like UI, collaboration, and policy are best built *on top* of this platform, not baked into its core.\n\n\n## High-Level Architecture\n\n> **Milestone(s):** This section provides a system-wide overview and is relevant to all milestones (1, 2, 3, 4).\n\nThis section presents the bird's-eye view of the Infrastructure as Code (IaC) engine. Before diving into individual component details, it's crucial to understand how the system fits together as a cohesive whole. We'll first introduce the five core components and their responsibilities, then describe the recommended project structure to organize this architecture in code.\n\n### Component Overview and Responsibilities\n\nThink of the IaC engine as a **construction project management office**. A project begins with architectural blueprints (configuration files). The office has specialists who interpret these blueprints, check what's already built, figure out the build order, and finally coordinate with various construction crews (cloud APIs) to execute the work. Our system decomposes this workflow into five specialized components.\n\nEach component has a single, well-defined responsibility and communicates with others through clear interfaces. This separation of concerns allows for independent development, testing, and potential replacement of individual parts (e.g., swapping the parser from HCL to YAML).\n\n![System Component Diagram](./diagrams/sys-component.svg)\n\nThe five core components are:\n\n1.  **Configuration Parser**: The **Interpreter and Expander**. This component consumes human-written declarative configuration files (HCL or YAML). Its job is to read the raw text, resolve all variables and module references, and produce a complete, normalized, in-memory representation of the desired infrastructure—a collection of `Resource` objects with concrete attribute values. It handles the complexity of the Domain-Specific Language (DSL) so the rest of the system can work with simple data structures.\n\n2.  **State Manager**: The **Ledger and Lock**. This component is the system's memory. It persistently stores the last known state of the deployed infrastructure in a **state file**. More importantly, it manages concurrent access to this state via a **lock**, preventing two simultaneous `apply` operations from corrupting each other's work. It can also compute the difference (diff) between the desired state (from the Parser) and the current state (from the ledger), which is the foundation of planning.\n\n3.  **Planner (Dependency Graph & Planning)**: The **Project Manager and Gantt Chart**. This component takes the normalized resources from the Parser and the current state from the State Manager. It analyzes the resources to build a **Directed Acyclic Graph (DAG)** based on their dependencies (e.g., a subnet must exist before a virtual machine placed within it). Using this graph and the state diff, it generates a safe, ordered **execution plan**—a list of `PlanAction` objects specifying precisely what needs to be created, updated, deleted, or left unchanged. This plan can be previewed by the user before any changes are made.\n\n4.  **Provider Abstraction (SDK)**: The **Universal Remote Control Interface**. This is not a single component but an abstraction layer. It defines a standard `BaseProvider` interface with **CRUD** operations (`create`, `read`, `update`, `delete`). Concrete implementations (like `AwsProvider`, `GoogleCloudProvider`) act as plugins that translate these generic calls into specific API calls for their respective cloud platforms. This design allows the engine to support multiple clouds without changing its core logic.\n\n5.  **Executor**: The **Foreman and Dispatcher**. This component takes the validated execution plan from the Planner and makes it happen. It is responsible for carrying out the plan by calling the appropriate methods on the configured `BaseProvider` implementations. It manages the execution flow: respecting the dependency order, handling concurrency for independent resources, implementing retry logic with exponential backoff for transient API failures, and reporting progress and outcomes back to the State Manager to update the ledger.\n\nThe table below summarizes each component's key responsibility, its primary inputs, and its primary outputs.\n\n| Component | Primary Responsibility | Key Inputs | Key Outputs |\n| :--- | :--- | :--- | :--- |\n| **Configuration Parser** | Transforms declarative config files into a normalized set of concrete resources. | HCL/YAML configuration files, variable values, module sources. | A collection of resolved `Resource` objects. |\n| **State Manager** | Persists the known state of infrastructure and manages safe, concurrent access to it. | Desired `Resource` collection, current state file, lock request. | `StateRecord` collection, state diff, lock token. |\n| **Planner** | Analyzes dependencies and state differences to produce a safe, ordered execution plan. | Desired `Resource` collection, current `StateRecord` collection. | `DependencyGraph`, ordered list of `PlanAction` objects (the plan). |\n| **Provider SDK** | Defines the interface for cloud-specific operations and provides plugin implementations. | `PlanAction` (via Executor), provider configuration (credentials, region). | Real cloud resource ID and attributes (on success) or error. |\n| **Executor** | Orchestrates the execution of a plan by calling provider methods and managing state updates. | Ordered `PlanAction` list, configured `BaseProvider` instances. | Updated `StateRecord` collection (written back via State Manager), execution result summary. |\n\n**Data Flow and Interactions:** The components interact in a specific sequence during the two primary workflows: `plan` and `apply`. During a `plan`, data flows from left to right in the diagram: Config → Parser → Planner. The Planner also reads from the State Manager. The final plan is output to the user. During an `apply`, the loop is closed: the Executor takes the plan, interacts with Providers to change the real infrastructure, and then writes the new state back through the State Manager. The State Manager's lock is acquired at the start of `apply` and released at the end, ensuring isolation.\n\n### Recommended File and Module Structure\n\nA well-organized codebase mirrors the architectural separation. The following structure is recommended for the Python implementation. It uses a clear separation between the core engine, provider plugins, and command-line interface, following Python packaging best practices.\n\n```\ninfra-as-code-engine/\n├── pyproject.toml                     # Project metadata and dependencies\n├── README.md\n├── src/\n│   └── iac_engine/                    # Main package\n│       ├── __init__.py\n│       ├── cli.py                     # Command-line interface (plan, apply, destroy)\n│       │\n│       ├── core/                      # The core engine components\n│       │   ├── __init__.py\n│       │   ├── parser.py              # Configuration Parser component\n│       │   ├── state_manager.py       # State Manager component\n│       │   ├── planner.py             # Planner component\n│       │   ├── executor.py            # Executor component\n│       │   └── models.py              # Core data types: Resource, StateRecord, etc.\n│       │\n│       ├── providers/                 # Provider Abstraction SDK and plugins\n│       │   ├── __init__.py\n│       │   ├── base.py                # BaseProvider abstract class\n│       │   ├── aws/                   # AWS provider implementation\n│       │   │   ├── __init__.py\n│       │   │   ├── provider.py        # AwsProvider class\n│       │   │   └── resources/         # AWS-specific resource implementations\n│       │   │       ├── ec2_instance.py\n│       │   │       └── s3_bucket.py\n│       │   ├── google/                # Google Cloud provider\n│       │   └── mock/                  # Mock provider for testing\n│       │\n│       └── utils/                     # Shared utilities\n│           ├── __init__.py\n│           ├── file_lock.py           # Locking implementation\n│           ├── retry.py               # Retry with exponential backoff\n│           └── graph.py               # Generic DAG utilities\n│\n├── tests/                             # Comprehensive test suite\n│   ├── unit/\n│   │   ├── test_parser.py\n│   │   ├── test_state_manager.py\n│   │   └── ...\n│   ├── integration/\n│   └── e2e/\n│\n├── examples/                          # Example configuration files\n│   ├── simple-webapp/\n│   │   ├── main.hcl\n│   │   └── variables.yaml\n│   └── multi-cloud/\n│\n└── docs/                              # Design docs, ADRs\n    └── architecture_decisions.md\n```\n\n**Key Rationale for This Structure:**\n*   **`src/` layout**: Using a `src` directory helps avoid common issues with Python imports, ensuring the package is always imported correctly, whether in development or after installation.\n*   **Clear namespace**: The main package `iac_engine` provides a clear namespace for all engine-related code.\n*   **Component isolation**: Each core component (`parser.py`, `state_manager.py`, etc.) lives in the `core/` module, making dependencies between them explicit and preventing circular imports.\n*   **Plugin architecture**: The `providers/` directory is structured to easily add new providers as sub-packages. The `base.py` defines the contract that all plugins must follow.\n*   **Shared utilities**: Common patterns like locking, retries, and graph algorithms are factored out into `utils/` to avoid duplication and ensure consistency.\n*   **Separation of tests**: Tests mirror the source structure, making it easy to locate tests for a specific module.\n\nThis structure scales well. As the project grows—adding more providers, utility functions, or complex examples—new directories and files can be added within the existing logical framework without major restructuring.\n\n### Implementation Guidance\n\nThis subsection provides concrete, actionable guidance for implementing the high-level architecture described above in Python.\n\n**A. Technology Recommendations Table**\n\n| Component | Simple Option (Recommended for Learning) | Advanced Option (For Production Readiness) |\n| :--- | :--- | :--- |\n| **Configuration Parsing** | Use `pyhcl2` (HCL2 parser) or `pyyaml` for YAML. Manual variable interpolation. | Implement a full recursive-descent parser for a custom DSL with advanced expression evaluation. |\n| **State Serialization** | JSON files for local state. Simple file-based locking. | Protocol Buffers or MessagePack for compact binary format. Distributed lock via DynamoDB or Consul. |\n| **Dependency Graph** | Python's `networkx` library for graph operations, or a custom `dict`-based adjacency list. | Custom incremental graph with persistent indexing for fast dependency queries on large state. |\n| **Provider SDK** | Abstract Base Classes (`abc.ABC`) for interface definition. `boto3` for AWS, `google-cloud-*` libraries for GCP. | gRPC service definitions for a plugin system where providers run as separate processes. |\n| **Concurrency & Retries** | `concurrent.futures.ThreadPoolExecutor` for parallel applies. Custom retry decorator. | `asyncio` with `aiohttp` for async I/O. Circuit breaker pattern (e.g., `pybreaker`) for API failure handling. |\n\n**B. Recommended File and Module Structure (Detailed)**\n\nThe following Python code establishes the foundational modules and data models. Create these files in the `src/iac_engine/` directory as shown in the structure above.\n\n**1. Core Data Models (`src/iac_engine/core/models.py`):**\n```python\n\"\"\"Core data models for the IaC engine.\"\"\"\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional\nfrom dataclasses import dataclass, field\n\nclass ActionType(Enum):\n    \"\"\"The type of change to be performed on a resource.\"\"\"\n    CREATE = \"create\"\n    UPDATE = \"update\"\n    DELETE = \"delete\"\n    NOOP = \"no-op\"  # No operation needed\n\n@dataclass\nclass Resource:\n    \"\"\"A desired infrastructure resource as defined in configuration.\"\"\"\n    id: str  # Unique identifier within the config (e.g., \"aws_instance.web\")\n    type: str  # Provider resource type (e.g., \"aws_instance\")\n    name: str  # Local name (e.g., \"web\")\n    attributes: Dict[str, Any] = field(default_factory=dict)  # Configuration attributes\n\n@dataclass\nclass StateRecord:\n    \"\"\"A record of a resource as it exists in the deployed infrastructure.\"\"\"\n    resource_id: str  # Matches Resource.id\n    resource_type: str\n    resource_name: str\n    attributes: Dict[str, Any] = field(default_factory=dict)  # Last known attributes\n    dependencies: List[str] = field(default_factory=list)  # IDs of resources this depends on\n\n@dataclass\nclass PlanAction:\n    \"\"\"A proposed change to bring reality in line with configuration.\"\"\"\n    action_type: ActionType\n    resource: Resource  # The desired resource state\n    prior_state: Optional[StateRecord] = None  # The state before the action (for UPDATE/DELETE)\n    new_state: Optional[StateRecord] = None  # The expected state after the action\n\n@dataclass\nclass DependencyGraphNode:\n    \"\"\"A node in the resource dependency graph.\"\"\"\n    resource_id: str\n    depends_on: List[str] = field(default_factory=list)  # Outgoing edges\n    required_by: List[str] = field(default_factory=list)  # Incoming edges (for efficient traversal)\n```\n\n**2. Provider Base Interface (`src/iac_engine/providers/base.py`):**\n```python\n\"\"\"Abstract base class for all infrastructure providers.\"\"\"\nfrom abc import ABC, abstractmethod\nfrom typing import Any, Dict, Optional\nfrom ..core.models import Resource, StateRecord\n\nclass BaseProvider(ABC):\n    \"\"\"Interface that all concrete providers must implement.\"\"\"\n    \n    @abstractmethod\n    def create(self, resource: Resource) -> StateRecord:\n        \"\"\"Create a new resource.\n        \n        Args:\n            resource: The desired resource configuration.\n            \n        Returns:\n            A StateRecord representing the newly created resource, including its\n            server-assigned ID and final attributes.\n            \n        Raises:\n            ProviderError: If creation fails.\n        \"\"\"\n        pass\n    \n    @abstractmethod\n    def read(self, resource_id: str, resource_type: str) -> Optional[StateRecord]:\n        \"\"\"Read the current state of a resource from the provider.\n        \n        Args:\n            resource_id: The unique identifier of the resource.\n            resource_type: The type of resource.\n            \n        Returns:\n            A StateRecord if the resource exists, None if it does not.\n            \n        Raises:\n            ProviderError: If the read operation fails (e.g., network error).\n        \"\"\"\n        pass\n    \n    @abstractmethod\n    def update(self, resource: Resource, prior_state: StateRecord) -> StateRecord:\n        \"\"\"Update an existing resource.\n        \n        Args:\n            resource: The new desired configuration.\n            prior_state: The state of the resource before the update.\n            \n        Returns:\n            A StateRecord representing the updated resource.\n            \n        Raises:\n            ProviderError: If update fails or the resource cannot be updated in-place.\n        \"\"\"\n        pass\n    \n    @abstractmethod\n    def delete(self, resource_id: str, resource_type: str, prior_state: StateRecord) -> None:\n        \"\"\"Delete an existing resource.\n        \n        Args:\n            resource_id: The unique identifier of the resource.\n            resource_type: The type of resource.\n            prior_state: The last known state of the resource.\n            \n        Raises:\n            ProviderError: If deletion fails.\n        \"\"\"\n        pass\n    \n    @abstractmethod\n    def validate_credentials(self) -> bool:\n        \"\"\"Validate that the provider is properly configured and credentials work.\n        \n        Returns:\n            True if credentials are valid, False otherwise.\n        \"\"\"\n        pass\n```\n\n**C. Infrastructure Starter Code**\n\n**1. Atomic File Operations Utility (`src/iac_engine/utils/atomic_file.py`):**\n```python\n\"\"\"Utilities for atomic file writes to prevent corruption.\"\"\"\nimport os\nimport tempfile\nimport shutil\nfrom pathlib import Path\nfrom typing import Any\nimport json\n\ndef write_atomic_json(filepath: Path, data: Any) -> None:\n    \"\"\"Write JSON data to a file atomically.\n    \n    Writes to a temporary file in the same directory, then renames it\n    to the target filepath. This prevents partial writes if the process\n    crashes during write.\n    \n    Args:\n        filepath: The destination file path.\n        data: Serializable data to write as JSON.\n    \"\"\"\n    filepath.parent.mkdir(parents=True, exist_ok=True)\n    \n    # Create a temporary file in the same directory\n    with tempfile.NamedTemporaryFile(\n        mode='w',\n        dir=filepath.parent,\n        prefix=f\".{filepath.name}.tmp.\",\n        delete=False\n    ) as tmp_file:\n        json.dump(data, tmp_file, indent=2)\n        tmp_path = Path(tmp_file.name)\n    \n    try:\n        # Atomic rename (POSIX guarantees this is atomic)\n        tmp_path.rename(filepath)\n    except Exception:\n        # If rename fails, clean up the temporary file\n        tmp_path.unlink(missing_ok=True)\n        raise\n\ndef read_json_with_backup(filepath: Path) -> Any:\n    \"\"\"Read JSON file, with automatic fallback to a backup if present.\n    \n    Args:\n        filepath: The primary file path to read.\n        \n    Returns:\n        The parsed JSON data.\n        \n    Raises:\n        FileNotFoundError: If neither the file nor its backup exists.\n        json.JSONDecodeError: If the file contains invalid JSON.\n    \"\"\"\n    backup_path = filepath.with_suffix(filepath.suffix + \".backup\")\n    \n    for path in [filepath, backup_path]:\n        if path.exists():\n            try:\n                with open(path, 'r') as f:\n                    return json.load(f)\n            except json.JSONDecodeError:\n                # If the main file is corrupt, try the backup\n                if path == filepath and backup_path.exists():\n                    continue\n                raise\n    \n    raise FileNotFoundError(f\"State file not found: {filepath}\")\n```\n\n**D. Core Logic Skeleton Code**\n\n**1. Main CLI Entry Point (`src/iac_engine/cli.py`):**\n```python\n\"\"\"Command-line interface for the IaC engine.\"\"\"\nimport argparse\nfrom pathlib import Path\nfrom typing import Optional\n\n# TODO: Import the core components once implemented\n# from .core.parser import ConfigurationParser\n# from .core.state_manager import StateManager\n# from .core.planner import Planner\n# from .core.executor import Executor\n\ndef plan_command(config_path: Path, state_path: Path, var_file: Optional[Path]) -> None:\n    \"\"\"Generate and show an execution plan.\n    \n    Args:\n        config_path: Path to the main configuration file.\n        state_path: Path to the state file.\n        var_file: Optional path to a file containing variable values.\n    \"\"\"\n    print(f\"Planning for config: {config_path}\")\n    \n    # TODO 1: Initialize the ConfigurationParser and parse the config file\n    # parser = ConfigurationParser()\n    # desired_resources = parser.parse_file(config_path, var_file)\n    \n    # TODO 2: Initialize the StateManager and read the current state\n    # state_manager = StateManager(state_path)\n    # current_state = state_manager.read_state()\n    \n    # TODO 3: Initialize the Planner, build the dependency graph, and generate plan\n    # planner = Planner()\n    # execution_plan = planner.generate_plan(desired_resources, current_state)\n    \n    # TODO 4: Display the plan in a human-readable format\n    # print(execution_plan.summary())\n    \n    print(\"Plan command not yet implemented.\")\n\ndef apply_command(config_path: Path, state_path: Path, var_file: Optional[Path], auto_approve: bool) -> None:\n    \"\"\"Apply the changes required to reach the desired state.\n    \n    Args:\n        config_path: Path to the main configuration file.\n        state_path: Path to the state file.\n        var_file: Optional path to a file containing variable values.\n        auto_approve: If True, skip interactive approval.\n    \"\"\"\n    print(f\"Applying config: {config_path}\")\n    # TODO: Implement apply workflow\n    print(\"Apply command not yet implemented.\")\n\ndef main():\n    \"\"\"Parse command line arguments and dispatch to appropriate function.\"\"\"\n    parser = argparse.ArgumentParser(description=\"Infrastructure as Code Engine\")\n    subparsers = parser.add_subparsers(dest='command', required=True)\n    \n    # Plan command\n    plan_parser = subparsers.add_parser('plan', help='Generate an execution plan')\n    plan_parser.add_argument('config', type=Path, help='Path to configuration file')\n    plan_parser.add_argument('--state', type=Path, default=Path(\"./terraform.tfstate\"), help='Path to state file')\n    plan_parser.add_argument('--var-file', type=Path, help='Path to variable definitions file')\n    \n    # Apply command\n    apply_parser = subparsers.add_parser('apply', help='Apply the execution plan')\n    apply_parser.add_argument('config', type=Path, help='Path to configuration file')\n    apply_parser.add_argument('--state', type=Path, default=Path(\"./terraform.tfstate\"), help='Path to state file')\n    apply_parser.add_argument('--var-file', type=Path, help='Path to variable definitions file')\n    apply_parser.add_argument('--auto-approve', action='store_true', help='Skip interactive approval')\n    \n    args = parser.parse_args()\n    \n    if args.command == 'plan':\n        plan_command(args.config, args.state, args.var_file)\n    elif args.command == 'apply':\n        apply_command(args.config, args.state, args.var_file, args.auto_approve)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n**E. Language-Specific Hints**\n\n*   **Data Classes:** Use `@dataclass` from the `dataclasses` module (as shown) for the core models. They provide a clean, boilerplate-free way to define data structures with type hints.\n*   **Path Management:** Use `pathlib.Path` instead of string paths for all file operations. It provides a more object-oriented and cross-platform API.\n*   **Type Hints:** Make extensive use of Python type hints (`from typing import ...`). They serve as documentation and enable static type checking with tools like `mypy`, catching many errors early.\n*   **Abstract Base Classes:** The `abc` module is perfect for defining the `BaseProvider` interface. Use `@abstractmethod` to enforce implementation in subclasses.\n*   **Serialization:** For the state file, `json` is simple and human-readable. Use `json.dump` with `indent=2` for debugging. For production, consider adding a schema validation step before writing.\n\n**F. Milestone Checkpoint**\n\nAfter setting up the project structure and the skeleton code above, you should be able to:\n1.  Create a virtual environment and install basic dependencies (e.g., `pip install pyyaml`).\n2.  Run the CLI with `python -m src.iac_engine.cli plan ./examples/simple-webapp/main.hcl` and see the \"not yet implemented\" message.\n3.  Verify that the core data models can be imported and instantiated correctly by writing a simple test script:\n    ```python\n    from iac_engine.core.models import Resource, ActionType\n    r = Resource(id=\"test.vm\", type=\"mock_instance\", name=\"vm\", attributes={\"size\": \"large\"})\n    print(r)  # Should print a readable representation\n    ```\nThis confirms the foundational project setup is correct before diving into component-specific implementation in the following milestones.\n\n\n## Data Model\n\n> **Milestone(s):** This section defines the foundational data structures used throughout the entire IaC engine and is relevant to all milestones (1, 2, 3, 4).\n\nThe **Data Model** serves as the common language spoken by all components of the IaC engine. It defines the core entities—resources, state records, plan actions, and dependency nodes—that flow through the system as infrastructure configurations are transformed from declarative intent into actual deployed resources. A consistent, well-defined data model is crucial because it ensures that the parser, state manager, planner, and executor can communicate without ambiguity, even as each component performs vastly different operations. This section provides the complete specification for these data structures and maps their lifecycle transformations.\n\n### Mental Model: The Recipe, the Pantry Inventory, the Shopping List, and the Cooking Steps\n\nImagine you're preparing a complex meal:\n1.  **The Recipe (`Resource`):** This is your desired end state—a list of ingredients and instructions. \"2 tomatoes, 1 onion, sauté for 10 minutes.\" It's declarative: you specify *what* you want, not the imperative steps to get it if ingredients are missing.\n2.  **The Pantry Inventory (`StateRecord`):** This is a snapshot of what you currently have. \"Pantry contains 1 tomato, 0 onions.\" It's a record of reality at a specific point in time.\n3.  **The Shopping List (`PlanAction`):** By comparing the recipe to your pantry, you generate a list of actions needed: \"BUY 1 tomato, BUY 1 onion.\" This is the **execution plan**—a set of imperative changes to bridge the gap between desired state (recipe) and current state (pantry).\n4.  **The Cooking Dependency Chart (`DependencyGraphNode`):** Some steps depend on others. You must chop the onion (Resource A) before you can sauté it with the tomatoes (Resource B). This chart defines the order in which actions must be executed.\n\nIn our IaC engine, the **Parser** reads the recipe (HCL/YAML config). The **State Manager** maintains the pantry inventory (state file). The **Planner** compares the two to create the shopping list (execution plan) and consults the dependency chart to put the list in the correct order. Finally, the **Executor** goes to the store and cooks (applies the plan via providers).\n\n### Key Types and Structures\n\nThe following tables define the primary data structures. All components must use these exact definitions to ensure interoperability. The fields are designed to carry all necessary information through each stage of the pipeline, from configuration parsing to final state persistence.\n\n#### `Resource`: The Declarative Intent\n\nA `Resource` represents a single infrastructure object as declared in the configuration file. It is the desired state specification before any runtime or state information is attached.\n\n| Field Name | Type | Description |\n| :--- | :--- | :--- |\n| `id` | `string` | **A unique, immutable identifier for the resource *within the configuration*.** This is typically constructed by the parser as `{resource_type}.{resource_name}` (e.g., `aws_instance.web_server`). It is used as the primary key for referencing resources in dependencies and within the state file. It is distinct from a cloud provider's runtime ID (e.g., `i-0abc123def456`). |\n| `type` | `string` | **The type of cloud resource.** This maps directly to a provider's resource type. Examples: `aws_instance`, `google_compute_instance`, `kubernetes_deployment`. The provider interface uses this field to route CRUD operations to the correct implementation. |\n| `name` | `string` | **The logical name given to the resource by the user in the configuration.** This is the local identifier within a configuration file or module. Example: In `resource \"aws_instance\" \"web_server\" { ... }`, the `name` is `\"web_server\"`. |\n| `attributes` | `map[string]any` | **The complete set of configuration properties for the resource.** This is a key-value map where keys are attribute names (e.g., `ami`, `instance_type`, `tags`) and values are the fully resolved, interpolated values after variable and module processing. The structure of this map must conform to the schema expected by the corresponding provider. |\n\n**Example:** A resource block `resource \"aws_s3_bucket\" \"data_lake\" { bucket = \"my-unique-name\" }` would be parsed into a `Resource` object with:\n- `id`: `\"aws_s3_bucket.data_lake\"`\n- `type`: `\"aws_s3_bucket\"`\n- `name`: `\"data_lake\"`\n- `attributes`: `{\"bucket\": \"my-unique-name\", \"acl\": null, ...}` (including default or omitted attributes).\n\n#### `StateRecord`: The Known Reality\n\nA `StateRecord` is a snapshot of an infrastructure resource as it exists (or is believed to exist) in the real world. It is persisted to the **state file** and serves as the system's \"memory\" of what it has previously created or managed.\n\n| Field Name | Type | Description |\n| :--- | :--- | :--- |\n| `resource_id` | `string` | **The unique identifier of the resource, matching the `Resource.id` from configuration.** This creates the link between a configuration declaration and its recorded state. |\n| `resource_type` | `string` | **The type of the resource.** Duplicated from the corresponding `Resource.type` for convenience and integrity checks. |\n| `resource_name` | `string` | **The logical name of the resource.** Duplicated from the corresponding `Resource.name`. |\n| `attributes` | `map[string]any` | **The actual attribute values as reported by the cloud provider's API during the last successful `read` or `apply` operation.** This includes **all** provider-output attributes, not just those set in configuration (e.g., a VM's `public_ip` assigned by the cloud, or a database's `arn`). This map is the source of truth for calculating diffs. |\n| `dependencies` | `list[string]` | **A list of `resource_id` values that this resource depends on.** This is persisted to avoid the need to re-compute the dependency graph from configuration on every run, which is critical for operations like `destroy` where the configuration may no longer be available. It captures both explicit (`depends_on`) and implicit (attribute reference) dependencies. |\n\n**Example:** After creating the S3 bucket above, a `StateRecord` might be:\n- `resource_id`: `\"aws_s3_bucket.data_lake\"`\n- `resource_type`: `\"aws_s3_bucket\"`\n- `resource_name`: `\"data_lake\"`\n- `attributes`: `{\"bucket\": \"my-unique-name\", \"arn\": \"arn:aws:s3:::my-unique-name\", \"region\": \"us-east-1\", ...}`\n- `dependencies`: `[]`\n\n#### `PlanAction`: The Proposed Change\n\nA `PlanAction` represents a single discrete change that needs to be applied to the infrastructure to align reality with the desired state. An **execution plan** is an ordered list of `PlanAction` objects.\n\n| Field Name | Type | Description |\n| :--- | :--- | :--- |\n| `action_type` | `enum(ActionType)` | **The type of change to perform.** The possible values are: <br>- `ActionType.CREATE`: The resource does not exist in state and must be created.<br>- `ActionType.UPDATE`: The resource exists, but one or more of its `attributes` have changed.<br>- `ActionType.DELETE`: The resource exists in state but is no longer present in the configuration.<br>- `ActionType.NOOP`: The resource exists and its configuration matches the state; no action is required. |\n| `resource` | `Resource` | **The desired state of the resource after the action completes.** For `CREATE` and `UPDATE`, this is the target configuration. For `DELETE`, this field contains the resource's last known configuration (useful for provider operations). For `NOOP`, it's the current configuration. |\n| `prior_state` | `StateRecord` (optional) | **The state of the resource before the action, if it exists.** This is `null` for `CREATE` actions. For `UPDATE` and `DELETE`, it holds the `StateRecord` read from the state file. It is used by the provider's `update` method to compute a partial update and by the executor for rollback information. |\n| `new_state` | `StateRecord` (optional) | **The expected state of the resource after the action succeeds.** This is populated by the **Planner** as a *prediction* and is later updated by the **Executor** with the *actual* results from the provider. It starts with the `attributes` from `resource` and will be merged with provider-output attributes after a successful `create` or `update`. |\n\n**Example:** If you change the S3 bucket's `acl` attribute from `private` to `public-read`, the planner generates a `PlanAction` with:\n- `action_type`: `ActionType.UPDATE`\n- `resource`: `Resource{id: \"aws_s3_bucket.data_lake\", attributes: {\"bucket\": \"my-unique-name\", \"acl\": \"public-read\", ...}}`\n- `prior_state`: `StateRecord{...attributes: {\"acl\": \"private\", ...}}`\n- `new_state`: `StateRecord{...attributes: {\"acl\": \"public-read\", ...}}` (predicted)\n\n#### `DependencyGraphNode`: The Ordering Constraint\n\nA `DependencyGraphNode` is a vertex in the **Directed Acyclic Graph (DAG)** that encodes the order dependencies between resources. The graph is built by the **Planner** and is used to topologically sort the `PlanAction` list.\n\n| Field Name | Type | Description |\n| :--- | :--- | :--- |\n| `resource_id` | `string` | **The identifier of the resource this node represents.** Matches `Resource.id` and `StateRecord.resource_id`. This is the node's unique key in the graph. |\n| `depends_on` | `list[string]` | **List of `resource_id` values that *this* resource depends on.** These are the outgoing edges. For example, if a subnet must exist before a VM can be created in it, the VM's node will have the subnet's `resource_id` in its `depends_on` list. |\n| `required_by` | `list[string]` | **List of `resource_id` values that depend on *this* resource.** These are the incoming edges. This field is often derived for convenience during graph traversal and topological sorting (it is the inverse of `depends_on` relationships across the graph). |\n\n**Example:** A network interface (`aws_network_interface.main`) depends on a subnet (`aws_subnet.main`). Their graph nodes would be:\n- Subnet Node: `resource_id: \"aws_subnet.main\", depends_on: [], required_by: [\"aws_network_interface.main\"]`\n- Interface Node: `resource_id: \"aws_network_interface.main\", depends_on: [\"aws_subnet.main\"], required_by: []`\n\n#### Supporting Enum: `ActionType`\n\nThis enumeration defines the four fundamental operations in a plan.\n\n| Constant | Description |\n| :--- | :--- |\n| `ActionType.CREATE` | The resource must be created. Corresponds to the provider's `create` method. |\n| `ActionType.UPDATE` | The resource must be updated in-place. Corresponds to the provider's `update` method. |\n| `ActionType.DELETE` | The resource must be destroyed. Corresponds to the provider's `delete` method. |\n| `ActionType.NOOP` | No operation is needed. The resource is already in sync. |\n\n### Type Relationships and Lifecycle\n\nThe data structures do not exist in isolation; they undergo a series of transformations as they move through the IaC engine's workflow. Understanding this lifecycle is key to understanding how the system maintains consistency and safety.\n\n#### Lifecycle Stages and Transformations\n\nThe journey from configuration to deployed infrastructure involves three primary states for each resource, represented by our core types:\n1.  **Desired State (`Resource`):** Defined by the user in HCL/YAML.\n2.  **Proposed Change (`PlanAction`):** Calculated by comparing Desired State with Known State.\n3.  **Known State (`StateRecord`):** Persisted after successful application of a change.\n\nThe following diagram illustrates the relationships and transformations:\n![Data Model Relationships](./diagrams/data-model-class.svg)\n\n**1. Configuration Parsing (Milestone 1)**\nThe **Parser** reads raw configuration files (HCL/YAML) and, after resolving variables, modules, and interpolations, produces a flat list of `Resource` objects. This list represents the complete desired state of the system. At this stage, `Resource.attributes` contain the final, user-specified values.\n\n> **Example Transformation:** The parser encounters `instance_type = \"${var.instance_size}\"`. It resolves `var.instance_size` to `\"t3.micro\"` and stores `\"t3.micro\"` in the `Resource.attributes` map under the key `instance_type`.\n\n**2. State Loading and Diff Calculation (Milestone 2)**\nThe **State Manager** loads the previous `StateRecord` for each `Resource` from the state file (keyed by `resource_id`). For each resource, the system now holds two representations:\n*   **Desired (`Resource`):** `{id: \"a\", attributes: {\"size\": \"large\"}}`\n*   **Actual (`StateRecord`):** `{resource_id: \"a\", attributes: {\"size\": \"medium\"}}`\n\nThe **Planner** performs a diff between these two representations. The diff logic must be aware of provider-specific semantics (e.g., some attributes are immutable and force a `DELETE`+`CREATE` instead of an `UPDATE`). The output of this diff is a **draft** `PlanAction` for the resource.\n\n> **Decision: Diffing Strategy**\n> - **Context:** We need to determine what constitutes a change worthy of an `UPDATE` action. A naive comparison of the entire `attributes` map is insufficient because the state contains read-only/computed fields (like ARNs, IDs) that are not present in the configuration.\n> - **Options Considered:**\n>     1.  **Full Deep Diff:** Compare all keys in both `Resource.attributes` and `StateRecord.attributes`, flagging any difference.\n>     2.  **Config-Key-Only Diff:** Only compare keys that are present in `Resource.attributes`. Ignore keys that only exist in `StateRecord.attributes` (computed fields).\n>     3.  **Schema-Aware Diff:** Use the provider's resource schema to classify attributes as \"configurable\" (requires update if changed) or \"computed\" (ignore for diff).\n> - **Decision:** Option 2, **Config-Key-Only Diff**.\n> - **Rationale:** It is simple to implement and correct for the majority of cases. Computed fields are outputs from the provider and should not trigger updates. While Option 3 is more robust, it requires integrating complex schema information at the planning stage, which is a significant increase in complexity for a learning project.\n> - **Consequences:** This approach may incorrectly flag a change if a user removes a configurable attribute from their configuration (as the diff will see a mismatch between `config[attr]=None` and `state[attr]=value`). We must treat a `None` in config as \"use default or remove,\" which requires special handling per attribute. This is a known simplification.\n\n| Option | Pros | Cons | Chosen? |\n| :--- | :--- | :--- | :--- |\n| Full Deep Diff | Simple, catches all changes. | Incorrectly triggers updates on computed/immutable fields, leading to failed applies. | ❌ |\n| Config-Key-Only Diff | Avoids noise from computed fields. Simple logic. | Requires careful handling of `null`/absent values. May miss force-new updates on immutable fields. | ✅ |\n| Schema-Aware Diff | Most accurate. Can handle immutable fields correctly. | Complex. Requires tight coupling with provider schemas early in the pipeline. | ❌ |\n\n**3. Dependency Graph Construction and Plan Finalization (Milestone 3)**\nThe **Planner** builds a `DependencyGraph` from the list of resources. Each node is a `DependencyGraphNode`. Edges are created by analyzing `Resource` attribute values for references (e.g., `subnet_id = aws_subnet.main.id` creates a dependency from the referencing resource to `aws_subnet.main`) and processing explicit `depends_on` directives.\n\nThe draft `PlanAction` list is then **topologically sorted** based on this graph. `CREATE` actions are ordered from dependencies to dependents. `DELETE` actions are ordered in the **reverse** direction (dependents before dependencies). This sorted list becomes the final **execution plan**.\n\n**4. Plan Execution and State Persistence (Milestone 4)**\nThe **Executor** iterates through the sorted `PlanAction` list. For each action:\n*   It calls the appropriate CRUD method on the `BaseProvider` (e.g., `create(resource)` for `ActionType.CREATE`).\n*   Upon success, it calls the provider's `read` method to obtain the *actual* new attributes from the cloud API.\n*   It constructs a new `StateRecord` using these read attributes and the persisted dependency list.\n*   It updates the `PlanAction.new_state` field with this record.\n*   After all actions for a resource are complete, the **Executor** sends the updated `StateRecord` to the **State Manager**, which atomically writes it to the state file, replacing the old `StateRecord`.\n\nThis last step closes the loop: the `StateRecord` generated from execution becomes the new \"known state\" for the next run.\n\n#### Walk-Through: A Complete Resource Lifecycle\n\nLet's trace a single resource, `aws_instance.app_server`, through a typical create-update-delete scenario.\n\n1.  **Initial Run (Create):**\n    *   **Config:** `resource \"aws_instance\" \"app_server\" { ami = \"ami-123\" }`\n    *   **Parser Output:** `Resource{id=\"aws_instance.app_server\", type=\"aws_instance\", name=\"app_server\", attributes={\"ami\": \"ami-123\"}}`\n    *   **State File:** No existing `StateRecord` for `aws_instance.app_server`.\n    *   **Planner Diff:** `prior_state` is `null`, `action_type` = `CREATE`.\n    *   **PlanAction:** `{action_type: CREATE, resource: Resource{...}, prior_state: null, new_state: StateRecord{predicted...}}`\n    *   **Executor:** Calls `provider.create(...)`. Gets actual instance ID `i-abc123` from cloud.\n    *   **New State:** `StateRecord{resource_id: \"aws_instance.app_server\", attributes: {\"ami\": \"ami-123\", \"id\": \"i-abc123\", \"public_ip\": \"1.2.3.4\"}, dependencies: []}` is written to state file.\n\n2.  **Second Run (Update):**\n    *   **Config Changed:** `ami = \"ami-456\"`\n    *   **Parser Output:** `Resource{attributes={\"ami\": \"ami-456\"}}`\n    *   **State Loaded:** The `StateRecord` from step 1.\n    *   **Planner Diff:** `ami` differs (`\"ami-456\"` vs `\"ami-123\"`). `action_type` = `UPDATE`.\n    *   **PlanAction:** `{action_type: UPDATE, resource: Resource{...ami-456}, prior_state: StateRecord{...ami-123}, new_state: StateRecord{predicted...}}`\n    *   **Executor:** Calls `provider.update(...)`. Cloud replaces the instance (new ID `i-def456`).\n    *   **New State:** `StateRecord{attributes: {\"ami\": \"ami-456\", \"id\": \"i-def456\", \"public_ip\": \"5.6.7.8\"}, ...}` overwrites the old record.\n\n3.  **Third Run (Delete):**\n    *   **Config:** The `aws_instance.app_server` block is removed.\n    *   **Parser Output:** No `Resource` with id `aws_instance.app_server`.\n    *   **State Loaded:** The `StateRecord` from step 2 still exists.\n    *   **Planner Diff:** Resource missing in config but present in state. `action_type` = `DELETE`.\n    *   **PlanAction:** `{action_type: DELETE, resource: Resource{last known config}, prior_state: StateRecord{...}, new_state: null}`\n    *   **Executor:** Calls `provider.delete(prior_state)`. Cloud destroys instance `i-def456`.\n    *   **State Updated:** The `StateRecord` for `aws_instance.app_server` is removed from the state file.\n\nThis predictable lifecycle, governed by the clear transformation between `Resource`, `PlanAction`, and `StateRecord`, is what enables the IaC engine to be idempotent and safe.\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Confusing `Resource.id` with Cloud Provider ID**\n*   **The Mistake:** Storing the cloud-assigned identifier (e.g., `i-0abc123`) in the `Resource.id` field or using it as the key in the state file.\n*   **Why It's Wrong:** The `Resource.id` is a logical identifier from configuration. It must be immutable and known before any API call. The cloud ID is an *output* of the create operation and belongs in `StateRecord.attributes`. Using the cloud ID as a key would break state tracking if the resource is recreated (new cloud ID).\n*   **The Fix:** Always use the structured `{type}.{name}` format for `Resource.id` and `StateRecord.resource_id`. Store the cloud provider ID as a plain attribute (e.g., `attributes[\"id\"]`) within the `StateRecord`.\n\n⚠️ **Pitfall: Storing Unresolved Variables or References in `Resource.attributes`**\n*   **The Mistake:** The Parser puts raw interpolated strings like `\"${var.region}\"` or references like `\"aws_vpc.main.id\"` into the `Resource.attributes` map.\n*   **Why It's Wrong:** The Planner's diff logic and the Provider's CRUD methods cannot work with unresolved references. They need concrete values (like `\"us-east-1\"`) or opaque IDs (like `\"vpc-123\"`).\n*   **The Fix:** Ensure the **Parser** fully resolves all variable interpolations and module outputs *before* creating the final `Resource` objects. References to other resources should be resolved to their *state* values (e.g., the actual VPC ID) by the Planner when building the dependency graph, and these concrete values should be placed in a copy of the `Resource` used for planning.\n\n⚠️ **Pitfall: Forgetting to Update `dependencies` in `StateRecord`**\n*   **The Mistake:** The `StateRecord` written after an apply contains an empty or outdated `dependencies` list.\n*   **Why It's Wrong:** The dependency graph is needed for `destroy` operations and for targeted plans. If the configuration is deleted, the system cannot rebuild the graph from source. An outdated list can lead to incorrect destroy order (trying to delete a subnet before deleting VMs inside it).\n*   **The Fix:** When the Planner builds the dependency graph, ensure the resulting `depends_on` list for each resource is captured and stored in the `StateRecord` that gets persisted after a successful apply.\n\n### Implementation Guidance\n\n**A. Technology Recommendations Table**\n\n| Component | Simple Option (Recommended for Learning) | Advanced Option (For Production) |\n| :--- | :--- | :--- |\n| Data Serialization | **Python's `json` module** (built-in, simple). Use `json.dumps` for writing and `json.loads` for reading. | **Pydantic models** with validation. Provides automatic type coercion, validation, and serialization. |\n| In-Memory Data Structures | **Python dictionaries (`dict`) and lists.** Directly map to JSON structures. Use `dataclasses` or simple classes for type hints. | **TypedDict** (Python 3.8+) for stricter dictionary shape validation. `@dataclass` for mutable objects. |\n| Enum Implementation | **Python `enum.Enum` class.** Provides clear names for `ActionType`. | **`str`-based enums** (`enum.Enum` with mixin) for easier JSON serialization. |\n\n**B. Recommended File/Module Structure**\n\nPlace the core data model definitions in a central module that all other components can import.\n\n```\ninfrastructure-as-code-engine/\n├── iac/\n│   ├── __init__.py\n│   ├── models/                  # Data model definitions\n│   │   ├── __init__.py\n│   │   ├── resource.py          # Resource class\n│   │   ├── state.py             # StateRecord class & StateFile container\n│   │   ├── plan.py              # PlanAction class & ActionType enum\n│   │   └── graph.py             # DependencyGraphNode & Graph class\n│   ├── parser/                  # Milestone 1\n│   ├── state/                   # Milestone 2\n│   ├── planner/                 # Milestone 3\n│   └── executor/                # Milestone 4\n└── pyproject.toml\n```\n\n**C. Infrastructure Starter Code (COMPLETE, ready to use)**\n\n**1. Base Model Helper (JSON Serialization):** Create a mixin class to easily convert our models to/from dictionaries for JSON serialization.\n\n```python\n# iac/models/__init__.py\nimport json\nfrom typing import Any, Dict\nfrom abc import ABC\n\nclass JsonSerializable(ABC):\n    \"\"\"Mixin class to provide to_dict and from_dict methods.\"\"\"\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert the object to a dictionary suitable for JSON serialization.\"\"\"\n        # This simple implementation works for dataclasses and simple classes.\n        # For complex objects, override this method in the subclass.\n        return self.__dict__.copy()\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> Any:\n        \"\"\"Create an instance of the class from a dictionary.\"\"\"\n        return cls(**data)\n\n    def to_json(self) -> str:\n        \"\"\"Serialize the object to a JSON string.\"\"\"\n        return json.dumps(self.to_dict(), indent=2)\n\n    @classmethod\n    def from_json(cls, json_str: str) -> Any:\n        \"\"\"Deserialize the object from a JSON string.\"\"\"\n        data = json.loads(json_str)\n        return cls.from_dict(data)\n```\n\n**2. Atomic File Operations Helper:** Use this for safe reading/writing of state and lock files.\n\n```python\n# iac/utils/file.py\nimport os\nimport json\nimport tempfile\nfrom pathlib import Path\nfrom typing import Any\n\ndef write_atomic_json(filepath: Path, data: Any) -> None:\n    \"\"\"\n    Write JSON data to a file atomically to prevent corruption.\n    Writes to a temporary file in the same directory then renames it.\n    \"\"\"\n    filepath = Path(filepath)\n    # Create a temporary file in the same directory for atomic rename\n    with tempfile.NamedTemporaryFile(\n        mode='w',\n        dir=filepath.parent,\n        prefix=f\".{filepath.name}.tmp.\",\n        delete=False\n    ) as tmp:\n        json.dump(data, tmp, indent=2)\n        tmp.flush()\n        os.fsync(tmp.fileno())\n        tmp_path = Path(tmp.name)\n\n    # Atomic rename (POSIX systems guarantee this is atomic)\n    try:\n        os.rename(tmp_path, filepath)\n    except Exception:\n        # Clean up temp file if rename fails\n        tmp_path.unlink(missing_ok=True)\n        raise\n\ndef read_json_with_backup(filepath: Path) -> Any:\n    \"\"\"\n    Read JSON file, with automatic fallback to a backup if present.\n    Returns the parsed data or raises FileNotFoundError if neither exists.\n    \"\"\"\n    filepath = Path(filepath)\n    backup_path = filepath.with_suffix(filepath.suffix + '.backup')\n\n    data = None\n    last_error = None\n\n    # Try main file first\n    if filepath.exists():\n        try:\n            with open(filepath, 'r') as f:\n                data = json.load(f)\n        except (json.JSONDecodeError, OSError) as e:\n            last_error = e\n            # Main file corrupted, try backup\n            if backup_path.exists():\n                try:\n                    with open(backup_path, 'r') as f:\n                        data = json.load(f)\n                    # Backup was good, restore it\n                    write_atomic_json(filepath, data)\n                except (json.JSONDecodeError, OSError) as backup_error:\n                    last_error = backup_error\n                    data = None\n    elif backup_path.exists():\n        # No main file, but backup exists (e.g., after a crash)\n        try:\n            with open(backup_path, 'r') as f:\n                data = json.load(f)\n            # Restore from backup\n            write_atomic_json(filepath, data)\n        except (json.JSONDecodeError, OSError) as e:\n            last_error = e\n            data = None\n\n    if data is None:\n        raise FileNotFoundError(\n            f\"Could not read valid JSON from {filepath} or backup. Last error: {last_error}\"\n        )\n    return data\n```\n\n**D. Core Logic Skeleton Code**\n\n**1. Data Model Definitions (`Resource`, `StateRecord`, `PlanAction`, `DependencyGraphNode`):**\n\n```python\n# iac/models/resource.py\nfrom dataclasses import dataclass, field\nfrom typing import Any, Dict\nfrom ..models import JsonSerializable\n\n@dataclass\nclass Resource(JsonSerializable):\n    \"\"\"Represents a desired infrastructure resource from configuration.\"\"\"\n    id: str  # Format: \"resource_type.resource_name\"\n    type: str  # e.g., \"aws_instance\"\n    name: str  # Logical name from config\n    attributes: Dict[str, Any] = field(default_factory=dict)\n\n    def __post_init__(self):\n        # Basic validation\n        if not self.id:\n            raise ValueError(\"Resource id cannot be empty\")\n        if '.' not in self.id:\n            raise ValueError(f\"Resource id should be in format 'type.name', got: {self.id}\")\n```\n\n```python\n# iac/models/state.py\nfrom dataclasses import dataclass, field\nfrom typing import Any, Dict, List, Optional\nfrom ..models import JsonSerializable\n\n@dataclass\nclass StateRecord(JsonSerializable):\n    \"\"\"Snapshot of a deployed resource's actual state.\"\"\"\n    resource_id: str\n    resource_type: str\n    resource_name: str\n    attributes: Dict[str, Any] = field(default_factory=dict)\n    dependencies: List[str] = field(default_factory=list)  # List of resource_ids this depends on\n\n    def __post_init__(self):\n        if not self.resource_id:\n            raise ValueError(\"StateRecord.resource_id cannot be empty\")\n```\n\n```python\n# iac/models/plan.py\nimport enum\nfrom dataclasses import dataclass, field\nfrom typing import Optional\nfrom .resource import Resource\nfrom .state import StateRecord\nfrom ..models import JsonSerializable\n\nclass ActionType(enum.Enum):\n    \"\"\"The type of change to perform on a resource.\"\"\"\n    CREATE = \"create\"\n    UPDATE = \"update\"\n    DELETE = \"delete\"\n    NOOP = \"noop\"\n\n    def __str__(self):\n        return self.value\n\n@dataclass\nclass PlanAction(JsonSerializable):\n    \"\"\"A proposed change to bring reality in line with desired state.\"\"\"\n    action_type: ActionType\n    resource: Resource\n    prior_state: Optional[StateRecord] = None\n    new_state: Optional[StateRecord] = None\n\n    def to_dict(self) -> Dict[str, Any]:\n        # Custom serialization to handle Enums and nested objects\n        data = {\n            \"action_type\": self.action_type.value,\n            \"resource\": self.resource.to_dict(),\n            \"prior_state\": self.prior_state.to_dict() if self.prior_state else None,\n            \"new_state\": self.new_state.to_dict() if self.new_state else None,\n        }\n        return data\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> 'PlanAction':\n        # Custom deserialization\n        return cls(\n            action_type=ActionType(data[\"action_type\"]),\n            resource=Resource.from_dict(data[\"resource\"]),\n            prior_state=StateRecord.from_dict(data[\"prior_state\"]) if data.get(\"prior_state\") else None,\n            new_state=StateRecord.from_dict(data[\"new_state\"]) if data.get(\"new_state\") else None,\n        )\n```\n\n```python\n# iac/models/graph.py\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Set\nfrom ..models import JsonSerializable\n\n@dataclass\nclass DependencyGraphNode(JsonSerializable):\n    \"\"\"A node in the resource dependency graph.\"\"\"\n    resource_id: str\n    depends_on: List[str] = field(default_factory=list)  # Outgoing edges\n    required_by: List[str] = field(default_factory=list)  # Incoming edges (derived)\n\nclass DependencyGraph:\n    \"\"\"A directed graph representing resource dependencies.\"\"\"\n\n    def __init__(self):\n        self.nodes: Dict[str, DependencyGraphNode] = {}\n\n    def add_node(self, resource_id: str) -> None:\n        \"\"\"Add a node for the given resource_id if it doesn't exist.\"\"\"\n        # TODO 1: Check if node with resource_id already exists in self.nodes\n        # TODO 2: If not, create a new DependencyGraphNode with that resource_id\n        # TODO 3: Store it in self.nodes\n        pass\n\n    def add_dependency(self, from_resource_id: str, to_resource_id: str) -> None:\n        \"\"\"\n        Add a dependency edge: from_resource depends on to_resource.\n        This means from_resource -> to_resource (from must be created after to).\n        \"\"\"\n        # TODO 1: Ensure both nodes exist (call add_node for each)\n        # TODO 2: Add to_resource_id to from_resource.depends_on list (if not already present)\n        # TODO 3: Add from_resource_id to to_resource.required_by list (if not already present)\n        pass\n\n    def topological_sort(self) -> List[str]:\n        \"\"\"\n        Return a list of resource_ids in topological order (dependencies first).\n        Raises ValueError if a cycle is detected.\n        \"\"\"\n        # TODO 1: Create a copy of the graph's dependency information\n        # TODO 2: Find all nodes with zero in-degree (empty depends_on)\n        # TODO 3: While there are zero in-degree nodes:\n        #   TODO 3a: Remove one and add it to result list\n        #   TODO 3b: For each node that required it, remove the dependency edge\n        #   TODO 3c: Update zero in-degree list\n        # TODO 4: If result list length != total nodes, there's a cycle → raise ValueError\n        # TODO 5: Return the result list\n        pass\n\n    def reverse_topological_sort(self) -> List[str]:\n        \"\"\"\n        Return a list of resource_ids in reverse topological order (dependents first).\n        Useful for destroy operations.\n        \"\"\"\n        # TODO 1: Get topological sort\n        # TODO 2: Return it reversed\n        pass\n```\n\n**E. Language-Specific Hints**\n\n1.  **Use `@dataclass`**: They automatically generate `__init__`, `__repr__`, and `__eq__` methods, making your data models clean and Pythonic.\n2.  **Type Hints**: Use them everywhere. They don't affect runtime but help with IDE autocompletion and catching bugs early with tools like `mypy`.\n3.  **JSON Serialization for Enums**: The built-in `json` module doesn't serialize `Enum` objects by default. Our `PlanAction.to_dict()` method manually converts the `ActionType` enum to its string value. Alternatively, you could write a custom JSON encoder.\n4.  **Default Factories**: Use `field(default_factory=list)` instead of `field(default=[])` for mutable defaults to avoid shared list instances across instances.\n\n**F. Milestone Checkpoint**\n\nAfter implementing the data models, verify they work correctly by creating a simple test script:\n\n```python\n# test_models.py\nfrom iac.models import Resource, StateRecord, ActionType, PlanAction\n\n# Create a Resource\nr = Resource(id=\"aws_instance.web\", type=\"aws_instance\", name=\"web\", attributes={\"ami\": \"ami-123\"})\nprint(f\"Resource: {r}\")\nprint(f\"Resource JSON: {r.to_json()}\")\n\n# Create a StateRecord\ns = StateRecord(\n    resource_id=\"aws_instance.web\",\n    resource_type=\"aws_instance\",\n    resource_name=\"web\",\n    attributes={\"id\": \"i-abc123\", \"ami\": \"ami-123\"},\n    dependencies=[]\n)\nprint(f\"\\nStateRecord: {s}\")\n\n# Create a PlanAction\np = PlanAction(\n    action_type=ActionType.UPDATE,\n    resource=r,\n    prior_state=s,\n    new_state=None\n)\nprint(f\"\\nPlanAction: {p}\")\nprint(f\"PlanAction JSON: {p.to_json()}\")\n\n# Test round-trip serialization\np2 = PlanAction.from_json(p.to_json())\nassert p2.action_type == p.action_type\nassert p2.resource.id == p.resource.id\nprint(\"\\n✅ Round-trip serialization works!\")\n```\n\nRun this script. Expected output should show the objects and their JSON representations without errors, confirming your basic data model is functional.\n\n\n## Component Design: Configuration Parser\n> **Milestone(s):** 1\n\nThe **Configuration Parser** is the entry point of the IaC engine, responsible for translating human-readable configuration files into a normalized, machine-processable representation of desired infrastructure. It must comprehend a domain-specific language (like HCL or YAML), resolve dynamic expressions, assemble reusable modules, and produce a complete collection of `Resource` objects—the \"desired state\" that subsequent components will compare against reality. This component's accuracy is foundational; any misinterpretation here leads to incorrect plans and potentially destructive infrastructure changes.\n\n### Mental Model: The Interpreter and Expander\n\nImagine you are given a construction blueprint written in a mix of standard notations and custom shorthand. Your job is to produce a single, unambiguous, and fully detailed set of instructions for the construction crew. The original blueprint might have placeholders like \"use the `main_color` specified in the `branding` folder,\" and it might reference entire pre-drawn sections from other blueprint files labeled \"standard office module.\" You, as the interpreter, must:\n\n1.  **Parse the Syntax:** Understand the meaning of each symbol and notation (e.g., a box labeled \"VM\" means to provision a virtual machine).\n2.  **Expand Templates:** Find the definition of `main_color` (perhaps in a separate `variables.tf` file) and replace every placeholder with the concrete value \"Deep Blue.\"\n3.  **Combine Chapters:** Locate the \"standard office module\" file, interpret its contents, and integrate its defined resources (desks, chairs, network jacks) into the main plan, possibly customizing them for this specific building.\n\nIn this analogy, the original HCL/YAML files are the blueprint with shorthand and references. The Parser acts as the **Interpreter and Expander**. It reads the raw text, understands the structure (parsing), fills in the blanks (variable interpolation), and pulls in external definitions (module resolution) to output one comprehensive, flat list of concrete `Resource` definitions—the final, unambiguous construction plan. This process is visualized in the parsing flowchart: ![Flowchart: Configuration Parsing and Resolution](./diagrams/flowchart-parser.svg)\n\n### Interface and Public Methods\n\nThe Parser's public API is designed for a straightforward workflow: load a root configuration file and receive a complete set of resolved resources. Its core interface consists of the following methods.\n\n| Method Name | Parameters | Returns | Description |\n| :--- | :--- | :--- | :--- |\n| `parse_file` | `file_path: Path` | `dict` (Raw AST) | Reads a single configuration file from disk and parses it into a raw, unprocessed abstract syntax tree (AST) represented as a Python dictionary. This is a low-level method that does not perform resolution. |\n| `resolve_variables` | `ast: dict, variable_files: List[Path], cli_vars: dict` | `dict` (Resolved AST) | Takes a raw AST and a set of variable values (from files and command-line overrides) and recursively replaces all variable interpolation expressions (e.g., `${var.name}`) with their concrete values. Returns a new AST with values resolved. |\n| `load_module` | `module_call: dict, parent_dir: Path` | `dict` (Module AST) | Given a module block definition (from the AST) and the directory of the parent configuration, locates the module's source (local path), parses its files, recursively resolves its own variables and sub-modules, and returns the fully resolved AST for that module. |\n| `process_configuration` | `root_file: Path, variable_files: List[Path], cli_vars: dict` | `List[Resource]` | **Primary entry point.** Orchestrates the full parsing pipeline. Parses the root file, resolves all variables, recursively loads all referenced modules, flattens the structure, and converts the final resolved AST into a list of `Resource` objects ready for the Planner. |\n\nThe `Resource` type produced by `process_configuration` is a core data structure of the entire system. Its fields are detailed below.\n\n| Field Name | Type | Description |\n| :--- | :--- | :--- |\n| `id` | `string` | A unique, deterministic identifier for the resource within the configuration. Typically formed as `<resource_type>.<resource_name>` (e.g., `aws_instance.web_server`). |\n| `type` | `string` | The type of infrastructure resource, which maps to a specific provider and API (e.g., `aws_instance`, `google_sql_database_instance`). |\n| `name` | `string` | The logical name given to this resource instance within the configuration, unique within its type scope. |\n| `attributes` | `map[string]any` | A key-value map of all configuration arguments for the resource. These are the fully resolved, concrete values (e.g., `{\"ami\": \"ami-12345\", \"instance_type\": \"t3.micro\"}`). |\n\n### Internal Behavior and Algorithm\n\nThe `process_configuration` method implements a multi-stage pipeline to transform text files into `Resource` objects. The following numbered algorithm details each step.\n\n1.  **Load and Parse Root Configuration:** Read the primary configuration file (e.g., `main.tf`) from disk. Pass its content through a syntax parser (for HCL or YAML) to produce a **raw AST**. This AST is a hierarchical dictionary mirroring the configuration's structure, containing unresolved blocks, expressions, and references.\n\n2.  **Extract and Merge Variable Values:** Gather variable definitions from all sources, following a precedence order (lowest to highest): default values in variable declarations, values from variable files (e.g., `terraform.tfvars`), and finally values provided via command-line flags (`-var`). Merge them into a single `variables` dictionary, with higher-priority sources overriding lower ones.\n\n3.  **Resolve Variable Interpolation:** Perform a depth-first traversal of the raw AST. For every string value encountered, check for the interpolation pattern `${...}`.\n    1.  If the pattern matches `var.<name>`, look up the concrete value in the merged `variables` dictionary and replace the entire expression with that value.\n    2.  If the pattern matches a more complex expression (e.g., `function.call`, `resource.attr`), tag it for later resolution by the Planner. For this milestone, we focus only on `var` references.\n    3.  Recursively process the updated value in case interpolation returns another string with nested expressions.\n\n4.  **Resolve Module Blocks:** Traverse the resolved AST to find all `module` blocks. For each module block:\n    1.  Extract the `source` attribute (a local file path).\n    2.  Compute the absolute source directory relative to the parent configuration's directory.\n    3.  Recursively call the parsing pipeline (`process_configuration`) on the module's own root file (e.g., `./modules/vpc/main.tf`), passing down any variables defined in the module block's `inputs`.\n    4.  The recursive call returns a list of `Resource` objects defined within that module.\n    5.  **Namespace the module's resources:** To avoid ID collisions, prepend the module's logical name to each returned resource's `id` and `name`. For example, a `vpc` module containing a resource `aws_vpc.main` becomes `module.vpc.aws_vpc.main`.\n\n5.  **Flatten and Convert to Resources:** After processing all modules, you have a collection of resolved resource blocks from the root and all nested modules. Convert each resource block into a `Resource` object.\n    1.  The `type` is the block label (e.g., `aws_instance`).\n    2.  The `name` is the user-defined label for that resource block.\n    3.  The `attributes` are the key-value pairs inside the block, now with all `var.*` interpolations resolved.\n    4.  The `id` is generated as a concatenation of `type` and `name` (and module prefix if applicable).\n\n6.  **Output Resource List:** Return the final, flat list of all `Resource` objects. This list represents the complete desired state of the infrastructure as declared in the configuration.\n\nThis sequence is part of the larger `plan` command workflow, as shown in the sequence diagram: ![Sequence Diagram: Plan Command](./diagrams/plan-sequence.svg)\n\n### ADR: Abstract Syntax Tree vs. Direct Dict\n\n> **Decision: Use a Lightweight Dict-based AST**\n> - **Context:** We need an in-memory representation of the configuration's structure after parsing but before resolution. This representation must be easy to traverse, manipulate, and serialize. We must choose between building a formal Abstract Syntax Tree (AST) with dedicated node classes or using the native data structures (dicts, lists, strings) returned by the parser.\n> - **Options Considered:**\n>     1.  **Formal AST Classes:** Define Python classes for each node type (e.g., `BlockNode`, `AttributeNode`, `VariableExprNode`). Each class has defined fields and methods for traversal and manipulation.\n>     2.  **Lightweight Dict/List Structure:** Use the nested dictionaries and lists produced directly by the parser (e.g., PyHCL's output). Treat the structure generically.\n> - **Decision:** We will use the lightweight dict/list structure (Option 2).\n> - **Rationale:**\n>     *   **Simplicity and Development Speed:** The dict structure requires no upfront class design. It maps directly to JSON, simplifying debugging and serialization for tests. For an educational project, this reduces cognitive load and lets us focus on the resolution algorithms.\n>     *   **Parser Agnosticism:** Different parsers (for HCL, YAML, JSON) naturally output dicts. A generic dict interface allows us to swap or support multiple parsers without changing the resolution logic.\n>     *   **Sufficient for Needs:** Our resolution algorithms (tree traversal, string replacement) are structurally simple. They don't require the type safety or encapsulation benefits of a full class hierarchy at this stage.\n> - **Consequences:**\n>     *   **Pros:** Faster to implement, easier to debug (`print(json.dumps(ast, indent=2))`), flexible for different input formats.\n>     *   **Cons:** Loss of type safety—the code must defensively check for expected keys and structures. Less self-documenting than a class-based model. Complex transformations in future extensions might become harder to manage.\n\nThe comparison table below summarizes the trade-offs.\n\n| Option | Pros | Cons | Chosen? |\n| :--- | :--- | :--- | :--- |\n| **Formal AST Classes** | Type-safe, self-documenting, enables visitor pattern for complex operations, compile-time checks possible. | Higher upfront design cost, more boilerplate code, tightly coupled to a specific parser's output structure. | No |\n| **Lightweight Dict/List** | Rapid prototyping, easy serialization/debugging, parser-agnostic, less code to maintain. | No type checking, reliance on string keys, potential for runtime errors due to malformed structure. | **Yes** |\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Infinite Loop in Variable Resolution**\n*   **Description:** A variable's value is defined by referencing another variable, which in turn references the first, either directly (`var.a -> var.b -> var.a`) or through a longer chain. During the `resolve_variables` traversal, the parser gets stuck in an endless loop.\n*   **Why it's Wrong:** The algorithm will never terminate, consuming CPU and hanging the IaC engine. This violates the requirement for predictable execution.\n*   **How to Fix:** Implement a **dependency graph for variables** before resolution. Before replacing values, analyze all variable expressions to build a graph of `var.a` depends on `var.b`. Run a cycle detection algorithm (like Depth-First Search with coloring). If a cycle is found, abort with a clear error message pointing to the involved variables.\n\n⚠️ **Pitfall: The `count`/`for_each` Interpolation Chicken-Egg Problem**\n*   **Description:** The `count` meta-argument determines how many instances of a resource are created. If `count` itself uses a variable interpolation (e.g., `count = var.num_servers`), but that variable's value is derived from the output attribute of another resource (e.g., `num_servers = length(aws_autoscaling_group.web.instances)`), you have a paradoxical dependency. You need the resource's output to know how many of it to create.\n*   **Why it's Wrong:** This creates a circular dependency that cannot be resolved at parse time. The parser cannot resolve `var.num_servers` because its value is unknown until *after* some infrastructure is provisioned.\n*   **How to Fix:** Recognize that `count` and `for_each` are **runtime evaluations**. The parser should leave interpolations within these meta-arguments unresolved during the initial parsing phase. They become **dynamic references** that are evaluated by the Planner *after* the dependency graph is built, using values from the state file or from outputs of already-applied resources during the `apply` phase.\n\n⚠️ **Pitfall: Module Source Path Ambiguity**\n*   **Description:** A module's `source` attribute is specified as a relative path like `../modules/vpc`. If the parser does not properly resolve this path relative to the calling configuration's directory, it may load the wrong files or fail to find them.\n*   **Why it's Wrong:** Leads to `FileNotFoundError` or, worse, silently loading an unrelated configuration, resulting in a plan that doesn't match the user's intent.\n*   **How to Fix:** Always resolve module source paths to absolute paths as early as possible. Use the parent configuration file's directory (`parent_dir`) as the base. The rule is: `abs_source = (parent_dir / source).resolve()`. Document this resolution strategy clearly.\n\n### Implementation Guidance\n\n**A. Technology Recommendations**\n\n| Component | Simple Option (Recommended for Learning) | Advanced Option (For Production) |\n| :--- | :--- | :--- |\n| **HCL Parser** | `pyhcl2` (a Python port of HCL 2) - Pure Python, easier to install and debug. | `python-hcl2` - Another popular parser. For maximum fidelity, use the official **HashiCorp Go libraries** via a subprocess or CFFI, but this adds complexity. |\n| **YAML Parser** | Python's built-in `yaml` module (`PyYAML` if not installed). | Use a schema validator like `yamale` alongside parsing to enforce structure. |\n| **Data Structure** | Nested `dict` and `list` objects. | Use `dataclasses` or `pydantic` models for the final `Resource` list, while keeping the intermediate AST as dicts. |\n\n**B. Recommended File/Module Structure**\nPlace the parser logic in a dedicated module. Separate concerns for file I/O, syntax parsing, and resolution logic.\n\n```\niac-engine/\n├── iac_engine/\n│   ├── __init__.py\n│   ├── cli.py                      # CLI commands (plan_command, apply_command)\n│   ├── parser/                     # Configuration Parser Component\n│   │   ├── __init__.py\n│   │   ├── core.py                 # Parser class with main interface methods\n│   │   ├── resolvers.py            # Variable and module resolution logic\n│   │   ├── file_loader.py          # Safe file loading utilities (starter code below)\n│   │   └── exceptions.py           # Parser-specific exceptions (e.g., ParseError, CyclicVariableError)\n│   ├── models.py                   # Shared data models (Resource, StateRecord, etc.)\n│   └── ... (other components)\n├── configs/                        # Example configurations for testing\n│   ├── main.tf\n│   └── variables.tfvars\n├── pyproject.toml\n└── README.md\n```\n\n**C. Infrastructure Starter Code**\n\nThe following is a complete, reusable utility for safely reading configuration files with basic error handling. It should be placed in `parser/file_loader.py`.\n\n```python\n\"\"\"\nSafe file loading utilities for the configuration parser.\n\"\"\"\nimport json\nfrom pathlib import Path\nfrom typing import Any, Union\nimport yaml\nimport hcl2  # Requires: pip install pyhcl2\n\nclass FileLoaderError(Exception):\n    \"\"\"Base exception for file loading failures.\"\"\"\n    pass\n\ndef safe_read_file(filepath: Path) -> str:\n    \"\"\"\n    Read a text file safely with explicit error handling.\n\n    Args:\n        filepath: Path to the file.\n\n    Returns:\n        The file content as a string.\n\n    Raises:\n        FileLoaderError: If the file cannot be read (does not exist, permission denied, etc.).\n    \"\"\"\n    try:\n        return filepath.read_text(encoding='utf-8')\n    except (FileNotFoundError, PermissionError, IsADirectoryError, UnicodeDecodeError) as e:\n        raise FileLoaderError(f\"Failed to read file '{filepath}': {e}\") from e\n\ndef load_config_file(filepath: Path) -> dict:\n    \"\"\"\n    Load and parse a configuration file based on its extension.\n    Supports .tf (HCL), .tf.json (JSON), .yaml, .yml.\n\n    Args:\n        filepath: Path to the configuration file.\n\n    Returns:\n        A dictionary representing the parsed configuration (raw AST).\n\n    Raises:\n        FileLoaderError: If the file cannot be parsed or has an unsupported extension.\n    \"\"\"\n    content = safe_read_file(filepath)\n    suffix = filepath.suffix.lower()\n\n    try:\n        if suffix == '.tf':\n            # Parse HCL using pyhcl2\n            return hcl2.loads(content)\n        elif suffix == '.json' or filepath.name.endswith('.tf.json'):\n            return json.loads(content)\n        elif suffix in ('.yaml', '.yml'):\n            # Using SafeLoader by default to avoid arbitrary code execution\n            return yaml.safe_load(content)\n        else:\n            raise FileLoaderError(f\"Unsupported configuration file extension: {suffix}\")\n    except (hcl2.HCL2Error, json.JSONDecodeError, yaml.YAMLError) as e:\n        raise FileLoaderError(f\"Failed to parse '{filepath}': {e}\") from e\n```\n\n**D. Core Logic Skeleton Code**\n\nThe main parsing logic resides in `parser/core.py`. Below is the skeleton for the primary `Parser` class with detailed TODO comments that map directly to the algorithm steps described earlier.\n\n```python\n\"\"\"\nCore configuration parser implementing the parsing pipeline.\n\"\"\"\nfrom pathlib import Path\nfrom typing import Dict, List, Any, Optional\nfrom ..models import Resource\nfrom . import resolvers\nfrom .file_loader import load_config_file, FileLoaderError\n\nclass Parser:\n    \"\"\"Orchestrates the parsing of IaC configuration files.\"\"\"\n\n    def parse_file(self, file_path: Path) -> dict:\n        \"\"\"\n        Parse a single configuration file into a raw AST (dict).\n\n        Args:\n            file_path: Path to the .tf, .yaml, or .json file.\n\n        Returns:\n            A dictionary representing the raw, unprocessed AST.\n        \"\"\"\n        # TODO 1: Use the `load_config_file` utility to load and parse the file.\n        # TODO 2: Return the parsed dictionary.\n        pass\n\n    def resolve_variables(self, ast: dict, variable_files: List[Path], cli_vars: Dict[str, Any]) -> dict:\n        \"\"\"\n        Resolve variable interpolations within an AST.\n\n        Args:\n            ast: The raw AST dictionary.\n            variable_files: List of paths to variable definition files (.tfvars, .json, .yaml).\n            cli_vars: Dictionary of variable values provided via command line.\n\n        Returns:\n            A new AST dictionary with variable references replaced by concrete values.\n        \"\"\"\n        # TODO 1: Extract default variable declarations from the 'variable' blocks in the AST.\n        # TODO 2: Load variable values from each file in `variable_files` (using load_config_file).\n        # TODO 3: Merge values: defaults < file values < cli_vars (highest priority).\n        # TODO 4: Perform a depth-first traversal of the AST.\n        # TODO 5: For each string value found, check for the pattern ${var.<name>}.\n        # TODO 6: Look up the variable name in the merged values dictionary.\n        # TODO 7: Replace the entire interpolation expression with the concrete value.\n        # TODO 8: (Advanced) Detect circular dependencies between variables and raise an error.\n        # Hint: Use a recursive function or a stack for traversal.\n        pass\n\n    def load_module(self, module_call: dict, parent_dir: Path) -> List[Resource]:\n        \"\"\"\n        Load and fully resolve a module, returning its resources.\n\n        Args:\n            module_call: The AST of the 'module' block (contains 'source', 'inputs', etc.).\n            parent_dir: The directory of the configuration file containing this module call.\n\n        Returns:\n            A list of Resource objects defined within the module, with names prefixed.\n        \"\"\"\n        # TODO 1: Extract the 'source' attribute from module_call. Raise error if missing.\n        # TODO 2: Resolve the source path to an absolute directory relative to parent_dir.\n        # TODO 3: Find the main configuration file within the module directory (e.g., main.tf).\n        # TODO 4: Call `self.process_configuration` on that main file, passing the 'inputs' as cli_vars.\n        # TODO 5: For each Resource returned, prepend the module's logical name to its `id` and `name`.\n        #   Example: module name = \"vpc\", resource id = \"aws_vpc.main\" -> \"module.vpc.aws_vpc.main\"\n        # TODO 6: Return the list of prefixed resources.\n        pass\n\n    def process_configuration(self, root_file: Path,\n                              variable_files: Optional[List[Path]] = None,\n                              cli_vars: Optional[Dict[str, Any]] = None) -> List[Resource]:\n        \"\"\"\n        Main entry point: parse a root configuration and all its modules.\n\n        Args:\n            root_file: Path to the root configuration file.\n            variable_files: Optional list of variable definition files.\n            cli_vars: Optional dictionary of command-line variable overrides.\n\n        Returns:\n            A flat list of all Resource objects from the root and nested modules.\n        \"\"\"\n        # TODO 1: Initialize variable_files and cli_vars to empty lists/dicts if None.\n        # TODO 2: Parse the root file using `self.parse_file`.\n        # TODO 3: Resolve variables in the root AST using `self.resolve_variables`.\n        # TODO 4: Initialize an empty list `all_resources`.\n        # TODO 5: Traverse the resolved AST to find 'resource' blocks at the root level.\n        # TODO 6: For each root resource block, convert it to a Resource and add to all_resources.\n        # TODO 7: Traverse the resolved AST to find 'module' blocks.\n        # TODO 8: For each module block, call `self.load_module` and extend all_resources with the result.\n        # TODO 9: Return the complete list of resources.\n        pass\n```\n\n**E. Language-Specific Hints**\n\n*   **Recursive Traversal:** When implementing `resolve_variables`, a recursive helper function that handles dictionaries, lists, and strings is simpler than managing an explicit stack for this use case.\n*   **Path Handling:** Always use `pathlib.Path` objects instead of string concatenation for file paths. Use `/` operator to join paths (e.g., `parent_dir / \"modules/vpc\"`).\n*   **Module Discovery:** A simple heuristic for finding a module's main file is to look for `main.tf`, then `variables.tf`, then any `.tf` file in the module directory.\n*   **Error Messages:** When raising exceptions, include the file name, line number (if available from the parser), and the specific problematic construct (e.g., \"Undefined variable 'region' in main.tf\").\n\n**F. Milestone Checkpoint**\n\nAfter implementing the `Parser` class, you should be able to run the following verification steps:\n\n1.  **Unit Test:** Create a simple test configuration.\n    ```python\n    # test_parser.py (simplified example)\n    from iac_engine.parser.core import Parser\n    from pathlib import Path\n\n    parser = Parser()\n    resources = parser.process_configuration(\n        root_file=Path(\"configs/main.tf\"),\n        variable_files=[Path(\"configs/terraform.tfvars\")],\n        cli_vars={\"instance_count\": 2}\n    )\n    print(f\"Parsed {len(resources)} resources\")\n    for r in resources:\n        print(f\"  - {r.id}: {r.attributes}\")\n    ```\n\n2.  **Expected Behavior:** Given a valid configuration, the script should print a list of `Resource` objects with fully resolved attribute values (no `${var...}` placeholders). Module resources should have IDs prefixed with `module.<name>.`.\n\n3.  **Signs of Trouble:**\n    *   **`FileLoaderError`:** Check file paths and ensure the parser's working directory is correct.\n    *   **Variable not resolved:** Verify the variable merging logic and the traversal/replacement in `resolve_variables`.\n    *   **Module resources missing:** Ensure `load_module` is being called and that it correctly recurses into subdirectories.\n\n\n## Component Design: State Manager\n> **Milestone(s):** 2\n\nThe **State Manager** is the system of record for the IaC engine, maintaining a persistent, authoritative snapshot of what infrastructure currently exists according to the system's knowledge. It bridges the declarative world of configuration files and the imperative reality of cloud resources by storing the last known state after each successful operation. Beyond simple persistence, it ensures safe concurrent access through locking mechanisms and provides the critical diffing logic that determines what changes are needed.\n\n### Mental Model: The Ledger and Lock\n\nThink of the State Manager as a combination of a **bank ledger** and a **safety deposit box lock**. The ledger (the state file) is a meticulously kept record of every resource the system has deployed: its unique cloud identifier, its current attributes, and how resources are connected. This ledger allows the system to answer the fundamental question: \"What do I already have?\"\n\nThe safety deposit box lock (the state lock) protects this ledger during updates. Imagine multiple people (or automated processes) trying to update the same bank ledger simultaneously—chaos would ensue. The lock ensures only one \"teller\" can modify the ledger at a time, preventing conflicting updates that could corrupt the record or cause duplicate resource creation. When a teller starts an update, they take the key (acquire the lock), make their changes, and then return the key (release the lock) for the next person.\n\nThis dual role—persistent record-keeping and concurrent access control—makes the State Manager a critical linchpin for safety and correctness in any multi-user or automated IaC environment.\n\n### Interface and Public Methods\n\nThe State Manager exposes a clean interface centered around four core operations: reading/writing state, acquiring/releasing locks, and computing the difference between states. The following table details the public contract.\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `read_state` | `state_path: Path` | `Dict[str, StateRecord]` | Loads the state file from the given path, parsing its JSON content into an in-memory dictionary keyed by resource address (e.g., `\"aws_instance.web\"`). Handles missing files (returns empty dict) and corrupted content (attempts recovery from backup). |\n| `write_state` | `state_path: Path`, `state_data: Dict[str, StateRecord]` | `None` | Persists the in-memory state dictionary to disk at the specified path. Performs an **atomic write** to prevent corruption: writes to a temporary file, syncs to disk, then renames to the target path. Optionally creates a backup of the previous state file. |\n| `acquire_lock` | `lock_path: Path`, `timeout_seconds: int = 30`, `heartbeat_interval: int = 10` | `LockHandle` | Attempts to acquire an exclusive lock for the state. Creates a lock file containing process metadata (PID, hostname, timestamp). If the lock already exists, checks if it's stale (older than timeout). Returns a handle object that must be used to release the lock. Starts a background heartbeat thread to periodically update the lock timestamp, preventing it from becoming stale during long operations. |\n| `release_lock` | `lock_handle: LockHandle` | `None` | Releases the lock represented by the given handle. Stops the heartbeat thread and deletes the lock file. Must be called even if errors occur during apply to prevent deadlocks. |\n| `compute_diff` | `current_state: Dict[str, StateRecord]`, `desired_resources: List[Resource]` | `Dict[str, PlanAction]` | The core diffing engine. Compares the current deployed state (from `read_state`) with the desired state (from the Parser). For each desired resource, determines if it needs to be created, updated, deleted, or left alone (`NOOP`). Returns a dictionary of actions keyed by resource address. |\n| `get_resource_address` | `resource: Resource` | `str` | Helper method that generates a unique address string for a resource, following the convention `\"{resource_type}.{resource_name}\"`. This address is used as the key in the state dictionary and for dependency tracking. |\n\n**Supporting Data Types:**\n| Type Name | Fields | Description |\n|-----------|--------|-------------|\n| `StateRecord` | `resource_id: str`, `resource_type: str`, `resource_name: str`, `attributes: Dict[str, Any]`, `dependencies: List[str]` | A snapshot of a resource as it exists in the cloud. The `resource_id` is the unique identifier assigned by the cloud provider (e.g., AWS instance ID `i-12345`). `attributes` are the *actual* values read from the cloud API at the last refresh. `dependencies` is a list of resource addresses this resource depends on, used for graph construction. |\n| `LockHandle` | `lock_path: Path`, `process_id: int`, `lock_id: str` (UUID), `heartbeat_thread: Optional[Thread]`, `stop_event: Event` | An opaque object representing an acquired lock. It holds references to the lock file path, the current process's ID, a unique lock identifier for verification, and the background heartbeat thread with its stop signal. The caller should not modify this object. |\n| `PlanAction` | `action_type: ActionType`, `resource: Resource`, `prior_state: Optional[StateRecord]`, `new_state: Optional[StateRecord]` | The output of `compute_diff`. Describes a change to be made. For `CREATE`, `prior_state` is `None`. For `DELETE`, `new_state` is `None`. For `UPDATE`, both are populated with the old and new states. |\n\n### Internal Behavior and Algorithm\n\nThe State Manager's internal logic can be decomposed into three primary algorithms: atomic state persistence, lock management with heartbeats, and state diff calculation.\n\n#### 1. Atomic State Persistence with `write_atomic_json`\nTo guarantee the state file is never left in a partially written, corrupted state, the write operation follows an **atomic rename pattern**. This is implemented in the helper function `write_atomic_json`, which the `write_state` method calls.\n\n1.  **Serialize to JSON**: Convert the state dictionary (containing `StateRecord` objects) into a JSON string. Use a consistent indentation for readability.\n2.  **Create Temporary File**: Generate a temporary file path in the same directory as the target state file, using a prefix (e.g., `.terraform_state.tmp-`) and a random suffix to avoid collisions.\n3.  **Write and Sync**: Open the temporary file in write mode (`'w'`). Write the JSON string. Call `os.fsync()` on the file descriptor to ensure the data is flushed to physical disk, not just the OS cache.\n4.  **Create Backup (Optional)**: If the target state file already exists, rename it to a backup file (e.g., `.terraform_state.backup`) before the next step. This provides a recovery point.\n5.  **Atomic Rename**: Perform an atomic filesystem rename operation (`os.rename`) to move the temporary file to the final state file path. On POSIX systems, rename is atomic even in the face of crashes: the target path will point either to the old file or the new file, never a mixture.\n6.  **Cleanup**: If the backup file exists and the rename succeeded, the old backup (if any) can be removed. If any step fails, the temporary file is cleaned up, leaving the original state file intact.\n\n#### 2. Lock Acquisition with Heartbeat\nThe locking mechanism prevents concurrent modifications. It uses a simple file-based lock with a heartbeat to handle long-running operations and process crashes.\n\n1.  **Check for Existing Lock**: When `acquire_lock` is called, it first checks if a lock file exists at `lock_path`.\n2.  **Stale Lock Detection**: If a lock file exists, read its JSON content (containing `process_id`, `hostname`, `timestamp`, and `lock_id`). Calculate the age of the lock (current time minus `timestamp`). If the age exceeds the `timeout_seconds` parameter, the lock is considered **stale** (likely from a crashed process). Log a warning and proceed to steal the lock. Otherwise, wait and retry (with a backoff) until the lock is released or becomes stale.\n3.  **Create New Lock**: If no lock exists or the existing lock is stale, create a new lock file. Write a JSON object with the current process's PID, the machine's hostname, the current timestamp, and a newly generated UUID (`lock_id`). Perform an atomic write (similar to state writes) to ensure the lock file is created completely.\n4.  **Start Heartbeat Thread**: Create a background daemon thread that will periodically (every `heartbeat_interval` seconds) update the lock file's timestamp to the current time. This \"refreshes\" the lock, preventing it from appearing stale during a long `apply` operation. The thread runs until a stop event is set.\n5.  **Return Handle**: Package the lock file path, PID, `lock_id`, and references to the heartbeat thread and stop event into a `LockHandle` object and return it.\n\n#### 3. Computing the State Diff\nThe `compute_diff` algorithm is the brain of the planning phase. It determines the set of actions required to converge the current state to the desired state.\n\n1.  **Index Current State**: Build a dictionary mapping resource addresses (`type.name`) to their `StateRecord` objects from the `current_state` input.\n2.  **Index Desired Resources**: Build a similar dictionary for the `desired_resources` list, using the `get_resource_address` helper.\n3.  **Initialize Action Dictionary**: Create an empty dictionary to hold `PlanAction` objects, keyed by resource address.\n4.  **Iterate Over Desired Resources**: For each resource in the desired resources dictionary:\n    *   **Address Lookup**: Look up the resource's address in the current state index.\n    *   **No Current State (`CREATE`)**: If not found, the resource does not exist. Create a `PlanAction` with `action_type=ActionType.CREATE`, the `resource` set to the desired resource, `prior_state=None`, and `new_state` set to a `StateRecord` populated from the desired resource (but with `resource_id` initially empty).\n    *   **Current State Exists**: If found, compare the desired resource's attributes with the current state's attributes. Perform a **deep, semantic comparison**. For complex nested structures (like security group rules), order may not matter. If any attribute differs (considering provider-specific semantics), mark the resource for `UPDATE`. Create a `PlanAction` with the changed resource and both states. If no attributes differ, mark as `NOOP`.\n5.  **Identify Resources to Delete**: Find all resources in the current state index that are *not* present in the desired resources index. For each, create a `PlanAction` with `action_type=ActionType.DELETE`, `resource` constructed from the `StateRecord` (type and name), `prior_state` set to the record, and `new_state=None`.\n6.  **Return Actions**: Return the populated action dictionary.\n\n> **Key Design Insight:** The diff algorithm must be **idempotent**. Running `plan` twice on the same configuration and state should produce an identical plan (ideally empty after an apply). This requires the comparison logic to ignore transient or read-only fields (like `arn` in AWS, which is derived from the ID) and to handle default values that the provider may inject.\n\n### ADR: Pessimistic File Locking vs. Optimistic Concurrency\n\n> **Decision: Use Pessimistic File Locking for State Modification**\n> - **Context**: The state file is a shared resource that must be modified by concurrent `apply` commands (from multiple users or CI/CD jobs). Without coordination, simultaneous writes could corrupt the file or cause race conditions where one process overwrites another's changes, leading to resource duplication or orphaned resources.\n> - **Options Considered**:\n>     1.  **Pessimistic File Locking (Chosen)**: Acquire an exclusive lock (via a lock file) before reading the state, hold it throughout the `plan` and `apply` workflow, and release only after the new state is written. This ensures serializability.\n>     2.  **Optimistic Concurrency Control (OCC)**: Read the state without a lock, perform the plan and apply, then attempt to write the new state only if the state file's content hasn't changed since the initial read (using a version stamp or checksum). If it has changed, abort and retry from the beginning.\n>     3.  **Distributed Lock Service**: Use an external service like Redis, etcd, or a database to manage distributed locks, which is more robust in highly concurrent, multi-host environments.\n> - **Decision**: Implement a simple **pessimistic file lock** using a lock file with a heartbeat mechanism and stale lock detection.\n> - **Rationale**:\n>     *   **Simplicity and Educational Value**: File locks are easier to understand and implement correctly for a learning project. The concepts of atomic file operations, lock files, and heartbeats are fundamental.\n>     *   **Deterministic Behavior**: Pessimistic locking provides a clear, linear workflow: acquire lock → plan → apply → write → release. There's no need for complex retry loops or merge conflict resolution logic.\n>     *   **Adequate for Common Use Case**: For many small to medium teams, serializing `apply` operations is acceptable and even desirable to prevent unexpected interactions.\n> - **Consequences**:\n>     *   **Positive**: Implementation is relatively straightforward. Provides strong consistency guarantees. Lock file and heartbeat logic are reusable patterns.\n>     *   **Negative**: Can cause bottlenecks if many `apply` operations are queued. Requires careful handling of process crashes to avoid stale locks (addressed via timeout+heartbeat). Not suitable for distributed workflows across multiple machines without a shared filesystem.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Pessimistic File Locking | Simple to implement; strong consistency; clear workflow; good for learning | Can bottleneck throughput; requires shared filesystem for team; stale lock handling needed | **Yes** |\n| Optimistic Concurrency Control | Allows parallel planning; no waiting for locks; better for high concurrency | Complex retry/merge logic; \"plan\" may be invalidated, wasting work; harder to debug | No |\n| Distributed Lock Service | Robust for distributed teams; no shared filesystem requirement; advanced features (leases) | Introduces external dependency; operational overhead; more complex to implement | No |\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Partial Write Corrupts State File**\n*   **Description**: If the system crashes or is killed while writing the state file (e.g., during a power loss), the file may be left with partially written JSON, making it unreadable.\n*   **Why It's Wrong**: A corrupted state file breaks the entire system. The engine can no longer determine what resources it manages, leading to potential resource orphanage or attempted duplicate creation.\n*   **How to Fix**: Always use the **atomic rename pattern** (`write_atomic_json`). Write the complete new state to a temporary file, `fsync` it, then rename it over the old state file. The rename is an atomic operation at the filesystem level. Additionally, keep a backup of the previous state file to allow manual recovery.\n\n⚠️ **Pitfall: Stale Lock Blocks All Operations**\n*   **Description**: A process acquires a lock and then crashes (or is killed) before releasing it. The lock file remains on disk, preventing any other process from acquiring the lock, effectively halting all deployments.\n*   **Why It's Wrong**: This creates a single point of failure. Manual intervention (deleting the lock file) is required to resume operations, which is error-prone and may lead to concurrent applies if done incorrectly.\n*   **How to Fix**: Implement **stale lock detection**. Store a timestamp in the lock file and have processes check the lock's age. If a lock is older than a configurable timeout (e.g., 30 minutes), a new process can assume the owner is dead, log a warning, and \"break\" the stale lock. Complement this with a **heartbeat** for long-running operations, where the lock owner periodically updates the timestamp to signal it's still alive.\n\n⚠️ **Pitfall: Remote State Race Condition (Read-Modify-Write)**\n*   **Description**: When using a remote backend (like S3), two processes might concurrently read the same state file (version 1). Both compute plans based on version 1. The first process applies changes and writes back state version 2. The second process, unaware of the update, applies its (now possibly invalid) changes and overwrites with a state derived from version 1, obliterating the first process's changes.\n*   **Why It's Wrong**: This is a classic lost update problem. It can cause resource conflicts, configuration rollback, or hidden dependencies being broken.\n*   **How to Fix**: For remote backends, you **must** implement optimistic concurrency control or use the remote system's locking capabilities. Use a version identifier (ETag in S3, conditional writes) in the state metadata. On write, include a condition that the remote object's version must match what was read. If the condition fails, abort and require the user to retry with the updated state. *Note: Our initial implementation uses local files, but this pitfall is critical for the \"Remote State Backend\" deliverable.*\n\n### Implementation Guidance\n\n**A. Technology Recommendations**\n| Component | Simple Option (Recommended) | Advanced Option (Future) |\n|-----------|-----------------------------|--------------------------|\n| State Serialization | JSON via Python's `json` module (human-readable, debuggable) | Protocol Buffers or CBOR (smaller, faster, binary) |\n| Atomic File Writes | `tempfile.NamedTemporaryFile` + `os.replace` (Python 3.3+) | Platform-specific syscalls (`fsync`, `rename`) |\n| Locking | File-based lock with `fcntl` (Unix) / `msvcrt.locking` (Windows) | Distributed lock via Redis/etcd API |\n| Remote Backend | AWS S3 with Boto3, using versioned buckets | Custom HTTP backend with auth, caching |\n\n**B. Recommended File/Module Structure**\n```\niac_engine/\n├── iac_engine/\n│   ├── __init__.py\n│   ├── cli.py                      # plan_command, apply_command\n│   ├── parser/                     # Milestone 1\n│   ├── state/                      # State Manager (this component)\n│   │   ├── __init__.py\n│   │   ├── manager.py              # StateManager class (main logic)\n│   │   ├── locking.py              # LockHandle, file locking utilities\n│   │   ├── backends/               # For remote state (local, s3, http)\n│   │   │   ├── __init__.py\n│   │   │   ├── local.py\n│   │   │   └── s3.py\n│   │   └── serialization.py        # StateRecord helper methods (to/from dict)\n│   ├── planner/                    # Milestone 3\n│   ├── executor/                   # Milestone 4\n│   └── providers/                  # Milestone 4\n└── tests/\n    └── state/\n        ├── test_manager.py\n        └── test_locking.py\n```\n\n**C. Infrastructure Starter Code**\n\nBelow is complete, reusable code for atomic file operations and a simple lockfile implementation. Learners should place these in `state/serialization.py` and `state/locking.py` respectively.\n\n```python\n# iac_engine/state/serialization.py\n\"\"\"Utilities for atomic file operations and JSON serialization.\"\"\"\nimport json\nimport os\nimport tempfile\nfrom pathlib import Path\nfrom typing import Any\n\ndef write_atomic_json(filepath: Path, data: Any) -> None:\n    \"\"\"\n    Write JSON data to a file atomically to prevent corruption.\n    \n    Args:\n        filepath: The target file path.\n        data: Any JSON-serializable Python object.\n    \n    Raises:\n        OSError: If file operations fail.\n        TypeError: If data is not JSON serializable.\n    \"\"\"\n    # Create a temporary file in the same directory for atomic rename\n    temp_fd, temp_path = tempfile.mkstemp(\n        prefix=f\"{filepath.name}.tmp.\",\n        suffix=\".json\",\n        dir=filepath.parent,\n        text=True\n    )\n    try:\n        with os.fdopen(temp_fd, 'w') as f:\n            json.dump(data, f, indent=2, default=str)\n            f.flush()\n            os.fsync(f.fileno())  # Force write to disk\n        # Atomic rename (replace if exists, works cross-platform)\n        os.replace(temp_path, filepath)\n    except Exception:\n        # Clean up temp file on any error\n        try:\n            os.unlink(temp_path)\n        except OSError:\n            pass\n        raise\n\ndef read_json_with_backup(filepath: Path) -> Any:\n    \"\"\"\n    Read JSON file, with automatic fallback to a backup if present.\n    \n    Args:\n        filepath: The primary state file path.\n    \n    Returns:\n        The parsed JSON data (typically a dict). Returns an empty dict\n        if neither the primary nor backup file exists.\n    \n    Raises:\n        json.JSONDecodeError: If both primary and backup files contain\n            invalid JSON (after attempting to read backup).\n    \"\"\"\n    backup_path = filepath.parent / f\"{filepath.name}.backup\"\n    \n    for path in [filepath, backup_path]:\n        if path.exists():\n            try:\n                with open(path, 'r') as f:\n                    return json.load(f)\n            except json.JSONDecodeError:\n                # Log warning but try backup if available\n                print(f\"Warning: Corrupted JSON in {path}, trying backup...\")\n                continue\n    # Neither file exists or both are corrupt\n    return {}\n```\n\n```python\n# iac_engine/state/locking.py\n\"\"\"File-based locking with stale lock detection and heartbeat.\"\"\"\nimport json\nimport os\nimport threading\nimport time\nimport uuid\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Optional\n\nclass LockHandle:\n    \"\"\"Represents an acquired lock.\"\"\"\n    def __init__(self, lock_path: Path, lock_id: str):\n        self.lock_path = lock_path\n        self.lock_id = lock_id  # UUID to verify we own the lock\n        self.heartbeat_thread: Optional[threading.Thread] = None\n        self.stop_event = threading.Event()\n\nclass FileLock:\n    \"\"\"Manages acquisition and release of a file-based lock.\"\"\"\n    def __init__(self, lock_path: Path, timeout_seconds: int = 300):\n        self.lock_path = lock_path\n        self.timeout_seconds = timeout_seconds\n        \n    def acquire(self, heartbeat_interval: int = 30) -> LockHandle:\n        \"\"\"\n        Acquire an exclusive lock, with stale lock detection.\n        \n        Args:\n            heartbeat_interval: How often (seconds) to refresh the lock timestamp.\n        \n        Returns:\n            A LockHandle that must be used to release the lock.\n        \n        Raises:\n            TimeoutError: If unable to acquire lock within timeout.\n        \"\"\"\n        start_time = time.time()\n        lock_id = str(uuid.uuid4())\n        \n        while time.time() - start_time < self.timeout_seconds:\n            if not self.lock_path.exists():\n                # No lock file, try to create it\n                if self._create_lock_file(lock_id):\n                    handle = LockHandle(self.lock_path, lock_id)\n                    self._start_heartbeat(handle, heartbeat_interval)\n                    return handle\n                    \n            # Lock exists, check if stale\n            lock_data = self._read_lock_file()\n            if lock_data:\n                lock_age = time.time() - lock_data['timestamp']\n                if lock_age > self.timeout_seconds:\n                    print(f\"Warning: Breaking stale lock from {lock_data.get('hostname')}\")\n                    # Stale lock, break it and try to acquire\n                    self.lock_path.unlink(missing_ok=True)\n                    continue\n            \n            # Lock is held by another active process, wait and retry\n            time.sleep(1)\n        \n        raise TimeoutError(f\"Could not acquire lock {self.lock_path} within timeout\")\n    \n    def _create_lock_file(self, lock_id: str) -> bool:\n        \"\"\"Atomically create lock file with current process info.\"\"\"\n        try:\n            lock_data = {\n                'pid': os.getpid(),\n                'hostname': os.uname().nodename if hasattr(os, 'uname') else 'unknown',\n                'timestamp': time.time(),\n                'lock_id': lock_id\n            }\n            # Use atomic write from serialization module\n            from .serialization import write_atomic_json\n            write_atomic_json(self.lock_path, lock_data)\n            return True\n        except (OSError, IOError):\n            return False\n    \n    def _read_lock_file(self) -> Optional[dict]:\n        \"\"\"Read and parse lock file, return None if invalid/missing.\"\"\"\n        try:\n            with open(self.lock_path, 'r') as f:\n                return json.load(f)\n        except (FileNotFoundError, json.JSONDecodeError):\n            return None\n    \n    def _start_heartbeat(self, handle: LockHandle, interval: int):\n        \"\"\"Start background thread to periodically refresh lock timestamp.\"\"\"\n        def heartbeat():\n            while not handle.stop_event.wait(interval):\n                if not self.lock_path.exists():\n                    break\n                lock_data = self._read_lock_file()\n                if lock_data and lock_data.get('lock_id') == handle.lock_id:\n                    lock_data['timestamp'] = time.time()\n                    try:\n                        from .serialization import write_atomic_json\n                        write_atomic_json(self.lock_path, lock_data)\n                    except (OSError, IOError):\n                        break  # Couldn't refresh, lock may be broken\n        \n        handle.heartbeat_thread = threading.Thread(\n            target=heartbeat,\n            daemon=True,\n            name=f\"lock-heartbeat-{handle.lock_id[:8]}\"\n        )\n        handle.heartbeat_thread.start()\n    \n    def release(self, handle: LockHandle):\n        \"\"\"Release the lock represented by the handle.\"\"\"\n        if handle.heartbeat_thread:\n            handle.stop_event.set()\n            handle.heartbeat_thread.join(timeout=5)\n        \n        # Verify we still own the lock before deleting\n        lock_data = self._read_lock_file()\n        if lock_data and lock_data.get('lock_id') == handle.lock_id:\n            self.lock_path.unlink(missing_ok=True)\n```\n\n**D. Core Logic Skeleton Code**\n\nThe main `StateManager` class integrates the above utilities. Learners should implement the `compute_diff` method following the algorithm outlined earlier.\n\n```python\n# iac_engine/state/manager.py\n\"\"\"Main State Manager component.\"\"\"\nimport json\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\nfrom dataclasses import asdict\n\nfrom ..models import Resource, StateRecord, PlanAction, ActionType\nfrom .locking import FileLock, LockHandle\nfrom .serialization import write_atomic_json, read_json_with_backup\n\nclass StateManager:\n    \"\"\"Manages persistent infrastructure state and concurrent access.\"\"\"\n    \n    def __init__(self, state_path: Path):\n        \"\"\"\n        Args:\n            state_path: Path to the main state file (e.g., terraform.tfstate).\n        \"\"\"\n        self.state_path = state_path\n        self.lock_path = state_path.parent / f\"{state_path.name}.lock\"\n        self.file_lock = FileLock(self.lock_path)\n    \n    def read_state(self) -> Dict[str, StateRecord]:\n        \"\"\"\n        Loads the state file into memory.\n        \n        Returns:\n            Dictionary mapping resource addresses to StateRecord objects.\n            Returns empty dict if state file doesn't exist or is corrupt.\n        \"\"\"\n        # TODO 1: Use read_json_with_backup to load raw JSON from self.state_path\n        # TODO 2: If result is empty dict, return empty dict\n        # TODO 3: Convert the raw JSON dict into a dict of StateRecord objects\n        #         The JSON keys are resource addresses (e.g., \"aws_instance.web\")\n        #         Each value should be converted using StateRecord.from_dict()\n        # TODO 4: Return the dictionary of StateRecord objects\n        pass\n    \n    def write_state(self, state_data: Dict[str, StateRecord]):\n        \"\"\"\n        Persists the state dictionary to disk atomically.\n        \n        Args:\n            state_data: Dictionary mapping resource addresses to StateRecord objects.\n        \"\"\"\n        # TODO 1: Convert the state_data dictionary to a JSON-serializable dict\n        #         Use StateRecord.to_dict() for each record\n        # TODO 2: Call write_atomic_json with self.state_path and the serialized data\n        # TODO 3: (Optional) Create a backup of the previous state file before writing\n        pass\n    \n    def acquire_lock(self, timeout_seconds: int = 300) -> LockHandle:\n        \"\"\"\n        Acquire an exclusive lock for the state.\n        \n        Args:\n            timeout_seconds: Maximum time to wait for lock acquisition.\n        \n        Returns:\n            A LockHandle that MUST be passed to release_lock.\n        \"\"\"\n        # TODO 1: Call self.file_lock.acquire() with appropriate heartbeat interval\n        # TODO 2: Return the LockHandle\n        pass\n    \n    def release_lock(self, lock_handle: LockHandle):\n        \"\"\"\n        Release a previously acquired lock.\n        \n        Args:\n            lock_handle: The handle returned by acquire_lock.\n        \"\"\"\n        # TODO 1: Call self.file_lock.release(lock_handle)\n        pass\n    \n    def compute_diff(\n        self,\n        current_state: Dict[str, StateRecord],\n        desired_resources: List[Resource]\n    ) -> Dict[str, PlanAction]:\n        \"\"\"\n        Compare current state with desired resources to determine needed changes.\n        \n        Args:\n            current_state: Output from read_state().\n            desired_resources: List of Resource objects from the parser.\n        \n        Returns:\n            Dictionary of PlanAction objects keyed by resource address.\n        \"\"\"\n        actions = {}\n        \n        # Build index of desired resources by address\n        desired_index = {}\n        for resource in desired_resources:\n            address = self.get_resource_address(resource)\n            desired_index[address] = resource\n        \n        # TODO 1: Iterate through desired resources (desired_index)\n        # TODO 2: For each desired resource, check if it exists in current_state\n        # TODO 3: If NOT in current_state -> CREATE action\n        #         - prior_state = None\n        #         - new_state = StateRecord from resource (resource_id=\"\")\n        # TODO 4: If EXISTS in current_state -> compare attributes\n        #         - Use _compare_attributes() helper for deep comparison\n        #         - If different -> UPDATE action (both states populated)\n        #         - If same -> NOOP action\n        # TODO 5: After processing desired resources, find resources in current_state\n        #         that are NOT in desired_index -> DELETE action\n        #         - resource = Resource from StateRecord (type and name)\n        #         - prior_state = the StateRecord, new_state = None\n        # TODO 6: Add each action to actions dict keyed by resource address\n        # TODO 7: Return actions dict\n        \n        return actions\n    \n    def get_resource_address(self, resource: Resource) -> str:\n        \"\"\"\n        Generate a unique address string for a resource.\n        \n        Args:\n            resource: A Resource object.\n        \n        Returns:\n            String in format \"{resource.type}.{resource.name}\".\n        \"\"\"\n        # TODO 1: Return f\"{resource.type}.{resource.name}\"\n        pass\n    \n    def _compare_attributes(\n        self,\n        desired_attrs: Dict[str, any],\n        current_attrs: Dict[str, any]\n    ) -> bool:\n        \"\"\"\n        Deep compare resource attributes, handling provider-specific semantics.\n        \n        Args:\n            desired_attrs: Attributes from configuration.\n            current_attrs: Attributes from cloud API (StateRecord).\n        \n        Returns:\n            True if attributes are effectively equal, False if changes are needed.\n        \"\"\"\n        # TODO 1: Implement a recursive comparison that handles:\n        #         - Lists where order may not matter (e.g., security group rules)\n        #         - Ignoring read-only/computed fields (like 'arn', 'id')\n        #         - Type coercion (string \"10\" vs integer 10)\n        #         - Nested dictionaries\n        # TODO 2: Return True if equal, False if any meaningful difference found\n        pass\n```\n\n**E. Language-Specific Hints (Python)**\n- Use `pathlib.Path` for all file path operations—it's more readable and cross-platform than `os.path`.\n- The `json` module's `default=str` parameter in `json.dump` handles non-serializable types (like `datetime`) by converting them to strings.\n- For atomic file replacement, `os.replace()` (Python 3.3+) is the most reliable cross-platform method.\n- When implementing the heartbeat thread, use `threading.Event` for clean shutdown rather than checking a boolean flag.\n- In `_compare_attributes`, consider using a \"schema\" per resource type to know which fields are computed/read-only and should be ignored during diff.\n\n**F. Milestone Checkpoint**\nAfter implementing the State Manager, verify its functionality:\n1. **Test Atomic Writes**: Create a test that writes a state file, simulates a crash (delete temp file mid-write), and ensures the original state remains uncorrupted.\n2. **Test Locking**: Run two Python scripts simultaneously that try to acquire the same lock. The second should wait (or timeout) until the first releases it.\n3. **Test Diff Logic**: Write unit tests for `compute_diff` with various scenarios: new resource, changed attribute, deleted resource, identical resource (`NOOP`).\n4. **Integration Test**: Run `plan_command` on a simple configuration. It should read state (or start with empty), compute a diff, and output a plan showing `CREATE` actions.\n\n**Expected Behavior**:\n- State file is created at `terraform.tfstate` after first successful apply.\n- A lock file (`terraform.tfstate.lock`) appears during `plan`/`apply` and disappears afterward.\n- Running `plan` twice on the same configuration (without apply) should show the same changes (idempotent diff).\n\n**Signs of Trouble**:\n- \"State file is corrupted\" errors: Check `write_atomic_json` is being used and temp files are cleaned up.\n- \"Lock never released\": Check heartbeat thread is daemon and `stop_event` is set in `release_lock`. Look for orphaned `.lock` files.\n- \"Plan shows no changes when resources exist\": Verify `compute_diff` attribute comparison logic, especially for nested structures.\n\n---\n\n\n## Component Design: Planner (Dependency Graph & Planning)\n> **Milestone(s):** 3\n\nThe **Planner** is the strategic brain of the IaC engine, responsible for transforming a collection of resources (from the parser) and the current state (from the state manager) into a safe, ordered execution plan. It determines **what** needs to change and, critically, **in what order** those changes must be applied to respect dependencies and avoid system failures.\n\n![Flowchart: Dependency Graph and Topological Sort](./diagrams/flowchart-graph.svg)\n\n### Mental Model: The Project Manager and Gantt Chart\n\nThink of the Planner as a **project manager** preparing to renovate a house. The project manager receives:\n\n1.  **The Blueprint:** The desired configuration from the parser (like the architect's new plans).\n2.  **The As-Built Drawings:** The current state from the state manager (what's actually constructed today).\n\nThe manager's job is to compare these two documents and create a **detailed work plan (execution plan)** for the construction crew. To do this, they must:\n\n*   **Identify Task Dependencies (Build the Dependency Graph):** They analyze which tasks depend on others. You cannot install light fixtures until the electrical wiring is run. You cannot pour the foundation until the site is excavated. These dependencies form a **Directed Acyclic Graph (DAG)** of tasks. A cycle (e.g., \"Task A needs B, but B also needs A\") indicates a planning error and must be caught.\n*   **Sequence the Work (Topological Sort):** Using the DAG, the manager creates a **Gantt chart** – a linear sequence of tasks where all dependencies are satisfied before a task begins. This is the topological sort.\n*   **Determine Action Types (Compute the Diff):** For each task (resource), the manager decides if it's a **new addition (CREATE)**, a **modification (UPDATE)**, something to be **removed (DELETE)**, or if it's already correct and needs **no action (NOOP)**.\n*   **Plan for Teardown (Reverse Destroy Order):** If removing parts of the house, the manager knows to work in reverse: remove light fixtures *before* removing the wiring, and remove the wiring *before* removing the wall it's in. The Planner ensures **destroy operations follow the reverse dependency order**.\n\nThis mental model emphasizes the Planner's core responsibilities: **dependency analysis, ordering, and change calculation** to produce a safe, actionable plan.\n\n### Interface and Public Methods\n\nThe Planner component exposes a clean interface focused on graph construction and plan generation. Its primary client is the CLI layer when executing the `plan_command`.\n\n| Method Name | Parameters | Returns | Description |\n| :--- | :--- | :--- | :--- |\n| `build_graph` | `resources: List[Resource]`, `state_records: Dict[str, StateRecord]` | `Dict[str, DependencyGraphNode]` | Constructs a dependency graph from the provided resources and existing state. Extracts both implicit (attribute reference) and explicit (`depends_on`) dependencies. Returns a dictionary mapping resource addresses to their graph node. |\n| `validate_acyclic` | `graph: Dict[str, DependencyGraphNode]` | `bool` | Validates that the dependency graph contains no cycles. Returns `True` if the graph is acyclic; raises a `CycleDetectionError` with details of the detected cycle if not. |\n| `topological_sort` | `graph: Dict[str, DependencyGraphNode]` | `List[str]` | Performs a topological sort on the validated DAG. Returns an ordered list of resource addresses where each resource appears **after** all its dependencies. |\n| `generate_plan` | `sorted_resources: List[str]`, `desired_resources: Dict[str, Resource]`, `current_state: Dict[str, StateRecord]` | `Dict[str, PlanAction]` | The core planning algorithm. Iterates through resources in topological order, comparing each desired `Resource` against its corresponding `StateRecord` to produce a `PlanAction`. Returns a dictionary of actions keyed by resource address. |\n| `plan_command` *(CLI)* | `config_path: Path`, `state_path: Path`, `var_file: Optional[Path]` | `None` | The orchestrating CLI command. Calls the parser (`process_configuration`), reads state (`read_state`), calls the planner's methods (`build_graph`, `validate_acyclic`, `topological_sort`, `generate_plan`), and prints a human-readable summary of the execution plan. |\n\n### Internal Behavior and Algorithm\n\nThe Planner's internal logic is a multi-stage pipeline. Each stage transforms data, progressively refining the raw configuration and state into a precise execution plan.\n\n#### 1. Dependency Graph Construction (`build_graph`)\n\nThis algorithm builds the `DependencyGraphNode` for each resource. A `DependencyGraphNode` tracks what a resource **depends on** (`depends_on`) and what **depends on it** (`required_by`).\n\n| Field | Type | Description |\n| :--- | :--- | :--- |\n| `resource_id` | `str` | The unique address of the resource (e.g., `aws_instance.web_server`). |\n| `depends_on` | `List[str]` | List of resource addresses that **this resource** depends on. Populated during dependency extraction. |\n| `required_by` | `List[str]` | List of resource addresses that depend on **this resource**. Populated as edges are added, creating the reverse link for efficient traversal. |\n\n**Algorithm Steps:**\n\n1.  **Initialize Graph:** Create an empty dictionary `graph: Dict[str, DependencyGraphNode]`. For each resource in `resources` and each existing resource in `state_records`, create a node with empty `depends_on` and `required_by` lists.\n2.  **Extract Explicit Dependencies:** For each resource, check for an explicit `depends_on` attribute in its `attributes` map. If present, validate that each referenced resource address exists in the combined set of desired and existing resources. For each valid reference, add the dependency to the current resource's `depends_on` list.\n3.  **Extract Implicit Dependencies:** This is the most complex step. For each resource, recursively scan all values in its `attributes` map (including nested maps and lists) for **interpolation references**. A reference pattern is `${<reference>}`. We are interested in references to other resources, which typically follow patterns like `${aws_security_group.my_sg.id}` or `${module.vpc.subnet_id}`.\n    *   **Parse the Reference:** Extract the referenced path (e.g., `aws_security_group.my_sg.id`).\n    *   **Resolve to Resource Address:** The core of the path before the first dot (`.`) or opening bracket (`[`) is the **resource address** (e.g., `aws_security_group.my_sg`). You may need to handle module outputs (e.g., `module.vpc.subnet_id` resolves to a resource inside the `vpc` module). The Planner relies on the Parser having already **flattened** module resources and resolved their addresses to global, unique strings.\n    *   **Add Dependency Edge:** If the resolved resource address exists in the graph, add an edge from the current resource (dependent) to the referenced resource (dependency). This means adding the dependency's address to the current resource's `depends_on` list and adding the current resource's address to the dependency's `required_by` list.\n4.  **Return Graph:** Return the completed `graph` dictionary.\n\n#### 2. Cycle Detection (`validate_acyclic`)\n\nA cycle in the dependency graph means no valid execution order exists (e.g., Resource A needs B created first, but B needs A created first). We must detect and report this before proceeding.\n\n**Algorithm Steps (Kahn's Algorithm or DFS):**\n\n1.  Use **Depth-First Search (DFS)** with coloring:\n    *   `WHITE` = Unvisited node\n    *   `GREY` = Currently visiting (in the DFS stack)\n    *   `BLACK` = Fully processed\n2.  For each node in the graph, if it's `WHITE`, start a DFS.\n3.  When entering a node, mark it `GREY`.\n4.  For each dependency in the node's `depends_on` list:\n    *   If the dependency node is `GREY`, a cycle has been found. Construct an error message tracing the cycle path and raise a `CycleDetectionError`.\n    *   If the dependency node is `WHITE`, recursively visit it.\n5.  After processing all dependencies, mark the node `BLACK`.\n6.  If the DFS completes for all nodes without finding a `GREY` dependency, the graph is acyclic.\n\n#### 3. Topological Sort (`topological_sort`)\n\nGiven an acyclic graph, we produce a linear execution order. **Kahn's Algorithm** is intuitive and efficient.\n\n**Algorithm Steps:**\n\n1.  **Compute In-Degree:** For each node in the graph, compute its \"in-degree\" – the count of resources that depend on it (the length of its `required_by` list). You can derive this from the `graph` structure.\n2.  **Initialize Queue:** Create a queue (or list) and add all nodes with an in-degree of `0`. These are resources with no dependencies and can be executed first.\n3.  **Process Queue:** While the queue is not empty:\n    a.  Remove a node `n` from the queue.\n    b.  Append `n.resource_id` to the result list `sorted_order`.\n    c.  For each node `m` that `n` depends on (i.e., for each node in `n.depends_on`), decrement the in-degree of `m` by `1`.\n    d.  If the in-degree of `m` becomes `0`, add `m` to the queue.\n4.  **Check for Cycles (Again):** After the queue is empty, if the length of `sorted_order` is less than the total number of nodes in the graph, it indicates a cycle (though `validate_acyclic` should have caught this). This is a final sanity check.\n5.  **Return Order:** Return the `sorted_order` list.\n\n#### 4. Plan Generation (`generate_plan`)\n\nThis function translates the desired state, current state, and execution order into concrete `PlanAction` objects. It must handle the four fundamental action types.\n\n| Field | Type | Description |\n| :--- | :--- | :--- |\n| `action_type` | `ActionType` (Enum) | One of: `CREATE`, `UPDATE`, `DELETE`, `NOOP`. |\n| `resource` | `Resource` | The desired `Resource` object. For `DELETE` actions, this is the resource *as it exists in the current state* (or a placeholder). |\n| `prior_state` | `Optional[StateRecord]` | The state of the resource before the action. Present for `UPDATE` and `DELETE`; `None` for `CREATE`. |\n| `new_state` | `Optional[StateRecord]` | The expected state of the resource after the action. Present for `CREATE` and `UPDATE`; `None` for `DELETE`. |\n\n**Algorithm Steps:**\n\n1.  **Initialize Plan:** Create an empty dictionary `plan: Dict[str, PlanAction]`.\n2.  **Iterate in Sorted Order:** Loop through each `resource_id` in the `sorted_resources` list.\n3.  **Retrieve States:** Get the `desired_resource` from `desired_resources` dict and the `current_record` from `current_state` dict for this `resource_id`. One may be `None`.\n4.  **Determine Action Type:**\n    *   If `desired_resource` exists and `current_record` is `None` → `ActionType.CREATE`\n    *   If `desired_resource` exists and `current_record` exists → Compare their `attributes`. If any attribute differs (deep comparison), → `ActionType.UPDATE`. If identical → `ActionType.NOOP`.\n    *   If `desired_resource` is `None` and `current_record` exists → `ActionType.DELETE`\n5.  **Construct PlanAction:**\n    *   For `CREATE`: `action_type=CREATE`, `resource=desired_resource`, `prior_state=None`, `new_state=a StateRecord derived from desired_resource`.\n    *   For `UPDATE`: `action_type=UPDATE`, `resource=desired_resource`, `prior_state=current_record`, `new_state=a StateRecord derived from desired_resource`.\n    *   For `DELETE`: `action_type=DELETE`, `resource=a Resource constructed from current_record`, `prior_state=current_record`, `new_state=None`.\n    *   For `NOOP`: `action_type=NOOP`, `resource=desired_resource`, `prior_state=current_record`, `new_state=current_record`.\n6.  **Store Action:** Add the `PlanAction` to the `plan` dictionary keyed by `resource_id`.\n7.  **Return Plan:** After processing all resources, return the `plan`.\n\n> **Key Design Insight:** The plan is generated **in dependency order**, but the `PlanAction` objects themselves are stored in a dictionary for easy lookup by the Executor. The Executor will later use the same topological order (or its reverse for destroy) to sequence operations.\n\n### ADR: Implicit vs. Explicit Dependency Detection\n\n> **Decision: Implement Both Implicit and Explicit Dependency Detection**\n>\n> - **Context:** Resources in an IaC configuration can depend on each other in two ways: 1) **Explicitly** via a `depends_on` directive, and 2) **Implicitly** via attribute references (e.g., using another resource's ID in a configuration string). We must decide which types of dependencies the Planner will recognize to build an accurate and safe execution graph.\n> - **Options Considered:**\n>     1.  **Explicit-Only Detection:** Only process the `depends_on` attribute. This is simple and fast but fails to catch the majority of real-world dependencies expressed through interpolation, leading to runtime failures when a resource references an attribute of another resource that hasn't been created yet.\n>     2.  **Implicit-Only Detection:** Only parse attribute values for interpolation references. This catches the most common dependency patterns but forces users to understand the engine's reference parsing logic. It may also miss dependencies expressed through complex, indirect means not caught by the parser.\n>     3.  **Hybrid Detection (Explicit + Implicit):** Process both `depends_on` and interpolated references. This provides robustness and user flexibility. Explicit `depends_on` can be used to force an ordering when implicit detection fails or is unclear.\n> - **Decision:** Implement **Hybrid Detection (Option 3)**. The Planner will scan for and process both explicit `depends_on` directives and implicit references found in attribute values.\n> - **Rationale:** The primary goal of the Planner is to guarantee a safe apply order. Relying solely on explicit dependencies places too much burden on the user and is error-prone. Relying solely on implicit detection is complex and may have blind spots. The hybrid approach offers a safety net: implicit detection handles the common cases automatically, while explicit `depends_on` allows users to override or clarify dependencies when necessary (e.g., for resources managed by a provider that don't expose useful attributes, or for meta-dependencies not expressed in configuration).\n> - **Consequences:**\n>     *   **Increased Complexity:** The dependency extraction logic must handle two distinct patterns and resolve interpolated strings to resource addresses. This requires a well-defined reference syntax and a robust parsing step.\n>     *   **Potential for Over-Specification:** Users might add unnecessary `depends_on` statements, which clutter the config but do not cause harm.\n>     *   **Accurate Graphs:** The resulting dependency graph more closely reflects the true operational dependencies of the infrastructure, leading to more reliable `apply` operations.\n\n| Option | Pros | Cons | Chosen? |\n| :--- | :--- | :--- | :--- |\n| **Explicit-Only** | Simple to implement and understand. | Fragile; misses most real dependencies, causing apply failures. | ❌ |\n| **Implicit-Only** | Catches common patterns automatically; reduces config clutter. | Complex to implement; may miss edge cases; no user override. | ❌ |\n| **Hybrid** | Robust; provides safety net with user override; mirrors industry standards (Terraform). | More complex implementation; requires parsing interpolation. | ✅ |\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Uncaught Circular Dependencies**\n*   **Description:** A configuration where Resource A depends on B, and B depends on A (directly or indirectly) creates a cycle. If the cycle detection algorithm fails (e.g., only checks explicit `depends_on` but not implicit references), the topological sort will either fail silently or produce an invalid order.\n*   **Why it's Wrong:** Applying such a plan is impossible. The engine would be stuck trying to create A before B and B before A. In practice, this can lead to infinite loops, partial applies, or corrupted state.\n*   **How to Fix:** Implement robust cycle detection using DFS coloring on the **full hybrid graph**. When a cycle is detected, **fail fast** with a clear error message listing the resources involved in the cycle. Do not attempt to generate a plan.\n\n⚠️ **Pitfall: Missed Implicit Dependencies from Complex Interpolation**\n*   **Description:** The implicit reference scanner only looks for simple `${type.name.attr}` patterns. It might miss dependencies hidden within string concatenation (`\"prefix-${var.sg_id}\"`), complex functions (`md5(\"${aws_instance.a.id}-salt\")`), or conditional logic (`count = var.create ? 1 : 0`).\n*   **Why it's Wrong:** The execution plan will be missing critical edges. During apply, a resource may try to reference an attribute from another resource that hasn't been created yet, causing a provider API error.\n*   **How to Fix:** 1) Document the limitation and encourage use of explicit `depends_on` for complex cases. 2) Implement a more sophisticated expression evaluator in the Parser that can resolve variable and resource references *statically* and export a list of referenced resources for the Planner. For Milestone 3, a best-effort scanner for common patterns is acceptable, with `depends_on` as the escape hatch.\n\n⚠️ **Pitfall: Destroy Operations in Incorrect Order**\n*   **Description:** Applying a plan that deletes resources using the same order as creation (topological sort). This tries to delete a resource (e.g., a database instance) before deleting resources that depend on it (e.g., a firewall rule pointing to that instance), which will fail because the provider API will reject the deletion of the dependent resource.\n*   **Why it's Wrong:** Destruction must respect dependency order in **reverse**. The dependent resource must be removed before the resource it depends on.\n*   **How to Fix:** When generating a plan that contains `DELETE` actions, the Executor (covered in the next section) must **reverse the topological order** for the destroy portion of the plan. The Planner's `topological_sort` provides the create/update order. The reverse of that order is the safe destroy order.\n\n### Implementation Guidance\n\n#### A. Technology Recommendations Table\n| Component | Simple Option (Recommended) | Advanced Option |\n| :--- | :--- | :--- |\n| Graph Data Structure | Python dictionaries and lists: `Dict[str, DependencyGraphNode]`. Use `List[str]` for `depends_on` and `required_by`. | NetworkX library for professional-grade graph algorithms and visualization. |\n| Cycle Detection & Topological Sort | Implement Kahn's Algorithm or DFS manually (good learning exercise). | Use `networkx.is_directed_acyclic_graph` and `networkx.topological_sort`. |\n| Deep Comparison for Diffs | Python's `==` operator with `json.dumps` serialization or recursive dictionary comparison. | Use a library like `deepdiff` for detailed diff reporting. |\n\n#### B. Recommended File/Module Structure\nAdd the Planner component to the established project layout.\n```\niac_engine/\n├── cmd/\n│   └── cli.py              # CLI commands: `plan_command`, `apply_command`\n├── core/                   # Core data types and interfaces\n│   ├── __init__.py\n│   ├── models.py           # Resource, StateRecord, PlanAction, DependencyGraphNode, ActionType Enum\n│   └── provider.py         # BaseProvider interface\n├── parser/                 # Milestone 1\n│   └── ...\n├── state/                  # Milestone 2\n│   └── ...\n├── planner/                # Milestone 3 (THIS COMPONENT)\n│   ├── __init__.py\n│   ├── builder.py          # build_graph, dependency extraction logic\n│   ├── graph_utils.py      # validate_acyclic, topological_sort, CycleDetectionError\n│   ├── plan_generator.py   # generate_plan\n│   └── errors.py           # Planner-specific exceptions\n├── executor/               # Milestone 4\n│   └── ...\n└── providers/              # Milestone 4\n    └── ...\n```\n\n#### C. Infrastructure Starter Code\n\n**Complete `DependencyGraphNode` and `CycleDetectionError`:**\n\n```python\n# File: core/models.py\nfrom typing import Dict, List, Optional, Any\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\n# ... (existing Resource, StateRecord, PlanAction definitions) ...\n\nclass ActionType(Enum):\n    CREATE = \"create\"\n    UPDATE = \"update\"\n    DELETE = \"delete\"\n    NOOP = \"noop\"\n\n@dataclass\nclass DependencyGraphNode:\n    \"\"\"Represents a node in the resource dependency DAG.\"\"\"\n    resource_id: str\n    depends_on: List[str] = field(default_factory=list)\n    required_by: List[str] = field(default_factory=list)\n\n    def add_dependency(self, dep_id: str) -> None:\n        \"\"\"Adds a dependency edge from this node to dep_id.\"\"\"\n        if dep_id not in self.depends_on:\n            self.depends_on.append(dep_id)\n```\n\n```python\n# File: planner/errors.py\nclass CycleDetectionError(Exception):\n    \"\"\"Raised when a circular dependency is detected in the resource graph.\"\"\"\n    def __init__(self, cycle_path: List[str]):\n        self.cycle_path = cycle_path\n        message = f\"Circular dependency detected: {' -> '.join(cycle_path)}\"\n        super().__init__(message)\n```\n\n**Generic Graph Utilities Skeleton:**\n\n```python\n# File: planner/graph_utils.py\nfrom typing import Dict, List\nfrom .errors import CycleDetectionError\nfrom core.models import DependencyGraphNode\n\ndef validate_acyclic(graph: Dict[str, DependencyGraphNode]) -> bool:\n    \"\"\"\n    Validates that the graph contains no cycles using DFS with coloring.\n    Returns True if acyclic, raises CycleDetectionError otherwise.\n    \"\"\"\n    WHITE, GREY, BLACK = 0, 1, 2\n    color: Dict[str, int] = {node_id: WHITE for node_id in graph}\n    stack: List[str] = []\n    \n    def dfs(node_id: str) -> None:\n        color[node_id] = GREY\n        stack.append(node_id)\n        \n        for dep_id in graph[node_id].depends_on:\n            if dep_id not in color:\n                # Dependency not in graph (maybe from a module not included). Ignore or handle.\n                continue\n            if color[dep_id] == GREY:\n                # Cycle found! The cycle is from dep_id to the node_id in the stack.\n                cycle_start = stack.index(dep_id)\n                cycle = stack[cycle_start:] + [dep_id]\n                raise CycleDetectionError(cycle)\n            if color[dep_id] == WHITE:\n                dfs(dep_id)\n        \n        stack.pop()\n        color[node_id] = BLACK\n    \n    for node_id in graph:\n        if color[node_id] == WHITE:\n            dfs(node_id)\n    return True\n\ndef topological_sort(graph: Dict[str, DependencyGraphNode]) -> List[str]:\n    \"\"\"\n    Performs a topological sort on a validated DAG using Kahn's Algorithm.\n    Returns a list of resource IDs in execution order.\n    \"\"\"\n    from collections import deque\n    \n    # 1. Compute in-degree for each node\n    in_degree: Dict[str, int] = {node_id: 0 for node_id in graph}\n    for node in graph.values():\n        for dep_id in node.depends_on:\n            if dep_id in in_degree:  # Only count dependencies present in the graph\n                in_degree[dep_id] += 1\n    \n    # 2. Initialize queue with nodes having zero in-degree\n    queue = deque([node_id for node_id, deg in in_degree.items() if deg == 0])\n    sorted_order: List[str] = []\n    \n    # 3. Process queue\n    while queue:\n        node_id = queue.popleft()\n        sorted_order.append(node_id)\n        \n        for dep_id in graph[node_id].depends_on:\n            if dep_id not in in_degree:\n                continue\n            in_degree[dep_id] -= 1\n            if in_degree[dep_id] == 0:\n                queue.append(dep_id)\n    \n    # 4. Check for cycles (should not happen if validate_acyclic was called)\n    if len(sorted_order) != len(graph):\n        missing = set(graph.keys()) - set(sorted_order)\n        raise CycleDetectionError(f\"Graph has cycle(s) involving: {missing}\")\n    \n    return sorted_order\n```\n\n#### D. Core Logic Skeleton Code\n\n**Dependency Graph Builder:**\n\n```python\n# File: planner/builder.py\nimport re\nfrom typing import Dict, List, Any\nfrom pathlib import Path\nfrom core.models import Resource, StateRecord, DependencyGraphNode\n\n# Simple pattern to find interpolation references: ${...}\n# This is a simplified version. A real implementation would need a proper HCL expression parser.\nREF_PATTERN = re.compile(r'\\$\\{([^}]+)\\}')\n\ndef extract_resource_address_from_ref(ref: str) -> str:\n    \"\"\"\n    Attempts to extract a resource address from an interpolation reference.\n    Example: 'aws_security_group.my_sg.id' -> 'aws_security_group.my_sg'\n             'module.vpc.subnet_id' -> 'module.vpc' (module resources are flattened by parser)\n    This is a heuristic and may need refinement.\n    \"\"\"\n    # Split by '.' and take the first two parts if it looks like a resource reference.\n    parts = ref.split('.')\n    if len(parts) >= 2:\n        # Check if the first part is a resource type or 'module'\n        if parts[0] in ('module', 'data') or not parts[0].startswith('var'):\n            return f\"{parts[0]}.{parts[1]}\"\n    # If we can't parse it, return the original ref. The caller will filter it out.\n    return ref\n\ndef find_references_in_value(value: Any) -> List[str]:\n    \"\"\"\n    Recursively traverses a value (which can be dict, list, str, etc.)\n    and extracts all interpolation reference strings.\n    \"\"\"\n    refs = []\n    if isinstance(value, str):\n        matches = REF_PATTERN.findall(value)\n        refs.extend(matches)\n    elif isinstance(value, dict):\n        for v in value.values():\n            refs.extend(find_references_in_value(v))\n    elif isinstance(value, list):\n        for item in value:\n            refs.extend(find_references_in_value(item))\n    return refs\n\ndef build_graph(resources: List[Resource],\n                state_records: Dict[str, StateRecord]) -> Dict[str, DependencyGraphNode]:\n    \"\"\"\n    Builds a dependency graph from desired resources and existing state records.\n    \"\"\"\n    graph: Dict[str, DependencyGraphNode] = {}\n    \n    # TODO 1: Create nodes for all resources and existing state records.\n    #   For each resource in `resources`, create a DependencyGraphNode with resource_id = get_resource_address(resource).\n    #   For each record in `state_records`, also create a node if one doesn't already exist.\n    #   Add all nodes to the `graph` dict keyed by resource_id.\n    \n    # TODO 2: Process explicit dependencies (depends_on).\n    #   For each resource in `resources`:\n    #       Check its attributes for a key named 'depends_on'. The value is likely a list of strings.\n    #       For each dependency string in that list:\n    #           Validate the dependency exists in the `graph`.\n    #           Add the dependency to the current resource's node.depends_on list.\n    #           Add the current resource to the dependency node's required_by list.\n    \n    # TODO 3: Process implicit dependencies (interpolation references).\n    #   For each resource in `resources`:\n    #       Recursively find all interpolation references in its attributes using `find_references_in_value`.\n    #       For each reference found:\n    #           Attempt to resolve it to a resource address using `extract_resource_address_from_ref`.\n    #           If the resolved address exists in the `graph` and is NOT the resource itself:\n    #               Add an implicit dependency edge (same as step 2).\n    \n    # TODO 4: Return the completed graph.\n    return graph\n```\n\n**Plan Generator:**\n\n```python\n# File: planner/plan_generator.py\nfrom typing import Dict, List\nfrom core.models import Resource, StateRecord, PlanAction, ActionType, get_resource_address\n\ndef generate_plan(sorted_resource_ids: List[str],\n                  desired_resources: Dict[str, Resource],\n                  current_state: Dict[str, StateRecord]) -> Dict[str, PlanAction]:\n    \"\"\"\n    Generates a PlanAction for each resource based on desired vs current state.\n    \"\"\"\n    plan: Dict[str, PlanAction] = {}\n    \n    # TODO 1: Iterate through each resource_id in the sorted_resource_ids list.\n    \n    # TODO 2: For each resource_id, retrieve:\n    #   desired = desired_resources.get(resource_id)\n    #   current = current_state.get(resource_id)\n    \n    # TODO 3: Determine the action type based on the presence of desired and current.\n    #   Use the logic described in the \"Plan Generation\" algorithm.\n    #   For UPDATE, you need to compare attributes. A simple way is:\n    #       import json; is_update = json.dumps(desired.attributes) != json.dumps(current.attributes)\n    \n    # TODO 4: Construct the appropriate PlanAction object.\n    #   Remember to set prior_state and new_state correctly for each action type.\n    #   For CREATE, new_state should be a StateRecord created from the desired Resource.\n    #   For DELETE, the PlanAction's 'resource' field should be derived from the current_state.\n    \n    # TODO 5: Add the PlanAction to the plan dictionary with resource_id as the key.\n    \n    # TODO 6: After the loop, return the plan dictionary.\n    return plan\n```\n\n#### E. Language-Specific Hints\n*   Use Python's `@dataclass` decorator from the `dataclasses` module for clean model definitions like `DependencyGraphNode`. It automatically generates `__init__`, `__repr__`, and `__eq__` methods.\n*   For recursive search in `find_references_in_value`, using `isinstance()` checks for `dict`, `list`, and `str` is a straightforward approach. Be mindful of recursion depth for very large configurations.\n*   When comparing attribute dictionaries for updates, serializing to JSON with `json.dumps` and comparing strings is a simple, order-insensitive way to perform a deep equality check. For more complex comparisons (e.g., ignoring certain fields), consider using the `deepdiff` library.\n*   The `re` module is sufficient for basic interpolation pattern matching. For a production-grade parser, you would integrate with the actual expression AST from the Parser component.\n\n\n## Component Design: Provider Abstraction & Executor\n> **Milestone(s):** 4\n\nThe **Provider Abstraction & Executor** represents the \"muscle\" of the IaC engine. While previous components understand *what* needs to change, this component actually *makes* those changes by interacting with external cloud platforms through a clean plugin architecture. The **Executor** orchestrates the safe application of the execution plan, while the **Provider Abstraction** defines the uniform interface that all cloud-specific implementations must follow.\n\n### Mental Model: The Universal Remote Control\n\nImagine you have a universal remote control that can operate any brand of TV. The remote has a standard set of buttons: Power, Volume Up/Down, Channel Change. However, each TV manufacturer requires different infrared codes to execute these same actions. The universal remote solves this by having a collection of \"device codes\" – each code translates the standard button press into the specific signals that a particular TV model understands.\n\nIn this analogy:\n- The **`BaseProvider` interface** is the standard set of buttons (CRUD operations) that every remote must have.\n- Each **provider implementation** (AWS, Azure, GCP) is a specific device code that translates those standard operations into the exact HTTP API calls, authentication mechanisms, and error handling for that cloud.\n- The **Executor** is the person holding the remote, who knows *when* to press which buttons and in what order, based on the execution plan (the \"channel guide\").\n\nThis separation achieves **polymorphism**: the Executor can orchestrate infrastructure changes without knowing the details of any specific cloud API. When we need to support a new cloud, we simply add a new \"device code\" (provider implementation) without modifying the orchestration logic.\n\n### Interface and Public Methods\n\nThe Provider Abstraction is defined by a Python abstract base class (ABC) that all concrete providers must implement. The Executor is a separate class that consumes this interface to apply changes.\n\n#### BaseProvider Interface\nAll providers must implement these CRUD lifecycle methods plus configuration validation.\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `create` | `resource: Resource` | `Resource` | Creates a new cloud resource. Takes a `Resource` with desired attributes, calls the cloud API, and returns a `Resource` populated with the actual created resource's attributes (including its cloud-assigned ID). Must be idempotent. |\n| `read` | `resource_id: str, resource_type: str` | `Optional[Resource]` | Reads the current state of a resource from the cloud API using its unique identifier. Returns a `Resource` if the resource exists, or `None` if it does not. Used for state refresh and validation. |\n| `update` | `resource_id: str, resource: Resource` | `Resource` | Updates an existing cloud resource. Compares current attributes (from `read`) with desired attributes, makes necessary API calls, and returns the updated `Resource`. Must handle partial updates and be idempotent. |\n| `delete` | `resource_id: str, resource_type: str` | `bool` | Deletes a cloud resource. Returns `True` if deletion succeeded or the resource was already absent, `False` on unrecoverable failure. Must be idempotent (deleting a non-existent resource is a success). |\n| `validate_credentials` | `config: dict` | `bool` | Validates that the provider configuration (credentials, region, etc.) is correct and can authenticate with the cloud API. Returns `True` on success, raises a descriptive exception on failure. |\n| `get_schema` | `resource_type: str` | `dict` | (Optional) Returns the attribute schema for a given resource type, used for validation. Includes required vs. optional fields, data types, and allowed values. |\n\n#### Executor Class\nThe Executor applies a plan by calling provider methods in the correct order, with safety mechanisms.\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `apply_plan` | `plan: Dict[str, PlanAction], providers: Dict[str, BaseProvider], max_concurrency: int = 1` | `Dict[str, ApplyResult]` | Main entry point. Applies the execution plan using the provided provider instances. Respects dependency ordering (plan already topologically sorted). Supports limited concurrency for independent resources. Returns a dictionary mapping resource addresses to `ApplyResult` objects (success/failure, new state, errors). |\n| `refresh_state` | `resource: Resource, provider: BaseProvider` | `Optional[Resource]` | Helper method that calls `provider.read` to get the current cloud state of a single resource. Used before updates and after creates to populate the state file with accurate attributes. |\n| `_execute_action` | `action: PlanAction, provider: BaseProvider` | `ApplyResult` | Internal method that executes a single `PlanAction` (CREATE, UPDATE, DELETE) by calling the corresponding provider method. Wraps the call with retry logic, timeout, and error handling. |\n\n**Supporting Data Structures:**\n\n| Type Name | Fields | Description |\n|-----------|--------|-------------|\n| `ApplyResult` | `resource_address: str`, `success: bool`, `new_state: Optional[Resource]`, `error: Optional[str]`, `retries: int` | Captures the outcome of applying a single `PlanAction`. Used to report success/failure back to the Executor and ultimately the user. |\n| `ProviderConfig` | `provider_type: str`, `config: dict` | Holder for provider-specific configuration (e.g., AWS region, access keys). Loaded from configuration files and passed to provider factory functions. |\n\n### Internal Behavior and Algorithm\n\nThe Executor's primary algorithm is the `apply_plan` method, which transforms a set of planned actions into actual cloud resources. The algorithm must be robust to partial failures, API rate limits, and eventual consistency.\n\n#### Algorithm: Executing an Infrastructure Plan\n1. **Input Validation & Setup**\n   - Verify that for every `PlanAction` in the plan, a corresponding `BaseProvider` instance exists in the `providers` dictionary (keyed by provider type, e.g., \"aws\").\n   - Initialize an empty results dictionary to track `ApplyResult` for each resource.\n   - If `max_concurrency > 1`, initialize a thread pool or async task queue. For simplicity, our reference implementation will use sequential execution (`max_concurrency = 1`).\n\n2. **Sequential Execution Following Topological Order**\n   - The `plan` dictionary is assumed to be already ordered by the Planner via topological sort (keys are resource addresses in execution order).\n   - For each resource address in the sorted order:\n     a. Retrieve the `PlanAction` for this resource.\n     b. Retrieve the appropriate `BaseProvider` instance based on the resource's type (e.g., \"aws_instance\" → \"aws\" provider).\n     c. Call `_execute_action(action, provider)`.\n     d. Store the resulting `ApplyResult` in the results dictionary.\n     e. **Critical: Update In-Memory State Immediately.** If the action succeeded, update an in-memory copy of the state with the `new_state` from the result. This ensures subsequent actions that depend on this resource see the updated state (e.g., a created resource's ID for reference).\n\n3. **Single Action Execution (`_execute_action`)**\n   For a given `PlanAction` and `BaseProvider`:\n   1. Determine the operation from `action.action_type`:\n      - `ActionType.CREATE`:\n        - Call `provider.create(action.resource)` with retry logic (see ADR below).\n        - After successful creation, call `provider.read` to refresh and capture all server-generated attributes (e.g., cloud IDs, timestamps).\n        - Return an `ApplyResult` with `success=True` and the refreshed resource as `new_state`.\n      - `ActionType.UPDATE`:\n        - First, call `provider.read` to get the current actual state from the cloud.\n        - Compare attributes with `action.resource` to compute the minimal update delta (some providers require full replacement).\n        - Call `provider.update(resource_id, action.resource)` with retry logic.\n        - Call `provider.read` again to refresh state.\n        - Return `ApplyResult` with the refreshed resource.\n      - `ActionType.DELETE`:\n        - Call `provider.delete(resource_id, resource_type)` with retry logic.\n        - Verify deletion by calling `provider.read`; it should return `None`.\n        - Return `ApplyResult` with `success=True` and `new_state=None`.\n      - `ActionType.NOOP`: Return a successful `ApplyResult` with the existing state.\n   2. **Retry & Error Handling Wrapper:**\n      - Wrap each provider call in a retry decorator implementing exponential backoff with jitter.\n      - Catch transient errors (network timeouts, rate limit exceedances, 5xx status codes) and retry.\n      - On permanent errors (invalid credentials, unsupported resource type, validation errors), fail immediately and return an `ApplyResult` with `success=False` and the error message.\n   3. **Timeout Protection:**\n      - Each provider call should have a configurable timeout (e.g., 300 seconds for long operations).\n      - If a timeout occurs, treat it as a transient error and retry (up to the retry limit).\n\n4. **Post-Application State Persistence**\n   - After all actions are completed (or upon early failure if we decide to stop), the Executor returns the results dictionary to the caller (typically the CLI).\n   - The caller (CLI) is responsible for writing the updated in-memory state to the state file using `write_state`, but only if the overall apply was successful (or partially successful with a flag to save). This ensures the state file only reflects changes that actually occurred.\n\n> **Key Insight:** The Executor must update its internal state representation *immediately* after each successful action, not just at the very end. This is because subsequent resources in the dependency order may reference attributes (like an ID) of a resource just created. If we don't update the internal view, those references would be pointing to stale or non-existent data.\n\n#### State Machine: Resource Lifecycle During Apply\nThe following table describes the states a resource transitions through during the `apply_plan` operation, corresponding to the ![State Machine: Resource Lifecycle](./diagrams/state-machine-resource.svg) diagram.\n\n| Current State | Event | Next State | Action Taken |\n|---------------|-------|------------|--------------|\n| Pending | `execute_action` called (CREATE) | Creating | Call `provider.create` with retry wrapper; start timeout timer. |\n| Creating | `provider.create` succeeds | Created | Call `provider.read` to refresh; store new state in memory; mark success. |\n| Creating | `provider.create` fails (permanent error) | Error | Store error in `ApplyResult`; do not update in-memory state. |\n| Creating | Timeout or transient error (with retries exhausted) | Error | Store timeout/error; do not update state. |\n| Pending | `execute_action` called (UPDATE) | Updating | Call `provider.read` → `provider.update` with retry wrapper. |\n| Updating | `provider.update` succeeds | Created | Call `provider.read` to refresh; update in-memory state. |\n| Updating | `provider.update` fails or timeout | Error | Store error; keep prior state in memory. |\n| Pending | `execute_action` called (DELETE) | Deleting | Call `provider.delete` with retry wrapper; verify with `provider.read`. |\n| Deleting | `provider.delete` succeeds (resource gone) | Deleted | Remove resource from in-memory state; mark success. |\n| Deleting | `provider.delete` fails (permanent) | Error | Store error; resource remains in state (manual intervention needed). |\n| Any state | User interrupt (Ctrl+C) | Interrupted | Attempt graceful cancellation of ongoing API call; mark as interrupted. |\n\n### ADR: Retry Logic Strategy\n\n> **Decision: Exponential Backoff with Jitter for Transient Failures**\n\n- **Context**: Cloud APIs are distributed systems that experience transient failures: network timeouts, rate limiting (429), internal server errors (5xx), and eventual consistency delays. The IaC engine must be resilient to these temporary issues without requiring user intervention, while also avoiding retry storms that exacerbate problems.\n\n- **Options Considered**:\n  1. **No retries** – Fail immediately on any error. Simplest to implement but not resilient, leading to frequent apply failures from transient issues.\n  2. **Fixed-interval retries** – Retry a fixed number of times with a constant delay (e.g., 5 seconds). Better than no retries, but can create synchronized retry bursts that overwhelm recovering services.\n  3. **Exponential backoff with jitter** – Increase wait times exponentially between retries (e.g., 1s, 2s, 4s, 8s) and add random variation (jitter) to spread retry attempts across time.\n\n- **Decision**: Implement **exponential backoff with jitter** as the default retry strategy for all provider API calls.\n\n- **Rationale**:\n  - Exponential backoff respects the cloud provider's potential overload by progressively reducing retry pressure, aligning with the TCP congestion control principle.\n  - Jitter (randomization) prevents thundering herd problems where many failed requests all retry at the same time, which is especially important in multi-tenant or parallel apply scenarios.\n  - This pattern is a well-established best practice for distributed system clients (AWS SDKs, Google Cloud libraries, and Terraform itself use it).\n  - The additional implementation complexity is modest (a decorator or wrapper function) and pays off in dramatically improved robustness.\n\n- **Consequences**:\n  - **Positive**: The IaC engine becomes significantly more resilient to transient cloud issues without user intervention.\n  - **Positive**: Retry logic is centralized in one place (the Executor's wrapper), ensuring consistent behavior across all providers.\n  - **Negative**: Apply operations may take longer to complete when retries occur (but this is preferable to failure).\n  - **Negative**: Requires careful configuration of maximum retry attempts and maximum delay to avoid excessively long hangs (e.g., cap total retry time at 5-10 minutes).\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| No retries | Simple; fails fast | Not resilient; frequent user intervention needed | No |\n| Fixed-interval retries | Some resilience; simple | Can cause retry synchronization; not adaptive | No |\n| Exponential backoff with jitter | Highly resilient; avoids retry storms; industry standard | Slightly more complex to implement | **Yes** |\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Rate Limit Ignorance Leads to Global API Ban**\n- **Description**: Implementing retries without respect to cloud API rate limits (e.g., AWS throttling) can cause the provider to temporarily ban your account's API key if you send too many requests too quickly.\n- **Why it's wrong**: The retry logic itself becomes a denial-of-service attack on the cloud API, triggering stricter rate limits or temporary suspensions.\n- **Fix**: Always inspect error responses for rate limit headers (e.g., `Retry-After`, `X-RateLimit-Reset`). When a 429 (Too Many Requests) is received, extract the recommended wait time and honor it. Additionally, implement client-side rate limiting (token bucket) for each provider to stay below known limits.\n\n⚠️ **Pitfall: Read-After-Create Race with Eventual Consistency**\n- **Description**: After a `create` call returns successfully, immediately calling `read` to refresh state might return a 404 (Not Found) because the cloud's internal consistency model hasn't propagated the resource existence to all regions or servers.\n- **Why it's wrong**: The Executor may incorrectly assume the create failed, or may populate the state file with incomplete data, causing downstream errors.\n- **Fix**: In the `create` flow, wrap the post-creation `read` call in its own retry loop with a short delay, specifically handling 404s as transient errors for a limited time (e.g., up to 30 seconds). This is separate from the general retry logic for the `create` itself.\n\n⚠️ **Pitfall: Zombie Resources from Partial Apply Failures**\n- **Description**: If the `apply_plan` fails halfway through (e.g., network partition), some resources may have been created in the cloud but not recorded in the updated state file because the overall apply wasn't committed.\n- **Why it's wrong**: On the next plan, the engine sees a discrepancy: the cloud has resources the state file doesn't know about, leading to confusion (should they be imported or deleted?). This is a form of state drift.\n- **Fix**: Implement a two-phase approach: 1) Perform all operations, collecting results, but don't persist state yet. 2) If *any* operation failed critically, attempt to roll back created resources (in reverse dependency order) before returning. If rollback succeeds, state remains unchanged. If rollback fails, alert the user about orphaned resources that require manual cleanup. For simplicity in the learning project, we may accept this risk and document it, requiring manual `import` for orphaned resources.\n\n⚠️ **Pitfall: Assuming Idempotency Without Validation**\n- **Description**: Assuming that a cloud API's `delete` operation is idempotent (returns success for a non-existent resource) without verifying it, leading to errors when a provider behaves differently.\n- **Why it's wrong**: Not all cloud APIs are perfectly idempotent. Some may return 404 on delete of a non-existent resource, which should be treated as success but might be flagged as an error by naive error detection.\n- **Fix**: In the `delete` implementation, catch specific \"not found\" error codes and treat them as success. Document idempotency expectations as part of the `BaseProvider` contract, and test each provider implementation to ensure they comply.\n\n### Implementation Guidance\n\n#### A. Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Provider Interface | Python `abc.ABC` with abstract methods | Protocol classes (structural subtyping) with `typing.Protocol` |\n| HTTP Client for Cloud APIs | `requests` library with session management | `httpx` with async/await support for concurrent operations |\n| Retry Logic | Custom decorator with `time.sleep` | `tenacity` library (rich feature set) or `backoff` |\n| Configuration | JSON/YAML files via `pyyaml` | Dynamic loading with environment variable interpolation |\n| Concurrency | Sequential execution (simpler) | `concurrent.futures.ThreadPoolExecutor` for parallel independent resources |\n\n#### B. Recommended File/Module Structure\n\n```\niac_engine/\n├── providers/               # Provider abstraction and implementations\n│   ├── __init__.py\n│   ├── base.py             # BaseProvider abstract class, ProviderConfig\n│   ├── aws/                # AWS-specific provider\n│   │   ├── __init__.py\n│   │   ├── provider.py     # AWSProvider class\n│   │   └── resources/      # Resource-specific modules (ec2, s3, etc.)\n│   ├── azure/              # Azure provider (similar structure)\n│   └── mock/               # Mock provider for testing\n├── executor.py             # Executor class, ApplyResult\n├── retry.py                # Retry decorator utility\n├── state_manager.py        # (From Milestone 2)\n├── planner.py              # (From Milestone 3)\n└── cli.py                  # CLI commands (plan_command, apply_command)\n```\n\n#### C. Infrastructure Starter Code\n\n**Complete Retry Decorator (`retry.py`):**\n```python\nimport time\nimport random\nfrom typing import Callable, Any, Type, Tuple\nfrom functools import wraps\n\ndef retry_with_backoff(\n    max_retries: int = 3,\n    base_delay: float = 1.0,\n    max_delay: float = 30.0,\n    jitter: bool = True,\n    retry_on_exceptions: Tuple[Type[Exception], ...] = (Exception,)\n):\n    \"\"\"\n    Decorator that retries a function with exponential backoff and jitter.\n    \n    Args:\n        max_retries: Maximum number of retry attempts (total calls = max_retries + 1)\n        base_delay: Base delay in seconds for exponential backoff (e.g., 1.0 for 1s, 2s, 4s...)\n        max_delay: Maximum delay between retries in seconds\n        jitter: If True, add random jitter to avoid thundering herd\n        retry_on_exceptions: Tuple of exception types to retry on (others will propagate immediately)\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @wraps(func)\n        def wrapper(*args, **kwargs) -> Any:\n            retries = 0\n            while True:\n                try:\n                    return func(*args, **kwargs)\n                except retry_on_exceptions as e:\n                    retries += 1\n                    if retries > max_retries:\n                        raise  # Re-raise the last exception after exhausting retries\n                    \n                    # Calculate delay with exponential backoff\n                    delay = min(base_delay * (2 ** (retries - 1)), max_delay)\n                    \n                    # Add jitter (randomize between 0.5*delay and 1.5*delay)\n                    if jitter:\n                        delay = delay * (0.5 + random.random())\n                    \n                    # Wait before retrying\n                    time.sleep(delay)\n        return wrapper\n    return decorator\n```\n\n**Mock Provider for Testing (`providers/mock/provider.py`):**\n```python\nfrom typing import Dict, Optional\nfrom ..base import BaseProvider, Resource\n\nclass MockProvider(BaseProvider):\n    \"\"\"Mock provider that stores resources in memory for testing.\"\"\"\n    \n    def __init__(self, config: dict):\n        self.config = config\n        self.resources: Dict[str, Resource] = {}  # resource_id -> Resource\n        \n    def validate_credentials(self, config: dict) -> bool:\n        return True  # Mock always validates\n    \n    def create(self, resource: Resource) -> Resource:\n        # Generate a mock ID\n        resource.attributes[\"id\"] = f\"mock-{resource.type}-{resource.name}\"\n        resource_id = resource.attributes[\"id\"]\n        \n        # Store in memory\n        self.resources[resource_id] = resource\n        return resource\n    \n    def read(self, resource_id: str, resource_type: str) -> Optional[Resource]:\n        return self.resources.get(resource_id)\n    \n    def update(self, resource_id: str, resource: Resource) -> Resource:\n        if resource_id not in self.resources:\n            raise ValueError(f\"Resource {resource_id} not found\")\n        \n        # Update attributes\n        current = self.resources[resource_id]\n        current.attributes.update(resource.attributes)\n        return current\n    \n    def delete(self, resource_id: str, resource_type: str) -> bool:\n        if resource_id in self.resources:\n            del self.resources[resource_id]\n            return True\n        return True  # Idempotent: deleting non-existent is success\n```\n\n#### D. Core Logic Skeleton Code\n\n**BaseProvider Abstract Class (`providers/base.py`):**\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import Optional, Dict, Any\nfrom dataclasses import dataclass\nfrom ..data_model import Resource  # Assuming Resource is defined elsewhere\n\n@dataclass\nclass ProviderConfig:\n    provider_type: str  # e.g., \"aws\", \"azure\"\n    config: Dict[str, Any]  # provider-specific configuration\n\nclass BaseProvider(ABC):\n    \"\"\"Abstract base class that all cloud providers must implement.\"\"\"\n    \n    @abstractmethod\n    def validate_credentials(self, config: dict) -> bool:\n        \"\"\"\n        Validate that the provider configuration is correct.\n        \n        Returns:\n            True if credentials are valid, raises an exception otherwise.\n        \"\"\"\n        pass\n    \n    @abstractmethod\n    def create(self, resource: Resource) -> Resource:\n        \"\"\"\n        Create a new resource in the cloud.\n        \n        Args:\n            resource: Resource object with desired attributes.\n            \n        Returns:\n            Resource object with actual created attributes (including ID).\n            \n        Raises:\n            ProviderError: If creation fails permanently.\n        \"\"\"\n        pass\n    \n    @abstractmethod\n    def read(self, resource_id: str, resource_type: str) -> Optional[Resource]:\n        \"\"\"\n        Read the current state of a resource from the cloud.\n        \n        Args:\n            resource_id: Unique identifier of the resource in the cloud.\n            resource_type: Type of the resource (e.g., 'aws_instance').\n            \n        Returns:\n            Resource object if found, None if the resource does not exist.\n        \"\"\"\n        pass\n    \n    @abstractmethod\n    def update(self, resource_id: str, resource: Resource) -> Resource:\n        \"\"\"\n        Update an existing resource in the cloud.\n        \n        Args:\n            resource_id: Unique identifier of the resource to update.\n            resource: Resource object with desired attributes.\n            \n        Returns:\n            Updated Resource object with actual attributes.\n        \"\"\"\n        pass\n    \n    @abstractmethod\n    def delete(self, resource_id: str, resource_type: str) -> bool:\n        \"\"\"\n        Delete a resource from the cloud.\n        \n        Args:\n            resource_id: Unique identifier of the resource to delete.\n            resource_type: Type of the resource.\n            \n        Returns:\n            True if deletion succeeded or resource was already absent.\n            False on unrecoverable failure.\n        \"\"\"\n        pass\n```\n\n**Executor Class (`executor.py`):**\n```python\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom .retry import retry_with_backoff\nfrom .data_model import PlanAction, ActionType, Resource\nfrom .providers.base import BaseProvider\n\n@dataclass\nclass ApplyResult:\n    resource_address: str\n    success: bool\n    new_state: Optional[Resource]\n    error: Optional[str] = None\n    retries: int = 0\n\nclass Executor:\n    \"\"\"Orchestrates the application of an execution plan using providers.\"\"\"\n    \n    def __init__(self, max_concurrency: int = 1):\n        self.max_concurrency = max_concurrency\n        self._state_snapshot: Dict[str, Resource] = {}  # In-memory state during apply\n        \n    def apply_plan(\n        self,\n        plan: Dict[str, PlanAction],\n        providers: Dict[str, BaseProvider],\n        state_before: Dict[str, Resource]\n    ) -> Dict[str, ApplyResult]:\n        \"\"\"\n        Apply the execution plan to reach desired infrastructure state.\n        \n        Args:\n            plan: Dictionary mapping resource addresses to PlanAction objects.\n                 Assumed to be topologically sorted by the Planner.\n            providers: Dictionary mapping provider type strings to BaseProvider instances.\n            state_before: The state as it was before apply (from state file).\n            \n        Returns:\n            Dictionary mapping resource addresses to ApplyResult objects.\n        \"\"\"\n        results = {}\n        # TODO 1: Initialize in-memory state snapshot with state_before\n        # TODO 2: Iterate through plan items in order (already sorted by dependencies)\n        # TODO 3: For each PlanAction, extract provider type from resource.type\n        # TODO 4: Get the appropriate provider from providers dictionary\n        # TODO 5: Call _execute_action(action, provider)\n        # TODO 6: If action succeeded, update in-memory state snapshot with new_state\n        # TODO 7: Store result in results dictionary\n        # TODO 8: If any action failed critically, consider stopping early (optional)\n        # TODO 9: Return results dictionary\n        return results\n    \n    def _execute_action(\n        self,\n        action: PlanAction,\n        provider: BaseProvider\n    ) -> ApplyResult:\n        \"\"\"\n        Execute a single PlanAction with retry logic and error handling.\n        \n        Args:\n            action: The PlanAction to execute.\n            provider: The provider instance to use.\n            \n        Returns:\n            ApplyResult indicating success/failure.\n        \"\"\"\n        resource_address = f\"{action.resource.type}.{action.resource.name}\"\n        \n        @retry_with_backoff(max_retries=3, base_delay=1.0)\n        def _call_with_retry():\n            # TODO 1: Based on action.action_type, call appropriate provider method\n            #   - CREATE: provider.create(action.resource)\n            #   - UPDATE: provider.read() then provider.update()\n            #   - DELETE: provider.delete()\n            #   - NOOP: return existing state (from prior_state or read)\n            # TODO 2: For CREATE and UPDATE, call provider.read() after to refresh state\n            # TODO 3: Return the resulting Resource (or None for DELETE)\n            pass\n        \n        try:\n            # TODO 4: Call _call_with_retry() and capture result\n            # TODO 5: Return ApplyResult with success=True and new_state\n            pass\n        except Exception as e:\n            # TODO 6: Handle specific exception types:\n            #   - Transient errors (network, rate limit): should have been retried\n            #   - Permanent errors: capture in ApplyResult with success=False\n            # TODO 7: Return ApplyResult with success=False and error message\n            pass\n```\n\n**Sample AWS Provider Skeleton (`providers/aws/provider.py`):**\n```python\nimport boto3\nfrom typing import Optional, Dict, Any\nfrom ..base import BaseProvider\nfrom ...data_model import Resource\n\nclass AWSProvider(BaseProvider):\n    \"\"\"AWS cloud provider implementation.\"\"\"\n    \n    def __init__(self, config: dict):\n        self.config = config\n        self.session = boto3.Session(\n            aws_access_key_id=config.get(\"access_key\"),\n            aws_secret_access_key=config.get(\"secret_key\"),\n            region_name=config.get(\"region\", \"us-east-1\")\n        )\n        # TODO: Initialize service clients (ec2, s3, etc.) as needed\n    \n    def validate_credentials(self, config: dict) -> bool:\n        # TODO 1: Attempt a lightweight API call (e.g., sts:GetCallerIdentity)\n        # TODO 2: Return True if successful, raise exception with details if not\n        pass\n    \n    def create(self, resource: Resource) -> Resource:\n        resource_type = resource.type\n        # TODO 1: Dispatch to appropriate resource-specific create method\n        #   Example: if resource_type == \"aws_instance\": return self._create_ec2_instance(resource)\n        # TODO 2: Extract parameters from resource.attributes\n        # TODO 3: Call AWS API (e.g., ec2.run_instances)\n        # TODO 4: Extract cloud-assigned ID from response\n        # TODO 5: Return updated Resource with ID and other attributes\n        pass\n    \n    def read(self, resource_id: str, resource_type: str) -> Optional[Resource]:\n        # TODO 1: Parse resource_type to determine AWS service and method\n        # TODO 2: Call appropriate describe/GET API\n        # TODO 3: If resource exists, map API response to Resource attributes\n        # TODO 4: If resource not found (404/InvalidParameter), return None\n        pass\n    \n    # Similar skeletons for update() and delete()\n```\n\n#### E. Language-Specific Hints\n\n- **Abstract Base Classes**: Use Python's `abc` module to define `BaseProvider`. Decorate methods with `@abstractmethod` to enforce implementation in subclasses.\n- **Error Handling**: Define a custom exception hierarchy: `ProviderError` as base, with subclasses like `TransientProviderError` (retryable) and `PermanentProviderError`.\n- **Type Hints**: Use `typing` module extensively for better IDE support and documentation (e.g., `Optional[Resource]`, `Dict[str, BaseProvider]`).\n- **Configuration Management**: Use `pydantic` for validation if advanced configuration schemas are needed, but simple `dict` is acceptable for the learning project.\n- **Dependency Injection**: Pass provider instances to the Executor rather than having it instantiate them. This makes testing easier (you can pass mock providers).\n\n#### F. Milestone Checkpoint\n\nTo verify Milestone 4 (Provider Abstraction & Executor) is complete:\n\n1. **Create a test configuration** with a simple resource (e.g., a mock \"file\" resource that creates a local file).\n2. **Run the plan command**: `python cli.py plan config.yaml`. It should show a plan to create the resource.\n3. **Apply the plan**: `python cli.py apply config.yaml --auto-approve`. The console should output:\n   ```\n   Applying plan...\n   file.example: Creating... (success after 0.2s)\n   Apply complete! Resources: 1 added, 0 changed, 0 destroyed.\n   ```\n4. **Verify the resource was created**: Check that the mock resource (e.g., a file on disk) exists with the expected attributes.\n5. **Run plan again**: Should show \"No changes\" because the state matches the configuration.\n6. **Test error handling**: Temporarily break the provider's credentials or network connection and verify that appropriate error messages are shown (not stack traces).\n\n**Expected Behavior**: The Executor calls provider methods in dependency order, respects retry logic, updates the state file upon successful completion, and provides clear feedback about what succeeded or failed.\n\n\n## Interactions and Data Flow\n\n> **Milestone(s):** 3, 4\n\nThis section describes the orchestration between components for the two primary workflows in the IaC engine: generating an execution plan (`plan`) and applying that plan to actual infrastructure (`apply`). Understanding these workflows is critical because they represent the main value proposition of the system—transforming declarative configuration into safe, ordered operations on cloud resources.\n\nThe mental model for these workflows is that of a **construction project management office**. The `plan` command is the project planning phase: architects review blueprints, check what's already built, and create a detailed work order. The `apply` command is the construction phase: site managers lock the site, hand work orders to specialized crews (providers), and update the building log as work completes.\n\n### Sequence: The Planning Workflow\n\nThe `plan` workflow answers the question: \"What changes would be made if I applied this configuration right now?\" It performs a **dry-run analysis** without modifying any infrastructure, which is crucial for safety and review. This workflow combines the **Parser**, **State Manager**, and **Planner** components to produce a human-readable diff of proposed changes.\n\n![Sequence Diagram: Plan Command](./diagrams/plan-sequence.svg)\n\nThe workflow begins when a user runs `plan_command(config_path, state_path, var_file)` from the CLI. Here's the step-by-step sequence:\n\n1. **Configuration Loading and Parsing**\n   - The CLI calls `process_configuration(root_file, variable_files, cli_vars)`, which orchestrates the Parser component.\n   - Internally, `parse_file` reads the root HCL/YAML file and produces a raw abstract syntax tree (AST).\n   - `resolve_variables` walks the AST, replacing `${var.name}` references with actual values from variable files and CLI arguments.\n   - For each module block found, `load_module` is called recursively to load and resolve the module's resources, flattening them into a single list.\n   - The final output is a normalized `List[Resource]` representing the **desired state**—what the infrastructure should look like.\n\n2. **Current State Loading**\n   - The CLI calls `read_state(state_path)` on the State Manager.\n   - This loads the persistent state file from disk (or remote backend) into a `Dict[str, StateRecord]` dictionary keyed by resource address.\n   - If no state file exists, an empty dictionary is returned, representing a \"clean slate\" with no existing infrastructure.\n\n3. **Dependency Graph Construction**\n   - The CLI passes both the desired resources and current state to the Planner via `build_graph(resources, state_records)`.\n   - The algorithm extracts dependencies from two sources:\n     - **Explicit dependencies**: From `depends_on` attributes in resource configurations.\n     - **Implicit dependencies**: By analyzing attribute references (e.g., when Resource B's `vpc_id` references `aws_vpc.main.id`, a dependency edge is created from B → A).\n   - The function returns a `Dict[str, DependencyGraphNode]` where each node contains `depends_on` and `required_by` lists.\n   - `validate_acyclic(graph)` ensures no circular dependencies exist (which would make topological sorting impossible).\n\n4. **Topological Sorting and Plan Generation**\n   - If the graph is acyclic, `topological_sort(graph)` produces a linear ordering where dependencies come before dependents.\n   - This sorted list is passed to `generate_plan(sorted_resources, desired_resources, current_state)`.\n   - For each resource address, the function compares the desired `Resource` against the current `StateRecord` (if any) to determine the appropriate `ActionType`:\n     - **CREATE**: No state record exists for this resource.\n     - **UPDATE**: State record exists but attributes differ (and update is supported).\n     - **DELETE**: State record exists but no corresponding desired resource (resource was removed from config).\n     - **NOOP**: State matches desired configuration exactly.\n   - The function assembles these into a `Dict[str, PlanAction]`—the **execution plan**.\n\n5. **Plan Presentation**\n   - The CLI formats the plan for human consumption, typically showing:\n     - Summary counts of creates, updates, deletes.\n     - Detailed diff for each resource showing attribute changes.\n     - Visual indication of dependency order.\n   - The plan is printed to stdout but **not persisted**—it's ephemeral and tied to the current state snapshot.\n\n> **Critical Insight:** The plan is a **point-in-time snapshot** based on the state file at the moment of reading. If the state changes between planning and applying (e.g., another engineer applies changes), the plan becomes stale and potentially dangerous to execute. This is why the `apply` workflow includes locking.\n\n**Common Scenario Walkthrough:** Consider adding a new web server behind an existing load balancer. The configuration defines an `aws_instance.web` (new) and an `aws_lb_listener.http` (modified to point to the new instance). The planning workflow would:\n1. Parse both resources, noting that the listener references the instance's ID via interpolation.\n2. Load current state showing the listener exists but the instance doesn't.\n3. Build a graph with edge: listener → instance (due to the ID reference).\n4. Topologically sort: [instance, listener] (instance must be created first so its ID is available).\n5. Generate plan: CREATE for instance, UPDATE for listener.\n6. Display: \"Plan: 1 to add, 1 to change, 0 to destroy.\"\n\n### Sequence: The Apply Workflow\n\nThe `apply` workflow executes the planned changes against real infrastructure in a safe, ordered manner. This is the **moment of truth** where the IaC engine interacts with cloud APIs to create, modify, or destroy resources. It coordinates the **State Manager**, **Executor**, and **Provider** components while maintaining safety through locking and idempotent operations.\n\n![Sequence Diagram: Apply Command](./diagrams/apply-sequence.svg)\n\nThe workflow begins when a user runs `apply_command(config_path, state_path, var_file, auto_approve)`. If `auto_approve` is false, the system first displays the plan and prompts for confirmation. Once approved:\n\n1. **State Lock Acquisition**\n   - Before any changes, `acquire_lock(lock_path)` is called to obtain an exclusive lock on the state.\n   - This implements **pessimistic concurrency control**: only one apply operation can proceed at a time.\n   - The lock includes a heartbeat mechanism to detect and release stale locks from crashed processes.\n   - If locking fails (e.g., timeout or another process holds the lock), the apply aborts immediately.\n\n2. **Fresh State Read and Plan Regeneration**\n   - With the lock held, `read_state(state_path)` loads the **current state** again.\n   - The configuration is reparsed (same as planning phase) to get fresh desired resources.\n   - `generate_plan` is called again with the freshly loaded state and desired resources.\n   - This **re-planning** ensures the execution plan reflects the absolute latest state, guarding against the \"stale plan\" problem.\n   - If the regenerated plan differs significantly from the originally shown plan (beyond a threshold), some systems ask for reconfirmation.\n\n3. **Plan Execution Orchestration**\n   - The plan and provider configurations are passed to `apply_plan(plan, providers, max_concurrency)`.\n   - The Executor processes resources in **topological order** (dependencies before dependents), but within independent branches, it can execute concurrently up to `max_concurrency`.\n   - For each `PlanAction`, the Executor:\n     1. Identifies the appropriate provider based on resource type (e.g., `aws_instance` → AWS provider).\n     2. Calls `_execute_action(action, provider)` which delegates to the provider's CRUD methods:\n        - **CREATE**: `provider.create(resource)` → returns actual resource with cloud-assigned IDs.\n        - **UPDATE**: `provider.update(resource_id, resource)` → returns updated resource.\n        - **DELETE**: `provider.delete(resource_id, resource_type)` → returns success/failure.\n     3. Implements **retry logic** with exponential backoff for transient failures (rate limits, network issues).\n     4. Handles **eventual consistency** by polling `provider.read()` after mutations until desired state is observed.\n   - Each action result is captured in an `ApplyResult` tracking success/failure, error messages, and retry counts.\n\n4. **State Persistence and Lock Release**\n   - As resources are successfully created/updated, their new attributes are recorded in an **in-memory state dictionary**.\n   - For deletions, the corresponding state records are removed.\n   - Once all actions complete (or fail), `write_state(state_path, state_data)` atomically writes the updated state to disk.\n   - The atomic write (via rename) ensures state file integrity even if the process crashes during write.\n   - Finally, `release_lock(lock_handle)` releases the lock, allowing other operations to proceed.\n\n5. **Result Reporting**\n   - The CLI summarizes the apply results: counts of successful/errored resources.\n   - For failures, it displays error details and may suggest remediation steps.\n   - The updated state file now reflects the actual infrastructure, making subsequent plans accurate.\n\n**Error Handling During Apply:** The Executor must handle partial failures gracefully. The strategy is **\"fail-fast within dependency chain, continue across independent chains\"**:\n\n- If a resource creation fails, all resources that depend on it cannot be created (marked as failed).\n- Resources in independent dependency chains continue processing.\n- The state is only updated for **successfully applied resources**—failed resources remain in their previous state.\n- This ensures the state file never reflects partially created dependency chains.\n\n**Common Scenario Walkthrough:** Continuing the web server example, the apply workflow would:\n1. Acquire lock on the state file.\n2. Re-read state and regenerate plan (same as before if no concurrent changes).\n3. Execute in order:\n   - **Instance creation**: Call AWS EC2 API, wait for instance to reach `running` state, capture `instance_id`.\n   - **Listener update**: Call AWS ELB API to update listener with the new instance's ID.\n4. Update state: Add instance record, update listener record with new attributes.\n5. Release lock and report: \"Apply complete! Resources: 1 added, 1 changed, 0 destroyed.\"\n\n### Key Data Flow Transformations\n\nThroughout these workflows, data transforms through specific stages:\n\n| Stage | Input | Processing | Output |\n|-------|-------|------------|--------|\n| **Parsing** | HCL/YAML files + variables | Lexical analysis, interpolation, module resolution | `List[Resource]` (desired state) |\n| **State Loading** | State file bytes | JSON deserialization, validation | `Dict[str, StateRecord]` (current state) |\n| **Diff Computation** | Desired resources + current state | Attribute-by-attribute comparison | `Dict[str, PlanAction]` (change set) |\n| **Graph Building** | Resources + state | Reference analysis, edge creation | `Dict[str, DependencyGraphNode]` (dependency DAG) |\n| **Plan Execution** | Plan + providers | CRUD API calls, retry logic | `Dict[str, ApplyResult]` (execution outcomes) |\n| **State Update** | Current state + execution results | Record addition/modification/removal | Updated `Dict[str, StateRecord]` (new state) |\n\n> **Architecture Insight:** The separation between planning and applying is not just organizational—it enables critical safety properties. The planning phase is **pure and deterministic** (no side effects), making it safe to run frequently for review. The applying phase is **transactional** with locking and atomic writes, ensuring consistency despite concurrent access and partial failures.\n\n### Common Integration Pitfalls\n\n⚠️ **Pitfall: Plan-Apply Race Conditions**\n- **Description:** User A runs `plan`, then user B applies changes before user A applies. User A's plan is now stale and applying it could overwrite B's changes.\n- **Why it's wrong:** The state has changed since the plan was generated, making the plan's assumptions invalid.\n- **Fix:** The `apply` workflow always re-reads state and re-plans after acquiring the lock, ensuring it acts on current reality.\n\n⚠️ **Pitfall: Locking Granularity Issues**\n- **Description:** Locking the entire state file for a small change (one resource) blocks all other operations unnecessarily.\n- **Why it's wrong:** Reduces system throughput and creates contention.\n- **Fix:** In advanced implementations, consider fine-grained locking per resource or dependency subgraph. For our educational context, whole-state locking is acceptable.\n\n⚠️ **Pitfall: Missing Rollback on Partial Failure**\n- **Description:** If the apply fails midway, some resources are created but others aren't, leaving infrastructure in an inconsistent state.\n- **Why it's wrong:** The user's configuration doesn't match reality, and dependencies may be broken.\n- **Fix:** Implement **reverse execution** for failed chains: if CREATE fails, delete any successfully created dependencies in reverse order. Alternatively, adopt a transactional approach where all changes are staged and committed atomically (complex for cloud APIs).\n\n### Implementation Guidance\n\nThis section provides concrete implementation patterns for orchestrating the workflows described above.\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Workflow Orchestration | Sequential function calls in CLI | State machine with async/await |\n| Concurrency Control | `threading.Thread` for parallel execution | `asyncio` with semaphores |\n| Retry Logic | Simple loop with `time.sleep()` | `tenacity` library with backoff strategies |\n| Lock Heartbeat | Separate daemon thread | `asyncio` background task |\n\n#### B. Recommended File/Module Structure\n\n```\niac_engine/\n├── cli/\n│   ├── __init__.py\n│   ├── commands.py           # plan_command, apply_command implementations\n│   └── formatters.py         # Pretty output for plans and results\n├── workflows/\n│   ├── __init__.py\n│   ├── planner.py            # Orchestrates planning workflow\n│   ├── applier.py            # Orchestrates apply workflow\n│   └── lock_manager.py       # Lock acquisition/release helpers\n├── parser/                   # Milestone 1\n├── state/                    # Milestone 2  \n├── planner/                  # Milestone 3\n├── providers/                # Milestone 4\n└── executor.py               # Executor component\n```\n\n#### C. Infrastructure Starter Code\n\n**Workflow Orchestration Helper:**\n\n```python\n# workflows/lock_manager.py\nimport threading\nimport time\nfrom pathlib import Path\nfrom typing import Optional\nfrom dataclasses import dataclass\nimport json\nimport os\n\n@dataclass\nclass LockHandle:\n    lock_path: Path\n    process_id: int\n    lock_id: str\n    heartbeat_thread: Optional[threading.Thread]\n    stop_event: threading.Event\n\nclass LockManager:\n    \"\"\"Helper for acquiring and releasing locks with heartbeat.\"\"\"\n    \n    @staticmethod\n    def acquire_lock(lock_path: Path, timeout_seconds: int = 30, \n                     heartbeat_interval: int = 10) -> LockHandle:\n        \"\"\"\n        Attempts to acquire an exclusive lock with stale detection.\n        \n        Args:\n            lock_path: Path to lock file\n            timeout_seconds: Maximum time to wait for lock\n            heartbeat_interval: How often to update lock timestamp\n            \n        Returns:\n            LockHandle if acquired, raises TimeoutError otherwise\n        \"\"\"\n        start_time = time.time()\n        lock_id = f\"{os.getpid()}-{int(time.time())}\"\n        \n        while time.time() - start_time < timeout_seconds:\n            try:\n                # Try to create lock file atomically\n                with open(lock_path, 'x') as f:\n                    lock_data = {\n                        \"process_id\": os.getpid(),\n                        \"lock_id\": lock_id,\n                        \"timestamp\": time.time(),\n                        \"heartbeat_interval\": heartbeat_interval\n                    }\n                    json.dump(lock_data, f)\n                \n                # Start heartbeat thread\n                stop_event = threading.Event()\n                heartbeat_thread = threading.Thread(\n                    target=LockManager._heartbeat_worker,\n                    args=(lock_path, lock_id, heartbeat_interval, stop_event),\n                    daemon=True\n                )\n                heartbeat_thread.start()\n                \n                return LockHandle(\n                    lock_path=lock_path,\n                    process_id=os.getpid(),\n                    lock_id=lock_id,\n                    heartbeat_thread=heartbeat_thread,\n                    stop_event=stop_event\n                )\n                \n            except FileExistsError:\n                # Lock exists, check if stale\n                try:\n                    with open(lock_path, 'r') as f:\n                        existing_lock = json.load(f)\n                    \n                    lock_age = time.time() - existing_lock[\"timestamp\"]\n                    max_age = existing_lock[\"heartbeat_interval\"] * 3\n                    \n                    if lock_age > max_age:\n                        # Stale lock, remove it and retry\n                        os.remove(lock_path)\n                        continue\n                        \n                except (json.JSONDecodeError, KeyError, IOError):\n                    # Corrupt lock file, remove it\n                    try:\n                        os.remove(lock_path)\n                    except OSError:\n                        pass\n                    continue\n                    \n            time.sleep(0.5)  # Brief pause before retry\n        \n        raise TimeoutError(f\"Could not acquire lock within {timeout_seconds} seconds\")\n    \n    @staticmethod\n    def _heartbeat_worker(lock_path: Path, lock_id: str, \n                         interval: int, stop_event: threading.Event):\n        \"\"\"Background thread that updates lock timestamp.\"\"\"\n        while not stop_event.is_set():\n            try:\n                with open(lock_path, 'r') as f:\n                    lock_data = json.load(f)\n                \n                # Only update if we still own the lock\n                if lock_data.get(\"lock_id\") == lock_id:\n                    lock_data[\"timestamp\"] = time.time()\n                    with open(lock_path, 'w') as f:\n                        json.dump(lock_data, f)\n            except (IOError, json.JSONDecodeError):\n                pass\n            \n            stop_event.wait(interval)\n    \n    @staticmethod\n    def release_lock(handle: LockHandle):\n        \"\"\"Releases a previously acquired lock.\"\"\"\n        handle.stop_event.set()\n        if handle.heartbeat_thread:\n            handle.heartbeat_thread.join(timeout=5)\n        \n        try:\n            # Verify we still own the lock before removing\n            with open(handle.lock_path, 'r') as f:\n                lock_data = json.load(f)\n            \n            if lock_data.get(\"lock_id\") == handle.lock_id:\n                os.remove(handle.lock_path)\n        except (IOError, json.JSONDecodeError):\n            # Lock file may already be gone\n            pass\n```\n\n#### D. Core Logic Skeleton Code\n\n**Plan Command Implementation:**\n\n```python\n# cli/commands.py\nfrom pathlib import Path\nfrom typing import Optional, Dict, List\nfrom iac_engine.parser import process_configuration\nfrom iac_engine.state import read_state, compute_diff\nfrom iac_engine.planner import build_graph, validate_acyclic, topological_sort, generate_plan\nfrom iac_engine.workflows.planner import generate_plan_summary\n\ndef plan_command(config_path: Path, state_path: Path, \n                 var_file: Optional[Path] = None) -> None:\n    \"\"\"\n    CLI command to generate and show an execution plan.\n    \n    Args:\n        config_path: Path to root configuration file\n        state_path: Path to state file\n        var_file: Optional path to variable definitions file\n    \"\"\"\n    # TODO 1: Collect variable values from var_file and environment\n    #   - Parse var_file if provided (could be JSON, YAML, or .tfvars)\n    #   - Also check environment variables with TF_VAR_ prefix\n    #   - Combine into a single variables dictionary\n    \n    # TODO 2: Parse configuration with variables\n    #   - Call process_configuration(root_file, variable_files, cli_vars)\n    #   - This returns List[Resource] representing desired state\n    \n    # TODO 3: Load current state\n    #   - Call read_state(state_path)\n    #   - Returns Dict[str, StateRecord] (empty dict if file doesn't exist)\n    \n    # TODO 4: Build dependency graph\n    #   - Call build_graph(desired_resources, current_state)\n    #   - Call validate_acyclic(graph) - raise error if cycles detected\n    \n    # TODO 5: Generate execution plan\n    #   - Call topological_sort(graph) to get execution order\n    #   - Convert desired_resources to dict keyed by address\n    #   - Call generate_plan(sorted_order, desired_dict, current_state)\n    \n    # TODO 6: Display plan to user\n    #   - Call generate_plan_summary(plan_dict) for human-readable output\n    #   - Show counts: + add, ~ change, - destroy\n    #   - Show detailed diff for each resource\n    #   - Color code output (green for add, yellow for change, red for destroy)\n    \n    pass\n```\n\n**Apply Command Implementation:**\n\n```python\n# cli/commands.py\nfrom iac_engine.workflows.lock_manager import LockManager, LockHandle\nfrom iac_engine.executor import apply_plan\nfrom iac_engine.state import write_state\nfrom iac_engine.workflows.planner import confirm_plan\n\ndef apply_command(config_path: Path, state_path: Path,\n                  var_file: Optional[Path] = None,\n                  auto_approve: bool = False) -> None:\n    \"\"\"\n    CLI command to apply changes to reach desired state.\n    \n    Args:\n        config_path: Path to root configuration file\n        state_path: Path to state file  \n        var_file: Optional path to variable definitions file\n        auto_approve: Skip confirmation prompt\n    \"\"\"\n    lock_handle: Optional[LockHandle] = None\n    \n    try:\n        # TODO 1: Generate plan (same as plan_command)\n        #   - Parse config, load state, build graph, generate plan\n        #   - This plan is for display/confirmation only\n        \n        # TODO 2: Show plan and request confirmation\n        #   - Unless auto_approve is True, display plan and ask \"Do you want to perform these actions?\"\n        #   - Use confirm_plan(plan_dict) helper\n        #   - If user rejects, exit immediately\n        \n        # TODO 3: Acquire state lock\n        #   - Determine lock file path (typically state_path + \".lock\")\n        #   - Call LockManager.acquire_lock(lock_path, timeout_seconds=30)\n        #   - Store returned LockHandle\n        \n        # TODO 4: Re-plan with fresh state (critical!)\n        #   - With lock held, re-read state using read_state(state_path)\n        #   - Re-parse configuration (variables might have changed)\n        #   - Re-generate plan with fresh state\n        #   - Compare with original plan - if significant differences, warn user\n        \n        # TODO 5: Execute plan\n        #   - Load provider configurations from parsed config\n        #   - Initialize provider instances (AWS, GCP, etc.)\n        #   - Call apply_plan(plan, providers, max_concurrency=5)\n        #   - This returns Dict[str, ApplyResult] for each resource\n        \n        # TODO 6: Update state with successful changes\n        #   - Start with copy of original state\n        #   - For each successful CREATE/UPDATE: add/update StateRecord\n        #   - For each successful DELETE: remove StateRecord\n        #   - For failed actions: leave state unchanged (resource stays as-is)\n        #   - Call write_state(state_path, updated_state) atomically\n        \n        # TODO 7: Release lock\n        #   - Call LockManager.release_lock(lock_handle)\n        \n        # TODO 8: Report results\n        #   - Show summary: X created, Y updated, Z destroyed, W failed\n        #   - For failures: show error messages and suggest fixes\n        \n    except Exception as e:\n        # TODO 9: Cleanup on error\n        #   - If lock_handle exists, release it\n        #   - Print error message with stack trace in debug mode\n        #   - Exit with non-zero code\n        \n        pass\n```\n\n**Executor Core Logic:**\n\n```python\n# executor.py\nimport concurrent.futures\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nimport time\nimport random\n\n@dataclass\nclass ApplyResult:\n    resource_address: str\n    success: bool\n    new_state: Optional[Resource]\n    error: Optional[str]\n    retries: int\n\nclass Executor:\n    \"\"\"Orchestrates plan execution using providers.\"\"\"\n    \n    def __init__(self, max_concurrency: int = 5):\n        self.max_concurrency = max_concurrency\n        \n    def apply_plan(self, plan: Dict[str, PlanAction], \n                   providers: Dict[str, BaseProvider],\n                   ) -> Dict[str, ApplyResult]:\n        \"\"\"\n        Applies execution plan using providers.\n        \n        Args:\n            plan: Dictionary of PlanActions keyed by resource address\n            providers: Dictionary mapping provider types to provider instances\n            \n        Returns:\n            Dictionary of ApplyResults keyed by resource address\n        \"\"\"\n        results = {}\n        \n        # TODO 1: Group actions by dependency level\n        #   - Create a dependency graph from the plan\n        #   - Group resources that can be executed in parallel (same dependency depth)\n        \n        # TODO 2: Process groups sequentially, resources within group in parallel\n        #   - For each dependency level (in topological order):\n        #   - Create ThreadPoolExecutor with max_concurrency\n        #   - Submit _execute_single_action for each resource in level\n        #   - Wait for all in level to complete before proceeding to next\n        \n        # TODO 3: Handle resource execution with retries\n        #   - Each _execute_single_action should:\n        #     1. Identify correct provider from resource type\n        #     2. For CREATE: call provider.create() with exponential backoff\n        #     3. For UPDATE: call provider.update() with exponential backoff  \n        #     4. For DELETE: call provider.delete() with exponential backoff\n        #     5. Capture result in ApplyResult structure\n        \n        # TODO 4: Propagate failures to dependents\n        #   - If a resource fails, mark all its dependents as \"failed due to dependency\"\n        #   - Skip execution for those dependents\n        \n        # TODO 5: Collect and return results\n        \n        return results\n    \n    def _execute_single_action(self, action: PlanAction, \n                               provider: BaseProvider) -> ApplyResult:\n        \"\"\"Internal method to execute single PlanAction with retry logic.\"\"\"\n        # TODO 1: Implement exponential backoff with jitter\n        #   - Base delay: 1 second, multiplier: 2, max delay: 30 seconds\n        #   - Add random jitter (±10%) to avoid thundering herd\n        \n        # TODO 2: For CREATE actions:\n        #   - Call provider.create(action.resource)\n        #   - If successful, return ApplyResult with new_state from provider\n        #   - If rate limited (429), wait and retry with backoff\n        #   - If other error, mark as failed after max retries\n        \n        # TODO 3: For UPDATE actions:\n        #   - Call provider.update(action.prior_state.resource_id, action.resource)\n        #   - Handle eventual consistency: read after update until attributes match\n        \n        # TODO 4: For DELETE actions:\n        #   - Call provider.delete(action.prior_state.resource_id, action.resource.type)\n        #   - Verify deletion by reading until resource not found\n        \n        # TODO 5: Track retry count and include in ApplyResult\n        \n        return ApplyResult(\n            resource_address=get_resource_address(action.resource),\n            success=False,\n            new_state=None,\n            error=\"Not implemented\",\n            retries=0\n        )\n```\n\n#### E. Language-Specific Hints\n\n- **Concurrent Execution:** Use `concurrent.futures.ThreadPoolExecutor` for parallel execution within dependency levels. Remember that I/O-bound operations (API calls) benefit from threading in Python despite the GIL.\n- **Atomic Writes:** Implement `write_atomic_json` using `tempfile.NamedTemporaryFile` with `delete=False`, writing to the temp file, then `os.replace()` to atomically replace the target file.\n- **Retry Logic:** Consider using the `tenacity` library for robust retry patterns: `@retry(stop=stop_after_attempt(5), wait=wait_exponential(multiplier=1, min=1, max=30))`.\n- **Provider Loading:** Use Python's `importlib` to dynamically load provider modules based on configuration: `importlib.import_module(f\"providers.{provider_type}\")`.\n\n#### F. Milestone Checkpoint\n\nAfter implementing both workflows, verify with this test scenario:\n\n1. **Setup test configuration:**\n   ```hcl\n   # test.tf\n   resource \"aws_vpc\" \"main\" {\n     cidr_block = \"10.0.0.0/16\"\n   }\n   \n   resource \"aws_subnet\" \"example\" {\n     vpc_id = aws_vpc.main.id\n     cidr_block = \"10.0.1.0/24\"\n   }\n   ```\n\n2. **Run planning workflow:**\n   ```bash\n   python -m iac_engine.cli plan test.tf --state state.json\n   ```\n   **Expected:** Plan shows 2 resources to create, with subnet depending on VPC.\n\n3. **Run apply workflow (with mock provider):**\n   ```bash\n   python -m iac_engine.cli apply test.tf --state state.json --auto-approve\n   ```\n   **Expected:** Resources created in correct order, state file updated with resource IDs.\n\n4. **Verify state:**\n   ```bash\n   cat state.json\n   ```\n   **Expected:** JSON file containing both resources with mock IDs and attributes.\n\n**Signs of problems:**\n- \"Cycle detected\" error when no cycles exist → Dependency extraction is buggy.\n- Resources created in wrong order → Topological sort is incorrect.\n- State file empty after apply → Atomic write failed or exceptions occurred.\n- Lock never released → Heartbeat thread not stopping properly.\n\n#### G. Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Plan shows no changes when changes exist | State diff logic buggy | Add debug logging to `compute_diff`, compare attribute dictionaries | Ensure diff compares all attributes, not just top-level |\n| Apply hangs forever | Deadlock in dependency chain or stuck provider | Check which resource is currently executing, provider logs | Implement timeouts for provider operations |\n| State file corrupted after crash | Partial write during crash | Check for `.tmp` files near state file | Ensure `write_atomic_json` uses temp file + rename |\n| \"Lock already held\" when no other process running | Stale lock file from crashed process | Check lock file timestamp and process ID | Implement stale lock detection in `acquire_lock` |\n| Resources created but dependencies broken | Execution order incorrect despite correct plan | Log dependency graph and execution order | Verify topological sort respects all edges |\n| Rate limiting errors even with retries | Retry logic too aggressive | Check retry delay values and jitter | Increase initial delay, add jitter, respect Retry-After headers |\n\n\n## Error Handling and Edge Cases\n\n> **Milestone(s):** 2, 3, 4\n\nA robust Infrastructure as Code engine must anticipate and gracefully handle failures that can occur at every stage of its operation—from parsing invalid configuration to dealing with unreliable cloud APIs. Unlike traditional applications where errors often stem from internal logic bugs, an IaC engine operates in a **distributed, eventually consistent, and adversarial environment** where external systems can fail independently, network connections can drop, and users can modify infrastructure outside the IaC workflow. This section provides a systematic framework for categorizing these failures and implementing appropriate recovery strategies, ensuring the system remains predictable and safe even when things go wrong.\n\n### Mental Model: The Fault-Tolerant Construction Site\n\nImagine our construction site from earlier analogies, but now we must account for real-world complications:\n- **Bad Blueprints:** The architect's drawings contain contradictory instructions (configuration errors).\n- **Missing Materials:** Some building materials are out of stock (provider API failures).\n- **Weather Delays:** Sudden rain stops work temporarily (transient network issues).\n- **Vandals:** Someone modifies the building overnight without telling the site manager (external drift).\n- **Partial Collapse:** Halfway through rebuilding a wall, the scaffolding collapses (partial apply failure).\n\nThe site manager (our IaC engine) needs procedures for each scenario: rejecting bad blueprints, waiting for materials, rescheduling delayed work, detecting and reconciling unauthorized changes, and safely recovering from partial failures without making things worse.\n\n### Error Classification and Recovery Strategy\n\nErrors in an IaC system fall into distinct categories based on their source, persistence, and impact on system safety. Each category requires a different handling strategy:\n\n| Error Category | Detection Point | Common Causes | Recovery Strategy | Safety Impact |\n|----------------|-----------------|---------------|-------------------|---------------|\n| **Configuration Errors** | During parsing (`process_configuration`) | Invalid HCL syntax, undefined variable references, circular dependencies in modules, invalid resource schemas | Fail fast with clear error messages pointing to exact file and line. Never proceed with invalid config. | High - Prevents deploying invalid infrastructure. |\n| **State Errors** | During state read/write (`read_state`, `write_state`) | Corrupted JSON, partial writes from crashed process, stale lock files, version incompatibility | Automatic fallback to backup file, stale lock detection with forced break, human intervention for schema migration. | Critical - Corrupted state can lead to destructive actions. |\n| **Planning Errors** | During graph building (`build_graph`) or plan generation (`generate_plan`) | Circular dependencies, unresolvable attribute references, provider schema mismatches | Fail during planning with clear diagnostic output (e.g., \"Cycle detected: A → B → A\"). Never generate invalid plan. | High - Invalid plans could cause unsafe execution order. |\n| **Provider Errors (Transient)** | During CRUD operations in `_execute_action` | Network timeouts, rate limiting (429), temporary cloud service unavailability (5xx), eventual consistency delays | Exponential backoff with jitter, circuit breaker pattern, retry with increasing delays up to configured maximum. | Medium - May delay apply but preserves safety. |\n| **Provider Errors (Permanent)** | During CRUD operations or `validate_credentials` | Invalid credentials, insufficient permissions, unsupported resource configuration, quota exceeded | Fail fast with provider-specific error message. Roll back any in-progress changes in the current operation. | High - Continuing would waste resources and fail anyway. |\n| **Partial Apply Failures** | During `apply_plan` execution | Resource creation succeeds but dependent resource fails, external modification during apply, provider bug leaves resource in zombie state | Stop further execution (fail-fast), preserve intermediate state, provide clear error report with affected resources. | Critical - Leaves infrastructure in inconsistent state. |\n| **Concurrency Conflicts** | During `acquire_lock` or state read-modify-write | Another process modifying same state simultaneously, S3 eventual consistency returning stale state | Pessimistic locking with lease timeout, state checksum validation (optimistic concurrency), retry with fresh state read. | Critical - Could cause conflicting modifications. |\n\n> **Design Insight:** The safety principle of **\"fail safe\"** is paramount. When uncertain, the system should err on the side of doing nothing rather than risking destructive action. This is why configuration and planning errors cause immediate failure, while transient errors trigger retries rather than abandonment.\n\n#### Detailed Recovery Procedures\n\nFor each error category, we implement specific recovery logic:\n\n1. **Configuration Error Recovery**\n   - **Detection:** Syntax validation in `parse_file`, reference resolution in `resolve_variables`, cycle detection in module loading\n   - **Action:** Immediately raise a `ConfigurationError` with:\n     - File path and line number (if available)\n     - Specific error description\n     - Suggested fix when possible\n   - **State Preservation:** No state modification occurs\n\n2. **Transient Provider Error Recovery**\n   ```prose\n   Algorithm: Exponential Backoff with Jitter\n   1. Initialize attempt counter = 1, base_delay = 1 second, max_delay = 60 seconds\n   2. Execute the provider operation (create/read/update/delete)\n   3. If success: return result\n   4. If failure is transient (timeout, 429, 5xx):\n      a. Calculate delay = min(base_delay * 2^(attempt-1) + random_jitter, max_delay)\n      b. Wait for delay\n      c. Increment attempt counter\n      d. If attempts < max_attempts (default 5): goto step 2\n      e. Else: raise PermanentProviderError\n   5. If failure is permanent: raise immediately\n   ```\n\n3. **Partial Apply Failure Recovery**\n   - **Detection:** `_execute_action` returns error for a resource in the middle of plan execution\n   - **Action:** \n     1. Stop executing further actions (fail-fast)\n     2. Record current progress in a `partial_failure_state` snapshot\n     3. For all successfully applied resources, refresh their state from cloud\n     4. Write combined state (original succeeded + refreshed new states) to disk\n     5. Return detailed error report listing succeeded and failed resources\n   - **User Recovery Path:** User must fix underlying issue, then re-run `apply` (which will compute diff from the partially updated state)\n\n### Key Edge Cases and Mitigations\n\nBeyond straightforward error categories, several subtle edge cases can undermine the system's correctness if not properly addressed.\n\n#### Edge Case 1: Partial Apply Failures with Dependency Chains\n\n**Scenario:** Creating resource B depends on resource A. A creates successfully, but B fails. The infrastructure is now in an inconsistent state—A exists but B doesn't.\n\n**Mitigation Strategy:**\n- **Fail-Fast Stop:** Stop execution immediately when B fails, preventing creation of C, D, etc.\n- **State Refresh & Preservation:** Refresh A's actual state from the cloud (in case cloud defaults differ from config), then write state file containing A (with actual attributes) and B (as desired but uncreated). This creates an **intentional drift** recorded in state.\n- **Next Apply Safety:** When user re-runs `apply` after fixing B's issue, the planner will:\n  1. Compare desired state (A, B) against current state (A exists, B missing)\n  2. Generate `NOOP` for A (already exists with correct attributes)\n  3. Generate `CREATE` for B (still needs creation)\n  4. Execute only the missing B creation\n\n> **Design Insight:** The state file should always reflect **reality as known to the IaC engine**, not wishful thinking. Recording partial failures honestly enables safe recovery.\n\n#### Edge Case 2: External Resource Modification (State Drift)\n\n**Scenario:** A system administrator manually deletes a VM via cloud console that's managed by our IaC engine. The next `plan` should detect this drift and either recreate it or remove it from management.\n\n**Mitigation Strategy:**\n- **Refresh Before Plan:** The `plan_command` should optionally call `refresh_state` for all resources to detect external changes.\n- **Drift Detection Algorithm:**\n  1. Read desired state from configuration\n  2. Read recorded state from state file\n  3. For each resource, call provider's `read` method to get actual cloud state\n  4. Compare: \n     - If actual == recorded: `NOOP`\n     - If actual == desired but ≠ recorded: `UPDATE` state only (drift corrected externally)\n     - If actual ≠ desired and recorded == desired: `UPDATE` or `RECREATE` (external modification)\n     - If actual == null but recorded exists: `CREATE` (external deletion)\n     - If actual exists but recorded == null: `IMPORT` suggestion (external creation)\n- **User Notification:** Clearly distinguish between \"changes to reach desired state\" and \"drift detection\" in plan output.\n\n#### Edge Case 3: Zombie Resources (Created but Unrecorded)\n\n**Scenario:** During a `create` operation, the provider API returns success but then crashes before returning the full resource attributes. The state file never gets updated with the new resource's ID, creating a \"zombie\" resource that exists in cloud but isn't managed.\n\n**Mitigation Strategy:**\n- **Two-Phase Create:** Implement create operations as:\n  1. Call provider `create` with desired configuration\n  2. Immediately call provider `read` with the returned ID to get complete attributes\n  3. Only if both succeed, record the `read` result in state\n- **Orphan Detection:** Periodic cleanup job that:\n  1. Lists all resources in cloud for a given tag (e.g., `managed_by=our_iac`)\n  2. Cross-references with state file\n  3. Flags resources in cloud but not in state for manual review\n- **Transaction Boundary:** Treat the entire `_execute_action` for a `CREATE` as atomic—either both create and state update succeed, or we retry/rollback.\n\n#### Edge Case 4: Schema Evolution and Version Compatibility\n\n**Scenario:** After upgrading to a new version of a provider, resource attributes that were previously optional become required. Existing state files contain the old schema, causing validation errors.\n\n**Mitigation Strategy:**\n- **State Versioning:** Include a `schema_version` field in `StateRecord` and state file metadata.\n- **Migration Hooks:** Provider implementations can define migration functions that upgrade state from v1 → v2 → v3.\n- **Backward Compatibility:** When reading old state, apply migration before validation.\n- **Forward Safety:** Never automatically downgrade state; require explicit user action.\n\n#### Edge Case 5: Circular Dependencies with Implicit References\n\n**Scenario:** Resource A references attribute of Resource B, while Resource B references attribute of Resource A, creating a circular dependency that's not explicitly declared with `depends_on`.\n\n**Mitigation Strategy:**\n- **Static Analysis During Planning:** `build_graph` must detect both explicit (`depends_on`) and implicit (attribute reference) dependencies.\n- **Cycle Detection Algorithm:** Use depth-first search with temporary marking to detect cycles in combined dependency graph.\n- **Clear Error Messages:** When cycle detected, output the cycle path: \"A → B → A\" and highlight the problematic attribute references.\n- **Require Explicit Break:** Force user to redesign configuration to eliminate cycle (e.g., by using `depends_on` to control order, or restructuring resources).\n\n#### Edge Case 6: Provider API Eventually Consistency\n\n**Scenario:** After successfully calling `create`, an immediate `read` returns \"not found\" because the cloud provider's replication hasn't completed.\n\n**Mitigation Strategy:**\n- **Eventual Consistency Awareness:** After mutating operations, implement progressive polling:\n  1. Initial read (may fail with \"not found\")\n  2. Wait 1 second, retry read\n  3. Exponential backoff up to reasonable limit (e.g., 30 seconds for global resources)\n  4. If still not found after max wait, treat as failure (may need recreate)\n- **Resource-Specific Timeouts:** Different resource types have different propagation characteristics (e.g., global DNS vs. regional compute).\n\n#### Edge Case 7: Concurrent Modification by Multiple Engineers\n\n**Scenario:** Two engineers run `apply` simultaneously on the same infrastructure, both using shared remote state (e.g., S3).\n\n**Mitigation Strategy:**\n- **Pessimistic Locking:** `acquire_lock` creates a lock file with process ID, timestamp, and owner.\n- **Lock Heartbeat:** Background thread periodically updates lock timestamp while operation in progress.\n- **Stale Lock Detection:** If lock exists but heartbeat is older than timeout (e.g., 10 minutes), assume previous process crashed and allow breaking lock.\n- **State Checksum Validation:** Before writing updated state, verify that the state hasn't changed since we read it (optimistic concurrency as backup).\n\n#### Edge Case 8: Configuration with Count/For_Each Interpolation\n\n**Scenario:** `count = length(${var.items})` creates chicken-and-egg problem: need variable value to know how many resources, but variables may reference resource attributes.\n\n**Mitigation Strategy:**\n- **Multi-Pass Resolution:** Implement variable resolution in phases:\n  1. Resolve all non-resource-dependent variables\n  2. Create initial resource graph with unknown `count`\n  3. If `count` references unresolved value, error with \"cannot compute count before resources exist\"\n  4. Require `count` to use only variables, not resource attributes\n- **Alternative:** Support `for_each` with explicitly known collections rather than computed lengths.\n\n### ADR: Fail-Fast vs. Continue-on-Error for Partial Apply\n\n> **Decision: Fail-Fast on Partial Apply**\n> - **Context:** When applying a plan with multiple resources, some may fail while others succeed. We must decide whether to continue applying unrelated resources or stop immediately.\n> - **Options Considered:**\n>   1. **Fail-Fast:** Stop execution at first failure, preserve partial state, report error.\n>   2. **Continue-on-Error:** Skip failed resource, continue with others, aggregate all errors at end.\n>   3. **Dependency-Aware Continue:** Stop only if dependent resources will fail; continue with independent ones.\n> - **Decision:** Implement Fail-Fast strategy.\n> - **Rationale:** \n>   - **Safety First:** Continuing after unknown failure could compound problems (e.g., creating dependent resources that will fail anyway).\n>   - **Predictability:** Engineers get immediate feedback rather than discovering multiple failures buried in log.\n>   - **Simpler Recovery:** With fail-fast, the point of failure is clear and state reflects exactly what succeeded.\n>   - **Industry Standard:** Terraform and most production IaC tools use fail-fast for apply operations.\n> - **Consequences:**\n>   - Engineers must fix errors and re-run apply more frequently.\n>   - Requires careful dependency ordering to minimize cascading failures.\n>   - Partial state must be accurately preserved for safe resume.\n\n| Option | Pros | Cons | Why Not Chosen |\n|--------|------|------|----------------|\n| **Fail-Fast** | Safe, predictable, easier to debug, matches user expectations | May stop early for non-critical failures, requires re-running apply | **Chosen** - Safety outweighs convenience |\n| **Continue-on-Error** | Maximizes progress in single run, good for independent resources | Can create inconsistent state, harder to debug multiple failures | Risk of creating \"zombie\" resources with missing dependencies |\n| **Dependency-Aware** | Intelligent compromise, minimizes unnecessary stops | Complex to implement (need real-time dependency analysis), still risky | Added complexity not justified for educational project |\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Silent State Corruption**\n- **Description:** Writing state with `json.dump()` directly without atomic rename can result in partially written/corrupted state files if process crashes mid-write.\n- **Why Wrong:** Corrupted state file on next read causes parser errors or, worse, incorrect diffs leading to destructive actions.\n- **Fix:** Always use `write_atomic_json` which writes to temp file then atomically renames.\n\n⚠️ **Pitfall: Infinite Retry Loop**\n- **Description:** Implementing retry logic without maximum attempts or circuit breaker for permanent failures.\n- **Why Wrong:** System hangs forever retrying impossible operations (e.g., invalid credentials), wasting resources.\n- **Fix:** Implement exponential backoff with jitter AND maximum attempt limit (e.g., 5 attempts). Add circuit breaker pattern to fail fast after repeated failures.\n\n⚠️ **Pitfall: Ignoring Stale Locks**\n- **Description:** Checking only if lock file exists, not checking its timestamp/heartbeat.\n- **Why Wrong:** Crashed process leaves lock file forever, blocking all future operations.\n- **Fix:** Implement `acquire_lock` with stale detection (e.g., locks older than 10 minutes can be broken with warning).\n\n⚠️ **Pitfall: Not Refreshing State After Partial Apply**\n- **Description:** After resource A succeeds but B fails, writing state with A's *expected* attributes rather than *actual* attributes from cloud.\n- **Why Wrong:** Cloud may set default values different from config; next plan will see incorrect \"drift.\"\n- **Fix:** After each successful operation, immediately call `refresh_state` and use the returned actual state.\n\n⚠️ **Pitfall: Assuming Immediate Consistency**\n- **Description:** Calling `read` immediately after `create` and treating \"not found\" as failure.\n- **Why Wrong:** Cloud providers have eventual consistency; resource may exist but not be immediately queryable.\n- **Fix:** Implement progressive polling with exponential backoff for read-after-write operations.\n\n### Implementation Guidance\n\n#### A. Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Error Classification | Custom exception hierarchy with base `IaCError` | Structured error codes with machine-readable metadata |\n| Retry Logic | Manual retry loops with `time.sleep()` | `tenacity` library with decorators and multiple backoff strategies |\n| Circuit Breaker | Simple counter tracking consecutive failures | `pybreaker` library with half-open state automation |\n| State Validation | JSON Schema validation with `jsonschema` | Protocol Buffers with backward compatibility rules |\n\n#### B. Recommended File Structure\n\n```\niac-engine/\n  errors/                    # Error hierarchy and utilities\n    __init__.py\n    exceptions.py           # Base IaCError and all subclasses\n    recovery.py             # Retry, circuit breaker utilities\n  state/                    # State management\n    lock.py                # LockHandle and acquisition logic\n    file_operations.py     # write_atomic_json, read_json_with_backup\n  providers/               # Provider implementations\n    base.py               # BaseProvider with error handling mixins\n    retry_decorators.py   # @retry_with_backoff decorator\n```\n\n#### C. Infrastructure Starter Code\n\n**Complete Retry Decorator with Exponential Backoff:**\n```python\n# errors/recovery.py\nimport time\nimport random\nfrom typing import Callable, Any, Type, Tuple\nfrom functools import wraps\n\ndef retry_with_backoff(\n    max_attempts: int = 5,\n    base_delay: float = 1.0,\n    max_delay: float = 60.0,\n    jitter: bool = True,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n):\n    \"\"\"\n    Decorator that retries a function with exponential backoff and jitter.\n    \n    Args:\n        max_attempts: Maximum number of attempts before giving up\n        base_delay: Base delay in seconds (will be doubled each retry)\n        max_delay: Maximum delay in seconds\n        jitter: Whether to add random jitter to delays\n        exceptions: Tuple of exception types to catch and retry\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @wraps(func)\n        def wrapper(*args, **kwargs) -> Any:\n            attempt = 1\n            while attempt <= max_attempts:\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    # Check if this is a permanent error (not transient)\n                    if hasattr(e, 'permanent') and e.permanent:\n                        raise\n                    \n                    # Permanent errors for certain status codes\n                    if hasattr(e, 'status_code'):\n                        if e.status_code in [400, 401, 403, 404, 409]:\n                            raise  # Don't retry client errors\n                    \n                    if attempt == max_attempts:\n                        raise  # Max attempts reached\n                    \n                    # Calculate delay with exponential backoff\n                    delay = min(base_delay * (2 ** (attempt - 1)), max_delay)\n                    \n                    # Add jitter (0.5 to 1.5 multiplier)\n                    if jitter:\n                        delay = delay * (0.5 + random.random())\n                    \n                    time.sleep(delay)\n                    attempt += 1\n            \n            # Should never reach here\n            raise RuntimeError(\"Retry logic exhausted unexpectedly\")\n        \n        return wrapper\n    return decorator\n\n\nclass CircuitBreaker:\n    \"\"\"Simple circuit breaker pattern implementation.\"\"\"\n    \n    def __init__(self, failure_threshold: int = 5, reset_timeout: float = 60.0):\n        self.failure_threshold = failure_threshold\n        self.reset_timeout = reset_timeout\n        self.failure_count = 0\n        self.last_failure_time = 0\n        self.state = \"CLOSED\"  # CLOSED, OPEN, HALF_OPEN\n        \n    def call(self, func: Callable, *args, **kwargs) -> Any:\n        current_time = time.time()\n        \n        # Check if circuit breaker is OPEN and reset timeout has passed\n        if self.state == \"OPEN\" and current_time - self.last_failure_time > self.reset_timeout:\n            self.state = \"HALF_OPEN\"\n        \n        # Reject calls if circuit is OPEN\n        if self.state == \"OPEN\":\n            raise CircuitOpenError(\"Circuit breaker is OPEN\")\n        \n        try:\n            result = func(*args, **kwargs)\n            # Success - reset circuit if it was HALF_OPEN\n            if self.state == \"HALF_OPEN\":\n                self.state = \"CLOSED\"\n                self.failure_count = 0\n            return result\n        except Exception as e:\n            self.failure_count += 1\n            self.last_failure_time = current_time\n            \n            # Trip circuit if threshold reached\n            if self.failure_count >= self.failure_threshold:\n                self.state = \"OPEN\"\n            \n            raise\n```\n\n#### D. Core Logic Skeleton Code\n\n**Error-Aware Execute Action:**\n```python\n# providers/base.py\nfrom errors.recovery import retry_with_backoff, CircuitBreaker\nfrom typing import Optional, Dict, Any\n\nclass ProviderError(Exception):\n    \"\"\"Base exception for all provider errors.\"\"\"\n    def __init__(self, message: str, resource_address: str = \"\", permanent: bool = False):\n        super().__init__(message)\n        self.resource_address = resource_address\n        self.permanent = permanent\n\nclass TransientProviderError(ProviderError):\n    \"\"\"Transient error that may succeed on retry.\"\"\"\n    def __init__(self, message: str, resource_address: str = \"\"):\n        super().__init__(message, resource_address, permanent=False)\n\nclass PermanentProviderError(ProviderError):\n    \"\"\"Permanent error that won't succeed with retry.\"\"\"\n    def __init__(self, message: str, resource_address: str = \"\"):\n        super().__init__(message, resource_address, permanent=True)\n\nclass BaseProvider:\n    # ... other methods ...\n    \n    @retry_with_backoff(max_attempts=3, base_delay=1.0, max_delay=10.0)\n    def create(self, resource: Resource) -> Resource:\n        \"\"\"\n        Create a resource in the cloud with retry logic.\n        \n        TODO 1: Validate resource configuration matches provider schema\n        TODO 2: Call cloud API to create resource (may raise TransientProviderError)\n        TODO 3: If API returns success but incomplete data, immediately call self.read()\n        TODO 4: Return Resource with actual cloud attributes (not just desired)\n        TODO 5: Handle specific error cases:\n               - Rate limiting (429) -> raise TransientProviderError\n               - Invalid config (400) -> raise PermanentProviderError\n               - Timeout -> raise TransientProviderError\n        TODO 6: Ensure operation is idempotent (same call twice creates only one resource)\n        \"\"\"\n        pass\n    \n    def read(self, resource_id: str, resource_type: str) -> Optional[Resource]:\n        \"\"\"\n        Read current resource state from cloud with eventual consistency handling.\n        \n        TODO 1: Call cloud API to get resource\n        TODO 2: If resource not found, return None\n        TODO 3: If API returns 404 but resource was just created, implement progressive polling:\n               - Wait 1 second, retry\n               - Exponential backoff up to 30 seconds\n               - If still not found, assume creation failed\n        TODO 4: Convert cloud API response to Resource object\n        TODO 5: Handle rate limiting and timeouts with retry decorator\n        \"\"\"\n        pass\n```\n\n**Partial Apply Recovery in Executor:**\n```python\n# executor/apply.py\nfrom typing import Dict, List\nfrom dataclasses import dataclass\nfrom errors.exceptions import PartialApplyError\n\n@dataclass\nclass ApplyResult:\n    resource_address: str\n    success: bool\n    new_state: Optional[Resource]\n    error: Optional[str]\n    retries: int\n\ndef apply_plan(plan: Dict[str, PlanAction], providers: Dict[str, BaseProvider], \n               max_concurrency: int = 10) -> Dict[str, ApplyResult]:\n    \"\"\"\n    Apply execution plan with partial failure recovery.\n    \n    TODO 1: Group actions by provider for efficient API usage\n    TODO 2: For each action in topological order (respecting dependencies):\n            - Execute with _execute_action helper\n            - If success: refresh state from cloud, store in results\n            - If failure: \n                a. Stop execution (fail-fast)\n                b. Refresh state for all succeeded resources\n                c. Compile partial state (original + succeeded refreshed)\n                d. Write partial state to disk\n                e. Raise PartialApplyError with details\n    TODO 3: If all actions succeed: write complete new state\n    TODO 4: Return ApplyResult for each resource\n    \"\"\"\n    results = {}\n    succeeded_resources = {}\n    \n    # TODO: Sort actions by dependency order from plan\n    sorted_actions = topological_sort_actions(plan)\n    \n    for resource_address, action in sorted_actions:\n        try:\n            result = _execute_action(action, providers)\n            results[resource_address] = result\n            \n            if result.success:\n                # Refresh to get actual cloud state (not just expected)\n                refreshed = refresh_state(result.new_state, providers)\n                succeeded_resources[resource_address] = refreshed\n            else:\n                # Partial failure - stop execution\n                raise PartialApplyError(\n                    message=f\"Resource {resource_address} failed: {result.error}\",\n                    succeeded=succeeded_resources,\n                    failed_resource=resource_address\n                )\n                \n        except PartialApplyError:\n            # Re-raise to outer handler\n            raise\n        except Exception as e:\n            # Unexpected error - convert to PartialApplyError\n            raise PartialApplyError(\n                message=f\"Unexpected error applying {resource_address}: {str(e)}\",\n                succeeded=succeeded_resources,\n                failed_resource=resource_address\n            )\n    \n    return results\n```\n\n#### E. Language-Specific Hints\n\n- **Python Exception Chaining:** Use `raise NewError(\"message\") from original_error` to preserve stack trace.\n- **Context Managers for Cleanup:** Use `with` statements for lock acquisition and file operations to ensure cleanup even on error.\n- **Typing for Error Metadata:** Use `typing.TypedDict` or dataclasses for structured error return values.\n- **Logging Structured Errors:** Use `logging.exception()` with extra context dict for machine-parsable error logs.\n\n#### F. Milestone Checkpoint\n\n**After implementing error handling for Milestone 4:**\n1. **Test Configuration Errors:** Run `plan_command` with invalid HCL syntax - should fail immediately with clear error message.\n2. **Test Transient Retry:** Mock a provider that fails twice then succeeds - verify retry logic works.\n3. **Test Partial Apply:** Create a plan where second resource fails - verify:\n   - Execution stops after first failure\n   - State file contains only first resource (refreshed from cloud)\n   - Error message clearly indicates which resource failed\n4. **Test Lock Recovery:** Start an apply, kill process, verify lock is stale-detected after timeout.\n\n**Expected Behavior:**\n```\n$ python -m iac_engine plan invalid_config.hcl\nERROR: Configuration error in invalid_config.hcl:10\n  Undefined variable \"vpc_id\" referenced in resource \"aws_instance.web\"\n  Hint: Define variable in variables.tf or pass with -var flag\n```\n\n#### G. Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **Plan shows no changes** | State file out of sync with actual cloud | Run `refresh_state` on all resources, compare with state file | Implement state refresh before planning |\n| **Lock never released** | Process crashed without cleanup | Check lock file timestamp, if >10 min old | Implement stale lock detection in `acquire_lock` |\n| **Apply hangs forever** | Infinite retry loop or waiting for consistency | Check logs for repeated \"retrying\" messages | Add max attempt limit, progressive polling timeout |\n| **State file corrupted** | Process killed during write | Check for `.tmp` files in state directory | Use `write_atomic_json` with temp file + rename |\n| **Cycle detected error** | Circular dependency in config | Run `build_graph` with debug output | Redesign config to break cycle, use explicit `depends_on` |\n| **Resource disappears after create** | Eventual consistency not handled | Check timestamps: create succeeded but immediate read failed | Implement read-after-write polling in `create` method |\n\n\n## Testing Strategy\n\n> **Milestone(s):** 1, 2, 3, 4\n\nA robust testing strategy is essential for an IaC engine due to the high stakes of infrastructure changes—a bug could cause service outages, security vulnerabilities, or costly cloud resource waste. This section outlines a comprehensive verification approach combining automated tests at multiple levels with manual verification checkpoints for each milestone. The goal is to build confidence that each component behaves correctly in isolation and that the integrated system safely orchestrates infrastructure changes.\n\n### Testing Approaches and Tools\n\nThe testing strategy follows the **testing pyramid**, emphasizing many fast, isolated unit tests at the base, fewer integration tests in the middle, and a minimal number of slow, realistic end-to-end tests at the top. This balances thoroughness with execution speed, enabling rapid development cycles while catching complex interaction bugs.\n\n#### Unit Testing\n\nUnit tests verify the behavior of individual functions and classes in isolation, mocking all external dependencies. They should be fast, deterministic, and cover edge cases.\n\n| Component | What to Unit Test | Mocking Strategy | Tools/Patterns |\n|-----------|-------------------|------------------|----------------|\n| **Parser** | Variable interpolation logic, module resolution, syntax validation | Mock file system I/O for config loading | `unittest.mock` for patching `open`, `os.path`; parameterized tests for different HCL patterns |\n| **State Manager** | Atomic file write logic, lock acquisition/release, diff computation | Mock file operations and system calls for locks | `tempfile` for isolated test directories; mock `fcntl` or `msvcrt` for platform-specific locking |\n| **Planner** | Dependency graph construction, cycle detection, topological sort | Provide synthetic resource lists with known dependencies | Graph algorithm verification with known DAGs and cyclic graphs; property-based testing for sort invariants |\n| **Provider/Executor** | Retry logic, circuit breaker state transitions, action execution flow | Mock cloud API calls with controlled responses | `unittest.mock` for provider methods; simulate API rate limits and transient failures |\n\nFor unit testing, Python's built-in `unittest` framework combined with `pytest` for richer fixtures and parameterization is recommended. Use `hypothesis` for property-based testing of complex algorithms like topological sort, where you can verify that for any arbitrary DAG, the sort order respects all dependencies.\n\n#### Integration Testing\n\nIntegration tests verify that components work correctly together, with real implementations of some internal dependencies but external systems (like cloud APIs) still mocked.\n\n| Integration Scope | Test Focus | Setup Required | Validation |\n|-------------------|------------|----------------|------------|\n| **Parser → Planner** | That parsed resources correctly feed into graph building | Parse real config files from test fixtures | Verify that implicit dependencies are extracted from attribute references |\n| **State Manager → Planner** | That state diffs accurately reflect changes between configurations | Create state files, modify configs, compute plan | Plan actions should match expected CREATE/UPDATE/DELETE |\n| **Planner → Executor** | That execution plan is correctly transformed into provider calls | Mock providers, feed plan to executor | Verify that provider methods are called in correct order with correct arguments |\n| **Full Pipeline (no cloud)** | End-to-end flow from config to plan without actual provisioning | All components with mocked providers | Plan output should be predictable and safe (no unintended deletions) |\n\nA key integration testing pattern is the **\"fake provider\"**—a complete implementation of the `BaseProvider` interface that simulates a cloud API in memory. This allows testing the entire engine workflow without network calls or cloud costs. The fake provider maintains an in-memory resource store and can be programmed to simulate specific failures (timeouts, rate limits) to test error handling.\n\n#### End-to-End Testing\n\nEnd-to-end (E2E) tests run the actual engine against real cloud providers in a controlled, isolated environment (like a dedicated test cloud account). These tests are slow, expensive, and flaky due to cloud eventual consistency, so they should be minimal and focused on critical happy paths and failure recovery scenarios.\n\n| E2E Scenario | Infrastructure Goal | Success Criteria | Cleanup |\n|--------------|---------------------|------------------|---------|\n| **Basic resource lifecycle** | Create, update, delete a simple resource (e.g., S3 bucket) | Resource exists with correct attributes after apply; gone after destroy | Engine must destroy all test resources even if test fails |\n| **Dependency ordering** | Create resources with dependencies (e.g., VPC before subnet) | Resources created in correct order; deletion reverses order | Verify deletion order via provider logs |\n| **Failure and recovery** | Simulate partial apply failure (e.g., rate limit mid-operation) | Engine stops gracefully; state is not corrupted; retry works | Manual intervention may be needed for zombie resources |\n\nFor E2E tests, use cloud provider sandbox accounts with tight budget controls and automatic cleanup via tagged resources. Run these tests only in the main branch or release candidates, not on every pull request.\n\n#### Mocking Cloud APIs\n\nComprehensive mocking is essential for reliable, fast tests. Two complementary approaches are recommended:\n\n**1. Ad-hoc mocking with `unittest.mock`:** Suitable for unit and integration tests where you control the exact sequence of calls. You can mock individual methods of a provider to return specific responses or raise exceptions.\n\n**2. Structured fake provider:** A full in-memory implementation that mimics cloud API behavior, including:\n- Resource storage with unique identifiers\n- Basic validation (required attributes)\n- Simulated eventual consistency (delayed visibility of updates)\n- Configurable failure modes (error rates, latency)\n\nThe fake provider can be shared across tests and even used as a teaching tool to understand how the engine interacts with providers.\n\n> **Decision: Fake Provider over HTTP API Mock**\n> - **Context**: We need to test provider interactions without network calls. While HTTP mocks (like `responses` or `httpretty`) can intercept requests, they tie tests to specific HTTP details.\n> - **Options Considered**: \n>   1. **HTTP-level mocking**: Intercept HTTP requests to cloud APIs.\n>   2. **Fake provider**: Implement the `BaseProvider` interface with in-memory storage.\n> - **Decision**: Implement a fake provider.\n> - **Rationale**: The fake provider operates at the same abstraction level as real providers (the `BaseProvider` interface), making tests more resilient to changes in HTTP libraries or API endpoints. It's also faster (no network stack) and can simulate higher-level behaviors like eventual consistency more naturally.\n> - **Consequences**: Tests are more portable and focused on business logic, but the fake provider must be maintained alongside real providers. It may not catch protocol-specific bugs (e.g., authentication headers).\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| HTTP-level mocking (e.g., `responses`) | Catches HTTP-level bugs; works with any HTTP client | Tied to specific HTTP library; verbose to set up; misses interface logic | No |\n| Fake provider (in-memory) | Matches abstraction level; fast; can simulate complex behaviors | Requires maintenance; may drift from real provider behavior | Yes |\n\n### Milestone Checkpoints and Verification\n\nEach milestone has specific deliverables that should be verified through both automated tests and manual commands. Below are checkpoints for each milestone, including what to test, how to test it, and commands to run for verification.\n\n#### Milestone 1: Configuration Parser\n\nThe parser must correctly interpret configuration files, resolve variables, and expand modules into a flat list of resources.\n\n**Automated Test Coverage:**\n\n| Functionality | Test Cases | Expected Outcome |\n|---------------|------------|------------------|\n| **Basic parsing** | Simple HCL/YAML with one resource | Returns list with one `Resource` with correct `type`, `name`, `attributes` |\n| **Variable interpolation** | Config with `${var.name}` references | Variables replaced with actual values from var files or CLI |\n| **Module resolution** | Config with `module \"x\"` block | Module resources are loaded and merged into main resource list |\n| **Error handling** | Invalid syntax, missing variables, circular module references | Raises `ConfigurationError` with clear message |\n\n**Manual Verification Checklist:**\n\n1. **Create a test configuration** (`test.tf`):\n   ```hcl\n   variable \"instance_type\" {\n     default = \"t2.micro\"\n   }\n   \n   resource \"aws_instance\" \"web\" {\n     instance_type = var.instance_type\n     ami           = \"ami-123456\"\n   }\n   ```\n\n2. **Run the parser from a Python shell or temporary script:**\n   ```python\n   from parser import process_configuration\n   resources = process_configuration(Path(\"test.tf\"), [], {})\n   print(f\"Found {len(resources)} resources\")\n   for r in resources:\n       print(f\"  {r.type}.{r.name}: {r.attributes}\")\n   ```\n\n3. **Verify output:**\n   - Should print exactly 1 resource: `aws_instance.web`\n   - Attribute `instance_type` should be `\"t2.micro\"` (resolved variable)\n   - Attribute `ami` should be `\"ami-123456\"`\n\n4. **Test variable precedence:** Pass a different `instance_type` via CLI variables dict and confirm it overrides the default.\n\n5. **Test module loading:** Create a module directory and reference it; verify its resources appear in the output.\n\n**Command to run unit tests:**\n```bash\npytest tests/unit/test_parser.py -v\n```\nExpected: All tests pass, with >80% line coverage for parser module.\n\n#### Milestone 2: State Manager\n\nThe state manager must reliably read/write state files, handle locking, and compute accurate diffs.\n\n**Automated Test Coverage:**\n\n| Functionality | Test Cases | Expected Outcome |\n|---------------|------------|------------------|\n| **Atomic writes** | Simulate crash during write (e.g., kill process) | State file remains intact; backup is used for recovery |\n| **Locking** | Concurrent lock attempts from different processes | Only one acquires lock; others timeout or wait |\n| **Diff computation** | Various desired vs. current state scenarios | Correct `PlanAction` types (CREATE, UPDATE, DELETE, NOOP) |\n| **Remote backend** | Mock S3/GCS operations | State can be read from/written to remote location |\n\n**Manual Verification Checklist:**\n\n1. **Create an initial state file** (`state.json`) with one resource:\n   ```json\n   {\n     \"aws_instance.web\": {\n       \"resource_id\": \"i-123456\",\n       \"resource_type\": \"aws_instance\",\n       \"resource_name\": \"web\",\n       \"attributes\": {\"instance_type\": \"t2.micro\", \"ami\": \"ami-123456\"},\n       \"dependencies\": []\n     }\n   }\n   ```\n\n2. **Test reading and writing:**\n   ```python\n   from state_manager import read_state, write_state\n   state = read_state(Path(\"state.json\"))\n   print(state[\"aws_instance.web\"][\"attributes\"][\"instance_type\"])\n   # Modify\n   state[\"aws_instance.web\"][\"attributes\"][\"instance_type\"] = \"t2.small\"\n   write_state(Path(\"state.json\"), state)\n   # Verify file updated atomically (check .bak file exists)\n   ```\n\n3. **Test locking:** In two separate terminal sessions, attempt to acquire a lock on the same file. The first should succeed; the second should timeout after 30 seconds.\n\n4. **Test diff:** Create a desired resource list that changes the `instance_type` and adds a new resource. Call `compute_diff` and verify it returns an UPDATE for the instance and a CREATE for the new resource.\n\n**Command to run unit tests:**\n```bash\npytest tests/unit/test_state_manager.py -v\n```\nExpected: Tests pass, including a test that verifies atomic write by simulating a power failure (writing a large state file and interrupting the process).\n\n#### Milestone 3: Planner (Dependency Graph & Planning)\n\nThe planner must construct a correct DAG, detect cycles, and generate a safe execution plan.\n\n**Automated Test Coverage:**\n\n| Functionality | Test Cases | Expected Outcome |\n|---------------|------------|------------------|\n| **Graph construction** | Resources with explicit `depends_on` and implicit references | Graph edges created in both directions |\n| **Cycle detection** | Resources with circular dependencies | `validate_acyclic` returns `False` or raises exception |\n| **Topological sort** | Valid DAG with known dependency order | Sort order respects all dependencies |\n| **Plan generation** | Various state diffs | Plan actions are in correct order (CREATE/UPDATE before DELETE when replacing) |\n\n**Manual Verification Checklist:**\n\n1. **Create a simple dependency scenario:** Two resources where a subnet depends on a VPC (reference in attributes or explicit `depends_on`).\n\n2. **Build graph and validate:**\n   ```python\n   from planner import build_graph, validate_acyclic, topological_sort\n   graph = build_graph(resources, current_state)\n   print(f\"Graph has {len(graph)} nodes\")\n   if validate_acyclic(graph):\n       order = topological_sort(graph)\n       print(f\"Execution order: {order}\")\n   else:\n       print(\"Cycle detected!\")\n   ```\n\n3. **Verify execution order:** The VPC should appear before the subnet in the sorted list.\n\n4. **Generate a plan:** Use the diff from Milestone 2 and the sorted order to generate a plan. Print the plan and verify actions are in the correct order.\n\n5. **Test cycle detection:** Intentionally create a circular dependency (A depends on B, B depends on A). The validator should catch it.\n\n**Command to run unit tests:**\n```bash\npytest tests/unit/test_planner.py -v\n```\nExpected: All tests pass, including a property-based test that for any random DAG, the topological sort produces a valid linear ordering.\n\n#### Milestone 4: Provider Abstraction & Executor\n\nThe provider interface must be implemented correctly, and the executor must apply plans with retries and error handling.\n\n**Automated Test Coverage:**\n\n| Functionality | Test Cases | Expected Outcome |\n|---------------|------------|------------------|\n| **Provider CRUD** | Mock API calls for each operation | Methods return appropriate `Resource` or success indicator |\n| **Retry logic** | Simulate transient failures (timeouts, 5xx errors) | Operation retries with exponential backoff, eventually succeeds |\n| **Circuit breaker** | Repeated provider failures | Circuit opens after threshold, fails fast, resets after timeout |\n| **Executor flow** | Plan with multiple actions, some failing | Executor applies successful actions, updates state, reports partial failure |\n\n**Manual Verification Checklist:**\n\n1. **Implement a mock provider:** Create a simple in-memory provider (e.g., `MockProvider`) that stores resources in a dict. Test each CRUD method.\n\n2. **Test retry decorator:** Apply `@retry_with_backoff` to a function that fails 3 times then succeeds. Verify it retries exactly 3 times with increasing delays.\n\n3. **Test circuit breaker:** Create a function that always fails. Use `CircuitBreaker` to call it; after N failures, subsequent calls should immediately raise `CircuitOpenError`.\n\n4. **End-to-end integration test:**\n   - Parse a config.\n   - Read empty state (no resources).\n   - Generate a plan (should be all CREATEs).\n   - Execute the plan using the mock provider.\n   - Verify state file now contains the resources with correct IDs from the mock provider.\n\n**Command to run unit tests:**\n```bash\npytest tests/unit/test_provider.py tests/unit/test_executor.py -v\n```\nExpected: All tests pass, including an integration test that runs a full `apply_command` with a mock provider and verifies the final state.\n\n#### Integrated System Verification\n\nAfter completing all milestones, run the full test suite and perform a manual smoke test:\n\n```bash\n# Run all unit and integration tests\npytest tests/ -v --cov=iac_engine --cov-report=html\n\n# Expected: >90% total coverage, all tests pass\n\n# Smoke test: plan and apply a simple configuration\npython -m iac_engine plan test_configs/simple.tf\npython -m iac_engine apply test_configs/simple.tf --auto-approve\n```\n\nThe smoke test should show a plan with the expected changes and apply them successfully, updating the state file.\n\n### Implementation Guidance\n\n#### A. Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Testing Framework | `pytest` + `unittest.mock` | `pytest` with `pytest-asyncio` for async tests |\n| HTTP Mocking | `requests-mock` for `requests`-based providers | `aioresponses` for async HTTP clients |\n| Property-based Testing | `hypothesis` for generating test cases | Custom generators for complex resource graphs |\n| Coverage Reporting | `pytest-cov` for coverage reports | Integrate with Codecov or Coveralls for CI |\n| End-to-End Testing | Manual scripts with cleanup tags | Automated using Terraform's testing framework as inspiration |\n\n#### B. Recommended File/Module Structure\n\n```\niac_engine/\n  src/\n    iac_engine/\n      parser/           # Milestone 1\n        __init__.py\n        parser.py\n        resolver.py\n        module_loader.py\n      state/            # Milestone 2\n        __init__.py\n        manager.py\n        lock.py\n        backends.py\n      planner/          # Milestone 3\n        __init__.py\n        graph.py\n        plan.py\n      providers/        # Milestone 4\n        __init__.py\n        base.py\n        executor.py\n        retry.py\n        circuit_breaker.py\n        aws/            # Example provider implementation\n          __init__.py\n          ec2.py\n        mock/           # Fake provider for testing\n          __init__.py\n          provider.py\n      cli.py            # CLI entry point\n      exceptions.py     # IaCError and subclasses\n  tests/\n    unit/\n      test_parser.py\n      test_state_manager.py\n      test_planner.py\n      test_providers.py\n      test_executor.py\n    integration/\n      test_parser_integration.py\n      test_plan_generation.py\n      test_full_workflow.py\n    fixtures/           # Sample configs, state files\n      configs/\n        simple.tf\n        with_modules/\n      state/\n        empty.json\n        simple.json\n    conftest.py         # Shared pytest fixtures\n```\n\n#### C. Infrastructure Starter Code\n\n**Fake Provider for Testing (Complete Implementation):**\n```python\n# tests/fake_provider.py\nfrom typing import Dict, Any, Optional\nfrom iac_engine.providers.base import BaseProvider, Resource\n\nclass FakeProvider(BaseProvider):\n    \"\"\"In-memory fake provider for testing.\"\"\"\n    \n    def __init__(self, provider_type: str):\n        self.provider_type = provider_type\n        self.resources: Dict[str, Resource] = {}  # resource_id -> Resource\n        self._next_id = 1\n        \n    def validate_credentials(self, config: Dict[str, Any]) -> bool:\n        # Always valid for testing\n        return True\n    \n    def create(self, resource: Resource) -> Resource:\n        # Simulate creation with a generated ID\n        resource_id = f\"{self.provider_type}-{self._next_id}\"\n        self._next_id += 1\n        \n        # Store the resource with its ID\n        resource.attributes[\"id\"] = resource_id\n        self.resources[resource_id] = resource\n        \n        # Simulate eventual consistency by not immediately returning\n        # (in real tests, you might add a delay flag)\n        return resource\n    \n    def read(self, resource_id: str, resource_type: str) -> Optional[Resource]:\n        return self.resources.get(resource_id)\n    \n    def update(self, resource_id: str, resource: Resource) -> Resource:\n        if resource_id not in self.resources:\n            raise KeyError(f\"Resource {resource_id} not found\")\n        \n        # Update attributes\n        self.resources[resource_id].attributes.update(resource.attributes)\n        return self.resources[resource_id]\n    \n    def delete(self, resource_id: str, resource_type: str) -> bool:\n        if resource_id in self.resources:\n            del self.resources[resource_id]\n            return True\n        return False\n```\n\n**Retry Decorator (Complete Implementation):**\n```python\n# src/iac_engine/providers/retry.py\nimport time\nimport random\nfrom functools import wraps\nfrom typing import Callable, Type, Tuple, Any\n\ndef retry_with_backoff(\n    max_attempts: int = 3,\n    base_delay: float = 1.0,\n    max_delay: float = 10.0,\n    jitter: bool = True,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,)\n):\n    \"\"\"\n    Decorator that retries a function with exponential backoff.\n    \n    Args:\n        max_attempts: Maximum number of attempts (including first)\n        base_delay: Base delay in seconds for exponential backoff\n        max_delay: Maximum delay in seconds\n        jitter: If True, add random jitter to delays\n        exceptions: Tuple of exception types to catch and retry on\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @wraps(func)\n        def wrapper(*args, **kwargs) -> Any:\n            attempts = 0\n            while True:\n                try:\n                    attempts += 1\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    if attempts >= max_attempts:\n                        raise\n                    \n                    # Calculate delay with exponential backoff\n                    delay = min(base_delay * (2 ** (attempts - 1)), max_delay)\n                    \n                    # Add jitter (up to 25% of delay)\n                    if jitter:\n                        delay = delay * (0.75 + 0.25 * random.random())\n                    \n                    time.sleep(delay)\n            return wrapper\n        return decorator\n```\n\n#### D. Core Logic Skeleton Code\n\n**Test for Dependency Graph Construction:**\n```python\n# tests/unit/test_planner.py\nimport pytest\nfrom iac_engine.planner.graph import build_graph, validate_acyclic\nfrom iac_engine.parser import Resource\n\ndef test_build_graph_with_implicit_dependencies():\n    \"\"\"Test that implicit dependencies are extracted from attribute references.\"\"\"\n    # TODO 1: Create two resources where resource B references resource A\n    #   resource_a = Resource(type=\"aws_vpc\", name=\"main\", attributes={\"id\": \"vpc-123\"})\n    #   resource_b = Resource(type=\"aws_subnet\", name=\"web\", attributes={\"vpc_id\": \"${aws_vpc.main.id}\"})\n    \n    # TODO 2: Build graph with these resources and empty state\n    \n    # TODO 3: Verify graph has two nodes\n    \n    # TODO 4: Verify edge exists from aws_subnet.web to aws_vpc.main\n    #   (subnet depends on vpc)\n    \n    # TODO 5: Validate graph is acyclic (should return True)\n    \n    pass\n\ndef test_cycle_detection():\n    \"\"\"Test that circular dependencies are detected.\"\"\"\n    # TODO 1: Create three resources with circular dependency:\n    #   A -> B (A depends on B)\n    #   B -> C (B depends on C)\n    #   C -> A (C depends on A)\n    \n    # TODO 2: Build graph\n    \n    # TODO 3: Call validate_acyclic - should return False or raise exception\n    \n    # TODO 4: Verify appropriate error message indicates cycle\n    \n    pass\n```\n\n**Test for State Diff Computation:**\n```python\n# tests/unit/test_state_manager.py\ndef test_compute_diff_scenarios():\n    \"\"\"Test various diff scenarios: create, update, delete, noop.\"\"\"\n    # TODO 1: Setup: Create a current_state dict with one resource\n    \n    # TODO 2: Scenario CREATE: desired_resources has a new resource not in current_state\n    #   Call compute_diff\n    #   Verify result contains PlanAction with action_type=CREATE for that resource\n    \n    # TODO 3: Scenario UPDATE: desired_resources modifies an attribute of existing resource\n    #   Verify action_type=UPDATE\n    \n    # TODO 4: Scenario DELETE: desired_resources removes a resource present in current_state\n    #   Verify action_type=DELETE\n    \n    # TODO 5: Scenario NOOP: resource identical in current and desired\n    #   Verify action_type=NOOP\n    \n    # TODO 6: Edge case: resource with dependencies being deleted\n    #   Verify delete action includes proper dependency ordering consideration\n    \n    pass\n```\n\n#### E. Language-Specific Hints\n\n- Use `pytest.fixture` for shared test setup (e.g., temporary directories, mock providers).\n- Use `@pytest.mark.parametrize` to test multiple input/output combinations for parsing functions.\n- For testing file operations, use `tempfile.TemporaryDirectory()` to ensure cleanup.\n- Mock time in tests involving retries or circuit breakers using `unittest.mock.patch('time.sleep')` and `unittest.mock.patch('time.time')`.\n- Use `pytest.raises(Exception)` context manager to verify that expected exceptions are raised.\n\n#### F. Milestone Checkpoint Commands\n\nAfter implementing each milestone, run these commands to verify basic functionality:\n\n**Milestone 1:**\n```bash\n# Run parser tests\npytest tests/unit/test_parser.py -xvs\n\n# Expected: All tests pass. If any fail, check:\n# - Did you handle variable interpolation correctly? Use the resolver test.\n# - Did you correctly parse nested blocks? Check the AST structure.\n```\n\n**Milestone 2:**\n```bash\n# Run state manager tests\npytest tests/unit/test_state_manager.py -xvs\n\n# Expected: Tests pass, including the atomic write test.\n# If locking tests fail on Windows, you may need to adjust file locking implementation.\n```\n\n**Milestone 3:**\n```bash\n# Run planner tests\npytest tests/unit/test_planner.py -xvs\n\n# Expected: All tests pass, including cycle detection.\n# If topological sort fails, verify your graph construction first.\n```\n\n**Milestone 4:**\n```bash\n# Run provider and executor tests\npytest tests/unit/test_provider.py tests/unit/test_executor.py -xvs\n\n# Expected: Tests pass, including retry and circuit breaker tests.\n# If executor tests fail, check that you're calling provider methods in correct order.\n```\n\n#### G. Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **Plan shows no changes when changes exist** | Diff computation not detecting attribute changes | Log desired vs. current attributes; check deep equality | Ensure diff compares nested structures, not just top-level dict |\n| **Lock never released after crash** | Heartbeat thread not stopped; lock file orphaned | Check for stale `.lock` file; verify `LockHandle.cleanup()` called | Implement lock stale detection; add timeout to lock acquisition |\n| **Cycle detected in valid config** | Over-eager implicit dependency detection | Log extracted references; visualize graph | Limit implicit dependencies to actual attribute references, not all strings |\n| **Provider retries exhausting but shouldn't** | Non-transient exception being caught | Check exception hierarchy; log exception types | Ensure `TransientProviderError` is raised for retryable errors only |\n| **State file corrupted after partial write** | Non-atomic write interrupted | Check for `.bak` file; verify `write_atomic_json` renames after write | Use `tempfile.NamedTemporaryFile` with `os.replace` for atomicity |\n| **Executor creates resources in wrong order** | Topological sort incorrect or graph edges reversed | Print dependency graph and sort order; verify edges point from dependent to dependency | Ensure `depends_on` and implicit refs create edge `dependent -> dependency` |\n\n---\n\n\n## Debugging Guide\n\n> **Milestone(s):** 1, 2, 3, 4 (cross-cutting)\n\nThis section provides a comprehensive guide to diagnosing and resolving common issues you'll encounter while implementing the Infrastructure as Code engine. Debugging distributed infrastructure management requires systematic thinking—you need to understand where in the pipeline a failure occurred and how different components interact. Think of debugging as being a **forensic investigator** examining a crime scene: you collect evidence (logs, state files), reconstruct events (execution sequences), and identify the culprit (buggy code or unexpected conditions).\n\n### Common Bugs: Symptom → Cause → Fix\n\nThe following table catalogs the most frequent issues you'll encounter during implementation, organized by component area. Each entry follows the pattern of observed symptom, root cause, and concrete fix.\n\n| Symptom | Likely Component | Root Cause | Diagnostic Steps | Fix |\n|---------|-----------------|------------|------------------|-----|\n| **\"Plan shows no changes\"** when resources should be created | Planner or State Manager | 1. **State file corruption**: The state file contains invalid data that doesn't match the parsed resources.<br>2. **Incorrect diff logic**: `compute_diff` returns `ActionType.NOOP` for resources that differ.<br>3. **Variable interpolation mismatch**: Variables resolve differently between runs, causing different resource addresses. | 1. Examine the state file with `cat state.json` - look for missing or malformed `StateRecord` entries.<br>2. Add debug logging to `compute_diff` to compare `desired_attributes` vs `current_attributes`.<br>3. Run `process_configuration` in isolation and inspect the resolved `Resource.attributes`. | 1. Use `read_json_with_backup` to restore from backup if corruption is detected.<br>2. Ensure `compute_diff` compares all attributes, not just a subset.<br>3. Verify variable resolution produces consistent values across runs. |\n| **\"Cycle detected\"** error during plan generation | Planner | 1. **Circular dependency**: Resource A depends on B, and B depends on A via explicit `depends_on` or implicit references.<br>2. **Self-reference**: A resource references its own attribute (e.g., `name = \"${self.id}\"`).<br>3. **Transitive cycle**: A → B → C → A forms a three-way cycle. | 1. Run `validate_acyclic` with debug output to print the cycle.<br>2. Inspect the `DependencyGraphNode.depends_on` for each resource in the suspected cycle.<br>3. Check for implicit dependencies from attribute references that create unintended edges. | 1. Review configuration and break the cycle by removing unnecessary `depends_on`.<br>2. For implicit cycles, consider using `ignore_changes` meta-argument or restructure resources.<br>3. Implement cycle detection that suggests which dependency to remove. |\n| **\"Lock never released\"** - subsequent operations hang | State Manager | 1. **Process crash without cleanup**: The previous process acquired a lock but crashed before calling `release_lock`.<br>2. **Heartbeat thread deadlock**: The `heartbeat_thread` is blocked or not updating the lock timestamp.<br>3. **Stale lock detection timeout too long**: Default timeout (e.g., 300 seconds) hasn't expired yet. | 1. Check lock file timestamp: `stat -c %y .terraform.lock`.<br>2. Verify if the locking process is still running: `ps -p <process_id>`.<br>3. Examine lock file contents for `process_id` and `lock_id`. | 1. Implement stale lock detection in `acquire_lock` - if lock is older than timeout, forcibly acquire.<br>2. Ensure `LockHandle.heartbeat_thread` properly updates timestamp with file atomic writes.<br>3. Add a `force-unlock` CLI command to manually remove stale locks. |\n| **\"Variable not found\"** during parsing | Configuration Parser | 1. **Variable defined in wrong scope**: Variable defined in child module but referenced in parent.<br>2. **Variable file not loaded**: `-var-file` not passed or file missing.<br>3. **Interpolation syntax error**: `${var. name}` has extra space or malformed expression. | 1. Print the variable resolution stack trace during `resolve_variables`.<br>2. List all loaded variable files and CLI variables before resolution.<br>3. Check raw AST for variable block locations vs reference locations. | 1. Ensure variable resolution searches parent scopes for definitions.<br>2. Implement fallback to environment variables for missing variables.<br>3. Validate interpolation syntax during parsing, not just resolution. |\n| **\"Provider not found\"** when applying plan | Executor/Provider SDK | 1. **Provider plugin not installed**: The required provider (e.g., `aws`) isn't in the plugins directory.<br>2. **Provider configuration missing**: No `provider \"aws\"` block with required `region` and `access_key`.<br>3. **Provider initialization error**: `validate_credentials` fails due to invalid credentials. | 1. Check `ProviderConfig.provider_type` matches available provider classes.<br>2. Verify `ProviderConfig.config` contains all required fields.<br>3. Test credentials independently (e.g., `aws sts get-caller-identity`). | 1. Implement provider plugin discovery scanning a `plugins/` directory.<br>2. Validate provider configuration during parsing, not just at execution.<br>3. Provide clear error messages including which field is missing. |\n| **Resource stuck in \"Creating...\"** forever | Executor/Provider | 1. **Eventual consistency delay**: Cloud API returns success but resource isn't immediately available.<br>2. **Missing async polling**: Provider `create` doesn't wait for resource to reach ready state.<br>3. **Timeout too short**: The polling timeout (e.g., 5 minutes) is less than cloud provisioning time. | 1. Check provider logs for API response - look for `pending` or `in-progress` status.<br>2. Verify `refresh_state` is called after `create` and what state it returns.<br>3. Monitor cloud console manually to see actual resource status. | 1. Implement exponential backoff polling in provider `create` method.<br>2. Increase timeout for slow resources (databases, VPCs).<br>3. Add progress indicators showing polling attempts. |\n| **Partial apply failure leaves \"zombie resources\"** | Executor | 1. **State not updated on failure**: Resource created successfully but error in subsequent step prevents `write_state`.<br>2. **No rollback on error**: The executor doesn't clean up successfully created resources when later resources fail.<br>3. **Inconsistent state file**: Partial write due to crash during `write_state`. | 1. Compare state file with actual cloud resources using provider `read`.<br>2. Check for `PartialApplyError.succeeded_resources` to see what was created.<br>3. Look for `write_atomic_json` temporary files left in directory. | 1. Implement two-phase state update: write intermediate state after each successful resource.<br>2. Add `-auto-approve=false` default to prevent accidental zombie creation.<br>3. Use backup state file that's only updated after full successful apply. |\n| **\"Invalid interpolation\"** in count or for_each | Configuration Parser | 1. **Chicken-egg problem**: Variable used in `count` references another resource attribute that doesn't exist yet.<br>2. **Type mismatch**: `count` expects a number but receives a string or list.<br>3. **Circular reference in count**: Two resources' counts depend on each other. | 1. Evaluate interpolation expressions in isolation to see their resolved value.<br>2. Check the type of the resolved variable (number vs string).<br>3. Build dependency graph including count references as edges. | 1. Implement two-pass parsing: first resolve static variables, then resolve dynamic ones.<br>2. Add type validation for `count` and `for_each` arguments.<br>3. Detect and reject circular count dependencies during graph building. |\n| **Graph topological sort returns different order each run** | Planner | 1. **Non-deterministic iteration over dictionary**: Python's `dict` iteration order affects graph construction.<br>2. **Missing dependency edge**: Some resources have no dependencies, creating multiple valid topological orders.<br>3. **Graph nodes not sorted before algorithm**: The algorithm picks arbitrary starting nodes. | 1. Print the adjacency list of the graph before sorting.<br>2. Run topological sort multiple times and compare outputs.<br>3. Check if all expected dependencies are captured (implicit vs explicit). | 1. Sort node IDs alphabetically before starting topological sort.<br>2. Ensure deterministic edge addition by sorting source and target nodes.<br>3. Document that multiple valid orders are possible when no dependencies exist. |\n| **Rate limit errors despite retry logic** | Provider SDK | 1. **No jitter in retry delays**: All retries happen simultaneously across parallel requests.<br>2. **Retry window too short**: Exponential backoff max delay (e.g., 30s) less than rate limit window (e.g., 1 minute).<br>3. **No circuit breaker**: Repeated failures continue retrying indefinitely. | 1. Check timestamps of API calls in logs - are they evenly spaced?<br>2. Examine cloud provider rate limit headers (`Retry-After`, `X-RateLimit-Reset`).<br>3. Monitor circuit breaker state (open/closed/half-open). | 1. Add jitter to retry delays using `random.uniform(0.5 * delay, 1.5 * delay)`.<br>2. Respect `Retry-After` headers when present in error responses.<br>3. Implement circuit breaker that opens after N consecutive failures. |\n| **State file grows indefinitely with stale resources** | State Manager | 1. **No state compaction**: Deleted resources remain in state as `tombstones` or with `ActionType.DELETE` records.<br>2. **Multiple state versions kept**: Backup mechanism never cleans up old backups.<br>3. **Resource renaming creates duplicates**: Old `Resource.id` remains while new one is added. | 1. Examine state file size over time - does it increase after each apply?<br>2. Count `StateRecord` entries for deleted resources (attributes null).<br>3. Check for duplicate resources with similar attributes. | 1. Implement state compaction after successful delete operations.<br>2. Add retention policy for backups (keep last N versions).<br>3. Add state validation that detects and removes orphaned resources. |\n| **Module source path resolution fails** | Configuration Parser | 1. **Relative path confusion**: Module uses `../parent` but current working directory differs.<br>2. **Git URL without ref**: Module source is `github.com/org/module` without branch/tag.<br>3. **Missing module cache**: Module downloaded previously but cache cleared. | 1. Print the resolved absolute path for each module source.<br>2. Check if directory exists at the resolved path.<br>3. Verify module registry configuration (if using remote modules). | 1. Normalize all paths to absolute paths relative to configuration root.<br>2. Implement module cache with version locking (similar to Terraform's `.terraform/modules`).<br>3. Provide clear error including the resolved path that failed. |\n\n### Debugging Techniques and Tools\n\nEffective debugging requires more than just reading error messages—you need a systematic approach to isolate issues. Think of these techniques as **medical diagnostic tools**: each reveals different aspects of the system's health.\n\n#### Strategic Logging with Context Correlation\n\nThe most powerful debugging technique is comprehensive, structured logging. Instead of simple `print` statements, implement a logging system that:\n\n1. **Includes correlation IDs**: Each operation (plan, apply) gets a unique ID logged with every message, making it easy to trace through components.\n2. **Uses log levels appropriately**:\n   - `DEBUG`: Detailed internal state (attribute values, graph edges)\n   - `INFO`: Major lifecycle events (resource created, plan generated)\n   - `WARN`: Unexpected but recoverable conditions (falling back to default)\n   - `ERROR`: Operation failures with stack traces\n3. **Logs to structured formats** (JSON) for machine parsing, with human-readable format for development.\n\n> **Diagnostic Pattern**: When you encounter an error, increase the log level to `DEBUG`, reproduce the issue, and search for the correlation ID in the log file. Follow the execution path through each component.\n\n#### State File Inspection and Diffing\n\nThe state file is the **ground truth** of your infrastructure. Learn to inspect it like a database:\n\n1. **Manual inspection**:\n   ```bash\n   # Pretty-print the state\n   jq . terraform.tfstate\n   \n   # Count resources by type\n   jq '.resources | group_by(.type) | map({type: .[0].type, count: length})' terraform.tfstate\n   \n   # Find resources with specific attribute\n   jq '.resources[] | select(.attributes.name == \"web-server\")' terraform.tfstate\n   ```\n\n2. **State diffs between runs**:\n   ```bash\n   # Compare current state with backup\n   diff -u <(jq -S . terraform.tfstate) <(jq -S . terraform.tfstate.backup)\n   \n   # Generate visual diff\n   git diff --no-index terraform.tfstate.old terraform.tfstate.new\n   ```\n\n3. **State validation script**: Create a Python script that loads the state file and validates invariants (no duplicate IDs, all dependencies exist, attributes match schema).\n\n#### Graph Visualization for Dependency Analysis\n\nWhen dependency issues arise, visualize the graph to understand relationships:\n\n1. **Export graph to DOT format** for Graphviz:\n   ```python\n   def export_to_dot(graph: Dict[str, DependencyGraphNode]) -> str:\n       lines = [\"digraph G {\"]\n       for node_id, node in graph.items():\n           for dep in node.depends_on:\n               lines.append(f'  \"{dep}\" -> \"{node_id}\";')\n       lines.append(\"}\")\n       return \"\\n\".join(lines)\n   ```\n\n2. **Render and view**:\n   ```bash\n   python -c \"from planner import build_graph; print(export_to_dot(graph))\" > graph.dot\n   dot -Tpng graph.dot -o graph.png\n   open graph.png  # Or display on Linux\n   ```\n\n3. **Interactive visualization** with network libraries (vis.js, D3.js) for complex graphs with 50+ nodes.\n\n#### Stepwise Execution with Intermediate Dumps\n\nWhen an algorithm fails (like topological sort), capture its intermediate state:\n\n1. **Add checkpoint debugging** that saves state at key points:\n   ```python\n   def topological_sort_with_debug(graph):\n       checkpoint = 1\n       while nodes_with_zero_indegree:\n           save_checkpoint(checkpoint, {\"graph\": graph.copy(), \"sorted\": sorted_nodes})\n           checkpoint += 1\n           # ... algorithm continues\n   ```\n\n2. **Create a replay capability** that loads checkpoint data and continues from that point, allowing you to test fixes without re-running the entire pipeline.\n\n#### Mock Provider for Isolated Testing\n\nWhen debugging provider issues, use a mock provider that simulates cloud APIs:\n\n1. **In-memory mock** that stores resources in a dictionary, simulating eventual consistency with configurable delays.\n2. **Fault-injection mock** that fails specific operations (create, update) at certain rates to test error handling.\n3. **Record/replay mock** that captures real API calls during one run and replays them during tests, eliminating cloud dependencies.\n\n#### Time Travel Debugging with State Snapshots\n\nFor intermittent issues, implement a **state snapshot** system:\n\n1. **Automatic snapshots** before each state-modifying operation.\n2. **Label snapshots** with metadata (timestamp, operation ID, user).\n3. **Restore capability** to roll back to any snapshot:\n   ```bash\n   iac-engine state restore --snapshot-id plan-2023-10-05-14-30-00\n   ```\n\n### Implementation Guidance\n\nThis section provides concrete tools and code patterns to implement the debugging techniques described above.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **Logging** | Python `logging` module with JSON formatter | Structured logging with `structlog` or `loguru` for context propagation |\n| **State Inspection** | `jq` command-line tool with Python wrapper | Custom web UI with React + D3 for visual state exploration |\n| **Graph Visualization** | Graphviz DOT format generation | Interactive visualization with `pyvis` or `networkx` + `matplotlib` |\n| **Debug UI** | CLI with rich tables via `rich` or `textual` | Web dashboard with FastAPI + WebSocket for real-time updates |\n| **Snapshot Management** | Directory of timestamped JSON files | Dedicated versioned store with content-addressable hashing |\n\n#### Recommended File Structure for Debugging Utilities\n\n```\niac-engine/\n  src/\n    iac/\n      debug/                    # Debugging utilities\n        __init__.py\n        logger.py               # Structured logging setup\n        state_inspector.py      # State file analysis tools\n        graph_exporter.py       # Graph visualization exports\n        snapshot_manager.py     # State snapshot management\n      cli/\n        commands/\n          debug.py              # Debug-specific CLI commands\n```\n\n#### Infrastructure Starter Code: Structured Logger\n\n```python\n# src/iac/debug/logger.py\nimport json\nimport logging\nimport uuid\nfrom datetime import datetime\nfrom typing import Any, Dict, Optional\nfrom contextvars import ContextVar\n\n# Correlation ID for tracing requests across components\ncorrelation_id: ContextVar[str] = ContextVar('correlation_id', default='')\n\nclass JsonFormatter(logging.Formatter):\n    \"\"\"Formats log records as JSON for machine parsing.\"\"\"\n    \n    def format(self, record: logging.LogRecord) -> str:\n        log_object = {\n            'timestamp': datetime.utcfromtimestamp(record.created).isoformat() + 'Z',\n            'level': record.levelname,\n            'logger': record.name,\n            'message': record.getMessage(),\n            'correlation_id': correlation_id.get(),\n            'module': record.module,\n            'function': record.funcName,\n            'line': record.lineno,\n        }\n        \n        # Add extra fields if present\n        if hasattr(record, 'extra'):\n            log_object.update(record.extra)\n            \n        # Add exception info if present\n        if record.exc_info:\n            log_object['exception'] = self.formatException(record.exc_info)\n            \n        return json.dumps(log_object)\n\ndef setup_logging(level: str = 'INFO', json_format: bool = False) -> None:\n    \"\"\"Configure logging for the IaC engine.\"\"\"\n    logger = logging.getLogger('iac')\n    logger.setLevel(getattr(logging, level.upper()))\n    \n    handler = logging.StreamHandler()\n    \n    if json_format:\n        handler.setFormatter(JsonFormatter())\n    else:\n        # Human-readable format for development\n        formatter = logging.Formatter(\n            '%(asctime)s [%(correlation_id)s] %(levelname)s %(name)s: %(message)s',\n            datefmt='%H:%M:%S'\n        )\n        handler.setFormatter(formatter)\n    \n    logger.addHandler(handler)\n    \n    # Set correlation ID filter\n    class CorrelationFilter(logging.Filter):\n        def filter(self, record: logging.LogRecord) -> bool:\n            record.correlation_id = correlation_id.get()\n            return True\n    \n    logger.addFilter(CorrelationFilter())\n\ndef log_operation(operation: str, **extra: Any) -> str:\n    \"\"\"Start a new operation with a correlation ID and log its beginning.\"\"\"\n    op_id = str(uuid.uuid4())[:8]\n    correlation_id.set(op_id)\n    \n    logger = logging.getLogger('iac')\n    logger.info(f\"Starting {operation}\", extra={'operation': operation, **extra})\n    \n    return op_id\n\n# Usage example:\n# from iac.debug.logger import setup_logging, log_operation\n# setup_logging(level='DEBUG')\n# op_id = log_operation('plan', config_path='main.tf')\n# # All subsequent logs will include this correlation_id\n```\n\n#### Infrastructure Starter Code: State Inspector\n\n```python\n# src/iac/debug/state_inspector.py\nimport json\nfrom pathlib import Path\nfrom typing import Dict, List, Any, Optional\nfrom dataclasses import dataclass\nfrom iac.state import StateRecord\n\n@dataclass\nclass StateReport:\n    \"\"\"Comprehensive analysis of a state file.\"\"\"\n    total_resources: int\n    resources_by_type: Dict[str, int]\n    orphaned_resources: List[str]  # Resources with missing dependencies\n    duplicate_addresses: List[str]  # Multiple resources with same address\n    validation_errors: List[str]\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            'total_resources': self.total_resources,\n            'resources_by_type': self.resources_by_type,\n            'orphaned_resources': self.orphaned_resources,\n            'duplicate_addresses': self.duplicate_addresses,\n            'validation_errors': self.validation_errors,\n            'is_valid': len(self.validation_errors) == 0\n        }\n\nclass StateInspector:\n    \"\"\"Tools for analyzing and debugging state files.\"\"\"\n    \n    @staticmethod\n    def load_state(state_path: Path) -> Dict[str, Any]:\n        \"\"\"Load state file with backup fallback.\"\"\"\n        from iac.state import read_json_with_backup\n        return read_json_with_backup(state_path)\n    \n    @staticmethod\n    def analyze(state_data: Dict[str, Any]) -> StateReport:\n        \"\"\"Perform comprehensive analysis of state data.\"\"\"\n        resources = state_data.get('resources', [])\n        \n        # Count by type\n        resources_by_type: Dict[str, int] = {}\n        for resource in resources:\n            rtype = resource.get('type', 'unknown')\n            resources_by_type[rtype] = resources_by_type.get(rtype, 0) + 1\n        \n        # Check for duplicates by address\n        addresses: Dict[str, int] = {}\n        duplicate_addresses: List[str] = []\n        for resource in resources:\n            addr = f\"{resource.get('type')}.{resource.get('name')}\"\n            addresses[addr] = addresses.get(addr, 0) + 1\n            if addresses[addr] > 1:\n                duplicate_addresses.append(addr)\n        \n        # Find orphaned resources (dependencies that don't exist)\n        orphaned_resources: List[str] = []\n        all_resource_addrs = {f\"{r.get('type')}.{r.get('name')}\" for r in resources}\n        \n        for resource in resources:\n            deps = resource.get('dependencies', [])\n            for dep in deps:\n                if dep not in all_resource_addrs:\n                    orphaned_resources.append(\n                        f\"{resource.get('type')}.{resource.get('name')} -> {dep}\"\n                    )\n        \n        # Collect validation errors\n        validation_errors: List[str] = []\n        \n        if duplicate_addresses:\n            validation_errors.append(\n                f\"Duplicate resource addresses: {', '.join(set(duplicate_addresses))}\"\n            )\n        \n        if orphaned_resources:\n            validation_errors.append(\n                f\"Resources with missing dependencies: {len(orphaned_resources)}\"\n            )\n        \n        return StateReport(\n            total_resources=len(resources),\n            resources_by_type=resources_by_type,\n            orphaned_resources=orphaned_resources,\n            duplicate_addresses=list(set(duplicate_addresses)),\n            validation_errors=validation_errors\n        )\n    \n    @staticmethod\n    def compare(state_a: Dict[str, Any], state_b: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Compare two state files and return differences.\"\"\"\n        resources_a = {f\"{r['type']}.{r['name']}\": r for r in state_a.get('resources', [])}\n        resources_b = {f\"{r['type']}.{r['name']}\": r for r in state_b.get('resources', [])}\n        \n        all_addrs = set(resources_a.keys()) | set(resources_b.keys())\n        \n        diff = {\n            'added': [],\n            'removed': [],\n            'modified': [],\n            'unchanged': []\n        }\n        \n        for addr in all_addrs:\n            if addr in resources_a and addr not in resources_b:\n                diff['removed'].append(addr)\n            elif addr not in resources_a and addr in resources_b:\n                diff['added'].append(addr)\n            elif resources_a[addr] == resources_b[addr]:\n                diff['unchanged'].append(addr)\n            else:\n                # Deep compare attributes\n                attrs_a = resources_a[addr].get('attributes', {})\n                attrs_b = resources_b[addr].get('attributes', {})\n                \n                # Simple attribute comparison (could be enhanced)\n                if attrs_a != attrs_b:\n                    diff['modified'].append({\n                        'address': addr,\n                        'attributes_changed': True\n                    })\n        \n        return diff\n\n# CLI command to inspect state\ndef inspect_state_command(state_path: Path, output_format: str = 'text') -> None:\n    \"\"\"CLI command for state inspection.\"\"\"\n    from iac.debug.state_inspector import StateInspector, StateReport\n    \n    state_data = StateInspector.load_state(state_path)\n    report = StateInspector.analyze(state_data)\n    \n    if output_format == 'json':\n        import json\n        print(json.dumps(report.to_dict(), indent=2))\n    else:\n        print(f\"State File: {state_path}\")\n        print(f\"Total Resources: {report.total_resources}\")\n        print(\"\\nResources by Type:\")\n        for rtype, count in report.resources_by_type.items():\n            print(f\"  {rtype}: {count}\")\n        \n        if report.duplicate_addresses:\n            print(f\"\\n⚠️  Duplicate Addresses: {len(report.duplicate_addresses)}\")\n            for addr in report.duplicate_addresses[:5]:  # Show first 5\n                print(f\"  {addr}\")\n        \n        if report.orphaned_resources:\n            print(f\"\\n⚠️  Orphaned Dependencies: {len(report.orphaned_resources)}\")\n            for orphan in report.orphaned_resources[:5]:\n                print(f\"  {orphan}\")\n        \n        if report.validation_errors:\n            print(f\"\\n❌ Validation Errors:\")\n            for error in report.validation_errors:\n                print(f\"  {error}\")\n        else:\n            print(\"\\n✅ State file appears valid\")\n```\n\n#### Core Logic Skeleton: Graph Visualization Exporter\n\n```python\n# src/iac/debug/graph_exporter.py\nfrom typing import Dict, List, Optional\nfrom iac.planner import DependencyGraphNode\n\nclass GraphExporter:\n    \"\"\"Exports dependency graphs to various visualization formats.\"\"\"\n    \n    @staticmethod\n    def to_dot(graph: Dict[str, DependencyGraphNode], \n               highlight_cycles: Optional[List[List[str]]] = None) -> str:\n        \"\"\"Export graph to Graphviz DOT format.\n        \n        Args:\n            graph: Dependency graph from build_graph\n            highlight_cycles: List of cycles to highlight in red\n            \n        Returns:\n            DOT format string for rendering with Graphviz\n        \"\"\"\n        # TODO 1: Initialize DOT string with digraph header and styling options\n        # Example: 'digraph G { rankdir=TB; node [shape=box];'\n        \n        # TODO 2: Add all nodes with labels\n        # For each node_id in graph.keys():\n        #   Create node with label like \"type.name\"\n        #   Format: '  \"aws_instance.web\" [label=\"aws_instance.web\"];'\n        \n        # TODO 3: Add all edges for dependencies\n        # For each node_id, node in graph.items():\n        #   For each dep in node.depends_on:\n        #     Add edge: '  \"aws_vpc.main\" -> \"aws_instance.web\";'\n        \n        # TODO 4: If highlight_cycles provided, color cycle nodes and edges\n        # For each cycle in highlight_cycles:\n        #   For node_id in cycle:\n        #     Add node attribute: '  \"node_id\" [color=red, penwidth=2];'\n        #   For edges within cycle:\n        #     Add edge attribute: '  \"a\" -> \"b\" [color=red, penwidth=2];'\n        \n        # TODO 5: Close the graph and return complete DOT string\n        pass\n    \n    @staticmethod\n    def to_mermaid(graph: Dict[str, DependencyGraphNode]) -> str:\n        \"\"\"Export graph to Mermaid.js format for web display.\n        \n        Returns:\n            Mermaid graph definition string\n        \"\"\"\n        # TODO 1: Start with 'graph TD' for top-down layout\n        \n        # TODO 2: Add all nodes with sanitized IDs\n        # Mermaid IDs can't contain dots, so convert 'aws_instance.web' to 'aws_instance_web'\n        \n        # TODO 3: Add all edges using Mermaid arrow syntax\n        # Format: 'aws_vpc_main --> aws_instance_web;'\n        \n        # TODO 4: Add click handlers for interactive debugging\n        # Format: 'click aws_instance_web callback \"show_resource_details\"'\n        \n        pass\n    \n    @staticmethod\n    def find_cycles(graph: Dict[str, DependencyGraphNode]) -> List[List[str]]:\n        \"\"\"Find all cycles in the graph using DFS.\n        \n        Returns:\n            List of cycles, where each cycle is a list of node IDs\n        \"\"\"\n        # TODO 1: Initialize visited set, recursion stack, and cycle list\n        \n        # TODO 2: Implement recursive DFS with cycle detection\n        # Use standard algorithm: white/gray/black sets for unvisited/visiting/visited\n        \n        # TODO 3: When back edge found (node in gray set), reconstruct cycle path\n        \n        # TODO 4: Return list of unique cycles (avoid duplicates)\n        pass\n```\n\n#### Debug CLI Command Skeleton\n\n```python\n# src/iac/cli/commands/debug.py\nimport click\nfrom pathlib import Path\nfrom typing import Optional\n\n@click.group(name=\"debug\")\ndef debug_cli():\n    \"\"\"Debugging commands for the IaC engine.\"\"\"\n    pass\n\n@debug_cli.command(\"state\")\n@click.argument(\"state_path\", type=click.Path(exists=True, path_type=Path))\n@click.option(\"--format\", type=click.Choice([\"text\", \"json\", \"html\"]), default=\"text\")\ndef state_inspect(state_path: Path, format: str):\n    \"\"\"Inspect and validate a state file.\"\"\"\n    from iac.debug.state_inspector import inspect_state_command\n    inspect_state_command(state_path, format)\n\n@debug_cli.command(\"graph\")\n@click.argument(\"config_path\", type=click.Path(exists=True, path_type=Path))\n@click.option(\"--output\", \"-o\", type=click.Path(path_type=Path), default=\"graph.png\")\n@click.option(\"--format\", type=click.Choice([\"dot\", \"mermaid\", \"png\", \"svg\"]), default=\"png\")\ndef graph_export(config_path: Path, output: Path, format: str):\n    \"\"\"Export dependency graph to visualization format.\"\"\"\n    # TODO 1: Parse configuration using process_configuration\n    \n    # TODO 2: Load state if exists\n    \n    # TODO 3: Build graph using build_graph\n    \n    # TODO 4: Export using GraphExporter based on format\n    \n    # TODO 5: If format is png/svg, call Graphviz to render\n    #   import subprocess\n    #   subprocess.run([\"dot\", \"-Tpng\", \"graph.dot\", \"-o\", output])\n    \n    click.echo(f\"Graph exported to {output}\")\n\n@debug_cli.command(\"replay\")\n@click.argument(\"snapshot_id\")\n@click.option(\"--step\", \"-s\", type=int, help=\"Execute only up to this step\")\ndef replay_snapshot(snapshot_id: str, step: Optional[int]):\n    \"\"\"Replay execution from a saved snapshot.\"\"\"\n    # TODO 1: Load snapshot by ID from snapshot manager\n    \n    # TODO 2: Restore state to snapshot state\n    \n    # TODO 3: If step provided, execute only up to that step\n    \n    # TODO 4: Provide interactive prompt to continue or inspect\n    click.echo(f\"Replaying snapshot {snapshot_id}\")\n\n# Register with main CLI\n# In main cli.py: cli.add_command(debug_cli)\n```\n\n#### Language-Specific Hints for Python\n\n1. **Use `pdb` or `ipdb` for interactive debugging**:\n   ```python\n   import ipdb; ipdb.set_trace()  # Add breakpoint\n   # Then inspect variables, step through code\n   ```\n\n2. **Leverage `inspect` module for runtime introspection**:\n   ```python\n   import inspect\n   print(inspect.getsource(compute_diff))  # View function source\n   print(inspect.signature(plan_command))  # View parameter signature\n   ```\n\n3. **Use `traceback` for better error context**:\n   ```python\n   import traceback\n   try:\n       apply_plan(plan, providers)\n   except Exception as e:\n       traceback.print_exc()  # Full stack trace\n       logger.error(\"Apply failed\", exc_info=True)  # Include in logs\n   ```\n\n4. **Profile performance bottlenecks**:\n   ```python\n   import cProfile\n   pr = cProfile.Profile()\n   pr.enable()\n   plan_command(config_path, state_path)\n   pr.disable()\n   pr.print_stats(sort='cumtime')\n   ```\n\n#### Milestone Checkpoint: Debugging Readiness\n\nAfter implementing the debugging utilities, verify they work:\n\n```bash\n# Test structured logging\npython -c \"from iac.debug.logger import setup_logging; setup_logging('DEBUG'); import logging; logging.getLogger('iac').info('Test log')\"\n\n# Test state inspection\npython src/iac/cli/main.py debug state terraform.tfstate --format=json\n\n# Test graph export (requires Graphviz installed)\npython src/iac/cli/main.py debug graph main.tf --output=dependency.png\n\n# Expected outputs:\n# - Logs appear in JSON format with correlation IDs\n# - State inspection shows resource counts and validation results\n# - dependency.png file created showing visual graph\n```\n\n**Signs something is wrong:**\n- Logs don't appear: Check logging level and handler configuration\n- State inspection crashes: State file may be malformed - add try/except\n- Graph export fails: Graphviz may not be installed (`brew install graphviz` or `apt-get install graphviz`)\n\nRemember: debugging is iterative. Start with logging, then add visualization, then build interactive tools as needed. The goal is to make the system's internal state as transparent as possible.\n\n\n## Future Extensions\n\n> **Milestone(s):** This section describes potential enhancements that build upon the core system and are relevant to all milestones (1, 2, 3, 4).\n\nThe foundational IaC engine we've designed provides a robust, extensible platform for managing infrastructure declaratively. By adhering to clean abstractions—particularly the separation between configuration, planning, and execution—the architecture can accommodate numerous enhancements without requiring fundamental redesign. This section explores several valuable extensions that could be built upon the existing components, each addressing a real-world operational need that mature IaC tools typically provide.\n\n### Possible Enhancements\n\nThe following enhancements represent natural evolution paths for the system, organized by the operational challenge they solve.\n\n#### Validation Webhook (Pre-Apply Policy Enforcement)\n\n**Mental Model: The Building Inspector**\n\n> Think of this enhancement as adding a building inspector who must approve the blueprints (execution plan) before any construction begins. The inspector reviews the plan against a set of safety codes (policies) and can either grant a permit (allow the apply) or require revisions (reject the plan).\n\nA validation webhook allows external systems to inspect and approve or reject an execution plan before it's applied. This is crucial for enforcing organizational policies (e.g., \"no S3 buckets can be publicly readable,\" \"all compute instances must have specific tags\") in an automated, non-bypassable way.\n\n| Component | Modification Required | Description |\n|-----------|-----------------------|-------------|\n| `Executor` | New `validate_plan` method | Instead of proceeding directly to `apply_plan`, the executor would first serialize the plan and send it to a configured webhook URL. |\n| `PlanAction` | None (serialization already exists via `JsonSerializable`) | The plan's `to_dict()` or `to_json()` would be used to create the payload. |\n| New: `WebhookValidator` | Entire new component | Handles HTTP communication, retries, timeout, and response parsing. Integrates with the `Executor`. |\n\n**Architecture Decision: Synchronous vs. Asynchronous Validation**\n\n> **Decision: Synchronous Validation with Timeout**\n> - **Context**: We need to guarantee policy enforcement before any resources are modified. The apply operation must wait for a definitive allow/deny decision.\n> - **Options Considered**:\n>   1. **Synchronous HTTP call**: The `apply_command` blocks, sends the plan to the webhook, and proceeds only after receiving an `APPROVE` response.\n>   2. **Asynchronous approval ticket**: The system creates a ticket (e.g., in a queue or issue tracker) and pauses. A separate human or automated process reviews and approves later, after which the apply resumes.\n> - **Decision**: Implement synchronous validation for fully automated pipelines, with a configurable timeout (e.g., 30 seconds).\n> - **Rationale**: Synchronous validation provides immediate feedback and fits seamlessly into CI/CD pipelines where the entire workflow must pass or fail in a single run. The timeout prevents the system from hanging indefinitely if the webhook is unresponsive.\n> - **Consequences**: Adds a critical dependency on the webhook service's availability. A down webhook will block all applies unless the feature is explicitly disabled. This can be mitigated with circuit breaker patterns in the `WebhookValidator`.\n\n**Integration Point**:\nThe `apply_command` would be extended with a new step between acquiring the state lock and beginning execution. A high-level algorithm would be:\n\n1. Generate the execution plan as usual.\n2. If a webhook URL is configured in the environment or config:\n   a. Serialize the plan and current state snapshot.\n   b. POST to the webhook with a correlation ID.\n   c. Wait for response (with timeout and retry for network errors).\n   d. If response contains `{\"result\": \"REJECTED\", \"reason\": \"...\"}`, abort the apply, release the lock, and output the rejection reason.\n   e. If response is `{\"result\": \"APPROVED\"}`, proceed to apply.\n3. If the webhook times out or returns an unexpected error, follow a configurable policy (fail open or fail closed).\n\n#### Policy-as-Code Integration\n\n**Mental Model: The Automated Rulebook**\n\n> This enhancement embeds a rulebook (policy engine) directly into the planning phase. Imagine a rulebook that automatically flags any blueprint line that violates company policy, similar to a spell-checker for infrastructure configurations.\n\nWhile a validation webhook is external, Policy-as-Code integrates policy evaluation directly into the engine, typically as a library (like Open Policy Agent - OPA). Policies are written in a dedicated language and evaluate the planned changes against rules that can be more complex than simple webhook checks (e.g., \"if the resource is in production, it must have at least two replicas\").\n\n| Integration Point | Design Approach |\n|-------------------|-----------------|\n| **Policy Evaluation Time** | During planning, after `generate_plan` but before output. Could also run during parsing for early syntax validation. |\n| **Policy Scope** | Can evaluate the entire config (`List[Resource]`), the computed diff (`Dict[str, PlanAction]`), or individual resources. |\n| **Policy Language** | Embed a generic engine (e.g., OPA Rego) or define a custom DSL. The `BaseProvider` could also contribute resource-specific validation schemas. |\n\n**Common Pitfalls and Solutions**:\n- ⚠️ **Pitfall: Performance degradation on large plans**.\n  - **Why it's wrong**: Evaluating complex policies against hundreds of resources can make the `plan` command unacceptably slow.\n  - **Fix**: Implement policy filtering (only run certain policies on certain resource types) and caching of policy query results. Consider a parallel evaluation mode.\n- ⚠️ **Pitfall: Policy rules conflict with provider validation**.\n  - **Why it's wrong**: A policy might reject a configuration that the cloud provider would actually accept, causing confusion.\n  - **Fix**: Clearly document that policies are for *organizational* guardrails, not syntax validation. Layer policies: syntax (provider schema) → semantics (policy) → runtime (webhook).\n\n**Example Workflow Addition**:\nA new `validate_policies` function could be added to the `Planner` component or as a separate `PolicyEngine` class. The `plan_command` would then:\n\n```plaintext\n1. Parse config -> desired resources.\n2. Read state.\n3. Build graph, compute diff, generate plan (as before).\n4. Call `policy_engine.validate(plan)`.\n5. If violations found, print them as warnings or errors (based on severity config) and optionally exit with a non-zero code.\n6. Continue to display plan.\n```\n\nThis keeps the policy evaluation inside the planning phase, giving users immediate feedback.\n\n#### Drift Detection Scheduler\n\n**Mental Model: The Periodic Inventory Auditor**\n\n> Imagine a warehouse manager who, every night, compares the official inventory log (state file) against a physical walkthrough of the shelves (actual cloud resources). Any discrepancies (drift) are recorded in a report for the morning shift.\n\nDrift detection is the process of periodically comparing the recorded state in the state file against the actual state in the cloud, identifying any changes made outside of the IaC tool (e.g., a console edit, CLI command, or another automation tool). Our architecture inherently supports this because the `Provider.read` method already knows how to fetch current state, and `compute_diff` can compare it to the recorded state.\n\n| New Component | Purpose |\n|---------------|---------|\n| `DriftDetector` | Orchestrates periodic refresh and diff. Could be a long-running daemon or a cron-triggered script. |\n| `DriftReport` | Extends `StateReport` with fields like `drifted_resources: List[Tuple[str, Dict[str, Any]]]` showing the resource address and the attributes that differ. |\n| Notification Integrations | Plugins to send drift reports via email, Slack, or incident management systems. |\n\n**Design Considerations**:\n\n1. **Detection Cadence**: Should be configurable per-resource or per-provider. Some resources change frequently (auto-scaling group instance count) and might be ignored.\n2. **State Refresh Strategy**: The `refresh_state` function (part of the executor) can be reused. However, a drift detection run should be *read-only* and must not acquire the state lock (or acquire it in shared read mode if implemented).\n3. **Handling Drift**: The system could generate an alert, automatically create a corrective plan, or even apply it (in auto-remediate mode). The safest initial implementation is alert-only.\n\n**Algorithm for Drift Detection Run**:\n1. For each provider configured, instantiate the provider with read-only credentials if possible.\n2. Load the state file (read-only, no lock).\n3. For each `StateRecord` in state:\n   a. Call `provider.read(resource_id, resource_type)`.\n   b. Compare returned attributes with `StateRecord.attributes`.\n   c. If any differences exist (ignoring certain metadata fields like timestamps), mark as drifted.\n4. Generate a `DriftReport` and trigger configured notifications.\n5. Optionally, if `auto_remediate: true`, call `plan_command` and `apply_command` with the current state and config to converge.\n\n**Integration with Existing Components**:\nThe `StateInspector` component (from our debugging guide) could be extended with a `detect_drift` method, leveraging the `compute_diff` function but with the \"desired\" state being the recorded state and the \"current\" state being the freshly read cloud state. A `drift_command` CLI command could be added.\n\n#### Workspace and Environment Management\n\n**Mental Model: The Construction Site Blueprint Copies**\n\n> Imagine you have one blueprint (configuration), but you need to build the same structure on three different construction sites (environments: dev, staging, prod). Each site has its own log of what's been built (state file) and slightly different characteristics (variables like size, location). The site manager needs to keep these contexts separate but use the same underlying plans.\n\nOur current design assumes a single state file path. In practice, teams manage multiple environments (dev/staging/prod) or multiple logical groupings (workspaces). This enhancement adds a layer of isolation, allowing the same configuration to be applied with different variable values and state files.\n\n| Concept | Implementation Approach |\n|---------|-------------------------|\n| **Workspace** | A named container for a distinct state file (e.g., `terraform.tfstate.d/dev/`). The workspace name becomes a prefix or suffix for the state file path. |\n| **Environment Variables** | Variable resolution would prioritize workspace-specific variable files (e.g., `dev.tfvars`) over generic ones. |\n| **State Isolation** | The `StateManager` would be extended to accept a `workspace` parameter, which it uses to construct the state and lock file paths (e.g., `terraform.tfstate.d/{workspace}/terraform.tfstate`). |\n\n**Required Changes**:\n- **CLI Commands**: Add `workspace list`, `workspace new`, `workspace select` commands to manage workspaces.\n- **State Manager**: Modify `read_state`, `write_state`, and `acquire_lock` to incorporate a workspace-aware path.\n- **Parser**: Extend variable resolution to load workspace-specific var files.\n\n**Architecture Decision: State File Organization**\n\n> **Decision: Directory-Based Workspace Isolation**\n> - **Context**: We need to store multiple state files for the same configuration root without conflict.\n> - **Options Considered**:\n>   1. **Directory per workspace**: `state.d/<workspace>/terraform.tfstate`.\n>   2. **State file with prefix/suffix**: `terraform-<workspace>.tfstate` in the same directory.\n>   3. **Database backend with workspace column**: Store all states in a single database table, keyed by config path + workspace.\n> - **Decision**: Use a directory-based approach (`state.d/<workspace>/`).\n> - **Rationale**: Simplicity and compatibility with file-based backup/restore tools. It mirrors Terraform's approach, making it familiar to users. Also, it works seamlessly with both local and remote (S3) backends using path prefixes.\n> - **Consequences**: Requires filesystem support for directories. Remote backends must support path prefixes (S3 does). Workspace switching becomes a matter of changing the current working directory or setting an environment variable.\n\n#### Advanced State Backends and Encryption\n\n**Mental Model: The Bank Vault Upgrade**\n\n> Initially, the ledger (state file) is kept in a filing cabinet (local disk). This enhancement moves it to a secure, replicated, access-controlled vault (remote backend with encryption and versioning).\n\nWhile Milestone 2 includes a remote backend (e.g., S3), advanced backends could include:\n- **Versioned State**: Every `write_state` creates a new version with a commit-like message, enabling rollback to previous states.\n- **State Encryption**: Encrypt the state file at rest using customer-managed keys (CMK) or a hardware security module (HSM) integration.\n- **State Query API**: Expose a read-only HTTP API for other tools to query the current state (e.g., \"list all EC2 instance IPs\").\n\n**Design Extension**: The `StateManager` would use a backend interface, similar to the `BaseProvider` pattern. Different backends (local, S3, HTTP API, database) would implement this interface. Encryption could be a wrapper backend that encrypts/decrypts data before passing it to the underlying backend.\n\n```plaintext\ninterface StateBackend:\n    read_state(workspace: str) -> Dict[str, StateRecord]\n    write_state(workspace: str, state_data: Dict[str, StateRecord], version_metadata: Optional[Dict]) -> None\n    lock_state(workspace: str, info: Dict) -> LockHandle\n    unlock_state(workspace: str, lock_handle: LockHandle) -> None\n```\n\n**Integration Example**: To add versioning, the `write_state` method would accept optional metadata (like a user, timestamp, and comment). The S3 backend could use S3 versioning, and also store metadata in a separate manifest file. The `state_inspect_command` could then list versions and show diffs between them.\n\n#### Resource Import and State Surgery\n\n**Mental Model: The Archaeologist's Catalog**\n\n> When discovering ancient artifacts already in the ground, an archaeologist doesn't build them—they carefully catalog them and bring them into the museum's inventory system. Similarly, this feature allows bringing existing cloud resources under IaC management.\n\nResource import is the process of taking an existing cloud resource that wasn't created by the IaC engine and adding it to the state file, so that future plans can manage it. This requires:\n1. Identifying the resource's cloud-side ID and attributes.\n2. Matching it to a resource block in the configuration.\n3. Writing a `StateRecord` for it without performing a create operation.\n\n**How the Architecture Supports It**: The `Provider.read` method already fetches current attributes. We would add a new `import_resource` method to the `BaseProvider` interface that takes a resource address and cloud ID, reads the resource, and returns a `StateRecord`. The `StateManager` would then write this record. The tricky part is ensuring the configuration matches; a dry-run or validation step is needed.\n\n**New CLI Command**: `import_command <resource_address> <cloud_id>` would:\n1. Parse config to find the resource definition.\n2. Call `provider.import_resource(resource_address, cloud_id)`.\n3. Add the returned `StateRecord` to the state (with a lock).\n4. Output a summary.\n\nThis feature highlights the power of the clear separation between state and configuration: import only manipulates state, leaving the configuration unchanged.\n\n#### Advanced Execution Strategies\n\n**Mental Model: The Traffic Controller for Construction Crews**\n\n> Instead of sending all construction crews to the site at once, a traffic controller staggers their arrival, monitors for accidents, and can reroute or pause new crews if problems arise.\n\nOur current `Executor` applies the plan in dependency order with basic concurrency. Advanced strategies could include:\n- **Canary Apply**: Apply changes to a small subset of resources first (e.g., one availability zone), verify health, then proceed to the rest.\n- **Blue-Green Deployment**: For resources like load balancers or ASGs, create a new parallel set of resources (green), switch traffic, then delete the old (blue).\n- **Automatic Rollback on Failure**: If a certain percentage of resources fail during apply, automatically revert the changes by applying the previous state.\n\n**Design Implications**: These strategies require the `Executor` to have more sophisticated control flow, potentially grouping resources into stages and monitoring outcomes. The `PlanAction` might need additional metadata (like resource tags for canary grouping). The `apply_plan` algorithm would evolve from a simple loop to a state machine orchestrating stages.\n\nWhile these strategies are complex, the foundational building blocks—dependency graph, plan generation, and provider CRUD—remain the same. The enhancement would be a new `StrategicExecutor` that wraps or extends the basic `Executor`.\n\n### Summary of Architectural Flexibility\n\nThe table below summarizes how the core architecture's design decisions enable these extensions:\n\n| Architectural Feature | Enabled Extensions | Rationale |\n|----------------------|-------------------|-----------|\n| **Provider Plugin Interface** (`BaseProvider`) | New cloud services, policy engines, state backends | The interface abstraction allows new capabilities to be added via plugins without modifying core engine code. |\n| **Explicit State Serialization** (`StateRecord`, `JsonSerializable`) | Drift detection, versioning, import, webhook validation | The state is a serializable, well-defined data structure that can be easily read, compared, and transmitted. |\n| **Declarative Resource Model** (`Resource` vs. `StateRecord`) | Policy-as-code, visualization, advanced planning | The clear separation between desired (config) and actual (state) enables analysis and transformation at multiple points. |\n| **Dependency Graph as First-Class Construct** (`DependencyGraphNode`) | Execution strategies, visualization, impact analysis | The explicit graph structure can be traversed, filtered, and displayed for various operational needs. |\n| **Modular Component Design** (Parser, State, Planner, Executor) | Workspace management, scheduler integration | Components have clean interfaces, allowing them to be wrapped or extended independently (e.g., a scheduler that calls the parser and planner). |\n\n> **Key Insight**: The most valuable architectural decision for extensibility was enforcing a unidirectional data flow: Configuration → Resources → Plan → Execution → Updated State. This pipeline model allows \"middleware\" components (like policy checkers, webhooks, or drift detectors) to intercept and process data at clear stages without side-effects on other stages.\n\nBy building upon these solid foundations, the IaC engine can evolve from a simple configuration applier to a comprehensive infrastructure governance platform, all while maintaining the core principles of safety, idempotency, and declarative intent that make IaC powerful.\n\n---\n\n\n## Glossary\n\n> **Milestone(s):** This section defines key terminology used throughout the design document and is relevant to all milestones (1, 2, 3, 4).\n\nA shared vocabulary is essential for clear communication about a complex system. This glossary defines the key terms, acronyms, and domain-specific language used throughout this design document and the Infrastructure as Code (IaC) engine implementation.\n\n### Term Definitions\n\n| Term | Definition | Related Concepts & Notes |\n| :--- | :--- | :--- |\n| **`ActionType`** | An enumeration representing the four fundamental operations the engine can perform on a resource: `CREATE`, `UPDATE`, `DELETE`, and `NOOP`. | **`PlanAction`** objects have an `action_type` field of this type. `NOOP` indicates the resource already matches the desired state. |\n| **`ApplyResult`** | A data structure (`ApplyResult`) returned by the executor for each resource action attempted during an apply operation. It records success/failure, the resulting state, any errors, and retry counts. | Used for reporting and handling **partial apply** failures. Contains fields: `resource_address`, `success`, `new_state`, `error`, `retries`. |\n| **Atomic Operation** | An operation that either completes fully or not at all, with no observable intermediate state. In state management, **atomic file writes** (via rename) prevent **state corruption** from partial writes. | Contrasts with non-atomic operations. Implemented via `write_atomic_json`. |\n| **BaseProvider** | The core interface (`BaseProvider`) that all cloud provider plugins must implement. It defines the standard CRUD operations (`create`, `read`, `update`, `delete`) and configuration validation (`validate_credentials`). | Enables **polymorphism**; the **Executor** interacts with all providers through this interface. |\n| **Circuit Breaker** | A resilience pattern that stops calling a failing service after a threshold of failures is reached, allowing it time to recover. It fails fast (**fail-fast**) instead of wasting resources on likely failures. | Implemented by the `CircuitBreaker` class. When open, calls result in a `CircuitOpenError`. Helps manage **rate limiting** and **transient provider errors**. |\n| **ConfigurationError** | A subclass of `IaCError` raised when there is a problem with the user's configuration files, such as invalid syntax, undefined variables, or invalid resource schemas. | Handled during the parsing and validation phase (**Milestone 1**). |\n| **Correlation ID** | A unique identifier attached to a single operation (e.g., an `apply` command) and included in all logs and requests related to that operation. Enables tracing the flow of execution across components for debugging. | Part of **structured logging** via `log_operation`. |\n| **CRUD** | Acronym for **Create, Read, Update, Delete**—the four basic operations of persistent storage. The `BaseProvider` interface is a CRUD interface for cloud resources. | |\n| **DAG (Directed Acyclic Graph)** | A **directed graph** with no cycles, used to model resource dependencies. The **Planner** builds a DAG where nodes are resources and edges represent \"depends on\" relationships. | **Topological sort** requires a DAG. **Cycle detection** is performed to ensure the graph is acyclic. |\n| **Declarative Configuration** | An approach where the user specifies the *desired end state* of the infrastructure (what resources should exist and their properties), not the step-by-step commands to achieve it. The IaC engine's job is to figure out and execute the necessary changes. | Contrasts with *imperative* or *procedural* approaches (e.g., scripts). Central philosophy of this project. |\n| **Dependency Graph** | A graph representation of resource dependencies, built by the **Planner**. Implemented as a collection of `DependencyGraphNode` objects. | Used to determine the correct order of operations during `apply`. |\n| **`DependencyGraphNode`** | A data structure representing a single resource within the **dependency graph**. It contains the resource's unique address and lists of resources it `depends_on` and is `required_by`. | Fields: `resource_id`, `depends_on`, `required_by`. |\n| **Diff** | The comparison between the **desired state** (derived from configuration) and the **current state** (from the state file) for a specific resource. The result of this comparison determines the `PlanAction` (`CREATE`, `UPDATE`, `DELETE`, `NOOP`). | Computed by `compute_diff`. |\n| **Directed Acyclic Graph (DAG)** | See **DAG**. |\n| **Eventual Consistency** | A property of many cloud APIs where a change (e.g., creating a resource) is not immediately reflected in all subsequent read requests. The system guarantees consistency only after an undefined period. | A major challenge for providers; requires robust **retry logic** and **state refresh**. |\n| **Execution Plan** | The final output of the `plan` command: an ordered list of `PlanAction` objects specifying the precise create, update, and delete operations needed to converge current state to desired state. | The \"what will happen\" preview shown to the user before `apply`. |\n| **Executor** | The component (**Component Design: Provider Abstraction & Executor**) responsible for carrying out an **execution plan**. It orchestrates calls to **providers**, handles **concurrency**, **retries**, and updates the **state**. | Calls `apply_plan`. |\n| **Exponential Backoff** | A retry strategy where the delay between retries increases exponentially (e.g., 1s, 2s, 4s, 8s). Often combined with **jitter** to prevent synchronized retry storms from multiple clients. | Implemented via the `retry_with_backoff` decorator for handling **transient provider errors**. |\n| **Fail-fast** | A design approach where a system immediately reports an error condition rather than attempting to proceed in an invalid or degraded state. The **circuit breaker** pattern is a form of fail-fast for downstream service failures. | |\n| **Graph Visualization** | The process of generating a visual diagram (e.g., DOT, Mermaid) of the **dependency graph** to aid in understanding and debugging resource relationships. | The `GraphExporter` class provides methods like `to_dot` and `to_mermaid`. |\n| **HCL (HashiCorp Configuration Language)** | A declarative configuration language created by HashiCorp, used by Terraform. It is a **DSL** designed for defining infrastructure. This project parses an HCL-like syntax. | |\n| **IaC (Infrastructure as Code)** | The practice of managing and provisioning computing infrastructure through machine-readable definition files, rather than physical hardware configuration or interactive configuration tools. | The overarching domain of this project. |\n| **`IaCError`** | The base exception class for all errors thrown by the IaC engine. Specific error types like `ConfigurationError`, `StateError`, and `ProviderError` inherit from it. | Allows for centralized error handling and logging. |\n| **Idempotent** | An operation is idempotent if performing it multiple times has the same effect as performing it once. For example, issuing the same `CREATE` API call twice should result in one resource, not two. A core requirement for **provider** operations. | Ensures safety of retries and re-running plans. |\n| **Jitter** | Random variation added to retry delays (e.g., +/- 0.5 seconds). Prevents many clients from retrying simultaneously (a \"thundering herd\" problem) after a service outage, which could cause a new outage upon recovery. | Used with **exponential backoff**. |\n| **`JsonSerializable`** | A mixin class providing standard `to_dict`, `from_dict`, `to_json`, and `from_json` methods. Core data types like `Resource` and `StateRecord` inherit from it to simplify serialization for the **state file**. | |\n| **`LockHandle`** | An object returned by `acquire_lock` representing an acquired state lock. It contains metadata (lock path, process ID, lock ID) and manages a **heartbeat thread** to prevent the lock from becoming **stale**. | Must be passed to `release_lock` to cleanly release the lock. |\n| **`PartialApplyError`** | A special exception raised when an `apply` operation completes for some resources but fails for others. It contains a dictionary of succeeded resources so the state can be partially updated. | Prevents losing track of **zombie resources** created before the failure. |\n| **`PermanentProviderError`** | A subclass of `ProviderError` indicating a failure that is not retryable (e.g., invalid credentials, unsupported resource type, validation error). The engine should stop immediately. | Contrast with `TransientProviderError`. |\n| **`PlanAction`** | A data structure representing a single change to be made to a resource. It includes the `action_type` (`CREATE`, `UPDATE`, `DELETE`, `NOOP`), the `resource` (desired state), and optionally the `prior_state` and `new_state`. | The building block of an **execution plan**. Generated by `generate_plan`. |\n| **Planner** | The component (**Component Design: Planner**) responsible for building the **dependency graph**, performing **topological sort**, and generating the **execution plan**. It answers \"what needs to change and in what order?\" | Key methods: `build_graph`, `validate_acyclic`, `topological_sort`, `generate_plan`. |\n| **Provider** | A plugin that translates the engine's generic CRUD operations into API calls for a specific cloud platform or service (e.g., AWS, Azure, Google Cloud). Implements the `BaseProvider` interface. | The extensibility point of the system; new clouds are supported by writing new providers. |\n| **`ProviderConfig`** | A data structure holding configuration for a specific provider instance, such as credentials, region, and endpoint overrides. | Fields: `provider_type`, `config`. |\n| **`ProviderError`** | The base exception class for errors originating from a **provider** (e.g., API failures). Subclassed into `TransientProviderError` and `PermanentProviderError`. | |\n| **Rate Limiting** | Restrictions imposed by cloud APIs on the frequency or volume of requests from a client. Exceeding limits results in throttling errors (HTTP 429). | Must be handled by providers using **exponential backoff** and **jitter**. |\n| **`Resource`** | The fundamental data structure representing a unit of infrastructure as defined in configuration (e.g., an AWS EC2 instance, a Google Cloud Storage bucket). It has a type, a unique name within that type, and a set of attributes. | Fields: `id`, `type`, `name`, `attributes`. The `id` is initially empty and populated by the provider after creation. |\n| **State Drift** | The situation where the actual state of a resource in the cloud diverges from the state recorded in the **state file**. This can happen due to manual changes, direct API calls, or other IaC tools. | The engine's `refresh_state` operation can detect drift by calling `provider.read`. |\n| **State File** | A persistent file (typically JSON) that stores the last known state of all managed infrastructure as a dictionary of `StateRecord` objects, keyed by resource address. It is the **single source of truth** for what the engine believes is deployed. | Managed by the **State Manager**. |\n| **State Inspection** | The process of analyzing the **state file** for issues like orphaned resources, duplicates, or validation errors. Performed by the `StateInspector` class and the `inspect_state_command` CLI command. | Useful for debugging and maintenance. |\n| **`StateInspector`** | A utility class providing methods to load, analyze, and compare state files. | Methods: `load_state`, `analyze`, `compare`. |\n| **State Manager** | The component (**Component Design: State Manager**) responsible for persisting and managing the **state file**, handling **locking** to prevent concurrent modifications, and computing **diffs** between states. | Key methods: `read_state`, `write_state`, `acquire_lock`, `compute_diff`. |\n| **`StateRecord`** | A data structure representing a snapshot of a `Resource` as it exists (or is believed to exist) in the cloud. It is what is stored in the **state file**. It includes the cloud-assigned `resource_id` and tracks `dependencies`. | Fields: `resource_id`, `resource_type`, `resource_name`, `attributes`, `dependencies`. |\n| **`StateReport`** | The output of a state inspection, containing statistics and identified issues. | Fields: `total_resources`, `resources_by_type`, `orphaned_resources`, `duplicate_addresses`, `validation_errors`. |\n| **Structured Logging** | A logging practice where log messages are emitted in a machine-parsable format (like JSON) with consistent, named fields (e.g., `timestamp`, `level`, `correlation_id`, `component`, `message`). Greatly aids in debugging and log analysis. | Configured via `setup_logging`. |\n| **Topological Sort** | A linear ordering of the nodes in a **DAG** such that for every directed edge from node *u* to node *v*, *u* appears before *v* in the ordering. This provides a safe execution order for resources. | Implemented by the `topological_sort` function in the **Planner**. |\n| **`TransientProviderError`** | A subclass of `ProviderError` indicating a failure that might be temporary and is worth retrying (e.g., network timeout, rate limit, internal server error). The engine will apply **retry logic**. | Contrast with `PermanentProviderError`. |\n| **Zombie Resource** | A resource that exists in the cloud but is not recorded in the **state file**. This can happen if a resource is created (e.g., by a **partial apply** failure) but the state update fails. The engine loses the ability to manage it. | Mitigated by **atomic state updates** and careful error recovery in the **Executor**. |\n"}