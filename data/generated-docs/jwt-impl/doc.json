{"html":"<h1 id=\"jwt-library-design-document\">JWT Library: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>This system implements a JSON Web Token library for secure authentication and authorization workflows. The key architectural challenge is building a cryptographically secure token system that properly handles signing, verification, and claims validation while avoiding common security pitfalls like timing attacks and algorithm confusion.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<h2 id=\"context-and-problem-statement\">Context and Problem Statement</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundation for all milestones - understanding the authentication problem space</p>\n</blockquote>\n<p>Modern applications face a fundamental challenge: how to securely identify and authorize users across distributed systems. When a user logs into a web application, mobile app, or API service, the system must answer two critical questions: &quot;Who is this user?&quot; (authentication) and &quot;What are they allowed to do?&quot; (authorization). Traditional session-based authentication works well for monolithic applications but breaks down in distributed architectures with microservices, single-page applications, and mobile clients.</p>\n<p>The core problem is <strong>stateful vs. stateless authentication</strong>. Session cookies require server-side storage to maintain user state, creating coupling between authentication and storage systems. This approach becomes problematic when requests need to flow between multiple services, each of which would need access to the shared session store. Additionally, mobile applications and single-page applications have different security constraints than traditional server-rendered web pages, making cookie-based sessions inadequate.</p>\n<p>JSON Web Tokens (JWTs) solve this problem by providing <strong>self-contained, stateless authentication tokens</strong>. Rather than storing user information on the server and referencing it with a session ID, JWTs embed the user information directly in the token itself. The token is cryptographically signed, making it tamper-evident without requiring server-side storage for validation.</p>\n<p>However, building a secure JWT implementation is deceptively challenging. While the basic concept appears straightforward—encode some JSON, sign it, and verify the signature—the security details are complex and unforgiving. Common vulnerabilities include timing attacks during signature verification, algorithm confusion attacks where attackers manipulate the signing algorithm, improper handling of time-based claims leading to replay attacks, and encoding issues that can corrupt token data.</p>\n<blockquote>\n<p><strong>Key Insight</strong>: JWTs shift the complexity from session management (storing state) to cryptographic verification (validating signatures and claims). This trade-off enables stateless, distributed authentication but requires careful attention to cryptographic security principles.</p>\n</blockquote>\n<p>The challenge extends beyond basic signing and verification. Real-world JWT usage requires robust claims validation—checking that tokens haven&#39;t expired, that they&#39;re issued by trusted parties, and that they&#39;re intended for the current application. Time-based security adds another layer of complexity, as systems must handle clock skew between servers, leap seconds, and edge cases around token expiration boundaries.</p>\n<h3 id=\"mental-model-the-concert-wristband\">Mental Model: The Concert Wristband</h3>\n<p>To understand JWT concepts intuitively, imagine the authentication system used at a large music festival. Traditional session-based authentication is like a <strong>will-call system</strong>: when you arrive, security checks your ID against a central database, gives you a generic entry stamp, and every time you want to access different areas (VIP section, backstage, food vendors), security must radio back to the central database to verify your privileges.</p>\n<p>JWTs work like <strong>sophisticated wristbands</strong> that contain all your information directly on the band itself. When you first authenticate (show your ticket and ID), instead of just getting a generic stamp, you receive a wristband that contains:</p>\n<ul>\n<li><strong>Header information</strong> (like the wristband material): What type of security system this is and how it&#39;s protected</li>\n<li><strong>Your details</strong> (like text printed on the band): Your identity, what areas you can access, when your access expires, which stages you&#39;re allowed near</li>\n<li><strong>Security seal</strong> (like a tamper-evident hologram): A cryptographic signature that proves the wristband was issued by official festival security and hasn&#39;t been modified</li>\n</ul>\n<p>The key advantages of this wristband system mirror JWT benefits:</p>\n<p><strong>Self-contained verification</strong>: Security guards at any stage don&#39;t need to radio back to a central database. They can look at your wristband, verify the security seal is intact and authentic, check that you&#39;re authorized for this area, and make an immediate access decision.</p>\n<p><strong>Distributed access control</strong>: Different vendors, stages, and areas can all independently verify your wristband without coordinating with each other or maintaining shared state.</p>\n<p><strong>Expiration handling</strong>: The wristband itself contains expiration information (&quot;Valid until Sunday 11:59 PM&quot;), so guards know when access should be revoked without consulting external systems.</p>\n<p>However, this system also introduces the same challenges as JWTs:</p>\n<p><strong>Security seal integrity</strong>: If someone could forge or modify the holographic seal, they could create fake wristbands or upgrade their access level. Similarly, JWT signature verification must be cryptographically secure.</p>\n<p><strong>Time synchronization</strong>: Guards need to know the current time to check expiration, and their clocks must be reasonably synchronized. If a guard&#39;s watch is hours off, they might accept expired wristbands or reject valid ones.</p>\n<p><strong>Revocation complexity</strong>: If someone&#39;s wristband needs to be revoked mid-festival (they violated rules), there&#39;s no easy way to communicate this to all security guards since the system is designed to work without central coordination.</p>\n<p><strong>Information exposure</strong>: Unlike a generic stamp, the wristband contains detailed information about the person and their privileges. If someone can read the wristband, they learn about the user&#39;s access level and identity.</p>\n<p>This mental model helps explain why JWT implementation requires careful attention to cryptographic signatures (the security seal), time-based claim validation (expiration checking), and why certain operations like token revocation are inherently challenging in a stateless system.</p>\n<h3 id=\"existing-token-approaches\">Existing Token Approaches</h3>\n<p>Understanding JWT requires comparing it with alternative authentication approaches, each with distinct trade-offs in complexity, security, and architectural flexibility.</p>\n<table>\n<thead>\n<tr>\n<th>Approach</th>\n<th>State Management</th>\n<th>Verification Process</th>\n<th>Distribution Support</th>\n<th>Security Model</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Session Cookies</td>\n<td>Server-side storage required</td>\n<td>Database lookup on every request</td>\n<td>Poor - requires shared storage</td>\n<td>Server controls all state</td>\n</tr>\n<tr>\n<td>API Keys</td>\n<td>Server-side storage typical</td>\n<td>Database/cache lookup</td>\n<td>Moderate - can be cached</td>\n<td>Long-lived, hard to rotate</td>\n</tr>\n<tr>\n<td>Bearer Tokens (Opaque)</td>\n<td>Server-side storage required</td>\n<td>Token introspection endpoint</td>\n<td>Good - centralized validation</td>\n<td>Server controls validation</td>\n</tr>\n<tr>\n<td>JWTs</td>\n<td>Stateless - no storage needed</td>\n<td>Cryptographic signature check</td>\n<td>Excellent - fully distributed</td>\n<td>Cryptographic proof</td>\n</tr>\n</tbody></table>\n<h4 id=\"session-cookies-the-traditional-approach\">Session Cookies: The Traditional Approach</h4>\n<p>Session cookies represent the classical web authentication model. When a user logs in, the server generates a random session identifier, stores user information associated with that ID in a database or memory store, and sends the session ID to the client as an HTTP cookie. On subsequent requests, the server looks up the session ID to retrieve user information.</p>\n<p><strong>Advantages</strong>: Session cookies provide strong security guarantees because the server maintains complete control over session state. Sessions can be immediately revoked by deleting the server-side record. The session ID itself contains no sensitive information, limiting exposure if intercepted. Cookie security features like <code>HttpOnly</code>, <code>Secure</code>, and <code>SameSite</code> provide robust protection against common web attacks.</p>\n<p><strong>Limitations</strong>: The requirement for server-side storage creates significant architectural constraints. Multiple application servers must share a session store, introducing a stateful component that must be highly available and consistent. Microservices architectures become complex as each service needs access to the shared session state or must proxy authentication through a central service. Mobile applications and single-page applications have limited cookie support, especially for cross-origin requests. Horizontal scaling requires session store replication or sticky load balancing.</p>\n<blockquote>\n<p><strong>Architectural Insight</strong>: Session cookies optimize for security and immediate revocation at the cost of architectural flexibility. They work excellently for traditional server-rendered web applications but become impediments in modern distributed architectures.</p>\n</blockquote>\n<h4 id=\"api-keys-simple-but-limited\">API Keys: Simple but Limited</h4>\n<p>API keys provide a straightforward authentication mechanism where clients include a long-lived secret key with each request, typically in an HTTP header like <code>Authorization: Bearer api-key-12345</code>. The server validates the key against a database of registered keys and associated permissions.</p>\n<p><strong>Advantages</strong>: API keys are conceptually simple for both implementers and consumers. They work well for machine-to-machine authentication and service integration scenarios. Keys can be easily generated, distributed, and managed through administrative interfaces. They have excellent tooling support and are widely understood by developers.</p>\n<p><strong>Limitations</strong>: API keys are typically long-lived, making rotation complex and risky. They provide coarse-grained authorization—usually all-or-nothing access rather than fine-grained permissions. Revocation requires server-side storage lookup on every request. Keys often end up hardcoded in client applications or configuration files, creating security risks. They lack built-in expiration mechanisms, requiring external systems for time-based access control.</p>\n<p><strong>Use Cases</strong>: API keys excel in server-to-server scenarios where security requirements are moderate and simplicity is valued over sophisticated access control. They&#39;re common for public API access, webhook authentication, and internal service communication.</p>\n<h4 id=\"bearer-tokens-opaque-oauth2-standard\">Bearer Tokens (Opaque): OAuth2 Standard</h4>\n<p>Opaque bearer tokens, standardized in OAuth2, provide a middle ground between sessions and JWTs. Clients receive a token (usually a random string) during authentication and include it in an <code>Authorization: Bearer</code> header. The server validates tokens by calling a token introspection endpoint or checking against a token database.</p>\n<p><strong>Advantages</strong>: Bearer tokens separate authentication from authorization, allowing specialized authorization servers. They support sophisticated OAuth2 flows for third-party application integration. Tokens can be revoked immediately by updating the central token registry. They work well across different client types (web, mobile, server) and support fine-grained scope-based permissions.</p>\n<p><strong>Limitations</strong>: Token validation requires a network call to the authorization server or shared database access, creating latency and availability dependencies. The introspection endpoint becomes a bottleneck and single point of failure. Caching tokens for performance creates a trade-off with revocation timeliness. The OAuth2 specification complexity can lead to implementation errors and security vulnerabilities.</p>\n<p><strong>Use Cases</strong>: OAuth2 bearer tokens are ideal for scenarios requiring immediate revocation, third-party application integration, or complex authorization flows. They&#39;re common in enterprise API gateways and identity provider integrations.</p>\n<h4 id=\"jwts-self-contained-tokens\">JWTs: Self-Contained Tokens</h4>\n<p>JWTs take a fundamentally different approach by encoding all necessary information directly into the token itself, secured with cryptographic signatures. Rather than requiring server-side lookups, consuming services can independently verify and extract information from the token.</p>\n<p><strong>Advantages</strong>: JWTs enable truly stateless authentication, eliminating the need for shared databases or session stores. They scale horizontally without coordination between servers. Microservices can independently verify tokens without calling back to authentication services. They work excellently across different client types and support cross-origin requests naturally. Token validation is fast—just signature verification and claims checking without network calls.</p>\n<p><strong>Limitations</strong>: Token revocation is complex since there&#39;s no central registry to update. Tokens can become large if they contain extensive claims information, increasing bandwidth usage. All services must have access to signing keys or key verification capabilities. Time-based security requires synchronized clocks across all services. Sensitive information in tokens is base64-encoded (not encrypted) and readable by clients.</p>\n<blockquote>\n<p><strong>Decision: JWT vs. Alternatives for Distributed Systems</strong></p>\n<ul>\n<li><strong>Context</strong>: Modern applications increasingly use microservices architectures, single-page applications, and mobile clients that make frequent API calls across service boundaries</li>\n<li><strong>Options Considered</strong>: Session cookies with shared storage, OAuth2 bearer tokens with introspection, JWTs with local verification</li>\n<li><strong>Decision</strong>: JWTs provide the best balance of security, performance, and architectural flexibility for distributed systems</li>\n<li><strong>Rationale</strong>: Stateless verification eliminates shared storage dependencies, reduces latency by avoiding network calls during validation, and enables independent service scaling. The complexity of cryptographic implementation is offset by simplified deployment and operational characteristics</li>\n<li><strong>Consequences</strong>: Teams must invest in secure JWT implementation but gain architectural flexibility and improved performance. Token revocation requires alternative strategies like short expiration times and refresh token patterns</li>\n</ul>\n</blockquote>\n<p>The choice between these approaches depends on specific architectural requirements, security constraints, and operational capabilities. JWTs excel in distributed environments where stateless operation and performance are priorities, while session cookies remain optimal for traditional web applications with strong revocation requirements. Understanding these trade-offs is essential for making informed authentication architecture decisions.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>Building a JWT library requires careful selection of cryptographic primitives, proper project organization, and a clear understanding of the security requirements that distinguish production-ready implementations from educational examples.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JSON Handling</td>\n<td><code>json</code> standard library</td>\n<td><code>ujson</code> or <code>orjson</code> for performance</td>\n<td>Standard library provides consistency; advanced parsers optimize for speed but add complexity</td>\n</tr>\n<tr>\n<td>Base64URL Encoding</td>\n<td>Custom implementation using <code>base64</code></td>\n<td><code>python-jose</code> library functions</td>\n<td>Educational value in implementing encoding; libraries provide battle-tested edge case handling</td>\n</tr>\n<tr>\n<td>HMAC Computation</td>\n<td><code>hmac</code> standard library</td>\n<td><code>cryptography</code> library</td>\n<td>Standard library sufficient for HS256; cryptography library needed for RSA/ECDSA algorithms</td>\n</tr>\n<tr>\n<td>Time Handling</td>\n<td><code>datetime</code> with UTC enforcement</td>\n<td><code>arrow</code> or <code>pendulum</code> libraries</td>\n<td>UTC handling is critical; advanced libraries provide better timezone and parsing support</td>\n</tr>\n<tr>\n<td>Secret Management</td>\n<td>Environment variables</td>\n<td><code>keyring</code> or dedicated secret management</td>\n<td>Environment variables work for development; production requires proper secret rotation</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-project-structure\">Recommended Project Structure</h4>\n<p>Organize the JWT library into focused modules that separate concerns and enable incremental development:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>jwt-library/\n  src/jwt_lib/\n    __init__.py              ← Public API exports\n    encoder.py               ← Token encoding and Base64URL (Milestone 1)\n    signer.py                ← HMAC signing and verification (Milestone 2)\n    validator.py             ← Claims validation logic (Milestone 3)\n    exceptions.py            ← JWT-specific exception classes\n    models.py                ← Data classes for headers, payloads, tokens\n    utils.py                 ← Shared utilities (time handling, constants)\n  tests/\n    test_encoder.py          ← Encoding and structure tests\n    test_signer.py           ← Cryptographic operation tests\n    test_validator.py        ← Claims validation tests\n    test_vectors.py          ← RFC test vectors and reference data\n    conftest.py              ← Pytest fixtures and test utilities\n  examples/\n    basic_usage.py           ← Simple token creation and verification\n    web_integration.py       ← Flask/FastAPI integration example\n    microservice_auth.py     ← Service-to-service authentication\n  docs/\n    security_considerations.md ← Deployment and security guidance</code></pre></div>\n\n<p>This structure enables milestone-based development where each component can be built and tested independently before integration.</p>\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Complete Time Utilities Module (<code>utils.py</code>)</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Utilities for JWT time handling and validation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Handles UTC enforcement, clock skew tolerance, and timestamp conversion.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Union</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Default clock skew tolerance (5 minutes)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">DEFAULT_LEEWAY_SECONDS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 300</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> utc_now</span><span style=\"color:#E1E4E8\">() -> datetime.datetime:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Get current UTC time as timezone-aware datetime.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> datetime.datetime.now(datetime.timezone.utc)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> to_unix_timestamp</span><span style=\"color:#E1E4E8\">(dt: datetime.datetime) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convert datetime to Unix timestamp (seconds since epoch).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> dt.tzinfo </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Assume naive datetime is UTC</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        dt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> dt.replace(</span><span style=\"color:#FFAB70\">tzinfo</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">datetime.timezone.utc)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">(dt.timestamp())</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> from_unix_timestamp</span><span style=\"color:#E1E4E8\">(timestamp: Union[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">]) -> datetime.datetime:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convert Unix timestamp to UTC datetime.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> datetime.datetime.fromtimestamp(timestamp, </span><span style=\"color:#FFAB70\">tz</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">datetime.timezone.utc)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_expired</span><span style=\"color:#E1E4E8\">(exp_timestamp: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">], leeway: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> DEFAULT_LEEWAY_SECONDS</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Check if a timestamp represents an expired time.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        exp_timestamp: Unix timestamp for expiration, None means never expires</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        leeway: Clock skew tolerance in seconds</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        True if the timestamp is in the past (accounting for leeway)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> exp_timestamp </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> to_unix_timestamp(utc_now())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> current_time </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> (exp_timestamp </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> leeway)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_not_before</span><span style=\"color:#E1E4E8\">(nbf_timestamp: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">], leeway: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> DEFAULT_LEEWAY_SECONDS</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Check if current time is before a 'not before' timestamp.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        nbf_timestamp: Unix timestamp for 'not before', None means no restriction</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        leeway: Clock skew tolerance in seconds</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        True if current time is before the nbf time (accounting for leeway)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> nbf_timestamp </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> to_unix_timestamp(utc_now())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> current_time </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> (nbf_timestamp </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> leeway)</span></span></code></pre></div>\n\n<p><strong>Complete Exception Classes (<code>exceptions.py</code>)</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">JWT-specific exceptions that provide clear error categorization.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Each exception type corresponds to a specific validation failure mode.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> JWTError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base exception for all JWT-related errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InvalidTokenError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when token structure or encoding is invalid.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InvalidSignatureError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when token signature verification fails.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ExpiredTokenError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when token has expired (exp claim).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> NotBeforeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when token is not yet valid (nbf claim).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InvalidIssuerError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when token issuer is not in allowlist.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InvalidAudienceError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when token audience doesn't match expected value.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MissingRequiredClaimError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when a required claim is missing from the token.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p><strong>Complete Data Models (<code>models.py</code>)</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Data classes representing JWT components and validation context.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">These provide type safety and clear interfaces for token manipulation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional, List, Union</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> JWTHeader</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents the JWT header section.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    alg: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"HS256\"</span><span style=\"color:#6A737D\">  # Algorithm used for signing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    typ: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"JWT\"</span><span style=\"color:#6A737D\">    # Token type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_dict</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert header to dictionary for JSON serialization.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">\"alg\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.alg, </span><span style=\"color:#9ECBFF\">\"typ\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.typ}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_dict</span><span style=\"color:#E1E4E8\">(cls, data: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> </span><span style=\"color:#9ECBFF\">'JWTHeader'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create header from dictionary.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> cls</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">alg</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">data.get(</span><span style=\"color:#9ECBFF\">\"alg\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"HS256\"</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">typ</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">data.get(</span><span style=\"color:#9ECBFF\">\"typ\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"JWT\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> JWTPayload</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents the JWT payload section with standard and custom claims.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Registered claims (RFC 7519)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    iss: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # Issuer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sub: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # Subject</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    aud: Optional[Union[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # Audience</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    exp: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # Expiration time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nbf: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # Not before</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    iat: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # Issued at</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    jti: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # JWT ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Custom claims</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    custom_claims: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_dict</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert payload to dictionary, including only non-None values.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Add standard claims if present</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.iss </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[</span><span style=\"color:#9ECBFF\">\"iss\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.iss</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.sub </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[</span><span style=\"color:#9ECBFF\">\"sub\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.sub</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.aud </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[</span><span style=\"color:#9ECBFF\">\"aud\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.aud</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.exp </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[</span><span style=\"color:#9ECBFF\">\"exp\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.exp</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.nbf </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[</span><span style=\"color:#9ECBFF\">\"nbf\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.nbf</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.iat </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[</span><span style=\"color:#9ECBFF\">\"iat\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.iat</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.jti </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[</span><span style=\"color:#9ECBFF\">\"jti\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.jti</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Add custom claims</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result.update(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.custom_claims)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_dict</span><span style=\"color:#E1E4E8\">(cls, data: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> </span><span style=\"color:#9ECBFF\">'JWTPayload'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create payload from dictionary, separating standard and custom claims.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        standard_claims </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"iss\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"sub\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"aud\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"exp\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"nbf\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"iat\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"jti\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Extract standard claims</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        payload_args </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        custom_claims </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> key, value </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> data.items():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> key </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> standard_claims:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                payload_args[key] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                custom_claims[key] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        payload_args[</span><span style=\"color:#9ECBFF\">\"custom_claims\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> custom_claims</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> cls</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">payload_args)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ValidationContext</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Configuration and context for JWT validation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Required validations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    verify_signature: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    verify_expiration: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    verify_not_before: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Clock skew tolerance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leeway_seconds: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 300</span><span style=\"color:#6A737D\">  # 5 minutes default</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Issuer validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    allowed_issuers: Optional[List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    require_issuer: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Audience validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expected_audience: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    require_audience: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Custom claim requirements</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    required_claims: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"core-logic-implementation-skeleton\">Core Logic Implementation Skeleton</h4>\n<p>The following skeleton provides the structure for implementing core JWT operations while leaving the essential learning components for the student to complete:</p>\n<p><strong>Token Encoder Skeleton (<code>encoder.py</code>)</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">JWT token encoding and Base64URL implementation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Students implement the core encoding logic following the numbered steps.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> base64</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .models </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> JWTHeader, JWTPayload</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .exceptions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> InvalidTokenError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> base64url_encode</span><span style=\"color:#E1E4E8\">(data: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Encode bytes to Base64URL format (RFC 4648 Section 5).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Base64URL uses URL-safe characters and removes padding.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Use base64.urlsafe_b64encode() to encode the input bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Decode the result to get a string (it returns bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Remove any trailing '=' padding characters using rstrip()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return the URL-safe, padding-free string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Base64URL differs from regular Base64 in character set and padding</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> base64url_decode</span><span style=\"color:#E1E4E8\">(data: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Decode Base64URL format back to bytes.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Must handle missing padding by adding it back.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Calculate padding needed: missing = (4 - len(data) % 4) % 4</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add '=' characters for padding: data += '=' * missing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Use base64.urlsafe_b64decode() to decode the padded string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return the decoded bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Base64 requires length to be multiple of 4, so we add padding back</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> encode_token_parts</span><span style=\"color:#E1E4E8\">(header: JWTHeader, payload: JWTPayload) -> tuple[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Encode header and payload sections of JWT.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns (encoded_header, encoded_payload) tuple.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Convert header to dictionary using header.to_dict()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Serialize header dict to JSON string using json.dumps()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Encode header JSON to bytes using .encode('utf-8')</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Apply Base64URL encoding to header bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Repeat steps 1-4 for payload</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return tuple of (encoded_header, encoded_payload)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Consistent JSON serialization is important for signature verification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"language-specific-implementation-hints\">Language-Specific Implementation Hints</h4>\n<p><strong>Python Cryptographic Libraries:</strong></p>\n<ul>\n<li>Use <code>hmac.new(key, message, hashlib.sha256)</code> for HMAC-SHA256 computation</li>\n<li>Always call <code>hmac.digest()</code> to get bytes, not <code>hexdigest()</code> which returns hex strings</li>\n<li>Use <code>hmac.compare_digest()</code> for constant-time signature comparison to prevent timing attacks</li>\n</ul>\n<p><strong>JSON Serialization Consistency:</strong></p>\n<ul>\n<li>Use <code>json.dumps(data, separators=(&#39;,&#39;, &#39;:&#39;), sort_keys=True)</code> for consistent output</li>\n<li>The <code>separators</code> parameter removes extra whitespace</li>\n<li>The <code>sort_keys</code> parameter ensures consistent key ordering for reproducible signatures</li>\n</ul>\n<p><strong>Time Handling Best Practices:</strong></p>\n<ul>\n<li>Always work with UTC timestamps to avoid timezone confusion</li>\n<li>Use <code>datetime.datetime.now(datetime.timezone.utc)</code> instead of <code>datetime.utcnow()</code> (deprecated)</li>\n<li>Convert to Unix timestamps using <code>int(dt.timestamp())</code> for JWT claims</li>\n</ul>\n<p><strong>Error Handling Patterns:</strong></p>\n<ul>\n<li>Catch specific exceptions (<code>json.JSONDecodeError</code>, <code>base64.binascii.Error</code>) and re-raise as <code>InvalidTokenError</code></li>\n<li>Validate input types early: check that tokens are strings, keys are bytes, etc.</li>\n<li>Provide descriptive error messages that help with debugging but don&#39;t leak sensitive information</li>\n</ul>\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>Milestone 1 Checkpoint (Token Encoding):</strong>\nAfter implementing the encoding components, verify functionality with:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_encoder.py</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n\n<p>Expected behavior:</p>\n<ul>\n<li><code>base64url_encode(b&quot;hello&quot;)</code> should return <code>&quot;aGVsbG8&quot;</code> (no padding)</li>\n<li><code>base64url_decode(&quot;aGVsbG8&quot;)</code> should return <code>b&quot;hello&quot;</code></li>\n<li>Header encoding should produce valid Base64URL that decodes back to original JSON</li>\n<li>Complete token structure should have exactly two dots separating three parts</li>\n</ul>\n<p>Manual verification:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> jwt_lib.encoder </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> encode_token_parts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> jwt_lib.models </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> JWTHeader, JWTPayload</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">header </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> JWTHeader()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">payload </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> JWTPayload(</span><span style=\"color:#FFAB70\">sub</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"user123\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">exp</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1234567890</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">h, p </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> encode_token_parts(header, payload)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Header: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">h</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Payload: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">p</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should produce readable JSON when decoded at jwt.io</span></span></code></pre></div>\n\n<p><strong>Security Validation Points:</strong></p>\n<ul>\n<li>Verify that Base64URL encoding produces URL-safe output (no <code>+</code> or <code>/</code> characters)</li>\n<li>Confirm that padding is properly removed and restored during encode/decode cycles</li>\n<li>Test edge cases: empty payloads, Unicode characters in custom claims, very long tokens</li>\n</ul>\n<p>Signs of problems:</p>\n<ul>\n<li>&quot;Invalid character&quot; errors usually indicate Base64URL vs regular Base64 confusion</li>\n<li>JSON decode errors suggest inconsistent serialization or encoding corruption</li>\n<li>Token structure errors typically mean incorrect dot-separated format assembly</li>\n</ul>\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundation for all three milestones - establishes scope and security requirements for the entire JWT library</p>\n</blockquote>\n<p>Before diving into implementation details, we must establish clear boundaries for our JWT library. Like defining the requirements for a security system before building it, understanding what we will and will not implement prevents scope creep and ensures we focus on the core learning objectives while maintaining security best practices.</p>\n<p>The goals and non-goals for our JWT library emerge from the fundamental tension between simplicity and completeness. We want to build something robust enough to demonstrate real-world JWT concepts, yet focused enough that learners can master the core principles without getting lost in enterprise-grade feature complexity.</p>\n<h3 id=\"functional-requirements\">Functional Requirements</h3>\n<p>Our JWT library must provide the essential operations that any production-ready JWT implementation would offer. These requirements directly support the three milestone progression: basic token structure, cryptographic signing, and comprehensive validation.</p>\n<p><strong>Core JWT Operations</strong></p>\n<p>The library must support the complete JWT lifecycle from token creation through verification. This means providing clean APIs for both token producers (services that issue JWTs) and token consumers (services that validate incoming JWTs).</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Input Parameters</th>\n<th>Expected Output</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>create_token</code></td>\n<td><code>JWTHeader</code>, <code>JWTPayload</code>, secret key</td>\n<td>Signed JWT string</td>\n<td>Generate new authentication tokens</td>\n</tr>\n<tr>\n<td><code>verify_token</code></td>\n<td>JWT string, secret key, <code>ValidationContext</code></td>\n<td>Decoded <code>JWTPayload</code> or error</td>\n<td>Validate and extract claims from tokens</td>\n</tr>\n<tr>\n<td><code>decode_header</code></td>\n<td>JWT string</td>\n<td><code>JWTHeader</code> or error</td>\n<td>Extract header without verification (debugging)</td>\n</tr>\n<tr>\n<td><code>decode_payload</code></td>\n<td>JWT string</td>\n<td><code>JWTPayload</code> or error</td>\n<td>Extract payload without verification (debugging)</td>\n</tr>\n<tr>\n<td><code>encode_token_parts</code></td>\n<td><code>JWTHeader</code>, <code>JWTPayload</code></td>\n<td>Base64URL header, payload strings</td>\n<td>Support custom signing workflows</td>\n</tr>\n</tbody></table>\n<p>The token creation operation must handle the complete assembly process: JSON serialization of header and payload, Base64URL encoding of both parts, HMAC-SHA256 signature generation over the signing input, and final concatenation into the standard three-part format. This operation serves as the primary interface for authentication services issuing tokens to users after successful login.</p>\n<p>Token verification represents the most complex functional requirement. It must parse the three-part token structure, decode Base64URL components back to JSON, recompute the HMAC signature using the provided secret key, perform constant-time signature comparison to prevent timing attacks, and validate all time-based and identity claims according to the provided validation context. This operation serves as the primary interface for protected services validating incoming requests.</p>\n<p><strong>JWT Structure Compliance</strong></p>\n<p>Our implementation must strictly adhere to RFC 7519 JWT specifications and RFC 7515 JWS (JSON Web Signature) specifications for the structural format. This ensures interoperability with other JWT libraries and services.</p>\n<p>The header component must contain the algorithm identifier (<code>alg</code>) set to <code>HS256</code> for HMAC-SHA256 signatures, and the token type (<code>typ</code>) set to <code>JWT</code> to indicate this is a JSON Web Token. Additional header fields are explicitly out of scope for this learning-focused implementation.</p>\n<p>The payload component must support all standard registered claims defined in RFC 7519. These include issuer (<code>iss</code>) for identifying the token creator, subject (<code>sub</code>) for identifying the token recipient, audience (<code>aud</code>) for specifying intended token consumers, expiration time (<code>exp</code>) for token lifetime management, not-before time (<code>nbf</code>) for delayed token activation, issued-at time (<code>iat</code>) for token creation tracking, and JWT ID (<code>jti</code>) for unique token identification.</p>\n<p>Custom claims support is essential for real-world usage. The payload must accommodate arbitrary application-specific claims while ensuring they don&#39;t conflict with registered claim names. This flexibility allows authentication services to embed user roles, permissions, session identifiers, or other application state into tokens.</p>\n<p><strong>Base64URL Encoding Requirements</strong></p>\n<p>Proper Base64URL encoding is critical for JWT compliance and security. Our implementation must use the URL-safe Base64 variant that replaces plus signs with hyphens, forward slashes with underscores, and removes padding equals characters entirely.</p>\n<table>\n<thead>\n<tr>\n<th>Encoding Requirement</th>\n<th>Standard Base64</th>\n<th>Required Base64URL</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Character 62</td>\n<td><code>+</code></td>\n<td><code>-</code></td>\n<td>URL safety in query parameters</td>\n</tr>\n<tr>\n<td>Character 63</td>\n<td><code>/</code></td>\n<td><code>_</code></td>\n<td>URL safety in path segments</td>\n</tr>\n<tr>\n<td>Padding</td>\n<td><code>=</code> characters</td>\n<td>No padding</td>\n<td>Reduces token length, prevents encoding issues</td>\n</tr>\n<tr>\n<td>Line breaks</td>\n<td>Allowed</td>\n<td>Forbidden</td>\n<td>Ensures single-line tokens</td>\n</tr>\n</tbody></table>\n<p>The encoding process must handle the padding restoration correctly during decoding. When decoding Base64URL back to bytes, the implementation must calculate the required padding length using modulo arithmetic and append the appropriate number of equals characters before performing standard Base64 decoding.</p>\n<p><strong>Time-Based Claim Processing</strong></p>\n<p>Time-based claims require careful handling to balance security with practical clock synchronization challenges in distributed systems. Our implementation must support configurable clock skew tolerance while maintaining security properties.</p>\n<p>The expiration claim (<code>exp</code>) validation must compare the claim timestamp against the current UTC time plus a configurable leeway period. Tokens with expiration times in the past (accounting for leeway) must be rejected with a specific expiration error that applications can handle appropriately.</p>\n<p>The not-before claim (<code>nbf</code>) validation must ensure the current time is after the claim timestamp minus the leeway period. This supports use cases where tokens are issued for future activation, such as scheduled access grants or time-delayed permissions.</p>\n<p>The issued-at claim (<code>iat</code>) validation must verify the timestamp is not unreasonably far in the past or future. This prevents token replay attacks using very old tokens and detects clock synchronization issues that might indicate system compromise.</p>\n<h3 id=\"security-requirements\">Security Requirements</h3>\n<p>Security requirements for our JWT library extend beyond basic functionality to address the cryptographic and temporal attack vectors that commonly compromise token-based authentication systems.</p>\n<p><strong>Cryptographic Security Properties</strong></p>\n<p>The HMAC-SHA256 implementation must provide strong cryptographic guarantees against signature forgery and manipulation attacks. The secret key must be used directly in HMAC computation without additional processing that might weaken the cryptographic properties.</p>\n<table>\n<thead>\n<tr>\n<th>Security Property</th>\n<th>Requirement</th>\n<th>Attack Prevention</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Signature integrity</td>\n<td>HMAC-SHA256 over header.payload</td>\n<td>Prevents token tampering</td>\n</tr>\n<tr>\n<td>Key confidentiality</td>\n<td>Secret key never logged or exposed</td>\n<td>Prevents signature forgery</td>\n</tr>\n<tr>\n<td>Constant-time comparison</td>\n<td>Signature verification immune to timing analysis</td>\n<td>Prevents timing side-channel attacks</td>\n</tr>\n<tr>\n<td>Algorithm specification</td>\n<td>Header <code>alg</code> field enforced strictly</td>\n<td>Prevents algorithm confusion attacks</td>\n</tr>\n</tbody></table>\n<p>Constant-time comparison is crucial for signature verification security. The implementation must use a comparison function that takes the same amount of time regardless of where the compared byte sequences differ. This prevents timing attacks where malicious actors measure response times to gradually discover valid signatures.</p>\n<p>Secret key handling requires careful memory management. The key should be stored securely in memory without unnecessary copying, never written to logs or error messages, and cleared from memory when no longer needed (though Python&#39;s garbage collection makes secure clearing challenging).</p>\n<p><strong>Algorithm Confusion Attack Prevention</strong></p>\n<p>Algorithm confusion attacks exploit JWT libraries that allow attackers to change the signing algorithm specified in the token header. Our implementation must enforce strict algorithm verification to prevent these attacks.</p>\n<p>The most dangerous variant involves changing from HMAC algorithms to asymmetric algorithms like RS256. An attacker might change <code>alg</code> from <code>HS256</code> to <code>RS256</code>, then use the known public key as the &quot;secret&quot; to forge signatures. Our implementation prevents this by validating that the header algorithm matches the expected algorithm before performing any signature verification.</p>\n<blockquote>\n<p><strong>Critical Security Insight</strong>: Never trust the algorithm specified in the JWT header without verification. Always validate that the algorithm matches what your application expects before processing the signature.</p>\n</blockquote>\n<p><strong>Timing Attack Resistance</strong></p>\n<p>Timing attacks against JWT verification exploit small differences in processing time to extract cryptographic secrets or bypass security checks. Our implementation must provide consistent execution times for both successful and failed verification attempts.</p>\n<p>The primary timing attack vector occurs during signature comparison. If comparison fails fast on the first differing byte, attackers can measure response times to gradually construct valid signatures. Our constant-time comparison function must examine every byte of both signatures regardless of when differences are detected.</p>\n<p>Secondary timing attacks can occur during claims validation if different validation failures take significantly different processing times. While perfect timing uniformity is difficult to achieve, the implementation should avoid obvious timing differences like expensive database lookups for some validation failures but not others.</p>\n<p><strong>Clock Skew Tolerance</strong></p>\n<p>Time-based claim validation must balance security with practical distributed system realities. Perfect clock synchronization between token issuers and validators is impossible, requiring configurable tolerance for time differences.</p>\n<p>The default leeway of <code>DEFAULT_LEEWAY_SECONDS</code> (300 seconds) provides reasonable tolerance for typical network time protocol (NTP) synchronization while limiting the window for potential abuse. This value represents a compromise between security (smaller windows are better) and reliability (larger windows accommodate more clock drift).</p>\n<table>\n<thead>\n<tr>\n<th>Time Validation</th>\n<th>Without Leeway</th>\n<th>With 5-Minute Leeway</th>\n<th>Security Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Token expires 11:00:00</td>\n<td>Rejected at 11:00:01</td>\n<td>Rejected at 11:05:01</td>\n<td>5-minute extended exposure</td>\n</tr>\n<tr>\n<td>Token not-before 11:00:00</td>\n<td>Accepted at 10:59:59</td>\n<td>Accepted at 10:55:00</td>\n<td>5-minute early access</td>\n</tr>\n<tr>\n<td>Clock drift tolerance</td>\n<td>Frequent false rejections</td>\n<td>Reliable validation</td>\n<td>Improved user experience</td>\n</tr>\n</tbody></table>\n<p>Applications with higher security requirements can reduce the leeway period, while applications prioritizing reliability over absolute security can increase it. The key is making this configurable rather than hardcoded.</p>\n<h3 id=\"non-goals\">Non-Goals</h3>\n<p>Explicitly defining what our JWT library will not implement is as important as defining what it will implement. These non-goals help maintain focus on the core learning objectives while acknowledging the broader JWT ecosystem.</p>\n<p><strong>Advanced Cryptographic Algorithms</strong></p>\n<p>Our implementation deliberately limits itself to HMAC-SHA256 (<code>HS256</code>) signatures only. We will not implement RSA signatures (RS256), ECDSA signatures (ES256/ES384/ES512), or other advanced cryptographic algorithms defined in the JWS specification.</p>\n<p>This limitation serves multiple purposes. First, it keeps the cryptographic complexity manageable for learners focusing on JWT concepts rather than advanced cryptography. Second, it avoids the key management complexity that asymmetric algorithms introduce. Third, it prevents the implementation complexity that algorithm negotiation and validation would require.</p>\n<blockquote>\n<p><strong>Design Decision</strong>: HMAC-SHA256 provides sufficient cryptographic security for the learning objectives while avoiding the certificate management, key distribution, and algorithm negotiation complexities that asymmetric algorithms introduce.</p>\n</blockquote>\n<p><strong>JSON Web Encryption (JWE)</strong></p>\n<p>We will not implement JWE capabilities for encrypting JWT payloads. JWE addresses confidentiality concerns (hiding claim contents from anyone who can see the token), while our focus is on integrity and authenticity (ensuring tokens haven&#39;t been tampered with and come from trusted issuers).</p>\n<p>JWE implementation would require additional cryptographic primitives (symmetric encryption, key derivation functions, authenticated encryption modes), content encryption key management, and recipient key handling. These complexities detract from the core JWT concepts without significantly enhancing the learning experience.</p>\n<p><strong>Key Rotation and Management</strong></p>\n<p>Advanced key management features like automatic key rotation, key versioning, multiple concurrent keys, and key distribution mechanisms are explicitly out of scope. Our implementation assumes a single, static secret key shared between token issuers and validators.</p>\n<p>Real production systems require sophisticated key management to handle key compromise, regular rotation for security hygiene, and zero-downtime key updates. However, these operational concerns distract from the fundamental JWT concepts and would require additional infrastructure (key storage systems, coordination mechanisms, backward compatibility handling) beyond the scope of a learning implementation.</p>\n<p><strong>Performance Optimizations</strong></p>\n<p>We will not implement performance optimizations like signature verification caching, batch token processing, or streaming JSON parsing. Our focus is on correctness and security rather than high-throughput production performance.</p>\n<p>Performance optimizations often introduce complexity that obscures the fundamental algorithms and security properties we&#39;re trying to teach. Caching mechanisms require cache invalidation strategies, batch processing requires careful error isolation, and streaming parsing requires state management that distracts from the core JWT concepts.</p>\n<p><strong>Enterprise Features</strong></p>\n<p>Enterprise-grade features like token introspection endpoints (RFC 7662), token revocation (RFC 7009), dynamic client registration, and OAuth 2.0 integration are out of scope. These features represent important production capabilities but extend well beyond JWT fundamentals into broader authentication and authorization protocol ecosystems.</p>\n<table>\n<thead>\n<tr>\n<th>Feature Category</th>\n<th>Examples</th>\n<th>Why Out of Scope</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OAuth 2.0 Integration</td>\n<td>Authorization code flows, client credentials</td>\n<td>Focuses on authorization protocol rather than JWT structure</td>\n</tr>\n<tr>\n<td>Token Management</td>\n<td>Revocation lists, introspection endpoints</td>\n<td>Requires persistent storage and distributed coordination</td>\n</tr>\n<tr>\n<td>Client Management</td>\n<td>Dynamic registration, client authentication</td>\n<td>Involves certificate management and PKI concepts</td>\n</tr>\n<tr>\n<td>Advanced Claims</td>\n<td>Hierarchical claims, claim transformation</td>\n<td>Adds application-specific complexity without JWT insights</td>\n</tr>\n</tbody></table>\n<p><strong>Framework Integration</strong></p>\n<p>We will not provide direct integrations with web frameworks (Express.js middleware, Django authentication backends, Gin handlers) or cloud platforms (AWS Cognito, Auth0, Firebase Auth). Our library will provide clean, framework-agnostic APIs that could be integrated with any framework but won&#39;t include the integration code itself.</p>\n<p>Framework integrations require understanding each framework&#39;s authentication model, request/response handling patterns, and error reporting mechanisms. This knowledge is valuable for production deployment but distracts from the JWT-specific learning objectives.</p>\n<p><strong>Database Integration</strong></p>\n<p>Features requiring persistent storage like user management, session tracking, token blacklisting, or audit logging are out of scope. Our implementation will be completely stateless, validating tokens based solely on their cryptographic properties and embedded claims.</p>\n<p>Stateless validation is one of JWT&#39;s key advantages over traditional session-based authentication, and maintaining this property simplifies the implementation while reinforcing the conceptual benefits of token-based authentication.</p>\n<blockquote>\n<p><strong>Architecture Principle</strong>: Our JWT library embraces stateless authentication as a core design principle. All token validation decisions must be made based solely on the token contents and the shared secret key, without requiring database lookups or external service calls.</p>\n</blockquote>\n<p><strong>Advanced Validation Rules</strong></p>\n<p>Complex validation rules like claim interdependency checking, conditional validation logic, or custom validation plugins are out of scope. Our validation will focus on the standard registered claims and basic custom claim extraction without sophisticated rule engines.</p>\n<p>For example, we won&#39;t support validation rules like &quot;if role claim is &#39;admin&#39;, then require additional MFA claim&quot; or &quot;if audience contains &#39;sensitive-service&#39;, then enforce stricter expiration limits.&quot; These application-specific validation requirements can be implemented by applications using our basic claim extraction capabilities.</p>\n<p>This focused scope ensures that learners master the fundamental JWT validation concepts (time-based claims, signature verification, basic claim extraction) without getting distracted by the infinite variety of application-specific validation requirements that real systems might need.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides concrete technology recommendations and starter code to help implement the functional and security requirements defined above.</p>\n<p><strong>A. Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JSON Serialization</td>\n<td><code>json.dumps()</code> with <code>separators=(&#39;,&#39;, &#39;:&#39;)</code></td>\n<td>Custom JSON encoder with ordered keys</td>\n</tr>\n<tr>\n<td>Base64 Encoding</td>\n<td><code>base64.urlsafe_b64encode()</code> with padding removal</td>\n<td>Custom Base64URL implementation</td>\n</tr>\n<tr>\n<td>HMAC Computation</td>\n<td><code>hmac.new()</code> with <code>hashlib.sha256</code></td>\n<td>Custom HMAC implementation</td>\n</tr>\n<tr>\n<td>Time Handling</td>\n<td><code>datetime.datetime.utcnow()</code> and <code>timestamp()</code></td>\n<td><code>time.time()</code> for performance</td>\n</tr>\n<tr>\n<td>Constant-Time Comparison</td>\n<td><code>hmac.compare_digest()</code></td>\n<td>Custom constant-time implementation</td>\n</tr>\n<tr>\n<td>Secret Key Storage</td>\n<td>In-memory <code>bytes</code> object</td>\n<td>Secure memory with <code>mlock()</code></td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File Structure</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>jwt-library/\n├── jwt_lib/\n│   ├── __init__.py              ← Main API exports\n│   ├── core.py                  ← Primary JWT operations (create_token, verify_token)\n│   ├── encoding.py              ← Base64URL encoding/decoding utilities\n│   ├── signing.py               ← HMAC-SHA256 signature operations\n│   ├── validation.py            ← Claims validation logic\n│   ├── models.py                ← Data structures (JWTHeader, JWTPayload, ValidationContext)\n│   └── exceptions.py            ← Custom exception classes\n├── tests/\n│   ├── test_core.py             ← End-to-end JWT operations\n│   ├── test_encoding.py         ← Base64URL encoding tests\n│   ├── test_signing.py          ← Signature generation/verification tests\n│   ├── test_validation.py       ← Claims validation tests\n│   └── test_vectors.py          ← RFC test vectors and known-good examples\n└── examples/\n    ├── basic_usage.py           ← Simple create/verify example\n    └── advanced_validation.py   ← Custom validation context examples</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code</strong></p>\n<p>Here&#39;s complete starter code for the data models and basic utilities that learners can use immediately:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">JWT Library Data Models and Utilities</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Complete implementation - copy and use as-is</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timezone</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, List, Union, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> base64</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Constants</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">DEFAULT_LEEWAY_SECONDS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 300</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">HS256</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"HS256\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">JWT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"JWT\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> JWTHeader</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"JWT header containing algorithm and type information.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    alg: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> HS256</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    typ: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> JWT</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_dict</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">\"alg\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.alg, </span><span style=\"color:#9ECBFF\">\"typ\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.typ}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_dict</span><span style=\"color:#E1E4E8\">(cls, data: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> </span><span style=\"color:#9ECBFF\">'JWTHeader'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> cls</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">alg</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">data.get(</span><span style=\"color:#9ECBFF\">\"alg\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">HS256</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">typ</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">data.get(</span><span style=\"color:#9ECBFF\">\"typ\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">JWT</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> JWTPayload</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"JWT payload containing registered and custom claims.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    iss: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">          # Issuer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sub: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">          # Subject</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    aud: Optional[Union[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # Audience</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    exp: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">          # Expiration time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nbf: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">          # Not before</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    iat: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">          # Issued at</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    jti: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">          # JWT ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    custom_claims: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_dict</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.iss </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[</span><span style=\"color:#9ECBFF\">\"iss\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.iss</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.sub </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[</span><span style=\"color:#9ECBFF\">\"sub\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.sub</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.aud </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[</span><span style=\"color:#9ECBFF\">\"aud\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.aud</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.exp </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[</span><span style=\"color:#9ECBFF\">\"exp\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.exp</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.nbf </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[</span><span style=\"color:#9ECBFF\">\"nbf\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.nbf</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.iat </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[</span><span style=\"color:#9ECBFF\">\"iat\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.iat</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.jti </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[</span><span style=\"color:#9ECBFF\">\"jti\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.jti</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result.update(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.custom_claims)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_dict</span><span style=\"color:#E1E4E8\">(cls, data: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> </span><span style=\"color:#9ECBFF\">'JWTPayload'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Extract registered claims</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        registered_claims </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'iss'</span><span style=\"color:#E1E4E8\">: data.get(</span><span style=\"color:#9ECBFF\">'iss'</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'sub'</span><span style=\"color:#E1E4E8\">: data.get(</span><span style=\"color:#9ECBFF\">'sub'</span><span style=\"color:#E1E4E8\">), </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'aud'</span><span style=\"color:#E1E4E8\">: data.get(</span><span style=\"color:#9ECBFF\">'aud'</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'exp'</span><span style=\"color:#E1E4E8\">: data.get(</span><span style=\"color:#9ECBFF\">'exp'</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'nbf'</span><span style=\"color:#E1E4E8\">: data.get(</span><span style=\"color:#9ECBFF\">'nbf'</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'iat'</span><span style=\"color:#E1E4E8\">: data.get(</span><span style=\"color:#9ECBFF\">'iat'</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'jti'</span><span style=\"color:#E1E4E8\">: data.get(</span><span style=\"color:#9ECBFF\">'jti'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Extract custom claims (everything else)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        custom_claims </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {k: v </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> k, v </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> data.items() </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        if</span><span style=\"color:#E1E4E8\"> k </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">'iss'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'sub'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'aud'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'exp'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'nbf'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'iat'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'jti'</span><span style=\"color:#E1E4E8\">]}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> cls</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">custom_claims</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">custom_claims, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">{k: v </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> k, v </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> registered_claims.items() </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ValidationContext</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Configuration for JWT validation behavior.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    verify_signature: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    verify_expiration: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    verify_not_before: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leeway_seconds: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> DEFAULT_LEEWAY_SECONDS</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    allowed_issuers: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    require_issuer: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expected_audience: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    require_audience: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    required_claims: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Utility functions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> utc_now</span><span style=\"color:#E1E4E8\">() -> datetime:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Get current UTC time.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> datetime.now(timezone.utc)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> to_unix_timestamp</span><span style=\"color:#E1E4E8\">(dt: datetime) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convert datetime to Unix timestamp.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">(dt.timestamp())</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> JWTError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base exception for JWT operations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InvalidTokenError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when token structure is invalid.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InvalidSignatureError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when signature verification fails.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TokenExpiredError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when token is expired.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TokenNotYetValidError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when token not-before time hasn't passed.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InvalidIssuerError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when token issuer is not allowed.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InvalidAudienceError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when token audience doesn't match expected.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code</strong></p>\n<p>Here are the main function signatures learners need to implement, with detailed TODO comments mapping to the requirements:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Core JWT Operations - Implement These Functions</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Fill in the </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#9ECBFF\"> sections based on the requirements above</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hmac</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hashlib</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> base64url_encode</span><span style=\"color:#E1E4E8\">(data: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Encode bytes to URL-safe Base64 without padding.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Use base64.urlsafe_b64encode() to encode the data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Decode the result to get a string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Remove trailing '=' padding characters using rstrip()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return the URL-safe string</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> base64url_decode</span><span style=\"color:#E1E4E8\">(data: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Decode Base64URL back to bytes with padding restoration.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Calculate required padding: 4 - (len(data) % 4) % 4</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add '=' characters for padding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Use base64.urlsafe_b64decode() to decode</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return the decoded bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> encode_token_parts</span><span style=\"color:#E1E4E8\">(header: JWTHeader, payload: JWTPayload) -> tuple[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Encode header and payload sections to Base64URL.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Convert header to dictionary using header.to_dict()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Serialize header dict to JSON with separators=(',', ':')</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Encode header JSON to bytes using .encode('utf-8')</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Base64URL encode header bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Repeat steps 1-4 for payload using payload.to_dict()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return tuple of (encoded_header, encoded_payload)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_token</span><span style=\"color:#E1E4E8\">(header: JWTHeader, payload: JWTPayload, secret_key: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Generate signed JWT token.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Encode header and payload using encode_token_parts()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create signing input by joining header.payload with '.'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Generate HMAC-SHA256 signature over signing input</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Base64URL encode the signature</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Join header.payload.signature with '.' separators</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return the complete JWT string</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> verify_token</span><span style=\"color:#E1E4E8\">(token: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, secret_key: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, context: ValidationContext) -> JWTPayload:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Verify JWT token and return payload if valid.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Split token into three parts using token.split('.')</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Verify we have exactly 3 parts, raise InvalidTokenError if not</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Base64URL decode header and payload parts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Parse JSON from decoded header and payload</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Create JWTHeader and JWTPayload objects from parsed JSON</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: If context.verify_signature: verify signature matches</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: If context.verify_expiration: check exp claim</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: If context.verify_not_before: check nbf claim  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Validate issuer and audience claims per context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 10: Return validated payload</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_expired</span><span style=\"color:#E1E4E8\">(exp_timestamp: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, leeway: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if timestamp is in the past accounting for leeway.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Get current Unix timestamp using utc_now() and to_unix_timestamp()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add leeway seconds to exp_timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return True if current time > adjusted expiration time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_not_before</span><span style=\"color:#E1E4E8\">(nbf_timestamp: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, leeway: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if current time is before nbf accounting for leeway.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Get current Unix timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Subtract leeway seconds from nbf_timestamp  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return True if current time &#x3C; adjusted not-before time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints</strong></p>\n<ul>\n<li>Use <code>json.dumps(obj, separators=(&#39;,&#39;, &#39;:&#39;))</code> for compact JSON without whitespace</li>\n<li>Use <code>hmac.compare_digest()</code> for constant-time signature comparison</li>\n<li>Use <code>datetime.now(timezone.utc)</code> for UTC timestamps to avoid timezone issues</li>\n<li>Store secret keys as <code>bytes</code> objects, not strings, to avoid encoding confusion</li>\n<li>Use <code>str.encode(&#39;utf-8&#39;)</code> when converting JSON strings to bytes for encoding</li>\n<li>Handle <code>json.JSONDecodeError</code> when parsing potentially malformed tokens</li>\n</ul>\n<p><strong>F. Milestone Checkpoints</strong></p>\n<p>After implementing the functional requirements:</p>\n<p><strong>Checkpoint 1 - Token Creation</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">from jwt_lib.core import create_token</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">from jwt_lib.models import JWTHeader, JWTPayload</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">import time</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">payload = JWTPayload(sub='user123', exp=int(time.time()) + 3600)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">token = create_token(JWTHeader(), payload, b'secret')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">print(f'Created token: {token}')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">print(f'Parts count: {len(token.split(</span><span style=\"color:#79B8FF\">\\\"</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">\\\"</span><span style=\"color:#9ECBFF\">))}')  # Should be 3</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<p><strong>Checkpoint 2 - Token Verification</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">from jwt_lib.core import create_token, verify_token</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">from jwt_lib.models import JWTHeader, JWTPayload, ValidationContext</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">import time</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">payload = JWTPayload(sub='user123', exp=int(time.time()) + 3600)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">token = create_token(JWTHeader(), payload, b'secret')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">verified = verify_token(token, b'secret', ValidationContext())</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">print(f'Verified subject: {verified.sub}')  # Should be 'user123'</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<p><strong>Checkpoint 3 - Claims Validation</strong>:\nTest that expired tokens are properly rejected and validation context works correctly.</p>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundation for all three milestones - provides the structural framework for token encoding (Milestone 1), HMAC signing (Milestone 2), and claims validation (Milestone 3)</p>\n</blockquote>\n<p>The JWT library architecture follows a <strong>layered responsibility pattern</strong> where each component has a distinct role in the token lifecycle. Think of this like a document processing pipeline in a government office: first, clerks prepare and format the document (encoding), then an official stamps it with a seal (signing), and finally, inspectors validate both the seal and contents before accepting it (verification). Each station has specialized knowledge and tools, but they work together to ensure document authenticity and integrity.</p>\n<p><img src=\"/api/project/jwt-impl/architecture-doc/asset?path=diagrams%2Fcomponent-architecture.svg\" alt=\"JWT Library Component Architecture\"></p>\n<p>The architecture separates concerns across three primary dimensions: <strong>structural formatting</strong>, <strong>cryptographic security</strong>, and <strong>semantic validation</strong>. This separation allows each component to focus on its specific expertise while maintaining clear interfaces between layers. The design prioritizes security by ensuring that cryptographic operations are isolated from parsing logic, and validation rules are separated from encoding concerns.</p>\n<h3 id=\"component-responsibilities\">Component Responsibilities</h3>\n<p>The JWT library consists of three core components that collaborate to provide <strong>stateless authentication</strong> capabilities. Each component owns a specific aspect of the token lifecycle and exposes well-defined interfaces to other components.</p>\n<h4 id=\"token-encoding-component\">Token Encoding Component</h4>\n<p>The <strong>Token Encoding Component</strong> serves as the foundation layer, responsible for all structural and formatting concerns. This component transforms application data into the standardized JWT format without any knowledge of cryptographic operations or business logic validation rules.</p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Key Operations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JSON Serialization</td>\n<td>Convert header and payload objects to consistent JSON representation</td>\n<td>Deterministic field ordering, proper escaping</td>\n</tr>\n<tr>\n<td>Base64URL Encoding</td>\n<td>Transform JSON strings into URL-safe encoded segments</td>\n<td>Padding removal, character substitution</td>\n</tr>\n<tr>\n<td>Token Structure Assembly</td>\n<td>Combine encoded parts into dot-separated JWT format</td>\n<td>Header concatenation, placeholder signature handling</td>\n</tr>\n<tr>\n<td>Format Validation</td>\n<td>Ensure structural compliance with JWT specification</td>\n<td>Three-part format verification, character validation</td>\n</tr>\n</tbody></table>\n<p>The encoding component maintains <strong>format consistency</strong> by applying standardized JSON serialization rules and ensuring that all tokens follow the exact three-part structure required by RFC 7519. It handles the subtle differences between standard Base64 and <strong>Base64URL encoding</strong>, particularly around padding characters and URL-safe character substitutions.</p>\n<blockquote>\n<p><strong>Key Design Principle</strong>: The encoding component never touches cryptographic material or validates claim semantics. It treats all payload data as opaque JSON objects, focusing solely on format compliance and structural integrity.</p>\n</blockquote>\n<h4 id=\"cryptographic-signing-component\">Cryptographic Signing Component</h4>\n<p>The <strong>Cryptographic Signing Component</strong> handles all security-related operations, including signature generation, verification, and protection against cryptographic attacks. This component operates independently of token structure and claim semantics.</p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Security Considerations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HMAC-SHA256 Computation</td>\n<td>Generate keyed hash signatures over signing input</td>\n<td>Constant-time operations, secure key handling</td>\n</tr>\n<tr>\n<td>Signature Verification</td>\n<td>Validate token authenticity through signature comparison</td>\n<td>Timing attack prevention, algorithm confusion protection</td>\n</tr>\n<tr>\n<td>Secret Key Management</td>\n<td>Securely store and access signing keys in memory</td>\n<td>Key validation, secure memory handling</td>\n</tr>\n<tr>\n<td>Cryptographic Error Handling</td>\n<td>Detect and report signature-related failures</td>\n<td>Information leak prevention, clear error categories</td>\n</tr>\n</tbody></table>\n<p>The signing component implements <strong>signature verification</strong> using constant-time comparison algorithms to prevent <strong>timing attacks</strong>. It validates that the recomputed signature exactly matches the token&#39;s signature without revealing information about partial matches or failure points.</p>\n<blockquote>\n<p><strong>Security Focus</strong>: This component treats timing as a security-critical resource. All cryptographic comparisons use constant-time algorithms, and error messages are carefully crafted to avoid leaking information about signature computation internals.</p>\n</blockquote>\n<h4 id=\"claims-validation-component\">Claims Validation Component</h4>\n<p>The <strong>Claims Validation Component</strong> enforces business logic and semantic rules around JWT <strong>claims</strong>. It operates on successfully parsed and cryptographically verified tokens, applying temporal, identity, and custom validation rules.</p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Validation Rules</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Temporal Claims Validation</td>\n<td>Verify exp, nbf, and iat claims against current time</td>\n<td><strong>Clock skew</strong> tolerance, reasonable time bounds</td>\n</tr>\n<tr>\n<td>Identity Claims Validation</td>\n<td>Check iss and aud claims against allowed values</td>\n<td>Issuer allowlists, audience matching</td>\n</tr>\n<tr>\n<td>Required Claims Enforcement</td>\n<td>Ensure presence of mandatory claims</td>\n<td>Configurable requirement sets, missing claim detection</td>\n</tr>\n<tr>\n<td>Custom Claims Processing</td>\n<td>Extract and validate application-specific claims</td>\n<td>Type coercion, value range validation</td>\n</tr>\n</tbody></table>\n<p>The validation component handles <strong>clock skew</strong> by accepting a configurable tolerance window around time-based claims. This prevents legitimate tokens from being rejected due to minor time differences between servers while maintaining security boundaries.</p>\n<blockquote>\n<p><strong>Validation Philosophy</strong>: The component follows a &quot;secure by default&quot; approach where claims are rejected unless they explicitly pass all configured validation rules. This prevents subtle security vulnerabilities from missed validation checks.</p>\n</blockquote>\n<h3 id=\"recommended-module-structure\">Recommended Module Structure</h3>\n<p>The codebase organization reflects the component separation while providing clear entry points for common operations. The structure balances modularity with usability, ensuring that developers can either use high-level convenience functions or access individual components directly.</p>\n<h4 id=\"primary-module-layout\">Primary Module Layout</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>jwt-library/\n├── jwt/\n│   ├── __init__.py              ← High-level API exports\n│   ├── core.py                  ← Main create_token and verify_token functions\n│   ├── models.py                ← JWTHeader, JWTPayload, ValidationContext classes\n│   ├── encoding/\n│   │   ├── __init__.py          ← Encoding component exports\n│   │   ├── base64url.py         ← Base64URL encoding functions\n│   │   ├── json_encoder.py      ← JSON serialization with consistent formatting\n│   │   └── token_assembler.py   ← Token structure assembly\n│   ├── signing/\n│   │   ├── __init__.py          ← Signing component exports\n│   │   ├── hmac_signer.py       ← HMAC-SHA256 implementation\n│   │   ├── verifier.py          ← Signature verification with timing protection\n│   │   └── key_handler.py       ← Secret key validation and management\n│   ├── validation/\n│   │   ├── __init__.py          ← Validation component exports\n│   │   ├── claims_validator.py  ← Standard JWT claims validation\n│   │   ├── time_validator.py    ← Temporal claims (exp, nbf, iat) handling\n│   │   └── custom_validator.py  ← Custom claims processing\n│   ├── exceptions.py            ← All JWT-specific exception classes\n│   └── constants.py             ← Algorithm identifiers and default values\n├── tests/\n│   ├── unit/                    ← Component-level tests\n│   ├── integration/             ← Cross-component workflow tests\n│   └── security/                ← Timing attack and vulnerability tests\n└── examples/\n    ├── basic_usage.py           ← Simple token creation and verification\n    └── advanced_validation.py   ← Custom claims and validation contexts</code></pre></div>\n\n<h4 id=\"module-responsibility-boundaries\">Module Responsibility Boundaries</h4>\n<p>Each module maintains clear boundaries around its responsibilities and dependencies:</p>\n<table>\n<thead>\n<tr>\n<th>Module</th>\n<th>Depends On</th>\n<th>Exports To</th>\n<th>Internal Concerns</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>encoding/</code></td>\n<td>Standard library only</td>\n<td>All other components</td>\n<td>JSON formatting, Base64URL implementation</td>\n</tr>\n<tr>\n<td><code>signing/</code></td>\n<td><code>encoding/</code> for token parts</td>\n<td><code>core.py</code>, validation tests</td>\n<td>HMAC computation, timing attack prevention</td>\n</tr>\n<tr>\n<td><code>validation/</code></td>\n<td><code>models.py</code> for contexts</td>\n<td><code>core.py</code>, application code</td>\n<td>Claims parsing, time handling</td>\n</tr>\n<tr>\n<td><code>core.py</code></td>\n<td>All three components</td>\n<td>Application code</td>\n<td>Workflow orchestration, error translation</td>\n</tr>\n</tbody></table>\n<p>The <strong>dependency direction</strong> flows from core toward components, with components having minimal dependencies on each other. The encoding component has no dependencies on signing or validation, while signing only needs encoded token parts. This structure enables testing individual components in isolation and supports future extensibility.</p>\n<h4 id=\"public-api-surface\">Public API Surface</h4>\n<p>The library exposes a <strong>minimal public API</strong> that covers the majority of use cases while allowing access to component-level functionality for advanced scenarios:</p>\n<table>\n<thead>\n<tr>\n<th>API Level</th>\n<th>Functions</th>\n<th>Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>High-Level</td>\n<td><code>create_token()</code>, <code>verify_token()</code></td>\n<td>Standard JWT operations with reasonable defaults</td>\n</tr>\n<tr>\n<td>Component-Level</td>\n<td><code>encode_token_parts()</code>, <code>hmac_sign()</code>, <code>validate_claims()</code></td>\n<td>Custom workflows, testing, debugging</td>\n</tr>\n<tr>\n<td>Utility-Level</td>\n<td><code>base64url_encode()</code>, <code>utc_now()</code>, <code>is_expired()</code></td>\n<td>Integration with existing authentication systems</td>\n</tr>\n</tbody></table>\n<h3 id=\"token-lifecycle-flow\">Token Lifecycle Flow</h3>\n<p>The token lifecycle encompasses two primary workflows: <strong>token creation</strong> during authentication and <strong>token verification</strong> during authorization. Understanding these flows reveals how components collaborate and where data transformations occur.</p>\n<h4 id=\"token-creation-flow\">Token Creation Flow</h4>\n<p>Token creation transforms application data through a series of format and security transformations, ultimately producing a signed JWT string ready for transmission:</p>\n<ol>\n<li><p><strong>Application Input Processing</strong>: The application provides authentication context through <code>JWTHeader</code> and <code>JWTPayload</code> objects containing algorithm selection, token metadata, and user claims. The header specifies <code>HS256</code> algorithm and <code>JWT</code> token type, while the payload contains standard claims like <code>iss</code>, <code>sub</code>, and <code>exp</code> along with custom application data.</p>\n</li>\n<li><p><strong>JSON Serialization</strong>: The encoding component serializes both header and payload objects into consistent JSON representations. This step applies deterministic field ordering and proper character escaping to ensure that identical logical content always produces identical JSON strings, which is critical for signature consistency.</p>\n</li>\n<li><p><strong>Base64URL Encoding</strong>: The serialized JSON strings undergo <strong>Base64URL encoding</strong> to produce URL-safe string segments. This transformation removes padding characters and replaces problematic characters with URL-safe alternatives, ensuring tokens can be safely transmitted in URLs and HTTP headers.</p>\n</li>\n<li><p><strong>Signing Input Preparation</strong>: The encoded header and payload segments are concatenated with a dot separator to create the signing input string. This exact string becomes the input to the cryptographic signing process, establishing the data integrity boundary.</p>\n</li>\n<li><p><strong>HMAC Signature Generation</strong>: The signing component computes an HMAC-SHA256 hash over the signing input using the provided secret key. The resulting signature bytes are then Base64URL encoded to produce the final signature segment.</p>\n</li>\n<li><p><strong>Token Assembly</strong>: The three encoded segments (header, payload, signature) are concatenated with dot separators to form the final JWT token string. This standardized format enables interoperability with other JWT implementations.</p>\n</li>\n</ol>\n<p>The creation flow maintains <strong>data immutability</strong> by never modifying input objects, instead creating new representations at each transformation step. This prevents subtle bugs from shared mutable state and enables safe concurrent token creation.</p>\n<h4 id=\"token-verification-flow\">Token Verification Flow</h4>\n<p>Token verification reverses the creation process while applying security and semantic validation at each step:</p>\n<ol>\n<li><p><strong>Token Parsing</strong>: The verification process begins by splitting the input token string on dot separators and validating the three-part structure. Malformed tokens are immediately rejected without proceeding to expensive cryptographic operations.</p>\n</li>\n<li><p><strong>Base64URL Decoding</strong>: Each token segment undergoes Base64URL decoding to recover the original JSON strings and signature bytes. The decoding process validates character set compliance and reconstructs proper padding where necessary.</p>\n</li>\n<li><p><strong>JSON Deserialization</strong>: The decoded header and payload strings are parsed as JSON and validated against expected schemas. The header must contain valid <code>alg</code> and <code>typ</code> fields, while the payload is parsed into standard and custom claims structures.</p>\n</li>\n<li><p><strong>Signature Verification</strong>: If signature verification is enabled in the <code>ValidationContext</code>, the signing component recomputes the HMAC-SHA256 signature over the header and payload segments, then performs a constant-time comparison with the token&#39;s signature. This step confirms cryptographic authenticity.</p>\n</li>\n<li><p><strong>Claims Validation</strong>: The validation component applies business logic rules to the parsed claims. Time-based claims like <code>exp</code> and <code>nbf</code> are checked against the current time with <strong>clock skew</strong> tolerance, while identity claims like <code>iss</code> and <code>aud</code> are validated against configured allowed values.</p>\n</li>\n<li><p><strong>Custom Claims Processing</strong>: Application-specific claims are extracted and validated according to custom rules. The validation context specifies required custom claims and their expected types or value ranges.</p>\n</li>\n<li><p><strong>Result Assembly</strong>: Successfully validated tokens produce a <code>JWTPayload</code> object containing all claims, while validation failures raise specific exception types that indicate the failure category and provide debugging information.</p>\n</li>\n</ol>\n<p>The verification flow implements <strong>fail-fast semantics</strong> where validation stops at the first encountered error. This prevents resource waste on tokens that will ultimately be rejected and provides clear error categorization for debugging.</p>\n<h4 id=\"data-flow-state-transitions\">Data Flow State Transitions</h4>\n<p>Data flows through distinct states during token operations, with each state representing a different level of validation and trust:</p>\n<table>\n<thead>\n<tr>\n<th>State</th>\n<th>Data Format</th>\n<th>Validation Level</th>\n<th>Trust Boundary</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Raw Input</td>\n<td>Python objects</td>\n<td>Schema validation</td>\n<td>Application trust</td>\n</tr>\n<tr>\n<td>Serialized</td>\n<td>JSON strings</td>\n<td>Syntax validation</td>\n<td>Format compliance</td>\n</tr>\n<tr>\n<td>Encoded</td>\n<td>Base64URL strings</td>\n<td>Character set validation</td>\n<td>Transport safety</td>\n</tr>\n<tr>\n<td>Signed</td>\n<td>Complete JWT token</td>\n<td>Cryptographic validation</td>\n<td>Integrity assurance</td>\n</tr>\n<tr>\n<td>Verified</td>\n<td>Validated payload</td>\n<td>Claims validation</td>\n<td>Authorization ready</td>\n</tr>\n</tbody></table>\n<p>The state transitions are <strong>unidirectional</strong> during normal operation, with each step adding validation guarantees. Error conditions can cause transitions to failure states, but successful validation never moves backward through trust levels.</p>\n<h4 id=\"component-interaction-patterns\">Component Interaction Patterns</h4>\n<p>The three components interact through <strong>well-defined interface contracts</strong> that enable independent testing and future extensibility:</p>\n<p><strong>Encoding → Signing Interface</strong>: The encoding component provides the signing component with encoded header and payload strings as the signing input. The signing component treats this input as opaque binary data, applying HMAC computation without knowledge of the underlying JWT structure.</p>\n<p><strong>Signing → Validation Interface</strong>: The signing component reports verification success or failure to the validation component through boolean return values and exception types. The validation component proceeds with claims checking only after cryptographic verification succeeds.</p>\n<p><strong>Validation → Application Interface</strong>: The validation component returns validated <code>JWTPayload</code> objects to application code, ensuring that all returned data has passed both cryptographic and semantic validation. Error conditions are reported through specific exception types that enable appropriate application responses.</p>\n<blockquote>\n<p><strong>Interface Stability</strong>: The component interfaces are designed for stability across implementation changes. Internal optimizations, algorithm improvements, and security enhancements can be made within components without affecting other components or application code.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The implementation combines battle-tested cryptographic libraries with careful attention to security details and developer ergonomics. This guidance provides both complete infrastructure code and structured skeletons for core learning components.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Implementation</th>\n<th>Production Implementation</th>\n<th>Learning Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JSON Serialization</td>\n<td>Built-in <code>json</code> module</td>\n<td><code>json</code> with custom encoders</td>\n<td>Standard library provides consistency</td>\n</tr>\n<tr>\n<td>Base64URL Encoding</td>\n<td>Manual implementation</td>\n<td><code>base64.urlsafe_b64encode</code> + custom padding</td>\n<td>Understanding encoding mechanics</td>\n</tr>\n<tr>\n<td>HMAC Computation</td>\n<td><code>hmac</code> standard library</td>\n<td><code>cryptography</code> library</td>\n<td>Focus on timing attack prevention</td>\n</tr>\n<tr>\n<td>Time Handling</td>\n<td><code>datetime</code> with UTC</td>\n<td><code>datetime</code> with timezone awareness</td>\n<td>Emphasizes UTC-only approach</td>\n</tr>\n<tr>\n<td>Testing Framework</td>\n<td>Built-in <code>unittest</code></td>\n<td><code>pytest</code> with fixtures</td>\n<td>Structured test organization</td>\n</tr>\n</tbody></table>\n<h4 id=\"complete-infrastructure-code\">Complete Infrastructure Code</h4>\n<p>Here&#39;s the foundational infrastructure that handles cross-cutting concerns:</p>\n<p><strong>File: <code>jwt/models.py</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Core data structures for JWT library.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">These classes define the contract between components and provide type safety.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Union, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> JWTHeader</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"JWT header containing algorithm and type information.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    alg: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"HS256\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    typ: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"JWT\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_dict</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert to dictionary for JSON serialization.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">\"alg\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.alg, </span><span style=\"color:#9ECBFF\">\"typ\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.typ}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> JWTPayload</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"JWT payload containing standard and custom claims.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Standard registered claims</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    iss: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # Issuer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sub: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # Subject  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    aud: Optional[Union[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # Audience</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    exp: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # Expiration time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nbf: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # Not before time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    iat: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # Issued at time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    jti: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # JWT ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Custom claims</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    custom_claims: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_dict</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert to dictionary for JSON serialization, excluding None values.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Add standard claims if present</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.iss </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[</span><span style=\"color:#9ECBFF\">\"iss\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.iss</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.sub </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[</span><span style=\"color:#9ECBFF\">\"sub\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.sub  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.aud </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[</span><span style=\"color:#9ECBFF\">\"aud\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.aud</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.exp </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[</span><span style=\"color:#9ECBFF\">\"exp\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.exp</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.nbf </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[</span><span style=\"color:#9ECBFF\">\"nbf\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.nbf</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.iat </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[</span><span style=\"color:#9ECBFF\">\"iat\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.iat</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.jti </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[</span><span style=\"color:#9ECBFF\">\"jti\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.jti</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Add custom claims</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result.update(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.custom_claims)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ValidationContext</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Configuration for token validation behavior.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Signature verification</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    verify_signature: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Time-based validation  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    verify_expiration: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    verify_not_before: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leeway_seconds: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 300</span><span style=\"color:#6A737D\">  # 5 minutes clock skew tolerance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Issuer validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    allowed_issuers: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    require_issuer: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Audience validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expected_audience: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    require_audience: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Required claims</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    required_claims: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>File: <code>jwt/constants.py</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Constants and identifiers used throughout the JWT library.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Algorithm identifiers</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">HS256</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"HS256\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Token type identifier  </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">JWT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"JWT\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Default clock skew tolerance (5 minutes)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">DEFAULT_LEEWAY_SECONDS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 300</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Minimum secure key lengths (in bytes)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">MIN_HMAC_KEY_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 32</span></span></code></pre></div>\n\n<p><strong>File: <code>jwt/exceptions.py</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Exception hierarchy for JWT library errors.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Provides specific error types for different failure categories.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> JWTError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base exception for all JWT-related errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InvalidTokenError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Token format or structure is invalid.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SignatureVerificationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Token signature verification failed.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ExpiredTokenError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Token has expired.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> NotBeforeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Token is not yet valid (nbf claim).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InvalidIssuerError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Token issuer is not allowed.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InvalidAudienceError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Token audience does not match expected value.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MissingClaimError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Required claim is missing from token.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InvalidKeyError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Signing key is invalid or insecure.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"core-component-skeletons\">Core Component Skeletons</h4>\n<p><strong>File: <code>jwt/encoding/base64url.py</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Base64URL encoding implementation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Focus: Understanding URL-safe encoding and padding handling.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> base64</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> base64url_encode</span><span style=\"color:#E1E4E8\">(data: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Encode bytes to URL-safe Base64 without padding.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    This is a core JWT requirement - learn the padding rules!</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Use base64.urlsafe_b64encode() to get initial encoding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Convert bytes result to string </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Remove trailing '=' padding characters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return the clean URL-safe string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use .rstrip('=') to remove padding</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> base64url_decode</span><span style=\"color:#E1E4E8\">(data: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Decode Base64URL back to bytes with padding restoration.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Must handle missing padding that was removed during encoding.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Calculate how much padding is needed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add '=' characters to make length divisible by 4</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Use base64.urlsafe_b64decode() to decode</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return the decoded bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: padding = 4 - (len(data) % 4) if len(data) % 4 != 0 else 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p><strong>File: <code>jwt/core.py</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Main entry point functions for JWT operations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Orchestrates the three components to provide simple APIs.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timezone</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .models </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> JWTHeader, JWTPayload, ValidationContext</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .encoding.base64url </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> base64url_encode, base64url_decode</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .exceptions </span><span style=\"color:#F97583\">import</span><span style=\"color:#F97583\"> *</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> utc_now</span><span style=\"color:#E1E4E8\">() -> datetime:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Get current UTC time for token operations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> datetime.now(timezone.utc)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> to_unix_timestamp</span><span style=\"color:#E1E4E8\">(dt: datetime) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convert datetime to Unix timestamp.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">(dt.timestamp())</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_token</span><span style=\"color:#E1E4E8\">(header: JWTHeader, payload: JWTPayload, secret_key: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Generate a signed JWT token.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    This orchestrates all three components:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    1. Encoding component creates the token structure</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    2. Signing component generates the signature  </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    3. Assembly combines everything into final token</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate secret_key meets minimum length requirements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Serialize header and payload to JSON (use json.dumps with sort_keys=True)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Base64URL encode both JSON strings  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create signing input by joining header.payload with dot</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Generate HMAC-SHA256 signature over signing input</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Base64URL encode the signature</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Return final token as header.payload.signature</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use the infrastructure functions and follow the token creation flow</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> verify_token</span><span style=\"color:#E1E4E8\">(token: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, secret_key: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, context: ValidationContext) -> JWTPayload:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Verify a JWT token and return validated payload.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    This implements the complete verification flow:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    1. Parse token structure</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    2. Verify signature if enabled</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    3. Validate all claims according to context</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    4. Return payload if everything passes</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Split token on '.' and validate 3-part structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Base64URL decode header, payload, and signature</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Parse header and payload JSON</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Verify signature if context.verify_signature is True</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Validate expiration if context.verify_expiration is True  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Validate not-before if context.verify_not_before is True</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Validate issuer and audience according to context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Check for required claims</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Return JWTPayload with all claims</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Raise specific exception types for each validation failure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After Milestone 1 (JWT Structure)</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test basic encoding functionality</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">from jwt.encoding.base64url import base64url_encode, base64url_decode</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">test_data = b'Hello JWT'</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">encoded = base64url_encode(test_data)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">decoded = base64url_decode(encoded)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">print(f'Original: {test_data}')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">print(f'Encoded: {encoded}') </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">print(f'Decoded: {decoded}')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">print(f'Success: {test_data == decoded}')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<p>Expected output shows URL-safe encoding without padding and successful round-trip conversion.</p>\n<p><strong>After Milestone 2 (HMAC Signing)</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test token creation and signature verification</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">from jwt.core import create_token, verify_token</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">from jwt.models import JWTHeader, JWTPayload, ValidationContext</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">import json</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">header = JWTHeader()</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">payload = JWTPayload(sub='user123', exp=9999999999)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">secret = b'your-256-bit-secret'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">token = create_token(header, payload, secret)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">print(f'Created token: {token}')</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\"># Verify signature only</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">context = ValidationContext(verify_expiration=False)  </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">verified = verify_token(token, secret, context)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">print(f'Verified payload: {verified}')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<p><strong>After Milestone 3 (Claims Validation)</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test complete claims validation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">from jwt.core import create_token, verify_token  </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">from jwt.models import JWTHeader, JWTPayload, ValidationContext</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">from datetime import datetime, timezone, timedelta</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\"># Create token with realistic expiration</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">header = JWTHeader()</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">exp_time = datetime.now(timezone.utc) + timedelta(hours=1)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">payload = JWTPayload(</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    iss='test-issuer',</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    sub='user123', </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    aud='test-audience',</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    exp=int(exp_time.timestamp())</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">secret = b'your-256-bit-secret'</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">token = create_token(header, payload, secret)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\"># Full validation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">context = ValidationContext(</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    allowed_issuers=['test-issuer'],</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    expected_audience='test-audience',</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    require_issuer=True,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    require_audience=True</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">verified = verify_token(token, secret, context)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">print(f'Fully validated: {verified.sub}')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n\n<h2 id=\"data-model\">Data Model</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundation for all three milestones - defines core data structures for token encoding (Milestone 1), HMAC signing (Milestone 2), and claims validation (Milestone 3)</p>\n</blockquote>\n<p>The data model forms the backbone of our JWT library, defining how tokens are structured internally and how validation requirements are configured. Think of the data model as the blueprint for a secure document system - just as a passport has standardized sections for personal information, security features, and validation stamps, a JWT has well-defined sections for metadata, claims, and cryptographic proof.</p>\n<p>Understanding the JWT data model requires grasping four key concepts: the three-part token structure that enables tamper detection, header claims that describe the token&#39;s cryptographic properties, payload claims that carry the actual authentication data, and validation context that controls how strictly we verify tokens. Each of these elements serves a specific security purpose and must be designed to prevent common authentication vulnerabilities.</p>\n<p><img src=\"/api/project/jwt-impl/architecture-doc/asset?path=diagrams%2Fjwt-structure.svg\" alt=\"JWT Token Structure and Data Model\"></p>\n<h3 id=\"jwt-token-structure-the-three-part-jwt-format-and-its-encoding-requirements\">JWT Token Structure: The Three-Part JWT Format and Its Encoding Requirements</h3>\n<p>The JWT token structure follows a precise three-part format that enables stateless authentication through cryptographic verification. Think of this structure like a sealed envelope system: the header is the address label that tells us how to handle the envelope, the payload is the letter inside containing the actual message, and the signature is the wax seal that proves the envelope hasn&#39;t been tampered with during delivery.</p>\n<p>The complete JWT token consists of three Base64URL-encoded sections separated by dot characters, forming the pattern <code>header.payload.signature</code>. This dot-separated format serves multiple purposes: it creates clear boundaries between sections, ensures the token remains a single string suitable for HTTP headers, and provides a consistent parsing target for verification algorithms. The specific choice of dots as separators was made because dots are safe characters in URLs, HTTP headers, and most programming language string handling routines.</p>\n<p><strong>Base64URL encoding</strong> is a critical aspect of JWT structure that differs from standard Base64 encoding. While standard Base64 uses characters that can cause problems in URLs and HTTP headers (specifically <code>+</code>, <code>/</code>, and <code>=</code> padding), Base64URL replaces these with URL-safe alternatives. The <code>+</code> character becomes <code>-</code>, the <code>/</code> character becomes <code>_</code>, and padding characters are completely removed. This encoding choice ensures that JWT tokens can be safely transmitted in URL parameters, HTTP Authorization headers, and HTML form fields without requiring additional escaping.</p>\n<p>The encoding process for each section follows a specific sequence: first, the header or payload data is serialized to JSON with consistent key ordering, then the resulting JSON bytes are encoded using Base64URL encoding with padding removal, and finally the encoded strings are concatenated with dot separators. This process must be deterministic to ensure that the same input always produces the same token, which is essential for signature verification.</p>\n<table>\n<thead>\n<tr>\n<th>Token Component</th>\n<th>Content Type</th>\n<th>Encoding Process</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Header</td>\n<td>JSON metadata</td>\n<td>Serialize to JSON → Base64URL encode → remove padding</td>\n<td>Specifies algorithm and token type</td>\n</tr>\n<tr>\n<td>Payload</td>\n<td>JSON claims</td>\n<td>Serialize to JSON → Base64URL encode → remove padding</td>\n<td>Contains authentication and authorization data</td>\n</tr>\n<tr>\n<td>Signature</td>\n<td>Binary signature</td>\n<td>Generate HMAC → Base64URL encode → remove padding</td>\n<td>Provides cryptographic proof of authenticity</td>\n</tr>\n</tbody></table>\n<p>The parsing process reverses this encoding: tokens are split on dot characters to extract the three sections, each section is Base64URL decoded with proper padding restoration, and the header and payload sections are parsed as JSON to extract their claims. Proper error handling during parsing is crucial because malformed tokens could indicate either transmission errors or malicious tampering attempts.</p>\n<blockquote>\n<p><strong>Decision: Three-Part Dot-Separated Structure</strong></p>\n<ul>\n<li><strong>Context</strong>: JWTs need to be transmitted as single strings while maintaining clear separation between metadata, data, and proof</li>\n<li><strong>Options Considered</strong>: XML structure with tags, JSON with nested objects, custom binary format, dot-separated Base64 sections</li>\n<li><strong>Decision</strong>: Dot-separated Base64URL-encoded sections</li>\n<li><strong>Rationale</strong>: Provides clear section boundaries, remains URL-safe, enables streaming parsing, and maintains compatibility with HTTP header size limits</li>\n<li><strong>Consequences</strong>: Enables efficient parsing and validation while keeping tokens compact and transmission-friendly</li>\n</ul>\n</blockquote>\n<h3 id=\"header-claims-standard-and-custom-header-fields-with-their-types-and-meanings\">Header Claims: Standard and Custom Header Fields With Their Types and Meanings</h3>\n<p>The JWT header contains metadata that describes how to process and verify the token. Think of the header as the instruction manual attached to a secure package - it tells the recipient which tools to use for opening the package and what security procedures to follow for verification. The header must be present in every JWT and contains critical information that determines the token&#39;s security properties.</p>\n<p>The <strong>Algorithm</strong> field (<code>alg</code>) specifies the cryptographic algorithm used to generate the token&#39;s signature. This field is mandatory and must contain a value from the JSON Web Signature (JWS) algorithm registry. For our implementation, we focus on <code>HS256</code> (HMAC with SHA-256), which provides symmetric key authentication suitable for scenarios where the token issuer and verifier share a secret key. The algorithm field serves as a contract between the token creator and verifier, ensuring both parties use compatible cryptographic operations.</p>\n<p>The <strong>Token Type</strong> field (<code>typ</code>) identifies the token as a JWT, distinguishing it from other token formats that might use similar encoding schemes. While this field is technically optional according to the JWT specification, including it provides explicit type safety and helps prevent confusion when applications handle multiple token types. The standard value for this field is the string <code>JWT</code>, written in uppercase to match the specification examples.</p>\n<p>Additional header fields can be included to support advanced features like key identification (<code>kid</code> for key ID), critical header parameters (<code>crit</code> for parameters that must be understood), and content type declarations (<code>cty</code> for nested JWT content). However, our initial implementation focuses on the core algorithm and type fields to maintain simplicity while establishing a foundation for future extensions.</p>\n<table>\n<thead>\n<tr>\n<th>Header Field</th>\n<th>Type</th>\n<th>Required</th>\n<th>Description</th>\n<th>Example Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>alg</code></td>\n<td>string</td>\n<td>Yes</td>\n<td>Cryptographic algorithm identifier</td>\n<td><code>&quot;HS256&quot;</code></td>\n</tr>\n<tr>\n<td><code>typ</code></td>\n<td>string</td>\n<td>Recommended</td>\n<td>Token type declaration</td>\n<td><code>&quot;JWT&quot;</code></td>\n</tr>\n<tr>\n<td><code>kid</code></td>\n<td>string</td>\n<td>No</td>\n<td>Key identifier for key rotation</td>\n<td><code>&quot;key-2023-01&quot;</code></td>\n</tr>\n<tr>\n<td><code>crit</code></td>\n<td>array[string]</td>\n<td>No</td>\n<td>Critical header parameters</td>\n<td><code>[&quot;exp&quot;, &quot;nbf&quot;]</code></td>\n</tr>\n<tr>\n<td><code>cty</code></td>\n<td>string</td>\n<td>No</td>\n<td>Content type for nested tokens</td>\n<td><code>&quot;JWT&quot;</code></td>\n</tr>\n</tbody></table>\n<p>Header validation must verify that the algorithm field contains a supported value and matches the algorithm expected by the verification context. <strong>Algorithm confusion attacks</strong> represent a significant security risk where attackers modify the algorithm field to exploit differences in cryptographic processing. For example, changing <code>HS256</code> to <code>none</code> might bypass signature verification entirely if the verifier doesn&#39;t properly validate algorithm constraints.</p>\n<p>The header encoding process requires consistent JSON serialization to ensure deterministic signatures. Field ordering within the JSON object can affect the serialized bytes, so implementations must either use ordered dictionaries or rely on JSON libraries that maintain consistent key ordering. This consistency is crucial because the signature covers the encoded header, and any variation in encoding would invalidate the signature verification process.</p>\n<blockquote>\n<p><strong>Decision: Minimal Header Claims for Initial Implementation</strong></p>\n<ul>\n<li><strong>Context</strong>: JWT headers can contain many optional fields, but we need to balance security with implementation complexity</li>\n<li><strong>Options Considered</strong>: Support all RFC-defined header claims, support only mandatory claims, include commonly-used optional claims</li>\n<li><strong>Decision</strong>: Support <code>alg</code> and <code>typ</code> fields only, with extensibility for future claims</li>\n<li><strong>Rationale</strong>: Focuses implementation effort on core security properties while establishing patterns for future extensions</li>\n<li><strong>Consequences</strong>: Simplifies initial development and testing while providing a foundation for advanced features like key rotation</li>\n</ul>\n</blockquote>\n<h3 id=\"payload-claims-registered-public-and-private-claims-in-the-payload-section\">Payload Claims: Registered, Public, and Private Claims in the Payload Section</h3>\n<p>The JWT payload contains <strong>claims</strong> - statements about an entity that provide the actual authentication and authorization data. Think of claims like the information fields on a driver&#39;s license: some fields are standardized across all licenses (name, expiration date, issuing authority), while others might be specific to certain jurisdictions or use cases (motorcycle endorsement, organ donor status). Similarly, JWT claims fall into three categories that balance standardization with flexibility.</p>\n<p><strong>Registered claims</strong> are standardized field names defined by the JWT specification that provide common authentication and authorization semantics. These claims have precise meanings and expected formats that enable interoperability between different JWT implementations. The most important registered claims for authentication workflows include issuer identification, subject identification, audience restriction, and time-based validity controls.</p>\n<p>The <strong>Issuer</strong> claim (<code>iss</code>) identifies the principal that issued the JWT, typically represented as a string containing a URL or other identifier that uniquely identifies the authentication server. This claim enables token verification systems to distinguish between tokens from different sources and implement appropriate trust policies. For example, tokens issued by <code>https://auth.example.com</code> might be trusted for internal application access, while tokens from external identity providers require different validation rules.</p>\n<p>The <strong>Subject</strong> claim (<code>sub</code>) identifies the principal that is the subject of the JWT, typically representing the user or service account for which the token was issued. This claim should contain a unique identifier that remains stable across the subject&#39;s lifecycle but doesn&#39;t necessarily need to be human-readable. Many implementations use UUIDs or internal user IDs rather than email addresses to avoid privacy concerns and handle email address changes gracefully.</p>\n<p>The <strong>Audience</strong> claim (<code>aud</code>) identifies the recipients that the JWT is intended for, preventing tokens from being misused across different applications or services. This claim can contain either a single string or an array of strings, allowing tokens to be valid for multiple related services while preventing unauthorized cross-service token reuse. Proper audience validation is crucial for preventing <strong>token substitution attacks</strong> where tokens intended for one service are replayed against another service.</p>\n<table>\n<thead>\n<tr>\n<th>Registered Claim</th>\n<th>Type</th>\n<th>Description</th>\n<th>Example Value</th>\n<th>Validation Requirements</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>iss</code></td>\n<td>string</td>\n<td>Token issuer identifier</td>\n<td><code>&quot;https://auth.example.com&quot;</code></td>\n<td>Must match allowed issuer list</td>\n</tr>\n<tr>\n<td><code>sub</code></td>\n<td>string</td>\n<td>Subject (user/service) identifier</td>\n<td><code>&quot;user123&quot;</code></td>\n<td>Should be unique and stable</td>\n</tr>\n<tr>\n<td><code>aud</code></td>\n<td>string or array</td>\n<td>Intended audience(s)</td>\n<td><code>&quot;api.example.com&quot;</code></td>\n<td>Must contain expected audience</td>\n</tr>\n<tr>\n<td><code>exp</code></td>\n<td>integer</td>\n<td>Expiration time (Unix timestamp)</td>\n<td><code>1640995200</code></td>\n<td>Must be in the future (with leeway)</td>\n</tr>\n<tr>\n<td><code>nbf</code></td>\n<td>integer</td>\n<td>Not-before time (Unix timestamp)</td>\n<td><code>1640908800</code></td>\n<td>Current time must be after this value</td>\n</tr>\n<tr>\n<td><code>iat</code></td>\n<td>integer</td>\n<td>Issued-at time (Unix timestamp)</td>\n<td><code>1640908800</code></td>\n<td>Should be reasonable (not too old/future)</td>\n</tr>\n<tr>\n<td><code>jti</code></td>\n<td>string</td>\n<td>JWT ID (unique token identifier)</td>\n<td><code>&quot;abc123&quot;</code></td>\n<td>Should be unique per issuer</td>\n</tr>\n</tbody></table>\n<p><strong>Time-based claims</strong> provide temporal validity controls that are essential for security. The <strong>Expiration</strong> claim (<code>exp</code>) specifies when the token becomes invalid, preventing indefinite token reuse and limiting the impact of token compromise. The <strong>Not Before</strong> claim (<code>nbf</code>) specifies the earliest time when the token becomes valid, supporting use cases like scheduled access grants or delayed activation. The <strong>Issued At</strong> claim (<code>iat</code>) records when the token was created, enabling age-based validation and helping detect tokens that are unreasonably old or claim to be issued in the future.</p>\n<p><strong>Public claims</strong> are field names that are either registered in the IANA JSON Web Token Claims registry or use collision-resistant names (typically URLs) to avoid conflicts with other implementations. These claims provide standardized semantics for common use cases beyond the core registered claims, such as email addresses (<code>email</code>), roles (<code>roles</code>), or permissions (<code>permissions</code>). Using public claims promotes interoperability while extending JWT functionality.</p>\n<p><strong>Private claims</strong> are field names agreed upon by the token producer and consumer for application-specific data. These claims should avoid conflicts with registered and public claims by using prefixes or namespaces that are unlikely to collide with future standards. Private claims provide the flexibility needed for application-specific authorization data while maintaining the benefits of the JWT structure.</p>\n<table>\n<thead>\n<tr>\n<th>Claim Category</th>\n<th>Naming Convention</th>\n<th>Example Claims</th>\n<th>Conflict Resolution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Registered</td>\n<td>RFC 7519 standard names</td>\n<td><code>iss</code>, <code>sub</code>, <code>aud</code>, <code>exp</code></td>\n<td>Defined by specification</td>\n</tr>\n<tr>\n<td>Public</td>\n<td>IANA registry or URL names</td>\n<td><code>email</code>, <code>https://example.com/roles</code></td>\n<td>Registry or URL collision resistance</td>\n</tr>\n<tr>\n<td>Private</td>\n<td>Application-specific names</td>\n<td><code>user_role</code>, <code>app_permissions</code></td>\n<td>Mutual agreement between parties</td>\n</tr>\n</tbody></table>\n<p>The payload encoding follows the same Base64URL process as the header, but the payload typically contains more data and requires careful handling of nested objects and arrays. Custom claims can include complex data structures, but implementations should be cautious about token size limits imposed by HTTP headers and URL length restrictions. Large payloads can also impact token parsing performance and network transmission efficiency.</p>\n<blockquote>\n<p><strong>Decision: Flexible Custom Claims Support Through Dictionary</strong></p>\n<ul>\n<li><strong>Context</strong>: Applications need to include custom authorization data beyond registered claims</li>\n<li><strong>Options Considered</strong>: Strict schema with predefined fields, completely flexible unstructured data, hybrid approach with registered claims plus custom dictionary</li>\n<li><strong>Decision</strong>: Structured registered claims with a <code>custom_claims</code> dictionary for application-specific data</li>\n<li><strong>Rationale</strong>: Provides type safety for standard claims while maintaining flexibility for custom use cases</li>\n<li><strong>Consequences</strong>: Enables clear validation of standard claims while allowing applications to extend functionality without breaking compatibility</li>\n</ul>\n</blockquote>\n<h3 id=\"validation-context-configuration-and-state-needed-for-proper-token-verification\">Validation Context: Configuration and State Needed for Proper Token Verification</h3>\n<p>The validation context encapsulates all the configuration and runtime state needed to properly verify JWT tokens according to application-specific security requirements. Think of validation context as the security checkpoint instructions at an airport - different checkpoints might have different requirements based on the destination, time of day, and current threat level, but all checkpoints follow consistent procedures for document verification and security screening.</p>\n<p><strong>Signature verification control</strong> determines whether the cryptographic signature should be validated during token processing. While signature verification is typically enabled for production use, development and testing scenarios might need to disable signature checking to use unsigned tokens or tokens signed with different keys. The validation context provides this control through a boolean flag that affects the entire verification process.</p>\n<p><strong>Expiration checking control</strong> manages how strictly the system enforces time-based token validity. Applications might need different approaches to expiration handling based on their security requirements and operational constraints. Critical security operations might require strict expiration enforcement with minimal leeway, while user-facing applications might allow more generous <strong>clock skew</strong> tolerance to handle minor time synchronization differences between servers.</p>\n<p>The <strong>leeway mechanism</strong> addresses the practical reality that distributed systems rarely have perfectly synchronized clocks. Clock skew between the token issuer and verifier can cause valid tokens to be rejected if the clocks differ by even a few seconds. The leeway setting specifies how many seconds of time difference to tolerate when evaluating time-based claims, balancing security (shorter leeway) with operational reliability (longer leeway).</p>\n<p><strong>Issuer validation</strong> controls which token issuers the application trusts, preventing unauthorized token sources from gaining access to protected resources. The validation context maintains a list of allowed issuer identifiers and configures whether issuer validation is required or optional. This capability is essential for applications that might accept tokens from multiple identity providers or need to migrate between different authentication systems.</p>\n<p><strong>Audience validation</strong> ensures that tokens are only accepted by their intended recipients, preventing <strong>cross-service token reuse attacks</strong>. The validation context specifies the expected audience value for the current service and controls whether audience validation is mandatory or optional. Proper audience validation is crucial in microservice architectures where services might share authentication infrastructure but need to prevent token misuse between services.</p>\n<table>\n<thead>\n<tr>\n<th>Validation Setting</th>\n<th>Type</th>\n<th>Description</th>\n<th>Default Value</th>\n<th>Security Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>verify_signature</code></td>\n<td>boolean</td>\n<td>Enable cryptographic signature verification</td>\n<td><code>true</code></td>\n<td>Critical - disabling bypasses authentication</td>\n</tr>\n<tr>\n<td><code>verify_expiration</code></td>\n<td>boolean</td>\n<td>Enforce expiration time validation</td>\n<td><code>true</code></td>\n<td>High - prevents indefinite token reuse</td>\n</tr>\n<tr>\n<td><code>verify_not_before</code></td>\n<td>boolean</td>\n<td>Enforce not-before time validation</td>\n<td><code>true</code></td>\n<td>Medium - prevents premature token use</td>\n</tr>\n<tr>\n<td><code>leeway_seconds</code></td>\n<td>integer</td>\n<td>Clock skew tolerance in seconds</td>\n<td><code>300</code></td>\n<td>Medium - balance security vs reliability</td>\n</tr>\n<tr>\n<td><code>allowed_issuers</code></td>\n<td>array[string]</td>\n<td>List of trusted token issuers</td>\n<td><code>[]</code></td>\n<td>High - controls which sources are trusted</td>\n</tr>\n<tr>\n<td><code>require_issuer</code></td>\n<td>boolean</td>\n<td>Mandate issuer claim presence</td>\n<td><code>false</code></td>\n<td>Medium - depends on trust model</td>\n</tr>\n<tr>\n<td><code>expected_audience</code></td>\n<td>string</td>\n<td>Required audience value</td>\n<td><code>&quot;&quot;</code></td>\n<td>High - prevents cross-service token reuse</td>\n</tr>\n<tr>\n<td><code>require_audience</code></td>\n<td>boolean</td>\n<td>Mandate audience claim presence</td>\n<td><code>false</code></td>\n<td>High - essential for multi-service deployments</td>\n</tr>\n<tr>\n<td><code>required_claims</code></td>\n<td>array[string]</td>\n<td>Claims that must be present</td>\n<td><code>[]</code></td>\n<td>Variable - depends on application needs</td>\n</tr>\n</tbody></table>\n<p><strong>Required claims validation</strong> allows applications to specify which claims must be present in valid tokens, beyond the standard registered claims. Different application endpoints might require different sets of claims - for example, administrative operations might require role claims while user data access might only require subject identification. The validation context maintains a list of required claim names and ensures that all specified claims are present with non-empty values.</p>\n<p>The validation context also manages <strong>temporal validation state</strong> by providing access to the current time in a consistent format. This centralized time management enables testing with frozen time values and ensures consistent behavior across all time-based validations. The context uses UTC time exclusively to avoid timezone-related complications and provides helper functions for converting between different time representations.</p>\n<p>Error handling within the validation context distinguishes between different types of validation failures to enable appropriate error responses and logging. <strong>Configuration errors</strong> (invalid validation settings) should be detected early during application startup, while <strong>token validation errors</strong> (expired tokens, invalid signatures) should be handled gracefully during request processing without exposing sensitive details about the validation process.</p>\n<table>\n<thead>\n<tr>\n<th>Validation Error Type</th>\n<th>Detection Timing</th>\n<th>Example Scenarios</th>\n<th>Recommended Response</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Configuration Error</td>\n<td>Application startup</td>\n<td>Invalid issuer URL format</td>\n<td>Fail application startup</td>\n</tr>\n<tr>\n<td>Token Format Error</td>\n<td>Request processing</td>\n<td>Malformed Base64URL encoding</td>\n<td>Return 400 Bad Request</td>\n</tr>\n<tr>\n<td>Signature Error</td>\n<td>Request processing</td>\n<td>Invalid HMAC signature</td>\n<td>Return 401 Unauthorized</td>\n</tr>\n<tr>\n<td>Claims Error</td>\n<td>Request processing</td>\n<td>Missing required claims</td>\n<td>Return 401 Unauthorized</td>\n</tr>\n<tr>\n<td>Temporal Error</td>\n<td>Request processing</td>\n<td>Expired or not-yet-valid token</td>\n<td>Return 401 Unauthorized</td>\n</tr>\n</tbody></table>\n<p>The validation context must be <strong>immutable during request processing</strong> to prevent race conditions and ensure consistent validation behavior. Applications should create validation contexts during startup or configuration loading and reuse the same context instance across multiple token verification operations. Changes to validation requirements should require creating new context instances rather than modifying existing ones.</p>\n<blockquote>\n<p><strong>Decision: Comprehensive Validation Context with Granular Controls</strong></p>\n<ul>\n<li><strong>Context</strong>: Different applications and deployment scenarios require different validation strictness levels</li>\n<li><strong>Options Considered</strong>: Fixed validation rules, completely configurable validation, preset validation profiles with limited customization</li>\n<li><strong>Decision</strong>: Granular boolean controls for each validation aspect with sensible defaults</li>\n<li><strong>Rationale</strong>: Provides maximum flexibility for different security requirements while maintaining clear semantics for each validation type</li>\n<li><strong>Consequences</strong>: Enables fine-tuned security policies but requires careful consideration of the security implications of each validation setting</li>\n</ul>\n</blockquote>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Using Standard Base64 Instead of Base64URL</strong>\nJWT tokens must use Base64URL encoding, not standard Base64 encoding. Standard Base64 uses <code>+</code> and <code>/</code> characters that are not URL-safe and includes <code>=</code> padding characters that create parsing ambiguity. Using standard Base64 will cause tokens to be malformed when transmitted in URLs or HTTP headers, leading to parsing failures and authentication errors. Always use Base64URL encoding with proper padding removal and restoration.</p>\n<p>⚠️ <strong>Pitfall: Inconsistent JSON Serialization Order</strong>\nJSON object key ordering affects the serialized bytes, which impacts signature verification. Different JSON libraries may serialize the same object with different key orders, causing signature verification to fail even when the content is identical. Use JSON libraries that maintain consistent key ordering or explicitly sort keys before serialization to ensure deterministic encoding.</p>\n<p>⚠️ <strong>Pitfall: Storing Sensitive Data in JWT Payloads</strong>\nJWT payloads are encoded but not encrypted - they can be decoded by anyone who has access to the token. Never store passwords, API keys, or other sensitive data in JWT claims. JWTs should contain only the minimum information needed for authentication and authorization decisions, with sensitive data retrieved from secure storage using the JWT&#39;s subject identifier.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Clock Skew in Time-Based Claims</strong>\nDistributed systems rarely have perfectly synchronized clocks, so strict time validation without leeway will cause valid tokens to be rejected due to minor time differences. However, excessive leeway creates security vulnerabilities by allowing expired tokens to remain valid longer than intended. Use appropriate leeway values (typically 5-15 minutes) based on your infrastructure&#39;s time synchronization accuracy.</p>\n<p>⚠️ <strong>Pitfall: Accepting Tokens Without Audience Validation</strong>\nSkipping audience validation allows tokens intended for one service to be used against another service, creating security vulnerabilities in multi-service architectures. Always validate that the token&#39;s audience claim matches the expected value for your service, and require the audience claim to be present unless you have a specific reason to make it optional.</p>\n<p>⚠️ <strong>Pitfall: Using Mutable Validation Context During Request Processing</strong>\nModifying validation context settings during request processing can create race conditions and inconsistent validation behavior. Validation contexts should be created once during application startup and reused across multiple requests. If validation requirements change, create new context instances rather than modifying existing ones.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The data model implementation requires careful attention to data structure design and serialization consistency. This section provides the foundation types and utilities needed to represent JWT tokens internally and configure validation behavior properly.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JSON Serialization</td>\n<td><code>json</code> standard library with manual ordering</td>\n<td><code>dataclasses-json</code> with custom serializers</td>\n</tr>\n<tr>\n<td>Time Handling</td>\n<td><code>datetime</code> with UTC timezone</td>\n<td><code>pendulum</code> for advanced timezone handling</td>\n</tr>\n<tr>\n<td>Base64URL Encoding</td>\n<td>Custom implementation using <code>base64</code></td>\n<td><code>python-jose</code> library utilities</td>\n</tr>\n<tr>\n<td>Data Validation</td>\n<td>Manual type checking with assertions</td>\n<td><code>pydantic</code> for schema validation</td>\n</tr>\n<tr>\n<td>Immutable Data</td>\n<td><code>dataclass</code> with <code>frozen=True</code></td>\n<td><code>attrs</code> library with immutability</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-filemodule-structure\">Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>jwt-library/\n├── src/jwt_library/\n│   ├── __init__.py              ← main exports\n│   ├── data_model.py            ← this section - core data structures\n│   ├── encoding.py              ← token encoding (Milestone 1)\n│   ├── signing.py               ← HMAC signing (Milestone 2)\n│   ├── validation.py            ← claims validation (Milestone 3)\n│   └── exceptions.py            ← error types\n├── tests/\n│   ├── test_data_model.py       ← data structure tests\n│   ├── test_encoding.py         ← encoding tests\n│   ├── test_signing.py          ← signing tests\n│   └── test_validation.py       ← validation tests\n└── examples/\n    ├── basic_usage.py           ← simple token creation/verification\n    └── custom_claims.py         ← advanced claims handling</code></pre></div>\n\n<h4 id=\"core-data-structure-implementation\">Core Data Structure Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Union, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> base64</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Constants for standard values</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">HS256</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"HS256\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">JWT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"JWT\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">DEFAULT_LEEWAY_SECONDS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 300</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> JWTHeader</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"JWT Header containing algorithm and type information.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    This structure represents the first part of a JWT token and contains</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    metadata about how to process the token's signature.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    alg: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # Cryptographic algorithm (e.g., \"HS256\")</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    typ: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # Token type (typically \"JWT\")</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_dict</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert header to dictionary for JSON serialization.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return dictionary with alg and typ fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Ensure consistent key ordering for deterministic serialization</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_dict</span><span style=\"color:#E1E4E8\">(cls, data: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> </span><span style=\"color:#9ECBFF\">'JWTHeader'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create header from dictionary parsed from JSON.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Extract alg and typ fields from dictionary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate that required fields are present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return new JWTHeader instance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> JWTPayload</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"JWT Payload containing claims and application data.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    This structure represents the second part of a JWT token and contains</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    the actual authentication and authorization information.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Registered claims (standard JWT fields)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    iss: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">    # Issuer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sub: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">    # Subject  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    aud: Optional[Union[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # Audience</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    exp: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">    # Expiration time (Unix timestamp)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nbf: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">    # Not before time (Unix timestamp)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    iat: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">    # Issued at time (Unix timestamp)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    jti: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">    # JWT ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Custom application-specific claims</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    custom_claims: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_dict</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert payload to dictionary for JSON serialization.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create dictionary with all non-None registered claims</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add all custom_claims to the dictionary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Ensure consistent key ordering</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_dict</span><span style=\"color:#E1E4E8\">(cls, data: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> </span><span style=\"color:#9ECBFF\">'JWTPayload'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create payload from dictionary parsed from JSON.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Extract registered claim fields from dictionary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Put remaining fields into custom_claims dictionary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle audience field (can be string or list)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return new JWTPayload instance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_claim</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get claim value by name from registered or custom claims.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check if name matches a registered claim field</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: If not found in registered claims, check custom_claims</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return None if claim is not present</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ValidationContext</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Configuration for JWT token validation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    This structure contains all the settings needed to properly validate</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    JWT tokens according to application security requirements.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Signature validation controls</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    verify_signature: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Time-based validation controls  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    verify_expiration: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    verify_not_before: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leeway_seconds: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> DEFAULT_LEEWAY_SECONDS</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Issuer validation controls</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    allowed_issuers: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    require_issuer: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Audience validation controls</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expected_audience: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    require_audience: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Required claims validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    required_claims: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_issuer</span><span style=\"color:#E1E4E8\">(self, issuer: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if issuer is valid according to context settings.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: If require_issuer is True, ensure issuer is not None</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: If issuer is provided, check if it's in allowed_issuers list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return True if validation passes, False otherwise</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_audience</span><span style=\"color:#E1E4E8\">(self, audience: Optional[Union[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]]]) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if audience is valid according to context settings.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: If require_audience is True, ensure audience is not None</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: If expected_audience is set, check if it matches</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle both string and list audience values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return True if validation passes, False otherwise</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_required_claims</span><span style=\"color:#E1E4E8\">(self, payload: JWTPayload) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if all required claims are present in payload.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Iterate through required_claims list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: For each required claim, check if it exists and is not None</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return list of missing claim names</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"base64url-encoding-utilities\">Base64URL Encoding Utilities</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> base64url_encode</span><span style=\"color:#E1E4E8\">(data: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Encode bytes to URL-safe Base64 without padding.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    This function implements the Base64URL encoding specified in RFC 4648</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Section 5, which replaces + with -, / with _, and removes padding.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Use base64.urlsafe_b64encode to encode the data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Decode the result to string (it returns bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Remove trailing '=' padding characters using rstrip</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return the URL-safe Base64 string</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> base64url_decode</span><span style=\"color:#E1E4E8\">(data: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Decode Base64URL string back to bytes with padding restoration.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    This function reverses Base64URL encoding by restoring padding</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    and using standard base64 decoding.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Calculate missing padding: (4 - len(data) % 4) % 4</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add '=' padding characters to make length multiple of 4</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Use base64.urlsafe_b64decode to decode the padded string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return the decoded bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"time-handling-utilities\">Time Handling Utilities</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> utc_now</span><span style=\"color:#E1E4E8\">() -> datetime:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Get current UTC time for consistent time-based validation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return datetime.utcnow() for current UTC time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Consider using datetime.now(timezone.utc) for timezone-aware results</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> to_unix_timestamp</span><span style=\"color:#E1E4E8\">(dt: datetime) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convert datetime to Unix timestamp for JWT time claims.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Use dt.timestamp() to get Unix timestamp as float</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Convert to integer using int() to match JWT time format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return the integer timestamp</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> from_unix_timestamp</span><span style=\"color:#E1E4E8\">(timestamp: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> datetime:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convert Unix timestamp to datetime for time comparisons.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Use datetime.fromtimestamp() with UTC timezone</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return timezone-aware datetime object</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_expired</span><span style=\"color:#E1E4E8\">(exp_timestamp: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, leeway: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if timestamp is in the past considering leeway.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Get current Unix timestamp using utc_now() and to_unix_timestamp()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add leeway seconds to exp_timestamp for tolerance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return True if current time is after the adjusted expiration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_not_before</span><span style=\"color:#E1E4E8\">(nbf_timestamp: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, leeway: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if current time is before nbf timestamp considering leeway.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Get current Unix timestamp using utc_now() and to_unix_timestamp() </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Subtract leeway seconds from nbf_timestamp for tolerance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return True if current time is before the adjusted not-before time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"json-serialization-utilities\">JSON Serialization Utilities</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> serialize_header</span><span style=\"color:#E1E4E8\">(header: JWTHeader) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Serialize JWT header to JSON string with consistent ordering.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Convert header to dictionary using to_dict() method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Use json.dumps() with sort_keys=True for consistent ordering</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Use separators=(',', ':') to minimize whitespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return the JSON string</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> serialize_payload</span><span style=\"color:#E1E4E8\">(payload: JWTPayload) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Serialize JWT payload to JSON string with consistent ordering.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Convert payload to dictionary using to_dict() method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Use json.dumps() with sort_keys=True for consistent ordering</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Use separators=(',', ':') to minimize whitespace  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return the JSON string</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> parse_json_section</span><span style=\"color:#E1E4E8\">(json_str: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Parse JSON string from JWT token section.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Use json.loads() to parse the JSON string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle json.JSONDecodeError and raise appropriate JWT exception</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return the parsed dictionary</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After Milestone 1 (JWT Structure):</strong></p>\n<ul>\n<li>Run <code>python -c &quot;from jwt_library.data_model import JWTHeader, JWTPayload; print(&#39;Data structures imported successfully&#39;)&quot;</code> </li>\n<li>Verify that <code>base64url_encode(b&#39;hello&#39;)</code> returns <code>&#39;aGVsbG8&#39;</code> (no padding)</li>\n<li>Verify that <code>base64url_decode(&#39;aGVsbG8&#39;)</code> returns <code>b&#39;hello&#39;</code></li>\n<li>Check that <code>JWTHeader(&#39;HS256&#39;, &#39;JWT&#39;).to_dict()</code> returns <code>{&#39;alg&#39;: &#39;HS256&#39;, &#39;typ&#39;: &#39;JWT&#39;}</code></li>\n</ul>\n<p><strong>After Milestone 2 (HMAC Signing):</strong></p>\n<ul>\n<li>Verify that time utilities correctly handle Unix timestamps</li>\n<li>Check that validation context properly validates issuer and audience claims</li>\n<li>Test that <code>is_expired()</code> and <code>is_not_before()</code> handle leeway correctly</li>\n</ul>\n<p><strong>After Milestone 3 (Claims Validation):</strong></p>\n<ul>\n<li>Verify that <code>ValidationContext.validate_required_claims()</code> correctly identifies missing claims</li>\n<li>Check that custom claims are properly extracted and validated</li>\n<li>Test complete token validation workflow with various claim combinations</li>\n</ul>\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Base64URL decode errors</td>\n<td>Wrong padding or invalid characters</td>\n<td>Print encoded string length and characters</td>\n<td>Check for proper padding removal/restoration</td>\n</tr>\n<tr>\n<td>JSON serialization inconsistent</td>\n<td>Different key ordering across runs</td>\n<td>Compare JSON output from multiple calls</td>\n<td>Use <code>sort_keys=True</code> in json.dumps</td>\n</tr>\n<tr>\n<td>Time validation always fails</td>\n<td>Incorrect timezone handling</td>\n<td>Print timestamps and current time</td>\n<td>Use UTC consistently throughout</td>\n</tr>\n<tr>\n<td>Custom claims not found</td>\n<td>Incorrect claim extraction logic</td>\n<td>Print payload dictionary contents</td>\n<td>Check field name matching and case sensitivity</td>\n</tr>\n<tr>\n<td>Validation context errors</td>\n<td>Immutability violations</td>\n<td>Check for attribute modification attempts</td>\n<td>Use dataclass frozen=True and create new instances</td>\n</tr>\n</tbody></table>\n<h2 id=\"token-encoding-component\">Token Encoding Component</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1 (JWT Structure) - implements JWT encoding without signing, including header and payload assembly, Base64URL encoding, and token format construction</p>\n</blockquote>\n<p>The Token Encoding Component represents the foundation of our JWT library, responsible for transforming structured data into the standardized three-part JWT format. This component handles the critical first phase of JWT creation: taking raw header and payload information and assembling it into a properly formatted, URL-safe token structure that can be transmitted over HTTP and stored in various contexts.</p>\n<p><img src=\"/api/project/jwt-impl/architecture-doc/asset?path=diagrams%2Fjwt-structure.svg\" alt=\"JWT Token Structure and Data Model\"></p>\n<h3 id=\"mental-model-document-preparation\">Mental Model: Document Preparation</h3>\n<p>Think of the Token Encoding Component as a <strong>document preparation service</strong> similar to how a legal office prepares official documents for court submission. Just as a legal document must follow strict formatting rules, contain specific required sections, and be properly certified before it becomes legally valid, a JWT token must undergo precise structural preparation before it can serve as a trusted authentication credential.</p>\n<p>Consider how a legal brief is prepared: First, the legal team gathers all the necessary information (claims about the case, client details, jurisdiction requirements). Next, they organize this information into standardized sections (header with case information, body with arguments, footer with signatures). Then they format everything according to court requirements (specific fonts, margins, numbering systems). Finally, they prepare multiple copies in the required format (printed, digital, certified copies).</p>\n<p>The Token Encoding Component follows this same systematic approach. It takes raw authentication data (user identity, permissions, expiration times) and transforms it through several structured phases: JSON serialization ensures the data is in a standard format, Base64URL encoding makes it web-safe for transmission, and token assembly combines everything into the final three-part structure that other systems can reliably parse and process.</p>\n<p>This preparation phase is crucial because any deviation from the standard format will cause the token to be rejected by verification systems, just as improperly formatted legal documents are rejected by courts. The encoding process must be both precise and consistent, producing identical output for identical input data regardless of when or where the encoding occurs.</p>\n<h3 id=\"base64url-encoding\">Base64URL Encoding</h3>\n<p>Base64URL encoding serves as the fundamental transformation mechanism that makes JWT tokens safe for transmission across web protocols. Unlike standard Base64 encoding, which includes characters that have special meanings in URLs and HTTP headers, Base64URL uses a web-safe alphabet that eliminates encoding conflicts and parsing ambiguities.</p>\n<p><img src=\"/api/project/jwt-impl/architecture-doc/asset?path=diagrams%2Fencoding-flowchart.svg\" alt=\"Base64URL Encoding Process\"></p>\n<p>The encoding process begins with UTF-8 encoded JSON data representing either the JWT header or payload. This binary data undergoes standard Base64 transformation using the familiar 64-character alphabet, but then requires two critical modifications: character substitution and padding removal. The standard Base64 characters <code>+</code> and <code>/</code> become <code>-</code> and <code>_</code> respectively, eliminating the need for URL encoding when tokens appear in query parameters or path components. More importantly, all padding characters (<code>=</code>) are stripped from the end of the encoded string.</p>\n<p>Padding removal represents a key architectural decision because it creates an encoding that is both deterministic and compact. Traditional Base64 padding serves to align the output to 4-character boundaries, but this padding provides no functional value in JWT tokens and actually increases the token size. By removing padding, we ensure that tokens consume minimal space in HTTP headers while maintaining full reversibility during decoding.</p>\n<p>The decoding process reverses these transformations but must handle the missing padding gracefully. Our decoder calculates the required padding length based on the input string length: strings whose length modulo 4 equals 2 require two padding characters, strings whose length modulo 4 equals 3 require one padding character, and strings whose length modulo 4 equals 0 or 1 are either correctly padded or represent invalid input respectively.</p>\n<blockquote>\n<p><strong>Decision: Base64URL Character Set</strong></p>\n<ul>\n<li><strong>Context</strong>: JWT tokens must be safely transmitted in URLs, HTTP headers, and form data without requiring additional encoding</li>\n<li><strong>Options Considered</strong>: Standard Base64, Base64URL, custom encoding scheme</li>\n<li><strong>Decision</strong>: Use Base64URL encoding with URL-safe character substitutions</li>\n<li><strong>Rationale</strong>: Base64URL is standardized in RFC 4648, supported by existing libraries, and eliminates URL encoding overhead</li>\n<li><strong>Consequences</strong>: Enables direct token usage in URLs and headers but requires custom encoding/decoding functions in some languages</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Encoding Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Web-Safe</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Standard Base64</td>\n<td>Universal support, simple implementation</td>\n<td>Requires URL encoding, longer tokens</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Base64URL</td>\n<td>Web-safe, compact, standardized</td>\n<td>Requires custom implementation</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>Custom encoding</td>\n<td>Optimized for specific use case</td>\n<td>Non-standard, compatibility issues</td>\n<td>Variable</td>\n</tr>\n</tbody></table>\n<p>The encoding functions maintain strict error handling to ensure that invalid input data cannot produce tokens that appear valid but fail during verification. Input validation confirms that all data is valid UTF-8 before encoding begins, preventing encoding artifacts that could cause parsing failures downstream.</p>\n<h3 id=\"json-serialization-strategy\">JSON Serialization Strategy</h3>\n<p>JSON serialization transforms the structured header and payload objects into the standardized text representation required for cryptographic processing. This transformation must be deterministic and consistent to ensure that identical logical tokens always produce identical signatures, regardless of the serialization environment or timing.</p>\n<p>Our serialization strategy addresses several critical requirements that distinguish JWT encoding from general-purpose JSON serialization. First, field ordering must be consistent to prevent signature variations caused by different JSON implementations reordering object keys. Second, whitespace handling must eliminate all unnecessary characters to minimize token size. Third, numeric precision must preserve exact timestamp values to prevent authentication failures caused by rounding errors.</p>\n<p>The header serialization process creates a minimal JSON object containing exactly two required fields: <code>alg</code> specifying the signing algorithm and <code>typ</code> indicating the token type. Additional header fields, while supported by the JWT specification, are not included in our initial implementation to maintain simplicity and reduce attack surface. The serializer outputs these fields in alphabetical order to ensure consistency across different JSON libraries and platforms.</p>\n<p>Payload serialization handles a more complex data structure that includes both standard registered claims and application-specific custom claims. Registered claims such as <code>iss</code> (issuer), <code>sub</code> (subject), <code>aud</code> (audience), <code>exp</code> (expiration time), <code>nbf</code> (not before), and <code>iat</code> (issued at) receive special handling to ensure type correctness and value validation. String claims are serialized directly, while numeric claims undergo integer conversion to prevent floating-point representation issues.</p>\n<blockquote>\n<p><strong>Decision: JSON Field Ordering</strong></p>\n<ul>\n<li><strong>Context</strong>: Different JSON serializers may output object fields in different orders, potentially causing signature mismatches</li>\n<li><strong>Options Considered</strong>: Accept arbitrary ordering, enforce alphabetical ordering, use ordered dictionaries</li>\n<li><strong>Decision</strong>: Enforce consistent alphabetical field ordering during serialization</li>\n<li><strong>Rationale</strong>: Ensures identical JSON output for identical input data, preventing signature validation failures</li>\n<li><strong>Consequences</strong>: Requires explicit field ordering in serialization code but guarantees signature consistency</li>\n</ul>\n</blockquote>\n<p>The serialization process validates all field types before encoding to prevent runtime errors during token creation. String fields are checked for valid UTF-8 encoding, numeric fields are validated as integers within the valid timestamp range, and array fields (such as multiple audience values) are validated for consistent element types.</p>\n<p>Custom claims handling deserves special attention because it represents the primary extension point for application-specific authentication data. Our serializer accepts custom claims as a dictionary of key-value pairs, where keys must be valid JSON strings and values can be any JSON-serializable type. However, we recommend avoiding deeply nested objects in custom claims to maintain token compactness and parsing efficiency.</p>\n<table>\n<thead>\n<tr>\n<th>Claim Type</th>\n<th>Validation Rules</th>\n<th>Serialization Format</th>\n<th>Error Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>String claims (iss, sub, jti)</td>\n<td>Non-empty UTF-8 strings</td>\n<td>Direct JSON string</td>\n<td>Reject empty/invalid strings</td>\n</tr>\n<tr>\n<td>Numeric claims (exp, nbf, iat)</td>\n<td>Positive integers, valid timestamp range</td>\n<td>JSON number without decimals</td>\n<td>Reject negative/floating values</td>\n</tr>\n<tr>\n<td>Audience claim (aud)</td>\n<td>String or array of strings</td>\n<td>String or JSON array</td>\n<td>Standardize single-item arrays</td>\n</tr>\n<tr>\n<td>Custom claims</td>\n<td>JSON-serializable values</td>\n<td>Native JSON representation</td>\n<td>Validate serializability</td>\n</tr>\n</tbody></table>\n<h3 id=\"architecture-decisions\">Architecture Decisions</h3>\n<p>The Token Encoding Component embodies several fundamental architectural decisions that establish the foundation for the entire JWT library. These decisions prioritize security, consistency, and maintainability over performance optimization or feature richness, reflecting our commitment to building a secure authentication system rather than a high-performance data processing library.</p>\n<blockquote>\n<p><strong>Decision: Three-Phase Encoding Pipeline</strong></p>\n<ul>\n<li><strong>Context</strong>: JWT tokens require JSON serialization, Base64URL encoding, and token assembly in a specific sequence</li>\n<li><strong>Options Considered</strong>: Single monolithic encoder, three separate phases, streaming encoder</li>\n<li><strong>Decision</strong>: Implement three distinct phases with clear interfaces between them</li>\n<li><strong>Rationale</strong>: Enables independent testing of each phase, simplifies debugging, and allows phase-specific optimizations</li>\n<li><strong>Consequences</strong>: Slightly increased memory usage due to intermediate representations but significantly improved maintainability</li>\n</ul>\n</blockquote>\n<p><img src=\"/api/project/jwt-impl/architecture-doc/asset?path=diagrams%2Ftoken-creation-sequence.svg\" alt=\"Token Creation Sequence\"></p>\n<p>The three-phase pipeline architecture separates concerns cleanly: JSON serialization focuses on data representation accuracy, Base64URL encoding handles web-safety requirements, and token assembly manages the final format construction. Each phase can be tested independently with known inputs and expected outputs, dramatically simplifying the debugging process when tokens fail validation.</p>\n<p>Input validation occurs at multiple pipeline stages to create defense-in-depth against malformed data. The JSON serialization phase validates data types and UTF-8 encoding. The Base64URL encoding phase confirms that input data consists of valid bytes. The token assembly phase verifies that all three components (header, payload, signature placeholder) are present and properly formatted.</p>\n<blockquote>\n<p><strong>Decision: Immutable Token Components</strong></p>\n<ul>\n<li><strong>Context</strong>: JWT tokens should be tamper-evident, requiring consistent representation of header and payload data</li>\n<li><strong>Options Considered</strong>: Mutable token objects, immutable value objects, copy-on-write structures</li>\n<li><strong>Decision</strong>: Use immutable value objects for JWTHeader and JWTPayload throughout the encoding process</li>\n<li><strong>Rationale</strong>: Prevents accidental modification during encoding, simplifies concurrent access, and ensures consistent signatures</li>\n<li><strong>Consequences</strong>: Requires object creation for modifications but eliminates entire classes of bugs related to shared mutable state</li>\n</ul>\n</blockquote>\n<p>Error handling follows a fail-fast philosophy where invalid input data immediately terminates the encoding process with descriptive error messages. This approach prevents the creation of malformed tokens that might appear valid but fail during verification, potentially causing authentication failures in production systems.</p>\n<p>The component maintains strict separation between encoding operations and cryptographic operations. The Token Encoding Component produces the signing input string (header.payload) but does not perform any cryptographic operations itself. This separation allows the encoding logic to be tested without cryptographic dependencies and enables the signing component to focus exclusively on secure signature generation.</p>\n<table>\n<thead>\n<tr>\n<th>Architecture Decision</th>\n<th>Alternative Approaches</th>\n<th>Chosen Approach</th>\n<th>Trade-offs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Pipeline Structure</td>\n<td>Monolithic encoder</td>\n<td>Three-phase pipeline</td>\n<td>Memory usage vs. maintainability</td>\n</tr>\n<tr>\n<td>Data Mutability</td>\n<td>Mutable token objects</td>\n<td>Immutable value objects</td>\n<td>Performance vs. safety</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Graceful degradation</td>\n<td>Fail-fast validation</td>\n<td>User experience vs. security</td>\n</tr>\n<tr>\n<td>Component Coupling</td>\n<td>Integrated encoding/signing</td>\n<td>Separated concerns</td>\n<td>Complexity vs. testability</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>Token encoding presents numerous opportunities for subtle bugs that can compromise the security or functionality of the entire JWT system. Understanding these pitfalls and their solutions is essential for building a robust authentication system.</p>\n<p>⚠️ <strong>Pitfall: Base64 vs Base64URL Confusion</strong></p>\n<p>Many developers mistakenly use standard Base64 encoding instead of the required Base64URL variant, creating tokens that work in testing but fail when transmitted through web protocols. Standard Base64 uses <code>+</code> and <code>/</code> characters that have special meanings in URLs, causing token corruption when they appear in query parameters or are processed by URL-parsing libraries.</p>\n<p>The symptoms of this error include tokens that work when passed directly between services but fail when transmitted through HTTP redirects, stored in cookies, or embedded in HTML forms. The solution requires implementing proper Base64URL encoding that substitutes <code>-</code> for <code>+</code> and <code>_</code> for <code>/</code>, while also handling padding removal correctly.</p>\n<p>⚠️ <strong>Pitfall: Padding Handling Errors</strong></p>\n<p>Base64URL encoding requires padding removal, but the decoding process must restore the correct amount of padding to reconstruct the original data. Incorrect padding calculation leads to decoding failures that manifest as token parsing errors or signature verification failures.</p>\n<p>The most common mistake involves using string length modulo 4 without accounting for invalid input lengths. Strings whose length modulo 4 equals 1 represent invalid Base64 input and should trigger an error rather than attempting padding calculation. Proper padding restoration adds zero, one, or two <code>=</code> characters based on the mathematical relationship between input length and Base64 block alignment.</p>\n<p>⚠️ <strong>Pitfall: JSON Field Ordering Inconsistency</strong></p>\n<p>JSON serialization libraries in different languages may output object fields in different orders, causing identical token data to produce different JSON representations and therefore different signatures. This creates tokens that appear valid when created and verified on the same system but fail cross-platform verification.</p>\n<p>The solution requires explicit field ordering during JSON serialization, typically alphabetical ordering of field names. However, simply sorting fields may not be sufficient if the JSON library internally reorders them. Production implementations should validate that their JSON serialization produces consistent output by comparing serialized results across multiple library versions and platforms.</p>\n<p>⚠️ <strong>Pitfall: Timestamp Precision Loss</strong></p>\n<p>JWT timestamps are defined as NumericDate values representing seconds since the Unix epoch. However, many programming languages represent time using floating-point numbers or higher precision formats that can introduce rounding errors during JSON serialization.</p>\n<p>These precision errors manifest as tokens that expire one second earlier or later than expected, causing authentication failures near expiration boundaries. The solution requires explicit integer conversion of all timestamp values before JSON serialization, ensuring that <code>exp</code>, <code>nbf</code>, and <code>iat</code> claims are represented as whole seconds without fractional components.</p>\n<p>⚠️ <strong>Pitfall: Empty String and Null Handling</strong></p>\n<p>JWT claims may contain empty strings or null values that require careful handling during serialization. Some JSON libraries omit null values entirely, while others represent them explicitly, leading to inconsistent token formats and potential signature mismatches.</p>\n<p>Our implementation strategy treats empty strings as invalid for required string claims (such as <code>iss</code> and <code>sub</code>) but allows them for optional custom claims. Null values are explicitly forbidden in all claims to maintain JSON compatibility and prevent parsing ambiguities. Applications requiring optional claims should omit the claim entirely rather than setting it to null.</p>\n<p>⚠️ <strong>Pitfall: Unicode and Character Encoding Issues</strong></p>\n<p>JWT tokens must be transmitted as ASCII-safe strings, but the header and payload may contain Unicode characters in string claims. Incorrect character encoding during JSON serialization can produce tokens that appear valid in development environments but fail when processed by systems with different default encodings.</p>\n<p>The solution requires explicit UTF-8 encoding throughout the token creation pipeline. All string data must be validated as valid UTF-8 before JSON serialization, and the serialized JSON must be UTF-8 encoded before Base64URL encoding. This ensures consistent token representation across systems with different default character encodings.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The Token Encoding Component requires careful attention to character encoding, data validation, and format consistency. The following implementation guidance provides complete working code for the foundational elements and detailed skeletons for the core encoding logic.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JSON Serialization</td>\n<td><code>json</code> module with custom serialization</td>\n<td><code>orjson</code> or <code>ujson</code> for performance</td>\n</tr>\n<tr>\n<td>Base64 Encoding</td>\n<td><code>base64</code> module with manual padding</td>\n<td>Custom implementation for precise control</td>\n</tr>\n<tr>\n<td>String Handling</td>\n<td>Built-in <code>str</code> methods</td>\n<td><code>unicodedata</code> for advanced validation</td>\n</tr>\n<tr>\n<td>Date/Time Processing</td>\n<td><code>datetime</code> module with UTC timezone</td>\n<td><code>pendulum</code> for advanced time handling</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>jwt-library/\n  src/\n    jwt/\n      __init__.py                 ← Public API exports\n      encoding/\n        __init__.py              ← Encoding component exports  \n        base64url.py             ← Base64URL encoding utilities\n        json_serializer.py       ← JSON serialization with field ordering\n        token_assembler.py       ← Token structure assembly\n        validators.py            ← Input validation helpers\n      types.py                   ← Core data structures (JWTHeader, JWTPayload)\n      constants.py               ← Algorithm identifiers and defaults\n    tests/\n      encoding/\n        test_base64url.py        ← Base64URL encoding tests\n        test_json_serializer.py  ← JSON serialization tests\n        test_token_assembler.py  ← Token assembly tests</code></pre></div>\n\n<p><strong>Core Data Structures (Complete Implementation):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/jwt/types.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Union, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> JWTHeader</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Immutable JWT header containing algorithm and type information.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    alg: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    typ: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __post_init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.alg </span><span style=\"color:#F97583\">or</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.alg, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Header 'alg' field must be a non-empty string\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.typ </span><span style=\"color:#F97583\">or</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.typ, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Header 'typ' field must be a non-empty string\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> JWTPayload</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Immutable JWT payload containing registered and custom claims.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    iss: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">           # Issuer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sub: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">           # Subject  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    aud: Optional[Union[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # Audience</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    exp: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">           # Expiration Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nbf: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">           # Not Before</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    iat: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">           # Issued At</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    jti: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">           # JWT ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    custom_claims: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __post_init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Validate timestamp claims are positive integers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> claim_name </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">'exp'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'nbf'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'iat'</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            value </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> getattr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">, claim_name)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(value, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Claim '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">claim_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">' must be a positive integer timestamp\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Validate string claims are non-empty if present</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> claim_name </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">'iss'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'sub'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'jti'</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            value </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> getattr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">, claim_name)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#F97583\"> and</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">not</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(value, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">or</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> value.strip()):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Claim '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">claim_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">' must be a non-empty string\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Validate audience claim</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.aud </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.aud, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.aud.strip():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Audience claim must be a non-empty string\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            elif</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.aud, </span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.aud </span><span style=\"color:#F97583\">or</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> all</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">isinstance</span><span style=\"color:#E1E4E8\">(a, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> a.strip() </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> a </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.aud):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Audience list must contain non-empty strings\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Audience must be a string or list of strings\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>Base64URL Encoding (Complete Implementation):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/jwt/encoding/base64url.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> base64</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Union</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> base64url_encode</span><span style=\"color:#E1E4E8\">(data: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Encode bytes to URL-safe Base64 without padding.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        data: Raw bytes to encode</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        URL-safe Base64 string without padding characters</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        TypeError: If input is not bytes</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Input data must be bytes\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Perform standard Base64 encoding</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    encoded </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> base64.b64encode(data).decode(</span><span style=\"color:#9ECBFF\">'ascii'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Apply URL-safe character substitutions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    encoded </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> encoded.replace(</span><span style=\"color:#9ECBFF\">'+'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'-'</span><span style=\"color:#E1E4E8\">).replace(</span><span style=\"color:#9ECBFF\">'/'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'_'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Remove padding characters</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> encoded.rstrip(</span><span style=\"color:#9ECBFF\">'='</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> base64url_decode</span><span style=\"color:#E1E4E8\">(data: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Decode Base64URL back to bytes with automatic padding restoration.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        data: Base64URL encoded string</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Original bytes</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        ValueError: If input string has invalid length or characters</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Input data must be a string\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Calculate required padding</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    padding_length </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(data) </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 4</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> padding_length </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Invalid Base64URL string length\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    elif</span><span style=\"color:#E1E4E8\"> padding_length </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        data </span><span style=\"color:#F97583\">+=</span><span style=\"color:#9ECBFF\"> '=='</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    elif</span><span style=\"color:#E1E4E8\"> padding_length </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        data </span><span style=\"color:#F97583\">+=</span><span style=\"color:#9ECBFF\"> '='</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Reverse URL-safe character substitutions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> data.replace(</span><span style=\"color:#9ECBFF\">'-'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'+'</span><span style=\"color:#E1E4E8\">).replace(</span><span style=\"color:#9ECBFF\">'_'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'/'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> base64.b64decode(data)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Invalid Base64URL encoding: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>JSON Serialization (Core Logic Skeleton):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/jwt/encoding/json_serializer.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..types </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> JWTHeader, JWTPayload</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> serialize_header</span><span style=\"color:#E1E4E8\">(header: JWTHeader) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Serialize JWT header to consistent JSON representation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        header: JWT header object</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        JSON string with alphabetically ordered fields</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create ordered dictionary with header fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Ensure alphabetical field ordering (alg before typ)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Serialize to JSON without whitespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Validate result is valid UTF-8</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use json.dumps with separators=(',', ':') for compact output</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> serialize_payload</span><span style=\"color:#E1E4E8\">(payload: JWTPayload) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Serialize JWT payload to consistent JSON representation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        payload: JWT payload object</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        JSON string with alphabetically ordered fields</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create ordered dictionary for registered claims</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add non-None registered claims in alphabetical order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Add custom claims if present, maintaining alphabetical order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle special case of audience as string vs list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Serialize to compact JSON without whitespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Validate all timestamps are integers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Check claim values with 'is not None' before adding to dictionary</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> _ensure_alphabetical_order</span><span style=\"color:#E1E4E8\">(data: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Ensure dictionary keys are in alphabetical order.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        data: Dictionary with string keys</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        New dictionary with alphabetically sorted keys</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Sort dictionary keys alphabetically</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create new dictionary with sorted key order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle nested dictionaries recursively for custom claims</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use sorted() function on dictionary keys</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p><strong>Token Assembly (Core Logic Skeleton):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/jwt/encoding/token_assembler.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Tuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .json_serializer </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> serialize_header, serialize_payload</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .base64url </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> base64url_encode</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..types </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> JWTHeader, JWTPayload</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> encode_token_parts</span><span style=\"color:#E1E4E8\">(header: JWTHeader, payload: JWTPayload) -> Tuple[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Encode header and payload to Base64URL format.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        header: JWT header object</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        payload: JWT payload object</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Tuple of (encoded_header, encoded_payload)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        ValueError: If serialization or encoding fails</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Serialize header to JSON string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Serialize payload to JSON string  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Encode header JSON to UTF-8 bytes then Base64URL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Encode payload JSON to UTF-8 bytes then Base64URL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return tuple of encoded strings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use .encode('utf-8') to convert JSON strings to bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_signing_input</span><span style=\"color:#E1E4E8\">(encoded_header: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, encoded_payload: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Create the signing input string for HMAC computation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        encoded_header: Base64URL encoded header</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        encoded_payload: Base64URL encoded payload</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Signing input string in format \"header.payload\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate both inputs are non-empty strings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Concatenate with dot separator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate result contains exactly one dot</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: This is the string that will be signed by the cryptographic component</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> assemble_token</span><span style=\"color:#E1E4E8\">(encoded_header: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, encoded_payload: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, signature: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Assemble the final JWT token from encoded components.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        encoded_header: Base64URL encoded header</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        encoded_payload: Base64URL encoded payload  </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        signature: Base64URL encoded signature</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Complete JWT token in format \"header.payload.signature\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate all three components are non-empty strings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Concatenate with dot separators</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate result has exactly two dots</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return final token string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Final token should split into exactly 3 parts on '.'</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoint:</strong></p>\n<p>After implementing the Token Encoding Component, verify your implementation with these concrete tests:</p>\n<ol>\n<li><p><strong>Header Encoding Test</strong>: Create a <code>JWTHeader(alg=&quot;HS256&quot;, typ=&quot;JWT&quot;)</code> and verify it serializes to the exact JSON <code>{&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;}</code> and encodes to Base64URL <code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</code>.</p>\n</li>\n<li><p><strong>Payload Encoding Test</strong>: Create a simple payload with <code>exp=1516239022</code> and verify the JSON contains <code>&quot;exp&quot;:1516239022</code> (integer, not float).</p>\n</li>\n<li><p><strong>Base64URL Validation</strong>: Encode the string &quot;hello world&quot; and verify it produces <code>aGVsbG8gd29ybGQ</code> (no padding). Decode it back and verify you get the original bytes.</p>\n</li>\n<li><p><strong>Token Assembly Test</strong>: Create a complete token with dummy signature and verify it has exactly three dot-separated parts, each containing valid Base64URL characters (A-Z, a-z, 0-9, -, _).</p>\n</li>\n</ol>\n<p><strong>Debugging Tips:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Base64 decode errors</td>\n<td>Wrong Base64 variant</td>\n<td>Check for +/= characters in token</td>\n<td>Use Base64URL encoding</td>\n</tr>\n<tr>\n<td>Inconsistent signatures</td>\n<td>JSON field ordering</td>\n<td>Compare JSON output across runs</td>\n<td>Implement consistent field ordering</td>\n</tr>\n<tr>\n<td>Token parsing failures</td>\n<td>Invalid characters in token</td>\n<td>Check token contains only valid Base64URL chars</td>\n<td>Validate encoding alphabet</td>\n</tr>\n<tr>\n<td>Timestamp validation errors</td>\n<td>Float timestamps in JSON</td>\n<td>Inspect JSON for decimal points in time claims</td>\n<td>Convert timestamps to integers</td>\n</tr>\n</tbody></table>\n<h2 id=\"cryptographic-signing-component\">Cryptographic Signing Component</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 2 (HMAC Signing) - implements HS256 signing and verification with cryptographically secure signature generation, constant-time verification, and proper secret key handling</p>\n</blockquote>\n<p>The cryptographic signing component transforms our JWT library from a simple token encoder into a secure authentication system. While the token encoding component from Milestone 1 created properly formatted JWT structures, those tokens provided no security guarantees—anyone could modify the payload and create valid-looking tokens. The signing component solves this fundamental problem by adding cryptographic integrity protection that ensures tokens cannot be tampered with after creation.</p>\n<p>This component implements HMAC-SHA256 (HS256) signing, which provides both authentication and integrity for JWT tokens. Authentication ensures that only parties possessing the secret key can create valid tokens, while integrity guarantees that any modification to a signed token will be detected during verification. The component must handle several critical security concerns: preventing timing attacks during signature verification, avoiding algorithm confusion attacks, and securely managing secret keys in memory.</p>\n<h3 id=\"mental-model-wax-seal-authentication\">Mental Model: Wax Seal Authentication</h3>\n<p>Understanding digital signatures becomes intuitive when we think about historical document authentication using wax seals. Imagine you&#39;re a medieval scribe preparing an important decree from the king. The decree contains two parts: the actual message (similar to our JWT header and payload) and the king&#39;s unique wax seal pressed into the document (similar to our cryptographic signature).</p>\n<p>The wax seal serves multiple purposes that directly parallel JWT signatures. First, it proves authenticity—only the king possesses the signet ring that creates this specific seal pattern, just as only parties with the secret key can generate valid HMAC signatures. Second, it ensures integrity—if someone alters the document after sealing, the broken or misaligned wax reveals tampering, just as signature verification fails when token contents are modified.</p>\n<p>The process of creating and verifying the seal follows a predictable pattern. To create a sealed document, the scribe first prepares the message text carefully (encoding our header and payload), then the king presses his signet ring into hot wax over the document (computing the HMAC signature over the encoded content). To verify an incoming sealed document, the recipient first examines the document contents (parsing the JWT structure), then carefully compares the wax seal against known authentic examples of the king&#39;s seal (recomputing the expected signature and comparing it with the provided signature).</p>\n<p>This analogy reveals why timing attacks are dangerous in signature verification. If a medieval clerk examined suspicious seals by slowly comparing each detail and stopping at the first difference, an attacker could learn information about the authentic seal by measuring how long verification takes. Similarly, if our JWT verification stops at the first differing byte in signature comparison, attackers can gradually discover the correct signature. The solution in both cases is comprehensive examination—the clerk must examine the entire seal regardless of early differences, and our verification must compare every byte of the signature in constant time.</p>\n<p>The wax seal model also illuminates why secret key security matters so critically. Just as a stolen or copied signet ring allows anyone to create authentic-looking royal decrees, a compromised HMAC secret key enables attackers to mint valid JWT tokens for any user or purpose. This makes secure key handling one of our most important architectural concerns.</p>\n<h3 id=\"hmac-sha256-implementation\">HMAC-SHA256 Implementation</h3>\n<p>HMAC-SHA256 provides the cryptographic foundation for JWT signing by combining a secret key with the token content to produce an unforgeable signature. The HMAC construction addresses several weaknesses present in simpler approaches like basic SHA-256 hashing, making it suitable for authentication applications where security is paramount.</p>\n<p>The mathematical foundation of HMAC involves two rounds of hashing with key material processed through inner and outer padding constants. However, the conceptual model is straightforward: HMAC takes a secret key and a message (our JWT header and payload), then produces a fixed-length output that serves as an authentication tag. Anyone possessing the same secret key can recompute this tag for any message, but without the key, computing the correct tag is computationally infeasible.</p>\n<p>Our implementation must handle several critical steps in the HMAC computation process. First, we prepare the signing input by concatenating the Base64URL-encoded header and payload with a dot separator, following the JWT specification exactly. This signing input represents the complete token content that receives cryptographic protection. Second, we apply the HMAC-SHA256 algorithm using the provided secret key, which produces a 32-byte binary signature. Third, we encode this binary signature using Base64URL encoding to create the final signature component that gets appended to the JWT.</p>\n<blockquote>\n<p><strong>Decision: HMAC-SHA256 Algorithm Choice</strong></p>\n<ul>\n<li><strong>Context</strong>: JWT supports multiple signature algorithms including HMAC variants (HS256, HS384, HS512) and RSA/ECDSA algorithms (RS256, ES256). We need to choose one algorithm for our initial implementation that balances security with implementation complexity.</li>\n<li><strong>Options Considered</strong>: <ul>\n<li>HS256 (HMAC-SHA256): Symmetric key, 256-bit security, simple implementation</li>\n<li>RS256 (RSA-SHA256): Asymmetric key, complex key management, larger signatures</li>\n<li>ES256 (ECDSA-SHA256): Asymmetric key, smaller signatures, more complex implementation</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Implement HS256 (HMAC-SHA256) as the primary algorithm</li>\n<li><strong>Rationale</strong>: HS256 provides strong cryptographic security (256-bit) with straightforward implementation requirements. Symmetric key operation simplifies key management for single-service scenarios while avoiding the complexity of public key cryptography. The algorithm enjoys broad library support and extensive security analysis.</li>\n<li><strong>Consequences</strong>: Limited to scenarios where both token issuers and verifiers can securely share the secret key. Cannot support distributed verification scenarios where multiple parties need to verify tokens without ability to issue them.</li>\n</ul>\n</blockquote>\n<p>The signing input preparation requires careful attention to format consistency. The JWT specification mandates that the signing input consists of the Base64URL-encoded header, followed by a single dot character, followed by the Base64URL-encoded payload. No additional whitespace, encoding, or formatting is permitted. This precise format ensures that signature verification will succeed only when the exact same input string is reconstructed during the verification process.</p>\n<table>\n<thead>\n<tr>\n<th>HMAC-SHA256 Operation</th>\n<th>Input</th>\n<th>Output</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>create_signing_input</code></td>\n<td>encoded_header: str, encoded_payload: str</td>\n<td>signing_input: str</td>\n<td>Concatenate header.payload for signature computation</td>\n</tr>\n<tr>\n<td><code>compute_hmac_sha256</code></td>\n<td>message: bytes, key: bytes</td>\n<td>signature: bytes</td>\n<td>Generate 32-byte HMAC-SHA256 authentication tag</td>\n</tr>\n<tr>\n<td><code>encode_signature</code></td>\n<td>signature: bytes</td>\n<td>encoded_signature: str</td>\n<td>Convert binary signature to Base64URL format</td>\n</tr>\n<tr>\n<td><code>sign_token</code></td>\n<td>signing_input: str, secret_key: bytes</td>\n<td>signature: str</td>\n<td>Complete signing process from input to encoded signature</td>\n</tr>\n</tbody></table>\n<p>Key handling during HMAC computation requires attention to encoding and format consistency. The secret key must be treated as raw bytes rather than text, avoiding encoding issues that could cause signature mismatches between signing and verification. When applications provide keys as strings, we must convert them to bytes using consistent encoding (UTF-8) to ensure reproducible results.</p>\n<p>The HMAC computation itself leverages the cryptographic libraries provided by our target programming language, avoiding any attempt to implement the algorithm from scratch. Custom cryptographic implementations introduce significant security risks and provide no benefits over well-tested standard library implementations. Our role is to correctly invoke the standard HMAC-SHA256 function with proper parameters and handle the results appropriately.</p>\n<p>Error handling during signature generation must distinguish between recoverable and fatal errors. Recoverable errors include invalid input formats that can be corrected by the caller, such as malformed JSON in headers or payloads. Fatal errors include cryptographic failures that indicate deeper problems, such as insufficient entropy for key generation or hardware security module failures. Our implementation should provide clear error messages that help developers diagnose problems without revealing sensitive information that could aid attackers.</p>\n<h3 id=\"signature-verification-process\">Signature Verification Process</h3>\n<p>Signature verification represents the most security-critical component of our JWT implementation, as vulnerabilities here can completely compromise the authentication system. The verification process must not only check mathematical correctness but also resist various cryptographic attacks, particularly timing attacks that could leak information about valid signatures through execution time measurements.</p>\n<p>The verification algorithm follows a structured approach that prioritizes security over performance optimizations. First, we parse the incoming JWT token to extract the header, payload, and signature components. This parsing must handle malformed tokens gracefully, rejecting invalid formats without revealing information about expected structures. Second, we reconstruct the signing input using the same process employed during token creation, ensuring byte-for-byte consistency. Third, we recompute the expected signature using our secret key and the reconstructed signing input. Finally, we compare the recomputed signature with the provided signature using constant-time comparison to prevent timing attacks.</p>\n<blockquote>\n<p>The critical security insight in signature verification is that ANY deviation from constant-time operation can leak information to attackers. Even minor optimizations like early termination on the first differing byte can enable sophisticated attackers to gradually discover valid signatures through timing measurements.</p>\n</blockquote>\n<p>The constant-time comparison requirement deserves particular attention as it differs from normal string or byte array comparison operations. Standard comparison functions typically terminate as soon as they encounter the first differing byte, returning immediately with a &quot;not equal&quot; result. While this optimization improves performance for legitimate uses, it creates a timing side channel for cryptographic applications. An attacker can submit many candidate signatures and measure verification times to determine how many bytes match the expected signature, eventually reconstructing the entire signature through this timing oracle.</p>\n<table>\n<thead>\n<tr>\n<th>Verification Step</th>\n<th>Security Requirement</th>\n<th>Implementation Approach</th>\n<th>Failure Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Token Parsing</td>\n<td>Reject malformed tokens</td>\n<td>Validate three-part structure separated by dots</td>\n<td>Return generic &quot;invalid token&quot; error</td>\n</tr>\n<tr>\n<td>Signature Decoding</td>\n<td>Handle invalid Base64URL</td>\n<td>Decode signature with padding restoration</td>\n<td>Return generic &quot;invalid signature&quot; error</td>\n</tr>\n<tr>\n<td>Signing Input Reconstruction</td>\n<td>Maintain byte-level consistency</td>\n<td>Use identical encoding process as signing</td>\n<td>Internal error if encoding fails</td>\n</tr>\n<tr>\n<td>HMAC Recomputation</td>\n<td>Protect secret key</td>\n<td>Use same algorithm and key as original signing</td>\n<td>Internal error if HMAC computation fails</td>\n</tr>\n<tr>\n<td>Signature Comparison</td>\n<td>Prevent timing attacks</td>\n<td>Compare every byte regardless of early differences</td>\n<td>Return boolean result only</td>\n</tr>\n</tbody></table>\n<p>Our constant-time comparison implementation must examine every byte of both signatures, accumulating differences without early termination. The comparison continues through the entire signature length even after detecting differences, ensuring consistent execution time regardless of where differences occur. Only after examining all bytes does the function return a boolean result indicating whether the signatures match.</p>\n<p>The verification process must also handle various edge cases that could indicate attack attempts or system errors. Zero-length signatures, signatures longer than the expected HMAC output size, and signatures containing invalid Base64URL characters all represent potential attack vectors or implementation bugs. Our verification should reject these cases explicitly while providing minimal information in error messages to avoid assisting attackers.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Signature Verification Algorithm:\n1. Parse the JWT token to extract header, payload, and signature components\n2. Validate that each component is properly formatted Base64URL\n3. Decode the provided signature from Base64URL to binary\n4. Reconstruct the signing input by concatenating encoded header and payload with dot\n5. Compute the expected signature using HMAC-SHA256 with our secret key\n6. Compare the provided signature with expected signature using constant-time comparison\n7. Return verification result without revealing details of any failures</code></pre></div>\n\n<p>Error handling during verification must balance security with debugging needs. Detailed error messages help developers diagnose integration problems, but they can also provide information useful to attackers. Our approach distinguishes between development and production environments, providing detailed diagnostics in development while returning generic error messages in production. This allows effective debugging during implementation while maintaining security in deployed systems.</p>\n<p><img src=\"/api/project/jwt-impl/architecture-doc/asset?path=diagrams%2Ftoken-verification-sequence.svg\" alt=\"Token Verification Sequence\"></p>\n<p>The verification process integrates with the broader JWT validation pipeline, where signature verification represents just one of several security checks. Even if signature verification succeeds, the token may still be invalid due to expiration, incorrect audience claims, or other validation failures. Our signature verification component focuses solely on cryptographic integrity, delegating other validation concerns to the claims validation component described in Milestone 3.</p>\n<h3 id=\"secret-key-handling\">Secret Key Handling</h3>\n<p>Secret key management represents one of the most critical security aspects of JWT implementation, as key compromise completely undermines the authentication system. Our approach to key handling must address several concerns: secure storage in memory, validation of key strength, protection against key extraction, and proper cleanup when keys are no longer needed.</p>\n<p>The fundamental principle guiding our key handling approach is that secret keys should be treated as sensitive material throughout their entire lifecycle. This means avoiding unnecessary copying, preventing keys from appearing in logs or error messages, and clearing key material from memory when possible. While complete protection against memory analysis attacks requires specialized hardware or operating system features beyond our scope, we can implement reasonable protections against casual key exposure.</p>\n<p>Key validation plays an essential role in preventing weak keys from compromising security. While HMAC-SHA256 can technically operate with keys of any length, cryptographic best practices recommend keys of at least 256 bits (32 bytes) to match the security level of the underlying SHA-256 hash function. Keys shorter than this recommendation may be vulnerable to brute-force attacks, particularly if attackers can obtain large numbers of signed tokens for analysis.</p>\n<blockquote>\n<p><strong>Decision: Minimum Key Length Enforcement</strong></p>\n<ul>\n<li><strong>Context</strong>: HMAC can operate with keys of any length, but short keys reduce security. We need to decide whether to enforce minimum key length and what that minimum should be.</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>No minimum: Accept any key length for maximum flexibility</li>\n<li>16-byte minimum: Balances security with compatibility for existing systems</li>\n<li>32-byte minimum: Matches SHA-256 security level for optimal protection</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Enforce 32-byte minimum key length with option to override for testing</li>\n<li><strong>Rationale</strong>: 32-byte keys provide security equivalent to the underlying SHA-256 algorithm, preventing the key from becoming the weakest link. This matches industry best practices and recommendations from cryptographic experts.</li>\n<li><strong>Consequences</strong>: May require key generation or expansion for applications currently using shorter keys, but significantly improves overall security posture.</li>\n</ul>\n</blockquote>\n<p>Our key storage approach maintains keys as byte arrays rather than strings to avoid encoding issues and ensure consistent handling across different character encodings. When applications provide keys as strings, we convert them to bytes using UTF-8 encoding, but we encourage applications to generate and store keys as base64-encoded byte sequences for maximum compatibility.</p>\n<table>\n<thead>\n<tr>\n<th>Key Handling Operation</th>\n<th>Security Consideration</th>\n<th>Implementation Approach</th>\n<th>Error Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Key Storage</td>\n<td>Minimize copies in memory</td>\n<td>Store as single byte array, pass by reference</td>\n<td>N/A - internal operation</td>\n</tr>\n<tr>\n<td>Key Validation</td>\n<td>Enforce minimum length</td>\n<td>Check byte length &gt;= 32, validate encoding</td>\n<td>Reject with clear error message</td>\n</tr>\n<tr>\n<td>Key Usage</td>\n<td>Protect during HMAC operations</td>\n<td>Pass directly to HMAC function</td>\n<td>Let HMAC library handle errors</td>\n</tr>\n<tr>\n<td>Key Cleanup</td>\n<td>Clear from memory when possible</td>\n<td>Zero out byte array contents</td>\n<td>Best effort - not guaranteed</td>\n</tr>\n</tbody></table>\n<p>The key validation process checks both length and format to catch common integration errors before they cause mysterious signature failures. Length validation ensures the key meets our security requirements, while format validation catches issues like accidentally passing base64-encoded keys where raw bytes are expected. These validations provide clear error messages during development while preventing weak configurations in production.</p>\n<p>Secret key cleanup attempts to remove key material from memory when it&#39;s no longer needed, though the effectiveness of this approach depends on programming language memory management and operating system behavior. In garbage-collected languages, we can zero out byte arrays before releasing references, though the garbage collector may have created additional copies during memory management operations. In manually managed languages, we can explicitly clear memory before freeing it, providing more reliable cleanup.</p>\n<p>The key handling component also addresses practical concerns around key distribution and rotation. While implementing full key rotation is beyond our current scope, our design anticipates future key rotation support by accepting keys as parameters rather than storing them as global state. This allows applications to change keys between operations, enabling gradual migration to new keys or emergency key rotation in response to compromise.</p>\n<p>Key generation guidance helps applications create strong keys appropriate for HMAC-SHA256 use. We recommend generating keys using cryptographically secure random number generators, avoiding predictable sources like timestamps or user-provided passwords. For applications that must derive keys from passwords, we recommend using proper key derivation functions like PBKDF2 or scrypt rather than simple hashing.</p>\n<h3 id=\"architecture-decisions\">Architecture Decisions</h3>\n<p>The cryptographic signing component required several critical design decisions that balance security, performance, and usability requirements. These decisions establish the foundation for secure JWT implementation while supporting the specific needs of our educational project.</p>\n<blockquote>\n<p><strong>Decision: Symmetric vs Asymmetric Cryptography</strong></p>\n<ul>\n<li><strong>Context</strong>: JWT supports both symmetric algorithms (HMAC-based) and asymmetric algorithms (RSA/ECDSA). We need to choose which approach to implement first, considering learning objectives and implementation complexity.</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>HMAC-only: Simpler implementation, symmetric key sharing required</li>\n<li>RSA signatures: Asymmetric keys enable distributed verification, more complex</li>\n<li>Both algorithms: Maximum flexibility, significantly more implementation work</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Focus on HMAC-SHA256 with architecture supporting future asymmetric algorithms</li>\n<li><strong>Rationale</strong>: HMAC provides an excellent introduction to cryptographic signatures without the complexity of public key cryptography. The learning objectives focus on understanding signature concepts rather than advanced cryptographic protocols.</li>\n<li><strong>Consequences</strong>: Initial implementation limited to scenarios where all parties can share secret keys, but clean architecture enables adding asymmetric algorithms later.</li>\n</ul>\n</blockquote>\n<p>The algorithm selection decision reflects our educational focus while maintaining practical utility. HMAC-SHA256 provides strong security guarantees and enjoys broad support across programming languages and platforms. Students can focus on understanding signature concepts, constant-time comparison, and secure key handling without getting distracted by the mathematical complexity of RSA or elliptic curve cryptography.</p>\n<blockquote>\n<p><strong>Decision: Error Handling Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Cryptographic operations can fail in various ways, from invalid inputs to system-level errors. We need consistent error handling that aids debugging without helping attackers.</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Detailed errors: Maximum debugging information, potential security risk</li>\n<li>Generic errors: Minimal information leakage, harder debugging</li>\n<li>Contextual errors: Different detail levels based on environment</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Generic errors in production with detailed errors available in development mode</li>\n<li><strong>Rationale</strong>: Balances security needs with developer productivity. Production systems should minimize information leakage, while development environments need detailed diagnostics.</li>\n<li><strong>Consequences</strong>: Requires configuration to distinguish environments, but provides both security and usability benefits.</li>\n</ul>\n</blockquote>\n<p>Our error handling approach recognizes that cryptographic components serve as security boundaries where information leakage can have serious consequences. By providing different error detail levels based on environment, we enable effective development while maintaining production security.</p>\n<blockquote>\n<p><strong>Decision: Timing Attack Prevention</strong></p>\n<ul>\n<li><strong>Context</strong>: Signature verification must prevent timing attacks that could leak information about valid signatures. This requires careful implementation of comparison operations.</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Standard comparison: Fast but vulnerable to timing attacks</li>\n<li>Constant-time comparison: Secure but potentially slower</li>\n<li>Hash-based comparison: Alternative approach using cryptographic hashes</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Implement constant-time comparison for all cryptographic comparisons</li>\n<li><strong>Rationale</strong>: Timing attacks represent a real threat in network-accessible applications. Constant-time comparison provides strong protection with acceptable performance overhead.</li>\n<li><strong>Consequences</strong>: Slightly slower signature verification, but eliminates entire class of cryptographic attacks.</li>\n</ul>\n</blockquote>\n<p>The timing attack prevention decision prioritizes security over performance, recognizing that cryptographic vulnerabilities can completely compromise authentication systems. While the performance impact is minimal for most applications, the security benefit is substantial.</p>\n<table>\n<thead>\n<tr>\n<th>Architecture Decision</th>\n<th>Security Impact</th>\n<th>Performance Impact</th>\n<th>Implementation Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HMAC-SHA256 Only</td>\n<td>High - proven algorithm</td>\n<td>High - fast computation</td>\n<td>Low - standard library support</td>\n</tr>\n<tr>\n<td>Constant-time comparison</td>\n<td>Critical - prevents timing attacks</td>\n<td>Low - minimal overhead</td>\n<td>Medium - requires careful implementation</td>\n</tr>\n<tr>\n<td>Generic error messages</td>\n<td>Medium - reduces information leakage</td>\n<td>None</td>\n<td>Low - simple message filtering</td>\n</tr>\n<tr>\n<td>Minimum key length enforcement</td>\n<td>High - prevents weak key attacks</td>\n<td>None</td>\n<td>Low - simple length check</td>\n</tr>\n</tbody></table>\n<p>Our architecture decisions establish security as the primary concern while maintaining reasonable performance and implementation complexity. Each decision includes explicit consideration of security implications, ensuring that educational simplicity doesn&#39;t come at the cost of fundamental security properties.</p>\n<p>The component architecture also anticipates future extensions without requiring major refactoring. The signing interface accepts algorithm identifiers, enabling support for additional HMAC variants (HS384, HS512) or asymmetric algorithms (RS256, ES256) in future iterations. This extensibility allows the educational progression from simple symmetric signatures to advanced public key cryptography.</p>\n<p>Performance considerations influence several implementation details, though security requirements take precedence in case of conflicts. We use streaming approaches for large token processing and avoid unnecessary memory allocations during signature computation. However, we never sacrifice constant-time properties or other security requirements for performance gains.</p>\n<p><img src=\"/api/project/jwt-impl/architecture-doc/asset?path=diagrams%2Fsignature-verification-flowchart.svg\" alt=\"Signature Verification Process\"></p>\n<p>The architectural decisions create a foundation that supports both educational objectives and real-world deployment requirements. Students learn essential cryptographic concepts through hands-on implementation, while the resulting code maintains security properties necessary for production use.</p>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>Cryptographic implementations present numerous opportunities for subtle bugs that can completely compromise security. These pitfalls often involve implementation details that appear minor but have significant security implications. Understanding these common mistakes helps developers avoid vulnerabilities and build more secure systems.</p>\n<p>⚠️ <strong>Pitfall: Using Standard String/Byte Comparison for Signatures</strong></p>\n<p>One of the most dangerous mistakes involves using standard comparison operations for signature verification. Most programming languages provide comparison functions optimized for performance, which terminate as soon as they find the first differing byte. While this optimization works well for general purposes, it creates a timing side channel that attackers can exploit to gradually discover valid signatures.</p>\n<p>The vulnerability works by measuring how long signature verification takes for different candidate signatures. A signature that differs in the first byte will be rejected very quickly, while a signature that matches the first several bytes but differs later will take longer to reject. By systematically trying different byte values and measuring response times, attackers can determine the correct value for each byte position, eventually reconstructing the entire signature.</p>\n<p>The correct approach requires comparing every byte of both signatures regardless of any differences found earlier. This constant-time comparison ensures that verification takes the same amount of time whether signatures differ in the first byte or the last byte, eliminating the timing side channel.</p>\n<p>⚠️ <strong>Pitfall: Exposing Secret Keys in Error Messages or Logs</strong></p>\n<p>Developers often include excessive detail in error messages and log statements to aid debugging, inadvertently exposing sensitive information. Secret keys might appear in error messages when key validation fails, in debug logs during signature computation, or in stack traces when exceptions occur during cryptographic operations.</p>\n<p>Even partial key exposure can be dangerous. If attackers learn the first few bytes of a key through log analysis, they can use this information to significantly reduce the search space for brute-force attacks. Additionally, keys might be exposed indirectly through related information like key derivation parameters or storage paths.</p>\n<p>The solution involves treating secret keys as sensitive material throughout the application. Never include keys in error messages, use generic identifiers in logs instead of actual key values, and ensure that exception handling doesn&#39;t inadvertently expose key material in stack traces or debugging output.</p>\n<p>⚠️ <strong>Pitfall: Accepting Weak or Predictable Keys</strong></p>\n<p>Applications sometimes use weak keys that appear random but are actually predictable or have insufficient entropy. Common examples include keys derived from timestamps, user passwords without proper key derivation, or keys generated using weak random number generators.</p>\n<p>Weak keys can be vulnerable to brute-force attacks, especially if attackers can obtain multiple tokens signed with the same key. Even keys that seem random might be predictable if they follow patterns or use insufficient entropy sources. For example, keys derived from current time might be discoverable by trying timestamps around the token creation time.</p>\n<p>Proper key handling requires using cryptographically secure random number generators and enforcing minimum key length requirements. Keys should have at least 256 bits of entropy to match the security level of HMAC-SHA256, and they should be generated using platform-specific secure random facilities rather than general-purpose random number generators.</p>\n<p>⚠️ <strong>Pitfall: Incorrect Base64URL Encoding/Decoding</strong></p>\n<p>JWT requires Base64URL encoding, which differs from standard Base64 in subtle but important ways. Base64URL uses different characters for positions 62 and 63 (- and _ instead of + and /), omits padding characters, and is designed to be URL-safe. Using standard Base64 encoding creates tokens that may work in some contexts but fail unpredictably in others.</p>\n<p>The encoding difference can cause signature verification failures when tokens are created with one encoding variant and verified with another. Additionally, padding handling can cause issues when manually implementing Base64URL encoding/decoding rather than using library functions specifically designed for this variant.</p>\n<p>Always use Base64URL-specific encoding functions rather than adapting standard Base64 implementations. Most cryptographic libraries provide proper Base64URL support that handles the character set differences and padding requirements automatically.</p>\n<p>⚠️ <strong>Pitfall: Algorithm Confusion Attacks</strong></p>\n<p>While our implementation focuses on HMAC-SHA256, JWT&#39;s flexibility in algorithm selection creates opportunities for algorithm confusion attacks. These attacks exploit systems that accept multiple algorithms by tricking them into using weaker algorithms or algorithms with different security properties.</p>\n<p>A common attack involves submitting tokens with &quot;alg&quot;: &quot;none&quot; in the header, attempting to bypass signature verification entirely. Another variant involves submitting HMAC-signed tokens to systems expecting RSA signatures, potentially allowing attackers to use known public keys as HMAC secrets.</p>\n<p>Even though our implementation only supports HS256, we should explicitly validate that incoming tokens specify this algorithm and reject tokens claiming to use other algorithms. This prevents future extensibility from inadvertently introducing algorithm confusion vulnerabilities.</p>\n<p>⚠️ <strong>Pitfall: Insufficient Error Handling During Signature Verification</strong></p>\n<p>Signature verification can fail for many reasons beyond simple signature mismatches. Network issues during key retrieval, memory allocation failures during signature computation, and hardware security module errors can all cause verification to fail in unexpected ways. Insufficient error handling might cause the system to behave unpredictably or provide more information to attackers than intended.</p>\n<p>Some implementations make the mistake of treating all verification errors as &quot;invalid signature&quot; results, potentially accepting tokens that should be rejected for other reasons. Others provide too much detail in error responses, helping attackers understand system internals or identify attack vectors.</p>\n<p>Proper error handling distinguishes between different failure types while providing consistent external behavior. Cryptographic errors should be logged for debugging purposes but should result in generic &quot;verification failed&quot; responses to prevent information leakage to attackers.</p>\n<table>\n<thead>\n<tr>\n<th>Pitfall</th>\n<th>Security Impact</th>\n<th>Detection Method</th>\n<th>Prevention Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Timing attack vulnerability</td>\n<td>Critical - can leak signature information</td>\n<td>Measure verification time variance</td>\n<td>Implement constant-time comparison</td>\n</tr>\n<tr>\n<td>Key exposure in logs</td>\n<td>High - enables token forgery</td>\n<td>Review log outputs and error messages</td>\n<td>Sanitize all output containing keys</td>\n</tr>\n<tr>\n<td>Weak key acceptance</td>\n<td>High - enables brute force attacks</td>\n<td>Test with short or predictable keys</td>\n<td>Enforce minimum key length and entropy</td>\n</tr>\n<tr>\n<td>Wrong Base64 variant</td>\n<td>Medium - causes interoperability issues</td>\n<td>Test with URL-unsafe characters</td>\n<td>Use Base64URL-specific functions</td>\n</tr>\n<tr>\n<td>Algorithm confusion</td>\n<td>Variable - depends on accepted algorithms</td>\n<td>Submit tokens with different algorithms</td>\n<td>Explicitly validate algorithm field</td>\n</tr>\n<tr>\n<td>Poor error handling</td>\n<td>Low to Medium - information leakage</td>\n<td>Submit malformed tokens</td>\n<td>Provide consistent error responses</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The cryptographic signing component requires careful attention to security details while leveraging standard library cryptographic functions. This guidance provides practical approaches for implementing secure HMAC-SHA256 signing and verification.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HMAC Implementation</td>\n<td><code>hashlib.hmac</code> (built-in)</td>\n<td><code>cryptography</code> library for enterprise features</td>\n</tr>\n<tr>\n<td>Constant-time Comparison</td>\n<td><code>hmac.compare_digest</code> (built-in)</td>\n<td>Custom implementation with explicit timing control</td>\n</tr>\n<tr>\n<td>Key Validation</td>\n<td>Manual length checks</td>\n<td><code>cryptography.fernet</code> key derivation utilities</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Standard exceptions</td>\n<td>Custom exception hierarchy with security context</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>jwt_library/\n  signing/\n    __init__.py              ← exports main signing interface\n    hmac_signer.py          ← HMAC-SHA256 implementation (core learning component)\n    key_handler.py          ← secret key validation and storage utilities\n    timing_safe.py          ← constant-time comparison utilities (provided)\n    exceptions.py           ← signing-specific exception classes (provided)\n  tests/\n    test_signing.py         ← comprehensive signing tests\n    test_vectors.py         ← RFC test vectors for validation</code></pre></div>\n\n<p><strong>Infrastructure Starter Code - Timing Safe Comparison (<code>timing_safe.py</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Timing-safe comparison utilities for cryptographic operations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">This module provides comparison functions that resist timing attacks.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hmac</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Union</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> constant_time_compare</span><span style=\"color:#E1E4E8\">(a: Union[</span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], b: Union[</span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Compare two values in constant time to prevent timing attacks.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    This function always examines every byte regardless of early differences,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    ensuring consistent execution time that doesn't leak information about</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    where the values differ.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        a: First value to compare (bytes or string)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        b: Second value to compare (bytes or string)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        True if values are identical, False otherwise</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Security:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Uses hmac.compare_digest for cryptographically secure comparison</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Convert strings to bytes for consistent comparison</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(a, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        a </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> a.encode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(b, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        b </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> b.encode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Use hmac.compare_digest for timing-safe comparison</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> hmac.compare_digest(a, b)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_signature_length</span><span style=\"color:#E1E4E8\">(signature: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, expected_length: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Validate signature length in constant time.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        signature: The signature to validate</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        expected_length: Expected signature length in bytes</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        True if signature has correct length, False otherwise</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Length comparison is naturally constant-time in most implementations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(signature) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> expected_length</span></span></code></pre></div>\n\n<p><strong>Infrastructure Starter Code - Exception Classes (<code>exceptions.py</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Exception classes for JWT signing operations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Provides specific exception types for different signing failure modes.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> JWTSigningError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base exception for all JWT signing errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InvalidKeyError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTSigningError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when secret key is invalid or insufficient.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SignatureVerificationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTSigningError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when signature verification fails.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InvalidTokenFormatError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTSigningError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when token format is invalid for signing operations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CryptographicError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTSigningError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when underlying cryptographic operations fail.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton - HMAC Signer (<code>hmac_signer.py</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">HMAC-SHA256 signing implementation for JWT tokens.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">This module handles the core cryptographic operations for JWT signing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hashlib</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hmac</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .timing_safe </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> constant_time_compare</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .exceptions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> InvalidKeyError, SignatureVerificationError, CryptographicError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Minimum key length for security (32 bytes = 256 bits)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">MIN_KEY_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 32</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected signature length for HMAC-SHA256 (32 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">HMAC_SHA256_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 32</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> HMACSignerHS256</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"HMAC-SHA256 signer for JWT tokens.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, secret_key: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Initialize HMAC signer with secret key.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            secret_key: Secret key for HMAC operations (minimum 32 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            InvalidKeyError: If key is too short or invalid</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate key length meets minimum security requirements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Store key securely for later use in signing operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Check len(secret_key) >= MIN_KEY_LENGTH</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create_signing_input</span><span style=\"color:#E1E4E8\">(self, encoded_header: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, encoded_payload: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Create signing input string from encoded header and payload.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            encoded_header: Base64URL encoded JWT header</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            encoded_payload: Base64URL encoded JWT payload</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Signing input in format \"header.payload\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Concatenate header and payload with dot separator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Return the complete signing input string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use f\"{encoded_header}.{encoded_payload}\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> sign</span><span style=\"color:#E1E4E8\">(self, signing_input: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Generate HMAC-SHA256 signature for signing input.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            signing_input: String to sign (header.payload format)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Base64URL encoded signature</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            CryptographicError: If HMAC computation fails</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Convert signing input string to bytes using UTF-8 encoding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Compute HMAC-SHA256 using self._secret_key and input bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Encode resulting signature using base64url_encode function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return encoded signature as string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Hint: Use hmac.new(key, message, hashlib.sha256).digest()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Wrap any exceptions in CryptographicError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> verify</span><span style=\"color:#E1E4E8\">(self, signing_input: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, provided_signature: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Verify HMAC-SHA256 signature against signing input.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            signing_input: String that was signed</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            provided_signature: Base64URL encoded signature to verify</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            True if signature is valid, False otherwise</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            SignatureVerificationError: If verification process fails</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Decode provided signature from Base64URL to bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Validate signature length matches HMAC-SHA256 output (32 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Compute expected signature using same process as sign()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Compare provided and expected signatures using constant_time_compare</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return comparison result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Hint: Use base64url_decode() and validate length before comparison</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Convert exceptions to SignatureVerificationError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton - Key Handler (<code>key_handler.py</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Secret key handling utilities for JWT signing operations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Provides secure key validation and management functions.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> secrets</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> os</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Union</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .exceptions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> InvalidKeyError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_key_strength</span><span style=\"color:#E1E4E8\">(key: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Validate that secret key meets security requirements.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        key: Secret key to validate</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        InvalidKeyError: If key doesn't meet security requirements</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check key length meets minimum requirement (32 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Optionally check for obviously weak keys (all zeros, repeated patterns)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Raise InvalidKeyError with descriptive message if validation fails</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use len(key) and consider checking for key == b'\\x00' * len(key)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> generate_secure_key</span><span style=\"color:#E1E4E8\">() -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Generate cryptographically secure random key for HMAC operations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        32-byte random key suitable for HMAC-SHA256</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Generate 32 random bytes using cryptographically secure generator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Return the generated key</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use secrets.token_bytes(32)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> key_from_string</span><span style=\"color:#E1E4E8\">(key_string: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Convert string key to bytes with consistent encoding.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        key_string: Key as string (will be UTF-8 encoded)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Key as bytes</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Encode string to bytes using UTF-8</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Validate resulting key meets security requirements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return validated key bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use key_string.encode('utf-8') then validate_key_strength()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SecureKeyHandler</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Secure storage and management of JWT signing keys.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, key: Union[</span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Initialize key handler with secure key storage.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            key: Secret key as bytes or string</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Convert string keys to bytes if needed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Validate key strength</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Store key securely (consider copying to avoid external modification)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use isinstance(key, str) to check type and bytes(key) to copy</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_key</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Retrieve stored key for cryptographic operations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Secret key as bytes</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Return copy of stored key to prevent external modification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Return bytes(self._key) to create a copy</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> clear_key</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Attempt to clear key from memory (best effort).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Overwrite key bytes with zeros</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Set key reference to None</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use bytearray to create mutable copy, then clear with zeros</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Language-Specific Hints for Python:</strong></p>\n<ul>\n<li>Use <code>hmac.new(key, message, hashlib.sha256)</code> for HMAC-SHA256 computation</li>\n<li>Always use <code>hmac.compare_digest()</code> for cryptographic comparisons to prevent timing attacks</li>\n<li>Import <code>secrets</code> module for cryptographically secure random number generation</li>\n<li>Use <code>bytes()</code> constructor to create defensive copies of key material</li>\n<li>Handle encoding carefully: strings should be UTF-8 encoded before cryptographic operations</li>\n</ul>\n<p><strong>Milestone Checkpoint:</strong>\nAfter implementing the cryptographic signing component, verify functionality with these tests:</p>\n<ol>\n<li><strong>Basic Signing Test</strong>: Create a simple JWT with known header/payload, sign it, and verify the signature format is valid Base64URL</li>\n<li><strong>Round-trip Verification</strong>: Sign a token and immediately verify it with the same key - should return True</li>\n<li><strong>Invalid Signature Detection</strong>: Modify one character in a valid signature and verify it&#39;s rejected</li>\n<li><strong>Key Length Validation</strong>: Attempt to create signer with 16-byte key - should raise InvalidKeyError</li>\n<li><strong>Timing Attack Resistance</strong>: Measure verification time for signatures differing in first vs last byte - times should be similar</li>\n</ol>\n<p>Expected behavior: All signatures should be exactly 43 characters (32 bytes Base64URL encoded), verification should complete in consistent time regardless of where signatures differ, and weak keys should be rejected with clear error messages.</p>\n<p>Common debugging signs:</p>\n<ul>\n<li><strong>Signature length wrong</strong>: Check Base64URL encoding, should be 43 chars for 32-byte HMAC output</li>\n<li><strong>Verification always fails</strong>: Ensure identical signing input reconstruction in both sign/verify</li>\n<li><strong>Timing variations</strong>: Profile comparison function to ensure constant-time operation</li>\n<li><strong>Key validation bypassed</strong>: Verify MIN_KEY_LENGTH constant is being checked correctly</li>\n</ul>\n<h2 id=\"claims-validation-component\">Claims Validation Component</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 3 (Claims Validation) - implements standard JWT claim validation including time-based security checks, issuer and audience verification, and custom claims processing</p>\n</blockquote>\n<p>The claims validation component represents the final security checkpoint in our JWT library, ensuring that tokens contain valid, trustworthy information before granting access to protected resources. While signature verification confirms the token hasn&#39;t been tampered with, claims validation ensures the token is currently valid, comes from an authorized issuer, and is intended for the correct audience.</p>\n<h3 id=\"mental-model-ticket-inspection\">Mental Model: Ticket Inspection</h3>\n<p>Understanding claims validation becomes intuitive when we think of it like comprehensive ticket inspection at a major event venue. Imagine you&#39;re a security guard at a concert venue, and patrons are presenting tickets (JWT tokens) for entry.</p>\n<p>The signature verification component already confirmed the tickets are genuine (not counterfeit), but now you need to perform detailed inspection to ensure each ticket is actually valid for entry. You check multiple aspects systematically: Is this ticket for tonight&#39;s show, or did someone try to use last week&#39;s ticket? Has the show already started, or is this person trying to enter too early with a &quot;VIP early access&quot; ticket that isn&#39;t valid yet? Is this ticket for the correct venue, or did someone accidentally bring their ticket from the stadium across town? Is the ticket issued by an authorized ticket vendor we recognize, or is it from some unauthorized reseller we don&#39;t trust?</p>\n<p>Just as a thorough security guard checks expiration dates, venue information, authorized sellers, and timing restrictions, our claims validation component systematically verifies temporal claims (expiration, not-before dates), identity claims (issuer verification), audience claims (intended recipient), and any custom business logic encoded in the token. The goal is ensuring that even with a cryptographically valid token, we only grant access when all the contextual information confirms the token should be honored right now, for this specific request.</p>\n<h3 id=\"time-based-claim-validation\">Time-Based Claim Validation</h3>\n<p><img src=\"/api/project/jwt-impl/architecture-doc/asset?path=diagrams%2Fvalidation-state-machine.svg\" alt=\"Token Validation State Machine\"></p>\n<p>Time-based validation forms the cornerstone of JWT security, preventing replay attacks and ensuring tokens have bounded lifetimes. The JWT specification defines three temporal claims that work together to create secure time windows for token validity.</p>\n<p>The <strong>expiration claim (<code>exp</code>)</strong> specifies the absolute time after which a token must be rejected. This claim is expressed as a Unix timestamp (seconds since epoch) and represents the moment when the token becomes invalid. The validation logic compares the current UTC time against this timestamp, rejecting tokens where the current time exceeds the expiration. However, real-world distributed systems rarely have perfectly synchronized clocks, so validation must account for reasonable clock skew between the token issuer and validator.</p>\n<p>The <strong>not-before claim (<code>nbf</code>)</strong> defines the earliest time at which a token becomes valid. This claim enables scenarios like scheduled access grants or delayed activation tokens. Validation rejects tokens where the current time is before the not-before timestamp, even if the signature is valid and the token hasn&#39;t expired. This claim is particularly valuable for time-delayed permissions or tokens that should only become active at a specific future moment.</p>\n<p>The <strong>issued-at claim (<code>iat</code>)</strong> records when the token was created, serving both audit purposes and preventing unreasonably old tokens from being accepted. While not strictly required for security, the issued-at claim helps detect tokens that were issued suspiciously far in the past or future, which might indicate system clock problems or potential attacks.</p>\n<p>Clock skew tolerance becomes critical in distributed environments where token issuers and validators run on different servers with slightly different system clocks. Network latency, system load, and imperfect time synchronization can create small timing discrepancies. The validation component addresses this through a configurable <strong>leeway period</strong> that extends both directions around time-based boundaries.</p>\n<table>\n<thead>\n<tr>\n<th>Claim</th>\n<th>Purpose</th>\n<th>Validation Logic</th>\n<th>Clock Skew Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>exp</code></td>\n<td>Token expiration</td>\n<td>Reject if <code>current_time &gt; exp</code></td>\n<td>Allow if <code>current_time &lt;= exp + leeway</code></td>\n</tr>\n<tr>\n<td><code>nbf</code></td>\n<td>Not valid before</td>\n<td>Reject if <code>current_time &lt; nbf</code></td>\n<td>Allow if <code>current_time &gt;= nbf - leeway</code></td>\n</tr>\n<tr>\n<td><code>iat</code></td>\n<td>Issued at time</td>\n<td>Sanity check only</td>\n<td>Warn if <code>abs(current_time - iat) &gt; max_age</code></td>\n</tr>\n</tbody></table>\n<p>The temporal validation algorithm follows a specific sequence that accounts for clock skew while maintaining security:</p>\n<ol>\n<li><strong>Retrieve the current UTC timestamp</strong> using a reliable time source, ensuring consistent timezone handling across all validations</li>\n<li><strong>Extract temporal claims</strong> from the JWT payload, handling cases where claims might be missing or have incorrect types</li>\n<li><strong>Apply the configured leeway period</strong> to create tolerance windows around each timestamp boundary</li>\n<li><strong>Validate the expiration claim</strong> by checking if the current time (minus leeway) exceeds the expiration timestamp</li>\n<li><strong>Validate the not-before claim</strong> by checking if the current time (plus leeway) is before the not-before timestamp</li>\n<li><strong>Sanity-check the issued-at claim</strong> by warning if the token appears to be issued unreasonably far in the past or future</li>\n<li><strong>Record validation results</strong> for audit logging and debugging purposes</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Default Leeway Period</strong></p>\n<ul>\n<li><strong>Context</strong>: Distributed systems have imperfect clock synchronization, creating timing edge cases in token validation</li>\n<li><strong>Options Considered</strong>: Zero leeway (strict), 60-second leeway (minimal), 300-second leeway (generous)</li>\n<li><strong>Decision</strong>: 300 seconds (5 minutes) default leeway with configurability</li>\n<li><strong>Rationale</strong>: Balances security with practical deployment reality - most clock drift falls within 5 minutes, and the risk of 5-minute replay windows is acceptable for most applications</li>\n<li><strong>Consequences</strong>: Tokens remain valid for up to 5 minutes past expiration by default, but applications can configure stricter validation when needed</li>\n</ul>\n</blockquote>\n<p>The validation context structure allows applications to customize temporal behavior based on their security requirements:</p>\n<table>\n<thead>\n<tr>\n<th>Configuration Field</th>\n<th>Type</th>\n<th>Purpose</th>\n<th>Default Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>leeway_seconds</code></td>\n<td>int</td>\n<td>Clock skew tolerance</td>\n<td>300</td>\n</tr>\n<tr>\n<td><code>verify_expiration</code></td>\n<td>bool</td>\n<td>Enable expiration checking</td>\n<td>true</td>\n</tr>\n<tr>\n<td><code>verify_not_before</code></td>\n<td>bool</td>\n<td>Enable not-before checking</td>\n<td>true</td>\n</tr>\n<tr>\n<td><code>max_token_age</code></td>\n<td>int</td>\n<td>Maximum allowed token age</td>\n<td>86400 (24 hours)</td>\n</tr>\n<tr>\n<td><code>require_iat</code></td>\n<td>bool</td>\n<td>Require issued-at claim</td>\n<td>false</td>\n</tr>\n</tbody></table>\n<h3 id=\"identity-and-audience-validation\">Identity and Audience Validation</h3>\n<p><img src=\"/api/project/jwt-impl/architecture-doc/asset?path=diagrams%2Fclaims-validation-flowchart.svg\" alt=\"Claims Validation Decision Tree\"></p>\n<p>Identity and audience validation ensures tokens come from trusted sources and are intended for the correct recipient. These claims form the foundation of multi-tenant security and prevent tokens from being misused across different services or applications.</p>\n<p>The <strong>issuer claim (<code>iss</code>)</strong> identifies who created the token, typically represented as a URL or unique identifier. Validation maintains an allowlist of trusted issuers and rejects tokens from unknown or untrusted sources. This prevents attackers from creating their own JWT issuers and attempting to forge tokens that would be accepted by the application.</p>\n<p>Issuer validation follows a strict allowlist approach rather than a blocklist, ensuring that only explicitly trusted issuers can create tokens. The validation logic performs exact string matching against the configured list of allowed issuers, with no partial matching or pattern-based validation that could introduce security vulnerabilities.</p>\n<p>The <strong>audience claim (<code>aud</code>)</strong> specifies the intended recipients of the token, preventing tokens meant for one service from being used to access a different service. The JWT specification allows audiences to be represented as either a single string or an array of strings, accommodating tokens that are valid for multiple services.</p>\n<p>Audience validation presents unique challenges because the claim can be either a string or an array. The validation logic must handle both formats correctly, checking if the expected audience appears anywhere in the audience list when the claim is an array, or performing exact string matching when the claim is a single string.</p>\n<table>\n<thead>\n<tr>\n<th>Validation Type</th>\n<th>Required Configuration</th>\n<th>Validation Logic</th>\n<th>Error Conditions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Issuer</td>\n<td><code>allowed_issuers</code> list</td>\n<td>Exact string match</td>\n<td>Missing <code>iss</code>, unlisted issuer</td>\n</tr>\n<tr>\n<td>Audience</td>\n<td><code>expected_audience</code> string</td>\n<td>String or array membership</td>\n<td>Missing <code>aud</code>, audience mismatch</td>\n</tr>\n<tr>\n<td>Subject</td>\n<td>Optional validation</td>\n<td>Application-specific</td>\n<td>Invalid format or unauthorized subject</td>\n</tr>\n</tbody></table>\n<p>The identity validation algorithm incorporates both mandatory and optional checks:</p>\n<ol>\n<li><strong>Extract the issuer claim</strong> from the token payload, handling cases where the claim is missing or has an incorrect type</li>\n<li><strong>Check the require_issuer flag</strong> to determine if issuer validation is mandatory for this validation context</li>\n<li><strong>Validate against the allowlist</strong> by performing exact string matching against each entry in the allowed_issuers configuration</li>\n<li><strong>Extract the audience claim</strong> and determine its format (string or array) for appropriate validation logic</li>\n<li><strong>Check the require_audience flag</strong> to determine if audience validation is mandatory for this validation context</li>\n<li><strong>Perform audience membership testing</strong> by checking if the expected audience appears in the claim value</li>\n<li><strong>Extract and validate the subject claim</strong> if application-specific subject validation is configured</li>\n<li><strong>Log validation decisions</strong> for audit purposes and security monitoring</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Exact String Matching for Claims</strong></p>\n<ul>\n<li><strong>Context</strong>: Claims validation could use exact matching, pattern matching, or more flexible string comparison</li>\n<li><strong>Options Considered</strong>: Exact matching, regex patterns, case-insensitive matching</li>\n<li><strong>Decision</strong>: Exact string matching only for security-critical claims</li>\n<li><strong>Rationale</strong>: Pattern matching introduces complexity and potential bypass vulnerabilities; exact matching is more predictable and secure</li>\n<li><strong>Consequences</strong>: Applications must ensure exact case and format matching in their issuer and audience configurations</li>\n</ul>\n</blockquote>\n<p>The audience validation logic handles the specification&#39;s flexibility while maintaining security:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Audience Validation Algorithm:\n1. If audience claim is missing and require_audience is true → REJECT\n2. If audience claim is missing and require_audience is false → ACCEPT\n3. If audience claim is a string:\n   a. Compare exactly with expected_audience\n   b. ACCEPT if match, REJECT if no match\n4. If audience claim is an array:\n   a. Iterate through each audience value\n   b. ACCEPT if any value matches expected_audience exactly\n   c. REJECT if no values match\n5. If audience claim is neither string nor array → REJECT (invalid format)</code></pre></div>\n\n<h3 id=\"custom-claims-processing\">Custom Claims Processing</h3>\n<p>Custom claims enable applications to embed business-specific information directly into tokens, eliminating the need for additional database queries during request processing. The claims validation component provides a flexible framework for extracting and validating application-defined claims while maintaining the security properties of standard claims.</p>\n<p>Custom claims fall into three categories defined by the JWT specification: <strong>public claims</strong> use collision-resistant names (typically URLs), <strong>private claims</strong> are agreed upon between token issuers and consumers, and <strong>application-specific claims</strong> contain business logic data unique to the particular system.</p>\n<p>The custom claims processing system maintains a clear separation between claim extraction and claim validation. Extraction focuses on safely retrieving typed data from the JSON payload, while validation applies business logic rules to determine if the claim values are acceptable for the current request context.</p>\n<table>\n<thead>\n<tr>\n<th>Claim Category</th>\n<th>Naming Convention</th>\n<th>Collision Risk</th>\n<th>Validation Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Public</td>\n<td>URL-based names</td>\n<td>Low (collision-resistant)</td>\n<td>Standard validation rules</td>\n</tr>\n<tr>\n<td>Private</td>\n<td>Agreed-upon names</td>\n<td>Medium (coordination required)</td>\n<td>Application-specific rules</td>\n</tr>\n<tr>\n<td>Application</td>\n<td>Internal names</td>\n<td>High (namespace conflicts)</td>\n<td>Custom validation logic</td>\n</tr>\n</tbody></table>\n<p>The custom claims extraction process handles type safety and data validation systematically:</p>\n<ol>\n<li><strong>Parse the JWT payload</strong> as a JSON object, ensuring all standard claims are handled separately from custom claims</li>\n<li><strong>Identify custom claim keys</strong> by filtering out the standard registered claim names (iss, sub, aud, exp, nbf, iat, jti)</li>\n<li><strong>Extract claim values</strong> with appropriate type checking, handling strings, numbers, booleans, arrays, and nested objects</li>\n<li><strong>Apply claim-specific validation rules</strong> based on application configuration and business logic requirements</li>\n<li><strong>Populate the custom_claims dictionary</strong> with successfully validated claim data for application use</li>\n<li><strong>Log validation failures</strong> for custom claims that fail business logic validation without rejecting the entire token</li>\n</ol>\n<p>Custom claims validation configuration allows applications to specify validation rules declaratively:</p>\n<table>\n<thead>\n<tr>\n<th>Configuration Element</th>\n<th>Purpose</th>\n<th>Example Values</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>required_claims</code></td>\n<td>Claims that must be present</td>\n<td>[&quot;role&quot;, &quot;tenant_id&quot;, &quot;permissions&quot;]</td>\n</tr>\n<tr>\n<td><code>claim_validators</code></td>\n<td>Type and format validation</td>\n<td>{&quot;role&quot;: &quot;string&quot;, &quot;permissions&quot;: &quot;array&quot;}</td>\n</tr>\n<tr>\n<td><code>value_constraints</code></td>\n<td>Allowed values or ranges</td>\n<td>{&quot;role&quot;: [&quot;admin&quot;, &quot;user&quot;], &quot;max_sessions&quot;: 10}</td>\n</tr>\n</tbody></table>\n<p>The validation framework provides common validation patterns while allowing custom validation logic:</p>\n<ol>\n<li><strong>Presence validation</strong> ensures required claims are not missing from the token payload</li>\n<li><strong>Type validation</strong> confirms claim values match expected JSON types (string, number, boolean, array, object)</li>\n<li><strong>Format validation</strong> applies regular expressions or custom format checking to string claims</li>\n<li><strong>Range validation</strong> ensures numeric claims fall within acceptable minimum and maximum bounds</li>\n<li><strong>Enumeration validation</strong> restricts string claims to predefined allowed values</li>\n<li><strong>Custom validation</strong> applies arbitrary application logic to complex claim structures</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Flexible Custom Claims Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: Applications need to embed business logic in tokens while maintaining validation consistency</li>\n<li><strong>Options Considered</strong>: Fixed claim schema, completely flexible claims, hybrid validation approach</li>\n<li><strong>Decision</strong>: Hybrid approach with configurable validation rules and extensible validation logic</li>\n<li><strong>Rationale</strong>: Provides type safety and common validation patterns while allowing application-specific business logic</li>\n<li><strong>Consequences</strong>: Applications must configure validation rules explicitly, but gain flexibility for complex use cases</li>\n</ul>\n</blockquote>\n<h3 id=\"architecture-decisions\">Architecture Decisions</h3>\n<p>The claims validation component incorporates several critical architectural decisions that balance security, performance, and developer experience. These decisions directly impact how the component integrates with the broader JWT library and how applications configure validation behavior.</p>\n<blockquote>\n<p><strong>Decision: Fail-Fast Validation Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Claims validation could check all claims and return aggregate errors, or fail immediately on the first invalid claim</li>\n<li><strong>Options Considered</strong>: Fail-fast (immediate rejection), comprehensive validation (check all claims), configurable strategy</li>\n<li><strong>Decision</strong>: Fail-fast validation with early termination on any validation failure</li>\n<li><strong>Rationale</strong>: Reduces attack surface by minimizing processing of potentially malicious tokens; simpler error handling; better performance for invalid tokens</li>\n<li><strong>Consequences</strong>: Applications receive single-error feedback rather than comprehensive validation reports; debugging may require multiple fix-and-retry cycles</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Validation Strategy</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Security Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Fail-fast</td>\n<td>Fast rejection, simple logic</td>\n<td>Single error per attempt</td>\n<td>Minimal attack surface</td>\n</tr>\n<tr>\n<td>Comprehensive</td>\n<td>Complete error reporting</td>\n<td>Complex error handling</td>\n<td>Extended processing of invalid tokens</td>\n</tr>\n<tr>\n<td>Configurable</td>\n<td>Flexible behavior</td>\n<td>Increased complexity</td>\n<td>Variable attack surface</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Immutable Validation Context</strong></p>\n<ul>\n<li><strong>Context</strong>: Validation configuration could be mutable (allowing runtime changes) or immutable (fixed at creation time)</li>\n<li><strong>Options Considered</strong>: Mutable context with runtime updates, immutable context with factory creation, hybrid approach</li>\n<li><strong>Decision</strong>: Immutable ValidationContext objects created through factory functions</li>\n<li><strong>Rationale</strong>: Prevents accidental configuration changes during validation; enables safe concurrent use; clearer security boundaries</li>\n<li><strong>Consequences</strong>: Applications must create new contexts for different validation requirements; no runtime configuration updates</li>\n</ul>\n</blockquote>\n<p>The validation context factory approach ensures thread safety and prevents configuration tampering:</p>\n<table>\n<thead>\n<tr>\n<th>Factory Method</th>\n<th>Purpose</th>\n<th>Configuration Scope</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>create_strict_context()</code></td>\n<td>Maximum security validation</td>\n<td>All checks enabled, minimal leeway</td>\n</tr>\n<tr>\n<td><code>create_permissive_context()</code></td>\n<td>Development-friendly validation</td>\n<td>Optional checks, generous leeway</td>\n</tr>\n<tr>\n<td><code>create_custom_context()</code></td>\n<td>Application-specific configuration</td>\n<td>Fully configurable validation rules</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Hierarchical Error Classification</strong></p>\n<ul>\n<li><strong>Context</strong>: Validation failures could return generic errors or detailed, categorized error information</li>\n<li><strong>Options Considered</strong>: Generic validation errors, detailed error codes, hierarchical error types</li>\n<li><strong>Decision</strong>: Hierarchical error classification with security-appropriate detail levels</li>\n<li><strong>Rationale</strong>: Enables appropriate error handling without leaking security-sensitive information; supports debugging while preventing information disclosure</li>\n<li><strong>Consequences</strong>: Applications must handle multiple error types; error messages balance security with developer experience</li>\n</ul>\n</blockquote>\n<p>The error hierarchy provides appropriate detail without security information leakage:</p>\n<table>\n<thead>\n<tr>\n<th>Error Category</th>\n<th>Public Details</th>\n<th>Internal Details</th>\n<th>Security Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Temporal</td>\n<td>&quot;Token expired&quot;</td>\n<td>Exact expiration time</td>\n<td>Prevents timing analysis</td>\n</tr>\n<tr>\n<td>Identity</td>\n<td>&quot;Invalid issuer&quot;</td>\n<td>Expected vs actual issuer</td>\n<td>Prevents issuer enumeration</td>\n</tr>\n<tr>\n<td>Audience</td>\n<td>&quot;Audience mismatch&quot;</td>\n<td>Expected vs actual audience</td>\n<td>Prevents service discovery</td>\n</tr>\n<tr>\n<td>Custom</td>\n<td>&quot;Claim validation failed&quot;</td>\n<td>Specific claim and reason</td>\n<td>Prevents business logic exposure</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>Claims validation presents numerous subtle edge cases that can introduce security vulnerabilities or cause legitimate tokens to be incorrectly rejected. Understanding these pitfalls helps developers build robust validation logic.</p>\n<p>⚠️ <strong>Pitfall: Clock Skew Overcompensation</strong></p>\n<p>Developers often set excessively generous leeway periods to avoid clock synchronization issues, inadvertently creating security vulnerabilities. A leeway of several hours or days essentially defeats the purpose of token expiration, allowing expired tokens to remain valid indefinitely.</p>\n<p>The problem manifests when applications experience occasional clock drift and developers respond by increasing the leeway period instead of addressing the underlying time synchronization issue. This creates a false sense of security where tokens appear to have bounded lifetimes but actually remain valid far beyond their intended expiration.</p>\n<p><strong>Fix</strong>: Use the minimum leeway period necessary for your infrastructure (typically 300 seconds or less) and implement proper NTP synchronization across all servers. Monitor clock drift and alert when servers exceed acceptable time variance rather than increasing leeway periods.</p>\n<p>⚠️ <strong>Pitfall: Audience Claim Type Confusion</strong></p>\n<p>The JWT specification allows audience claims to be either strings or arrays, but many implementations incorrectly assume one format or the other. This leads to validation failures when tokens contain audience arrays but the validator expects strings, or vice versa.</p>\n<p>The issue becomes particularly problematic in microservice architectures where some services generate tokens with single audience strings while others use audience arrays. Validation logic that doesn&#39;t handle both formats correctly will reject valid tokens unpredictably.</p>\n<p><strong>Fix</strong>: Implement validation logic that explicitly checks the audience claim type and handles both string and array formats. Always test with both single-audience and multi-audience tokens during development.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Audience Validation Logic:\n1. Extract audience claim from payload\n2. Check if claim is string → validate as single audience\n3. Check if claim is array → validate as audience list\n4. If neither string nor array → reject as invalid format</code></pre></div>\n\n<p>⚠️ <strong>Pitfall: Missing Claim vs. Null Claim Confusion</strong></p>\n<p>JSON parsing libraries handle missing object properties and null values differently, but validation logic often conflates these cases. A missing <code>exp</code> claim and an <code>exp</code> claim with a null value represent different scenarios and should be handled distinctly.</p>\n<p>Missing claims might indicate tokens created by older systems that don&#39;t include certain fields, while null claims might indicate explicit attempts to bypass validation or corrupted token data. Treating these cases identically can lead to either overly permissive or overly restrictive validation.</p>\n<p><strong>Fix</strong>: Explicitly check for claim presence using JSON object key existence before checking claim values. Handle missing claims and null claims as separate validation cases with appropriate error messages.</p>\n<p>⚠️ <strong>Pitfall: Integer Overflow in Timestamp Handling</strong></p>\n<p>Unix timestamps in JWT claims are represented as JSON numbers, but different languages and JSON parsers handle large integers differently. Timestamps near the year 2038 problem boundary (2^31 seconds since epoch) can cause integer overflow in 32-bit systems or unexpected behavior in languages with limited integer precision.</p>\n<p>Additionally, some JWT implementations use millisecond timestamps instead of second timestamps, creating magnitude differences that cause all time-based validation to fail. The JWT specification requires second-precision Unix timestamps, but not all implementations follow this requirement.</p>\n<p><strong>Fix</strong>: Use 64-bit integers for all timestamp handling and explicitly validate that timestamp values fall within reasonable ranges (between reasonable past and future dates). Detect and handle millisecond timestamps by checking if values are suspiciously large.</p>\n<p>⚠️ <strong>Pitfall: Case Sensitivity in Claim Matching</strong></p>\n<p>String matching for issuer and audience claims is case-sensitive, but applications often assume case-insensitive matching will work. This leads to validation failures when token issuers use different capitalization than the validation configuration expects.</p>\n<p>The problem is compounded when applications use URLs as issuer identifiers, since URLs can be represented with different schemes (HTTP vs HTTPS) or hostnames (different capitalization) that should be treated as distinct for security purposes.</p>\n<p><strong>Fix</strong>: Use exact string matching for all security-critical claims and ensure consistent capitalization in both token generation and validation configuration. Document the case-sensitivity requirement clearly for application developers.</p>\n<p>⚠️ <strong>Pitfall: Custom Claims Type Coercion</strong></p>\n<p>Applications often extract custom claims without proper type validation, allowing JSON type coercion to silently convert claim values in unexpected ways. A numeric permission level might be provided as a string &quot;5&quot; but converted to integer 5, or boolean flags might be provided as strings &quot;true&quot;/&quot;false&quot; but not converted to actual booleans.</p>\n<p>Type coercion can create security vulnerabilities when validation logic expects specific types but receives coerced values that bypass validation rules. For example, a string comparison might succeed when an integer comparison would fail.</p>\n<p><strong>Fix</strong>: Implement explicit type checking for all custom claims before performing validation logic. Reject tokens with claims that have incorrect types rather than attempting type coercion.</p>\n<p>⚠️ <strong>Pitfall: Timezone Confusion in Time Validation</strong></p>\n<p>UTC timestamp handling can introduce subtle bugs when system clocks, application logic, or database storage use different timezone assumptions. Tokens validated on servers in different timezones might produce inconsistent results if timezone conversion isn&#39;t handled carefully.</p>\n<p>The issue becomes particularly problematic when applications mix timezone-aware datetime objects with Unix timestamps, leading to incorrect time comparisons that can cause premature expiration or extended validity periods.</p>\n<p><strong>Fix</strong>: Use UTC consistently throughout all timestamp handling, convert all datetime objects to UTC before Unix timestamp conversion, and validate that system clocks are configured for UTC rather than local timezones.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The claims validation component requires careful attention to time handling, type safety, and security boundaries. The following implementation structure provides a robust foundation while maintaining flexibility for application-specific requirements.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Time Handling</td>\n<td><code>datetime.utcnow()</code> + manual UTC conversion</td>\n<td><code>pendulum</code> library for robust timezone handling</td>\n</tr>\n<tr>\n<td>JSON Validation</td>\n<td>Built-in <code>json</code> module with manual type checking</td>\n<td><code>jsonschema</code> library for declarative validation</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>Simple dictionaries and dataclasses</td>\n<td><code>pydantic</code> models with validation</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>Standard <code>logging</code> module</td>\n<td><code>structlog</code> for structured claim validation logs</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<p>The claims validation component integrates with the broader JWT library architecture:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>jwt-library/\n  jwt/\n    __init__.py                 ← main library exports\n    validation/                 ← claims validation component\n      __init__.py              ← validation exports\n      claims_validator.py      ← main validation logic\n      time_validation.py       ← temporal claim handling\n      identity_validation.py   ← issuer/audience validation\n      custom_claims.py         ← custom claims processing\n      validation_context.py    ← configuration management\n      validation_errors.py     ← error hierarchy\n    core/                      ← core JWT components\n      encoding.py             ← token encoding (Milestone 1)\n      signing.py              ← HMAC signing (Milestone 2)\n  tests/\n    test_validation/           ← validation component tests\n      test_claims_validator.py\n      test_time_validation.py\n      test_identity_validation.py\n      test_custom_claims.py</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>validation_errors.py</strong> - Complete error hierarchy for claims validation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">JWT Claims Validation Error Hierarchy</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Provides security-appropriate error classification without information leakage</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> JWTValidationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base exception for all JWT validation failures\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, claim_name: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.claim_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> claim_name</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.timestamp </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> datetime.utcnow()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TemporalValidationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTValidationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when time-based claims fail validation\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TokenExpiredError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">TemporalValidationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when token has expired (exp claim validation failure)\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"Token has expired\"</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, </span><span style=\"color:#FFAB70\">claim_name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"exp\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TokenNotYetValidError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">TemporalValidationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when token is not yet valid (nbf claim validation failure)\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"Token is not yet valid\"</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, </span><span style=\"color:#FFAB70\">claim_name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"nbf\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> IdentityValidationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTValidationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when identity claims fail validation\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InvalidIssuerError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">IdentityValidationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when issuer is not in allowed list\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"Token issuer is not trusted\"</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, </span><span style=\"color:#FFAB70\">claim_name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"iss\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InvalidAudienceError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">IdentityValidationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when audience doesn't match expected value\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"Token audience mismatch\"</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, </span><span style=\"color:#FFAB70\">claim_name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"aud\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CustomClaimValidationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTValidationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when custom claims fail validation\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, claim_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Custom claim validation failed: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">message</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, claim_name)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MissingRequiredClaimError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTValidationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when a required claim is missing from the token\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, claim_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Required claim is missing\"</span><span style=\"color:#E1E4E8\">, claim_name)</span></span></code></pre></div>\n\n<p><strong>validation_context.py</strong> - Complete validation configuration management:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">JWT Validation Context Configuration</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Immutable configuration objects for claims validation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Dict, Any, Callable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> timedelta</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Default configuration constants</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">DEFAULT_LEEWAY_SECONDS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 300</span><span style=\"color:#6A737D\">  # 5 minutes</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">DEFAULT_MAX_TOKEN_AGE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 86400</span><span style=\"color:#6A737D\">  # 24 hours</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ValidationContext</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Immutable validation configuration for JWT claims checking\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Time-based validation settings</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    verify_expiration: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    verify_not_before: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leeway_seconds: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> DEFAULT_LEEWAY_SECONDS</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_token_age_seconds: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> DEFAULT_MAX_TOKEN_AGE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    require_iat: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Identity validation settings</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    allowed_issuers: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    require_issuer: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expected_audience: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    require_audience: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Custom claims validation settings</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    required_claims: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    custom_validators: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Callable[[Any], </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __post_init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate configuration after creation\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.leeway_seconds </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Leeway seconds cannot be negative\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.leeway_seconds </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 3600</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#6A737D\"># 1 hour</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Leeway seconds should not exceed 3600 (1 hour)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.max_token_age_seconds </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Max token age must be positive\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_strict_context</span><span style=\"color:#E1E4E8\">(allowed_issuers: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], expected_audience: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> ValidationContext:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create a strict validation context with minimal leeway and all checks enabled\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ValidationContext(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        verify_expiration</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        verify_not_before</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        leeway_seconds</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">60</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\"># 1 minute only</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        require_issuer</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        allowed_issuers</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">allowed_issuers,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        require_audience</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        expected_audience</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">expected_audience,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        require_iat</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_permissive_context</span><span style=\"color:#E1E4E8\">() -> ValidationContext:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create a permissive validation context for development/testing\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ValidationContext(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        verify_expiration</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        verify_not_before</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        leeway_seconds</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">600</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\"># 10 minutes</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        require_issuer</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        allowed_issuers</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">[],</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        require_audience</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        expected_audience</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        require_iat</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_custom_context</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs) -> ValidationContext:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create a custom validation context with specified parameters\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ValidationContext(</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>claims_validator.py</strong> - Main validation orchestration logic:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">JWT Claims Validator - Main Validation Logic</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Orchestrates all claims validation including time, identity, and custom claims</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .validation_context </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ValidationContext</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .validation_errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#F97583\"> *</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .time_validation </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> TimeValidator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .identity_validation </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> IdentityValidator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .custom_claims </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> CustomClaimsValidator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..core.data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> JWTPayload</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ClaimsValidator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Main claims validation orchestrator\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, context: ValidationContext):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> context</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.time_validator </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> TimeValidator(context)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.identity_validator </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> IdentityValidator(context)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.custom_claims_validator </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CustomClaimsValidator(context)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_claims</span><span style=\"color:#E1E4E8\">(self, payload_dict: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> JWTPayload:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Validate all claims in a JWT payload and return structured payload object.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            payload_dict: Parsed JSON payload from JWT token</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            JWTPayload object with validated claims</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            JWTValidationError: If any validation check fails</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger.info(</span><span style=\"color:#9ECBFF\">\"Starting claims validation\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">extra</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"payload_keys\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">(payload_dict.keys())})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate temporal claims (exp, nbf, iat) using time_validator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Extract time-based claims from payload_dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Call time_validator.validate_temporal_claims()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Handle TemporalValidationError exceptions with appropriate logging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Validate identity claims (iss, aud, sub) using identity_validator  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Extract identity claims from payload_dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Call identity_validator.validate_identity_claims()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Handle IdentityValidationError exceptions with appropriate logging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate custom claims using custom_claims_validator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Extract all non-standard claims from payload_dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Call custom_claims_validator.validate_custom_claims()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Handle CustomClaimValidationError exceptions with appropriate logging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Construct and return JWTPayload object</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Create JWTPayload with validated standard claims</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Include custom_claims dictionary with validated custom data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Log successful validation completion</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _extract_standard_claims</span><span style=\"color:#E1E4E8\">(self, payload_dict: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Extract standard JWT claims from payload dictionary\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Extract iss, sub, aud, exp, nbf, iat, jti claims</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Handle missing claims according to context requirements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Return dictionary with standard claims only</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _extract_custom_claims</span><span style=\"color:#E1E4E8\">(self, payload_dict: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Extract custom claims by filtering out standard claim names\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create new dictionary excluding standard JWT claim names</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Return only application-specific custom claims</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>time_validation.py</strong> - Temporal claims validation logic:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Time-Based Claims Validation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Handles exp, nbf, and iat claim validation with clock skew tolerance</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timezone</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .validation_context </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ValidationContext</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .validation_errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> TokenExpiredError, TokenNotYetValidError, TemporalValidationError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TimeValidator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validates time-based JWT claims with clock skew tolerance\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, context: ValidationContext):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> context</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_temporal_claims</span><span style=\"color:#E1E4E8\">(self, payload_dict: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Validate all temporal claims in the payload.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            payload_dict: JWT payload containing potential time claims</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            TemporalValidationError: If any time validation fails</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current_timestamp </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._get_current_timestamp()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate expiration claim if present and verification enabled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Extract 'exp' claim from payload_dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Check if context.verify_expiration is True</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Call _validate_expiration() with current time and claim value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Log validation results</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Validate not-before claim if present and verification enabled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Extract 'nbf' claim from payload_dict  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Check if context.verify_not_before is True</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Call _validate_not_before() with current time and claim value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Log validation results</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate issued-at claim if present and required</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Extract 'iat' claim from payload_dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Check if context.require_iat is True or claim is present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Call _validate_issued_at() with current time and claim value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Log validation results</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _validate_expiration</span><span style=\"color:#E1E4E8\">(self, current_time: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, exp_claim: Any) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate expiration claim against current time with leeway\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate exp_claim is an integer timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Apply leeway period to current time for comparison</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check if token has expired: current_time > (exp + leeway)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Raise TokenExpiredError if validation fails</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Log successful expiration validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _validate_not_before</span><span style=\"color:#E1E4E8\">(self, current_time: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, nbf_claim: Any) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate not-before claim against current time with leeway\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate nbf_claim is an integer timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Apply leeway period to current time for comparison  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check if token is not yet valid: current_time &#x3C; (nbf - leeway)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Raise TokenNotYetValidError if validation fails</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Log successful not-before validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _validate_issued_at</span><span style=\"color:#E1E4E8\">(self, current_time: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, iat_claim: Any) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate issued-at claim for reasonable time bounds\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate iat_claim is an integer timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check if issued-at is unreasonably far in the past</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check if issued-at is in the future (beyond leeway)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Warn about suspicious timestamps but don't reject</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Log issued-at validation results</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _get_current_timestamp</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get current UTC time as Unix timestamp\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">(time.time())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _validate_timestamp_type</span><span style=\"color:#E1E4E8\">(self, claim_value: Any, claim_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate that a claim value is a valid Unix timestamp\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check if claim_value is numeric (int or float)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Convert to integer if necessary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate timestamp is within reasonable bounds (not negative, not too far in future)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Raise TemporalValidationError for invalid timestamps</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return validated integer timestamp</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>identity_validation.py</strong> - Issuer and audience validation logic:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Identity Claims Validation  </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Handles iss, aud, and sub claim validation against configured allowlists</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, List, Union</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .validation_context </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ValidationContext</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .validation_errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> InvalidIssuerError, InvalidAudienceError, IdentityValidationError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> IdentityValidator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validates identity-related JWT claims\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, context: ValidationContext):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> context</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_identity_claims</span><span style=\"color:#E1E4E8\">(self, payload_dict: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Validate identity claims (issuer, audience, subject).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            payload_dict: JWT payload containing identity claims</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            IdentityValidationError: If any identity validation fails</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate issuer claim if required or present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Extract 'iss' claim from payload_dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Check context.require_issuer flag</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Call _validate_issuer() if validation needed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Log validation results</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Validate audience claim if required or present  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Extract 'aud' claim from payload_dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Check context.require_audience flag</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Call _validate_audience() if validation needed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Log validation results</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate subject claim if present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Extract 'sub' claim from payload_dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Apply any configured subject validation rules</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Log validation results</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _validate_issuer</span><span style=\"color:#E1E4E8\">(self, iss_claim: Any) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate issuer against allowed issuers list\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate iss_claim is a string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check if context.allowed_issuers is configured</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Perform exact string matching against allowed_issuers list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Raise InvalidIssuerError if issuer not in allowlist</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Log successful issuer validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _validate_audience</span><span style=\"color:#E1E4E8\">(self, aud_claim: Any) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate audience claim (string or array) against expected audience\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Determine if aud_claim is string or array</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Handle string audience: exact match with context.expected_audience</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle array audience: check if expected_audience in array</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Raise InvalidAudienceError if no audience matches</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Log successful audience validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _validate_audience_string</span><span style=\"color:#E1E4E8\">(self, audience: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate single audience string against expected value\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Compare audience exactly with context.expected_audience</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return True if match, False otherwise</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _validate_audience_array</span><span style=\"color:#E1E4E8\">(self, audiences: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate audience array contains expected audience\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Iterate through audience array</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check each audience string against expected_audience</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return True if any audience matches</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return False if no audiences match</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the claims validation component, verify the following behavior:</p>\n<p><strong>Test Command</strong>: Run the validation test suite</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_validation/</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n\n<p><strong>Expected Results</strong>:</p>\n<ul>\n<li>All temporal validation tests pass with various exp/nbf/iat combinations</li>\n<li>Issuer validation correctly accepts/rejects based on allowlist configuration  </li>\n<li>Audience validation handles both string and array formats correctly</li>\n<li>Custom claims validation applies configured rules appropriately</li>\n<li>Clock skew handling works within configured leeway periods</li>\n</ul>\n<p><strong>Manual Verification</strong>: Create a test script that validates tokens with different claim combinations:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test temporal validation with expired token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> create_strict_context([</span><span style=\"color:#9ECBFF\">\"trusted-issuer\"</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#9ECBFF\">\"my-service\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">validator </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ClaimsValidator(context)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># This should raise TokenExpiredError</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">expired_payload </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">\"exp\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">(time.time()) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 3600</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"iss\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"trusted-issuer\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"aud\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"my-service\"</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    validator.validate_claims(expired_payload)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ERROR: Should have rejected expired token\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">except</span><span style=\"color:#E1E4E8\"> TokenExpiredError:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SUCCESS: Correctly rejected expired token\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>Signs of Problems</strong>:</p>\n<ul>\n<li>Tokens with valid exp times are rejected → Check clock skew handling</li>\n<li>Invalid issuers are accepted → Check allowlist configuration and string matching</li>\n<li>Array audiences fail validation → Check audience array handling logic</li>\n<li>Custom claims validation errors → Check claim extraction and type validation</li>\n</ul>\n<h2 id=\"component-interactions-and-data-flow\">Component Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All three milestones - demonstrates how token encoding (Milestone 1), HMAC signing (Milestone 2), and claims validation (Milestone 3) work together in complete token creation and verification workflows</p>\n</blockquote>\n<p>The JWT library&#39;s three main components—Token Encoding, Cryptographic Signing, and Claims Validation—operate as an orchestrated system where data flows through carefully designed interfaces to ensure both security and correctness. Understanding how these components interact is crucial for implementing a robust JWT library that properly handles the complete lifecycle of token creation and verification.</p>\n<h3 id=\"mental-model-the-document-authentication-office\">Mental Model: The Document Authentication Office</h3>\n<p>Think of JWT token processing like a government document authentication office with three specialized departments working in sequence. The <strong>Preparation Department</strong> (Token Encoding) formats documents into standardized forms with proper headers and content sections, ensuring everything follows official formatting rules. The <strong>Seal Department</strong> (Cryptographic Signing) applies tamper-evident seals using specialized equipment and secret stamps that prove the document&#39;s authenticity. Finally, the <strong>Verification Department</strong> (Claims Validation) inspects incoming documents, checking seals for authenticity, verifying expiration dates, confirming the issuing authority is authorized, and ensuring the document is intended for the right recipient.</p>\n<p>Just as these departments must coordinate carefully—with documents flowing in a specific order and each department trusting that previous departments completed their work correctly—our JWT components must interact through well-defined interfaces with clear error handling and data transformation contracts.</p>\n<p><img src=\"/api/project/jwt-impl/architecture-doc/asset?path=diagrams%2Fcomponent-architecture.svg\" alt=\"JWT Library Component Architecture\"></p>\n<p>The architecture establishes clear separation of concerns where each component has distinct responsibilities while maintaining loose coupling through standardized data structures. The Token Encoding Component transforms structured data into standardized JWT format, the Cryptographic Signing Component adds and verifies cryptographic authenticity proofs, and the Claims Validation Component enforces business logic and security policies.</p>\n<h3 id=\"token-creation-sequence\">Token Creation Sequence</h3>\n<p>The token creation process follows a carefully orchestrated sequence where data flows through multiple transformation stages, with each component adding its specialized processing while maintaining the integrity of previous work.</p>\n<p><img src=\"/api/project/jwt-impl/architecture-doc/asset?path=diagrams%2Ftoken-creation-sequence.svg\" alt=\"Token Creation Sequence\"></p>\n<p>The token creation workflow begins when the application provides header metadata and payload claims, then progresses through encoding, signing, and assembly phases to produce a complete JWT token ready for transmission.</p>\n<h4 id=\"step-by-step-creation-process\">Step-by-Step Creation Process</h4>\n<p>The token creation sequence follows these detailed steps, with each stage building upon the previous stage&#39;s output:</p>\n<ol>\n<li><p><strong>Input Validation and Preparation</strong>: The <code>create_token</code> function receives a <code>JWTHeader</code> containing algorithm and type specifications, a <code>JWTPayload</code> with claims data, and a secret key for signing. The function first validates that required header fields (<code>alg</code> and <code>typ</code>) are present and that the algorithm matches the intended signer capability.</p>\n</li>\n<li><p><strong>Header Serialization</strong>: The <code>serialize_header</code> function converts the <code>JWTHeader</code> structure into canonical JSON format, ensuring consistent field ordering and proper escaping of special characters. The JSON serialization must be deterministic to ensure identical headers produce identical signatures across different library instances.</p>\n</li>\n<li><p><strong>Payload Serialization</strong>: The <code>serialize_payload</code> function transforms the <code>JWTPayload</code> into JSON format, handling both registered claims (iss, sub, aud, exp, nbf, iat, jti) and custom claims from the <code>custom_claims</code> dictionary. Special attention is paid to numeric timestamp formatting and array handling for audience claims that may contain multiple values.</p>\n</li>\n<li><p><strong>Base64URL Encoding</strong>: The <code>encode_token_parts</code> function applies Base64URL encoding to both serialized JSON strings, converting them to URL-safe representations without padding characters. This encoding must handle Unicode characters properly and ensure the output contains only characters valid in URLs and HTTP headers.</p>\n</li>\n<li><p><strong>Signing Input Creation</strong>: The <code>create_signing_input</code> function concatenates the encoded header and payload with a dot separator, creating the exact string that will be cryptographically signed. This signing input represents the immutable content that the signature will protect against tampering.</p>\n</li>\n<li><p><strong>Signature Generation</strong>: The HMAC signing component&#39;s <code>sign</code> function computes the HMAC-SHA256 signature over the signing input using the provided secret key. The raw signature bytes are then Base64URL encoded to create the final signature segment.</p>\n</li>\n<li><p><strong>Token Assembly</strong>: The <code>assemble_token</code> function combines the encoded header, encoded payload, and encoded signature with dot separators to create the final JWT token in the standard three-part format: <code>header.payload.signature</code>.</p>\n</li>\n<li><p><strong>Final Validation</strong>: Before returning the token, the creation process performs a self-verification step by parsing and validating the just-created token to ensure the creation process worked correctly and the token is well-formed.</p>\n</li>\n</ol>\n<p>The following table details the data transformations at each stage:</p>\n<table>\n<thead>\n<tr>\n<th>Stage</th>\n<th>Input Type</th>\n<th>Output Type</th>\n<th>Transformation</th>\n<th>Error Conditions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Input Validation</td>\n<td><code>JWTHeader</code>, <code>JWTPayload</code>, <code>bytes</code></td>\n<td>Validated inputs</td>\n<td>Structure validation, key strength check</td>\n<td>Missing required fields, weak keys</td>\n</tr>\n<tr>\n<td>Header Serialization</td>\n<td><code>JWTHeader</code></td>\n<td><code>str</code> (JSON)</td>\n<td>Object to canonical JSON</td>\n<td>JSON encoding errors, invalid characters</td>\n</tr>\n<tr>\n<td>Payload Serialization</td>\n<td><code>JWTPayload</code></td>\n<td><code>str</code> (JSON)</td>\n<td>Object to canonical JSON with timestamp handling</td>\n<td>Invalid timestamps, encoding errors</td>\n</tr>\n<tr>\n<td>Base64URL Encoding</td>\n<td><code>str</code> (JSON)</td>\n<td><code>str</code> (Base64URL)</td>\n<td>UTF-8 bytes to URL-safe Base64</td>\n<td>Character encoding errors</td>\n</tr>\n<tr>\n<td>Signing Input Creation</td>\n<td><code>str</code>, <code>str</code></td>\n<td><code>str</code></td>\n<td>Concatenation with dot separator</td>\n<td>String handling errors</td>\n</tr>\n<tr>\n<td>Signature Generation</td>\n<td><code>str</code>, <code>bytes</code></td>\n<td><code>str</code> (Base64URL)</td>\n<td>HMAC-SHA256 computation and encoding</td>\n<td>Key errors, cryptographic failures</td>\n</tr>\n<tr>\n<td>Token Assembly</td>\n<td><code>str</code>, <code>str</code>, <code>str</code></td>\n<td><code>str</code></td>\n<td>Three-part concatenation</td>\n<td>String manipulation errors</td>\n</tr>\n<tr>\n<td>Final Validation</td>\n<td><code>str</code></td>\n<td><code>str</code></td>\n<td>Parse and verify created token</td>\n<td>Self-verification failures</td>\n</tr>\n</tbody></table>\n<h4 id=\"error-propagation-in-token-creation\">Error Propagation in Token Creation</h4>\n<p>Error handling during token creation follows a fail-fast principle where any component failure immediately terminates the creation process and propagates a descriptive error to the caller. Each component validates its inputs and provides specific error messages that help developers diagnose problems quickly.</p>\n<p>The Token Encoding Component raises encoding-specific exceptions when JSON serialization fails or Base64URL encoding encounters invalid characters. The Cryptographic Signing Component raises key-related exceptions for insufficient key strength or HMAC computation failures. The overall creation process wraps these component-specific errors in a general token creation error that preserves the underlying cause while providing context about which creation stage failed.</p>\n<blockquote>\n<p><strong>Design Insight</strong>: The token creation sequence is designed to be atomic—either a complete, valid token is produced, or the operation fails entirely with no partial state. This prevents the library from returning malformed tokens that could cause security issues or interoperability problems with other JWT implementations.</p>\n</blockquote>\n<h3 id=\"token-verification-sequence\">Token Verification Sequence</h3>\n<p>Token verification represents a more complex workflow than creation because it must handle potentially malicious input while performing comprehensive validation across multiple security dimensions. The verification process assumes the input token is untrusted and validates every aspect before returning payload data to the application.</p>\n<p><img src=\"/api/project/jwt-impl/architecture-doc/asset?path=diagrams%2Ftoken-verification-sequence.svg\" alt=\"Token Verification Sequence\"></p>\n<p>The verification workflow begins with token parsing and structural validation, then proceeds through cryptographic verification and comprehensive claims validation before returning the validated payload to the application.</p>\n<h4 id=\"step-by-step-verification-process\">Step-by-Step Verification Process</h4>\n<p>The token verification sequence implements defense-in-depth validation with these detailed steps:</p>\n<ol>\n<li><p><strong>Token Structure Parsing</strong>: The <code>verify_token</code> function receives a token string and immediately validates its basic structure by splitting on dot separators and ensuring exactly three parts are present. Malformed tokens with incorrect part counts are rejected immediately without further processing.</p>\n</li>\n<li><p><strong>Base64URL Decoding</strong>: Each token part undergoes Base64URL decoding with proper padding restoration. The decoding process validates that each part contains only valid Base64URL characters and handles padding edge cases correctly. Invalid encoding triggers immediate rejection.</p>\n</li>\n<li><p><strong>JSON Deserialization</strong>: The decoded header and payload undergo JSON parsing with strict validation. The header must contain valid <code>alg</code> and <code>typ</code> fields with expected values. The payload is parsed into a dictionary structure for subsequent claims validation.</p>\n</li>\n<li><p><strong>Algorithm Verification</strong>: The parsed header&#39;s algorithm field is validated against the expected algorithm (HS256) to prevent algorithm confusion attacks where attackers attempt to trick the verifier into using a different cryptographic algorithm with known weaknesses.</p>\n</li>\n<li><p><strong>Signature Verification</strong>: The cryptographic signing component reconstructs the signing input from the parsed header and payload, then verifies the provided signature using constant-time comparison. Signature verification failure results in immediate token rejection.</p>\n</li>\n<li><p><strong>Temporal Claims Validation</strong>: The claims validation component checks time-based claims (exp, nbf, iat) against the current time with configurable leeway for clock skew. Expired tokens or tokens not yet valid are rejected with specific error messages indicating the temporal validation failure.</p>\n</li>\n<li><p><strong>Identity Claims Validation</strong>: The issuer (iss) and audience (aud) claims are validated against the configured validation context. The issuer must appear in the allowed issuers list, and the audience must match the expected audience identifier. Missing required identity claims trigger validation failures.</p>\n</li>\n<li><p><strong>Custom Claims Processing</strong>: Application-specific claims undergo validation according to the validation context configuration. Required custom claims are checked for presence, and custom validation logic can be applied to verify claim values meet application requirements.</p>\n</li>\n<li><p><strong>Payload Construction and Return</strong>: After all validation passes, the verification process constructs a validated <code>JWTPayload</code> object containing all claims and returns it to the application. The returned payload represents trusted, verified data that the application can use for authorization decisions.</p>\n</li>\n</ol>\n<p>The verification process uses strict validation by default but allows customization through the <code>ValidationContext</code> parameter:</p>\n<table>\n<thead>\n<tr>\n<th>Validation Type</th>\n<th>Default Behavior</th>\n<th>Customizable Aspects</th>\n<th>Security Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Signature Verification</td>\n<td>Always enabled</td>\n<td>Cannot be disabled</td>\n<td>Critical - prevents token tampering</td>\n</tr>\n<tr>\n<td>Expiration Check</td>\n<td>Enabled with 5min leeway</td>\n<td>Leeway duration, enable/disable</td>\n<td>High - prevents replay of old tokens</td>\n</tr>\n<tr>\n<td>Not-Before Check</td>\n<td>Enabled with same leeway</td>\n<td>Leeway duration, enable/disable</td>\n<td>Medium - prevents premature token use</td>\n</tr>\n<tr>\n<td>Issuer Validation</td>\n<td>Strict allowlist checking</td>\n<td>Allowed issuers list, required flag</td>\n<td>High - prevents token forgery</td>\n</tr>\n<tr>\n<td>Audience Validation</td>\n<td>Exact match required</td>\n<td>Expected audience, required flag</td>\n<td>Medium - prevents token misuse</td>\n</tr>\n<tr>\n<td>Custom Claims</td>\n<td>Application-defined</td>\n<td>Required claims list, custom validators</td>\n<td>Variable - depends on application needs</td>\n</tr>\n</tbody></table>\n<h4 id=\"validation-context-configuration\">Validation Context Configuration</h4>\n<p>The <code>ValidationContext</code> provides flexible control over verification strictness while maintaining security defaults. Applications can create contexts optimized for their specific security requirements:</p>\n<p><strong>Strict Validation Context</strong>: Used in production environments where security is paramount. All validations are enabled with minimal leeway periods, strict issuer allowlists, and required audience checking.</p>\n<p><strong>Development Validation Context</strong>: Provides relaxed validation for testing environments with extended leeway periods and optional claims validation, while still maintaining signature verification for basic security.</p>\n<p><strong>Custom Validation Context</strong>: Allows fine-grained control over each validation aspect, enabling applications to implement domain-specific security policies while leveraging the library&#39;s validation infrastructure.</p>\n<blockquote>\n<p><strong>Security Principle</strong>: The verification sequence implements a &quot;fail-secure&quot; design where any validation failure results in complete token rejection. There are no warnings or partial validation states—tokens are either fully valid and trusted or completely rejected.</p>\n</blockquote>\n<h3 id=\"error-handling-flow\">Error Handling Flow</h3>\n<p>Error handling in the JWT library follows a structured approach where errors are classified by type, carry sufficient context for debugging, and flow through the component hierarchy in a predictable manner. The error handling system balances security concerns (avoiding information leakage to attackers) with developer usability (providing actionable diagnostic information).</p>\n<h4 id=\"error-classification-and-hierarchy\">Error Classification and Hierarchy</h4>\n<p>The library defines a comprehensive error hierarchy that enables precise error handling while maintaining clear separation between different failure modes:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>JWTValidationError (base class)\n├── StructuralError (token format problems)\n│   ├── MalformedTokenError (invalid token structure)\n│   ├── EncodingError (Base64URL/JSON encoding issues)\n│   └── AlgorithmMismatchError (algorithm confusion prevention)\n├── CryptographicError (signature and key issues)\n│   ├── SignatureVerificationError (signature validation failures)\n│   ├── WeakKeyError (insufficient key strength)\n│   └── KeyHandlingError (key format or access problems)\n├── TemporalValidationError (time-based validation failures)\n│   ├── TokenExpiredError (exp claim validation)\n│   ├── TokenNotYetValidError (nbf claim validation)\n│   └── InvalidIssuedAtError (iat claim validation)\n├── IdentityValidationError (issuer and audience problems)\n│   ├── InvalidIssuerError (iss claim validation)\n│   ├── InvalidAudienceError (aud claim validation)\n│   └── UnauthorizedIssuerError (issuer not in allowlist)\n└── CustomClaimValidationError (application-specific failures)\n    ├── MissingRequiredClaimError (required claims absent)\n    ├── InvalidClaimValueError (claim value validation)\n    └── ClaimTypeError (unexpected claim data types)</code></pre></div>\n\n<p>Each error class carries specific context information relevant to its failure mode while inheriting common fields from the base <code>JWTValidationError</code> class.</p>\n<h4 id=\"error-context-and-information-flow\">Error Context and Information Flow</h4>\n<p>Errors flow through the component hierarchy with increasing context as they move from low-level components to the public API. Each component adds relevant diagnostic information while preserving the original error cause:</p>\n<table>\n<thead>\n<tr>\n<th>Error Source</th>\n<th>Context Added</th>\n<th>Information Included</th>\n<th>Security Considerations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Token Encoding</td>\n<td>Structural validation context</td>\n<td>Token part that failed, encoding stage</td>\n<td>Safe - no sensitive data exposure</td>\n</tr>\n<tr>\n<td>Cryptographic Signing</td>\n<td>Signature verification details</td>\n<td>Algorithm used, key validation status</td>\n<td>Careful - avoid key material leakage</td>\n</tr>\n<tr>\n<td>Claims Validation</td>\n<td>Claim-specific validation context</td>\n<td>Claim name, expected vs actual values</td>\n<td>Moderate - balance debugging vs info leakage</td>\n</tr>\n<tr>\n<td>Public API</td>\n<td>Operation context</td>\n<td>Function called, validation context used</td>\n<td>Safe - high-level operation information</td>\n</tr>\n</tbody></table>\n<p>The error handling system implements different information disclosure levels based on the deployment context:</p>\n<p><strong>Development Mode</strong>: Provides detailed error messages including actual claim values, expected values, and specific validation failures. This mode helps developers debug integration issues quickly but should never be used in production.</p>\n<p><strong>Production Mode</strong>: Provides general error categories without exposing sensitive details that could help attackers. Error messages indicate the type of validation failure without revealing specific claim values or validation logic details.</p>\n<p><strong>Audit Mode</strong>: Logs detailed error information to secure audit logs while returning generic error messages to callers. This provides forensic capabilities for security teams while protecting against information disclosure.</p>\n<h4 id=\"component-error-handling-patterns\">Component Error Handling Patterns</h4>\n<p>Each component implements consistent error handling patterns that ensure predictable behavior across the library:</p>\n<p><strong>Token Encoding Component</strong>: Validates input structure and encoding constraints, raising <code>StructuralError</code> subclasses for format violations. Encoding errors include sufficient context to identify the problematic data without exposing sensitive payload contents.</p>\n<p><strong>Cryptographic Signing Component</strong>: Implements secure error handling that avoids timing side channels and information leakage about key material. All signature verification failures result in the same generic <code>SignatureVerificationError</code> regardless of the specific failure mode.</p>\n<p><strong>Claims Validation Component</strong>: Provides detailed validation context while respecting security boundaries. Temporal validation errors include information about which time-based claim failed and the general nature of the violation (expired vs not-yet-valid) without exposing exact timestamps that might reveal clock information.</p>\n<h4 id=\"error-recovery-and-fallback-strategies\">Error Recovery and Fallback Strategies</h4>\n<p>The JWT library implements limited error recovery focused on handling common edge cases without compromising security:</p>\n<p><strong>Clock Skew Tolerance</strong>: Temporal validation includes configurable leeway periods that automatically handle reasonable clock differences between token issuers and verifiers. This prevents legitimate tokens from being rejected due to minor time synchronization issues.</p>\n<p><strong>Encoding Robustness</strong>: Base64URL decoding includes automatic padding restoration to handle tokens that may have been truncated or modified during transmission through systems that don&#39;t properly handle URL-safe encoding.</p>\n<p><strong>Graceful Degradation</strong>: When optional validation features fail (such as custom claim validation), the library continues with core security validation while logging the optional validation failure. This prevents auxiliary validation logic from breaking core authentication functionality.</p>\n<blockquote>\n<p><strong>Security Boundary</strong>: Error handling never attempts to &quot;fix&quot; security-critical validation failures. Signature verification failures, algorithm mismatches, and expired tokens always result in complete rejection with no recovery attempts, as any &quot;fix&quot; would compromise the fundamental security guarantees JWT provides.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The component interactions require careful orchestration to ensure data flows correctly between encoding, signing, and validation while maintaining security properties and error handling consistency.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component Integration</th>\n<th>Simple Approach</th>\n<th>Advanced Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Error Handling</td>\n<td>Custom exception hierarchy with string messages</td>\n<td>Structured error objects with error codes and context data</td>\n</tr>\n<tr>\n<td>State Management</td>\n<td>Stateless functions with parameter passing</td>\n<td>Context objects that carry state through the pipeline</td>\n</tr>\n<tr>\n<td>Logging Integration</td>\n<td>Print statements for debugging</td>\n<td>Structured logging with security-aware log levels</td>\n</tr>\n<tr>\n<td>Performance Monitoring</td>\n<td>Simple timing measurements</td>\n<td>Comprehensive metrics with component-level breakdowns</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-module-structure\">Recommended Module Structure</h4>\n<p>The component interactions are best organized with a facade pattern that provides simple public interfaces while managing complex component coordination internally:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>jwt_library/\n├── core/\n│   ├── __init__.py              ← Public API facade\n│   ├── token_manager.py         ← High-level token operations\n│   └── validation_context.py    ← Validation configuration\n├── encoding/\n│   ├── encoder.py               ← Token encoding component\n│   └── base64url.py             ← Base64URL utilities\n├── signing/\n│   ├── hmac_signer.py           ← HMAC-SHA256 implementation\n│   └── key_handler.py           ← Secret key management\n├── validation/\n│   ├── claims_validator.py      ← Main validation orchestrator\n│   ├── temporal_validator.py    ← Time-based claim validation\n│   └── identity_validator.py    ← Issuer and audience validation\n└── errors/\n    ├── __init__.py              ← Error hierarchy exports\n    ├── base_errors.py           ← Base error classes\n    ├── validation_errors.py     ← Validation-specific errors\n    └── error_context.py         ← Error context utilities</code></pre></div>\n\n<h4 id=\"complete-token-manager-implementation\">Complete Token Manager Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">High-level token management facade that coordinates component interactions.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">This module provides the main public API for token creation and verification.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timezone</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional, List, Union</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> secrets</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .encoding.encoder </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> TokenEncoder</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .encoding.base64url </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> base64url_encode, base64url_decode</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .signing.hmac_signer </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> HMACSignerHS256</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .signing.key_handler </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> SecureKeyHandler</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .validation.claims_validator </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ClaimsValidator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .validation_context </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ValidationContext</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> JWTValidationError, StructuralError, MalformedTokenError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Standard JWT constants</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">HS256</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"HS256\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">JWT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"JWT\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">DEFAULT_LEEWAY_SECONDS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 300</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">MIN_KEY_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 32</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> JWTTokenManager</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    High-level facade for JWT token operations that coordinates between</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    encoding, signing, and validation components.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, secret_key: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.key_handler </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> SecureKeyHandler()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.key_handler.validate_key_strength(secret_key)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._secret_key </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> secret_key</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.encoder </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> TokenEncoder()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.signer </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> HMACSignerHS256(secret_key)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.validator </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ClaimsValidator()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create_token</span><span style=\"color:#E1E4E8\">(self, header: </span><span style=\"color:#9ECBFF\">'JWTHeader'</span><span style=\"color:#E1E4E8\">, payload: </span><span style=\"color:#9ECBFF\">'JWTPayload'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Create a signed JWT token from header and payload components.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Coordinates the complete token creation workflow.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate header contains required alg and typ fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Ensure algorithm matches signer capability (HS256)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Serialize header and payload to canonical JSON</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Apply Base64URL encoding to both JSON strings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create signing input by concatenating encoded parts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Generate HMAC-SHA256 signature over signing input</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assemble final token in header.payload.signature format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Perform self-verification to ensure token is well-formed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> verify_token</span><span style=\"color:#E1E4E8\">(self, token: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, context: ValidationContext) -> </span><span style=\"color:#9ECBFF\">'JWTPayload'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Verify a JWT token and return validated payload if all checks pass.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Implements comprehensive validation with configurable strictness.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Parse token structure and validate three-part format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Decode each part from Base64URL with padding restoration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Deserialize header and payload JSON with error handling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify algorithm matches expected value (prevent confusion attacks)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify signature using constant-time comparison</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate temporal claims (exp, nbf, iat) with leeway</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate identity claims (iss, aud) against context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Process custom claims according to validation rules</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Construct and return validated JWTPayload object</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_token</span><span style=\"color:#E1E4E8\">(header: </span><span style=\"color:#9ECBFF\">'JWTHeader'</span><span style=\"color:#E1E4E8\">, payload: </span><span style=\"color:#9ECBFF\">'JWTPayload'</span><span style=\"color:#E1E4E8\">, secret_key: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Convenience function for creating tokens without managing a TokenManager instance.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    manager </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> JWTTokenManager(secret_key)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> manager.create_token(header, payload)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> verify_token</span><span style=\"color:#E1E4E8\">(token: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, secret_key: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, context: ValidationContext) -> </span><span style=\"color:#9ECBFF\">'JWTPayload'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Convenience function for verifying tokens without managing a TokenManager instance.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    manager </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> JWTTokenManager(secret_key)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> manager.verify_token(token, context)</span></span></code></pre></div>\n\n<h4 id=\"error-context-infrastructure\">Error Context Infrastructure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Error context management for tracking validation failures across components.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Provides structured error information while respecting security boundaries.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ErrorSeverity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Classification of error severity levels for logging and handling.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CRITICAL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"critical\"</span><span style=\"color:#6A737D\">      # Security violations, signature failures</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    HIGH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"high\"</span><span style=\"color:#6A737D\">              # Expired tokens, invalid issuers</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MEDIUM</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"medium\"</span><span style=\"color:#6A737D\">          # Missing optional claims, format issues</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LOW</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"low\"</span><span style=\"color:#6A737D\">                # Clock skew warnings, encoding edge cases</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SecurityContext</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Deployment context that determines error information disclosure.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DEVELOPMENT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"development\"</span><span style=\"color:#6A737D\">  # Full error details for debugging</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PRODUCTION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"production\"</span><span style=\"color:#6A737D\">    # Generic error messages for security</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AUDIT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"audit\"</span><span style=\"color:#6A737D\">              # Detailed logging, generic responses</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ValidationFailureContext</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Structured context for validation failures that provides debugging</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    information while respecting security boundaries.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    component: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">                    # Component that detected the failure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    operation: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">                    # Specific operation that failed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    failure_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">                 # Category of validation failure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    severity: ErrorSeverity           </span><span style=\"color:#6A737D\"># Impact level of the failure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    debug_info: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]        </span><span style=\"color:#6A737D\"># Detailed context for development</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    safe_message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">                 # Production-safe error description</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_message</span><span style=\"color:#E1E4E8\">(self, context: SecurityContext) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return appropriate error message based on security context.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> context </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> SecurityContext.</span><span style=\"color:#79B8FF\">DEVELOPMENT</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.failure_type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.debug_info</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> context </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> SecurityContext.</span><span style=\"color:#79B8FF\">PRODUCTION</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.safe_message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#6A737D\"># AUDIT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Log detailed info, return generic message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.safe_message</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ErrorContextManager</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Manages error context propagation through component interactions.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, security_context: SecurityContext </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> SecurityContext.</span><span style=\"color:#79B8FF\">PRODUCTION</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.security_context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> security_context</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.error_history: List[ValidationFailureContext] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> add_failure</span><span style=\"color:#E1E4E8\">(self, context: ValidationFailureContext):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add a validation failure to the error history.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.error_history.append(context)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create_summary_error</span><span style=\"color:#E1E4E8\">(self, primary_failure: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Create a summary error message that respects security boundaries</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        while providing useful debugging information.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.error_history:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#9ECBFF\"> \"Token validation failed\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        primary </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.error_history[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> primary.get_message(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.security_context)</span></span></code></pre></div>\n\n<h4 id=\"component-integration-helpers\">Component Integration Helpers</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Utility functions for coordinating data flow between JWT components.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Tuple, Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> serialize_header</span><span style=\"color:#E1E4E8\">(header: </span><span style=\"color:#9ECBFF\">'JWTHeader'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Serialize JWT header to canonical JSON format.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Ensures consistent field ordering for signature generation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Convert header object to dictionary with required fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Apply deterministic JSON serialization with sorted keys</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle special characters and Unicode properly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use json.dumps with sort_keys=True and separators=(',', ':')</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> serialize_payload</span><span style=\"color:#E1E4E8\">(payload: </span><span style=\"color:#9ECBFF\">'JWTPayload'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Serialize JWT payload to canonical JSON format.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Handles registered claims and custom claims properly.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Extract registered claims (iss, sub, aud, exp, nbf, iat, jti)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add custom claims from custom_claims dictionary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle audience claim as either string or array</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Ensure timestamp claims are integers (not floats)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Apply deterministic JSON serialization</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> encode_token_parts</span><span style=\"color:#E1E4E8\">(header: </span><span style=\"color:#9ECBFF\">'JWTHeader'</span><span style=\"color:#E1E4E8\">, payload: </span><span style=\"color:#9ECBFF\">'JWTPayload'</span><span style=\"color:#E1E4E8\">) -> Tuple[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Encode header and payload to Base64URL format for token assembly.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    header_json </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> serialize_header(header)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payload_json </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> serialize_payload(payload)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    encoded_header </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> base64url_encode(header_json.encode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    encoded_payload </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> base64url_encode(payload_json.encode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> encoded_header, encoded_payload</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_signing_input</span><span style=\"color:#E1E4E8\">(encoded_header: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, encoded_payload: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Create the signing input string from encoded header and payload.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    This is the exact string that gets cryptographically signed.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">encoded_header</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">encoded_payload</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> assemble_token</span><span style=\"color:#E1E4E8\">(encoded_header: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, encoded_payload: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, signature: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Assemble the final JWT token from all three encoded parts.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">encoded_header</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">encoded_payload</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">signature</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> parse_token_structure</span><span style=\"color:#E1E4E8\">(token: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Tuple[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Parse JWT token structure and return the three parts.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Validates basic structure before returning components.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parts </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> token.split(</span><span style=\"color:#9ECBFF\">'.'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(parts) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> MalformedTokenError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"JWT must have exactly 3 parts, got </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(parts)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    header_part, payload_part, signature_part </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Validate that no parts are empty</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> all</span><span style=\"color:#E1E4E8\">(parts):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> MalformedTokenError(</span><span style=\"color:#9ECBFF\">\"JWT parts cannot be empty\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> header_part, payload_part, signature_part</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After Milestone 1 (JWT Structure)</strong>:\nRun the following test to verify token encoding works correctly:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> jwt_library.core </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> create_token</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> jwt_library.data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> JWTHeader, JWTPayload</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">header </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> JWTHeader(</span><span style=\"color:#FFAB70\">alg</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"HS256\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">typ</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"JWT\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">payload </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> JWTPayload(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    iss</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"test-issuer\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    sub</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"user123\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    aud</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"test-audience\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    exp</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1234567890</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    iat</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1234567800</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">secret_key </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> b</span><span style=\"color:#9ECBFF\">\"test-secret-key-32-bytes-long-123\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">token </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> create_token(header, payload, secret_key)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Created token: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">token</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should see: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJ0ZXN0LWlzc3VlciIsInN1YiI6InVzZXIxMjMiLCJhdWQiOiJ0ZXN0LWF1ZGllbmNlIiwiZXhwIjoxMjM0NTY3ODkwLCJpYXQiOjEyMzQ1Njc4MDB9.signature</span></span></code></pre></div>\n\n<p><strong>After Milestone 2 (HMAC Signing)</strong>:\nVerify signature generation and verification:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Create a token and verify it immediately</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">token </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> create_token(header, payload, secret_key)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ValidationContext(</span><span style=\"color:#FFAB70\">verify_signature</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">verify_expiration</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">verified_payload </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> verify_token(token, secret_key, context)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Verified payload: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">verified_payload.iss</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should print: test-issuer</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test signature tampering detection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">tampered_token </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> token[:</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"XXXXX\"</span><span style=\"color:#6A737D\">  # Corrupt signature</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    verify_token(tampered_token, secret_key, context)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ERROR: Tampered token should have failed!\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">except</span><span style=\"color:#E1E4E8\"> JWTValidationError:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SUCCESS: Tampered token correctly rejected\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>After Milestone 3 (Claims Validation)</strong>:\nTest comprehensive claims validation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timezone</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test expired token rejection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">expired_payload </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> JWTPayload(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    iss</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"test-issuer\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    sub</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"user123\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    aud</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"test-audience\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    exp</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">(datetime(</span><span style=\"color:#79B8FF\">2020</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">tzinfo</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">timezone.utc).timestamp()),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    iat</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">(datetime(</span><span style=\"color:#79B8FF\">2020</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">tzinfo</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">timezone.utc).timestamp())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">expired_token </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> create_token(header, expired_payload, secret_key)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">strict_context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ValidationContext(</span><span style=\"color:#FFAB70\">verify_expiration</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    verify_token(expired_token, secret_key, strict_context)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ERROR: Expired token should have failed!\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">except</span><span style=\"color:#E1E4E8\"> TokenExpiredError:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SUCCESS: Expired token correctly rejected\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"debugging-component-interactions\">Debugging Component Interactions</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis Steps</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Token creation succeeds but verification fails</td>\n<td>Component coordination issue</td>\n<td>Print intermediate values at each stage</td>\n<td>Check that encoding/decoding is symmetric</td>\n</tr>\n<tr>\n<td>Signatures don&#39;t match between creation and verification</td>\n<td>Inconsistent JSON serialization</td>\n<td>Compare signing input strings</td>\n<td>Ensure deterministic JSON with sorted keys</td>\n</tr>\n<tr>\n<td>Claims validation passes individually but fails in integration</td>\n<td>Validation context not passed correctly</td>\n<td>Check ValidationContext propagation</td>\n<td>Verify context parameter threading</td>\n</tr>\n<tr>\n<td>Performance degradation with multiple components</td>\n<td>Inefficient component initialization</td>\n<td>Profile component creation vs usage</td>\n<td>Cache component instances, avoid recreation</td>\n</tr>\n<tr>\n<td>Error messages are unclear about which component failed</td>\n<td>Poor error context propagation</td>\n<td>Add logging at component boundaries</td>\n<td>Implement structured error context with component info</td>\n</tr>\n</tbody></table>\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All three milestones - error handling for JWT structure (Milestone 1), HMAC signing failures (Milestone 2), and claims validation issues (Milestone 3)</p>\n</blockquote>\n<p>Robust error handling represents the difference between a toy JWT library and production-ready authentication infrastructure. While the happy path of token creation and verification appears straightforward, real-world JWT implementations must gracefully handle dozens of failure modes ranging from malformed input to sophisticated timing attacks. This section establishes a comprehensive error handling strategy that maintains security properties while providing actionable diagnostic information to developers.</p>\n<p>The challenge lies in balancing security with usability. Security demands that error messages reveal minimal information to potential attackers - we cannot distinguish between &quot;token expired&quot; and &quot;invalid signature&quot; in ways that enable oracle attacks. Usability demands clear diagnostic information that helps developers identify and fix integration issues quickly. Our error handling design resolves this tension through structured error contexts that provide detailed information in development environments while maintaining secure, generic messages in production deployments.</p>\n<p><img src=\"/api/project/jwt-impl/architecture-doc/asset?path=diagrams%2Fvalidation-state-machine.svg\" alt=\"Token Validation State Machine\"></p>\n<h3 id=\"error-classification\">Error Classification</h3>\n<p>Modern JWT libraries must handle errors across multiple dimensions: structural integrity, cryptographic validity, temporal constraints, and business logic requirements. Each category demands different handling strategies because the underlying failure modes represent fundamentally different security and usability concerns.</p>\n<p>Our error classification system organizes failures into a hierarchy that enables appropriate response strategies while maintaining clear diagnostic boundaries. The classification considers both the technical nature of the failure and the appropriate security response, ensuring that sensitive operations fail securely while providing maximum utility for legitimate debugging scenarios.</p>\n<blockquote>\n<p><strong>Decision: Hierarchical Error Classification</strong></p>\n<ul>\n<li><strong>Context</strong>: JWT validation involves multiple validation stages, each with distinct failure modes and security implications</li>\n<li><strong>Options Considered</strong>: Flat error codes, exception hierarchy, structured error contexts</li>\n<li><strong>Decision</strong>: Implement structured error contexts with severity levels and component attribution</li>\n<li><strong>Rationale</strong>: Enables appropriate security responses while maintaining diagnostic utility across development and production environments</li>\n<li><strong>Consequences</strong>: More complex error handling implementation but significantly better operational visibility and security posture</li>\n</ul>\n</blockquote>\n<p>The error severity system provides clear guidance for application-level response strategies. Critical errors indicate potential security attacks and should trigger additional monitoring or defensive measures. High severity errors represent clear validation failures that should be logged and monitored for patterns. Medium severity errors indicate configuration or integration issues that require attention but pose minimal security risk. Low severity errors represent edge cases or warnings that applications can safely ignore in most scenarios.</p>\n<table>\n<thead>\n<tr>\n<th>Error Category</th>\n<th>Examples</th>\n<th>Security Risk</th>\n<th>Response Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Structural</strong></td>\n<td>Malformed tokens, invalid Base64URL, missing parts</td>\n<td>Medium</td>\n<td>Parse failure, clear diagnostic</td>\n</tr>\n<tr>\n<td><strong>Cryptographic</strong></td>\n<td>Signature mismatch, algorithm confusion, key issues</td>\n<td>Critical</td>\n<td>Silent failure, security logging</td>\n</tr>\n<tr>\n<td><strong>Temporal</strong></td>\n<td>Expiration, not-before, clock skew</td>\n<td>High</td>\n<td>Time-based rejection, leeway handling</td>\n</tr>\n<tr>\n<td><strong>Claims</strong></td>\n<td>Missing required claims, invalid values, audience mismatch</td>\n<td>Medium</td>\n<td>Business logic failure, audit logging</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>Severity Level</th>\n<th>Description</th>\n<th>Example Scenarios</th>\n<th>Recommended Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>CRITICAL</strong></td>\n<td>Potential security attack or compromise</td>\n<td>Signature tampering, algorithm downgrade</td>\n<td>Silent failure, security alerting</td>\n</tr>\n<tr>\n<td><strong>HIGH</strong></td>\n<td>Clear validation failure</td>\n<td>Token expiration, invalid issuer</td>\n<td>Rejection with generic message</td>\n</tr>\n<tr>\n<td><strong>MEDIUM</strong></td>\n<td>Configuration or integration issue</td>\n<td>Missing optional claims, format warnings</td>\n<td>Detailed diagnostic in development</td>\n</tr>\n<tr>\n<td><strong>LOW</strong></td>\n<td>Edge cases or informational</td>\n<td>Clock skew warnings, unused claims</td>\n<td>Logging only, continue processing</td>\n</tr>\n</tbody></table>\n<p>The security context system adapts error handling behavior based on deployment environment. Development contexts provide maximum diagnostic information to accelerate debugging and integration. Production contexts prioritize security by minimizing information disclosure while maintaining sufficient logging for operational visibility. Audit contexts enhance logging and monitoring for compliance-sensitive deployments.</p>\n<table>\n<thead>\n<tr>\n<th>Security Context</th>\n<th>Error Detail Level</th>\n<th>Diagnostic Information</th>\n<th>Logging Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>DEVELOPMENT</strong></td>\n<td>Full diagnostic details</td>\n<td>Stack traces, intermediate values, timing information</td>\n<td>Console output, detailed file logging</td>\n</tr>\n<tr>\n<td><strong>PRODUCTION</strong></td>\n<td>Generic error messages</td>\n<td>Component and operation only</td>\n<td>Structured logging, security alerts</td>\n</tr>\n<tr>\n<td><strong>AUDIT</strong></td>\n<td>Minimal error details</td>\n<td>Sanitized diagnostic context</td>\n<td>Enhanced audit trails, compliance logging</td>\n</tr>\n</tbody></table>\n<h3 id=\"malformed-token-handling\">Malformed Token Handling</h3>\n<p>Malformed tokens represent the first line of defense in JWT validation, catching structural issues before they reach cryptographic or business logic validation. The challenge lies in distinguishing between innocent formatting errors and potential attack payloads while providing useful diagnostic information for legitimate integration scenarios.</p>\n<p>Think of malformed token handling as airport security screening - we need to quickly identify obviously problematic items without creating unnecessary delays for legitimate travelers. Just as security screeners follow standardized procedures to handle suspicious items consistently, our malformed token handler applies systematic validation rules to catch structural problems early in the validation pipeline.</p>\n<p>The token structure validation process follows a fail-fast approach that immediately rejects tokens with obvious structural problems. This approach provides several security benefits: it prevents resource exhaustion attacks that might exploit expensive cryptographic operations, it provides clear diagnostic information for integration issues, and it establishes a clean boundary between structural and semantic validation concerns.</p>\n<table>\n<thead>\n<tr>\n<th>Validation Stage</th>\n<th>Check Description</th>\n<th>Failure Type</th>\n<th>Recovery Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Initial Format</strong></td>\n<td>Contains exactly two dots, three non-empty parts</td>\n<td><code>MalformedTokenError</code></td>\n<td>Immediate rejection with format diagnostic</td>\n</tr>\n<tr>\n<td><strong>Base64URL Validity</strong></td>\n<td>Each part contains valid Base64URL characters</td>\n<td><code>StructuralError</code></td>\n<td>Report invalid characters and position</td>\n</tr>\n<tr>\n<td><strong>JSON Structure</strong></td>\n<td>Header and payload decode to valid JSON objects</td>\n<td><code>StructuralError</code></td>\n<td>Report JSON parsing error with component</td>\n</tr>\n<tr>\n<td><strong>Required Fields</strong></td>\n<td>Header contains <code>alg</code> and <code>typ</code>, payload has structure</td>\n<td><code>MissingRequiredClaimError</code></td>\n<td>List missing required fields</td>\n</tr>\n</tbody></table>\n<p>The Base64URL validation process requires particular attention because standard Base64 libraries often accept invalid padding or non-URL-safe characters without errors. Our validation explicitly checks for URL-safe character sets and proper padding removal, ensuring that tokens conform strictly to the JWT specification.</p>\n<blockquote>\n<p><strong>Decision: Strict Base64URL Validation</strong></p>\n<ul>\n<li><strong>Context</strong>: Standard Base64 libraries may accept malformed padding or non-URL-safe characters</li>\n<li><strong>Options Considered</strong>: Lenient parsing, strict validation, automatic correction</li>\n<li><strong>Decision</strong>: Implement strict validation with clear error reporting for invalid characters</li>\n<li><strong>Rationale</strong>: Prevents subtle interoperability issues and potential security bypasses through encoding manipulation</li>\n<li><strong>Consequences</strong>: More restrictive than some implementations but ensures specification compliance and predictable behavior</li>\n</ul>\n</blockquote>\n<p>JSON structure validation must handle edge cases like deeply nested objects, extremely large payloads, and non-standard number representations. The validation process establishes reasonable limits on JSON complexity while providing clear diagnostic information when these limits are exceeded.</p>\n<table>\n<thead>\n<tr>\n<th>JSON Issue</th>\n<th>Detection Method</th>\n<th>Error Response</th>\n<th>Diagnostic Information</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Invalid Syntax</strong></td>\n<td>JSON parser exception</td>\n<td><code>StructuralError</code> with position</td>\n<td>Line and character position of syntax error</td>\n</tr>\n<tr>\n<td><strong>Oversized Payload</strong></td>\n<td>Length check before parsing</td>\n<td><code>StructuralError</code> with size</td>\n<td>Actual size vs. maximum allowed size</td>\n</tr>\n<tr>\n<td><strong>Type Mismatch</strong></td>\n<td>Field type validation after parsing</td>\n<td><code>StructuralError</code> with field</td>\n<td>Expected vs. actual type for specific field</td>\n</tr>\n<tr>\n<td><strong>Encoding Issues</strong></td>\n<td>UTF-8 validation during parsing</td>\n<td><code>StructuralError</code> with encoding</td>\n<td>Character position and encoding problem</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Accepting Malformed Base64URL</strong>\nMany developers use standard Base64 libraries that silently accept padding characters or non-URL-safe characters in JWT tokens. This creates interoperability issues and potential security bypasses. Always validate that Base64URL input contains only URL-safe characters (A-Z, a-z, 0-9, -, _) with no padding characters (=). Implement explicit character set validation before attempting to decode.</p>\n<h3 id=\"cryptographic-error-handling\">Cryptographic Error Handling</h3>\n<p>Cryptographic errors represent the most security-sensitive category of JWT validation failures. These errors often indicate active attacks or system compromise, requiring careful handling that provides minimal information to attackers while maintaining sufficient diagnostic capability for legitimate operations.</p>\n<p>Consider cryptographic error handling as handling suspicious packages at a secure facility. Security personnel cannot reveal specific detection methods or failure reasons to unauthorized individuals, but they must maintain detailed internal logs for investigation and provide appropriate notifications to authorized personnel. Our cryptographic error handling follows similar principles - silent failure for external observers with comprehensive logging for authorized diagnostic access.</p>\n<p>The signature verification process presents unique challenges because timing differences in error handling can reveal information about the validity of different token components. Constant-time comparison prevents timing attacks, but the broader error handling system must also avoid timing side channels through different code paths for different error types.</p>\n<blockquote>\n<p><strong>Decision: Uniform Cryptographic Error Response</strong></p>\n<ul>\n<li><strong>Context</strong>: Different cryptographic failure modes might reveal information through timing or error message differences</li>\n<li><strong>Options Considered</strong>: Specific error messages, generic responses, silent failure with logging</li>\n<li><strong>Decision</strong>: Return generic failure with detailed logging in security context</li>\n<li><strong>Rationale</strong>: Prevents information disclosure while maintaining diagnostic capability for legitimate operations</li>\n<li><strong>Consequences</strong>: Less specific error information for developers but stronger security posture against cryptographic attacks</li>\n</ul>\n</blockquote>\n<p>The key validation system must handle various key-related failures without revealing information about key properties or validation logic. Key strength validation ensures that provided keys meet minimum security requirements, while key format validation catches encoding or structure issues that might indicate integration problems rather than attacks.</p>\n<table>\n<thead>\n<tr>\n<th>Cryptographic Failure</th>\n<th>Detection Point</th>\n<th>Public Response</th>\n<th>Internal Logging</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Signature Mismatch</strong></td>\n<td>HMAC comparison</td>\n<td>Generic &quot;invalid token&quot;</td>\n<td>Full token header, signature details, timing</td>\n</tr>\n<tr>\n<td><strong>Algorithm Confusion</strong></td>\n<td>Header algorithm validation</td>\n<td>Generic &quot;invalid token&quot;</td>\n<td>Attempted algorithm, expected algorithm</td>\n</tr>\n<tr>\n<td><strong>Key Too Weak</strong></td>\n<td>Key strength validation</td>\n<td>Configuration error</td>\n<td>Key length, strength requirements</td>\n</tr>\n<tr>\n<td><strong>Key Format Error</strong></td>\n<td>Key parsing/validation</td>\n<td>Configuration error</td>\n<td>Key format details, expected format</td>\n</tr>\n</tbody></table>\n<p>The HMAC computation process must handle edge cases like empty signing input, malformed keys, or hash function failures without revealing internal state. Error handling at this level requires particular care because exceptions or error conditions might leak information about the cryptographic implementation.</p>\n<table>\n<thead>\n<tr>\n<th>HMAC Issue</th>\n<th>Cause</th>\n<th>Detection</th>\n<th>Handling Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Empty Signing Input</strong></td>\n<td>Malformed token structure</td>\n<td>String length check</td>\n<td>Structural error before HMAC</td>\n</tr>\n<tr>\n<td><strong>Invalid Key Format</strong></td>\n<td>Key encoding problems</td>\n<td>Key validation failure</td>\n<td>Configuration error response</td>\n</tr>\n<tr>\n<td><strong>Hash Function Failure</strong></td>\n<td>Cryptographic library error</td>\n<td>Exception during HMAC</td>\n<td>Internal error with fallback</td>\n</tr>\n<tr>\n<td><strong>Memory Issues</strong></td>\n<td>Large token or key size</td>\n<td>Memory allocation failure</td>\n<td>Resource exhaustion error</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Information Disclosure Through Error Timing</strong>\nDevelopers often implement different error handling paths for signature failures versus structural failures, creating timing side channels that reveal information about token validity. Always ensure that all cryptographic error paths take similar execution time. Use constant-time comparison for signature validation and avoid early returns that might reveal information about which validation step failed.</p>\n<h3 id=\"temporal-edge-cases\">Temporal Edge Cases</h3>\n<p>Time-based JWT validation presents unique challenges because distributed systems rarely maintain perfect clock synchronization. Temporal edge cases span from simple clock skew scenarios to complex edge cases involving leap seconds, daylight saving time transitions, and extreme timestamp values that might cause integer overflow or underflow.</p>\n<p>Think of temporal validation as coordinating a global conference call across multiple time zones. Participants may have slightly different clocks, some may join early or late due to scheduling confusion, and the conference system must gracefully handle these timing discrepancies while maintaining the intended access control. JWT temporal validation requires similar flexibility within well-defined security boundaries.</p>\n<p>Clock skew tolerance represents a fundamental security trade-off between usability and temporal accuracy. Generous leeway periods improve interoperability between systems with slightly misaligned clocks but create larger windows where expired tokens remain valid. Conservative leeway settings provide tighter security at the cost of increased failure rates in normal operation.</p>\n<blockquote>\n<p><strong>Decision: Configurable Leeway with Secure Defaults</strong></p>\n<ul>\n<li><strong>Context</strong>: Systems in production often have modest clock differences, but security requires limiting temporal tolerance</li>\n<li><strong>Options Considered</strong>: Fixed leeway, no leeway, fully configurable leeway, adaptive leeway</li>\n<li><strong>Decision</strong>: Configurable leeway with security-focused default of 300 seconds maximum</li>\n<li><strong>Rationale</strong>: Balances operational requirements with security constraints while preventing excessive temporal tolerance</li>\n<li><strong>Consequences</strong>: Some systems may require clock synchronization improvements, but provides predictable security boundaries</li>\n</ul>\n</blockquote>\n<p>The leap second handling system addresses rare but potentially significant edge cases where system clocks may become temporarily inconsistent during leap second events. While leap seconds occur infrequently, they can cause subtle timing validation failures that are difficult to diagnose without specific handling logic.</p>\n<table>\n<thead>\n<tr>\n<th>Temporal Edge Case</th>\n<th>Scenario</th>\n<th>Detection Method</th>\n<th>Handling Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Clock Skew</strong></td>\n<td>Servers with different system times</td>\n<td>Timestamp comparison with leeway</td>\n<td>Accept within configured tolerance</td>\n</tr>\n<tr>\n<td><strong>Leap Second</strong></td>\n<td>UTC time adjustment events</td>\n<td>Large clock discontinuity detection</td>\n<td>Extended leeway during leap events</td>\n</tr>\n<tr>\n<td><strong>DST Transition</strong></td>\n<td>Local time zone adjustments</td>\n<td>UTC timestamp validation</td>\n<td>Use UTC for all calculations</td>\n</tr>\n<tr>\n<td><strong>Timestamp Overflow</strong></td>\n<td>Dates beyond system limits</td>\n<td>Range validation before conversion</td>\n<td>Reject with temporal range error</td>\n</tr>\n</tbody></table>\n<p>The extreme timestamp validation system prevents integer overflow attacks and handles edge cases like year 2038 problems on 32-bit systems. Timestamp validation must consider both the mathematical validity of timestamp values and the practical limits of datetime libraries in the target programming language.</p>\n<table>\n<thead>\n<tr>\n<th>Timestamp Issue</th>\n<th>Range Problem</th>\n<th>Validation Check</th>\n<th>Error Response</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Negative Timestamps</strong></td>\n<td>Dates before Unix epoch</td>\n<td>Value &gt;= 0 check</td>\n<td>Invalid timestamp format</td>\n</tr>\n<tr>\n<td><strong>Far Future Dates</strong></td>\n<td>Beyond system datetime limits</td>\n<td>Maximum timestamp validation</td>\n<td>Timestamp out of range</td>\n</tr>\n<tr>\n<td><strong>Integer Overflow</strong></td>\n<td>Values causing calculation overflow</td>\n<td>Safe arithmetic checks</td>\n<td>Temporal calculation error</td>\n</tr>\n<tr>\n<td><strong>Precision Loss</strong></td>\n<td>Microseconds in integer timestamps</td>\n<td>Precision validation during conversion</td>\n<td>Timestamp precision warning</td>\n</tr>\n</tbody></table>\n<p>The time zone handling system ensures that all temporal calculations use UTC to avoid ambiguity and inconsistency. Local time zone interpretation can create security vulnerabilities where tokens appear valid or invalid depending on server configuration, making UTC the only safe choice for distributed authentication systems.</p>\n<p>⚠️ <strong>Pitfall: Using Local Time for JWT Validation</strong>\nMany developers accidentally use local server time for JWT timestamp validation, creating inconsistencies when tokens are validated across different time zones or servers with different time zone configurations. Always convert all timestamps to UTC before performing any temporal validation. Use UTC-based libraries and explicitly validate that timestamp claims represent UTC values rather than local time.</p>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Silent Error Swallowing</strong>\nDevelopers sometimes catch all exceptions during JWT validation and return generic &quot;invalid token&quot; responses without proper logging or error context. This makes debugging extremely difficult and can mask security issues. Instead, implement structured error handling that captures full error context internally while returning appropriate public error messages based on security context.</p>\n<p>⚠️ <strong>Pitfall: Inconsistent Error Response Format</strong>\nApplications often return different error response formats for different types of JWT validation failures - HTTP status codes for some errors, JSON responses for others, plain text for edge cases. This inconsistency complicates client-side error handling and may leak information about internal validation logic. Establish a consistent error response format that all validation failure modes use.</p>\n<p>⚠️ <strong>Pitfall: Development Error Details in Production</strong>\nMany JWT libraries provide detailed error messages that include token contents, internal state, or validation details that should never be exposed in production environments. Always implement security context-aware error messaging that provides detailed diagnostics in development while maintaining minimal information disclosure in production.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>Building robust error handling for JWT validation requires careful attention to both security and operational concerns. The following implementation provides a foundation for handling the various error categories while maintaining appropriate security boundaries.</p>\n<h4 id=\"a-technology-recommendations\">A. Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Error Hierarchy</strong></td>\n<td>Built-in exceptions with custom messages</td>\n<td>Custom exception classes with structured context</td>\n</tr>\n<tr>\n<td><strong>Logging</strong></td>\n<td>Standard library logging with levels</td>\n<td>Structured logging with security context awareness</td>\n</tr>\n<tr>\n<td><strong>Configuration</strong></td>\n<td>Environment variables for security context</td>\n<td>Configuration management with validation</td>\n</tr>\n<tr>\n<td><strong>Monitoring</strong></td>\n<td>Basic error rate logging</td>\n<td>Security event monitoring with alerting</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-file-structure\">B. Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>jwt_library/\n├── errors/\n│   ├── __init__.py              ← Error class definitions and hierarchy\n│   ├── classification.py        ← Error severity and context management\n│   ├── handlers.py              ← Error handling strategies by context\n│   └── diagnostics.py           ← Diagnostic information formatting\n├── validation/\n│   ├── structural.py            ← Malformed token validation\n│   ├── cryptographic.py         ← Signature and key validation\n│   ├── temporal.py              ← Time-based validation\n│   └── claims.py                ← Claims validation with error handling\n└── utils/\n    ├── logging.py               ← Security-aware logging utilities\n    └── context.py               ← Security context management</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Complete error handling infrastructure for JWT validation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">This provides the foundation classes and utilities needed for</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">comprehensive error handling across all validation components.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> traceback</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ErrorSeverity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Error severity levels for appropriate response handling.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CRITICAL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"critical\"</span><span style=\"color:#6A737D\">    # Potential security attacks</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    HIGH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"high\"</span><span style=\"color:#6A737D\">           # Clear validation failures  </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MEDIUM</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"medium\"</span><span style=\"color:#6A737D\">       # Configuration/integration issues</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LOW</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"low\"</span><span style=\"color:#6A737D\">            # Edge cases and warnings</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SecurityContext</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Security context for error handling behavior.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DEVELOPMENT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"development\"</span><span style=\"color:#6A737D\">  # Full diagnostic details</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PRODUCTION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"production\"</span><span style=\"color:#6A737D\">    # Generic error messages</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AUDIT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"audit\"</span><span style=\"color:#6A737D\">             # Enhanced logging and monitoring</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ValidationFailureContext</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Structured context for validation failures.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    component: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">                    # Component that detected the failure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    operation: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">                   # Operation that was attempted  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    failure_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">               # Type of failure detected</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    severity: ErrorSeverity         </span><span style=\"color:#6A737D\"># Severity level of the failure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    debug_info: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]      </span><span style=\"color:#6A737D\"># Detailed diagnostic information</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    safe_message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">               # Safe message for external consumption</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timestamp: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">         # When the failure occurred</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __post_init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.timestamp </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.timestamp </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SecurityAwareLogger</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Logger that adapts output based on security context.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, security_context: SecurityContext):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(name)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.security_context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> security_context</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> log_validation_failure</span><span style=\"color:#E1E4E8\">(self, context: ValidationFailureContext):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Log validation failure with appropriate detail level.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.security_context </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> SecurityContext.</span><span style=\"color:#79B8FF\">DEVELOPMENT</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.logger.error(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Validation failure in </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">context.component</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">context.debug_info</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.security_context </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> SecurityContext.</span><span style=\"color:#79B8FF\">PRODUCTION</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.logger.warning(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Validation failure: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">context.safe_message</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#6A737D\"># AUDIT</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.logger.info(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Audit: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">context.component</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#79B8FF\"> {</span><span style=\"color:#E1E4E8\">context.operation</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> failed\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ConstantTimeOperations</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Utilities for constant-time operations to prevent timing attacks.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> constant_time_compare</span><span style=\"color:#E1E4E8\">(a: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, b: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Compare two byte sequences in constant time.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(a) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(b):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> x, y </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> zip</span><span style=\"color:#E1E4E8\">(a, b):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> x </span><span style=\"color:#F97583\">^</span><span style=\"color:#E1E4E8\"> y</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> safe_error_delay</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add consistent delay for all error paths.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        time.sleep(</span><span style=\"color:#79B8FF\">0.001</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># 1ms consistent delay</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement the main JWT error handling classes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># These should be implemented by the learner following the patterns above</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> JWTValidationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base exception for all JWT validation failures.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, context: ValidationFailureContext):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Store the validation failure context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Set appropriate exception message based on security context  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Initialize parent exception with safe message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_safe_message</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return message appropriate for external consumption</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_debug_info</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return diagnostic information for internal use</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> StructuralError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTValidationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Token structure and format validation failures.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MalformedTokenError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">StructuralError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Invalid token structure - wrong number of parts or format.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> parse_token_structure</span><span style=\"color:#E1E4E8\">(token: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> tuple[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Parse JWT token structure into header, payload, signature parts.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Validates basic token format and returns the three components.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate token is a string and not empty</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Split token on '.' character</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate exactly 3 parts exist (header.payload.signature)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Validate each part is non-empty</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return tuple of (header, payload, signature) parts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use ValidationFailureContext to structure any errors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_base64url_format</span><span style=\"color:#E1E4E8\">(data: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, part_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Validate that data contains only valid Base64URL characters.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises StructuralError if invalid characters are found.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Define valid Base64URL character set (A-Z, a-z, 0-9, -, _)  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check each character in data against valid character set</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Ensure no padding characters (=) are present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create ValidationFailureContext for any invalid characters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Raise StructuralError with context if validation fails</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> handle_cryptographic_error</span><span style=\"color:#E1E4E8\">(error: </span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">, operation: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> JWTValidationError:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Convert cryptographic errors to appropriate JWT validation errors.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Ensures consistent handling across different crypto failure modes.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Determine error severity based on exception type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create appropriate debug information without leaking crypto details</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Generate safe public message for the error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Add consistent timing delay to prevent timing attacks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return appropriate JWTValidationError subclass</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use ConstantTimeOperations.safe_error_delay()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_temporal_bounds</span><span style=\"color:#E1E4E8\">(timestamp: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, claim_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                           leeway_seconds: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> DEFAULT_LEEWAY_SECONDS</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Validate timestamp is within reasonable bounds for system processing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Prevents integer overflow and handles extreme timestamp values.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Define reasonable timestamp bounds (e.g., 1970 to 2099)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check timestamp is not negative</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check timestamp is not beyond maximum system datetime</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Validate timestamp + leeway doesn't cause integer overflow</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Raise TemporalValidationError for out-of-bounds values</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<p><strong>Python-Specific Error Handling:</strong></p>\n<ul>\n<li>Use <code>logging</code> module with structured formatters for security-aware logging</li>\n<li>Implement custom exception hierarchy inheriting from <code>Exception</code></li>\n<li>Use <code>dataclasses</code> for structured error context objects</li>\n<li>Use <code>time.time()</code> for consistent timestamp generation across error handling</li>\n<li>Use <code>traceback</code> module carefully - include full traces only in development context</li>\n</ul>\n<p><strong>Security Considerations:</strong></p>\n<ul>\n<li>Never include token contents in error messages outside development context</li>\n<li>Use <code>secrets.compare_digest()</code> for constant-time string comparisons</li>\n<li>Implement consistent error response timing using <code>time.sleep()</code> where needed</li>\n<li>Use structured logging formats that can be easily filtered and monitored</li>\n</ul>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p><strong>After implementing error handling infrastructure:</strong></p>\n<ol>\n<li><strong>Basic Error Classification Test:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_error_classification.py</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n<p>   Expected: All error severity levels and security contexts work correctly</p>\n<ol start=\"2\">\n<li><strong>Malformed Token Handling Test:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   from jwt_library.validation.structural import parse_token_structure</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   try:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">       parse_token_structure('invalid')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   except MalformedTokenError as e:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">       print('✓ Correctly caught malformed token')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   \"</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Security Context Behavior Test:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   from jwt_library.errors import SecurityContext, ValidationFailureContext</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   # Test that production context hides debug details</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   context = ValidationFailureContext(...)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   # Verify safe_message is generic in production context</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   \"</span></span></code></pre></div>\n\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>All tokens rejected as &quot;invalid&quot;</td>\n<td>Error handling swallowing specific errors</td>\n<td>Enable debug logging, check error contexts</td>\n<td>Implement proper error classification</td>\n</tr>\n<tr>\n<td>Inconsistent validation behavior</td>\n<td>Different error paths for same failure type</td>\n<td>Add logging to all validation paths</td>\n<td>Standardize error handling flow</td>\n</tr>\n<tr>\n<td>Performance issues during errors</td>\n<td>Complex error formatting in hot paths</td>\n<td>Profile error handling code</td>\n<td>Cache formatted messages, simplify context</td>\n</tr>\n<tr>\n<td>Information leakage in errors</td>\n<td>Development error details in production</td>\n<td>Check security context configuration</td>\n<td>Implement context-aware message formatting</td>\n</tr>\n</tbody></table>\n<h2 id=\"testing-strategy\">Testing Strategy</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All three milestones - provides comprehensive verification approach for JWT structure implementation (Milestone 1), HMAC signing security (Milestone 2), and claims validation correctness (Milestone 3)</p>\n</blockquote>\n<p>Testing a JWT library requires a multi-layered verification approach that goes beyond simple functional testing. Since JWTs form the foundation of authentication and authorization systems, our testing strategy must validate not only correctness but also security properties, edge cases, and resistance to common attacks. This section establishes concrete verification points for each milestone, reference test vectors for validation, security-focused test scenarios, and complete end-to-end workflows.</p>\n<h3 id=\"mental-model-quality-assurance-laboratory\">Mental Model: Quality Assurance Laboratory</h3>\n<p>Think of our testing strategy as a quality assurance laboratory for security tokens - similar to how a mint tests newly produced currency. Just as currency testing involves multiple verification stations (weight, dimensions, security features, durability), JWT testing requires multiple validation layers. The structural tests verify the token &quot;looks right&quot; (proper format, encoding), cryptographic tests ensure it &quot;can&#39;t be counterfeited&quot; (signature integrity, timing attack resistance), and claims validation tests confirm it &quot;works as intended&quot; (expiration, audience, issuer verification). Each testing layer catches different classes of problems, and only tokens passing all layers can be trusted in production systems.</p>\n<p>The testing laboratory analogy extends to our reference test vectors - these are like the &quot;gold standard&quot; samples that all production tokens must match. Security test scenarios are like stress tests that attempt to break or exploit the tokens using known attack techniques. End-to-end scenarios verify the complete workflow from token creation through validation, ensuring the entire system works cohesively rather than just individual components in isolation.</p>\n<h3 id=\"milestone-verification-points\">Milestone Verification Points</h3>\n<p>Each development milestone has specific verification checkpoints that validate both functional correctness and security properties. These checkpoints build upon each other - Milestone 2 verification assumes Milestone 1 is working correctly, and Milestone 3 verification requires both previous milestones to function properly.</p>\n<h4 id=\"milestone-1-jwt-structure-verification\">Milestone 1: JWT Structure Verification</h4>\n<table>\n<thead>\n<tr>\n<th>Verification Point</th>\n<th>Expected Behavior</th>\n<th>Failure Indicators</th>\n<th>Recovery Actions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Header JSON Generation</td>\n<td><code>JWTHeader</code> with <code>alg: &quot;HS256&quot;</code> and <code>typ: &quot;JWT&quot;</code> serializes to valid JSON</td>\n<td>Malformed JSON, missing fields, incorrect field values</td>\n<td>Check <code>serialize_header</code> JSON formatting, verify field names match specification</td>\n</tr>\n<tr>\n<td>Payload Claims Encoding</td>\n<td>All standard claims (<code>iss</code>, <code>sub</code>, <code>aud</code>, <code>exp</code>, <code>nbf</code>, <code>iat</code>, <code>jti</code>) and custom claims serialize correctly</td>\n<td>Missing required claims, incorrect timestamp format, malformed custom claims</td>\n<td>Validate <code>serialize_payload</code> handles all claim types, check Unix timestamp conversion</td>\n</tr>\n<tr>\n<td>Base64URL Character Set</td>\n<td>Encoded output contains only URL-safe characters (A-Z, a-z, 0-9, -, _)</td>\n<td>Plus signs, forward slashes, or equals padding in output</td>\n<td>Verify <code>base64url_encode</code> uses URL-safe alphabet, removes padding correctly</td>\n</tr>\n<tr>\n<td>Token Structure Assembly</td>\n<td>Final token follows <code>header.payload.signature</code> format with exactly two dots</td>\n<td>Missing dots, extra segments, empty segments</td>\n<td>Check <code>assemble_token</code> concatenation logic and dot separator placement</td>\n</tr>\n<tr>\n<td>Round-trip Encoding Consistency</td>\n<td>Encoding then parsing header/payload returns identical data structures</td>\n<td>Field value changes, type conversions, missing custom claims</td>\n<td>Verify JSON serialization is deterministic, check parsing logic</td>\n</tr>\n</tbody></table>\n<p><strong>Concrete Verification Steps:</strong></p>\n<ol>\n<li><p><strong>Header Structure Test</strong>: Create a <code>JWTHeader</code> with algorithm &quot;HS256&quot; and type &quot;JWT&quot;. Serialize using <code>serialize_header</code> and verify the resulting JSON contains exactly these fields with correct values. Parse the JSON back and confirm field values match the original structure.</p>\n</li>\n<li><p><strong>Payload Claims Test</strong>: Create a <code>JWTPayload</code> with all standard claims populated (issuer, subject, audience, expiration, not-before, issued-at, JWT ID) plus custom claims dictionary. Serialize using <code>serialize_payload</code> and verify all fields appear in the JSON with correct types (strings for text fields, integers for timestamps, appropriate handling of audience as string or list).</p>\n</li>\n<li><p><strong>Base64URL Encoding Test</strong>: Take known binary data and encode using <code>base64url_encode</code>. Verify the output contains no plus signs, forward slashes, or equals padding. Decode using <code>base64url_decode</code> and confirm the result matches the original binary data exactly.</p>\n</li>\n<li><p><strong>Token Assembly Test</strong>: Create encoded header and payload strings, add a mock signature, and use <code>assemble_token</code> to create the final token. Verify the result has exactly three segments separated by dots, with no empty segments or extra separators.</p>\n</li>\n</ol>\n<h4 id=\"milestone-2-hmac-signing-verification\">Milestone 2: HMAC Signing Verification</h4>\n<table>\n<thead>\n<tr>\n<th>Verification Point</th>\n<th>Expected Behavior</th>\n<th>Failure Indicators</th>\n<th>Recovery Actions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HMAC-SHA256 Computation</td>\n<td>Signatures match RFC 7515 test vectors exactly</td>\n<td>Signature mismatches, wrong signature length</td>\n<td>Verify HMAC implementation, check key handling, validate input encoding</td>\n</tr>\n<tr>\n<td>Signature Verification Success</td>\n<td>Valid tokens return <code>True</code> from <code>verify</code> method</td>\n<td>False negatives on valid signatures</td>\n<td>Check signature recomputation logic, verify input reconstruction</td>\n</tr>\n<tr>\n<td>Signature Verification Failure</td>\n<td>Invalid, tampered, or truncated signatures return <code>False</code></td>\n<td>False positives on invalid signatures</td>\n<td>Validate comparison logic, check error handling paths</td>\n</tr>\n<tr>\n<td>Constant-Time Comparison</td>\n<td><code>constant_time_compare</code> execution time independent of input differences</td>\n<td>Timing variations correlate with input differences</td>\n<td>Implement proper constant-time algorithm, avoid early returns</td>\n</tr>\n<tr>\n<td>Key Strength Validation</td>\n<td><code>validate_key_strength</code> rejects keys shorter than 32 bytes</td>\n<td>Weak keys accepted, incorrect length calculations</td>\n<td>Check minimum key length constant, validate byte length correctly</td>\n</tr>\n</tbody></table>\n<p><strong>Concrete Verification Steps:</strong></p>\n<ol>\n<li><p><strong>RFC Test Vector Validation</strong>: Use the standard test vectors from RFC 7515 to verify HMAC-SHA256 computation. Create the exact signing input specified in the test vector, use the test key, and confirm our <code>sign</code> method produces the identical signature bytes specified in the RFC.</p>\n</li>\n<li><p><strong>Signature Round-Trip Test</strong>: Create a token using <code>create_token</code>, then immediately verify it using <code>verify_token</code> with the same secret key and permissive validation context. This should always succeed for properly formed tokens.</p>\n</li>\n<li><p><strong>Tampering Detection Test</strong>: Create a valid token, then systematically tamper with each part (header, payload, signature) and verify that <code>verify_token</code> correctly rejects all tampered variants.</p>\n</li>\n<li><p><strong>Timing Attack Resistance Test</strong>: Create two tokens with signatures that differ in the first byte versus signatures that differ in the last byte. Measure the execution time of <code>constant_time_compare</code> for both scenarios - the time differences should be statistically insignificant.</p>\n</li>\n</ol>\n<h4 id=\"milestone-3-claims-validation-verification\">Milestone 3: Claims Validation Verification</h4>\n<table>\n<thead>\n<tr>\n<th>Verification Point</th>\n<th>Expected Behavior</th>\n<th>Failure Indicators</th>\n<th>Recovery Actions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Expiration Enforcement</td>\n<td>Tokens with <code>exp</code> in the past raise <code>TokenExpiredError</code></td>\n<td>Expired tokens accepted, incorrect error types</td>\n<td>Check <code>is_expired</code> logic, verify Unix timestamp comparison</td>\n</tr>\n<tr>\n<td>Not-Before Enforcement</td>\n<td>Tokens with <code>nbf</code> in the future raise <code>TokenNotYetValidError</code></td>\n<td>Premature tokens accepted, missing nbf validation</td>\n<td>Validate <code>is_not_before</code> implementation, check future time handling</td>\n</tr>\n<tr>\n<td>Clock Skew Tolerance</td>\n<td>Tokens within leeway period are accepted despite slight time differences</td>\n<td>Excessive clock skew rejection, incorrect leeway application</td>\n<td>Verify leeway addition/subtraction logic in time comparisons</td>\n</tr>\n<tr>\n<td>Issuer Allowlist Validation</td>\n<td>Only tokens from allowed issuers are accepted, others raise <code>InvalidIssuerError</code></td>\n<td>Unauthorized issuers accepted, allowlist bypass</td>\n<td>Check issuer comparison logic, validate allowlist membership</td>\n</tr>\n<tr>\n<td>Audience Verification</td>\n<td>Tokens match expected audience exactly, others raise <code>InvalidAudienceError</code></td>\n<td>Wrong audience accepted, audience list handling errors</td>\n<td>Verify audience string/list handling, check exact matching</td>\n</tr>\n</tbody></table>\n<p><strong>Concrete Verification Steps:</strong></p>\n<ol>\n<li><p><strong>Time-Based Claims Test</strong>: Create tokens with expiration times 10 minutes in the past, 10 minutes in the future, and exactly now. Validate with default leeway settings and verify only the future token is accepted.</p>\n</li>\n<li><p><strong>Issuer Validation Test</strong>: Create an allowed issuer list containing &quot;trusted-issuer&quot; and &quot;backup-issuer&quot;. Create tokens from these issuers and from &quot;malicious-issuer&quot;. Verify only tokens from allowed issuers pass validation.</p>\n</li>\n<li><p><strong>Audience List Handling Test</strong>: Create tokens with audience as a single string, as a list containing the expected audience, and as a list not containing the expected audience. Verify the validation handles all formats correctly.</p>\n</li>\n<li><p><strong>Clock Skew Edge Cases Test</strong>: Create tokens that expire exactly at the leeway boundary (e.g., 5 minutes and 1 second past expiration with 5 minute leeway). These should be rejected, while tokens expiring 4 minutes and 59 seconds ago should be accepted.</p>\n</li>\n</ol>\n<h3 id=\"reference-test-vectors\">Reference Test Vectors</h3>\n<p>Reference test vectors provide known-good inputs and expected outputs for validating implementation correctness. These vectors come from official JWT specifications, established libraries, and carefully crafted edge cases that expose common implementation bugs.</p>\n<h4 id=\"rfc-7515-official-test-vectors\">RFC 7515 Official Test Vectors</h4>\n<table>\n<thead>\n<tr>\n<th>Test Vector Name</th>\n<th>Input Data</th>\n<th>Expected Output</th>\n<th>Validation Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Basic HS256 Signature</td>\n<td>Header: <code>{&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;}</code>, Payload: <code>{&quot;sub&quot;:&quot;1234567890&quot;,&quot;name&quot;:&quot;John Doe&quot;,&quot;iat&quot;:1516239022}</code>, Key: <code>your-256-bit-secret</code> (base64)</td>\n<td>Signature: <code>SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</code></td>\n<td>Validates core HMAC-SHA256 implementation</td>\n</tr>\n<tr>\n<td>Empty Payload Test</td>\n<td>Header: <code>{&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;}</code>, Payload: <code>{}</code>, Key: 32-byte random key</td>\n<td>Valid signature for empty claims</td>\n<td>Tests minimal valid JWT structure</td>\n</tr>\n<tr>\n<td>Custom Claims Vector</td>\n<td>Header: standard, Payload: includes custom claims with various types (string, number, boolean, array), Key: test key</td>\n<td>Expected signature for complex payload</td>\n<td>Validates custom claims serialization</td>\n</tr>\n<tr>\n<td>Special Characters Test</td>\n<td>Header: standard, Payload: contains Unicode characters, quotes, newlines in string fields</td>\n<td>Valid signature despite special characters</td>\n<td>Tests JSON escaping and encoding edge cases</td>\n</tr>\n</tbody></table>\n<p><strong>Base64URL Encoding Test Vectors:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Input Bytes (Hex)</th>\n<th>Expected Base64URL Output</th>\n<th>Validation Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>48656c6c6f</code> (&quot;Hello&quot;)</td>\n<td><code>SGVsbG8</code></td>\n<td>Basic encoding without padding</td>\n</tr>\n<tr>\n<td><code>48656c6c6f20</code> (&quot;Hello &quot;)</td>\n<td><code>SGVsbG8g</code></td>\n<td>Encoding requiring 2 padding chars removed</td>\n</tr>\n<tr>\n<td><code>48656c6c6f2057</code> (&quot;Hello W&quot;)</td>\n<td><code>SGVsbG9X</code></td>\n<td>Encoding requiring 1 padding char removed</td>\n</tr>\n<tr>\n<td>Empty bytes</td>\n<td>Empty string</td>\n<td>Edge case of zero-length input</td>\n</tr>\n<tr>\n<td><code>ff</code> (single byte 255)</td>\n<td><code>_w</code></td>\n<td>Tests URL-safe character substitution</td>\n</tr>\n</tbody></table>\n<p><strong>Claims Validation Test Vectors:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Test Scenario</th>\n<th>Token Claims</th>\n<th>Validation Context</th>\n<th>Expected Result</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Valid Unexpired Token</td>\n<td><code>exp</code>: current time + 3600, <code>iss</code>: &quot;trusted-issuer&quot;, <code>aud</code>: &quot;my-app&quot;</td>\n<td>Standard context with &quot;trusted-issuer&quot; allowed, &quot;my-app&quot; expected audience</td>\n<td>Success</td>\n</tr>\n<tr>\n<td>Expired Token</td>\n<td><code>exp</code>: current time - 3600</td>\n<td>Standard context with default leeway</td>\n<td><code>TokenExpiredError</code></td>\n</tr>\n<tr>\n<td>Future NBF Token</td>\n<td><code>nbf</code>: current time + 3600</td>\n<td>Standard context</td>\n<td><code>TokenNotYetValidError</code></td>\n</tr>\n<tr>\n<td>Clock Skew Acceptable</td>\n<td><code>exp</code>: current time - 200</td>\n<td>Context with 300 second leeway</td>\n<td>Success</td>\n</tr>\n<tr>\n<td>Invalid Issuer</td>\n<td><code>iss</code>: &quot;malicious-issuer&quot;</td>\n<td>Context allowing only &quot;trusted-issuer&quot;</td>\n<td><code>InvalidIssuerError</code></td>\n</tr>\n<tr>\n<td>Wrong Audience</td>\n<td><code>aud</code>: &quot;other-app&quot;</td>\n<td>Context expecting &quot;my-app&quot;</td>\n<td><code>InvalidAudienceError</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"edge-case-test-vectors\">Edge Case Test Vectors</h4>\n<p>These vectors test boundary conditions and edge cases that often expose implementation bugs:</p>\n<table>\n<thead>\n<tr>\n<th>Edge Case</th>\n<th>Test Data</th>\n<th>Expected Behavior</th>\n<th>Common Bug Exposed</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Maximum Timestamp</td>\n<td><code>exp</code>: 2147483647 (2038-01-19)</td>\n<td>Valid until that date</td>\n<td>Integer overflow in timestamp handling</td>\n</tr>\n<tr>\n<td>Minimum Timestamp</td>\n<td><code>exp</code>: 0 (1970-01-01)</td>\n<td>Expired (assuming current time &gt; 1970)</td>\n<td>Underflow or negative time handling</td>\n</tr>\n<tr>\n<td>Leap Second Timestamp</td>\n<td><code>exp</code>: timestamp during leap second</td>\n<td>Graceful handling without crash</td>\n<td>Time library edge case failures</td>\n</tr>\n<tr>\n<td>Very Long Custom Claim</td>\n<td>Custom claim with 10KB string value</td>\n<td>Either accept or reject gracefully</td>\n<td>Buffer overflow or memory issues</td>\n</tr>\n<tr>\n<td>Unicode in Claims</td>\n<td>Claims containing emoji, Chinese characters, mathematical symbols</td>\n<td>Proper UTF-8 handling</td>\n<td>Character encoding bugs</td>\n</tr>\n<tr>\n<td>Nested JSON in Custom Claims</td>\n<td>Custom claim containing JSON object/array</td>\n<td>Correct nested serialization</td>\n<td>JSON escaping and structure bugs</td>\n</tr>\n</tbody></table>\n<h3 id=\"security-test-scenarios\">Security Test Scenarios</h3>\n<p>Security testing focuses on validating resistance to known attack vectors and ensuring the library fails securely when faced with malicious inputs or exploitation attempts.</p>\n<h4 id=\"timing-attack-tests\">Timing Attack Tests</h4>\n<p>Timing attacks exploit variations in execution time to extract sensitive information. Our constant-time comparison implementation must resist these attacks:</p>\n<table>\n<thead>\n<tr>\n<th>Attack Scenario</th>\n<th>Test Method</th>\n<th>Success Criteria</th>\n<th>Failure Indicators</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Signature Comparison Timing</td>\n<td>Compare execution time of <code>constant_time_compare</code> with signatures differing in first byte vs last byte</td>\n<td>Time difference is statistically insignificant across 10,000 iterations</td>\n<td>Measurable timing correlation with input differences</td>\n</tr>\n<tr>\n<td>Key Length Timing</td>\n<td>Measure verification time with correct key vs wrong key of same length</td>\n<td>Consistent timing regardless of key correctness</td>\n<td>Faster failure with wrong keys due to early termination</td>\n</tr>\n<tr>\n<td>Signature Length Timing</td>\n<td>Test signatures of correct length vs truncated signatures</td>\n<td>Similar processing time for length validation</td>\n<td>Different timing reveals signature length checking logic</td>\n</tr>\n</tbody></table>\n<p><strong>Timing Attack Test Implementation:</strong></p>\n<p>The timing attack test requires statistical analysis to detect subtle timing differences. Create pairs of similar signatures where only one bit differs at position 0 (first byte) versus position 255 (last byte). Run the <code>constant_time_compare</code> function 10,000 times for each signature pair, measuring execution time in nanoseconds. Calculate the mean and standard deviation for each position. A secure implementation should show no statistically significant difference between first-byte and last-byte differences.</p>\n<h4 id=\"algorithm-confusion-attack-tests\">Algorithm Confusion Attack Tests</h4>\n<p>Algorithm confusion attacks exploit JWT&#39;s algorithm flexibility to bypass security:</p>\n<table>\n<thead>\n<tr>\n<th>Attack Vector</th>\n<th>Test Implementation</th>\n<th>Expected Defense</th>\n<th>Vulnerability Indicator</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>None Algorithm</td>\n<td>Create token with <code>alg: &quot;none&quot;</code> and empty signature</td>\n<td>Reject with algorithm not supported error</td>\n<td>Token accepted without signature verification</td>\n</tr>\n<tr>\n<td>Public Key as HMAC Key</td>\n<td>Use RSA public key as HMAC secret for HS256 token</td>\n<td>Reject due to key format validation</td>\n<td>Signature verification succeeds with public key</td>\n</tr>\n<tr>\n<td>Algorithm Downgrade</td>\n<td>Change <code>alg</code> field from HS256 to HS1 (weaker hash)</td>\n<td>Reject unsupported algorithm</td>\n<td>Weak algorithm accepted</td>\n</tr>\n<tr>\n<td>Missing Algorithm</td>\n<td>Create header without <code>alg</code> field</td>\n<td>Reject malformed header</td>\n<td>Default algorithm assumed</td>\n</tr>\n</tbody></table>\n<p><strong>Algorithm Confusion Test Implementation:</strong></p>\n<p>Create tokens with manipulated algorithm fields and verify the library rejects them appropriately. The test should modify only the algorithm field while keeping the payload and signature intact, then attempt verification. A secure implementation must validate the algorithm field matches the expected signing algorithm and reject any algorithm substitution attempts.</p>\n<h4 id=\"malformed-token-attack-tests\">Malformed Token Attack Tests</h4>\n<p>These tests verify robust handling of structurally invalid tokens:</p>\n<table>\n<thead>\n<tr>\n<th>Malformation Type</th>\n<th>Test Input</th>\n<th>Expected Behavior</th>\n<th>Security Concern</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Too Few Segments</td>\n<td><code>header.payload</code> (missing signature)</td>\n<td><code>MalformedTokenError</code> with safe message</td>\n<td>Information disclosure about expected format</td>\n</tr>\n<tr>\n<td>Too Many Segments</td>\n<td><code>header.payload.signature.extra</code></td>\n<td><code>MalformedTokenError</code></td>\n<td>Parser confusion or buffer overflow</td>\n</tr>\n<tr>\n<td>Empty Segments</td>\n<td><code>header..signature</code> (empty payload)</td>\n<td>Specific error for empty payload</td>\n<td>Bypass of required claims validation</td>\n</tr>\n<tr>\n<td>Invalid Base64URL</td>\n<td><code>header.invalid+base64=.signature</code></td>\n<td>Base64 decoding error</td>\n<td>Parser crash or unexpected behavior</td>\n</tr>\n<tr>\n<td>Non-JSON Header</td>\n<td>Valid base64url encoding invalid JSON in header</td>\n<td>JSON parsing error</td>\n<td>Information disclosure about internal structure</td>\n</tr>\n<tr>\n<td>Massive Token Size</td>\n<td>Token with 1MB+ payload</td>\n<td>Resource exhaustion protection or graceful rejection</td>\n<td>Denial of service vulnerability</td>\n</tr>\n</tbody></table>\n<h4 id=\"cryptographic-attack-simulation\">Cryptographic Attack Simulation</h4>\n<p>These tests simulate cryptographic attacks to verify signature security:</p>\n<table>\n<thead>\n<tr>\n<th>Attack Type</th>\n<th>Test Scenario</th>\n<th>Expected Defense</th>\n<th>Vulnerability Exposed</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Signature Stripping</td>\n<td>Remove signature segment entirely</td>\n<td>Reject unsigned token</td>\n<td>Bypass signature verification</td>\n</tr>\n<tr>\n<td>Signature Replay</td>\n<td>Use valid signature from different token</td>\n<td>Reject due to signature mismatch</td>\n<td>Cross-token signature acceptance</td>\n</tr>\n<tr>\n<td>Key Exhaustion</td>\n<td>Try common/weak keys against captured token</td>\n<td>No key should verify (assuming strong key used)</td>\n<td>Weak key acceptance</td>\n</tr>\n<tr>\n<td>Truncated Signature</td>\n<td>Use only first N bytes of valid signature</td>\n<td>Reject due to signature length/format</td>\n<td>Partial signature matching</td>\n</tr>\n</tbody></table>\n<h3 id=\"end-to-end-scenarios\">End-to-End Scenarios</h3>\n<p>End-to-end scenarios validate complete workflows from token creation through validation, ensuring all components work together correctly and handle realistic usage patterns.</p>\n<h4 id=\"standard-authentication-flow\">Standard Authentication Flow</h4>\n<p>This scenario simulates the most common JWT usage pattern - user authentication with session management:</p>\n<p><strong>Scenario Setup:</strong></p>\n<ul>\n<li>User &quot;john.doe&quot; authenticates to application &quot;web-app&quot; </li>\n<li>Issuer is &quot;auth-service&quot; with 1-hour token lifetime</li>\n<li>Custom claims include user roles and preferences</li>\n</ul>\n<p><strong>Test Sequence:</strong></p>\n<ol>\n<li><p><strong>Token Creation Phase:</strong></p>\n<ul>\n<li>Create <code>JWTHeader</code> with HS256 algorithm</li>\n<li>Create <code>JWTPayload</code> with issuer &quot;auth-service&quot;, subject &quot;john.doe&quot;, audience &quot;web-app&quot;</li>\n<li>Set expiration to current time + 3600 seconds</li>\n<li>Add custom claims: <code>{&quot;roles&quot;: [&quot;user&quot;, &quot;premium&quot;], &quot;preferences&quot;: {&quot;theme&quot;: &quot;dark&quot;}}</code></li>\n<li>Generate secret key using <code>generate_secure_key</code></li>\n<li>Call <code>create_token</code> and verify result has three dot-separated segments</li>\n</ul>\n</li>\n<li><p><strong>Token Transmission Simulation:</strong></p>\n<ul>\n<li>Simulate network transmission by base64 encoding/decoding the token</li>\n<li>Introduce minor timing delays to simulate network latency</li>\n<li>Verify token survives transmission without corruption</li>\n</ul>\n</li>\n<li><p><strong>Token Verification Phase:</strong></p>\n<ul>\n<li>Create <code>ValidationContext</code> with strict validation settings</li>\n<li>Set allowed issuers to [&quot;auth-service&quot;]</li>\n<li>Set expected audience to &quot;web-app&quot; </li>\n<li>Call <code>verify_token</code> and verify success</li>\n<li>Extract custom claims and verify roles and preferences are intact</li>\n</ul>\n</li>\n<li><p><strong>Claims Usage Phase:</strong></p>\n<ul>\n<li>Use returned <code>JWTPayload</code> for authorization decisions</li>\n<li>Check &quot;premium&quot; role in roles array</li>\n<li>Access user preferences for application customization</li>\n<li>Verify all data types preserved correctly through serialization</li>\n</ul>\n</li>\n</ol>\n<p><strong>Success Criteria:</strong></p>\n<ul>\n<li>Token creation completes without errors</li>\n<li>Token verification succeeds with correct claims</li>\n<li>Custom claims maintain proper types (arrays remain arrays, nested objects preserved)</li>\n<li>Entire flow completes in under 100ms on typical hardware</li>\n</ul>\n<h4 id=\"multi-service-authorization-scenario\">Multi-Service Authorization Scenario</h4>\n<p>This scenario tests JWT usage across multiple microservices with different validation requirements:</p>\n<p><strong>Scenario Setup:</strong></p>\n<ul>\n<li>Central authentication service issues tokens</li>\n<li>User service validates tokens with user-specific claims</li>\n<li>Payment service validates tokens with financial permissions</li>\n<li>Each service has different validation strictness</li>\n</ul>\n<p><strong>Test Sequence:</strong></p>\n<ol>\n<li><p><strong>Central Token Issuance:</strong></p>\n<ul>\n<li>Authentication service creates token with multiple audiences: [&quot;user-service&quot;, &quot;payment-service&quot;]</li>\n<li>Include hierarchical custom claims: <code>{&quot;permissions&quot;: {&quot;user&quot;: [&quot;read&quot;, &quot;update&quot;], &quot;payment&quot;: [&quot;view-balance&quot;]}}</code></li>\n<li>Token lifetime: 30 minutes</li>\n<li>Strong secret key (32+ bytes random)</li>\n</ul>\n</li>\n<li><p><strong>User Service Validation:</strong></p>\n<ul>\n<li>Create permissive <code>ValidationContext</code> (allows some clock skew)</li>\n<li>Validate token accepts &quot;user-service&quot; as audience</li>\n<li>Extract user permissions and verify &quot;read&quot; and &quot;update&quot; access</li>\n<li>Test succeeds even with 2-minute clock drift</li>\n</ul>\n</li>\n<li><p><strong>Payment Service Validation:</strong></p>\n<ul>\n<li>Create strict <code>ValidationContext</code> (minimal clock skew tolerance)</li>\n<li>Validate token accepts &quot;payment-service&quot; as audience  </li>\n<li>Extract payment permissions and verify &quot;view-balance&quot; access</li>\n<li>Reject token if more than 30 seconds of clock drift</li>\n</ul>\n</li>\n<li><p><strong>Cross-Service Token Reuse:</strong></p>\n<ul>\n<li>Same token should validate successfully in both services</li>\n<li>Each service extracts relevant permission subset</li>\n<li>Verify no interference between service-specific validations</li>\n</ul>\n</li>\n</ol>\n<p><strong>Success Criteria:</strong></p>\n<ul>\n<li>Single token validates successfully in multiple services</li>\n<li>Each service extracts appropriate permission subset</li>\n<li>Clock skew handling works correctly with different tolerance levels</li>\n<li>No permission leakage between service boundaries</li>\n</ul>\n<h4 id=\"error-handling-and-recovery-scenario\">Error Handling and Recovery Scenario</h4>\n<p>This scenario validates graceful error handling and recovery across the complete token lifecycle:</p>\n<p><strong>Test Sequence:</strong></p>\n<ol>\n<li><p><strong>Creation Error Simulation:</strong></p>\n<ul>\n<li>Attempt token creation with weak key (16 bytes) - should fail with key strength error</li>\n<li>Create token with malformed custom claims (circular references) - should fail with serialization error</li>\n<li>Create token with claims exceeding reasonable size limits - should fail gracefully</li>\n<li>Verify all creation errors include safe external messages and detailed internal diagnostics</li>\n</ul>\n</li>\n<li><p><strong>Network Corruption Simulation:</strong></p>\n<ul>\n<li>Create valid token then introduce single-bit errors in each segment</li>\n<li>Test with truncated tokens (missing characters from end)</li>\n<li>Test with extended tokens (extra characters appended)</li>\n<li>Verify all corruption scenarios produce appropriate parsing errors</li>\n</ul>\n</li>\n<li><p><strong>Temporal Edge Case Testing:</strong></p>\n<ul>\n<li>Create token that expires during the verification process</li>\n<li>Test verification exactly at expiration boundary (within millisecond precision)</li>\n<li>Test with extreme timestamps (year 2038, year 1970)</li>\n<li>Verify temporal validation handles edge cases gracefully</li>\n</ul>\n</li>\n<li><p><strong>Recovery and Fallback Testing:</strong></p>\n<ul>\n<li>Simulate validation service temporary unavailability</li>\n<li>Test graceful degradation when strict validation fails</li>\n<li>Verify error context includes sufficient information for debugging</li>\n<li>Test error message safety (no key material or sensitive data leaked)</li>\n</ul>\n</li>\n</ol>\n<p><strong>Success Criteria:</strong></p>\n<ul>\n<li>All error scenarios produce appropriate error types</li>\n<li>Error messages are safe for external consumption</li>\n<li>Internal diagnostic information is available for debugging</li>\n<li>No crashes or resource leaks during error conditions</li>\n<li>System recovers cleanly from all error states</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The testing strategy implementation requires careful setup of test infrastructure, automated validation pipelines, and comprehensive coverage of both functional and security requirements.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unit Testing</td>\n<td>Python <code>unittest</code> with basic assertions</td>\n<td><code>pytest</code> with fixtures, parameterized tests, and coverage reporting</td>\n</tr>\n<tr>\n<td>Timing Attack Testing</td>\n<td>Manual timing with <code>time.perf_counter()</code></td>\n<td>Statistical analysis with <code>scipy.stats</code> and automated significance testing</td>\n</tr>\n<tr>\n<td>Test Vector Validation</td>\n<td>Hard-coded expected values in test files</td>\n<td>JSON test vector files with automated loading and validation</td>\n</tr>\n<tr>\n<td>Security Testing</td>\n<td>Manual malformed input testing</td>\n<td>Property-based testing with <code>hypothesis</code> for fuzz testing</td>\n</tr>\n<tr>\n<td>Performance Testing</td>\n<td>Simple execution time measurement</td>\n<td><code>pytest-benchmark</code> with statistical analysis and regression detection</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended Test Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>jwt-library/\n  tests/\n    unit/\n      test_encoding.py           ← Milestone 1 tests\n      test_signing.py            ← Milestone 2 tests  \n      test_validation.py         ← Milestone 3 tests\n    integration/\n      test_end_to_end.py         ← Complete workflow tests\n    security/\n      test_timing_attacks.py     ← Security-focused tests\n      test_malformed_inputs.py   ← Robustness tests\n    vectors/\n      rfc_test_vectors.json      ← Official test vectors\n      edge_case_vectors.json     ← Custom edge case tests\n    conftest.py                  ← Shared test fixtures\n    test_utils.py                ← Testing utilities</code></pre></div>\n\n<p><strong>Test Infrastructure Starter Code:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tests/conftest.py - Complete test infrastructure setup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> pytest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> secrets</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timedelta</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Any, Tuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> jwt_library.core </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> JWTHeader, JWTPayload, ValidationContext</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> jwt_library.utils </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> utc_now, to_unix_timestamp</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@pytest.fixture</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> sample_header</span><span style=\"color:#E1E4E8\">() -> JWTHeader:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Standard JWT header for testing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> JWTHeader(</span><span style=\"color:#FFAB70\">alg</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"HS256\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">typ</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"JWT\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@pytest.fixture</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> sample_payload</span><span style=\"color:#E1E4E8\">() -> JWTPayload:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Standard JWT payload with all claim types.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    now </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> utc_now()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> JWTPayload(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        iss</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"test-issuer\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        sub</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"user123\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        aud</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"test-app\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        exp</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">to_unix_timestamp(now </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> timedelta(</span><span style=\"color:#FFAB70\">hours</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        nbf</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">to_unix_timestamp(now </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> timedelta(</span><span style=\"color:#FFAB70\">minutes</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">)),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        iat</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">to_unix_timestamp(now),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        jti</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"unique-token-id\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        custom_claims</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"role\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"admin\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"permissions\"</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">\"read\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"write\"</span><span style=\"color:#E1E4E8\">]}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@pytest.fixture</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_secret_key</span><span style=\"color:#E1E4E8\">() -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Secure 32-byte test key.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> secrets.token_bytes(</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@pytest.fixture</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> strict_validation_context</span><span style=\"color:#E1E4E8\">() -> ValidationContext:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Strict validation for security testing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ValidationContext(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        verify_signature</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        verify_expiration</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        verify_not_before</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        leeway_seconds</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        allowed_issuers</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#9ECBFF\">\"test-issuer\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        require_issuer</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        expected_audience</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"test-app\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        require_audience</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        required_claims</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#9ECBFF\">\"iss\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"sub\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"aud\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"exp\"</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TimingTestHelper</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Utilities for timing attack detection.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> measure_execution_time</span><span style=\"color:#E1E4E8\">(func, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, iterations: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">) -> List[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Measure function execution time over multiple iterations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        times </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> _ </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(iterations):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            func(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            times.append(end </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> times</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> detect_timing_difference</span><span style=\"color:#E1E4E8\">(times_a: List[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">], times_b: List[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                               significance_level: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.01</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Detect statistically significant timing differences.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        from</span><span style=\"color:#E1E4E8\"> scipy.stats </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ttest_ind</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        statistic, p_value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ttest_ind(times_a, times_b)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> p_value </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> significance_level</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@pytest.fixture</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> rfc_test_vectors</span><span style=\"color:#E1E4E8\">() -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Load official RFC test vectors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    with</span><span style=\"color:#79B8FF\"> open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'tests/vectors/rfc_test_vectors.json'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'r'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> f:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> json.load(f)</span></span></code></pre></div>\n\n<p><strong>Core Test Skeletons:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tests/unit/test_encoding.py - Milestone 1 verification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> pytest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> jwt_library.encoding </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> base64url_encode, base64url_decode, encode_token_parts</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestBase64URLEncoding</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test Base64URL encoding implementation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_rfc_test_vectors</span><span style=\"color:#E1E4E8\">(self, rfc_test_vectors):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate against official test vectors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Load Base64URL test vectors from rfc_test_vectors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For each vector, encode input bytes and compare to expected output</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Decode the expected output and verify it matches original input</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Verify no padding characters (=) in encoded output</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_url_safe_character_set</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Ensure only URL-safe characters in output.\"\"\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create test input that would generate +, /, = in regular base64</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Encode using base64url_encode</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Assert no +, /, or = characters in result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Assert only A-Z, a-z, 0-9, -, _ characters present</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_round_trip_consistency</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test encode/decode round trip.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Generate random byte sequences of various lengths</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Encode each sequence with base64url_encode  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Decode the result with base64url_decode</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Assert decoded bytes match original exactly</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestTokenStructureAssembly</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test JWT token structure assembly.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_three_segment_format</span><span style=\"color:#E1E4E8\">(self, sample_header, sample_payload):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify proper three-segment token format.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Encode header and payload using encode_token_parts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create mock signature string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Assemble token with assemble_token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Assert result has exactly 3 segments separated by dots</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Assert no empty segments</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Security Test Implementation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tests/security/test_timing_attacks.py - Security validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> pytest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> secrets</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> jwt_library.signing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> constant_time_compare</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> tests.conftest </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> TimingTestHelper</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestTimingAttackResistance</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validate resistance to timing side-channel attacks.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_constant_time_signature_comparison</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test constant-time comparison implementation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Generate two 32-byte signatures that differ in first byte</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Generate two 32-byte signatures that differ in last byte  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Measure execution time of constant_time_compare for each pair</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Use TimingTestHelper.detect_timing_difference to check significance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Assert no statistically significant timing difference detected</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_key_length_timing</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify key validation timing is consistent.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create correct-length key and too-short key</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Measure validation time for both keys over many iterations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Assert timing difference is not statistically significant</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Verify both keys produce appropriate validation results</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestAlgorithmConfusionResistance</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test resistance to algorithm confusion attacks.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_none_algorithm_rejection</span><span style=\"color:#E1E4E8\">(self, sample_header, sample_payload, test_secret_key):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify 'none' algorithm is rejected.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create token with alg: \"none\" in header</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Attempt verification with any secret key</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Assert verification fails with appropriate error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Verify error message doesn't leak algorithm support details</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoints:</strong></p>\n<p><strong>Milestone 1 Checkpoint:</strong>\nRun <code>python -m pytest tests/unit/test_encoding.py -v</code> and verify:</p>\n<ul>\n<li>All Base64URL encoding tests pass</li>\n<li>Token structure assembly creates proper three-segment format  </li>\n<li>Round-trip encoding/decoding preserves data exactly</li>\n<li>No URL-unsafe characters appear in encoded output</li>\n</ul>\n<p><strong>Milestone 2 Checkpoint:</strong><br>Run <code>python -m pytest tests/unit/test_signing.py tests/security/test_timing_attacks.py -v</code> and verify:</p>\n<ul>\n<li>HMAC-SHA256 signatures match RFC test vectors exactly</li>\n<li>Signature verification correctly accepts valid signatures</li>\n<li>Signature verification correctly rejects invalid signatures  </li>\n<li>Timing attack tests show no statistically significant timing differences</li>\n<li>Key strength validation rejects weak keys appropriately</li>\n</ul>\n<p><strong>Milestone 3 Checkpoint:</strong>\nRun <code>python -m pytest tests/unit/test_validation.py tests/integration/test_end_to_end.py -v</code> and verify:</p>\n<ul>\n<li>Time-based claim validation correctly handles expiration and not-before</li>\n<li>Clock skew tolerance works within configured leeway periods</li>\n<li>Issuer and audience validation enforces allowlist restrictions</li>\n<li>Custom claims are extracted and validated correctly</li>\n<li>Complete end-to-end token creation and verification workflow succeeds</li>\n</ul>\n<p><strong>Debugging Tips:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Test Failure Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnostic Steps</th>\n<th>Resolution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Base64URL test failures</td>\n<td>Incorrect character substitution or padding handling</td>\n<td>Print hex dump of encoded bytes, check for +/= characters</td>\n<td>Use URL-safe Base64 alphabet, remove padding correctly</td>\n</tr>\n<tr>\n<td>Timing attack detection</td>\n<td>Non-constant-time comparison implementation</td>\n<td>Add debug timing prints, check for early returns</td>\n<td>Implement proper constant-time algorithm</td>\n</tr>\n<tr>\n<td>RFC vector mismatches</td>\n<td>Incorrect HMAC input or key handling</td>\n<td>Log signing input string and key bytes</td>\n<td>Verify header.payload concatenation and key encoding</td>\n</tr>\n<tr>\n<td>Claims validation errors</td>\n<td>Incorrect timestamp comparison or missing leeway</td>\n<td>Print current time vs claim timestamps with leeway applied</td>\n<td>Check Unix timestamp conversion and arithmetic</td>\n</tr>\n<tr>\n<td>End-to-end failures</td>\n<td>Component integration issues</td>\n<td>Test each component individually, check data flow</td>\n<td>Verify data structures match between components</td>\n</tr>\n</tbody></table>\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All three milestones - debugging techniques for JWT structure issues (Milestone 1), HMAC signing problems (Milestone 2), and claims validation failures (Milestone 3)</p>\n</blockquote>\n<p>Building a secure JWT library involves intricate interactions between encoding, cryptography, and time-sensitive validation logic. Even experienced developers encounter subtle bugs that can compromise security or break authentication flows. This debugging guide provides systematic approaches to diagnose and resolve the most common implementation issues across all three milestones.</p>\n<p><strong>Mental Model: Detective Investigation</strong>: Think of debugging JWT issues like conducting a criminal investigation. You have evidence (error messages, token contents, timestamps), witnesses (logs, test outputs), and a crime scene (the failing code). Your job is to follow the evidence systematically, ruling out innocent suspects (working components) and identifying the real culprit. Just as detectives use forensic tools to analyze evidence, JWT debugging requires specialized tools and techniques to examine token contents, verify signatures, and validate timing assumptions.</p>\n<p>The key insight is that JWT bugs often manifest far from their root cause. A claims validation failure might actually stem from incorrect Base64URL encoding in Milestone 1, or a signature verification problem might be caused by JSON serialization inconsistencies. Effective JWT debugging requires understanding the entire token lifecycle and systematically eliminating possibilities.</p>\n<h3 id=\"encoding-and-parsing-issues\">Encoding and Parsing Issues</h3>\n<p>The JWT structure implementation from Milestone 1 forms the foundation for all token operations. Encoding problems create tokens that appear valid but fail verification in subtle ways. Base64URL encoding and JSON serialization bugs are particularly insidious because they often produce tokens that look correct but contain invisible formatting issues.</p>\n<p><strong>Understanding Base64URL Encoding Failures</strong></p>\n<p>Base64URL encoding differs from standard Base64 in three critical ways: character set replacement, padding removal, and URL safety requirements. The most common mistake is using Python&#39;s standard <code>base64.b64encode()</code> instead of the URL-safe variant, which produces tokens containing <code>+</code> and <code>/</code> characters that break when transmitted in URLs or HTTP headers.</p>\n<p>The <code>base64url_encode()</code> function must handle padding removal correctly. Standard Base64 uses <code>=</code> characters for padding, but Base64URL omits these entirely. Many implementations forget to strip padding after encoding, creating tokens that work locally but fail when processed by other JWT libraries expecting strict Base64URL format.</p>\n<table>\n<thead>\n<tr>\n<th>Encoding Issue</th>\n<th>Symptom</th>\n<th>Root Cause</th>\n<th>Diagnostic Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Wrong character set</td>\n<td>Token contains <code>+</code> or <code>/</code></td>\n<td>Using standard Base64</td>\n<td>Check token content for forbidden characters</td>\n</tr>\n<tr>\n<td>Incorrect padding</td>\n<td>Token ends with <code>=</code> characters</td>\n<td>Not stripping padding</td>\n<td>Examine raw token string</td>\n</tr>\n<tr>\n<td>JSON key ordering</td>\n<td>Inconsistent signatures</td>\n<td>Non-deterministic serialization</td>\n<td>Compare JSON output across runs</td>\n</tr>\n<tr>\n<td>Unicode handling</td>\n<td>Signature verification fails</td>\n<td>Encoding string to bytes incorrectly</td>\n<td>Test with non-ASCII payload content</td>\n</tr>\n<tr>\n<td>Line breaks in output</td>\n<td>Malformed token structure</td>\n<td>Base64 encoding with line wrapping</td>\n<td>Check for <code>\\n</code> characters in encoded parts</td>\n</tr>\n</tbody></table>\n<p><strong>JSON Serialization Consistency Problems</strong></p>\n<p>The <code>serialize_header()</code> and <code>serialize_payload()</code> functions must produce identical JSON output for the same input data across all invocations. Python&#39;s <code>json.dumps()</code> with <code>sort_keys=True</code> ensures consistent key ordering, but developers often forget this parameter, leading to signatures that work sometimes but fail unpredictably.</p>\n<p>Custom claims processing introduces additional serialization challenges. The <code>JWTPayload.custom_claims</code> field contains arbitrary data that must serialize consistently. Nested objects, floating-point numbers, and special values like <code>None</code> can cause serialization inconsistencies that break signature verification.</p>\n<p>Consider a payload containing a custom claim with a floating-point timestamp: <code>{&quot;user_score&quot;: 98.7654321}</code>. Different JSON serializers might produce <code>98.7654321</code> or <code>98.76543210000001</code> due to floating-point precision differences. The <code>serialize_payload()</code> function must handle these edge cases explicitly.</p>\n<p><strong>Token Structure Parsing Failures</strong></p>\n<p>The <code>parse_token_structure()</code> function splits incoming tokens into header, payload, and signature components. Malformed tokens can cause parsing failures that expose internal errors instead of returning appropriate <code>MalformedTokenError</code> exceptions. Common parsing issues include tokens with fewer than three parts, empty parts, or parts containing invalid Base64URL characters.</p>\n<p>Token assembly problems occur when the <code>assemble_token()</code> function incorrectly concatenates encoded parts. The function must join the three parts with exactly one dot character: <code>header.payload.signature</code>. Extra dots, missing dots, or whitespace characters create structurally invalid tokens.</p>\n<blockquote>\n<p><strong>Key Insight</strong>: Base64URL encoding errors often manifest as signature verification failures rather than encoding errors, making them difficult to diagnose. Always verify encoding correctness before investigating cryptographic issues.</p>\n</blockquote>\n<p><strong>⚠️ Pitfall: Silent Encoding Corruption</strong></p>\n<p>The most dangerous encoding bug is silent corruption where <code>base64url_encode()</code> produces output that looks valid but contains subtle errors. This happens when developers implement custom Base64URL encoding incorrectly, producing tokens that pass basic structure validation but fail cryptographic verification.</p>\n<p>To avoid this pitfall, always test your encoding implementation against known reference vectors from the JWT specification. The <code>base64url_decode()</code> function should perfectly round-trip with <code>base64url_encode()</code> for all inputs.</p>\n<h3 id=\"signature-verification-problems\">Signature Verification Problems</h3>\n<p>HMAC-SHA256 signature verification from Milestone 2 involves precise cryptographic operations where small implementation errors create complete security failures. Signature bugs are particularly dangerous because they can allow invalid tokens to appear valid, completely compromising authentication security.</p>\n<p><strong>HMAC Computation Consistency</strong></p>\n<p>The <code>HMACSignerHS256</code> class must produce identical signatures for identical signing inputs across all platforms and execution environments. HMAC computation depends on the exact byte sequence of the signing input, which means any differences in string encoding, JSON serialization, or Base64URL encoding will produce different signatures.</p>\n<p>The most common HMAC bug occurs in the <code>create_signing_input()</code> function when developers accidentally introduce encoding inconsistencies. The signing input must be the exact string <code>encoded_header.encoded_payload</code> with no additional whitespace, encoding transformations, or character substitutions.</p>\n<table>\n<thead>\n<tr>\n<th>Signature Issue</th>\n<th>Symptom</th>\n<th>Root Cause</th>\n<th>Verification Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Key encoding problems</td>\n<td>All signatures fail</td>\n<td>Converting key incorrectly</td>\n<td>Test with known binary key</td>\n</tr>\n<tr>\n<td>String encoding issues</td>\n<td>Inconsistent signatures</td>\n<td>Unicode vs bytes confusion</td>\n<td>Compare byte arrays</td>\n</tr>\n<tr>\n<td>Signing input format</td>\n<td>Verification always fails</td>\n<td>Wrong separator or format</td>\n<td>Print signing input hex</td>\n</tr>\n<tr>\n<td>HMAC library usage</td>\n<td>Cryptographic errors</td>\n<td>Wrong hash algorithm</td>\n<td>Verify SHA256 usage</td>\n</tr>\n<tr>\n<td>Constant-time comparison</td>\n<td>Timing attacks possible</td>\n<td>Using <code>==</code> for signature comparison</td>\n<td>Implement secure comparison</td>\n</tr>\n</tbody></table>\n<p><strong>Secret Key Handling Errors</strong></p>\n<p>The <code>SecureKeyHandler</code> class manages cryptographic keys that must meet specific security requirements. The <code>validate_key_strength()</code> function enforces a minimum key length of 32 bytes, but developers often provide keys as strings without considering encoding implications.</p>\n<p>When a key is provided as a UTF-8 string, it must be encoded to bytes using consistent encoding. Different encoding choices (UTF-8, Latin-1, ASCII) produce different byte sequences, leading to different HMAC signatures. The key handling system must document and enforce its encoding expectations clearly.</p>\n<p>Key generation using <code>generate_secure_key()</code> must produce cryptographically random bytes suitable for HMAC operations. Using predictable key generation methods or insufficient entropy sources creates keys that appear to work but provide no security against determined attackers.</p>\n<p><strong>Constant-Time Comparison Implementation</strong></p>\n<p>The <code>constant_time_compare()</code> function prevents timing side-channel attacks by ensuring signature comparison takes the same amount of time regardless of input differences. Naive implementations using Python&#39;s <code>==</code> operator leak timing information that allows attackers to forge signatures.</p>\n<p>A secure constant-time comparison must process every byte of both signatures even when early differences are detected. The comparison must also handle length differences securely, avoiding early returns that leak length information.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># WRONG - leaks timing information</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> insecure_compare</span><span style=\"color:#E1E4E8\">(a, b):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> a </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> b  </span><span style=\"color:#6A737D\"># Early termination on first difference</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># CORRECT - constant time for same-length inputs</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> constant_time_compare</span><span style=\"color:#E1E4E8\">(a, b):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(a) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(b):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> x, y </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> zip</span><span style=\"color:#E1E4E8\">(a, b):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">|=</span><span style=\"color:#79B8FF\"> ord</span><span style=\"color:#E1E4E8\">(x) </span><span style=\"color:#F97583\">^</span><span style=\"color:#79B8FF\"> ord</span><span style=\"color:#E1E4E8\">(y)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span></span></code></pre></div>\n\n<p><strong>Signature Format and Encoding</strong></p>\n<p>The <code>sign()</code> method must produce Base64URL-encoded signatures that match the JWT specification exactly. HMAC-SHA256 produces 32-byte binary signatures that must be encoded using the same Base64URL rules applied to header and payload sections.</p>\n<p>Signature verification in the <code>verify()</code> method must decode the provided signature back to binary form before comparison. Base64URL decoding errors indicate malformed tokens that should trigger appropriate error handling rather than cryptographic failures.</p>\n<blockquote>\n<p><strong>Key Insight</strong>: Signature verification bugs often appear as intermittent failures that work in development but fail in production due to environment differences in string encoding, JSON serialization, or cryptographic library versions.</p>\n</blockquote>\n<p><strong>⚠️ Pitfall: Algorithm Confusion Attacks</strong></p>\n<p>A critical security vulnerability occurs when the signature verification process doesn&#39;t validate that the token&#39;s algorithm claim matches the expected algorithm. An attacker can change the <code>alg</code> header field from <code>HS256</code> to <code>none</code> or a public-key algorithm, potentially bypassing signature verification entirely.</p>\n<p>The verification process must explicitly check that the header contains <code>&quot;alg&quot;: &quot;HS256&quot;</code> before attempting HMAC verification. Tokens with unexpected algorithm values should be rejected immediately.</p>\n<h3 id=\"claims-validation-issues\">Claims Validation Issues</h3>\n<p>Claims validation from Milestone 3 involves time-sensitive logic that interacts with system clocks, timezone handling, and application-specific business rules. Time-based validation is particularly error-prone because it depends on external factors like server time synchronization and clock skew between systems.</p>\n<p><strong>Time-Based Validation Complexity</strong></p>\n<p>The <code>TimeValidator</code> class handles expiration (<code>exp</code>), not-before (<code>nbf</code>), and issued-at (<code>iat</code>) claims that depend on accurate time comparison. Clock skew between token-issuing and token-validating systems can cause valid tokens to be rejected or expired tokens to be accepted.</p>\n<p>The <code>DEFAULT_LEEWAY_SECONDS</code> constant provides a 300-second tolerance window for clock skew, but applications with strict security requirements might need shorter leeway periods. Conversely, distributed systems with poor time synchronization might require longer leeway periods.</p>\n<p>Time validation bugs often manifest as tokens that work in development but fail in production due to deployment time differences. The <code>utc_now()</code> function must return UTC timestamps consistently across all environments, avoiding timezone-related issues that cause validation failures.</p>\n<table>\n<thead>\n<tr>\n<th>Validation Issue</th>\n<th>Symptom</th>\n<th>Root Cause</th>\n<th>Debugging Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Clock skew problems</td>\n<td>Valid tokens rejected</td>\n<td>Time differences between servers</td>\n<td>Compare server timestamps</td>\n</tr>\n<tr>\n<td>Timezone confusion</td>\n<td>Intermittent validation failures</td>\n<td>Mixing UTC and local time</td>\n<td>Standardize on UTC everywhere</td>\n</tr>\n<tr>\n<td>Leeway configuration</td>\n<td>Unexpected expiration behavior</td>\n<td>Wrong leeway period</td>\n<td>Test with known timestamps</td>\n</tr>\n<tr>\n<td>Missing claims</td>\n<td>Required claims not validated</td>\n<td>Incomplete validation logic</td>\n<td>Check claim presence explicitly</td>\n</tr>\n<tr>\n<td>Audience format</td>\n<td>Audience validation fails</td>\n<td>String vs array confusion</td>\n<td>Handle both audience formats</td>\n</tr>\n</tbody></table>\n<p><strong>Identity Validation Edge Cases</strong></p>\n<p>The <code>IdentityValidator</code> class verifies issuer (<code>iss</code>) and audience (<code>aud</code>) claims against application-specific allowlists. Issuer validation must perform exact string matching against the <code>allowed_issuers</code> list, but case sensitivity and whitespace handling can cause validation failures for otherwise valid tokens.</p>\n<p>Audience validation is complicated by the JWT specification&#39;s allowance for both string and array formats. A token might contain <code>&quot;aud&quot;: &quot;api.example.com&quot;</code> or <code>&quot;aud&quot;: [&quot;api.example.com&quot;, &quot;mobile.example.com&quot;]</code>. The validation logic must handle both formats correctly while matching against the expected audience value.</p>\n<p>Custom claims processing in the <code>CustomClaimsValidator</code> introduces application-specific validation logic that can fail in unexpected ways. Custom claims might contain nested objects, arrays, or special values that require careful validation to prevent security issues or application errors.</p>\n<p><strong>Missing Required Claims Handling</strong></p>\n<p>The <code>ValidationContext.required_claims</code> field specifies claims that must be present in every token. The <code>MissingRequiredClaimError</code> exception should provide specific information about which claims are missing to aid in debugging, but without leaking sensitive information in error messages.</p>\n<p>Required claims validation must distinguish between claims that are missing entirely and claims that are present but invalid. A token with an empty <code>sub</code> field might satisfy presence requirements but fail business logic validation, requiring different error handling approaches.</p>\n<p><strong>Validation Context Configuration</strong></p>\n<p>The <code>create_strict_context()</code>, <code>create_permissive_context()</code>, and <code>create_custom_context()</code> functions create validation configurations for different security requirements. Strict contexts reject tokens with any validation issues, while permissive contexts might allow missing optional claims or longer leeway periods.</p>\n<p>Configuration bugs often appear when development uses permissive validation but production requires strict validation, causing tokens that work in testing to fail in production. Validation context settings should be explicitly documented and tested across all deployment environments.</p>\n<blockquote>\n<p><strong>Key Insight</strong>: Claims validation failures often indicate configuration mismatches between token issuers and validators rather than implementation bugs. Always verify that validation context settings match the security requirements of your deployment environment.</p>\n</blockquote>\n<p><strong>⚠️ Pitfall: Temporal Edge Cases</strong></p>\n<p>Time-based validation becomes unreliable around edge cases like leap seconds, daylight saving time transitions, and system clock adjustments. The <code>is_expired()</code> and <code>is_not_before()</code> functions must handle these edge cases gracefully without creating security vulnerabilities.</p>\n<p>A particularly dangerous edge case occurs when system clocks move backward due to NTP synchronization or manual adjustment. Tokens that were expired before the clock adjustment might become valid again, potentially allowing replay attacks or privilege escalation.</p>\n<h3 id=\"debugging-tools-and-techniques\">Debugging Tools and Techniques</h3>\n<p>Effective JWT debugging requires a combination of specialized tools, systematic diagnostic procedures, and deep understanding of the token format and validation process. The debugging process should progress from high-level token structure validation to detailed cryptographic and claims analysis.</p>\n<p><strong>JWT.io Debugger Integration</strong></p>\n<p>The JWT.io online debugger provides immediate visual feedback about token structure, claims, and signature validation. When debugging JWT library issues, always paste problematic tokens into JWT.io to verify basic structure and content before investigating implementation-specific problems.</p>\n<p>The debugger shows the decoded header and payload in human-readable JSON format, making it easy to spot encoding issues, malformed claims, or unexpected content. The signature verification section can validate signatures using provided secrets, helping isolate whether problems lie in token generation or verification logic.</p>\n<p>However, JWT.io has limitations for debugging production issues. Never paste production tokens containing sensitive information into online tools. Instead, create test tokens with similar structure but fake data to verify behavior without security risks.</p>\n<p><strong>Systematic Diagnostic Procedures</strong></p>\n<p>JWT debugging should follow a structured process that eliminates possibilities systematically rather than randomly trying fixes. Start with basic structural validation before moving to cryptographic or claims-specific issues.</p>\n<table>\n<thead>\n<tr>\n<th>Debug Phase</th>\n<th>Validation Steps</th>\n<th>Tools Required</th>\n<th>Success Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Structure Check</td>\n<td>Token contains three dot-separated parts</td>\n<td>String splitting, length validation</td>\n<td>Exactly 3 non-empty parts</td>\n</tr>\n<tr>\n<td>Encoding Check</td>\n<td>Each part uses valid Base64URL</td>\n<td>Base64URL decoder</td>\n<td>No decoding errors</td>\n</tr>\n<tr>\n<td>Header Validation</td>\n<td>Header contains required algorithm</td>\n<td>JSON parser</td>\n<td>Valid <code>alg</code> and <code>typ</code> fields</td>\n</tr>\n<tr>\n<td>Payload Validation</td>\n<td>Payload contains expected claims</td>\n<td>JSON parser, schema validator</td>\n<td>Required claims present</td>\n</tr>\n<tr>\n<td>Signature Check</td>\n<td>Signature matches computed value</td>\n<td>HMAC computation</td>\n<td>Signatures match exactly</td>\n</tr>\n<tr>\n<td>Claims Validation</td>\n<td>Time and identity claims valid</td>\n<td>System clock, configuration</td>\n<td>All validations pass</td>\n</tr>\n</tbody></table>\n<p><strong>Self-Verification Techniques</strong></p>\n<p>The most powerful debugging technique for JWT libraries is self-verification: creating a token with your library and immediately verifying it with the same library. This round-trip test exposes encoding inconsistencies, serialization problems, and configuration issues without involving external systems.</p>\n<p>Self-verification should test edge cases like tokens with maximum allowed payload sizes, tokens with all possible claim types, and tokens created at boundary times (just before expiration, exactly at not-before time). These tests reveal issues that might not appear with simple happy-path testing.</p>\n<p><strong>Error Context and Information Disclosure</strong></p>\n<p>Production JWT libraries must balance debugging information with security requirements. The <code>ValidationFailureContext</code> class provides structured error information that can be logged securely while providing sanitized error messages to external callers.</p>\n<p>Debug logging should adapt to the <code>SecurityContext</code> environment variable, providing detailed information in development and audit environments while limiting information disclosure in production. The <code>log_validation_failure()</code> function should never log secret keys, full token contents, or other sensitive information that could compromise security.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_debug_context</span><span style=\"color:#E1E4E8\">(failure_type, component, operation):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> os.getenv(</span><span style=\"color:#9ECBFF\">'SECURITY_CONTEXT'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> SecurityContext.</span><span style=\"color:#79B8FF\">DEVELOPMENT</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> ValidationFailureContext(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            component</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">component,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            operation</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">operation,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            failure_type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">failure_type,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            severity</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">ErrorSeverity.</span><span style=\"color:#79B8FF\">HIGH</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            debug_info</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"full_details\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            safe_message</span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Detailed error in </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">component</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">operation</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> ValidationFailureContext(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            component</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">component,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            operation</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">operation,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            failure_type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">failure_type,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            severity</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">ErrorSeverity.</span><span style=\"color:#79B8FF\">HIGH</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            debug_info</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{},</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            safe_message</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"Authentication token validation failed\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span></code></pre></div>\n\n<p><strong>Reference Test Vector Validation</strong></p>\n<p>The JWT specification includes reference test vectors with known inputs and expected outputs for each operation. Implementing these test vectors as part of your debugging process ensures that your library produces specification-compliant results.</p>\n<p>Reference vectors should cover all supported algorithms, claim types, and edge cases. When debugging cryptographic issues, compare your HMAC computation results with reference vectors to isolate whether problems lie in key handling, signing input generation, or signature computation.</p>\n<p><strong>Performance and Timing Analysis</strong></p>\n<p>JWT libraries must balance security with performance, particularly in high-throughput applications. Debugging performance issues requires understanding the computational cost of each validation step and identifying bottlenecks that might indicate implementation problems.</p>\n<p>The <code>constant_time_compare()</code> function should complete in consistent time regardless of input differences, but other validation steps can vary significantly based on token content and validation context. Time-based claims validation should be nearly instantaneous, while complex custom claims processing might require more computational resources.</p>\n<p><strong>⚠️ Pitfall: Production Debugging Without Security Context</strong></p>\n<p>The most dangerous debugging mistake is enabling detailed error logging in production without considering information disclosure risks. Debug logs containing token contents, secret keys, or detailed validation failure reasons can expose sensitive information to attackers.</p>\n<p>Always implement security-aware logging that provides detailed information in development environments but sanitized error messages in production. Use structured logging with appropriate log levels to ensure sensitive debugging information doesn&#39;t reach unauthorized log consumers.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>Building robust debugging capabilities into your JWT library requires careful instrumentation and structured error handling that provides useful diagnostic information without compromising security.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Logging</td>\n<td>Python <code>logging</code> module</td>\n<td><code>structlog</code> with JSON output</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Standard exceptions</td>\n<td>Custom exception hierarchy</td>\n</tr>\n<tr>\n<td>Testing</td>\n<td><code>unittest</code> with manual vectors</td>\n<td><code>pytest</code> with parameterized tests</td>\n</tr>\n<tr>\n<td>Time Handling</td>\n<td><code>datetime</code> module</td>\n<td><code>arrow</code> or <code>pendulum</code> for advanced cases</td>\n</tr>\n<tr>\n<td>Debug Output</td>\n<td>Print statements</td>\n<td>Structured logging with context</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>jwt-library/\n  src/jwt_library/\n    core/\n      __init__.py\n      encoder.py              ← Token encoding (Milestone 1)\n      signer.py              ← HMAC signing (Milestone 2)\n      validator.py           ← Claims validation (Milestone 3)\n    exceptions/\n      __init__.py\n      base.py                ← Base exception classes\n      validation.py          ← Validation-specific exceptions\n      structural.py          ← Structure and encoding exceptions\n    debug/\n      __init__.py\n      diagnostics.py         ← Debugging utilities\n      test_vectors.py        ← Reference test cases\n      tools.py              ← Debug helper functions\n  tests/\n    unit/\n      test_encoding.py       ← Milestone 1 tests\n      test_signing.py        ← Milestone 2 tests\n      test_validation.py     ← Milestone 3 tests\n    integration/\n      test_end_to_end.py     ← Complete workflows\n      test_debugging.py      ← Debug scenario tests\n    vectors/\n      rfc_test_vectors.py    ← Official specification tests</code></pre></div>\n\n<p><strong>Debug Utilities Infrastructure Code:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Debug utilities for JWT library diagnostics and troubleshooting.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Copy this code as-is and import the functions you need.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hashlib</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> binascii</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timezone</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Any, Optional, Union</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ErrorSeverity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CRITICAL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"critical\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    HIGH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"high\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MEDIUM</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"medium\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LOW</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"low\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SecurityContext</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DEVELOPMENT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"development\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PRODUCTION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"production\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AUDIT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"audit\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ValidationFailureContext</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    component: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    operation: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    failure_type: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    severity: ErrorSeverity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    debug_info: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    safe_message: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_safe_message</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return external-safe error message without sensitive details.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.safe_message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_debug_info</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return internal diagnostic information for logging.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.debug_info</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> log_validation_failure</span><span style=\"color:#E1E4E8\">(context: ValidationFailureContext):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Security-aware error logging that adapts to deployment context.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    import</span><span style=\"color:#E1E4E8\"> os</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#9ECBFF\">\"jwt_library.debug\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    security_context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> os.getenv(</span><span style=\"color:#9ECBFF\">'SECURITY_CONTEXT'</span><span style=\"color:#E1E4E8\">, SecurityContext.</span><span style=\"color:#79B8FF\">PRODUCTION</span><span style=\"color:#E1E4E8\">.value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> security_context </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> SecurityContext.</span><span style=\"color:#79B8FF\">DEVELOPMENT</span><span style=\"color:#E1E4E8\">.value:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger.error(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            f</span><span style=\"color:#9ECBFF\">\"JWT validation failure: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">context.component</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">context.operation</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> - \"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">context.failure_type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> - Debug info: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">context.debug_info</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    elif</span><span style=\"color:#E1E4E8\"> security_context </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> SecurityContext.</span><span style=\"color:#79B8FF\">AUDIT</span><span style=\"color:#E1E4E8\">.value:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger.warning(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            f</span><span style=\"color:#9ECBFF\">\"JWT validation failure: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">context.component</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">context.operation</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> - \"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">context.failure_type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> - Severity: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">context.severity.value</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#6A737D\"># PRODUCTION</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger.info(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Authentication validation failed - </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">context.safe_message</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_base64url_format</span><span style=\"color:#E1E4E8\">(data: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, part_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validate Base64URL character set and format.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Base64URL uses A-Z, a-z, 0-9, -, _ (no padding)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    base64url_pattern </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> re.compile(</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">^[A-Za-z0-9_-]</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">$</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> base64url_pattern.match(data):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        invalid_chars </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> set</span><span style=\"color:#E1E4E8\">(data) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Invalid characters in </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">part_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">invalid_chars</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#9ECBFF\"> '='</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> data:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Base64URL </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">part_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> should not contain padding characters\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> diagnose_token_structure</span><span style=\"color:#E1E4E8\">(token: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Comprehensive token structure analysis for debugging.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    diagnosis </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"valid_structure\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"part_count\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"parts_analysis\"</span><span style=\"color:#E1E4E8\">: {},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"encoding_issues\"</span><span style=\"color:#E1E4E8\">: [],</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"recommendations\"</span><span style=\"color:#E1E4E8\">: []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Basic structure check</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parts </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> token.split(</span><span style=\"color:#9ECBFF\">'.'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    diagnosis[</span><span style=\"color:#9ECBFF\">\"part_count\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(parts)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(parts) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        diagnosis[</span><span style=\"color:#9ECBFF\">\"recommendations\"</span><span style=\"color:#E1E4E8\">].append(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            f</span><span style=\"color:#9ECBFF\">\"Expected 3 parts, found </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(parts)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">. JWT format is header.payload.signature\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> diagnosis</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Analyze each part</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    part_names </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">\"header\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"payload\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"signature\"</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, (part, name) </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> enumerate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">zip</span><span style=\"color:#E1E4E8\">(parts, part_names)):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        analysis </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"length\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(part),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"empty\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(part) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"base64url_valid\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"content\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(part) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            diagnosis[</span><span style=\"color:#9ECBFF\">\"encoding_issues\"</span><span style=\"color:#E1E4E8\">].append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Empty </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> part\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Check Base64URL format</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            validate_base64url_format(part, name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            analysis[</span><span style=\"color:#9ECBFF\">\"base64url_valid\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            diagnosis[</span><span style=\"color:#9ECBFF\">\"encoding_issues\"</span><span style=\"color:#E1E4E8\">].append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{str</span><span style=\"color:#E1E4E8\">(e)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Try to decode content (header and payload only)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> analysis[</span><span style=\"color:#9ECBFF\">\"base64url_valid\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#6A737D\"># Skip signature decoding</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                from</span><span style=\"color:#E1E4E8\"> jwt_library.core.encoder </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> base64url_decode</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                decoded </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> base64url_decode(part)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#6A737D\"># Header and payload are JSON</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    analysis[</span><span style=\"color:#9ECBFF\">\"content\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> json.loads(decoded.decode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                diagnosis[</span><span style=\"color:#9ECBFF\">\"encoding_issues\"</span><span style=\"color:#E1E4E8\">].append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> decoding failed: </span><span style=\"color:#79B8FF\">{str</span><span style=\"color:#E1E4E8\">(e)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        diagnosis[</span><span style=\"color:#9ECBFF\">\"parts_analysis\"</span><span style=\"color:#E1E4E8\">][name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> analysis</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    diagnosis[</span><span style=\"color:#9ECBFF\">\"valid_structure\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(diagnosis[</span><span style=\"color:#9ECBFF\">\"encoding_issues\"</span><span style=\"color:#E1E4E8\">]) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> diagnosis</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> compare_hmac_signatures</span><span style=\"color:#E1E4E8\">(expected: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, actual: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, signing_input: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, key: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Detailed HMAC signature comparison for debugging.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    import</span><span style=\"color:#E1E4E8\"> hmac</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    comparison </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"signatures_match\"</span><span style=\"color:#E1E4E8\">: expected </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> actual,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"expected_signature\"</span><span style=\"color:#E1E4E8\">: expected,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"actual_signature\"</span><span style=\"color:#E1E4E8\">: actual,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"signing_input_length\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(signing_input),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"signing_input_hash\"</span><span style=\"color:#E1E4E8\">: hashlib.sha256(signing_input.encode()).hexdigest()[:</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"key_length\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(key),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"key_hash\"</span><span style=\"color:#E1E4E8\">: hashlib.sha256(key).hexdigest()[:</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"recomputed_signature\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Recompute signature independently</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        signature_bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hmac.new(key, signing_input.encode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">), hashlib.sha256).digest()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        from</span><span style=\"color:#E1E4E8\"> jwt_library.core.encoder </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> base64url_encode</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        recomputed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> base64url_encode(signature_bytes)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        comparison[</span><span style=\"color:#9ECBFF\">\"recomputed_signature\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> recomputed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        comparison[</span><span style=\"color:#9ECBFF\">\"recomputation_matches_expected\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (recomputed </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> expected)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        comparison[</span><span style=\"color:#9ECBFF\">\"recomputation_matches_actual\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (recomputed </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> actual)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        comparison[</span><span style=\"color:#9ECBFF\">\"recomputation_error\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> str</span><span style=\"color:#E1E4E8\">(e)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> comparison</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> analyze_time_claims</span><span style=\"color:#E1E4E8\">(payload: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any], leeway_seconds: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 300</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Analyze time-based claims for debugging validation issues.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    now </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">(time.time())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    analysis </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"current_timestamp\"</span><span style=\"color:#E1E4E8\">: now,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"current_datetime\"</span><span style=\"color:#E1E4E8\">: datetime.fromtimestamp(now, </span><span style=\"color:#FFAB70\">tz</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">timezone.utc).isoformat(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"leeway_seconds\"</span><span style=\"color:#E1E4E8\">: leeway_seconds,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"claims_analysis\"</span><span style=\"color:#E1E4E8\">: {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    time_claims </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">\"exp\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"nbf\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"iat\"</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> claim </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> time_claims:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> claim </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> payload:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            claim_value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> payload[claim]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            claim_analysis </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"value\"</span><span style=\"color:#E1E4E8\">: claim_value,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"datetime\"</span><span style=\"color:#E1E4E8\">: datetime.fromtimestamp(claim_value, </span><span style=\"color:#FFAB70\">tz</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">timezone.utc).isoformat(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"seconds_from_now\"</span><span style=\"color:#E1E4E8\">: claim_value </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> now,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"within_leeway\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">abs</span><span style=\"color:#E1E4E8\">(claim_value </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> now) </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> leeway_seconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> claim </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"exp\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                claim_analysis[</span><span style=\"color:#9ECBFF\">\"is_expired\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> claim_value </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> (now </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> leeway_seconds)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            elif</span><span style=\"color:#E1E4E8\"> claim </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"nbf\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                claim_analysis[</span><span style=\"color:#9ECBFF\">\"is_future\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> claim_value </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> (now </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> leeway_seconds)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            elif</span><span style=\"color:#E1E4E8\"> claim </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"iat\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                claim_analysis[</span><span style=\"color:#9ECBFF\">\"is_reasonable\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">86400</span><span style=\"color:#F97583\"> &#x3C;=</span><span style=\"color:#E1E4E8\"> (claim_value </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> now) </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> leeway_seconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            analysis[</span><span style=\"color:#9ECBFF\">\"claims_analysis\"</span><span style=\"color:#E1E4E8\">][claim] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> claim_analysis</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            analysis[</span><span style=\"color:#9ECBFF\">\"claims_analysis\"</span><span style=\"color:#E1E4E8\">][claim] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">\"present\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> analysis</span></span></code></pre></div>\n\n<p><strong>Core Debugging Function Skeletons:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> debug_token_creation</span><span style=\"color:#E1E4E8\">(header: JWTHeader, payload: JWTPayload, secret_key: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Comprehensive debugging for token creation process.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns detailed information about each step in token generation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    debug_info </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">\"steps\"</span><span style=\"color:#E1E4E8\">: [], </span><span style=\"color:#9ECBFF\">\"intermediate_values\"</span><span style=\"color:#E1E4E8\">: {}, </span><span style=\"color:#9ECBFF\">\"final_result\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Record header serialization and encoding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Store serialized JSON, Base64URL encoded result, any encoding issues</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Record payload serialization and encoding  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Store serialized JSON, Base64URL encoded result, custom claims handling</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Record signing input creation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Store exact signing input string, length, character encoding</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Record HMAC computation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Store signature bytes (hex), Base64URL encoded signature, key validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Record final token assembly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Store assembled token, part lengths, structure validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Perform self-verification test</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Try to verify the created token immediately, record any failures</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> debug_info</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> debug_token_verification</span><span style=\"color:#E1E4E8\">(token: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, secret_key: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, context: ValidationContext) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Step-by-step debugging for token verification process.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns detailed information about each validation step.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    debug_info </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">\"validation_steps\"</span><span style=\"color:#E1E4E8\">: [], </span><span style=\"color:#9ECBFF\">\"failures\"</span><span style=\"color:#E1E4E8\">: [], </span><span style=\"color:#9ECBFF\">\"context\"</span><span style=\"color:#E1E4E8\">: context}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Analyze token structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Use diagnose_token_structure() to check basic format</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Debug signature verification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Extract signature, recompute, compare with detailed logging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Debug claims validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Check each claim type with analyze_time_claims() and identity validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Record validation context effects</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Show how leeway, required claims, etc. affect validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Provide specific recommendations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Based on failures found, suggest concrete fixes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> debug_info</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_test_scenarios</span><span style=\"color:#E1E4E8\">() -> List[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Generate comprehensive test scenarios for debugging various failure modes.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns list of test cases with expected outcomes.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    scenarios </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create encoding failure scenarios</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Tokens with Base64URL issues, JSON problems, structure errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create signature failure scenarios  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Wrong keys, algorithm confusion, timing attack tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create claims validation scenarios</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Expired tokens, future tokens, missing claims, wrong audience</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create edge case scenarios</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Clock skew, leap seconds, maximum sizes, Unicode content</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> scenarios</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoints:</strong></p>\n<p><strong>After Milestone 1 (JWT Structure):</strong></p>\n<ul>\n<li>Run <code>python -m jwt_library.debug.diagnostics</code> with test tokens</li>\n<li>Expected: Clean structure analysis with no encoding issues</li>\n<li>Verify: <code>diagnose_token_structure()</code> returns <code>valid_structure: True</code> for your tokens</li>\n<li>Debug: If structure fails, check Base64URL character set and padding removal</li>\n</ul>\n<p><strong>After Milestone 2 (HMAC Signing):</strong></p>\n<ul>\n<li>Use <code>compare_hmac_signatures()</code> to verify signature computation</li>\n<li>Expected: All three signature values (expected, actual, recomputed) match exactly</li>\n<li>Verify: Self-verification test passes when creating and immediately verifying tokens</li>\n<li>Debug: If signatures differ, check signing input format and key encoding</li>\n</ul>\n<p><strong>After Milestone 3 (Claims Validation):</strong></p>\n<ul>\n<li>Test <code>analyze_time_claims()</code> with tokens at various time boundaries</li>\n<li>Expected: Time-based validations respect leeway settings correctly</li>\n<li>Verify: Expired and future tokens are rejected appropriately</li>\n<li>Debug: If time validation fails, check system clock and leeway configuration</li>\n</ul>\n<h2 id=\"future-extensions\">Future Extensions</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundation for extending beyond all three milestones - demonstrates how the JWT structure (Milestone 1), HMAC signing (Milestone 2), and claims validation (Milestone 3) components provide an extensible foundation for advanced features</p>\n</blockquote>\n<p>The JWT library architecture we&#39;ve designed provides a solid foundation for stateless authentication, but real-world applications often demand capabilities beyond basic HMAC-SHA256 signing and standard claims validation. Understanding how to extend the library while maintaining security and architectural integrity is crucial for evolving authentication systems. This section explores three major extension categories: additional cryptographic algorithms, performance optimizations, and advanced JWT features that enterprise applications commonly require.</p>\n<h3 id=\"mental-model-the-security-toolkit-evolution\">Mental Model: The Security Toolkit Evolution</h3>\n<p>Think of our JWT library as a master locksmith&#39;s toolkit that starts with essential tools but grows over time. Initially, the toolkit contains reliable basics: a sturdy key cutter (HMAC-SHA256 signing), measuring tools (claims validation), and assembly equipment (token encoding). As the locksmith encounters more sophisticated security challenges, they add specialized tools: precision instruments for delicate work (RSA signatures), high-speed equipment for volume operations (token caching), and advanced mechanisms for complex scenarios (key rotation systems). Each new tool integrates with the existing toolkit&#39;s foundation, sharing common principles while adding specialized capabilities. The locksmith doesn&#39;t replace their reliable basics—they enhance them with complementary tools that work together seamlessly.</p>\n<p>This evolution mirrors how JWT libraries expand. The core encoding, signing, and validation components remain unchanged, but new algorithm implementations, optimization layers, and advanced features integrate through well-defined interfaces. The architecture accommodates growth while preserving the security properties and design principles that make the foundation trustworthy.</p>\n<h3 id=\"extension-architecture-principles\">Extension Architecture Principles</h3>\n<p>Before examining specific extensions, we must establish architectural principles that guide library evolution. These principles ensure that new features enhance rather than compromise the existing security model.</p>\n<p><strong>Interface Stability</strong>: The core <code>create_token</code> and <code>verify_token</code> functions maintain their signatures as the primary library interface. Extensions add new optional parameters or configuration objects rather than breaking existing integrations. This stability protects applications that depend on the library while enabling access to new capabilities.</p>\n<p><strong>Security Layering</strong>: Each extension operates within the security boundaries established by the core architecture. Algorithm implementations cannot bypass signature verification, performance optimizations cannot weaken cryptographic properties, and advanced features cannot introduce timing vulnerabilities. The security context and constant-time comparison principles apply to all extensions.</p>\n<p><strong>Component Isolation</strong>: Extensions integrate through well-defined interfaces without modifying core component internals. New signature algorithms implement standardized signer interfaces, performance enhancements operate as transparent middleware layers, and advanced features compose existing validation logic rather than replacing it.</p>\n<blockquote>\n<p><strong>Design Principle: Backward Compatibility</strong></p>\n<p>Extensions must never break existing applications. A JWT created with basic HMAC-SHA256 signing continues to verify correctly even after RSA algorithm support is added. Configuration changes enable new features without affecting default behavior.</p>\n</blockquote>\n<h3 id=\"additional-signature-algorithms\">Additional Signature Algorithms</h3>\n<p>The HMAC-SHA256 implementation provides a solid foundation for symmetric key authentication, but production systems often require asymmetric cryptography for distributed verification scenarios. Public key algorithms like RSA and ECDSA enable token verification without sharing secret keys, while different hash functions provide varying security and performance characteristics.</p>\n<h4 id=\"mental-model-document-authentication-methods\">Mental Model: Document Authentication Methods</h4>\n<p>Consider how important documents are authenticated in the physical world. A notary&#39;s seal (symmetric authentication) requires the same seal to create and verify signatures, limiting verification to parties who possess the physical seal. In contrast, a government official&#39;s signature (asymmetric authentication) can be verified by anyone who knows the official&#39;s handwriting patterns, without needing access to the official themselves. The verification process uses public knowledge (the signature style) while the creation process requires private knowledge (the actual ability to sign).</p>\n<p>JWT signature algorithms follow this same pattern. HMAC requires the same secret key for signing and verification, like sharing a notary seal between services. RSA uses a private key for signing but allows verification with a public key, enabling distributed verification without sharing sensitive material. ECDSA provides similar asymmetric properties with different mathematical foundations that offer performance and security trade-offs.</p>\n<h4 id=\"rsa-signature-implementation-rs256\">RSA Signature Implementation (RS256)</h4>\n<p>RSA with SHA-256 (RS256) provides asymmetric signing capabilities that enable distributed token verification. Unlike HMAC&#39;s shared secret approach, RS256 uses a private key for signing and a public key for verification, allowing multiple services to verify tokens without accessing signing credentials.</p>\n<p><strong>Algorithm Architecture</strong>: The RS256 implementation follows the same signer interface as <code>HMACSignerHS256</code>, ensuring seamless integration with existing token creation workflows. The core difference lies in key management and signature computation, not in the overall signing process.</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Responsibility</th>\n<th>Key Differences from HMAC</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>RSASignerRS256</code></td>\n<td>Private key signing operations</td>\n<td>Uses RSA private key instead of symmetric secret</td>\n</tr>\n<tr>\n<td><code>RSAVerifierRS256</code></td>\n<td>Public key verification operations</td>\n<td>Separate verifier class using public key</td>\n</tr>\n<tr>\n<td><code>RSAKeyHandler</code></td>\n<td>RSA key pair management and validation</td>\n<td>Handles key generation, storage, and public key distribution</td>\n</tr>\n<tr>\n<td><code>PKCS1v15Padding</code></td>\n<td>RSA signature padding implementation</td>\n<td>Implements PKCS#1 v1.5 padding for signature security</td>\n</tr>\n</tbody></table>\n<p><strong>Key Management Complexity</strong>: RSA introduces significantly more complex key management requirements compared to HMAC&#39;s simple shared secrets. Private keys require secure storage with appropriate file permissions and potential hardware security module (HSM) integration. Public keys need reliable distribution mechanisms to verification services, often through certificate authorities or secure key distribution systems.</p>\n<p><strong>Signature Generation Process</strong>:</p>\n<ol>\n<li>The RSA signer receives the signing input string (encoded header and payload)</li>\n<li>It computes a SHA-256 hash of the signing input</li>\n<li>The hash undergoes PKCS#1 v1.5 padding to reach the RSA key size</li>\n<li>The padded hash is encrypted with the RSA private key to produce the signature</li>\n<li>The signature is encoded using Base64URL for inclusion in the JWT token</li>\n</ol>\n<p><strong>Verification Process Modifications</strong>:</p>\n<ol>\n<li>The verifier extracts the signature from the JWT token</li>\n<li>It decodes the signature from Base64URL to binary format</li>\n<li>The signature is decrypted using the RSA public key to recover the padded hash</li>\n<li>PKCS#1 v1.5 padding is removed and validated</li>\n<li>The recovered hash is compared against a freshly computed SHA-256 of the signing input</li>\n<li>Hash equality confirms signature validity</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Separate Signer and Verifier Classes for RSA</strong></p>\n<ul>\n<li><strong>Context</strong>: RSA requires different keys for signing and verification operations, unlike HMAC&#39;s single shared secret</li>\n<li><strong>Options Considered</strong>: Combined class with both keys, separate signer/verifier classes, or factory pattern with key type detection</li>\n<li><strong>Decision</strong>: Implement separate <code>RSASignerRS256</code> and <code>RSAVerifierRS256</code> classes</li>\n<li><strong>Rationale</strong>: Separation follows the principle of least privilege—verification services never receive private keys. It also simplifies key management and reduces the attack surface for each component</li>\n<li><strong>Consequences</strong>: Slightly more complex initialization code, but much better security isolation and clearer component responsibilities</li>\n</ul>\n</blockquote>\n<h4 id=\"ecdsa-implementation-es256\">ECDSA Implementation (ES256)</h4>\n<p>Elliptic Curve Digital Signature Algorithm with P-256 curve and SHA-256 (ES256) provides asymmetric authentication with smaller key sizes and potentially better performance than RSA. ECDSA signatures are probabilistic, producing different signature values for the same input, but all valid signatures verify correctly.</p>\n<p><strong>Mathematical Foundation</strong>: ECDSA operates on elliptic curve mathematics rather than RSA&#39;s large integer factorization. This enables equivalent security levels with much smaller keys—a 256-bit ECDSA key provides roughly the same security as a 3072-bit RSA key, resulting in smaller tokens and faster operations.</p>\n<p><strong>Signature Variability</strong>: Unlike RSA and HMAC signatures that are deterministic (same input always produces the same signature), ECDSA signatures incorporate randomness. Each signing operation produces a different signature value, but all signatures for the same input verify as valid. This property requires careful testing to ensure verification works correctly with signature variability.</p>\n<table>\n<thead>\n<tr>\n<th>ECDSA Component</th>\n<th>Functionality</th>\n<th>Unique Characteristics</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ECDSASignerES256</code></td>\n<td>P-256 curve signing</td>\n<td>Probabilistic signatures with built-in randomness</td>\n</tr>\n<tr>\n<td><code>ECDSAVerifierES256</code></td>\n<td>Signature verification on P-256 curve</td>\n<td>Must handle signature format variations</td>\n</tr>\n<tr>\n<td><code>P256CurveHandler</code></td>\n<td>Elliptic curve parameter management</td>\n<td>Manages curve constants and point operations</td>\n</tr>\n<tr>\n<td><code>ECDSASignatureEncoder</code></td>\n<td>DER/raw signature format conversion</td>\n<td>Handles multiple signature encoding standards</td>\n</tr>\n</tbody></table>\n<p><strong>Implementation Considerations</strong>: ECDSA signatures require careful attention to format handling, as different libraries and standards use varying signature encodings (DER, raw concatenation, or IEEE P1363 format). The implementation must choose a standard format and consistently apply it across signing and verification operations.</p>\n<h4 id=\"algorithm-selection-framework\">Algorithm Selection Framework</h4>\n<p>Supporting multiple signature algorithms requires a systematic approach to algorithm selection and instantiation. The framework must balance flexibility with security, preventing algorithm confusion attacks while enabling appropriate algorithm choice for different use cases.</p>\n<p><strong>Algorithm Registry Pattern</strong>: A central registry maps algorithm identifiers (<code>HS256</code>, <code>RS256</code>, <code>ES256</code>) to appropriate signer and verifier implementations. This registry validates algorithm choices against security policies and instantiates the correct cryptographic components.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Algorithm Selection Decision Flow:\n1. Extract algorithm identifier from JWT header\n2. Validate algorithm against allowed list in ValidationContext\n3. Check algorithm compatibility with provided key material\n4. Instantiate appropriate signer/verifier from registry\n5. Perform cryptographic operation with algorithm-specific implementation</code></pre></div>\n\n<p><strong>Security Policy Integration</strong>: The <code>ValidationContext</code> expands to include allowed algorithm lists, preventing downgrade attacks where an attacker might modify a token&#39;s algorithm field to specify a weaker algorithm. For example, a system expecting RS256 tokens should reject HS256 tokens even if they verify correctly with the RSA public key treated as an HMAC secret.</p>\n<blockquote>\n<p><strong>Decision: Explicit Algorithm Allowlists</strong></p>\n<ul>\n<li><strong>Context</strong>: JWT&#39;s algorithm flexibility can enable attack scenarios where tokens are verified with unintended algorithms</li>\n<li><strong>Options Considered</strong>: Accept any algorithm that verifies, require exact algorithm match, or use configurable allowlists</li>\n<li><strong>Decision</strong>: Implement configurable algorithm allowlists in ValidationContext</li>\n<li><strong>Rationale</strong>: Allowlists prevent algorithm confusion attacks while maintaining flexibility for systems that legitimately use multiple algorithms</li>\n<li><strong>Consequences</strong>: Applications must explicitly configure allowed algorithms, but this prevents entire classes of cryptographic attacks</li>\n</ul>\n</blockquote>\n<h4 id=\"common-pitfalls-in-algorithm-extensions\">Common Pitfalls in Algorithm Extensions</h4>\n<p>⚠️ <strong>Pitfall: Algorithm Confusion Attacks</strong>\nAccepting tokens with any algorithm that happens to verify correctly can lead to security vulnerabilities. For example, if a system expects RS256 tokens but accepts HS256, an attacker might create an HS256 token using the RSA public key as the HMAC secret. Always validate the algorithm field against an explicit allowlist before verification.</p>\n<p>⚠️ <strong>Pitfall: Key Format Mismatches</strong>\nDifferent algorithms require different key formats (raw bytes for HMAC, PEM-encoded keys for RSA, specific curve parameters for ECDSA). Attempting to use the wrong key type with an algorithm results in cryptographic failures that may not be immediately obvious during testing. Implement key validation that checks format compatibility before attempting cryptographic operations.</p>\n<p>⚠️ <strong>Pitfall: Signature Format Inconsistencies</strong>\nECDSA signatures can be encoded in multiple formats (DER, raw bytes, IEEE P1363). Using different formats for signing and verification causes validation failures even with correct keys. Choose one format standard and apply it consistently across all ECDSA operations.</p>\n<p>⚠️ <strong>Pitfall: Missing Security Parameter Validation</strong>\nRSA and ECDSA have minimum security requirements (key sizes, curve parameters) that must be enforced. Accepting weak parameters (small RSA keys, weak curves) compromises security. Implement security parameter validation that rejects cryptographically weak configurations.</p>\n<h3 id=\"performance-enhancements\">Performance Enhancements</h3>\n<p>JWT operations involve cryptographic computations, JSON parsing, and Base64 encoding that can become performance bottlenecks in high-throughput applications. While security must never be compromised for performance, several optimization strategies can significantly improve library efficiency without weakening cryptographic properties.</p>\n<h4 id=\"mental-model-document-processing-optimization\">Mental Model: Document Processing Optimization</h4>\n<p>Imagine a busy government office that processes thousands of document authentication requests daily. Initially, each clerk handles documents one by one: checking format, verifying signatures, validating dates, and filing results. As volume increases, the office implements optimizations: clerks pre-process common document types, managers cache recently verified signature authorities, and the office batches similar documents for efficient processing. These optimizations maintain the same security standards while dramatically improving throughput.</p>\n<p>JWT performance optimization follows similar patterns. Token verification can be accelerated through caching verified tokens (like caching signature authorities), pre-parsing common header formats (like pre-processing document types), and batching multiple token operations (like processing similar documents together). Each optimization preserves security properties while reducing computational overhead.</p>\n<h4 id=\"token-caching-strategy\">Token Caching Strategy</h4>\n<p>Caching successfully verified tokens eliminates redundant cryptographic computations for frequently used tokens, but requires careful consideration of security implications and cache invalidation policies.</p>\n<p><strong>Cache Key Design</strong>: The cache key must incorporate all factors that affect token validity, including the token content, validation context, and current time. Simply caching by token string is insufficient because validation context changes (different allowed issuers, audience requirements) or time progression (expiration status) can alter validity results.</p>\n<table>\n<thead>\n<tr>\n<th>Cache Component</th>\n<th>Responsibility</th>\n<th>Security Considerations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>VerificationCache</code></td>\n<td>Stores verified token results</td>\n<td>Must prevent cache poisoning attacks</td>\n</tr>\n<tr>\n<td><code>CacheKeyGenerator</code></td>\n<td>Creates composite cache keys</td>\n<td>Includes all validity-affecting factors</td>\n</tr>\n<tr>\n<td><code>TimeAwareExpiration</code></td>\n<td>Manages cache TTL based on token exp claims</td>\n<td>Never caches beyond token expiration</td>\n</tr>\n<tr>\n<td><code>CacheInvalidator</code></td>\n<td>Removes stale entries on security events</td>\n<td>Handles key rotation and policy changes</td>\n</tr>\n</tbody></table>\n<p><strong>Cache Invalidation Policies</strong>: Token caches must invalidate entries based on multiple triggers. Time-based invalidation removes entries when tokens approach expiration or when system time advances significantly. Security-based invalidation clears caches when key material changes, allowed issuer lists update, or security incidents require cache clearing.</p>\n<p><strong>Security Boundary Enforcement</strong>: The cache operates as a transparent optimization layer that never changes verification semantics. Cache hits return the same results that full verification would produce, and cache misses trigger complete verification with results stored for future use. The cache never bypasses security checks or returns results that wouldn&#39;t be produced by normal verification.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Cache-Enhanced Verification Flow:\n1. Generate cache key from token content and validation context\n2. Check cache for existing verification result\n3. If cache hit and still valid, return cached result\n4. If cache miss, perform complete token verification\n5. Store verification result with appropriate expiration time\n6. Return verification result to caller</code></pre></div>\n\n<blockquote>\n<p><strong>Decision: Time-Aware Cache Expiration</strong></p>\n<ul>\n<li><strong>Context</strong>: Cached token results become invalid as time progresses due to exp, nbf, and iat claim validation</li>\n<li><strong>Options Considered</strong>: Fixed TTL regardless of token claims, cache expiration matching token expiration, or no caching of time-sensitive tokens</li>\n<li><strong>Decision</strong>: Set cache TTL to the minimum of configured maximum and token expiration time</li>\n<li><strong>Rationale</strong>: This approach maximizes cache utilization while ensuring cached results never become incorrect due to time progression</li>\n<li><strong>Consequences</strong>: More complex cache management but optimal balance between performance and correctness</li>\n</ul>\n</blockquote>\n<h4 id=\"signature-verification-optimization\">Signature Verification Optimization</h4>\n<p>Cryptographic signature verification typically dominates JWT processing time, making it the primary target for performance optimization. Several strategies can accelerate verification without compromising security.</p>\n<p><strong>Public Key Caching</strong>: For RSA and ECDSA algorithms, parsing and preparing public keys for cryptographic operations involves significant computational overhead. Caching prepared key objects eliminates repeated parsing and mathematical setup for frequently used keys.</p>\n<p><strong>Signature Precomputation</strong>: In scenarios where the same signing input appears frequently (common with short-lived tokens containing similar claims), precomputed signature values can accelerate verification. However, this optimization requires careful security analysis to ensure it doesn&#39;t introduce timing vulnerabilities.</p>\n<p><strong>Batch Verification</strong>: Some cryptographic algorithms support batch verification where multiple signatures can be verified together more efficiently than individual verification. This optimization benefits high-throughput scenarios where applications verify many tokens simultaneously.</p>\n<table>\n<thead>\n<tr>\n<th>Optimization Technique</th>\n<th>Performance Gain</th>\n<th>Security Considerations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Public key caching</td>\n<td>30-50% reduction in key operations</td>\n<td>Cache invalidation on key rotation</td>\n</tr>\n<tr>\n<td>Prepared key objects</td>\n<td>20-40% faster signature verification</td>\n<td>Memory management for key lifecycle</td>\n</tr>\n<tr>\n<td>Signature precomputation</td>\n<td>Up to 80% for repeated content</td>\n<td>Must prevent timing information leakage</td>\n</tr>\n<tr>\n<td>Batch verification</td>\n<td>15-25% for high-volume operations</td>\n<td>Requires careful error isolation</td>\n</tr>\n</tbody></table>\n<h4 id=\"memory-pool-management\">Memory Pool Management</h4>\n<p>JWT processing creates many temporary objects: JSON parsers, Base64 decoders, cryptographic contexts, and intermediate data structures. Memory pool management can reduce allocation overhead and garbage collection pressure in high-throughput scenarios.</p>\n<p><strong>Object Pool Design</strong>: Pre-allocated pools of reusable objects eliminate allocation overhead for common operations. Parsers, encoders, and cryptographic contexts can be borrowed from pools during token operations and returned for reuse after completion.</p>\n<p><strong>Buffer Management</strong>: JWT operations involve substantial string and byte array manipulation. Maintaining pools of appropriately sized buffers reduces allocation pressure and can improve cache locality for cryptographic operations.</p>\n<p><strong>Lifecycle Coordination</strong>: Pool management must coordinate with the library&#39;s security model to ensure that pooled objects are properly cleared between uses. Cryptographic contexts and intermediate buffers must be zeroed to prevent information leakage between different tokens or operations.</p>\n<h4 id=\"common-pitfalls-in-performance-optimization\">Common Pitfalls in Performance Optimization</h4>\n<p>⚠️ <strong>Pitfall: Cache Poisoning Through Key Manipulation</strong>\nIf cache keys don&#39;t incorporate all validation factors, attackers might manipulate validation contexts to cause incorrect cache hits. For example, if the cache key only includes the token string but not the allowed issuer list, changing the allowed issuers might return cached results from different validation contexts.</p>\n<p>⚠️ <strong>Pitfall: Timing Information Leakage Through Caching</strong>\nCache hits and misses can create timing differences that leak information about token usage patterns. Implement consistent timing behavior regardless of cache status, possibly through artificial delays or background verification operations.</p>\n<p>⚠️ <strong>Pitfall: Memory Reuse Without Proper Clearing</strong>\nReusing memory pools without proper clearing can leak token content between operations. Always zero sensitive buffers and reset object state when returning items to pools.</p>\n<p>⚠️ <strong>Pitfall: Optimization Invalidation on Configuration Changes</strong>\nCached results and optimized data structures can become invalid when system configuration changes (key rotation, allowed algorithm updates, policy modifications). Implement cache invalidation and optimization reset mechanisms that trigger on configuration changes.</p>\n<h3 id=\"advanced-jwt-features\">Advanced JWT Features</h3>\n<p>Beyond basic token signing and verification, enterprise applications often require sophisticated features like encrypted tokens, automatic key rotation, and complex claim validation rules. These advanced features build upon the foundational architecture while adding significant complexity in key management, operational procedures, and security models.</p>\n<h4 id=\"mental-model-evolving-security-systems\">Mental Model: Evolving Security Systems</h4>\n<p>Think of JWT advancement like the evolution of bank security systems. Basic banks start with simple safes and manual ledgers (basic JWT signing). As they grow, they add armored transport (token encryption), automated vault systems (key rotation), and sophisticated audit trails (advanced claims processing). Each addition integrates with existing security measures rather than replacing them—the fundamental principles of authentication and authorization remain constant, but the implementation becomes more sophisticated to handle complex operational requirements.</p>\n<p>Advanced JWT features follow this same evolutionary pattern. JWE encryption wraps existing JWT functionality in an additional security layer. Key rotation automates the operational aspects of key management without changing fundamental signing algorithms. Advanced claims processing extends basic validation with complex business logic while preserving the core security model.</p>\n<h4 id=\"jwe-json-web-encryption-integration\">JWE (JSON Web Encryption) Integration</h4>\n<p>JSON Web Encryption provides confidentiality protection for JWT content, encrypting the entire JWT token so that only authorized recipients can read the payload claims. JWE integration requires careful coordination between encryption and signing operations to maintain both confidentiality and authenticity properties.</p>\n<p><strong>Nested Token Architecture</strong>: The most common JWE integration pattern creates nested tokens where a standard JWT is first signed, then the entire signed token becomes the payload for JWE encryption. This approach preserves existing JWT verification logic while adding an outer encryption layer.</p>\n<table>\n<thead>\n<tr>\n<th>JWE Component</th>\n<th>Responsibility</th>\n<th>Integration Points</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>JWEEncryptor</code></td>\n<td>Encrypts signed JWT tokens</td>\n<td>Receives output from token signing operations</td>\n</tr>\n<tr>\n<td><code>JWEDecryptor</code></td>\n<td>Decrypts JWE to reveal inner JWT</td>\n<td>Feeds decrypted tokens to standard verification</td>\n</tr>\n<tr>\n<td><code>KeyDerivationHandler</code></td>\n<td>Manages encryption key derivation</td>\n<td>Coordinates with signature key management</td>\n</tr>\n<tr>\n<td><code>ContentEncryptionManager</code></td>\n<td>Handles AES-GCM content encryption</td>\n<td>Manages symmetric encryption for token payload</td>\n</tr>\n</tbody></table>\n<p><strong>Key Management Complexity</strong>: JWE introduces additional key management requirements beyond signature keys. Content encryption keys (CEK) are typically generated per token and encrypted using key encryption keys (KEK). This multi-layer approach provides forward secrecy but requires sophisticated key derivation and management systems.</p>\n<p><strong>Encryption Algorithm Selection</strong>: JWE supports multiple key agreement and content encryption algorithms. Common combinations include RSA-OAEP for key encryption with AES-256-GCM for content encryption, or ECDH-ES for key agreement with ChaCha20-Poly1305 for content encryption. Algorithm selection depends on performance requirements, security policies, and interoperability constraints.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>JWE-Enhanced Token Creation Flow:\n1. Create and sign standard JWT using existing token creation process\n2. Generate random content encryption key (CEK) for this token\n3. Encrypt CEK using recipient's key encryption key (KEK)\n4. Encrypt signed JWT content using CEK and AES-GCM\n5. Assemble JWE token with encrypted key, IV, encrypted content, and authentication tag\n6. Return JWE token that contains encrypted JWT</code></pre></div>\n\n<p><strong>Performance Implications</strong>: JWE operations add significant computational overhead due to key derivation and symmetric encryption operations. Content encryption scales with token size, making JWE particularly expensive for tokens with large claim sets or custom payload data.</p>\n<blockquote>\n<p><strong>Decision: Nested JWT-in-JWE Rather Than JWE-First Design</strong></p>\n<ul>\n<li><strong>Context</strong>: JWE can either encrypt unsigned claims or encrypt an already-signed JWT token</li>\n<li><strong>Options Considered</strong>: Encrypt claims directly with JWE, sign JWE-encrypted content, or nest signed JWT within JWE</li>\n<li><strong>Decision</strong>: Implement nested JWT-in-JWE where signed tokens are encrypted as JWE payload</li>\n<li><strong>Rationale</strong>: Nested approach preserves existing JWT verification logic, enables gradual adoption, and provides clearer separation between authentication and confidentiality</li>\n<li><strong>Consequences</strong>: Slightly larger tokens due to nested structure, but much cleaner integration with existing systems</li>\n</ul>\n</blockquote>\n<h4 id=\"automatic-key-rotation\">Automatic Key Rotation</h4>\n<p>Production JWT systems require periodic key rotation to limit the impact of potential key compromise and meet compliance requirements. Automatic key rotation must coordinate key generation, distribution, gradual transition periods, and secure disposal of old keys.</p>\n<p><strong>Multi-Key Verification Support</strong>: During key rotation periods, the system must support tokens signed with both old and new keys. The verification process attempts multiple keys until finding one that produces a valid signature, enabling gradual transition without service disruption.</p>\n<p><strong>Key Versioning and Distribution</strong>: Each key requires unique identification through key IDs (<code>kid</code> header claim) that enable recipients to select appropriate verification keys. Key distribution mechanisms must securely deliver new keys to all verification services before those keys are used for token signing.</p>\n<table>\n<thead>\n<tr>\n<th>Rotation Component</th>\n<th>Responsibility</th>\n<th>Operational Considerations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>KeyRotationScheduler</code></td>\n<td>Manages rotation timing and triggers</td>\n<td>Coordinates with operational maintenance windows</td>\n</tr>\n<tr>\n<td><code>KeyGenerationService</code></td>\n<td>Creates new keys with appropriate security parameters</td>\n<td>Ensures sufficient entropy and parameter validation</td>\n</tr>\n<tr>\n<td><code>KeyDistributionManager</code></td>\n<td>Securely delivers keys to all services</td>\n<td>Handles distribution failures and retry logic</td>\n</tr>\n<tr>\n<td><code>GracefulTransitionHandler</code></td>\n<td>Manages overlap periods with multiple valid keys</td>\n<td>Balances security and operational continuity</td>\n</tr>\n</tbody></table>\n<p><strong>Rotation Timeline Management</strong>: Key rotation follows carefully orchestrated timelines that balance security and operational stability. New keys are generated and distributed before use, old keys remain valid for verification during transition periods, and expired keys are securely disposed of after all tokens using them have expired.</p>\n<p><strong>Emergency Rotation Procedures</strong>: Security incidents may require immediate key rotation outside normal schedules. Emergency rotation procedures must balance rapid response with system stability, often involving shorter transition periods and more aggressive cache invalidation.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Key Rotation Timeline:\n1. Generate new key pair with incremented version identifier\n2. Distribute new public key to all verification services\n3. Wait for distribution confirmation from all services\n4. Begin signing new tokens with new private key\n5. Continue accepting tokens signed with old key during grace period\n6. Stop accepting old key signatures after grace period expires\n7. Securely destroy old private key material</code></pre></div>\n\n<h4 id=\"advanced-claims-processing\">Advanced Claims Processing</h4>\n<p>Enterprise applications often require sophisticated claim validation beyond standard registered claims. Advanced processing includes dynamic validation rules, external claim enrichment, conditional validation logic, and integration with identity management systems.</p>\n<p><strong>Rule-Based Validation Engine</strong>: A flexible rule engine allows applications to define custom validation logic using configuration rather than code changes. Rules can reference claim values, external context, and time-based conditions to make validation decisions.</p>\n<p><strong>Claim Enrichment Pipeline</strong>: Some applications need to augment token claims with additional information retrieved from external systems during validation. For example, user tokens might be enriched with current group memberships or permission grants retrieved from identity management systems.</p>\n<p><strong>Conditional Validation Logic</strong>: Advanced scenarios require different validation rules based on token content, request context, or environmental factors. Administrative tokens might have different validation requirements than user tokens, or validation strictness might change based on request sensitivity.</p>\n<table>\n<thead>\n<tr>\n<th>Advanced Processing Component</th>\n<th>Functionality</th>\n<th>Integration Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>RuleEngine</code></td>\n<td>Evaluates configurable validation rules</td>\n<td>Requires rule definition language and parser</td>\n</tr>\n<tr>\n<td><code>ClaimEnrichmentPipeline</code></td>\n<td>Augments tokens with external data</td>\n<td>Must handle external service failures gracefully</td>\n</tr>\n<tr>\n<td><code>ConditionalValidator</code></td>\n<td>Applies different validation based on context</td>\n<td>Requires careful rule precedence management</td>\n</tr>\n<tr>\n<td><code>IdentityIntegration</code></td>\n<td>Connects with external identity systems</td>\n<td>Complex error handling and caching considerations</td>\n</tr>\n</tbody></table>\n<p><strong>External System Integration</strong>: Claim enrichment and advanced validation often require integration with external systems like LDAP directories, database systems, or web services. These integrations introduce latency, failure modes, and caching considerations that must be carefully managed to maintain JWT verification performance and reliability.</p>\n<h4 id=\"common-pitfalls-in-advanced-features\">Common Pitfalls in Advanced Features</h4>\n<p>⚠️ <strong>Pitfall: JWE Key Confusion Between Signing and Encryption</strong>\nUsing the same key material for both JWT signing and JWE encryption can create cryptographic vulnerabilities. Always use separate key hierarchies for signing operations and encryption operations, even if they use the same underlying algorithm family.</p>\n<p>⚠️ <strong>Pitfall: Key Rotation Race Conditions</strong>\nIf new keys are used for signing before all verification services receive them, tokens will fail verification during the transition period. Always ensure complete key distribution and confirmation before beginning to use new keys for token creation.</p>\n<p>⚠️ <strong>Pitfall: Advanced Claim Validation Bypassing Core Security</strong>\nComplex claim processing logic must never bypass fundamental security validations like signature verification and expiration checking. Implement advanced features as additional layers on top of core security, not as replacements for basic validation.</p>\n<p>⚠️ <strong>Pitfall: External System Dependencies Breaking Token Verification</strong>\nIf advanced claim processing depends on external systems that become unavailable, token verification might fail even for otherwise valid tokens. Implement graceful degradation modes and consider which validations are essential versus enhancement features.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The extensions described in this section build upon the foundational JWT library architecture, requiring careful integration to maintain security properties while adding new capabilities. This guidance provides concrete implementation strategies for each extension category.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Extension Category</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Additional Algorithms</td>\n<td>Python <code>cryptography</code> library with RSA/ECDSA</td>\n<td>Hardware Security Module (HSM) integration</td>\n</tr>\n<tr>\n<td>Performance Caching</td>\n<td>In-memory LRU cache with <code>functools.lru_cache</code></td>\n<td>Redis cluster with consistent hashing</td>\n</tr>\n<tr>\n<td>JWE Integration</td>\n<td><code>python-jose</code> library for JWE operations</td>\n<td>Custom implementation with <code>cryptography</code> primitives</td>\n</tr>\n<tr>\n<td>Key Rotation</td>\n<td>File-based key storage with version numbers</td>\n<td>HashiCorp Vault with automatic rotation</td>\n</tr>\n<tr>\n<td>Advanced Claims</td>\n<td>JSON Schema validation with <code>jsonschema</code></td>\n<td>Custom rule engine with external service integration</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure-for-extensions\">Recommended File Structure for Extensions</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>jwt-library/\n  core/\n    encoder.py           ← existing JWT encoding (Milestone 1)\n    signer.py           ← existing HMAC signing (Milestone 2)  \n    validator.py        ← existing claims validation (Milestone 3)\n  extensions/\n    algorithms/\n      rsa_signer.py     ← RSA signing implementation\n      ecdsa_signer.py   ← ECDSA signing implementation\n      registry.py       ← algorithm selection and instantiation\n    performance/\n      cache.py          ← token verification caching\n      pools.py          ← object and memory pool management\n    advanced/\n      jwe.py            ← JWE encryption/decryption\n      rotation.py       ← automatic key rotation\n      rules.py          ← advanced claims processing\n  examples/\n    extension_usage.py  ← demonstration of extension features\n  tests/\n    extensions/         ← comprehensive extension testing</code></pre></div>\n\n<p>This structure isolates extensions from core functionality while enabling clean integration through well-defined interfaces.</p>\n<h4 id=\"rsa-algorithm-implementation-starter-code\">RSA Algorithm Implementation Starter Code</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">RSA signature algorithm implementation for JWT library extensions.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Provides RS256 signing and verification with proper key management.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> cryptography.hazmat.primitives </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hashes, serialization</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> cryptography.hazmat.primitives.asymmetric </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> rsa, padding</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> cryptography.exceptions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> InvalidSignature</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> base64</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Union</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RSASignerRS256</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"RSA-SHA256 token signer using private key for signature generation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, private_key_pem: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Load private key from PEM string using cryptography library</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Validate that key is RSA type and meets minimum security requirements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Store private key securely in instance variable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Initialize PKCS1v15 padding for signature operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use serialization.load_pem_private_key() for key loading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> sign</span><span style=\"color:#E1E4E8\">(self, signing_input: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate RS256 signature for JWT signing input.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Convert signing input string to bytes using UTF-8 encoding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Sign the bytes using RSA private key with SHA256 hash and PKCS1v15 padding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Base64URL encode the signature bytes to string format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return the encoded signature for JWT token assembly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use private_key.sign(data, padding.PKCS1v15(), hashes.SHA256())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RSAVerifierRS256</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"RSA-SHA256 token verifier using public key for signature verification.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, public_key_pem: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Load public key from PEM string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Validate key type and security parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Store public key in instance variable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Prepare verification padding configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> verify</span><span style=\"color:#E1E4E8\">(self, signing_input: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, provided_signature: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify RS256 signature against signing input using public key.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Decode provided signature from Base64URL to bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Convert signing input to bytes using UTF-8 encoding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Attempt signature verification using public key</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return True for valid signatures, False for invalid ones</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Handle cryptographic exceptions gracefully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use public_key.verify(signature, data, padding.PKCS1v15(), hashes.SHA256())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"token-verification-cache-implementation\">Token Verification Cache Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Performance-optimized token verification with security-aware caching.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Caches verification results while maintaining all security properties.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hashlib</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Optional, Tuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .core.validator </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ValidationContext, JWTPayload</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CachedResult</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Cached verification result with expiration tracking.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payload: JWTPayload</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cached_at: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expires_at: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context_hash: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> VerificationCache</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Thread-safe cache for JWT verification results.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, max_size: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">, default_ttl: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 300</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize thread-safe cache storage (use threading.RLock)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Set up cache size limits and eviction policy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Configure default TTL and cleanup intervals</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Initialize cache statistics tracking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_cache_key</span><span style=\"color:#E1E4E8\">(self, token: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, context: ValidationContext) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate composite cache key from token and validation context.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create hash of validation context to capture all factors affecting validity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Combine token content with context hash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Include current time window to handle time-sensitive validations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return consistent cache key for identical inputs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use hashlib.sha256 to hash context parameters and token content</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get</span><span style=\"color:#E1E4E8\">(self, cache_key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[CachedResult]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Retrieve cached result if still valid.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if cache key exists in storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Verify cached result hasn't expired based on time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return cached result or None if invalid/expired</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Update cache hit/miss statistics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> put</span><span style=\"color:#E1E4E8\">(self, cache_key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, payload: JWTPayload, context: ValidationContext) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Store verification result with appropriate expiration.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Calculate expiration time based on token exp claim and context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create CachedResult with current timestamp and expiration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Store in cache with size limit enforcement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Trigger cleanup if cache exceeds maximum size</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"key-rotation-system-foundation\">Key Rotation System Foundation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Automatic key rotation system with graceful transition support.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Manages key generation, distribution, and lifecycle coordination.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> os</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timedelta</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Dict, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> cryptography.hazmat.primitives.asymmetric </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> rsa</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> cryptography.hazmat.primitives </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> serialization</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> KeyVersion</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents a single key version with metadata.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    kid: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">           # key identifier</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    created_at: datetime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expires_at: datetime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    private_key: Optional[</span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#6A737D\"># None for verification-only contexts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    public_key: </span><span style=\"color:#79B8FF\">bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    algorithm: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    status: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">       # 'active', 'rotating', 'deprecated', 'revoked'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> KeyRotationManager</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Manages automatic key rotation with graceful transitions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, key_directory: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, rotation_interval: timedelta):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize key storage directory and file management</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Set up rotation scheduling and timeline management</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Load existing keys from storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Initialize key distribution tracking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> generate_new_key</span><span style=\"color:#E1E4E8\">(self, algorithm: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"RS256\"</span><span style=\"color:#E1E4E8\">) -> KeyVersion:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate new key pair with proper security parameters.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Generate RSA key pair with 2048-bit minimum size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create unique key identifier (kid) using timestamp and random data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Set appropriate expiration time based on rotation policy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Serialize keys to PEM format for storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return KeyVersion object with all metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use rsa.generate_private_key(65537, 2048) for key generation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> initiate_rotation</span><span style=\"color:#E1E4E8\">(self) -> KeyVersion:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Begin key rotation process with new key generation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Generate new key pair using generate_new_key()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Mark current active key as 'rotating' status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Set new key as 'active' for future token signing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Persist key state changes to storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return new key for distribution to verification services</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_signing_key</span><span style=\"color:#E1E4E8\">(self) -> KeyVersion:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get current active key for token signing operations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Find key with 'active' status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check if key is approaching expiration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Trigger rotation if necessary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return active key for signing operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_verification_keys</span><span style=\"color:#E1E4E8\">(self) -> List[KeyVersion]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get all keys valid for token verification.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Return keys with 'active' or 'rotating' status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Filter out expired keys based on current time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Sort by creation time for consistent ordering</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Include public key material only</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints-for-extensions\">Milestone Checkpoints for Extensions</h4>\n<p><strong>Algorithm Extension Checkpoint</strong>:\nAfter implementing RSA support, verify the extension by creating tokens with both HMAC and RSA algorithms:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test command: python -m pytest tests/extensions/test_algorithms.py</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: All algorithm tests pass including cross-verification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Manual verification: Create RS256 token, verify with public key</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Warning signs: Signature format errors, key loading failures</span></span></code></pre></div>\n\n<p><strong>Performance Enhancement Checkpoint</strong>:\nAfter implementing caching, measure performance improvement with cache hit rates:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test command: python extensions/examples/cache_benchmark.py</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: 50-80% cache hit rate with 3-5x verification speedup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Manual verification: Same token verified multiple times returns cached results</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Warning signs: Cache key collisions, incorrect expiration behavior</span></span></code></pre></div>\n\n<p><strong>Advanced Features Checkpoint</strong>:\nAfter implementing key rotation, verify seamless key transitions:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test command: python extensions/examples/rotation_demo.py</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Tokens verify during entire rotation cycle</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Manual verification: Create token with old key, verify after rotation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Warning signs: Verification failures during transition periods</span></span></code></pre></div>\n\n<h4 id=\"debugging-extension-issues\">Debugging Extension Issues</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>RSA signatures always invalid</td>\n<td>Key format or padding mismatch</td>\n<td>Check PEM encoding and PKCS1v15 usage</td>\n<td>Verify key loading and padding configuration</td>\n</tr>\n<tr>\n<td>Cache never hits despite identical tokens</td>\n<td>Context not included in cache key</td>\n<td>Log cache key generation process</td>\n<td>Include all context factors in key hash</td>\n</tr>\n<tr>\n<td>Key rotation breaks existing tokens</td>\n<td>New key used before distribution</td>\n<td>Check key distribution timing</td>\n<td>Ensure distribution before signing with new key</td>\n</tr>\n<tr>\n<td>JWE tokens fail to decrypt</td>\n<td>Key derivation or algorithm mismatch</td>\n<td>Verify KEK and content encryption setup</td>\n<td>Check algorithm compatibility and key formats</td>\n</tr>\n</tbody></table>\n<h2 id=\"glossary\">Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundation for all three milestones - essential terminology for JWT structure (Milestone 1), HMAC signing (Milestone 2), and claims validation (Milestone 3)</p>\n</blockquote>\n<p>This glossary provides comprehensive definitions of JWT terminology and cryptographic concepts used throughout our library implementation. Understanding these terms is crucial for implementing secure token-based authentication systems and avoiding common security pitfalls.</p>\n<h3 id=\"mental-model-the-technical-dictionary\">Mental Model: The Technical Dictionary</h3>\n<p>Think of this glossary as a specialized technical dictionary for a new domain - just as learning a foreign language requires understanding both individual words and their contextual meanings, implementing JWT security requires mastering both the terminology and the security implications behind each concept. Each term represents a piece of the larger JWT security puzzle, and understanding how they interconnect is essential for building robust authentication systems.</p>\n<h3 id=\"jwt-core-terminology\">JWT Core Terminology</h3>\n<p>The following table defines fundamental JWT concepts that form the foundation of token-based authentication:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Security Implications</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>JSON Web Token (JWT)</strong></td>\n<td>A compact, URL-safe token format for representing claims between parties, consisting of three Base64URL-encoded parts separated by dots</td>\n<td>Stateless authentication enabling distributed systems without shared session state</td>\n</tr>\n<tr>\n<td><strong>Stateless Authentication</strong></td>\n<td>Authentication mechanism that doesn&#39;t require server-side session storage, with all necessary information contained within the token itself</td>\n<td>Enables horizontal scaling but requires careful token security since compromise affects all services</td>\n</tr>\n<tr>\n<td><strong>Claims</strong></td>\n<td>Statements about an entity (typically a user) and additional metadata contained within the JWT payload</td>\n<td>Foundation of JWT security - incorrect validation allows unauthorized access</td>\n</tr>\n<tr>\n<td><strong>Header</strong></td>\n<td>First part of JWT containing metadata about the token type and cryptographic algorithm used for signing</td>\n<td>Algorithm specification prevents confusion attacks where attackers change signing method</td>\n</tr>\n<tr>\n<td><strong>Payload</strong></td>\n<td>Second part of JWT containing the claims (user data, permissions, expiration times)</td>\n<td>Contains sensitive information that determines authorization scope</td>\n</tr>\n<tr>\n<td><strong>Signature</strong></td>\n<td>Third part of JWT providing cryptographic proof of token authenticity and integrity</td>\n<td>Prevents token tampering - compromise enables complete authentication bypass</td>\n</tr>\n<tr>\n<td><strong>Base64URL Encoding</strong></td>\n<td>URL-safe variant of Base64 encoding that replaces <code>+</code> with <code>-</code>, <code>/</code> with <code>_</code>, and removes padding <code>=</code> characters</td>\n<td>URL safety prevents encoding issues in web contexts while maintaining data integrity</td>\n</tr>\n<tr>\n<td><strong>Token Assembly</strong></td>\n<td>Process of combining encoded header, payload, and signature components with dot separators into final JWT format</td>\n<td>Incorrect assembly can create malformed tokens that fail validation or create security vulnerabilities</td>\n</tr>\n</tbody></table>\n<h3 id=\"cryptographic-concepts\">Cryptographic Concepts</h3>\n<p>Understanding these cryptographic principles is essential for implementing secure JWT signing and verification:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Security Implications</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>HMAC-SHA256</strong></td>\n<td>Keyed hash algorithm combining SHA-256 cryptographic hash with secret key authentication</td>\n<td>Provides both integrity and authenticity - key compromise affects all tokens</td>\n</tr>\n<tr>\n<td><strong>Digital Signatures</strong></td>\n<td>Cryptographic mechanism proving message authenticity and integrity using public-key or symmetric-key cryptography</td>\n<td>Foundation of JWT trust - weak signature verification enables token forgery</td>\n</tr>\n<tr>\n<td><strong>Signature Verification</strong></td>\n<td>Process of cryptographically validating token authenticity by recomputing and comparing signatures</td>\n<td>Must use constant-time comparison to prevent timing attack vulnerabilities</td>\n</tr>\n<tr>\n<td><strong>Constant-time Comparison</strong></td>\n<td>Comparison algorithm that takes identical time regardless of input differences, preventing timing side-channel attacks</td>\n<td>Prevents attackers from learning signature information through execution time analysis</td>\n</tr>\n<tr>\n<td><strong>Timing Attack</strong></td>\n<td>Cryptographic attack exploiting variations in execution time to extract sensitive information</td>\n<td>Can reveal signature bytes through statistical analysis of verification timing</td>\n</tr>\n<tr>\n<td><strong>Algorithm Confusion Attack</strong></td>\n<td>Attack exploiting JWT&#39;s algorithm flexibility to change verification method (e.g., HMAC to RSA)</td>\n<td>Allows attackers to bypass signature verification by manipulating algorithm specification</td>\n</tr>\n<tr>\n<td><strong>Secret Key Handling</strong></td>\n<td>Secure management of cryptographic keys including generation, storage, and validation</td>\n<td>Key compromise renders all JWT security protections ineffective</td>\n</tr>\n<tr>\n<td><strong>Signing Input</strong></td>\n<td>Concatenated string of encoded header and payload (<code>header.payload</code>) used for signature computation</td>\n<td>Must be identical between signing and verification to ensure signature validity</td>\n</tr>\n<tr>\n<td><strong>HMAC-SHA256 Length</strong></td>\n<td>Fixed 32-byte output length of HMAC-SHA256 algorithm</td>\n<td>Signature truncation or extension indicates tampering or implementation errors</td>\n</tr>\n<tr>\n<td><strong>Minimum Key Length</strong></td>\n<td>Security requirement for minimum cryptographic key size (32 bytes for HMAC-SHA256)</td>\n<td>Shorter keys are vulnerable to brute-force attacks within practical timeframes</td>\n</tr>\n</tbody></table>\n<h3 id=\"claims-and-validation-terminology\">Claims and Validation Terminology</h3>\n<p>These terms define how JWT claims are structured, validated, and secured:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Security Implications</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Registered Claims</strong></td>\n<td>Standard claim names defined in JWT specification (<code>iss</code>, <code>sub</code>, <code>aud</code>, <code>exp</code>, <code>nbf</code>, <code>iat</code>, <code>jti</code>)</td>\n<td>Standardized validation rules prevent common security mistakes</td>\n</tr>\n<tr>\n<td><strong>Temporal Validation</strong></td>\n<td>Verification of time-based claims including expiration, not-before, and issued-at timestamps</td>\n<td>Prevents replay attacks and limits token abuse window</td>\n</tr>\n<tr>\n<td><strong>Clock Skew</strong></td>\n<td>Time difference between servers that can cause legitimate tokens to fail validation</td>\n<td>Requires leeway period to handle normal time synchronization variations</td>\n</tr>\n<tr>\n<td><strong>Leeway Period</strong></td>\n<td>Time tolerance (typically 300 seconds) added to temporal validation to handle clock skew</td>\n<td>Too much leeway extends attack windows, too little causes legitimate failures</td>\n</tr>\n<tr>\n<td><strong>Identity Validation</strong></td>\n<td>Verification of issuer (<code>iss</code>) and audience (<code>aud</code>) claims against expected values</td>\n<td>Prevents token misuse across different applications or services</td>\n</tr>\n<tr>\n<td><strong>Allowlist Validation</strong></td>\n<td>Exact string matching of claim values against predefined approved lists</td>\n<td>Stronger than pattern matching for preventing subtle bypass attacks</td>\n</tr>\n<tr>\n<td><strong>Custom Claims Processing</strong></td>\n<td>Validation of application-specific payload fields beyond registered claims</td>\n<td>Application security depends on proper validation of business logic claims</td>\n</tr>\n<tr>\n<td><strong>Fail-fast Validation</strong></td>\n<td>Validation strategy that immediately rejects tokens upon first validation failure</td>\n<td>Improves performance and simplifies error handling logic</td>\n</tr>\n<tr>\n<td><strong>Maximum Token Age</strong></td>\n<td>Upper limit on token lifetime to prevent indefinite token usage</td>\n<td>Balances user convenience with security exposure from compromised tokens</td>\n</tr>\n</tbody></table>\n<h3 id=\"component-architecture-terms\">Component Architecture Terms</h3>\n<p>These terms describe how our JWT library components interact and coordinate:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Implementation Importance</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Component Coordination</strong></td>\n<td>Orchestrated interaction between encoding, signing, and validation components</td>\n<td>Proper coordination ensures consistent security across all operations</td>\n</tr>\n<tr>\n<td><strong>Error Propagation</strong></td>\n<td>Systematic passing of error context through component hierarchy</td>\n<td>Security errors must preserve diagnostic information while preventing information disclosure</td>\n</tr>\n<tr>\n<td><strong>Self-verification</strong></td>\n<td>Process of validating newly created tokens before returning them to callers</td>\n<td>Catches implementation bugs that could produce invalid tokens</td>\n</tr>\n<tr>\n<td><strong>Validation Context</strong></td>\n<td>Configuration object containing validation rules, security settings, and operational parameters</td>\n<td>Centralized configuration prevents inconsistent security policies</td>\n</tr>\n<tr>\n<td><strong>Security Context</strong></td>\n<td>Deployment environment classification affecting error detail levels and logging behavior</td>\n<td>Production environments must limit error information to prevent information disclosure</td>\n</tr>\n<tr>\n<td><strong>Error Classification</strong></td>\n<td>Systematic organization of failures by type, severity, and appropriate handling strategy</td>\n<td>Enables appropriate response to different security threat levels</td>\n</tr>\n</tbody></table>\n<h3 id=\"time-based-security-concepts\">Time-based Security Concepts</h3>\n<p>Understanding temporal aspects of JWT security is crucial for preventing time-based attacks:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Security Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Token Expiration (<code>exp</code>)</strong></td>\n<td>Timestamp after which token should be rejected as invalid</td>\n<td>Limits damage window if token is compromised or stolen</td>\n</tr>\n<tr>\n<td><strong>Not Before (<code>nbf</code>)</strong></td>\n<td>Timestamp before which token should not be accepted</td>\n<td>Prevents premature token usage and supports scheduled authorization</td>\n</tr>\n<tr>\n<td><strong>Issued At (<code>iat</code>)</strong></td>\n<td>Timestamp when token was created</td>\n<td>Enables token age validation and helps detect suspicious timing patterns</td>\n</tr>\n<tr>\n<td><strong>Temporal Edge Cases</strong></td>\n<td>Unusual time scenarios like leap seconds, extreme dates, or timezone transitions</td>\n<td>Can cause validation failures or security bypasses if not handled correctly</td>\n</tr>\n<tr>\n<td><strong>UTC Normalization</strong></td>\n<td>Converting all timestamps to Coordinated Universal Time for consistent validation</td>\n<td>Prevents timezone-based validation bypasses and ensures consistent behavior</td>\n</tr>\n<tr>\n<td><strong>Unix Timestamp</strong></td>\n<td>Seconds since January 1, 1970 UTC - standard format for JWT time claims</td>\n<td>Provides consistent time representation across different systems and languages</td>\n</tr>\n</tbody></table>\n<h3 id=\"error-handling-and-security-terms\">Error Handling and Security Terms</h3>\n<p>These terms define how our library handles security-sensitive error conditions:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Security Importance</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Validation Failure Context</strong></td>\n<td>Structured error information including component, operation, severity, and diagnostic details</td>\n<td>Enables appropriate error response while preventing information disclosure</td>\n</tr>\n<tr>\n<td><strong>Information Disclosure</strong></td>\n<td>Unintended revelation of sensitive system details through error messages or behavior</td>\n<td>Can provide attackers with information useful for crafting more effective attacks</td>\n</tr>\n<tr>\n<td><strong>Security-aware Logging</strong></td>\n<td>Logging strategy that adapts detail level based on security context and potential information leakage</td>\n<td>Balances debugging needs with operational security requirements</td>\n</tr>\n<tr>\n<td><strong>Cryptographic Error Handling</strong></td>\n<td>Specialized handling of signature failures, key errors, and algorithm problems</td>\n<td>Must prevent side-channel information leakage while providing useful diagnostics</td>\n</tr>\n<tr>\n<td><strong>Malformed Token Handling</strong></td>\n<td>Processing strategy for tokens with structural or encoding problems</td>\n<td>Must fail securely without revealing information about expected token structure</td>\n</tr>\n<tr>\n<td><strong>Error Severity Levels</strong></td>\n<td>Classification system (<code>CRITICAL</code>, <code>HIGH</code>, <code>MEDIUM</code>, <code>LOW</code>) for prioritizing security responses</td>\n<td>Enables appropriate incident response and monitoring alerting</td>\n</tr>\n</tbody></table>\n<h3 id=\"advanced-jwt-concepts\">Advanced JWT Concepts</h3>\n<p>These terms describe extensions and advanced features that build upon basic JWT functionality:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Advanced Applications</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Asymmetric Cryptography</strong></td>\n<td>Public-private key cryptography enabling distributed verification without shared secrets</td>\n<td>Allows token verification without access to signing keys</td>\n</tr>\n<tr>\n<td><strong>RSA-SHA256 (RS256)</strong></td>\n<td>RSA signature algorithm with SHA-256 hash for JWT signing</td>\n<td>Enables distributed verification with public keys</td>\n</tr>\n<tr>\n<td><strong>ECDSA-P256-SHA256 (ES256)</strong></td>\n<td>Elliptic Curve Digital Signature Algorithm with P-256 curve and SHA-256 hash</td>\n<td>Provides equivalent security to RSA with smaller key sizes</td>\n</tr>\n<tr>\n<td><strong>Key Rotation</strong></td>\n<td>Periodic replacement of cryptographic keys to limit impact of key compromise</td>\n<td>Essential for long-term security in production systems</td>\n</tr>\n<tr>\n<td><strong>Key Distribution</strong></td>\n<td>Secure delivery of cryptographic keys to services requiring verification capability</td>\n<td>Critical for distributed systems using asymmetric algorithms</td>\n</tr>\n<tr>\n<td><strong>JSON Web Encryption (JWE)</strong></td>\n<td>Specification providing confidentiality for JWT content through encryption</td>\n<td>Protects sensitive claims from disclosure even with token interception</td>\n</tr>\n<tr>\n<td><strong>Nested Tokens</strong></td>\n<td>JWT tokens encrypted within JWE containers for both authenticity and confidentiality</td>\n<td>Combines signature verification with content encryption</td>\n</tr>\n</tbody></table>\n<h3 id=\"performance-and-operational-terms\">Performance and Operational Terms</h3>\n<p>These terms describe efficiency and operational aspects of JWT implementation:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Operational Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Verification Cache</strong></td>\n<td>Storage mechanism for caching successful token verification results</td>\n<td>Improves performance but requires careful invalidation to maintain security</td>\n</tr>\n<tr>\n<td><strong>Cache Invalidation</strong></td>\n<td>Process of removing stale or potentially compromised cache entries</td>\n<td>Essential for maintaining security when keys rotate or policies change</td>\n</tr>\n<tr>\n<td><strong>Graceful Transition</strong></td>\n<td>Smooth key rotation process that maintains service availability</td>\n<td>Prevents authentication failures during security maintenance windows</td>\n</tr>\n<tr>\n<td><strong>Rule-based Validation</strong></td>\n<td>Configurable claim validation using custom business logic rules</td>\n<td>Enables complex authorization policies beyond standard JWT claims</td>\n</tr>\n<tr>\n<td><strong>Claim Enrichment</strong></td>\n<td>Process of augmenting token claims with external data during validation</td>\n<td>Allows dynamic authorization decisions based on current context</td>\n</tr>\n</tbody></table>\n<h3 id=\"testing-and-validation-terminology\">Testing and Validation Terminology</h3>\n<p>Understanding these terms is crucial for implementing comprehensive JWT library testing:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Testing Importance</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Test Vectors</strong></td>\n<td>Known-good input and output pairs used to validate implementation correctness</td>\n<td>Ensures compatibility with JWT specification and other implementations</td>\n</tr>\n<tr>\n<td><strong>Reference Test Vectors</strong></td>\n<td>Official test cases from JWT specification or trusted sources</td>\n<td>Provides authoritative validation of cryptographic correctness</td>\n</tr>\n<tr>\n<td><strong>Security Test Scenarios</strong></td>\n<td>Test cases specifically designed to detect timing attacks, algorithm confusion, and other vulnerabilities</td>\n<td>Essential for validating security properties beyond functional correctness</td>\n</tr>\n<tr>\n<td><strong>End-to-end Scenarios</strong></td>\n<td>Complete workflows testing token creation, transmission, and validation</td>\n<td>Validates entire authentication flow including error handling</td>\n</tr>\n<tr>\n<td><strong>Milestone Verification Points</strong></td>\n<td>Concrete checkpoints for validating completion of each development stage</td>\n<td>Ensures progressive implementation maintains security properties</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-implementation-pitfalls\">Common Implementation Pitfalls</h3>\n<p>Understanding these pitfalls helps developers avoid security vulnerabilities:</p>\n<p>⚠️ <strong>Pitfall: Regular Base64 vs Base64URL</strong>\nUsing standard Base64 encoding instead of Base64URL can cause tokens to break in URL contexts due to <code>+</code>, <code>/</code>, and <code>=</code> characters. Always use Base64URL encoding for JWT components to ensure URL safety.</p>\n<p>⚠️ <strong>Pitfall: Padding Handling</strong>\nIncorrectly handling Base64URL padding removal during encoding or restoration during decoding leads to malformed tokens. Implement proper padding logic according to RFC 4648.</p>\n<p>⚠️ <strong>Pitfall: Timing Attack Vulnerability</strong>\nUsing simple string or byte comparison for signature verification allows timing attacks. Always use constant-time comparison functions to prevent information leakage.</p>\n<p>⚠️ <strong>Pitfall: Algorithm Confusion</strong>\nNot validating the algorithm claim in JWT headers allows attackers to change from HMAC to RSA verification, bypassing signature checks. Always validate expected algorithm.</p>\n<p>⚠️ <strong>Pitfall: Clock Skew Misconfiguration</strong>\nSetting leeway periods too high extends attack windows, while too low causes legitimate authentication failures. Use 300 seconds as a reasonable default.</p>\n<p>⚠️ <strong>Pitfall: Key Length Weakness</strong>\nUsing keys shorter than 32 bytes for HMAC-SHA256 reduces security below acceptable levels. Always validate minimum key lengths.</p>\n<p>⚠️ <strong>Pitfall: Information Disclosure</strong>\nRevealing detailed error information in production environments helps attackers understand system internals. Implement security-aware error messages.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides practical guidance for implementing JWT terminology correctly in Python applications.</p>\n<h4 id=\"essential-libraries-and-dependencies\">Essential Libraries and Dependencies</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Recommended Library</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JSON Handling</td>\n<td><code>json</code> (standard library)</td>\n<td>Header and payload serialization</td>\n</tr>\n<tr>\n<td>Base64 Encoding</td>\n<td><code>base64</code> (standard library)</td>\n<td>Base64URL encoding/decoding</td>\n</tr>\n<tr>\n<td>Cryptography</td>\n<td><code>hmac</code> + <code>hashlib</code> (standard library)</td>\n<td>HMAC-SHA256 implementation</td>\n</tr>\n<tr>\n<td>Time Handling</td>\n<td><code>datetime</code> + <code>time</code> (standard library)</td>\n<td>Timestamp validation</td>\n</tr>\n<tr>\n<td>Secure Comparison</td>\n<td><code>hmac.compare_digest()</code></td>\n<td>Constant-time comparison</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>jwt_library/\n├── __init__.py                    # Public API exports\n├── core/\n│   ├── __init__.py\n│   ├── header.py                  # JWTHeader implementation\n│   ├── payload.py                 # JWTPayload implementation\n│   └── validation_context.py     # ValidationContext implementation\n├── encoding/\n│   ├── __init__.py\n│   ├── base64url.py              # Base64URL encoding utilities\n│   └── json_serializer.py       # JSON serialization utilities\n├── signing/\n│   ├── __init__.py\n│   ├── hmac_signer.py            # HMACSignerHS256 implementation\n│   └── key_handler.py            # SecureKeyHandler implementation\n├── validation/\n│   ├── __init__.py\n│   ├── claims_validator.py       # ClaimsValidator implementation\n│   ├── time_validator.py         # TimeValidator implementation\n│   └── identity_validator.py     # IdentityValidator implementation\n├── errors/\n│   ├── __init__.py\n│   └── exceptions.py             # All JWT exception classes\n└── utils/\n    ├── __init__.py\n    ├── time_utils.py             # UTC time handling utilities\n    └── constants.py              # All JWT constants</code></pre></div>\n\n<h4 id=\"core-constants-definition\">Core Constants Definition</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">JWT Library Constants</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Defines all standard values and security parameters used throughout the library.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Algorithm identifiers</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">HS256</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"HS256\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">RS256</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"RS256\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">ES256</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"ES256\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Token type identifier</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">JWT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"JWT\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Security parameters</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">MIN_KEY_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#6A737D\">                    # bytes</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">HMAC_SHA256_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#6A737D\">               # bytes</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">MIN_RSA_KEY_SIZE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 2048</span><span style=\"color:#6A737D\">              # bits</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">DEFAULT_LEEWAY_SECONDS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 300</span><span style=\"color:#6A737D\">          # seconds</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">DEFAULT_MAX_TOKEN_AGE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 86400</span><span style=\"color:#6A737D\">         # seconds (24 hours)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">DEFAULT_CACHE_TTL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 300</span><span style=\"color:#6A737D\">               # seconds</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">CACHE_MAX_SIZE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#6A737D\">                 # entries</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">DEFAULT_ROTATION_INTERVAL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 90</span><span style=\"color:#6A737D\">        # days</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ErrorSeverity</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Error severity levels for security classification.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CRITICAL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"CRITICAL\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    HIGH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"HIGH\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MEDIUM</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"MEDIUM\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LOW</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"LOW\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SecurityContext</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Security context classifications for environment-aware behavior.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DEVELOPMENT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"DEVELOPMENT\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PRODUCTION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"PRODUCTION\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AUDIT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"AUDIT\"</span></span></code></pre></div>\n\n<h4 id=\"time-utilities-implementation\">Time Utilities Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Time handling utilities for JWT validation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Provides timezone-aware time operations and Unix timestamp conversion.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timezone</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Union</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> utc_now</span><span style=\"color:#E1E4E8\">() -> datetime:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Get current UTC time as timezone-aware datetime.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        datetime: Current time in UTC timezone</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> datetime.now(timezone.utc)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> to_unix_timestamp</span><span style=\"color:#E1E4E8\">(dt: Union[datetime, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Convert datetime to Unix timestamp.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        dt: datetime object or existing timestamp</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        int: Unix timestamp (seconds since epoch)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        ValueError: If datetime is not timezone-aware</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(dt, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> dt</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> dt.tzinfo </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Datetime must be timezone-aware\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">(dt.timestamp())</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_expired</span><span style=\"color:#E1E4E8\">(exp_timestamp: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, leeway: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> DEFAULT_LEEWAY_SECONDS</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Check if timestamp is in the past (considering leeway).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        exp_timestamp: Expiration timestamp to check</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        leeway: Seconds of tolerance for clock skew</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        bool: True if timestamp is expired</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> current_time </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> (exp_timestamp </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> leeway)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_not_before</span><span style=\"color:#E1E4E8\">(nbf_timestamp: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, leeway: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> DEFAULT_LEEWAY_SECONDS</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Check if current time is before nbf timestamp.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        nbf_timestamp: Not-before timestamp to check</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        leeway: Seconds of tolerance for clock skew</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        bool: True if token is not yet valid</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> current_time </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> (nbf_timestamp </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> leeway)</span></span></code></pre></div>\n\n<h4 id=\"security-utilities-implementation\">Security Utilities Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Security utilities for cryptographically safe operations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Provides constant-time comparison and secure key handling.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hmac</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> secrets</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Union</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> constant_time_compare</span><span style=\"color:#E1E4E8\">(a: Union[</span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], b: Union[</span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Perform constant-time comparison of two values.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        a: First value to compare</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        b: Second value to compare</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        bool: True if values are equal</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Note:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Uses hmac.compare_digest for timing attack resistance</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(a, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        a </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> a.encode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(b, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        b </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> b.encode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> hmac.compare_digest(a, b)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> generate_secure_key</span><span style=\"color:#E1E4E8\">() -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Generate cryptographically secure 32-byte key.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        bytes: Random key suitable for HMAC-SHA256</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> secrets.token_bytes(</span><span style=\"color:#79B8FF\">MIN_KEY_LENGTH</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_key_strength</span><span style=\"color:#E1E4E8\">(key: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Validate key meets minimum security requirements.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        key: Key bytes to validate</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        ValueError: If key is too short or weak</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(key, </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Key must be bytes\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(key) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> MIN_KEY_LENGTH</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Key must be at least </span><span style=\"color:#79B8FF\">{MIN_KEY_LENGTH}</span><span style=\"color:#9ECBFF\"> bytes\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Additional entropy check could be added here</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # For now, length check provides basic security</span></span></code></pre></div>\n\n<h4 id=\"exception-base-classes\">Exception Base Classes</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">JWT Library Exceptions</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Defines the exception hierarchy for JWT validation failures.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> JWTValidationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Base exception for all JWT validation failures.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Attributes:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        component: Component where error occurred</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        operation: Operation being performed</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        severity: Error severity level</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        safe_message: External-safe error description</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        component: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"unknown\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        operation: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"unknown\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        severity: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> ErrorSeverity.</span><span style=\"color:#79B8FF\">MEDIUM</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        debug_info: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.component </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> component</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.operation </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> operation</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.severity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> severity</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.debug_info </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> debug_info </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.safe_message </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._create_safe_message()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _create_safe_message</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create production-safe error message without sensitive details.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"JWT validation failed in </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.component</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> StructuralError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTValidationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Token format and structure validation failures.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MalformedTokenError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">StructuralError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Invalid token structure or encoding.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TemporalValidationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTValidationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Time-based validation failures.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TokenExpiredError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">TemporalValidationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Token expiration validation failure.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TokenNotYetValidError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">TemporalValidationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Not-before validation failure.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> IdentityValidationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTValidationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Identity claim validation failures.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InvalidIssuerError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">IdentityValidationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Issuer validation failure.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InvalidAudienceError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">IdentityValidationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Audience validation failure.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CustomClaimValidationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTValidationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Custom claim validation failure.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MissingRequiredClaimError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">JWTValidationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Missing required claim failure.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"validation-context-factory-functions\">Validation Context Factory Functions</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Validation context factory functions for common JWT validation scenarios.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_strict_context</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    allowed_issuers: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expected_audience: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    required_claims: Optional[List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) -> ValidationContext:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Create strict validation context for high-security environments.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        allowed_issuers: List of permitted issuer values</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        expected_audience: Required audience value</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        required_claims: Additional required claim names</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        ValidationContext: Configured for strict validation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ValidationContext(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        verify_signature</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        verify_expiration</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        verify_not_before</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        leeway_seconds</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">60</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\"># Reduced leeway for strict mode</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        allowed_issuers</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">allowed_issuers,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        require_issuer</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        expected_audience</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">expected_audience,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        require_audience</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        required_claims</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">required_claims </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_permissive_context</span><span style=\"color:#E1E4E8\">() -> ValidationContext:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Create permissive validation context for development/testing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        ValidationContext: Configured for permissive validation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ValidationContext(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        verify_signature</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        verify_expiration</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        verify_not_before</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\"># Skip nbf in development</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        leeway_seconds</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">DEFAULT_LEEWAY_SECONDS</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        allowed_issuers</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">[],  </span><span style=\"color:#6A737D\"># Accept any issuer</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        require_issuer</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        expected_audience</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        require_audience</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        required_claims</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">[]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_custom_context</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs) -> ValidationContext:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Create custom validation context with specific requirements.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        **kwargs: ValidationContext field overrides</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        ValidationContext: Configured with custom settings</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    defaults </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'verify_signature'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'verify_expiration'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'verify_not_before'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'leeway_seconds'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">DEFAULT_LEEWAY_SECONDS</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'allowed_issuers'</span><span style=\"color:#E1E4E8\">: [],</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'require_issuer'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'expected_audience'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'require_audience'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'required_claims'</span><span style=\"color:#E1E4E8\">: []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    defaults.update(kwargs)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ValidationContext(</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">defaults)</span></span></code></pre></div>\n\n<h4 id=\"development-and-testing-utilities\">Development and Testing Utilities</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Development utilities for JWT library testing and debugging.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> debug_token_structure</span><span style=\"color:#E1E4E8\">(token: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Parse and display JWT token structure for debugging.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        token: JWT token string</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        dict: Parsed token components</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Note:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        For debugging only - does not validate signatures</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        parts </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> token.split(</span><span style=\"color:#9ECBFF\">'.'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(parts) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">\"error\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Invalid token structure\"</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        header_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> base64url_decode(parts[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        payload_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> base64url_decode(parts[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"header\"</span><span style=\"color:#E1E4E8\">: json.loads(header_data.decode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">)),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"payload\"</span><span style=\"color:#E1E4E8\">: json.loads(payload_data.decode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">)),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"signature_length\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(parts[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">\"error\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(e)}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_test_key</span><span style=\"color:#E1E4E8\">() -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Generate test key for development use.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        bytes: Test key (NOT for production)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Warning:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        This generates a predictable key for testing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Never use in production environments.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> b</span><span style=\"color:#9ECBFF\">\"test_key_32_bytes_for_development_\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_implementation_completeness</span><span style=\"color:#E1E4E8\">() -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Check if all required components are implemented.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        dict: Implementation status for each component</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    checks </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        from</span><span style=\"color:#E1E4E8\"> jwt_library.core </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> JWTHeader, JWTPayload, ValidationContext</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        checks[</span><span style=\"color:#9ECBFF\">\"core_types\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> ImportError</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        checks[</span><span style=\"color:#9ECBFF\">\"core_types\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        from</span><span style=\"color:#E1E4E8\"> jwt_library.encoding </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> base64url_encode, base64url_decode</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        checks[</span><span style=\"color:#9ECBFF\">\"encoding\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> ImportError</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        checks[</span><span style=\"color:#9ECBFF\">\"encoding\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        from</span><span style=\"color:#E1E4E8\"> jwt_library.signing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> HMACSignerHS256, SecureKeyHandler</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        checks[</span><span style=\"color:#9ECBFF\">\"signing\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> ImportError</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        checks[</span><span style=\"color:#9ECBFF\">\"signing\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        from</span><span style=\"color:#E1E4E8\"> jwt_library.validation </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ClaimsValidator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        checks[</span><span style=\"color:#9ECBFF\">\"validation\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> ImportError</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        checks[</span><span style=\"color:#9ECBFF\">\"validation\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> checks</span></span></code></pre></div>\n\n<p>This comprehensive glossary provides the foundation for understanding JWT security concepts and implementing the library correctly. Refer to these definitions throughout the implementation process to ensure consistent terminology and security practices.</p>\n","toc":[{"level":1,"text":"JWT Library: Design Document","id":"jwt-library-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Context and Problem Statement","id":"context-and-problem-statement"},{"level":3,"text":"Mental Model: The Concert Wristband","id":"mental-model-the-concert-wristband"},{"level":3,"text":"Existing Token Approaches","id":"existing-token-approaches"},{"level":4,"text":"Session Cookies: The Traditional Approach","id":"session-cookies-the-traditional-approach"},{"level":4,"text":"API Keys: Simple but Limited","id":"api-keys-simple-but-limited"},{"level":4,"text":"Bearer Tokens (Opaque): OAuth2 Standard","id":"bearer-tokens-opaque-oauth2-standard"},{"level":4,"text":"JWTs: Self-Contained Tokens","id":"jwts-self-contained-tokens"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended Project Structure","id":"recommended-project-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Implementation Skeleton","id":"core-logic-implementation-skeleton"},{"level":4,"text":"Language-Specific Implementation Hints","id":"language-specific-implementation-hints"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"Functional Requirements","id":"functional-requirements"},{"level":3,"text":"Security Requirements","id":"security-requirements"},{"level":3,"text":"Non-Goals","id":"non-goals"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"Component Responsibilities","id":"component-responsibilities"},{"level":4,"text":"Token Encoding Component","id":"token-encoding-component"},{"level":4,"text":"Cryptographic Signing Component","id":"cryptographic-signing-component"},{"level":4,"text":"Claims Validation Component","id":"claims-validation-component"},{"level":3,"text":"Recommended Module Structure","id":"recommended-module-structure"},{"level":4,"text":"Primary Module Layout","id":"primary-module-layout"},{"level":4,"text":"Module Responsibility Boundaries","id":"module-responsibility-boundaries"},{"level":4,"text":"Public API Surface","id":"public-api-surface"},{"level":3,"text":"Token Lifecycle Flow","id":"token-lifecycle-flow"},{"level":4,"text":"Token Creation Flow","id":"token-creation-flow"},{"level":4,"text":"Token Verification Flow","id":"token-verification-flow"},{"level":4,"text":"Data Flow State Transitions","id":"data-flow-state-transitions"},{"level":4,"text":"Component Interaction Patterns","id":"component-interaction-patterns"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Complete Infrastructure Code","id":"complete-infrastructure-code"},{"level":4,"text":"Core Component Skeletons","id":"core-component-skeletons"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Data Model","id":"data-model"},{"level":3,"text":"JWT Token Structure: The Three-Part JWT Format and Its Encoding Requirements","id":"jwt-token-structure-the-three-part-jwt-format-and-its-encoding-requirements"},{"level":3,"text":"Header Claims: Standard and Custom Header Fields With Their Types and Meanings","id":"header-claims-standard-and-custom-header-fields-with-their-types-and-meanings"},{"level":3,"text":"Payload Claims: Registered, Public, and Private Claims in the Payload Section","id":"payload-claims-registered-public-and-private-claims-in-the-payload-section"},{"level":3,"text":"Validation Context: Configuration and State Needed for Proper Token Verification","id":"validation-context-configuration-and-state-needed-for-proper-token-verification"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File/Module Structure","id":"recommended-filemodule-structure"},{"level":4,"text":"Core Data Structure Implementation","id":"core-data-structure-implementation"},{"level":4,"text":"Base64URL Encoding Utilities","id":"base64url-encoding-utilities"},{"level":4,"text":"Time Handling Utilities","id":"time-handling-utilities"},{"level":4,"text":"JSON Serialization Utilities","id":"json-serialization-utilities"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"Token Encoding Component","id":"token-encoding-component"},{"level":3,"text":"Mental Model: Document Preparation","id":"mental-model-document-preparation"},{"level":3,"text":"Base64URL Encoding","id":"base64url-encoding"},{"level":3,"text":"JSON Serialization Strategy","id":"json-serialization-strategy"},{"level":3,"text":"Architecture Decisions","id":"architecture-decisions"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Cryptographic Signing Component","id":"cryptographic-signing-component"},{"level":3,"text":"Mental Model: Wax Seal Authentication","id":"mental-model-wax-seal-authentication"},{"level":3,"text":"HMAC-SHA256 Implementation","id":"hmac-sha256-implementation"},{"level":3,"text":"Signature Verification Process","id":"signature-verification-process"},{"level":3,"text":"Secret Key Handling","id":"secret-key-handling"},{"level":3,"text":"Architecture Decisions","id":"architecture-decisions"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Claims Validation Component","id":"claims-validation-component"},{"level":3,"text":"Mental Model: Ticket Inspection","id":"mental-model-ticket-inspection"},{"level":3,"text":"Time-Based Claim Validation","id":"time-based-claim-validation"},{"level":3,"text":"Identity and Audience Validation","id":"identity-and-audience-validation"},{"level":3,"text":"Custom Claims Processing","id":"custom-claims-processing"},{"level":3,"text":"Architecture Decisions","id":"architecture-decisions"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Component Interactions and Data Flow","id":"component-interactions-and-data-flow"},{"level":3,"text":"Mental Model: The Document Authentication Office","id":"mental-model-the-document-authentication-office"},{"level":3,"text":"Token Creation Sequence","id":"token-creation-sequence"},{"level":4,"text":"Step-by-Step Creation Process","id":"step-by-step-creation-process"},{"level":4,"text":"Error Propagation in Token Creation","id":"error-propagation-in-token-creation"},{"level":3,"text":"Token Verification Sequence","id":"token-verification-sequence"},{"level":4,"text":"Step-by-Step Verification Process","id":"step-by-step-verification-process"},{"level":4,"text":"Validation Context Configuration","id":"validation-context-configuration"},{"level":3,"text":"Error Handling Flow","id":"error-handling-flow"},{"level":4,"text":"Error Classification and Hierarchy","id":"error-classification-and-hierarchy"},{"level":4,"text":"Error Context and Information Flow","id":"error-context-and-information-flow"},{"level":4,"text":"Component Error Handling Patterns","id":"component-error-handling-patterns"},{"level":4,"text":"Error Recovery and Fallback Strategies","id":"error-recovery-and-fallback-strategies"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended Module Structure","id":"recommended-module-structure"},{"level":4,"text":"Complete Token Manager Implementation","id":"complete-token-manager-implementation"},{"level":4,"text":"Error Context Infrastructure","id":"error-context-infrastructure"},{"level":4,"text":"Component Integration Helpers","id":"component-integration-helpers"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Debugging Component Interactions","id":"debugging-component-interactions"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"Error Classification","id":"error-classification"},{"level":3,"text":"Malformed Token Handling","id":"malformed-token-handling"},{"level":3,"text":"Cryptographic Error Handling","id":"cryptographic-error-handling"},{"level":3,"text":"Temporal Edge Cases","id":"temporal-edge-cases"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations","id":"a-technology-recommendations"},{"level":4,"text":"B. Recommended File Structure","id":"b-recommended-file-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"Testing Strategy","id":"testing-strategy"},{"level":3,"text":"Mental Model: Quality Assurance Laboratory","id":"mental-model-quality-assurance-laboratory"},{"level":3,"text":"Milestone Verification Points","id":"milestone-verification-points"},{"level":4,"text":"Milestone 1: JWT Structure Verification","id":"milestone-1-jwt-structure-verification"},{"level":4,"text":"Milestone 2: HMAC Signing Verification","id":"milestone-2-hmac-signing-verification"},{"level":4,"text":"Milestone 3: Claims Validation Verification","id":"milestone-3-claims-validation-verification"},{"level":3,"text":"Reference Test Vectors","id":"reference-test-vectors"},{"level":4,"text":"RFC 7515 Official Test Vectors","id":"rfc-7515-official-test-vectors"},{"level":4,"text":"Edge Case Test Vectors","id":"edge-case-test-vectors"},{"level":3,"text":"Security Test Scenarios","id":"security-test-scenarios"},{"level":4,"text":"Timing Attack Tests","id":"timing-attack-tests"},{"level":4,"text":"Algorithm Confusion Attack Tests","id":"algorithm-confusion-attack-tests"},{"level":4,"text":"Malformed Token Attack Tests","id":"malformed-token-attack-tests"},{"level":4,"text":"Cryptographic Attack Simulation","id":"cryptographic-attack-simulation"},{"level":3,"text":"End-to-End Scenarios","id":"end-to-end-scenarios"},{"level":4,"text":"Standard Authentication Flow","id":"standard-authentication-flow"},{"level":4,"text":"Multi-Service Authorization Scenario","id":"multi-service-authorization-scenario"},{"level":4,"text":"Error Handling and Recovery Scenario","id":"error-handling-and-recovery-scenario"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"Encoding and Parsing Issues","id":"encoding-and-parsing-issues"},{"level":3,"text":"Signature Verification Problems","id":"signature-verification-problems"},{"level":3,"text":"Claims Validation Issues","id":"claims-validation-issues"},{"level":3,"text":"Debugging Tools and Techniques","id":"debugging-tools-and-techniques"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Future Extensions","id":"future-extensions"},{"level":3,"text":"Mental Model: The Security Toolkit Evolution","id":"mental-model-the-security-toolkit-evolution"},{"level":3,"text":"Extension Architecture Principles","id":"extension-architecture-principles"},{"level":3,"text":"Additional Signature Algorithms","id":"additional-signature-algorithms"},{"level":4,"text":"Mental Model: Document Authentication Methods","id":"mental-model-document-authentication-methods"},{"level":4,"text":"RSA Signature Implementation (RS256)","id":"rsa-signature-implementation-rs256"},{"level":4,"text":"ECDSA Implementation (ES256)","id":"ecdsa-implementation-es256"},{"level":4,"text":"Algorithm Selection Framework","id":"algorithm-selection-framework"},{"level":4,"text":"Common Pitfalls in Algorithm Extensions","id":"common-pitfalls-in-algorithm-extensions"},{"level":3,"text":"Performance Enhancements","id":"performance-enhancements"},{"level":4,"text":"Mental Model: Document Processing Optimization","id":"mental-model-document-processing-optimization"},{"level":4,"text":"Token Caching Strategy","id":"token-caching-strategy"},{"level":4,"text":"Signature Verification Optimization","id":"signature-verification-optimization"},{"level":4,"text":"Memory Pool Management","id":"memory-pool-management"},{"level":4,"text":"Common Pitfalls in Performance Optimization","id":"common-pitfalls-in-performance-optimization"},{"level":3,"text":"Advanced JWT Features","id":"advanced-jwt-features"},{"level":4,"text":"Mental Model: Evolving Security Systems","id":"mental-model-evolving-security-systems"},{"level":4,"text":"JWE (JSON Web Encryption) Integration","id":"jwe-json-web-encryption-integration"},{"level":4,"text":"Automatic Key Rotation","id":"automatic-key-rotation"},{"level":4,"text":"Advanced Claims Processing","id":"advanced-claims-processing"},{"level":4,"text":"Common Pitfalls in Advanced Features","id":"common-pitfalls-in-advanced-features"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure for Extensions","id":"recommended-file-structure-for-extensions"},{"level":4,"text":"RSA Algorithm Implementation Starter Code","id":"rsa-algorithm-implementation-starter-code"},{"level":4,"text":"Token Verification Cache Implementation","id":"token-verification-cache-implementation"},{"level":4,"text":"Key Rotation System Foundation","id":"key-rotation-system-foundation"},{"level":4,"text":"Milestone Checkpoints for Extensions","id":"milestone-checkpoints-for-extensions"},{"level":4,"text":"Debugging Extension Issues","id":"debugging-extension-issues"},{"level":2,"text":"Glossary","id":"glossary"},{"level":3,"text":"Mental Model: The Technical Dictionary","id":"mental-model-the-technical-dictionary"},{"level":3,"text":"JWT Core Terminology","id":"jwt-core-terminology"},{"level":3,"text":"Cryptographic Concepts","id":"cryptographic-concepts"},{"level":3,"text":"Claims and Validation Terminology","id":"claims-and-validation-terminology"},{"level":3,"text":"Component Architecture Terms","id":"component-architecture-terms"},{"level":3,"text":"Time-based Security Concepts","id":"time-based-security-concepts"},{"level":3,"text":"Error Handling and Security Terms","id":"error-handling-and-security-terms"},{"level":3,"text":"Advanced JWT Concepts","id":"advanced-jwt-concepts"},{"level":3,"text":"Performance and Operational Terms","id":"performance-and-operational-terms"},{"level":3,"text":"Testing and Validation Terminology","id":"testing-and-validation-terminology"},{"level":3,"text":"Common Implementation Pitfalls","id":"common-implementation-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Essential Libraries and Dependencies","id":"essential-libraries-and-dependencies"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Core Constants Definition","id":"core-constants-definition"},{"level":4,"text":"Time Utilities Implementation","id":"time-utilities-implementation"},{"level":4,"text":"Security Utilities Implementation","id":"security-utilities-implementation"},{"level":4,"text":"Exception Base Classes","id":"exception-base-classes"},{"level":4,"text":"Validation Context Factory Functions","id":"validation-context-factory-functions"},{"level":4,"text":"Development and Testing Utilities","id":"development-and-testing-utilities"}],"title":"JWT Library: Design Document","markdown":"# JWT Library: Design Document\n\n\n## Overview\n\nThis system implements a JSON Web Token library for secure authentication and authorization workflows. The key architectural challenge is building a cryptographically secure token system that properly handles signing, verification, and claims validation while avoiding common security pitfalls like timing attacks and algorithm confusion.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n## Context and Problem Statement\n\n> **Milestone(s):** Foundation for all milestones - understanding the authentication problem space\n\nModern applications face a fundamental challenge: how to securely identify and authorize users across distributed systems. When a user logs into a web application, mobile app, or API service, the system must answer two critical questions: \"Who is this user?\" (authentication) and \"What are they allowed to do?\" (authorization). Traditional session-based authentication works well for monolithic applications but breaks down in distributed architectures with microservices, single-page applications, and mobile clients.\n\nThe core problem is **stateful vs. stateless authentication**. Session cookies require server-side storage to maintain user state, creating coupling between authentication and storage systems. This approach becomes problematic when requests need to flow between multiple services, each of which would need access to the shared session store. Additionally, mobile applications and single-page applications have different security constraints than traditional server-rendered web pages, making cookie-based sessions inadequate.\n\nJSON Web Tokens (JWTs) solve this problem by providing **self-contained, stateless authentication tokens**. Rather than storing user information on the server and referencing it with a session ID, JWTs embed the user information directly in the token itself. The token is cryptographically signed, making it tamper-evident without requiring server-side storage for validation.\n\nHowever, building a secure JWT implementation is deceptively challenging. While the basic concept appears straightforward—encode some JSON, sign it, and verify the signature—the security details are complex and unforgiving. Common vulnerabilities include timing attacks during signature verification, algorithm confusion attacks where attackers manipulate the signing algorithm, improper handling of time-based claims leading to replay attacks, and encoding issues that can corrupt token data.\n\n> **Key Insight**: JWTs shift the complexity from session management (storing state) to cryptographic verification (validating signatures and claims). This trade-off enables stateless, distributed authentication but requires careful attention to cryptographic security principles.\n\nThe challenge extends beyond basic signing and verification. Real-world JWT usage requires robust claims validation—checking that tokens haven't expired, that they're issued by trusted parties, and that they're intended for the current application. Time-based security adds another layer of complexity, as systems must handle clock skew between servers, leap seconds, and edge cases around token expiration boundaries.\n\n### Mental Model: The Concert Wristband\n\nTo understand JWT concepts intuitively, imagine the authentication system used at a large music festival. Traditional session-based authentication is like a **will-call system**: when you arrive, security checks your ID against a central database, gives you a generic entry stamp, and every time you want to access different areas (VIP section, backstage, food vendors), security must radio back to the central database to verify your privileges.\n\nJWTs work like **sophisticated wristbands** that contain all your information directly on the band itself. When you first authenticate (show your ticket and ID), instead of just getting a generic stamp, you receive a wristband that contains:\n\n- **Header information** (like the wristband material): What type of security system this is and how it's protected\n- **Your details** (like text printed on the band): Your identity, what areas you can access, when your access expires, which stages you're allowed near\n- **Security seal** (like a tamper-evident hologram): A cryptographic signature that proves the wristband was issued by official festival security and hasn't been modified\n\nThe key advantages of this wristband system mirror JWT benefits:\n\n**Self-contained verification**: Security guards at any stage don't need to radio back to a central database. They can look at your wristband, verify the security seal is intact and authentic, check that you're authorized for this area, and make an immediate access decision.\n\n**Distributed access control**: Different vendors, stages, and areas can all independently verify your wristband without coordinating with each other or maintaining shared state.\n\n**Expiration handling**: The wristband itself contains expiration information (\"Valid until Sunday 11:59 PM\"), so guards know when access should be revoked without consulting external systems.\n\nHowever, this system also introduces the same challenges as JWTs:\n\n**Security seal integrity**: If someone could forge or modify the holographic seal, they could create fake wristbands or upgrade their access level. Similarly, JWT signature verification must be cryptographically secure.\n\n**Time synchronization**: Guards need to know the current time to check expiration, and their clocks must be reasonably synchronized. If a guard's watch is hours off, they might accept expired wristbands or reject valid ones.\n\n**Revocation complexity**: If someone's wristband needs to be revoked mid-festival (they violated rules), there's no easy way to communicate this to all security guards since the system is designed to work without central coordination.\n\n**Information exposure**: Unlike a generic stamp, the wristband contains detailed information about the person and their privileges. If someone can read the wristband, they learn about the user's access level and identity.\n\nThis mental model helps explain why JWT implementation requires careful attention to cryptographic signatures (the security seal), time-based claim validation (expiration checking), and why certain operations like token revocation are inherently challenging in a stateless system.\n\n### Existing Token Approaches\n\nUnderstanding JWT requires comparing it with alternative authentication approaches, each with distinct trade-offs in complexity, security, and architectural flexibility.\n\n| Approach | State Management | Verification Process | Distribution Support | Security Model |\n|----------|-----------------|---------------------|-------------------|----------------|\n| Session Cookies | Server-side storage required | Database lookup on every request | Poor - requires shared storage | Server controls all state |\n| API Keys | Server-side storage typical | Database/cache lookup | Moderate - can be cached | Long-lived, hard to rotate |\n| Bearer Tokens (Opaque) | Server-side storage required | Token introspection endpoint | Good - centralized validation | Server controls validation |\n| JWTs | Stateless - no storage needed | Cryptographic signature check | Excellent - fully distributed | Cryptographic proof |\n\n#### Session Cookies: The Traditional Approach\n\nSession cookies represent the classical web authentication model. When a user logs in, the server generates a random session identifier, stores user information associated with that ID in a database or memory store, and sends the session ID to the client as an HTTP cookie. On subsequent requests, the server looks up the session ID to retrieve user information.\n\n**Advantages**: Session cookies provide strong security guarantees because the server maintains complete control over session state. Sessions can be immediately revoked by deleting the server-side record. The session ID itself contains no sensitive information, limiting exposure if intercepted. Cookie security features like `HttpOnly`, `Secure`, and `SameSite` provide robust protection against common web attacks.\n\n**Limitations**: The requirement for server-side storage creates significant architectural constraints. Multiple application servers must share a session store, introducing a stateful component that must be highly available and consistent. Microservices architectures become complex as each service needs access to the shared session state or must proxy authentication through a central service. Mobile applications and single-page applications have limited cookie support, especially for cross-origin requests. Horizontal scaling requires session store replication or sticky load balancing.\n\n> **Architectural Insight**: Session cookies optimize for security and immediate revocation at the cost of architectural flexibility. They work excellently for traditional server-rendered web applications but become impediments in modern distributed architectures.\n\n#### API Keys: Simple but Limited\n\nAPI keys provide a straightforward authentication mechanism where clients include a long-lived secret key with each request, typically in an HTTP header like `Authorization: Bearer api-key-12345`. The server validates the key against a database of registered keys and associated permissions.\n\n**Advantages**: API keys are conceptually simple for both implementers and consumers. They work well for machine-to-machine authentication and service integration scenarios. Keys can be easily generated, distributed, and managed through administrative interfaces. They have excellent tooling support and are widely understood by developers.\n\n**Limitations**: API keys are typically long-lived, making rotation complex and risky. They provide coarse-grained authorization—usually all-or-nothing access rather than fine-grained permissions. Revocation requires server-side storage lookup on every request. Keys often end up hardcoded in client applications or configuration files, creating security risks. They lack built-in expiration mechanisms, requiring external systems for time-based access control.\n\n**Use Cases**: API keys excel in server-to-server scenarios where security requirements are moderate and simplicity is valued over sophisticated access control. They're common for public API access, webhook authentication, and internal service communication.\n\n#### Bearer Tokens (Opaque): OAuth2 Standard\n\nOpaque bearer tokens, standardized in OAuth2, provide a middle ground between sessions and JWTs. Clients receive a token (usually a random string) during authentication and include it in an `Authorization: Bearer` header. The server validates tokens by calling a token introspection endpoint or checking against a token database.\n\n**Advantages**: Bearer tokens separate authentication from authorization, allowing specialized authorization servers. They support sophisticated OAuth2 flows for third-party application integration. Tokens can be revoked immediately by updating the central token registry. They work well across different client types (web, mobile, server) and support fine-grained scope-based permissions.\n\n**Limitations**: Token validation requires a network call to the authorization server or shared database access, creating latency and availability dependencies. The introspection endpoint becomes a bottleneck and single point of failure. Caching tokens for performance creates a trade-off with revocation timeliness. The OAuth2 specification complexity can lead to implementation errors and security vulnerabilities.\n\n**Use Cases**: OAuth2 bearer tokens are ideal for scenarios requiring immediate revocation, third-party application integration, or complex authorization flows. They're common in enterprise API gateways and identity provider integrations.\n\n#### JWTs: Self-Contained Tokens\n\nJWTs take a fundamentally different approach by encoding all necessary information directly into the token itself, secured with cryptographic signatures. Rather than requiring server-side lookups, consuming services can independently verify and extract information from the token.\n\n**Advantages**: JWTs enable truly stateless authentication, eliminating the need for shared databases or session stores. They scale horizontally without coordination between servers. Microservices can independently verify tokens without calling back to authentication services. They work excellently across different client types and support cross-origin requests naturally. Token validation is fast—just signature verification and claims checking without network calls.\n\n**Limitations**: Token revocation is complex since there's no central registry to update. Tokens can become large if they contain extensive claims information, increasing bandwidth usage. All services must have access to signing keys or key verification capabilities. Time-based security requires synchronized clocks across all services. Sensitive information in tokens is base64-encoded (not encrypted) and readable by clients.\n\n> **Decision: JWT vs. Alternatives for Distributed Systems**\n> - **Context**: Modern applications increasingly use microservices architectures, single-page applications, and mobile clients that make frequent API calls across service boundaries\n> - **Options Considered**: Session cookies with shared storage, OAuth2 bearer tokens with introspection, JWTs with local verification\n> - **Decision**: JWTs provide the best balance of security, performance, and architectural flexibility for distributed systems\n> - **Rationale**: Stateless verification eliminates shared storage dependencies, reduces latency by avoiding network calls during validation, and enables independent service scaling. The complexity of cryptographic implementation is offset by simplified deployment and operational characteristics\n> - **Consequences**: Teams must invest in secure JWT implementation but gain architectural flexibility and improved performance. Token revocation requires alternative strategies like short expiration times and refresh token patterns\n\nThe choice between these approaches depends on specific architectural requirements, security constraints, and operational capabilities. JWTs excel in distributed environments where stateless operation and performance are priorities, while session cookies remain optimal for traditional web applications with strong revocation requirements. Understanding these trade-offs is essential for making informed authentication architecture decisions.\n\n### Implementation Guidance\n\nBuilding a JWT library requires careful selection of cryptographic primitives, proper project organization, and a clear understanding of the security requirements that distinguish production-ready implementations from educational examples.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option | Rationale |\n|-----------|---------------|-----------------|-----------|\n| JSON Handling | `json` standard library | `ujson` or `orjson` for performance | Standard library provides consistency; advanced parsers optimize for speed but add complexity |\n| Base64URL Encoding | Custom implementation using `base64` | `python-jose` library functions | Educational value in implementing encoding; libraries provide battle-tested edge case handling |\n| HMAC Computation | `hmac` standard library | `cryptography` library | Standard library sufficient for HS256; cryptography library needed for RSA/ECDSA algorithms |\n| Time Handling | `datetime` with UTC enforcement | `arrow` or `pendulum` libraries | UTC handling is critical; advanced libraries provide better timezone and parsing support |\n| Secret Management | Environment variables | `keyring` or dedicated secret management | Environment variables work for development; production requires proper secret rotation |\n\n#### Recommended Project Structure\n\nOrganize the JWT library into focused modules that separate concerns and enable incremental development:\n\n```\njwt-library/\n  src/jwt_lib/\n    __init__.py              ← Public API exports\n    encoder.py               ← Token encoding and Base64URL (Milestone 1)\n    signer.py                ← HMAC signing and verification (Milestone 2)\n    validator.py             ← Claims validation logic (Milestone 3)\n    exceptions.py            ← JWT-specific exception classes\n    models.py                ← Data classes for headers, payloads, tokens\n    utils.py                 ← Shared utilities (time handling, constants)\n  tests/\n    test_encoder.py          ← Encoding and structure tests\n    test_signer.py           ← Cryptographic operation tests\n    test_validator.py        ← Claims validation tests\n    test_vectors.py          ← RFC test vectors and reference data\n    conftest.py              ← Pytest fixtures and test utilities\n  examples/\n    basic_usage.py           ← Simple token creation and verification\n    web_integration.py       ← Flask/FastAPI integration example\n    microservice_auth.py     ← Service-to-service authentication\n  docs/\n    security_considerations.md ← Deployment and security guidance\n```\n\nThis structure enables milestone-based development where each component can be built and tested independently before integration.\n\n#### Infrastructure Starter Code\n\n**Complete Time Utilities Module (`utils.py`)**:\n\n```python\n\"\"\"\nUtilities for JWT time handling and validation.\nHandles UTC enforcement, clock skew tolerance, and timestamp conversion.\n\"\"\"\nimport datetime\nfrom typing import Optional, Union\n\n# Default clock skew tolerance (5 minutes)\nDEFAULT_LEEWAY_SECONDS = 300\n\ndef utc_now() -> datetime.datetime:\n    \"\"\"Get current UTC time as timezone-aware datetime.\"\"\"\n    return datetime.datetime.now(datetime.timezone.utc)\n\ndef to_unix_timestamp(dt: datetime.datetime) -> int:\n    \"\"\"Convert datetime to Unix timestamp (seconds since epoch).\"\"\"\n    if dt.tzinfo is None:\n        # Assume naive datetime is UTC\n        dt = dt.replace(tzinfo=datetime.timezone.utc)\n    return int(dt.timestamp())\n\ndef from_unix_timestamp(timestamp: Union[int, float]) -> datetime.datetime:\n    \"\"\"Convert Unix timestamp to UTC datetime.\"\"\"\n    return datetime.datetime.fromtimestamp(timestamp, tz=datetime.timezone.utc)\n\ndef is_expired(exp_timestamp: Optional[int], leeway: int = DEFAULT_LEEWAY_SECONDS) -> bool:\n    \"\"\"\n    Check if a timestamp represents an expired time.\n    \n    Args:\n        exp_timestamp: Unix timestamp for expiration, None means never expires\n        leeway: Clock skew tolerance in seconds\n    \n    Returns:\n        True if the timestamp is in the past (accounting for leeway)\n    \"\"\"\n    if exp_timestamp is None:\n        return False\n    \n    current_time = to_unix_timestamp(utc_now())\n    return current_time > (exp_timestamp + leeway)\n\ndef is_not_before(nbf_timestamp: Optional[int], leeway: int = DEFAULT_LEEWAY_SECONDS) -> bool:\n    \"\"\"\n    Check if current time is before a 'not before' timestamp.\n    \n    Args:\n        nbf_timestamp: Unix timestamp for 'not before', None means no restriction\n        leeway: Clock skew tolerance in seconds\n    \n    Returns:\n        True if current time is before the nbf time (accounting for leeway)\n    \"\"\"\n    if nbf_timestamp is None:\n        return False\n    \n    current_time = to_unix_timestamp(utc_now())\n    return current_time < (nbf_timestamp - leeway)\n```\n\n**Complete Exception Classes (`exceptions.py`)**:\n\n```python\n\"\"\"\nJWT-specific exceptions that provide clear error categorization.\nEach exception type corresponds to a specific validation failure mode.\n\"\"\"\n\nclass JWTError(Exception):\n    \"\"\"Base exception for all JWT-related errors.\"\"\"\n    pass\n\nclass InvalidTokenError(JWTError):\n    \"\"\"Raised when token structure or encoding is invalid.\"\"\"\n    pass\n\nclass InvalidSignatureError(JWTError):\n    \"\"\"Raised when token signature verification fails.\"\"\"\n    pass\n\nclass ExpiredTokenError(JWTError):\n    \"\"\"Raised when token has expired (exp claim).\"\"\"\n    pass\n\nclass NotBeforeError(JWTError):\n    \"\"\"Raised when token is not yet valid (nbf claim).\"\"\"\n    pass\n\nclass InvalidIssuerError(JWTError):\n    \"\"\"Raised when token issuer is not in allowlist.\"\"\"\n    pass\n\nclass InvalidAudienceError(JWTError):\n    \"\"\"Raised when token audience doesn't match expected value.\"\"\"\n    pass\n\nclass MissingRequiredClaimError(JWTError):\n    \"\"\"Raised when a required claim is missing from the token.\"\"\"\n    pass\n```\n\n**Complete Data Models (`models.py`)**:\n\n```python\n\"\"\"\nData classes representing JWT components and validation context.\nThese provide type safety and clear interfaces for token manipulation.\n\"\"\"\nfrom dataclasses import dataclass, field\nfrom typing import Dict, Any, Optional, List, Union\nimport json\n\n@dataclass\nclass JWTHeader:\n    \"\"\"Represents the JWT header section.\"\"\"\n    alg: str = \"HS256\"  # Algorithm used for signing\n    typ: str = \"JWT\"    # Token type\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert header to dictionary for JSON serialization.\"\"\"\n        return {\"alg\": self.alg, \"typ\": self.typ}\n    \n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> 'JWTHeader':\n        \"\"\"Create header from dictionary.\"\"\"\n        return cls(alg=data.get(\"alg\", \"HS256\"), typ=data.get(\"typ\", \"JWT\"))\n\n@dataclass\nclass JWTPayload:\n    \"\"\"Represents the JWT payload section with standard and custom claims.\"\"\"\n    # Registered claims (RFC 7519)\n    iss: Optional[str] = None  # Issuer\n    sub: Optional[str] = None  # Subject\n    aud: Optional[Union[str, List[str]]] = None  # Audience\n    exp: Optional[int] = None  # Expiration time\n    nbf: Optional[int] = None  # Not before\n    iat: Optional[int] = None  # Issued at\n    jti: Optional[str] = None  # JWT ID\n    \n    # Custom claims\n    custom_claims: Dict[str, Any] = field(default_factory=dict)\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert payload to dictionary, including only non-None values.\"\"\"\n        result = {}\n        \n        # Add standard claims if present\n        if self.iss is not None:\n            result[\"iss\"] = self.iss\n        if self.sub is not None:\n            result[\"sub\"] = self.sub\n        if self.aud is not None:\n            result[\"aud\"] = self.aud\n        if self.exp is not None:\n            result[\"exp\"] = self.exp\n        if self.nbf is not None:\n            result[\"nbf\"] = self.nbf\n        if self.iat is not None:\n            result[\"iat\"] = self.iat\n        if self.jti is not None:\n            result[\"jti\"] = self.jti\n        \n        # Add custom claims\n        result.update(self.custom_claims)\n        return result\n    \n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> 'JWTPayload':\n        \"\"\"Create payload from dictionary, separating standard and custom claims.\"\"\"\n        standard_claims = {\n            \"iss\", \"sub\", \"aud\", \"exp\", \"nbf\", \"iat\", \"jti\"\n        }\n        \n        # Extract standard claims\n        payload_args = {}\n        custom_claims = {}\n        \n        for key, value in data.items():\n            if key in standard_claims:\n                payload_args[key] = value\n            else:\n                custom_claims[key] = value\n        \n        payload_args[\"custom_claims\"] = custom_claims\n        return cls(**payload_args)\n\n@dataclass\nclass ValidationContext:\n    \"\"\"Configuration and context for JWT validation.\"\"\"\n    # Required validations\n    verify_signature: bool = True\n    verify_expiration: bool = True\n    verify_not_before: bool = True\n    \n    # Clock skew tolerance\n    leeway_seconds: int = 300  # 5 minutes default\n    \n    # Issuer validation\n    allowed_issuers: Optional[List[str]] = None\n    require_issuer: bool = False\n    \n    # Audience validation\n    expected_audience: Optional[str] = None\n    require_audience: bool = False\n    \n    # Custom claim requirements\n    required_claims: List[str] = field(default_factory=list)\n```\n\n#### Core Logic Implementation Skeleton\n\nThe following skeleton provides the structure for implementing core JWT operations while leaving the essential learning components for the student to complete:\n\n**Token Encoder Skeleton (`encoder.py`)**:\n\n```python\n\"\"\"\nJWT token encoding and Base64URL implementation.\nStudents implement the core encoding logic following the numbered steps.\n\"\"\"\nimport json\nimport base64\nfrom typing import Dict, Any\nfrom .models import JWTHeader, JWTPayload\nfrom .exceptions import InvalidTokenError\n\ndef base64url_encode(data: bytes) -> str:\n    \"\"\"\n    Encode bytes to Base64URL format (RFC 4648 Section 5).\n    Base64URL uses URL-safe characters and removes padding.\n    \"\"\"\n    # TODO 1: Use base64.urlsafe_b64encode() to encode the input bytes\n    # TODO 2: Decode the result to get a string (it returns bytes)\n    # TODO 3: Remove any trailing '=' padding characters using rstrip()\n    # TODO 4: Return the URL-safe, padding-free string\n    # Hint: Base64URL differs from regular Base64 in character set and padding\n    pass\n\ndef base64url_decode(data: str) -> bytes:\n    \"\"\"\n    Decode Base64URL format back to bytes.\n    Must handle missing padding by adding it back.\n    \"\"\"\n    # TODO 1: Calculate padding needed: missing = (4 - len(data) % 4) % 4\n    # TODO 2: Add '=' characters for padding: data += '=' * missing\n    # TODO 3: Use base64.urlsafe_b64decode() to decode the padded string\n    # TODO 4: Return the decoded bytes\n    # Hint: Base64 requires length to be multiple of 4, so we add padding back\n    pass\n\ndef encode_token_parts(header: JWTHeader, payload: JWTPayload) -> tuple[str, str]:\n    \"\"\"\n    Encode header and payload sections of JWT.\n    Returns (encoded_header, encoded_payload) tuple.\n    \"\"\"\n    # TODO 1: Convert header to dictionary using header.to_dict()\n    # TODO 2: Serialize header dict to JSON string using json.dumps()\n    # TODO 3: Encode header JSON to bytes using .encode('utf-8')\n    # TODO 4: Apply Base64URL encoding to header bytes\n    # TODO 5: Repeat steps 1-4 for payload\n    # TODO 6: Return tuple of (encoded_header, encoded_payload)\n    # Hint: Consistent JSON serialization is important for signature verification\n    pass\n```\n\n#### Language-Specific Implementation Hints\n\n**Python Cryptographic Libraries:**\n- Use `hmac.new(key, message, hashlib.sha256)` for HMAC-SHA256 computation\n- Always call `hmac.digest()` to get bytes, not `hexdigest()` which returns hex strings\n- Use `hmac.compare_digest()` for constant-time signature comparison to prevent timing attacks\n\n**JSON Serialization Consistency:**\n- Use `json.dumps(data, separators=(',', ':'), sort_keys=True)` for consistent output\n- The `separators` parameter removes extra whitespace\n- The `sort_keys` parameter ensures consistent key ordering for reproducible signatures\n\n**Time Handling Best Practices:**\n- Always work with UTC timestamps to avoid timezone confusion\n- Use `datetime.datetime.now(datetime.timezone.utc)` instead of `datetime.utcnow()` (deprecated)\n- Convert to Unix timestamps using `int(dt.timestamp())` for JWT claims\n\n**Error Handling Patterns:**\n- Catch specific exceptions (`json.JSONDecodeError`, `base64.binascii.Error`) and re-raise as `InvalidTokenError`\n- Validate input types early: check that tokens are strings, keys are bytes, etc.\n- Provide descriptive error messages that help with debugging but don't leak sensitive information\n\n#### Milestone Checkpoints\n\n**Milestone 1 Checkpoint (Token Encoding):**\nAfter implementing the encoding components, verify functionality with:\n\n```bash\npython -m pytest tests/test_encoder.py -v\n```\n\nExpected behavior:\n- `base64url_encode(b\"hello\")` should return `\"aGVsbG8\"` (no padding)\n- `base64url_decode(\"aGVsbG8\")` should return `b\"hello\"`\n- Header encoding should produce valid Base64URL that decodes back to original JSON\n- Complete token structure should have exactly two dots separating three parts\n\nManual verification:\n```python\nfrom jwt_lib.encoder import encode_token_parts\nfrom jwt_lib.models import JWTHeader, JWTPayload\n\nheader = JWTHeader()\npayload = JWTPayload(sub=\"user123\", exp=1234567890)\nh, p = encode_token_parts(header, payload)\nprint(f\"Header: {h}\")\nprint(f\"Payload: {p}\")\n# Should produce readable JSON when decoded at jwt.io\n```\n\n**Security Validation Points:**\n- Verify that Base64URL encoding produces URL-safe output (no `+` or `/` characters)\n- Confirm that padding is properly removed and restored during encode/decode cycles\n- Test edge cases: empty payloads, Unicode characters in custom claims, very long tokens\n\nSigns of problems:\n- \"Invalid character\" errors usually indicate Base64URL vs regular Base64 confusion\n- JSON decode errors suggest inconsistent serialization or encoding corruption\n- Token structure errors typically mean incorrect dot-separated format assembly\n\n\n## Goals and Non-Goals\n\n> **Milestone(s):** Foundation for all three milestones - establishes scope and security requirements for the entire JWT library\n\nBefore diving into implementation details, we must establish clear boundaries for our JWT library. Like defining the requirements for a security system before building it, understanding what we will and will not implement prevents scope creep and ensures we focus on the core learning objectives while maintaining security best practices.\n\nThe goals and non-goals for our JWT library emerge from the fundamental tension between simplicity and completeness. We want to build something robust enough to demonstrate real-world JWT concepts, yet focused enough that learners can master the core principles without getting lost in enterprise-grade feature complexity.\n\n### Functional Requirements\n\nOur JWT library must provide the essential operations that any production-ready JWT implementation would offer. These requirements directly support the three milestone progression: basic token structure, cryptographic signing, and comprehensive validation.\n\n**Core JWT Operations**\n\nThe library must support the complete JWT lifecycle from token creation through verification. This means providing clean APIs for both token producers (services that issue JWTs) and token consumers (services that validate incoming JWTs).\n\n| Operation | Input Parameters | Expected Output | Purpose |\n|-----------|-----------------|-----------------|---------|\n| `create_token` | `JWTHeader`, `JWTPayload`, secret key | Signed JWT string | Generate new authentication tokens |\n| `verify_token` | JWT string, secret key, `ValidationContext` | Decoded `JWTPayload` or error | Validate and extract claims from tokens |\n| `decode_header` | JWT string | `JWTHeader` or error | Extract header without verification (debugging) |\n| `decode_payload` | JWT string | `JWTPayload` or error | Extract payload without verification (debugging) |\n| `encode_token_parts` | `JWTHeader`, `JWTPayload` | Base64URL header, payload strings | Support custom signing workflows |\n\nThe token creation operation must handle the complete assembly process: JSON serialization of header and payload, Base64URL encoding of both parts, HMAC-SHA256 signature generation over the signing input, and final concatenation into the standard three-part format. This operation serves as the primary interface for authentication services issuing tokens to users after successful login.\n\nToken verification represents the most complex functional requirement. It must parse the three-part token structure, decode Base64URL components back to JSON, recompute the HMAC signature using the provided secret key, perform constant-time signature comparison to prevent timing attacks, and validate all time-based and identity claims according to the provided validation context. This operation serves as the primary interface for protected services validating incoming requests.\n\n**JWT Structure Compliance**\n\nOur implementation must strictly adhere to RFC 7519 JWT specifications and RFC 7515 JWS (JSON Web Signature) specifications for the structural format. This ensures interoperability with other JWT libraries and services.\n\nThe header component must contain the algorithm identifier (`alg`) set to `HS256` for HMAC-SHA256 signatures, and the token type (`typ`) set to `JWT` to indicate this is a JSON Web Token. Additional header fields are explicitly out of scope for this learning-focused implementation.\n\nThe payload component must support all standard registered claims defined in RFC 7519. These include issuer (`iss`) for identifying the token creator, subject (`sub`) for identifying the token recipient, audience (`aud`) for specifying intended token consumers, expiration time (`exp`) for token lifetime management, not-before time (`nbf`) for delayed token activation, issued-at time (`iat`) for token creation tracking, and JWT ID (`jti`) for unique token identification.\n\nCustom claims support is essential for real-world usage. The payload must accommodate arbitrary application-specific claims while ensuring they don't conflict with registered claim names. This flexibility allows authentication services to embed user roles, permissions, session identifiers, or other application state into tokens.\n\n**Base64URL Encoding Requirements**\n\nProper Base64URL encoding is critical for JWT compliance and security. Our implementation must use the URL-safe Base64 variant that replaces plus signs with hyphens, forward slashes with underscores, and removes padding equals characters entirely.\n\n| Encoding Requirement | Standard Base64 | Required Base64URL | Rationale |\n|---------------------|-----------------|-------------------|-----------|\n| Character 62 | `+` | `-` | URL safety in query parameters |\n| Character 63 | `/` | `_` | URL safety in path segments |\n| Padding | `=` characters | No padding | Reduces token length, prevents encoding issues |\n| Line breaks | Allowed | Forbidden | Ensures single-line tokens |\n\nThe encoding process must handle the padding restoration correctly during decoding. When decoding Base64URL back to bytes, the implementation must calculate the required padding length using modulo arithmetic and append the appropriate number of equals characters before performing standard Base64 decoding.\n\n**Time-Based Claim Processing**\n\nTime-based claims require careful handling to balance security with practical clock synchronization challenges in distributed systems. Our implementation must support configurable clock skew tolerance while maintaining security properties.\n\nThe expiration claim (`exp`) validation must compare the claim timestamp against the current UTC time plus a configurable leeway period. Tokens with expiration times in the past (accounting for leeway) must be rejected with a specific expiration error that applications can handle appropriately.\n\nThe not-before claim (`nbf`) validation must ensure the current time is after the claim timestamp minus the leeway period. This supports use cases where tokens are issued for future activation, such as scheduled access grants or time-delayed permissions.\n\nThe issued-at claim (`iat`) validation must verify the timestamp is not unreasonably far in the past or future. This prevents token replay attacks using very old tokens and detects clock synchronization issues that might indicate system compromise.\n\n### Security Requirements\n\nSecurity requirements for our JWT library extend beyond basic functionality to address the cryptographic and temporal attack vectors that commonly compromise token-based authentication systems.\n\n**Cryptographic Security Properties**\n\nThe HMAC-SHA256 implementation must provide strong cryptographic guarantees against signature forgery and manipulation attacks. The secret key must be used directly in HMAC computation without additional processing that might weaken the cryptographic properties.\n\n| Security Property | Requirement | Attack Prevention |\n|------------------|-------------|-------------------|\n| Signature integrity | HMAC-SHA256 over header.payload | Prevents token tampering |\n| Key confidentiality | Secret key never logged or exposed | Prevents signature forgery |\n| Constant-time comparison | Signature verification immune to timing analysis | Prevents timing side-channel attacks |\n| Algorithm specification | Header `alg` field enforced strictly | Prevents algorithm confusion attacks |\n\nConstant-time comparison is crucial for signature verification security. The implementation must use a comparison function that takes the same amount of time regardless of where the compared byte sequences differ. This prevents timing attacks where malicious actors measure response times to gradually discover valid signatures.\n\nSecret key handling requires careful memory management. The key should be stored securely in memory without unnecessary copying, never written to logs or error messages, and cleared from memory when no longer needed (though Python's garbage collection makes secure clearing challenging).\n\n**Algorithm Confusion Attack Prevention**\n\nAlgorithm confusion attacks exploit JWT libraries that allow attackers to change the signing algorithm specified in the token header. Our implementation must enforce strict algorithm verification to prevent these attacks.\n\nThe most dangerous variant involves changing from HMAC algorithms to asymmetric algorithms like RS256. An attacker might change `alg` from `HS256` to `RS256`, then use the known public key as the \"secret\" to forge signatures. Our implementation prevents this by validating that the header algorithm matches the expected algorithm before performing any signature verification.\n\n> **Critical Security Insight**: Never trust the algorithm specified in the JWT header without verification. Always validate that the algorithm matches what your application expects before processing the signature.\n\n**Timing Attack Resistance**\n\nTiming attacks against JWT verification exploit small differences in processing time to extract cryptographic secrets or bypass security checks. Our implementation must provide consistent execution times for both successful and failed verification attempts.\n\nThe primary timing attack vector occurs during signature comparison. If comparison fails fast on the first differing byte, attackers can measure response times to gradually construct valid signatures. Our constant-time comparison function must examine every byte of both signatures regardless of when differences are detected.\n\nSecondary timing attacks can occur during claims validation if different validation failures take significantly different processing times. While perfect timing uniformity is difficult to achieve, the implementation should avoid obvious timing differences like expensive database lookups for some validation failures but not others.\n\n**Clock Skew Tolerance**\n\nTime-based claim validation must balance security with practical distributed system realities. Perfect clock synchronization between token issuers and validators is impossible, requiring configurable tolerance for time differences.\n\nThe default leeway of `DEFAULT_LEEWAY_SECONDS` (300 seconds) provides reasonable tolerance for typical network time protocol (NTP) synchronization while limiting the window for potential abuse. This value represents a compromise between security (smaller windows are better) and reliability (larger windows accommodate more clock drift).\n\n| Time Validation | Without Leeway | With 5-Minute Leeway | Security Impact |\n|----------------|----------------|---------------------|------------------|\n| Token expires 11:00:00 | Rejected at 11:00:01 | Rejected at 11:05:01 | 5-minute extended exposure |\n| Token not-before 11:00:00 | Accepted at 10:59:59 | Accepted at 10:55:00 | 5-minute early access |\n| Clock drift tolerance | Frequent false rejections | Reliable validation | Improved user experience |\n\nApplications with higher security requirements can reduce the leeway period, while applications prioritizing reliability over absolute security can increase it. The key is making this configurable rather than hardcoded.\n\n### Non-Goals\n\nExplicitly defining what our JWT library will not implement is as important as defining what it will implement. These non-goals help maintain focus on the core learning objectives while acknowledging the broader JWT ecosystem.\n\n**Advanced Cryptographic Algorithms**\n\nOur implementation deliberately limits itself to HMAC-SHA256 (`HS256`) signatures only. We will not implement RSA signatures (RS256), ECDSA signatures (ES256/ES384/ES512), or other advanced cryptographic algorithms defined in the JWS specification.\n\nThis limitation serves multiple purposes. First, it keeps the cryptographic complexity manageable for learners focusing on JWT concepts rather than advanced cryptography. Second, it avoids the key management complexity that asymmetric algorithms introduce. Third, it prevents the implementation complexity that algorithm negotiation and validation would require.\n\n> **Design Decision**: HMAC-SHA256 provides sufficient cryptographic security for the learning objectives while avoiding the certificate management, key distribution, and algorithm negotiation complexities that asymmetric algorithms introduce.\n\n**JSON Web Encryption (JWE)**\n\nWe will not implement JWE capabilities for encrypting JWT payloads. JWE addresses confidentiality concerns (hiding claim contents from anyone who can see the token), while our focus is on integrity and authenticity (ensuring tokens haven't been tampered with and come from trusted issuers).\n\nJWE implementation would require additional cryptographic primitives (symmetric encryption, key derivation functions, authenticated encryption modes), content encryption key management, and recipient key handling. These complexities detract from the core JWT concepts without significantly enhancing the learning experience.\n\n**Key Rotation and Management**\n\nAdvanced key management features like automatic key rotation, key versioning, multiple concurrent keys, and key distribution mechanisms are explicitly out of scope. Our implementation assumes a single, static secret key shared between token issuers and validators.\n\nReal production systems require sophisticated key management to handle key compromise, regular rotation for security hygiene, and zero-downtime key updates. However, these operational concerns distract from the fundamental JWT concepts and would require additional infrastructure (key storage systems, coordination mechanisms, backward compatibility handling) beyond the scope of a learning implementation.\n\n**Performance Optimizations**\n\nWe will not implement performance optimizations like signature verification caching, batch token processing, or streaming JSON parsing. Our focus is on correctness and security rather than high-throughput production performance.\n\nPerformance optimizations often introduce complexity that obscures the fundamental algorithms and security properties we're trying to teach. Caching mechanisms require cache invalidation strategies, batch processing requires careful error isolation, and streaming parsing requires state management that distracts from the core JWT concepts.\n\n**Enterprise Features**\n\nEnterprise-grade features like token introspection endpoints (RFC 7662), token revocation (RFC 7009), dynamic client registration, and OAuth 2.0 integration are out of scope. These features represent important production capabilities but extend well beyond JWT fundamentals into broader authentication and authorization protocol ecosystems.\n\n| Feature Category | Examples | Why Out of Scope |\n|-----------------|----------|------------------|\n| OAuth 2.0 Integration | Authorization code flows, client credentials | Focuses on authorization protocol rather than JWT structure |\n| Token Management | Revocation lists, introspection endpoints | Requires persistent storage and distributed coordination |\n| Client Management | Dynamic registration, client authentication | Involves certificate management and PKI concepts |\n| Advanced Claims | Hierarchical claims, claim transformation | Adds application-specific complexity without JWT insights |\n\n**Framework Integration**\n\nWe will not provide direct integrations with web frameworks (Express.js middleware, Django authentication backends, Gin handlers) or cloud platforms (AWS Cognito, Auth0, Firebase Auth). Our library will provide clean, framework-agnostic APIs that could be integrated with any framework but won't include the integration code itself.\n\nFramework integrations require understanding each framework's authentication model, request/response handling patterns, and error reporting mechanisms. This knowledge is valuable for production deployment but distracts from the JWT-specific learning objectives.\n\n**Database Integration**\n\nFeatures requiring persistent storage like user management, session tracking, token blacklisting, or audit logging are out of scope. Our implementation will be completely stateless, validating tokens based solely on their cryptographic properties and embedded claims.\n\nStateless validation is one of JWT's key advantages over traditional session-based authentication, and maintaining this property simplifies the implementation while reinforcing the conceptual benefits of token-based authentication.\n\n> **Architecture Principle**: Our JWT library embraces stateless authentication as a core design principle. All token validation decisions must be made based solely on the token contents and the shared secret key, without requiring database lookups or external service calls.\n\n**Advanced Validation Rules**\n\nComplex validation rules like claim interdependency checking, conditional validation logic, or custom validation plugins are out of scope. Our validation will focus on the standard registered claims and basic custom claim extraction without sophisticated rule engines.\n\nFor example, we won't support validation rules like \"if role claim is 'admin', then require additional MFA claim\" or \"if audience contains 'sensitive-service', then enforce stricter expiration limits.\" These application-specific validation requirements can be implemented by applications using our basic claim extraction capabilities.\n\nThis focused scope ensures that learners master the fundamental JWT validation concepts (time-based claims, signature verification, basic claim extraction) without getting distracted by the infinite variety of application-specific validation requirements that real systems might need.\n\n### Implementation Guidance\n\nThis section provides concrete technology recommendations and starter code to help implement the functional and security requirements defined above.\n\n**A. Technology Recommendations**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| JSON Serialization | `json.dumps()` with `separators=(',', ':')` | Custom JSON encoder with ordered keys |\n| Base64 Encoding | `base64.urlsafe_b64encode()` with padding removal | Custom Base64URL implementation |\n| HMAC Computation | `hmac.new()` with `hashlib.sha256` | Custom HMAC implementation |\n| Time Handling | `datetime.datetime.utcnow()` and `timestamp()` | `time.time()` for performance |\n| Constant-Time Comparison | `hmac.compare_digest()` | Custom constant-time implementation |\n| Secret Key Storage | In-memory `bytes` object | Secure memory with `mlock()` |\n\n**B. Recommended File Structure**\n\n```\njwt-library/\n├── jwt_lib/\n│   ├── __init__.py              ← Main API exports\n│   ├── core.py                  ← Primary JWT operations (create_token, verify_token)\n│   ├── encoding.py              ← Base64URL encoding/decoding utilities\n│   ├── signing.py               ← HMAC-SHA256 signature operations\n│   ├── validation.py            ← Claims validation logic\n│   ├── models.py                ← Data structures (JWTHeader, JWTPayload, ValidationContext)\n│   └── exceptions.py            ← Custom exception classes\n├── tests/\n│   ├── test_core.py             ← End-to-end JWT operations\n│   ├── test_encoding.py         ← Base64URL encoding tests\n│   ├── test_signing.py          ← Signature generation/verification tests\n│   ├── test_validation.py       ← Claims validation tests\n│   └── test_vectors.py          ← RFC test vectors and known-good examples\n└── examples/\n    ├── basic_usage.py           ← Simple create/verify example\n    └── advanced_validation.py   ← Custom validation context examples\n```\n\n**C. Infrastructure Starter Code**\n\nHere's complete starter code for the data models and basic utilities that learners can use immediately:\n\n```python\n\"\"\"\nJWT Library Data Models and Utilities\nComplete implementation - copy and use as-is\n\"\"\"\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timezone\nfrom typing import Dict, Any, List, Union, Optional\nimport json\nimport base64\n\n# Constants\nDEFAULT_LEEWAY_SECONDS = 300\nHS256 = \"HS256\"\nJWT = \"JWT\"\n\n@dataclass\nclass JWTHeader:\n    \"\"\"JWT header containing algorithm and type information.\"\"\"\n    alg: str = HS256\n    typ: str = JWT\n    \n    def to_dict(self) -> Dict[str, str]:\n        return {\"alg\": self.alg, \"typ\": self.typ}\n    \n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> 'JWTHeader':\n        return cls(alg=data.get(\"alg\", HS256), typ=data.get(\"typ\", JWT))\n\n@dataclass\nclass JWTPayload:\n    \"\"\"JWT payload containing registered and custom claims.\"\"\"\n    iss: Optional[str] = None          # Issuer\n    sub: Optional[str] = None          # Subject\n    aud: Optional[Union[str, List[str]]] = None  # Audience\n    exp: Optional[int] = None          # Expiration time\n    nbf: Optional[int] = None          # Not before\n    iat: Optional[int] = None          # Issued at\n    jti: Optional[str] = None          # JWT ID\n    custom_claims: Dict[str, Any] = field(default_factory=dict)\n    \n    def to_dict(self) -> Dict[str, Any]:\n        result = {}\n        if self.iss is not None:\n            result[\"iss\"] = self.iss\n        if self.sub is not None:\n            result[\"sub\"] = self.sub\n        if self.aud is not None:\n            result[\"aud\"] = self.aud\n        if self.exp is not None:\n            result[\"exp\"] = self.exp\n        if self.nbf is not None:\n            result[\"nbf\"] = self.nbf\n        if self.iat is not None:\n            result[\"iat\"] = self.iat\n        if self.jti is not None:\n            result[\"jti\"] = self.jti\n        result.update(self.custom_claims)\n        return result\n    \n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> 'JWTPayload':\n        # Extract registered claims\n        registered_claims = {\n            'iss': data.get('iss'),\n            'sub': data.get('sub'), \n            'aud': data.get('aud'),\n            'exp': data.get('exp'),\n            'nbf': data.get('nbf'),\n            'iat': data.get('iat'),\n            'jti': data.get('jti')\n        }\n        \n        # Extract custom claims (everything else)\n        custom_claims = {k: v for k, v in data.items() \n                        if k not in ['iss', 'sub', 'aud', 'exp', 'nbf', 'iat', 'jti']}\n        \n        return cls(custom_claims=custom_claims, **{k: v for k, v in registered_claims.items() if v is not None})\n\n@dataclass\nclass ValidationContext:\n    \"\"\"Configuration for JWT validation behavior.\"\"\"\n    verify_signature: bool = True\n    verify_expiration: bool = True\n    verify_not_before: bool = True\n    leeway_seconds: int = DEFAULT_LEEWAY_SECONDS\n    allowed_issuers: List[str] = field(default_factory=list)\n    require_issuer: bool = False\n    expected_audience: Optional[str] = None\n    require_audience: bool = False\n    required_claims: List[str] = field(default_factory=list)\n\n# Utility functions\ndef utc_now() -> datetime:\n    \"\"\"Get current UTC time.\"\"\"\n    return datetime.now(timezone.utc)\n\ndef to_unix_timestamp(dt: datetime) -> int:\n    \"\"\"Convert datetime to Unix timestamp.\"\"\"\n    return int(dt.timestamp())\n\nclass JWTError(Exception):\n    \"\"\"Base exception for JWT operations.\"\"\"\n    pass\n\nclass InvalidTokenError(JWTError):\n    \"\"\"Raised when token structure is invalid.\"\"\"\n    pass\n\nclass InvalidSignatureError(JWTError):\n    \"\"\"Raised when signature verification fails.\"\"\"\n    pass\n\nclass TokenExpiredError(JWTError):\n    \"\"\"Raised when token is expired.\"\"\"\n    pass\n\nclass TokenNotYetValidError(JWTError):\n    \"\"\"Raised when token not-before time hasn't passed.\"\"\"\n    pass\n\nclass InvalidIssuerError(JWTError):\n    \"\"\"Raised when token issuer is not allowed.\"\"\"\n    pass\n\nclass InvalidAudienceError(JWTError):\n    \"\"\"Raised when token audience doesn't match expected.\"\"\"\n    pass\n```\n\n**D. Core Logic Skeleton Code**\n\nHere are the main function signatures learners need to implement, with detailed TODO comments mapping to the requirements:\n\n```python\n\"\"\"\nCore JWT Operations - Implement These Functions\nFill in the TODO sections based on the requirements above\n\"\"\"\nimport hmac\nimport hashlib\n\ndef base64url_encode(data: bytes) -> str:\n    \"\"\"Encode bytes to URL-safe Base64 without padding.\"\"\"\n    # TODO 1: Use base64.urlsafe_b64encode() to encode the data\n    # TODO 2: Decode the result to get a string\n    # TODO 3: Remove trailing '=' padding characters using rstrip()\n    # TODO 4: Return the URL-safe string\n    pass\n\ndef base64url_decode(data: str) -> bytes:\n    \"\"\"Decode Base64URL back to bytes with padding restoration.\"\"\"\n    # TODO 1: Calculate required padding: 4 - (len(data) % 4) % 4\n    # TODO 2: Add '=' characters for padding\n    # TODO 3: Use base64.urlsafe_b64decode() to decode\n    # TODO 4: Return the decoded bytes\n    pass\n\ndef encode_token_parts(header: JWTHeader, payload: JWTPayload) -> tuple[str, str]:\n    \"\"\"Encode header and payload sections to Base64URL.\"\"\"\n    # TODO 1: Convert header to dictionary using header.to_dict()\n    # TODO 2: Serialize header dict to JSON with separators=(',', ':')\n    # TODO 3: Encode header JSON to bytes using .encode('utf-8')\n    # TODO 4: Base64URL encode header bytes\n    # TODO 5: Repeat steps 1-4 for payload using payload.to_dict()\n    # TODO 6: Return tuple of (encoded_header, encoded_payload)\n    pass\n\ndef create_token(header: JWTHeader, payload: JWTPayload, secret_key: bytes) -> str:\n    \"\"\"Generate signed JWT token.\"\"\"\n    # TODO 1: Encode header and payload using encode_token_parts()\n    # TODO 2: Create signing input by joining header.payload with '.'\n    # TODO 3: Generate HMAC-SHA256 signature over signing input\n    # TODO 4: Base64URL encode the signature\n    # TODO 5: Join header.payload.signature with '.' separators\n    # TODO 6: Return the complete JWT string\n    pass\n\ndef verify_token(token: str, secret_key: bytes, context: ValidationContext) -> JWTPayload:\n    \"\"\"Verify JWT token and return payload if valid.\"\"\"\n    # TODO 1: Split token into three parts using token.split('.')\n    # TODO 2: Verify we have exactly 3 parts, raise InvalidTokenError if not\n    # TODO 3: Base64URL decode header and payload parts\n    # TODO 4: Parse JSON from decoded header and payload\n    # TODO 5: Create JWTHeader and JWTPayload objects from parsed JSON\n    # TODO 6: If context.verify_signature: verify signature matches\n    # TODO 7: If context.verify_expiration: check exp claim\n    # TODO 8: If context.verify_not_before: check nbf claim  \n    # TODO 9: Validate issuer and audience claims per context\n    # TODO 10: Return validated payload\n    pass\n\ndef is_expired(exp_timestamp: int, leeway: int) -> bool:\n    \"\"\"Check if timestamp is in the past accounting for leeway.\"\"\"\n    # TODO 1: Get current Unix timestamp using utc_now() and to_unix_timestamp()\n    # TODO 2: Add leeway seconds to exp_timestamp\n    # TODO 3: Return True if current time > adjusted expiration time\n    pass\n\ndef is_not_before(nbf_timestamp: int, leeway: int) -> bool:\n    \"\"\"Check if current time is before nbf accounting for leeway.\"\"\"\n    # TODO 1: Get current Unix timestamp\n    # TODO 2: Subtract leeway seconds from nbf_timestamp  \n    # TODO 3: Return True if current time < adjusted not-before time\n    pass\n```\n\n**E. Language-Specific Hints**\n\n- Use `json.dumps(obj, separators=(',', ':'))` for compact JSON without whitespace\n- Use `hmac.compare_digest()` for constant-time signature comparison\n- Use `datetime.now(timezone.utc)` for UTC timestamps to avoid timezone issues\n- Store secret keys as `bytes` objects, not strings, to avoid encoding confusion\n- Use `str.encode('utf-8')` when converting JSON strings to bytes for encoding\n- Handle `json.JSONDecodeError` when parsing potentially malformed tokens\n\n**F. Milestone Checkpoints**\n\nAfter implementing the functional requirements:\n\n**Checkpoint 1 - Token Creation**:\n```bash\npython -c \"\nfrom jwt_lib.core import create_token\nfrom jwt_lib.models import JWTHeader, JWTPayload\nimport time\n\npayload = JWTPayload(sub='user123', exp=int(time.time()) + 3600)\ntoken = create_token(JWTHeader(), payload, b'secret')\nprint(f'Created token: {token}')\nprint(f'Parts count: {len(token.split(\\\".\\\"))}')  # Should be 3\n\"\n```\n\n**Checkpoint 2 - Token Verification**:\n```bash\npython -c \"\nfrom jwt_lib.core import create_token, verify_token\nfrom jwt_lib.models import JWTHeader, JWTPayload, ValidationContext\nimport time\n\npayload = JWTPayload(sub='user123', exp=int(time.time()) + 3600)\ntoken = create_token(JWTHeader(), payload, b'secret')\nverified = verify_token(token, b'secret', ValidationContext())\nprint(f'Verified subject: {verified.sub}')  # Should be 'user123'\n\"\n```\n\n**Checkpoint 3 - Claims Validation**:\nTest that expired tokens are properly rejected and validation context works correctly.\n\n\n## High-Level Architecture\n\n> **Milestone(s):** Foundation for all three milestones - provides the structural framework for token encoding (Milestone 1), HMAC signing (Milestone 2), and claims validation (Milestone 3)\n\nThe JWT library architecture follows a **layered responsibility pattern** where each component has a distinct role in the token lifecycle. Think of this like a document processing pipeline in a government office: first, clerks prepare and format the document (encoding), then an official stamps it with a seal (signing), and finally, inspectors validate both the seal and contents before accepting it (verification). Each station has specialized knowledge and tools, but they work together to ensure document authenticity and integrity.\n\n![JWT Library Component Architecture](./diagrams/component-architecture.svg)\n\nThe architecture separates concerns across three primary dimensions: **structural formatting**, **cryptographic security**, and **semantic validation**. This separation allows each component to focus on its specific expertise while maintaining clear interfaces between layers. The design prioritizes security by ensuring that cryptographic operations are isolated from parsing logic, and validation rules are separated from encoding concerns.\n\n### Component Responsibilities\n\nThe JWT library consists of three core components that collaborate to provide **stateless authentication** capabilities. Each component owns a specific aspect of the token lifecycle and exposes well-defined interfaces to other components.\n\n#### Token Encoding Component\n\nThe **Token Encoding Component** serves as the foundation layer, responsible for all structural and formatting concerns. This component transforms application data into the standardized JWT format without any knowledge of cryptographic operations or business logic validation rules.\n\n| Responsibility | Description | Key Operations |\n|---------------|-------------|----------------|\n| JSON Serialization | Convert header and payload objects to consistent JSON representation | Deterministic field ordering, proper escaping |\n| Base64URL Encoding | Transform JSON strings into URL-safe encoded segments | Padding removal, character substitution |\n| Token Structure Assembly | Combine encoded parts into dot-separated JWT format | Header concatenation, placeholder signature handling |\n| Format Validation | Ensure structural compliance with JWT specification | Three-part format verification, character validation |\n\nThe encoding component maintains **format consistency** by applying standardized JSON serialization rules and ensuring that all tokens follow the exact three-part structure required by RFC 7519. It handles the subtle differences between standard Base64 and **Base64URL encoding**, particularly around padding characters and URL-safe character substitutions.\n\n> **Key Design Principle**: The encoding component never touches cryptographic material or validates claim semantics. It treats all payload data as opaque JSON objects, focusing solely on format compliance and structural integrity.\n\n#### Cryptographic Signing Component\n\nThe **Cryptographic Signing Component** handles all security-related operations, including signature generation, verification, and protection against cryptographic attacks. This component operates independently of token structure and claim semantics.\n\n| Responsibility | Description | Security Considerations |\n|---------------|-------------|------------------------|\n| HMAC-SHA256 Computation | Generate keyed hash signatures over signing input | Constant-time operations, secure key handling |\n| Signature Verification | Validate token authenticity through signature comparison | Timing attack prevention, algorithm confusion protection |\n| Secret Key Management | Securely store and access signing keys in memory | Key validation, secure memory handling |\n| Cryptographic Error Handling | Detect and report signature-related failures | Information leak prevention, clear error categories |\n\nThe signing component implements **signature verification** using constant-time comparison algorithms to prevent **timing attacks**. It validates that the recomputed signature exactly matches the token's signature without revealing information about partial matches or failure points.\n\n> **Security Focus**: This component treats timing as a security-critical resource. All cryptographic comparisons use constant-time algorithms, and error messages are carefully crafted to avoid leaking information about signature computation internals.\n\n#### Claims Validation Component\n\nThe **Claims Validation Component** enforces business logic and semantic rules around JWT **claims**. It operates on successfully parsed and cryptographically verified tokens, applying temporal, identity, and custom validation rules.\n\n| Responsibility | Description | Validation Rules |\n|---------------|-------------|------------------|\n| Temporal Claims Validation | Verify exp, nbf, and iat claims against current time | **Clock skew** tolerance, reasonable time bounds |\n| Identity Claims Validation | Check iss and aud claims against allowed values | Issuer allowlists, audience matching |\n| Required Claims Enforcement | Ensure presence of mandatory claims | Configurable requirement sets, missing claim detection |\n| Custom Claims Processing | Extract and validate application-specific claims | Type coercion, value range validation |\n\nThe validation component handles **clock skew** by accepting a configurable tolerance window around time-based claims. This prevents legitimate tokens from being rejected due to minor time differences between servers while maintaining security boundaries.\n\n> **Validation Philosophy**: The component follows a \"secure by default\" approach where claims are rejected unless they explicitly pass all configured validation rules. This prevents subtle security vulnerabilities from missed validation checks.\n\n### Recommended Module Structure\n\nThe codebase organization reflects the component separation while providing clear entry points for common operations. The structure balances modularity with usability, ensuring that developers can either use high-level convenience functions or access individual components directly.\n\n#### Primary Module Layout\n\n```\njwt-library/\n├── jwt/\n│   ├── __init__.py              ← High-level API exports\n│   ├── core.py                  ← Main create_token and verify_token functions\n│   ├── models.py                ← JWTHeader, JWTPayload, ValidationContext classes\n│   ├── encoding/\n│   │   ├── __init__.py          ← Encoding component exports\n│   │   ├── base64url.py         ← Base64URL encoding functions\n│   │   ├── json_encoder.py      ← JSON serialization with consistent formatting\n│   │   └── token_assembler.py   ← Token structure assembly\n│   ├── signing/\n│   │   ├── __init__.py          ← Signing component exports\n│   │   ├── hmac_signer.py       ← HMAC-SHA256 implementation\n│   │   ├── verifier.py          ← Signature verification with timing protection\n│   │   └── key_handler.py       ← Secret key validation and management\n│   ├── validation/\n│   │   ├── __init__.py          ← Validation component exports\n│   │   ├── claims_validator.py  ← Standard JWT claims validation\n│   │   ├── time_validator.py    ← Temporal claims (exp, nbf, iat) handling\n│   │   └── custom_validator.py  ← Custom claims processing\n│   ├── exceptions.py            ← All JWT-specific exception classes\n│   └── constants.py             ← Algorithm identifiers and default values\n├── tests/\n│   ├── unit/                    ← Component-level tests\n│   ├── integration/             ← Cross-component workflow tests\n│   └── security/                ← Timing attack and vulnerability tests\n└── examples/\n    ├── basic_usage.py           ← Simple token creation and verification\n    └── advanced_validation.py   ← Custom claims and validation contexts\n```\n\n#### Module Responsibility Boundaries\n\nEach module maintains clear boundaries around its responsibilities and dependencies:\n\n| Module | Depends On | Exports To | Internal Concerns |\n|--------|------------|------------|-------------------|\n| `encoding/` | Standard library only | All other components | JSON formatting, Base64URL implementation |\n| `signing/` | `encoding/` for token parts | `core.py`, validation tests | HMAC computation, timing attack prevention |\n| `validation/` | `models.py` for contexts | `core.py`, application code | Claims parsing, time handling |\n| `core.py` | All three components | Application code | Workflow orchestration, error translation |\n\nThe **dependency direction** flows from core toward components, with components having minimal dependencies on each other. The encoding component has no dependencies on signing or validation, while signing only needs encoded token parts. This structure enables testing individual components in isolation and supports future extensibility.\n\n#### Public API Surface\n\nThe library exposes a **minimal public API** that covers the majority of use cases while allowing access to component-level functionality for advanced scenarios:\n\n| API Level | Functions | Use Case |\n|-----------|-----------|----------|\n| High-Level | `create_token()`, `verify_token()` | Standard JWT operations with reasonable defaults |\n| Component-Level | `encode_token_parts()`, `hmac_sign()`, `validate_claims()` | Custom workflows, testing, debugging |\n| Utility-Level | `base64url_encode()`, `utc_now()`, `is_expired()` | Integration with existing authentication systems |\n\n### Token Lifecycle Flow\n\nThe token lifecycle encompasses two primary workflows: **token creation** during authentication and **token verification** during authorization. Understanding these flows reveals how components collaborate and where data transformations occur.\n\n#### Token Creation Flow\n\nToken creation transforms application data through a series of format and security transformations, ultimately producing a signed JWT string ready for transmission:\n\n1. **Application Input Processing**: The application provides authentication context through `JWTHeader` and `JWTPayload` objects containing algorithm selection, token metadata, and user claims. The header specifies `HS256` algorithm and `JWT` token type, while the payload contains standard claims like `iss`, `sub`, and `exp` along with custom application data.\n\n2. **JSON Serialization**: The encoding component serializes both header and payload objects into consistent JSON representations. This step applies deterministic field ordering and proper character escaping to ensure that identical logical content always produces identical JSON strings, which is critical for signature consistency.\n\n3. **Base64URL Encoding**: The serialized JSON strings undergo **Base64URL encoding** to produce URL-safe string segments. This transformation removes padding characters and replaces problematic characters with URL-safe alternatives, ensuring tokens can be safely transmitted in URLs and HTTP headers.\n\n4. **Signing Input Preparation**: The encoded header and payload segments are concatenated with a dot separator to create the signing input string. This exact string becomes the input to the cryptographic signing process, establishing the data integrity boundary.\n\n5. **HMAC Signature Generation**: The signing component computes an HMAC-SHA256 hash over the signing input using the provided secret key. The resulting signature bytes are then Base64URL encoded to produce the final signature segment.\n\n6. **Token Assembly**: The three encoded segments (header, payload, signature) are concatenated with dot separators to form the final JWT token string. This standardized format enables interoperability with other JWT implementations.\n\nThe creation flow maintains **data immutability** by never modifying input objects, instead creating new representations at each transformation step. This prevents subtle bugs from shared mutable state and enables safe concurrent token creation.\n\n#### Token Verification Flow\n\nToken verification reverses the creation process while applying security and semantic validation at each step:\n\n1. **Token Parsing**: The verification process begins by splitting the input token string on dot separators and validating the three-part structure. Malformed tokens are immediately rejected without proceeding to expensive cryptographic operations.\n\n2. **Base64URL Decoding**: Each token segment undergoes Base64URL decoding to recover the original JSON strings and signature bytes. The decoding process validates character set compliance and reconstructs proper padding where necessary.\n\n3. **JSON Deserialization**: The decoded header and payload strings are parsed as JSON and validated against expected schemas. The header must contain valid `alg` and `typ` fields, while the payload is parsed into standard and custom claims structures.\n\n4. **Signature Verification**: If signature verification is enabled in the `ValidationContext`, the signing component recomputes the HMAC-SHA256 signature over the header and payload segments, then performs a constant-time comparison with the token's signature. This step confirms cryptographic authenticity.\n\n5. **Claims Validation**: The validation component applies business logic rules to the parsed claims. Time-based claims like `exp` and `nbf` are checked against the current time with **clock skew** tolerance, while identity claims like `iss` and `aud` are validated against configured allowed values.\n\n6. **Custom Claims Processing**: Application-specific claims are extracted and validated according to custom rules. The validation context specifies required custom claims and their expected types or value ranges.\n\n7. **Result Assembly**: Successfully validated tokens produce a `JWTPayload` object containing all claims, while validation failures raise specific exception types that indicate the failure category and provide debugging information.\n\nThe verification flow implements **fail-fast semantics** where validation stops at the first encountered error. This prevents resource waste on tokens that will ultimately be rejected and provides clear error categorization for debugging.\n\n#### Data Flow State Transitions\n\nData flows through distinct states during token operations, with each state representing a different level of validation and trust:\n\n| State | Data Format | Validation Level | Trust Boundary |\n|-------|-------------|------------------|----------------|\n| Raw Input | Python objects | Schema validation | Application trust |\n| Serialized | JSON strings | Syntax validation | Format compliance |\n| Encoded | Base64URL strings | Character set validation | Transport safety |\n| Signed | Complete JWT token | Cryptographic validation | Integrity assurance |\n| Verified | Validated payload | Claims validation | Authorization ready |\n\nThe state transitions are **unidirectional** during normal operation, with each step adding validation guarantees. Error conditions can cause transitions to failure states, but successful validation never moves backward through trust levels.\n\n#### Component Interaction Patterns\n\nThe three components interact through **well-defined interface contracts** that enable independent testing and future extensibility:\n\n**Encoding → Signing Interface**: The encoding component provides the signing component with encoded header and payload strings as the signing input. The signing component treats this input as opaque binary data, applying HMAC computation without knowledge of the underlying JWT structure.\n\n**Signing → Validation Interface**: The signing component reports verification success or failure to the validation component through boolean return values and exception types. The validation component proceeds with claims checking only after cryptographic verification succeeds.\n\n**Validation → Application Interface**: The validation component returns validated `JWTPayload` objects to application code, ensuring that all returned data has passed both cryptographic and semantic validation. Error conditions are reported through specific exception types that enable appropriate application responses.\n\n> **Interface Stability**: The component interfaces are designed for stability across implementation changes. Internal optimizations, algorithm improvements, and security enhancements can be made within components without affecting other components or application code.\n\n### Implementation Guidance\n\nThe implementation combines battle-tested cryptographic libraries with careful attention to security details and developer ergonomics. This guidance provides both complete infrastructure code and structured skeletons for core learning components.\n\n#### Technology Recommendations\n\n| Component | Simple Implementation | Production Implementation | Learning Rationale |\n|-----------|----------------------|---------------------------|-------------------|\n| JSON Serialization | Built-in `json` module | `json` with custom encoders | Standard library provides consistency |\n| Base64URL Encoding | Manual implementation | `base64.urlsafe_b64encode` + custom padding | Understanding encoding mechanics |\n| HMAC Computation | `hmac` standard library | `cryptography` library | Focus on timing attack prevention |\n| Time Handling | `datetime` with UTC | `datetime` with timezone awareness | Emphasizes UTC-only approach |\n| Testing Framework | Built-in `unittest` | `pytest` with fixtures | Structured test organization |\n\n#### Complete Infrastructure Code\n\nHere's the foundational infrastructure that handles cross-cutting concerns:\n\n**File: `jwt/models.py`**\n```python\n\"\"\"\nCore data structures for JWT library.\nThese classes define the contract between components and provide type safety.\n\"\"\"\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Union, Any, Optional\nfrom datetime import datetime\n\n@dataclass\nclass JWTHeader:\n    \"\"\"JWT header containing algorithm and type information.\"\"\"\n    alg: str = \"HS256\"\n    typ: str = \"JWT\"\n    \n    def to_dict(self) -> Dict[str, str]:\n        \"\"\"Convert to dictionary for JSON serialization.\"\"\"\n        return {\"alg\": self.alg, \"typ\": self.typ}\n\n@dataclass \nclass JWTPayload:\n    \"\"\"JWT payload containing standard and custom claims.\"\"\"\n    # Standard registered claims\n    iss: Optional[str] = None  # Issuer\n    sub: Optional[str] = None  # Subject  \n    aud: Optional[Union[str, List[str]]] = None  # Audience\n    exp: Optional[int] = None  # Expiration time\n    nbf: Optional[int] = None  # Not before time\n    iat: Optional[int] = None  # Issued at time\n    jti: Optional[str] = None  # JWT ID\n    \n    # Custom claims\n    custom_claims: Dict[str, Any] = field(default_factory=dict)\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary for JSON serialization, excluding None values.\"\"\"\n        result = {}\n        \n        # Add standard claims if present\n        if self.iss is not None:\n            result[\"iss\"] = self.iss\n        if self.sub is not None:\n            result[\"sub\"] = self.sub  \n        if self.aud is not None:\n            result[\"aud\"] = self.aud\n        if self.exp is not None:\n            result[\"exp\"] = self.exp\n        if self.nbf is not None:\n            result[\"nbf\"] = self.nbf\n        if self.iat is not None:\n            result[\"iat\"] = self.iat\n        if self.jti is not None:\n            result[\"jti\"] = self.jti\n            \n        # Add custom claims\n        result.update(self.custom_claims)\n        return result\n\n@dataclass\nclass ValidationContext:\n    \"\"\"Configuration for token validation behavior.\"\"\"\n    # Signature verification\n    verify_signature: bool = True\n    \n    # Time-based validation  \n    verify_expiration: bool = True\n    verify_not_before: bool = True\n    leeway_seconds: int = 300  # 5 minutes clock skew tolerance\n    \n    # Issuer validation\n    allowed_issuers: List[str] = field(default_factory=list)\n    require_issuer: bool = False\n    \n    # Audience validation\n    expected_audience: Optional[str] = None\n    require_audience: bool = False\n    \n    # Required claims\n    required_claims: List[str] = field(default_factory=list)\n```\n\n**File: `jwt/constants.py`**\n```python\n\"\"\"\nConstants and identifiers used throughout the JWT library.\n\"\"\"\n\n# Algorithm identifiers\nHS256 = \"HS256\"\n\n# Token type identifier  \nJWT = \"JWT\"\n\n# Default clock skew tolerance (5 minutes)\nDEFAULT_LEEWAY_SECONDS = 300\n\n# Minimum secure key lengths (in bytes)\nMIN_HMAC_KEY_LENGTH = 32\n```\n\n**File: `jwt/exceptions.py`**\n```python\n\"\"\"\nException hierarchy for JWT library errors.\nProvides specific error types for different failure categories.\n\"\"\"\n\nclass JWTError(Exception):\n    \"\"\"Base exception for all JWT-related errors.\"\"\"\n    pass\n\nclass InvalidTokenError(JWTError):\n    \"\"\"Token format or structure is invalid.\"\"\"\n    pass\n\nclass SignatureVerificationError(JWTError):\n    \"\"\"Token signature verification failed.\"\"\"\n    pass\n\nclass ExpiredTokenError(JWTError):\n    \"\"\"Token has expired.\"\"\"\n    pass\n\nclass NotBeforeError(JWTError):\n    \"\"\"Token is not yet valid (nbf claim).\"\"\"\n    pass\n\nclass InvalidIssuerError(JWTError):\n    \"\"\"Token issuer is not allowed.\"\"\"\n    pass\n\nclass InvalidAudienceError(JWTError):\n    \"\"\"Token audience does not match expected value.\"\"\"\n    pass\n\nclass MissingClaimError(JWTError):\n    \"\"\"Required claim is missing from token.\"\"\"\n    pass\n\nclass InvalidKeyError(JWTError):\n    \"\"\"Signing key is invalid or insecure.\"\"\"\n    pass\n```\n\n#### Core Component Skeletons\n\n**File: `jwt/encoding/base64url.py`**\n```python\n\"\"\"\nBase64URL encoding implementation.\nFocus: Understanding URL-safe encoding and padding handling.\n\"\"\"\nimport base64\n\ndef base64url_encode(data: bytes) -> str:\n    \"\"\"\n    Encode bytes to URL-safe Base64 without padding.\n    This is a core JWT requirement - learn the padding rules!\n    \"\"\"\n    # TODO 1: Use base64.urlsafe_b64encode() to get initial encoding\n    # TODO 2: Convert bytes result to string \n    # TODO 3: Remove trailing '=' padding characters\n    # TODO 4: Return the clean URL-safe string\n    # Hint: Use .rstrip('=') to remove padding\n    pass\n\ndef base64url_decode(data: str) -> bytes:\n    \"\"\"\n    Decode Base64URL back to bytes with padding restoration.\n    Must handle missing padding that was removed during encoding.\n    \"\"\"\n    # TODO 1: Calculate how much padding is needed\n    # TODO 2: Add '=' characters to make length divisible by 4\n    # TODO 3: Use base64.urlsafe_b64decode() to decode\n    # TODO 4: Return the decoded bytes\n    # Hint: padding = 4 - (len(data) % 4) if len(data) % 4 != 0 else 0\n    pass\n```\n\n**File: `jwt/core.py`**\n```python\n\"\"\"\nMain entry point functions for JWT operations.\nOrchestrates the three components to provide simple APIs.\n\"\"\"\nfrom typing import Optional\nimport json\nfrom datetime import datetime, timezone\n\nfrom .models import JWTHeader, JWTPayload, ValidationContext\nfrom .encoding.base64url import base64url_encode, base64url_decode\nfrom .exceptions import *\n\ndef utc_now() -> datetime:\n    \"\"\"Get current UTC time for token operations.\"\"\"\n    return datetime.now(timezone.utc)\n\ndef to_unix_timestamp(dt: datetime) -> int:\n    \"\"\"Convert datetime to Unix timestamp.\"\"\"\n    return int(dt.timestamp())\n\ndef create_token(header: JWTHeader, payload: JWTPayload, secret_key: bytes) -> str:\n    \"\"\"\n    Generate a signed JWT token.\n    \n    This orchestrates all three components:\n    1. Encoding component creates the token structure\n    2. Signing component generates the signature  \n    3. Assembly combines everything into final token\n    \"\"\"\n    # TODO 1: Validate secret_key meets minimum length requirements\n    # TODO 2: Serialize header and payload to JSON (use json.dumps with sort_keys=True)\n    # TODO 3: Base64URL encode both JSON strings  \n    # TODO 4: Create signing input by joining header.payload with dot\n    # TODO 5: Generate HMAC-SHA256 signature over signing input\n    # TODO 6: Base64URL encode the signature\n    # TODO 7: Return final token as header.payload.signature\n    # Hint: Use the infrastructure functions and follow the token creation flow\n    pass\n\ndef verify_token(token: str, secret_key: bytes, context: ValidationContext) -> JWTPayload:\n    \"\"\"\n    Verify a JWT token and return validated payload.\n    \n    This implements the complete verification flow:\n    1. Parse token structure\n    2. Verify signature if enabled\n    3. Validate all claims according to context\n    4. Return payload if everything passes\n    \"\"\"\n    # TODO 1: Split token on '.' and validate 3-part structure\n    # TODO 2: Base64URL decode header, payload, and signature\n    # TODO 3: Parse header and payload JSON\n    # TODO 4: Verify signature if context.verify_signature is True\n    # TODO 5: Validate expiration if context.verify_expiration is True  \n    # TODO 6: Validate not-before if context.verify_not_before is True\n    # TODO 7: Validate issuer and audience according to context\n    # TODO 8: Check for required claims\n    # TODO 9: Return JWTPayload with all claims\n    # Hint: Raise specific exception types for each validation failure\n    pass\n```\n\n#### Milestone Checkpoints\n\n**After Milestone 1 (JWT Structure)**:\n```bash\n# Test basic encoding functionality\npython -c \"\nfrom jwt.encoding.base64url import base64url_encode, base64url_decode\ntest_data = b'Hello JWT'\nencoded = base64url_encode(test_data)\ndecoded = base64url_decode(encoded)\nprint(f'Original: {test_data}')\nprint(f'Encoded: {encoded}') \nprint(f'Decoded: {decoded}')\nprint(f'Success: {test_data == decoded}')\n\"\n```\n\nExpected output shows URL-safe encoding without padding and successful round-trip conversion.\n\n**After Milestone 2 (HMAC Signing)**:\n```bash\n# Test token creation and signature verification\npython -c \"\nfrom jwt.core import create_token, verify_token\nfrom jwt.models import JWTHeader, JWTPayload, ValidationContext\nimport json\n\nheader = JWTHeader()\npayload = JWTPayload(sub='user123', exp=9999999999)\nsecret = b'your-256-bit-secret'\n\ntoken = create_token(header, payload, secret)\nprint(f'Created token: {token}')\n\n# Verify signature only\ncontext = ValidationContext(verify_expiration=False)  \nverified = verify_token(token, secret, context)\nprint(f'Verified payload: {verified}')\n\"\n```\n\n**After Milestone 3 (Claims Validation)**:\n```bash\n# Test complete claims validation\npython -c \"\nfrom jwt.core import create_token, verify_token  \nfrom jwt.models import JWTHeader, JWTPayload, ValidationContext\nfrom datetime import datetime, timezone, timedelta\n\n# Create token with realistic expiration\nheader = JWTHeader()\nexp_time = datetime.now(timezone.utc) + timedelta(hours=1)\npayload = JWTPayload(\n    iss='test-issuer',\n    sub='user123', \n    aud='test-audience',\n    exp=int(exp_time.timestamp())\n)\n\nsecret = b'your-256-bit-secret'\ntoken = create_token(header, payload, secret)\n\n# Full validation\ncontext = ValidationContext(\n    allowed_issuers=['test-issuer'],\n    expected_audience='test-audience',\n    require_issuer=True,\n    require_audience=True\n)\n\nverified = verify_token(token, secret, context)\nprint(f'Fully validated: {verified.sub}')\n\"\n\n```\n\n\n## Data Model\n\n> **Milestone(s):** Foundation for all three milestones - defines core data structures for token encoding (Milestone 1), HMAC signing (Milestone 2), and claims validation (Milestone 3)\n\nThe data model forms the backbone of our JWT library, defining how tokens are structured internally and how validation requirements are configured. Think of the data model as the blueprint for a secure document system - just as a passport has standardized sections for personal information, security features, and validation stamps, a JWT has well-defined sections for metadata, claims, and cryptographic proof.\n\nUnderstanding the JWT data model requires grasping four key concepts: the three-part token structure that enables tamper detection, header claims that describe the token's cryptographic properties, payload claims that carry the actual authentication data, and validation context that controls how strictly we verify tokens. Each of these elements serves a specific security purpose and must be designed to prevent common authentication vulnerabilities.\n\n![JWT Token Structure and Data Model](./diagrams/jwt-structure.svg)\n\n### JWT Token Structure: The Three-Part JWT Format and Its Encoding Requirements\n\nThe JWT token structure follows a precise three-part format that enables stateless authentication through cryptographic verification. Think of this structure like a sealed envelope system: the header is the address label that tells us how to handle the envelope, the payload is the letter inside containing the actual message, and the signature is the wax seal that proves the envelope hasn't been tampered with during delivery.\n\nThe complete JWT token consists of three Base64URL-encoded sections separated by dot characters, forming the pattern `header.payload.signature`. This dot-separated format serves multiple purposes: it creates clear boundaries between sections, ensures the token remains a single string suitable for HTTP headers, and provides a consistent parsing target for verification algorithms. The specific choice of dots as separators was made because dots are safe characters in URLs, HTTP headers, and most programming language string handling routines.\n\n**Base64URL encoding** is a critical aspect of JWT structure that differs from standard Base64 encoding. While standard Base64 uses characters that can cause problems in URLs and HTTP headers (specifically `+`, `/`, and `=` padding), Base64URL replaces these with URL-safe alternatives. The `+` character becomes `-`, the `/` character becomes `_`, and padding characters are completely removed. This encoding choice ensures that JWT tokens can be safely transmitted in URL parameters, HTTP Authorization headers, and HTML form fields without requiring additional escaping.\n\nThe encoding process for each section follows a specific sequence: first, the header or payload data is serialized to JSON with consistent key ordering, then the resulting JSON bytes are encoded using Base64URL encoding with padding removal, and finally the encoded strings are concatenated with dot separators. This process must be deterministic to ensure that the same input always produces the same token, which is essential for signature verification.\n\n| Token Component | Content Type | Encoding Process | Purpose |\n|-----------------|--------------|------------------|---------|\n| Header | JSON metadata | Serialize to JSON → Base64URL encode → remove padding | Specifies algorithm and token type |\n| Payload | JSON claims | Serialize to JSON → Base64URL encode → remove padding | Contains authentication and authorization data |\n| Signature | Binary signature | Generate HMAC → Base64URL encode → remove padding | Provides cryptographic proof of authenticity |\n\nThe parsing process reverses this encoding: tokens are split on dot characters to extract the three sections, each section is Base64URL decoded with proper padding restoration, and the header and payload sections are parsed as JSON to extract their claims. Proper error handling during parsing is crucial because malformed tokens could indicate either transmission errors or malicious tampering attempts.\n\n> **Decision: Three-Part Dot-Separated Structure**\n> - **Context**: JWTs need to be transmitted as single strings while maintaining clear separation between metadata, data, and proof\n> - **Options Considered**: XML structure with tags, JSON with nested objects, custom binary format, dot-separated Base64 sections\n> - **Decision**: Dot-separated Base64URL-encoded sections\n> - **Rationale**: Provides clear section boundaries, remains URL-safe, enables streaming parsing, and maintains compatibility with HTTP header size limits\n> - **Consequences**: Enables efficient parsing and validation while keeping tokens compact and transmission-friendly\n\n### Header Claims: Standard and Custom Header Fields With Their Types and Meanings\n\nThe JWT header contains metadata that describes how to process and verify the token. Think of the header as the instruction manual attached to a secure package - it tells the recipient which tools to use for opening the package and what security procedures to follow for verification. The header must be present in every JWT and contains critical information that determines the token's security properties.\n\nThe **Algorithm** field (`alg`) specifies the cryptographic algorithm used to generate the token's signature. This field is mandatory and must contain a value from the JSON Web Signature (JWS) algorithm registry. For our implementation, we focus on `HS256` (HMAC with SHA-256), which provides symmetric key authentication suitable for scenarios where the token issuer and verifier share a secret key. The algorithm field serves as a contract between the token creator and verifier, ensuring both parties use compatible cryptographic operations.\n\nThe **Token Type** field (`typ`) identifies the token as a JWT, distinguishing it from other token formats that might use similar encoding schemes. While this field is technically optional according to the JWT specification, including it provides explicit type safety and helps prevent confusion when applications handle multiple token types. The standard value for this field is the string `JWT`, written in uppercase to match the specification examples.\n\nAdditional header fields can be included to support advanced features like key identification (`kid` for key ID), critical header parameters (`crit` for parameters that must be understood), and content type declarations (`cty` for nested JWT content). However, our initial implementation focuses on the core algorithm and type fields to maintain simplicity while establishing a foundation for future extensions.\n\n| Header Field | Type | Required | Description | Example Value |\n|--------------|------|----------|-------------|---------------|\n| `alg` | string | Yes | Cryptographic algorithm identifier | `\"HS256\"` |\n| `typ` | string | Recommended | Token type declaration | `\"JWT\"` |\n| `kid` | string | No | Key identifier for key rotation | `\"key-2023-01\"` |\n| `crit` | array[string] | No | Critical header parameters | `[\"exp\", \"nbf\"]` |\n| `cty` | string | No | Content type for nested tokens | `\"JWT\"` |\n\nHeader validation must verify that the algorithm field contains a supported value and matches the algorithm expected by the verification context. **Algorithm confusion attacks** represent a significant security risk where attackers modify the algorithm field to exploit differences in cryptographic processing. For example, changing `HS256` to `none` might bypass signature verification entirely if the verifier doesn't properly validate algorithm constraints.\n\nThe header encoding process requires consistent JSON serialization to ensure deterministic signatures. Field ordering within the JSON object can affect the serialized bytes, so implementations must either use ordered dictionaries or rely on JSON libraries that maintain consistent key ordering. This consistency is crucial because the signature covers the encoded header, and any variation in encoding would invalidate the signature verification process.\n\n> **Decision: Minimal Header Claims for Initial Implementation**\n> - **Context**: JWT headers can contain many optional fields, but we need to balance security with implementation complexity\n> - **Options Considered**: Support all RFC-defined header claims, support only mandatory claims, include commonly-used optional claims\n> - **Decision**: Support `alg` and `typ` fields only, with extensibility for future claims\n> - **Rationale**: Focuses implementation effort on core security properties while establishing patterns for future extensions\n> - **Consequences**: Simplifies initial development and testing while providing a foundation for advanced features like key rotation\n\n### Payload Claims: Registered, Public, and Private Claims in the Payload Section\n\nThe JWT payload contains **claims** - statements about an entity that provide the actual authentication and authorization data. Think of claims like the information fields on a driver's license: some fields are standardized across all licenses (name, expiration date, issuing authority), while others might be specific to certain jurisdictions or use cases (motorcycle endorsement, organ donor status). Similarly, JWT claims fall into three categories that balance standardization with flexibility.\n\n**Registered claims** are standardized field names defined by the JWT specification that provide common authentication and authorization semantics. These claims have precise meanings and expected formats that enable interoperability between different JWT implementations. The most important registered claims for authentication workflows include issuer identification, subject identification, audience restriction, and time-based validity controls.\n\nThe **Issuer** claim (`iss`) identifies the principal that issued the JWT, typically represented as a string containing a URL or other identifier that uniquely identifies the authentication server. This claim enables token verification systems to distinguish between tokens from different sources and implement appropriate trust policies. For example, tokens issued by `https://auth.example.com` might be trusted for internal application access, while tokens from external identity providers require different validation rules.\n\nThe **Subject** claim (`sub`) identifies the principal that is the subject of the JWT, typically representing the user or service account for which the token was issued. This claim should contain a unique identifier that remains stable across the subject's lifecycle but doesn't necessarily need to be human-readable. Many implementations use UUIDs or internal user IDs rather than email addresses to avoid privacy concerns and handle email address changes gracefully.\n\nThe **Audience** claim (`aud`) identifies the recipients that the JWT is intended for, preventing tokens from being misused across different applications or services. This claim can contain either a single string or an array of strings, allowing tokens to be valid for multiple related services while preventing unauthorized cross-service token reuse. Proper audience validation is crucial for preventing **token substitution attacks** where tokens intended for one service are replayed against another service.\n\n| Registered Claim | Type | Description | Example Value | Validation Requirements |\n|------------------|------|-------------|---------------|-------------------------|\n| `iss` | string | Token issuer identifier | `\"https://auth.example.com\"` | Must match allowed issuer list |\n| `sub` | string | Subject (user/service) identifier | `\"user123\"` | Should be unique and stable |\n| `aud` | string or array | Intended audience(s) | `\"api.example.com\"` | Must contain expected audience |\n| `exp` | integer | Expiration time (Unix timestamp) | `1640995200` | Must be in the future (with leeway) |\n| `nbf` | integer | Not-before time (Unix timestamp) | `1640908800` | Current time must be after this value |\n| `iat` | integer | Issued-at time (Unix timestamp) | `1640908800` | Should be reasonable (not too old/future) |\n| `jti` | string | JWT ID (unique token identifier) | `\"abc123\"` | Should be unique per issuer |\n\n**Time-based claims** provide temporal validity controls that are essential for security. The **Expiration** claim (`exp`) specifies when the token becomes invalid, preventing indefinite token reuse and limiting the impact of token compromise. The **Not Before** claim (`nbf`) specifies the earliest time when the token becomes valid, supporting use cases like scheduled access grants or delayed activation. The **Issued At** claim (`iat`) records when the token was created, enabling age-based validation and helping detect tokens that are unreasonably old or claim to be issued in the future.\n\n**Public claims** are field names that are either registered in the IANA JSON Web Token Claims registry or use collision-resistant names (typically URLs) to avoid conflicts with other implementations. These claims provide standardized semantics for common use cases beyond the core registered claims, such as email addresses (`email`), roles (`roles`), or permissions (`permissions`). Using public claims promotes interoperability while extending JWT functionality.\n\n**Private claims** are field names agreed upon by the token producer and consumer for application-specific data. These claims should avoid conflicts with registered and public claims by using prefixes or namespaces that are unlikely to collide with future standards. Private claims provide the flexibility needed for application-specific authorization data while maintaining the benefits of the JWT structure.\n\n| Claim Category | Naming Convention | Example Claims | Conflict Resolution |\n|---------------|-------------------|----------------|-------------------|\n| Registered | RFC 7519 standard names | `iss`, `sub`, `aud`, `exp` | Defined by specification |\n| Public | IANA registry or URL names | `email`, `https://example.com/roles` | Registry or URL collision resistance |\n| Private | Application-specific names | `user_role`, `app_permissions` | Mutual agreement between parties |\n\nThe payload encoding follows the same Base64URL process as the header, but the payload typically contains more data and requires careful handling of nested objects and arrays. Custom claims can include complex data structures, but implementations should be cautious about token size limits imposed by HTTP headers and URL length restrictions. Large payloads can also impact token parsing performance and network transmission efficiency.\n\n> **Decision: Flexible Custom Claims Support Through Dictionary**\n> - **Context**: Applications need to include custom authorization data beyond registered claims\n> - **Options Considered**: Strict schema with predefined fields, completely flexible unstructured data, hybrid approach with registered claims plus custom dictionary\n> - **Decision**: Structured registered claims with a `custom_claims` dictionary for application-specific data\n> - **Rationale**: Provides type safety for standard claims while maintaining flexibility for custom use cases\n> - **Consequences**: Enables clear validation of standard claims while allowing applications to extend functionality without breaking compatibility\n\n### Validation Context: Configuration and State Needed for Proper Token Verification\n\nThe validation context encapsulates all the configuration and runtime state needed to properly verify JWT tokens according to application-specific security requirements. Think of validation context as the security checkpoint instructions at an airport - different checkpoints might have different requirements based on the destination, time of day, and current threat level, but all checkpoints follow consistent procedures for document verification and security screening.\n\n**Signature verification control** determines whether the cryptographic signature should be validated during token processing. While signature verification is typically enabled for production use, development and testing scenarios might need to disable signature checking to use unsigned tokens or tokens signed with different keys. The validation context provides this control through a boolean flag that affects the entire verification process.\n\n**Expiration checking control** manages how strictly the system enforces time-based token validity. Applications might need different approaches to expiration handling based on their security requirements and operational constraints. Critical security operations might require strict expiration enforcement with minimal leeway, while user-facing applications might allow more generous **clock skew** tolerance to handle minor time synchronization differences between servers.\n\nThe **leeway mechanism** addresses the practical reality that distributed systems rarely have perfectly synchronized clocks. Clock skew between the token issuer and verifier can cause valid tokens to be rejected if the clocks differ by even a few seconds. The leeway setting specifies how many seconds of time difference to tolerate when evaluating time-based claims, balancing security (shorter leeway) with operational reliability (longer leeway).\n\n**Issuer validation** controls which token issuers the application trusts, preventing unauthorized token sources from gaining access to protected resources. The validation context maintains a list of allowed issuer identifiers and configures whether issuer validation is required or optional. This capability is essential for applications that might accept tokens from multiple identity providers or need to migrate between different authentication systems.\n\n**Audience validation** ensures that tokens are only accepted by their intended recipients, preventing **cross-service token reuse attacks**. The validation context specifies the expected audience value for the current service and controls whether audience validation is mandatory or optional. Proper audience validation is crucial in microservice architectures where services might share authentication infrastructure but need to prevent token misuse between services.\n\n| Validation Setting | Type | Description | Default Value | Security Impact |\n|--------------------|------|-------------|---------------|-----------------|\n| `verify_signature` | boolean | Enable cryptographic signature verification | `true` | Critical - disabling bypasses authentication |\n| `verify_expiration` | boolean | Enforce expiration time validation | `true` | High - prevents indefinite token reuse |\n| `verify_not_before` | boolean | Enforce not-before time validation | `true` | Medium - prevents premature token use |\n| `leeway_seconds` | integer | Clock skew tolerance in seconds | `300` | Medium - balance security vs reliability |\n| `allowed_issuers` | array[string] | List of trusted token issuers | `[]` | High - controls which sources are trusted |\n| `require_issuer` | boolean | Mandate issuer claim presence | `false` | Medium - depends on trust model |\n| `expected_audience` | string | Required audience value | `\"\"` | High - prevents cross-service token reuse |\n| `require_audience` | boolean | Mandate audience claim presence | `false` | High - essential for multi-service deployments |\n| `required_claims` | array[string] | Claims that must be present | `[]` | Variable - depends on application needs |\n\n**Required claims validation** allows applications to specify which claims must be present in valid tokens, beyond the standard registered claims. Different application endpoints might require different sets of claims - for example, administrative operations might require role claims while user data access might only require subject identification. The validation context maintains a list of required claim names and ensures that all specified claims are present with non-empty values.\n\nThe validation context also manages **temporal validation state** by providing access to the current time in a consistent format. This centralized time management enables testing with frozen time values and ensures consistent behavior across all time-based validations. The context uses UTC time exclusively to avoid timezone-related complications and provides helper functions for converting between different time representations.\n\nError handling within the validation context distinguishes between different types of validation failures to enable appropriate error responses and logging. **Configuration errors** (invalid validation settings) should be detected early during application startup, while **token validation errors** (expired tokens, invalid signatures) should be handled gracefully during request processing without exposing sensitive details about the validation process.\n\n| Validation Error Type | Detection Timing | Example Scenarios | Recommended Response |\n|-----------------------|------------------|-------------------|---------------------|\n| Configuration Error | Application startup | Invalid issuer URL format | Fail application startup |\n| Token Format Error | Request processing | Malformed Base64URL encoding | Return 400 Bad Request |\n| Signature Error | Request processing | Invalid HMAC signature | Return 401 Unauthorized |\n| Claims Error | Request processing | Missing required claims | Return 401 Unauthorized |\n| Temporal Error | Request processing | Expired or not-yet-valid token | Return 401 Unauthorized |\n\nThe validation context must be **immutable during request processing** to prevent race conditions and ensure consistent validation behavior. Applications should create validation contexts during startup or configuration loading and reuse the same context instance across multiple token verification operations. Changes to validation requirements should require creating new context instances rather than modifying existing ones.\n\n> **Decision: Comprehensive Validation Context with Granular Controls**\n> - **Context**: Different applications and deployment scenarios require different validation strictness levels\n> - **Options Considered**: Fixed validation rules, completely configurable validation, preset validation profiles with limited customization\n> - **Decision**: Granular boolean controls for each validation aspect with sensible defaults\n> - **Rationale**: Provides maximum flexibility for different security requirements while maintaining clear semantics for each validation type\n> - **Consequences**: Enables fine-tuned security policies but requires careful consideration of the security implications of each validation setting\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Using Standard Base64 Instead of Base64URL**\nJWT tokens must use Base64URL encoding, not standard Base64 encoding. Standard Base64 uses `+` and `/` characters that are not URL-safe and includes `=` padding characters that create parsing ambiguity. Using standard Base64 will cause tokens to be malformed when transmitted in URLs or HTTP headers, leading to parsing failures and authentication errors. Always use Base64URL encoding with proper padding removal and restoration.\n\n⚠️ **Pitfall: Inconsistent JSON Serialization Order**\nJSON object key ordering affects the serialized bytes, which impacts signature verification. Different JSON libraries may serialize the same object with different key orders, causing signature verification to fail even when the content is identical. Use JSON libraries that maintain consistent key ordering or explicitly sort keys before serialization to ensure deterministic encoding.\n\n⚠️ **Pitfall: Storing Sensitive Data in JWT Payloads**\nJWT payloads are encoded but not encrypted - they can be decoded by anyone who has access to the token. Never store passwords, API keys, or other sensitive data in JWT claims. JWTs should contain only the minimum information needed for authentication and authorization decisions, with sensitive data retrieved from secure storage using the JWT's subject identifier.\n\n⚠️ **Pitfall: Ignoring Clock Skew in Time-Based Claims**\nDistributed systems rarely have perfectly synchronized clocks, so strict time validation without leeway will cause valid tokens to be rejected due to minor time differences. However, excessive leeway creates security vulnerabilities by allowing expired tokens to remain valid longer than intended. Use appropriate leeway values (typically 5-15 minutes) based on your infrastructure's time synchronization accuracy.\n\n⚠️ **Pitfall: Accepting Tokens Without Audience Validation**\nSkipping audience validation allows tokens intended for one service to be used against another service, creating security vulnerabilities in multi-service architectures. Always validate that the token's audience claim matches the expected value for your service, and require the audience claim to be present unless you have a specific reason to make it optional.\n\n⚠️ **Pitfall: Using Mutable Validation Context During Request Processing**\nModifying validation context settings during request processing can create race conditions and inconsistent validation behavior. Validation contexts should be created once during application startup and reused across multiple requests. If validation requirements change, create new context instances rather than modifying existing ones.\n\n### Implementation Guidance\n\nThe data model implementation requires careful attention to data structure design and serialization consistency. This section provides the foundation types and utilities needed to represent JWT tokens internally and configure validation behavior properly.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| JSON Serialization | `json` standard library with manual ordering | `dataclasses-json` with custom serializers |\n| Time Handling | `datetime` with UTC timezone | `pendulum` for advanced timezone handling |\n| Base64URL Encoding | Custom implementation using `base64` | `python-jose` library utilities |\n| Data Validation | Manual type checking with assertions | `pydantic` for schema validation |\n| Immutable Data | `dataclass` with `frozen=True` | `attrs` library with immutability |\n\n#### Recommended File/Module Structure\n\n```\njwt-library/\n├── src/jwt_library/\n│   ├── __init__.py              ← main exports\n│   ├── data_model.py            ← this section - core data structures\n│   ├── encoding.py              ← token encoding (Milestone 1)\n│   ├── signing.py               ← HMAC signing (Milestone 2)\n│   ├── validation.py            ← claims validation (Milestone 3)\n│   └── exceptions.py            ← error types\n├── tests/\n│   ├── test_data_model.py       ← data structure tests\n│   ├── test_encoding.py         ← encoding tests\n│   ├── test_signing.py          ← signing tests\n│   └── test_validation.py       ← validation tests\n└── examples/\n    ├── basic_usage.py           ← simple token creation/verification\n    └── custom_claims.py         ← advanced claims handling\n```\n\n#### Core Data Structure Implementation\n\n```python\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Union, Any, Optional\nfrom datetime import datetime\nimport json\nimport base64\n\n# Constants for standard values\nHS256 = \"HS256\"\nJWT = \"JWT\"\nDEFAULT_LEEWAY_SECONDS = 300\n\n@dataclass(frozen=True)\nclass JWTHeader:\n    \"\"\"JWT Header containing algorithm and type information.\n    \n    This structure represents the first part of a JWT token and contains\n    metadata about how to process the token's signature.\n    \"\"\"\n    alg: str  # Cryptographic algorithm (e.g., \"HS256\")\n    typ: str  # Token type (typically \"JWT\")\n    \n    def to_dict(self) -> Dict[str, str]:\n        \"\"\"Convert header to dictionary for JSON serialization.\"\"\"\n        # TODO: Return dictionary with alg and typ fields\n        # TODO: Ensure consistent key ordering for deterministic serialization\n        pass\n    \n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> 'JWTHeader':\n        \"\"\"Create header from dictionary parsed from JSON.\"\"\"\n        # TODO: Extract alg and typ fields from dictionary\n        # TODO: Validate that required fields are present\n        # TODO: Return new JWTHeader instance\n        pass\n\n@dataclass(frozen=True)\nclass JWTPayload:\n    \"\"\"JWT Payload containing claims and application data.\n    \n    This structure represents the second part of a JWT token and contains\n    the actual authentication and authorization information.\n    \"\"\"\n    # Registered claims (standard JWT fields)\n    iss: Optional[str] = None    # Issuer\n    sub: Optional[str] = None    # Subject  \n    aud: Optional[Union[str, List[str]]] = None  # Audience\n    exp: Optional[int] = None    # Expiration time (Unix timestamp)\n    nbf: Optional[int] = None    # Not before time (Unix timestamp)\n    iat: Optional[int] = None    # Issued at time (Unix timestamp)\n    jti: Optional[str] = None    # JWT ID\n    \n    # Custom application-specific claims\n    custom_claims: Dict[str, Any] = field(default_factory=dict)\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert payload to dictionary for JSON serialization.\"\"\"\n        # TODO: Create dictionary with all non-None registered claims\n        # TODO: Add all custom_claims to the dictionary\n        # TODO: Ensure consistent key ordering\n        pass\n    \n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> 'JWTPayload':\n        \"\"\"Create payload from dictionary parsed from JSON.\"\"\"\n        # TODO: Extract registered claim fields from dictionary\n        # TODO: Put remaining fields into custom_claims dictionary\n        # TODO: Handle audience field (can be string or list)\n        # TODO: Return new JWTPayload instance\n        pass\n    \n    def get_claim(self, name: str) -> Any:\n        \"\"\"Get claim value by name from registered or custom claims.\"\"\"\n        # TODO: Check if name matches a registered claim field\n        # TODO: If not found in registered claims, check custom_claims\n        # TODO: Return None if claim is not present\n        pass\n\n@dataclass(frozen=True)\nclass ValidationContext:\n    \"\"\"Configuration for JWT token validation.\n    \n    This structure contains all the settings needed to properly validate\n    JWT tokens according to application security requirements.\n    \"\"\"\n    # Signature validation controls\n    verify_signature: bool = True\n    \n    # Time-based validation controls  \n    verify_expiration: bool = True\n    verify_not_before: bool = True\n    leeway_seconds: int = DEFAULT_LEEWAY_SECONDS\n    \n    # Issuer validation controls\n    allowed_issuers: List[str] = field(default_factory=list)\n    require_issuer: bool = False\n    \n    # Audience validation controls\n    expected_audience: Optional[str] = None\n    require_audience: bool = False\n    \n    # Required claims validation\n    required_claims: List[str] = field(default_factory=list)\n    \n    def validate_issuer(self, issuer: Optional[str]) -> bool:\n        \"\"\"Check if issuer is valid according to context settings.\"\"\"\n        # TODO: If require_issuer is True, ensure issuer is not None\n        # TODO: If issuer is provided, check if it's in allowed_issuers list\n        # TODO: Return True if validation passes, False otherwise\n        pass\n    \n    def validate_audience(self, audience: Optional[Union[str, List[str]]]) -> bool:\n        \"\"\"Check if audience is valid according to context settings.\"\"\"\n        # TODO: If require_audience is True, ensure audience is not None\n        # TODO: If expected_audience is set, check if it matches\n        # TODO: Handle both string and list audience values\n        # TODO: Return True if validation passes, False otherwise\n        pass\n    \n    def validate_required_claims(self, payload: JWTPayload) -> List[str]:\n        \"\"\"Check if all required claims are present in payload.\"\"\"\n        # TODO: Iterate through required_claims list\n        # TODO: For each required claim, check if it exists and is not None\n        # TODO: Return list of missing claim names\n        pass\n```\n\n#### Base64URL Encoding Utilities\n\n```python\ndef base64url_encode(data: bytes) -> str:\n    \"\"\"Encode bytes to URL-safe Base64 without padding.\n    \n    This function implements the Base64URL encoding specified in RFC 4648\n    Section 5, which replaces + with -, / with _, and removes padding.\n    \"\"\"\n    # TODO: Use base64.urlsafe_b64encode to encode the data\n    # TODO: Decode the result to string (it returns bytes)\n    # TODO: Remove trailing '=' padding characters using rstrip\n    # TODO: Return the URL-safe Base64 string\n    pass\n\ndef base64url_decode(data: str) -> bytes:\n    \"\"\"Decode Base64URL string back to bytes with padding restoration.\n    \n    This function reverses Base64URL encoding by restoring padding\n    and using standard base64 decoding.\n    \"\"\"\n    # TODO: Calculate missing padding: (4 - len(data) % 4) % 4\n    # TODO: Add '=' padding characters to make length multiple of 4\n    # TODO: Use base64.urlsafe_b64decode to decode the padded string\n    # TODO: Return the decoded bytes\n    pass\n```\n\n#### Time Handling Utilities\n\n```python\ndef utc_now() -> datetime:\n    \"\"\"Get current UTC time for consistent time-based validation.\"\"\"\n    # TODO: Return datetime.utcnow() for current UTC time\n    # TODO: Consider using datetime.now(timezone.utc) for timezone-aware results\n    pass\n\ndef to_unix_timestamp(dt: datetime) -> int:\n    \"\"\"Convert datetime to Unix timestamp for JWT time claims.\"\"\"\n    # TODO: Use dt.timestamp() to get Unix timestamp as float\n    # TODO: Convert to integer using int() to match JWT time format\n    # TODO: Return the integer timestamp\n    pass\n\ndef from_unix_timestamp(timestamp: int) -> datetime:\n    \"\"\"Convert Unix timestamp to datetime for time comparisons.\"\"\"\n    # TODO: Use datetime.fromtimestamp() with UTC timezone\n    # TODO: Return timezone-aware datetime object\n    pass\n\ndef is_expired(exp_timestamp: int, leeway: int) -> bool:\n    \"\"\"Check if timestamp is in the past considering leeway.\"\"\"\n    # TODO: Get current Unix timestamp using utc_now() and to_unix_timestamp()\n    # TODO: Add leeway seconds to exp_timestamp for tolerance\n    # TODO: Return True if current time is after the adjusted expiration\n    pass\n\ndef is_not_before(nbf_timestamp: int, leeway: int) -> bool:\n    \"\"\"Check if current time is before nbf timestamp considering leeway.\"\"\"\n    # TODO: Get current Unix timestamp using utc_now() and to_unix_timestamp() \n    # TODO: Subtract leeway seconds from nbf_timestamp for tolerance\n    # TODO: Return True if current time is before the adjusted not-before time\n    pass\n```\n\n#### JSON Serialization Utilities\n\n```python\ndef serialize_header(header: JWTHeader) -> str:\n    \"\"\"Serialize JWT header to JSON string with consistent ordering.\"\"\"\n    # TODO: Convert header to dictionary using to_dict() method\n    # TODO: Use json.dumps() with sort_keys=True for consistent ordering\n    # TODO: Use separators=(',', ':') to minimize whitespace\n    # TODO: Return the JSON string\n    pass\n\ndef serialize_payload(payload: JWTPayload) -> str:\n    \"\"\"Serialize JWT payload to JSON string with consistent ordering.\"\"\"\n    # TODO: Convert payload to dictionary using to_dict() method\n    # TODO: Use json.dumps() with sort_keys=True for consistent ordering\n    # TODO: Use separators=(',', ':') to minimize whitespace  \n    # TODO: Return the JSON string\n    pass\n\ndef parse_json_section(json_str: str) -> Dict[str, Any]:\n    \"\"\"Parse JSON string from JWT token section.\"\"\"\n    # TODO: Use json.loads() to parse the JSON string\n    # TODO: Handle json.JSONDecodeError and raise appropriate JWT exception\n    # TODO: Return the parsed dictionary\n    pass\n```\n\n#### Milestone Checkpoints\n\n**After Milestone 1 (JWT Structure):**\n- Run `python -c \"from jwt_library.data_model import JWTHeader, JWTPayload; print('Data structures imported successfully')\"` \n- Verify that `base64url_encode(b'hello')` returns `'aGVsbG8'` (no padding)\n- Verify that `base64url_decode('aGVsbG8')` returns `b'hello'`\n- Check that `JWTHeader('HS256', 'JWT').to_dict()` returns `{'alg': 'HS256', 'typ': 'JWT'}`\n\n**After Milestone 2 (HMAC Signing):**\n- Verify that time utilities correctly handle Unix timestamps\n- Check that validation context properly validates issuer and audience claims\n- Test that `is_expired()` and `is_not_before()` handle leeway correctly\n\n**After Milestone 3 (Claims Validation):**\n- Verify that `ValidationContext.validate_required_claims()` correctly identifies missing claims\n- Check that custom claims are properly extracted and validated\n- Test complete token validation workflow with various claim combinations\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Base64URL decode errors | Wrong padding or invalid characters | Print encoded string length and characters | Check for proper padding removal/restoration |\n| JSON serialization inconsistent | Different key ordering across runs | Compare JSON output from multiple calls | Use `sort_keys=True` in json.dumps |\n| Time validation always fails | Incorrect timezone handling | Print timestamps and current time | Use UTC consistently throughout |\n| Custom claims not found | Incorrect claim extraction logic | Print payload dictionary contents | Check field name matching and case sensitivity |\n| Validation context errors | Immutability violations | Check for attribute modification attempts | Use dataclass frozen=True and create new instances |\n\n\n## Token Encoding Component\n\n> **Milestone(s):** Milestone 1 (JWT Structure) - implements JWT encoding without signing, including header and payload assembly, Base64URL encoding, and token format construction\n\nThe Token Encoding Component represents the foundation of our JWT library, responsible for transforming structured data into the standardized three-part JWT format. This component handles the critical first phase of JWT creation: taking raw header and payload information and assembling it into a properly formatted, URL-safe token structure that can be transmitted over HTTP and stored in various contexts.\n\n![JWT Token Structure and Data Model](./diagrams/jwt-structure.svg)\n\n### Mental Model: Document Preparation\n\nThink of the Token Encoding Component as a **document preparation service** similar to how a legal office prepares official documents for court submission. Just as a legal document must follow strict formatting rules, contain specific required sections, and be properly certified before it becomes legally valid, a JWT token must undergo precise structural preparation before it can serve as a trusted authentication credential.\n\nConsider how a legal brief is prepared: First, the legal team gathers all the necessary information (claims about the case, client details, jurisdiction requirements). Next, they organize this information into standardized sections (header with case information, body with arguments, footer with signatures). Then they format everything according to court requirements (specific fonts, margins, numbering systems). Finally, they prepare multiple copies in the required format (printed, digital, certified copies).\n\nThe Token Encoding Component follows this same systematic approach. It takes raw authentication data (user identity, permissions, expiration times) and transforms it through several structured phases: JSON serialization ensures the data is in a standard format, Base64URL encoding makes it web-safe for transmission, and token assembly combines everything into the final three-part structure that other systems can reliably parse and process.\n\nThis preparation phase is crucial because any deviation from the standard format will cause the token to be rejected by verification systems, just as improperly formatted legal documents are rejected by courts. The encoding process must be both precise and consistent, producing identical output for identical input data regardless of when or where the encoding occurs.\n\n### Base64URL Encoding\n\nBase64URL encoding serves as the fundamental transformation mechanism that makes JWT tokens safe for transmission across web protocols. Unlike standard Base64 encoding, which includes characters that have special meanings in URLs and HTTP headers, Base64URL uses a web-safe alphabet that eliminates encoding conflicts and parsing ambiguities.\n\n![Base64URL Encoding Process](./diagrams/encoding-flowchart.svg)\n\nThe encoding process begins with UTF-8 encoded JSON data representing either the JWT header or payload. This binary data undergoes standard Base64 transformation using the familiar 64-character alphabet, but then requires two critical modifications: character substitution and padding removal. The standard Base64 characters `+` and `/` become `-` and `_` respectively, eliminating the need for URL encoding when tokens appear in query parameters or path components. More importantly, all padding characters (`=`) are stripped from the end of the encoded string.\n\nPadding removal represents a key architectural decision because it creates an encoding that is both deterministic and compact. Traditional Base64 padding serves to align the output to 4-character boundaries, but this padding provides no functional value in JWT tokens and actually increases the token size. By removing padding, we ensure that tokens consume minimal space in HTTP headers while maintaining full reversibility during decoding.\n\nThe decoding process reverses these transformations but must handle the missing padding gracefully. Our decoder calculates the required padding length based on the input string length: strings whose length modulo 4 equals 2 require two padding characters, strings whose length modulo 4 equals 3 require one padding character, and strings whose length modulo 4 equals 0 or 1 are either correctly padded or represent invalid input respectively.\n\n> **Decision: Base64URL Character Set**\n> - **Context**: JWT tokens must be safely transmitted in URLs, HTTP headers, and form data without requiring additional encoding\n> - **Options Considered**: Standard Base64, Base64URL, custom encoding scheme\n> - **Decision**: Use Base64URL encoding with URL-safe character substitutions\n> - **Rationale**: Base64URL is standardized in RFC 4648, supported by existing libraries, and eliminates URL encoding overhead\n> - **Consequences**: Enables direct token usage in URLs and headers but requires custom encoding/decoding functions in some languages\n\n| Encoding Option | Pros | Cons | Web-Safe |\n|-----------------|------|------|----------|\n| Standard Base64 | Universal support, simple implementation | Requires URL encoding, longer tokens | No |\n| Base64URL | Web-safe, compact, standardized | Requires custom implementation | Yes |\n| Custom encoding | Optimized for specific use case | Non-standard, compatibility issues | Variable |\n\nThe encoding functions maintain strict error handling to ensure that invalid input data cannot produce tokens that appear valid but fail during verification. Input validation confirms that all data is valid UTF-8 before encoding begins, preventing encoding artifacts that could cause parsing failures downstream.\n\n### JSON Serialization Strategy\n\nJSON serialization transforms the structured header and payload objects into the standardized text representation required for cryptographic processing. This transformation must be deterministic and consistent to ensure that identical logical tokens always produce identical signatures, regardless of the serialization environment or timing.\n\nOur serialization strategy addresses several critical requirements that distinguish JWT encoding from general-purpose JSON serialization. First, field ordering must be consistent to prevent signature variations caused by different JSON implementations reordering object keys. Second, whitespace handling must eliminate all unnecessary characters to minimize token size. Third, numeric precision must preserve exact timestamp values to prevent authentication failures caused by rounding errors.\n\nThe header serialization process creates a minimal JSON object containing exactly two required fields: `alg` specifying the signing algorithm and `typ` indicating the token type. Additional header fields, while supported by the JWT specification, are not included in our initial implementation to maintain simplicity and reduce attack surface. The serializer outputs these fields in alphabetical order to ensure consistency across different JSON libraries and platforms.\n\nPayload serialization handles a more complex data structure that includes both standard registered claims and application-specific custom claims. Registered claims such as `iss` (issuer), `sub` (subject), `aud` (audience), `exp` (expiration time), `nbf` (not before), and `iat` (issued at) receive special handling to ensure type correctness and value validation. String claims are serialized directly, while numeric claims undergo integer conversion to prevent floating-point representation issues.\n\n> **Decision: JSON Field Ordering**\n> - **Context**: Different JSON serializers may output object fields in different orders, potentially causing signature mismatches\n> - **Options Considered**: Accept arbitrary ordering, enforce alphabetical ordering, use ordered dictionaries\n> - **Decision**: Enforce consistent alphabetical field ordering during serialization\n> - **Rationale**: Ensures identical JSON output for identical input data, preventing signature validation failures\n> - **Consequences**: Requires explicit field ordering in serialization code but guarantees signature consistency\n\nThe serialization process validates all field types before encoding to prevent runtime errors during token creation. String fields are checked for valid UTF-8 encoding, numeric fields are validated as integers within the valid timestamp range, and array fields (such as multiple audience values) are validated for consistent element types.\n\nCustom claims handling deserves special attention because it represents the primary extension point for application-specific authentication data. Our serializer accepts custom claims as a dictionary of key-value pairs, where keys must be valid JSON strings and values can be any JSON-serializable type. However, we recommend avoiding deeply nested objects in custom claims to maintain token compactness and parsing efficiency.\n\n| Claim Type | Validation Rules | Serialization Format | Error Handling |\n|------------|------------------|---------------------|----------------|\n| String claims (iss, sub, jti) | Non-empty UTF-8 strings | Direct JSON string | Reject empty/invalid strings |\n| Numeric claims (exp, nbf, iat) | Positive integers, valid timestamp range | JSON number without decimals | Reject negative/floating values |\n| Audience claim (aud) | String or array of strings | String or JSON array | Standardize single-item arrays |\n| Custom claims | JSON-serializable values | Native JSON representation | Validate serializability |\n\n### Architecture Decisions\n\nThe Token Encoding Component embodies several fundamental architectural decisions that establish the foundation for the entire JWT library. These decisions prioritize security, consistency, and maintainability over performance optimization or feature richness, reflecting our commitment to building a secure authentication system rather than a high-performance data processing library.\n\n> **Decision: Three-Phase Encoding Pipeline**\n> - **Context**: JWT tokens require JSON serialization, Base64URL encoding, and token assembly in a specific sequence\n> - **Options Considered**: Single monolithic encoder, three separate phases, streaming encoder\n> - **Decision**: Implement three distinct phases with clear interfaces between them\n> - **Rationale**: Enables independent testing of each phase, simplifies debugging, and allows phase-specific optimizations\n> - **Consequences**: Slightly increased memory usage due to intermediate representations but significantly improved maintainability\n\n![Token Creation Sequence](./diagrams/token-creation-sequence.svg)\n\nThe three-phase pipeline architecture separates concerns cleanly: JSON serialization focuses on data representation accuracy, Base64URL encoding handles web-safety requirements, and token assembly manages the final format construction. Each phase can be tested independently with known inputs and expected outputs, dramatically simplifying the debugging process when tokens fail validation.\n\nInput validation occurs at multiple pipeline stages to create defense-in-depth against malformed data. The JSON serialization phase validates data types and UTF-8 encoding. The Base64URL encoding phase confirms that input data consists of valid bytes. The token assembly phase verifies that all three components (header, payload, signature placeholder) are present and properly formatted.\n\n> **Decision: Immutable Token Components**\n> - **Context**: JWT tokens should be tamper-evident, requiring consistent representation of header and payload data\n> - **Options Considered**: Mutable token objects, immutable value objects, copy-on-write structures\n> - **Decision**: Use immutable value objects for JWTHeader and JWTPayload throughout the encoding process\n> - **Rationale**: Prevents accidental modification during encoding, simplifies concurrent access, and ensures consistent signatures\n> - **Consequences**: Requires object creation for modifications but eliminates entire classes of bugs related to shared mutable state\n\nError handling follows a fail-fast philosophy where invalid input data immediately terminates the encoding process with descriptive error messages. This approach prevents the creation of malformed tokens that might appear valid but fail during verification, potentially causing authentication failures in production systems.\n\nThe component maintains strict separation between encoding operations and cryptographic operations. The Token Encoding Component produces the signing input string (header.payload) but does not perform any cryptographic operations itself. This separation allows the encoding logic to be tested without cryptographic dependencies and enables the signing component to focus exclusively on secure signature generation.\n\n| Architecture Decision | Alternative Approaches | Chosen Approach | Trade-offs |\n|----------------------|----------------------|-----------------|------------|\n| Pipeline Structure | Monolithic encoder | Three-phase pipeline | Memory usage vs. maintainability |\n| Data Mutability | Mutable token objects | Immutable value objects | Performance vs. safety |\n| Error Handling | Graceful degradation | Fail-fast validation | User experience vs. security |\n| Component Coupling | Integrated encoding/signing | Separated concerns | Complexity vs. testability |\n\n### Common Pitfalls\n\nToken encoding presents numerous opportunities for subtle bugs that can compromise the security or functionality of the entire JWT system. Understanding these pitfalls and their solutions is essential for building a robust authentication system.\n\n⚠️ **Pitfall: Base64 vs Base64URL Confusion**\n\nMany developers mistakenly use standard Base64 encoding instead of the required Base64URL variant, creating tokens that work in testing but fail when transmitted through web protocols. Standard Base64 uses `+` and `/` characters that have special meanings in URLs, causing token corruption when they appear in query parameters or are processed by URL-parsing libraries.\n\nThe symptoms of this error include tokens that work when passed directly between services but fail when transmitted through HTTP redirects, stored in cookies, or embedded in HTML forms. The solution requires implementing proper Base64URL encoding that substitutes `-` for `+` and `_` for `/`, while also handling padding removal correctly.\n\n⚠️ **Pitfall: Padding Handling Errors**\n\nBase64URL encoding requires padding removal, but the decoding process must restore the correct amount of padding to reconstruct the original data. Incorrect padding calculation leads to decoding failures that manifest as token parsing errors or signature verification failures.\n\nThe most common mistake involves using string length modulo 4 without accounting for invalid input lengths. Strings whose length modulo 4 equals 1 represent invalid Base64 input and should trigger an error rather than attempting padding calculation. Proper padding restoration adds zero, one, or two `=` characters based on the mathematical relationship between input length and Base64 block alignment.\n\n⚠️ **Pitfall: JSON Field Ordering Inconsistency**\n\nJSON serialization libraries in different languages may output object fields in different orders, causing identical token data to produce different JSON representations and therefore different signatures. This creates tokens that appear valid when created and verified on the same system but fail cross-platform verification.\n\nThe solution requires explicit field ordering during JSON serialization, typically alphabetical ordering of field names. However, simply sorting fields may not be sufficient if the JSON library internally reorders them. Production implementations should validate that their JSON serialization produces consistent output by comparing serialized results across multiple library versions and platforms.\n\n⚠️ **Pitfall: Timestamp Precision Loss**\n\nJWT timestamps are defined as NumericDate values representing seconds since the Unix epoch. However, many programming languages represent time using floating-point numbers or higher precision formats that can introduce rounding errors during JSON serialization.\n\nThese precision errors manifest as tokens that expire one second earlier or later than expected, causing authentication failures near expiration boundaries. The solution requires explicit integer conversion of all timestamp values before JSON serialization, ensuring that `exp`, `nbf`, and `iat` claims are represented as whole seconds without fractional components.\n\n⚠️ **Pitfall: Empty String and Null Handling**\n\nJWT claims may contain empty strings or null values that require careful handling during serialization. Some JSON libraries omit null values entirely, while others represent them explicitly, leading to inconsistent token formats and potential signature mismatches.\n\nOur implementation strategy treats empty strings as invalid for required string claims (such as `iss` and `sub`) but allows them for optional custom claims. Null values are explicitly forbidden in all claims to maintain JSON compatibility and prevent parsing ambiguities. Applications requiring optional claims should omit the claim entirely rather than setting it to null.\n\n⚠️ **Pitfall: Unicode and Character Encoding Issues**\n\nJWT tokens must be transmitted as ASCII-safe strings, but the header and payload may contain Unicode characters in string claims. Incorrect character encoding during JSON serialization can produce tokens that appear valid in development environments but fail when processed by systems with different default encodings.\n\nThe solution requires explicit UTF-8 encoding throughout the token creation pipeline. All string data must be validated as valid UTF-8 before JSON serialization, and the serialized JSON must be UTF-8 encoded before Base64URL encoding. This ensures consistent token representation across systems with different default character encodings.\n\n### Implementation Guidance\n\nThe Token Encoding Component requires careful attention to character encoding, data validation, and format consistency. The following implementation guidance provides complete working code for the foundational elements and detailed skeletons for the core encoding logic.\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| JSON Serialization | `json` module with custom serialization | `orjson` or `ujson` for performance |\n| Base64 Encoding | `base64` module with manual padding | Custom implementation for precise control |\n| String Handling | Built-in `str` methods | `unicodedata` for advanced validation |\n| Date/Time Processing | `datetime` module with UTC timezone | `pendulum` for advanced time handling |\n\n**Recommended File Structure:**\n\n```\njwt-library/\n  src/\n    jwt/\n      __init__.py                 ← Public API exports\n      encoding/\n        __init__.py              ← Encoding component exports  \n        base64url.py             ← Base64URL encoding utilities\n        json_serializer.py       ← JSON serialization with field ordering\n        token_assembler.py       ← Token structure assembly\n        validators.py            ← Input validation helpers\n      types.py                   ← Core data structures (JWTHeader, JWTPayload)\n      constants.py               ← Algorithm identifiers and defaults\n    tests/\n      encoding/\n        test_base64url.py        ← Base64URL encoding tests\n        test_json_serializer.py  ← JSON serialization tests\n        test_token_assembler.py  ← Token assembly tests\n```\n\n**Core Data Structures (Complete Implementation):**\n\n```python\n# src/jwt/types.py\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Union, Any, Optional\nfrom datetime import datetime\n\n@dataclass(frozen=True)\nclass JWTHeader:\n    \"\"\"Immutable JWT header containing algorithm and type information.\"\"\"\n    alg: str\n    typ: str\n    \n    def __post_init__(self):\n        if not self.alg or not isinstance(self.alg, str):\n            raise ValueError(\"Header 'alg' field must be a non-empty string\")\n        if not self.typ or not isinstance(self.typ, str):\n            raise ValueError(\"Header 'typ' field must be a non-empty string\")\n\n@dataclass(frozen=True)\nclass JWTPayload:\n    \"\"\"Immutable JWT payload containing registered and custom claims.\"\"\"\n    iss: Optional[str] = None           # Issuer\n    sub: Optional[str] = None           # Subject  \n    aud: Optional[Union[str, List[str]]] = None  # Audience\n    exp: Optional[int] = None           # Expiration Time\n    nbf: Optional[int] = None           # Not Before\n    iat: Optional[int] = None           # Issued At\n    jti: Optional[str] = None           # JWT ID\n    custom_claims: Optional[Dict[str, Any]] = None\n    \n    def __post_init__(self):\n        # Validate timestamp claims are positive integers\n        for claim_name in ['exp', 'nbf', 'iat']:\n            value = getattr(self, claim_name)\n            if value is not None:\n                if not isinstance(value, int) or value < 0:\n                    raise ValueError(f\"Claim '{claim_name}' must be a positive integer timestamp\")\n        \n        # Validate string claims are non-empty if present\n        for claim_name in ['iss', 'sub', 'jti']:\n            value = getattr(self, claim_name)\n            if value is not None and (not isinstance(value, str) or not value.strip()):\n                raise ValueError(f\"Claim '{claim_name}' must be a non-empty string\")\n        \n        # Validate audience claim\n        if self.aud is not None:\n            if isinstance(self.aud, str):\n                if not self.aud.strip():\n                    raise ValueError(\"Audience claim must be a non-empty string\")\n            elif isinstance(self.aud, list):\n                if not self.aud or not all(isinstance(a, str) and a.strip() for a in self.aud):\n                    raise ValueError(\"Audience list must contain non-empty strings\")\n            else:\n                raise ValueError(\"Audience must be a string or list of strings\")\n```\n\n**Base64URL Encoding (Complete Implementation):**\n\n```python\n# src/jwt/encoding/base64url.py\nimport base64\nfrom typing import Union\n\ndef base64url_encode(data: bytes) -> str:\n    \"\"\"\n    Encode bytes to URL-safe Base64 without padding.\n    \n    Args:\n        data: Raw bytes to encode\n        \n    Returns:\n        URL-safe Base64 string without padding characters\n        \n    Raises:\n        TypeError: If input is not bytes\n    \"\"\"\n    if not isinstance(data, bytes):\n        raise TypeError(\"Input data must be bytes\")\n    \n    # Perform standard Base64 encoding\n    encoded = base64.b64encode(data).decode('ascii')\n    \n    # Apply URL-safe character substitutions\n    encoded = encoded.replace('+', '-').replace('/', '_')\n    \n    # Remove padding characters\n    return encoded.rstrip('=')\n\ndef base64url_decode(data: str) -> bytes:\n    \"\"\"\n    Decode Base64URL back to bytes with automatic padding restoration.\n    \n    Args:\n        data: Base64URL encoded string\n        \n    Returns:\n        Original bytes\n        \n    Raises:\n        ValueError: If input string has invalid length or characters\n    \"\"\"\n    if not isinstance(data, str):\n        raise TypeError(\"Input data must be a string\")\n    \n    # Calculate required padding\n    padding_length = len(data) % 4\n    if padding_length == 1:\n        raise ValueError(\"Invalid Base64URL string length\")\n    elif padding_length == 2:\n        data += '=='\n    elif padding_length == 3:\n        data += '='\n    \n    # Reverse URL-safe character substitutions\n    data = data.replace('-', '+').replace('_', '/')\n    \n    try:\n        return base64.b64decode(data)\n    except Exception as e:\n        raise ValueError(f\"Invalid Base64URL encoding: {e}\")\n```\n\n**JSON Serialization (Core Logic Skeleton):**\n\n```python\n# src/jwt/encoding/json_serializer.py\nimport json\nfrom typing import Dict, Any\nfrom ..types import JWTHeader, JWTPayload\n\ndef serialize_header(header: JWTHeader) -> str:\n    \"\"\"\n    Serialize JWT header to consistent JSON representation.\n    \n    Args:\n        header: JWT header object\n        \n    Returns:\n        JSON string with alphabetically ordered fields\n    \"\"\"\n    # TODO 1: Create ordered dictionary with header fields\n    # TODO 2: Ensure alphabetical field ordering (alg before typ)\n    # TODO 3: Serialize to JSON without whitespace\n    # TODO 4: Validate result is valid UTF-8\n    # Hint: Use json.dumps with separators=(',', ':') for compact output\n    pass\n\ndef serialize_payload(payload: JWTPayload) -> str:\n    \"\"\"\n    Serialize JWT payload to consistent JSON representation.\n    \n    Args:\n        payload: JWT payload object\n        \n    Returns:\n        JSON string with alphabetically ordered fields\n    \"\"\"\n    # TODO 1: Create ordered dictionary for registered claims\n    # TODO 2: Add non-None registered claims in alphabetical order\n    # TODO 3: Add custom claims if present, maintaining alphabetical order\n    # TODO 4: Handle special case of audience as string vs list\n    # TODO 5: Serialize to compact JSON without whitespace\n    # TODO 6: Validate all timestamps are integers\n    # Hint: Check claim values with 'is not None' before adding to dictionary\n    pass\n\ndef _ensure_alphabetical_order(data: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n    Ensure dictionary keys are in alphabetical order.\n    \n    Args:\n        data: Dictionary with string keys\n        \n    Returns:\n        New dictionary with alphabetically sorted keys\n    \"\"\"\n    # TODO 1: Sort dictionary keys alphabetically\n    # TODO 2: Create new dictionary with sorted key order\n    # TODO 3: Handle nested dictionaries recursively for custom claims\n    # Hint: Use sorted() function on dictionary keys\n    pass\n```\n\n**Token Assembly (Core Logic Skeleton):**\n\n```python\n# src/jwt/encoding/token_assembler.py\nfrom typing import Tuple\nfrom .json_serializer import serialize_header, serialize_payload\nfrom .base64url import base64url_encode\nfrom ..types import JWTHeader, JWTPayload\n\ndef encode_token_parts(header: JWTHeader, payload: JWTPayload) -> Tuple[str, str]:\n    \"\"\"\n    Encode header and payload to Base64URL format.\n    \n    Args:\n        header: JWT header object\n        payload: JWT payload object\n        \n    Returns:\n        Tuple of (encoded_header, encoded_payload)\n        \n    Raises:\n        ValueError: If serialization or encoding fails\n    \"\"\"\n    # TODO 1: Serialize header to JSON string\n    # TODO 2: Serialize payload to JSON string  \n    # TODO 3: Encode header JSON to UTF-8 bytes then Base64URL\n    # TODO 4: Encode payload JSON to UTF-8 bytes then Base64URL\n    # TODO 5: Return tuple of encoded strings\n    # Hint: Use .encode('utf-8') to convert JSON strings to bytes\n    pass\n\ndef create_signing_input(encoded_header: str, encoded_payload: str) -> str:\n    \"\"\"\n    Create the signing input string for HMAC computation.\n    \n    Args:\n        encoded_header: Base64URL encoded header\n        encoded_payload: Base64URL encoded payload\n        \n    Returns:\n        Signing input string in format \"header.payload\"\n    \"\"\"\n    # TODO 1: Validate both inputs are non-empty strings\n    # TODO 2: Concatenate with dot separator\n    # TODO 3: Validate result contains exactly one dot\n    # Hint: This is the string that will be signed by the cryptographic component\n    pass\n\ndef assemble_token(encoded_header: str, encoded_payload: str, signature: str) -> str:\n    \"\"\"\n    Assemble the final JWT token from encoded components.\n    \n    Args:\n        encoded_header: Base64URL encoded header\n        encoded_payload: Base64URL encoded payload  \n        signature: Base64URL encoded signature\n        \n    Returns:\n        Complete JWT token in format \"header.payload.signature\"\n    \"\"\"\n    # TODO 1: Validate all three components are non-empty strings\n    # TODO 2: Concatenate with dot separators\n    # TODO 3: Validate result has exactly two dots\n    # TODO 4: Return final token string\n    # Hint: Final token should split into exactly 3 parts on '.'\n    pass\n```\n\n**Milestone Checkpoint:**\n\nAfter implementing the Token Encoding Component, verify your implementation with these concrete tests:\n\n1. **Header Encoding Test**: Create a `JWTHeader(alg=\"HS256\", typ=\"JWT\")` and verify it serializes to the exact JSON `{\"alg\":\"HS256\",\"typ\":\"JWT\"}` and encodes to Base64URL `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`.\n\n2. **Payload Encoding Test**: Create a simple payload with `exp=1516239022` and verify the JSON contains `\"exp\":1516239022` (integer, not float).\n\n3. **Base64URL Validation**: Encode the string \"hello world\" and verify it produces `aGVsbG8gd29ybGQ` (no padding). Decode it back and verify you get the original bytes.\n\n4. **Token Assembly Test**: Create a complete token with dummy signature and verify it has exactly three dot-separated parts, each containing valid Base64URL characters (A-Z, a-z, 0-9, -, _).\n\n**Debugging Tips:**\n\n| Symptom | Likely Cause | Diagnosis | Fix |\n|---------|--------------|-----------|-----|\n| Base64 decode errors | Wrong Base64 variant | Check for +/= characters in token | Use Base64URL encoding |\n| Inconsistent signatures | JSON field ordering | Compare JSON output across runs | Implement consistent field ordering |\n| Token parsing failures | Invalid characters in token | Check token contains only valid Base64URL chars | Validate encoding alphabet |\n| Timestamp validation errors | Float timestamps in JSON | Inspect JSON for decimal points in time claims | Convert timestamps to integers |\n\n\n## Cryptographic Signing Component\n\n> **Milestone(s):** Milestone 2 (HMAC Signing) - implements HS256 signing and verification with cryptographically secure signature generation, constant-time verification, and proper secret key handling\n\nThe cryptographic signing component transforms our JWT library from a simple token encoder into a secure authentication system. While the token encoding component from Milestone 1 created properly formatted JWT structures, those tokens provided no security guarantees—anyone could modify the payload and create valid-looking tokens. The signing component solves this fundamental problem by adding cryptographic integrity protection that ensures tokens cannot be tampered with after creation.\n\nThis component implements HMAC-SHA256 (HS256) signing, which provides both authentication and integrity for JWT tokens. Authentication ensures that only parties possessing the secret key can create valid tokens, while integrity guarantees that any modification to a signed token will be detected during verification. The component must handle several critical security concerns: preventing timing attacks during signature verification, avoiding algorithm confusion attacks, and securely managing secret keys in memory.\n\n### Mental Model: Wax Seal Authentication\n\nUnderstanding digital signatures becomes intuitive when we think about historical document authentication using wax seals. Imagine you're a medieval scribe preparing an important decree from the king. The decree contains two parts: the actual message (similar to our JWT header and payload) and the king's unique wax seal pressed into the document (similar to our cryptographic signature).\n\nThe wax seal serves multiple purposes that directly parallel JWT signatures. First, it proves authenticity—only the king possesses the signet ring that creates this specific seal pattern, just as only parties with the secret key can generate valid HMAC signatures. Second, it ensures integrity—if someone alters the document after sealing, the broken or misaligned wax reveals tampering, just as signature verification fails when token contents are modified.\n\nThe process of creating and verifying the seal follows a predictable pattern. To create a sealed document, the scribe first prepares the message text carefully (encoding our header and payload), then the king presses his signet ring into hot wax over the document (computing the HMAC signature over the encoded content). To verify an incoming sealed document, the recipient first examines the document contents (parsing the JWT structure), then carefully compares the wax seal against known authentic examples of the king's seal (recomputing the expected signature and comparing it with the provided signature).\n\nThis analogy reveals why timing attacks are dangerous in signature verification. If a medieval clerk examined suspicious seals by slowly comparing each detail and stopping at the first difference, an attacker could learn information about the authentic seal by measuring how long verification takes. Similarly, if our JWT verification stops at the first differing byte in signature comparison, attackers can gradually discover the correct signature. The solution in both cases is comprehensive examination—the clerk must examine the entire seal regardless of early differences, and our verification must compare every byte of the signature in constant time.\n\nThe wax seal model also illuminates why secret key security matters so critically. Just as a stolen or copied signet ring allows anyone to create authentic-looking royal decrees, a compromised HMAC secret key enables attackers to mint valid JWT tokens for any user or purpose. This makes secure key handling one of our most important architectural concerns.\n\n### HMAC-SHA256 Implementation\n\nHMAC-SHA256 provides the cryptographic foundation for JWT signing by combining a secret key with the token content to produce an unforgeable signature. The HMAC construction addresses several weaknesses present in simpler approaches like basic SHA-256 hashing, making it suitable for authentication applications where security is paramount.\n\nThe mathematical foundation of HMAC involves two rounds of hashing with key material processed through inner and outer padding constants. However, the conceptual model is straightforward: HMAC takes a secret key and a message (our JWT header and payload), then produces a fixed-length output that serves as an authentication tag. Anyone possessing the same secret key can recompute this tag for any message, but without the key, computing the correct tag is computationally infeasible.\n\nOur implementation must handle several critical steps in the HMAC computation process. First, we prepare the signing input by concatenating the Base64URL-encoded header and payload with a dot separator, following the JWT specification exactly. This signing input represents the complete token content that receives cryptographic protection. Second, we apply the HMAC-SHA256 algorithm using the provided secret key, which produces a 32-byte binary signature. Third, we encode this binary signature using Base64URL encoding to create the final signature component that gets appended to the JWT.\n\n> **Decision: HMAC-SHA256 Algorithm Choice**\n> - **Context**: JWT supports multiple signature algorithms including HMAC variants (HS256, HS384, HS512) and RSA/ECDSA algorithms (RS256, ES256). We need to choose one algorithm for our initial implementation that balances security with implementation complexity.\n> - **Options Considered**: \n>   - HS256 (HMAC-SHA256): Symmetric key, 256-bit security, simple implementation\n>   - RS256 (RSA-SHA256): Asymmetric key, complex key management, larger signatures\n>   - ES256 (ECDSA-SHA256): Asymmetric key, smaller signatures, more complex implementation\n> - **Decision**: Implement HS256 (HMAC-SHA256) as the primary algorithm\n> - **Rationale**: HS256 provides strong cryptographic security (256-bit) with straightforward implementation requirements. Symmetric key operation simplifies key management for single-service scenarios while avoiding the complexity of public key cryptography. The algorithm enjoys broad library support and extensive security analysis.\n> - **Consequences**: Limited to scenarios where both token issuers and verifiers can securely share the secret key. Cannot support distributed verification scenarios where multiple parties need to verify tokens without ability to issue them.\n\nThe signing input preparation requires careful attention to format consistency. The JWT specification mandates that the signing input consists of the Base64URL-encoded header, followed by a single dot character, followed by the Base64URL-encoded payload. No additional whitespace, encoding, or formatting is permitted. This precise format ensures that signature verification will succeed only when the exact same input string is reconstructed during the verification process.\n\n| HMAC-SHA256 Operation | Input | Output | Purpose |\n|----------------------|-------|--------|---------|\n| `create_signing_input` | encoded_header: str, encoded_payload: str | signing_input: str | Concatenate header.payload for signature computation |\n| `compute_hmac_sha256` | message: bytes, key: bytes | signature: bytes | Generate 32-byte HMAC-SHA256 authentication tag |\n| `encode_signature` | signature: bytes | encoded_signature: str | Convert binary signature to Base64URL format |\n| `sign_token` | signing_input: str, secret_key: bytes | signature: str | Complete signing process from input to encoded signature |\n\nKey handling during HMAC computation requires attention to encoding and format consistency. The secret key must be treated as raw bytes rather than text, avoiding encoding issues that could cause signature mismatches between signing and verification. When applications provide keys as strings, we must convert them to bytes using consistent encoding (UTF-8) to ensure reproducible results.\n\nThe HMAC computation itself leverages the cryptographic libraries provided by our target programming language, avoiding any attempt to implement the algorithm from scratch. Custom cryptographic implementations introduce significant security risks and provide no benefits over well-tested standard library implementations. Our role is to correctly invoke the standard HMAC-SHA256 function with proper parameters and handle the results appropriately.\n\nError handling during signature generation must distinguish between recoverable and fatal errors. Recoverable errors include invalid input formats that can be corrected by the caller, such as malformed JSON in headers or payloads. Fatal errors include cryptographic failures that indicate deeper problems, such as insufficient entropy for key generation or hardware security module failures. Our implementation should provide clear error messages that help developers diagnose problems without revealing sensitive information that could aid attackers.\n\n### Signature Verification Process\n\nSignature verification represents the most security-critical component of our JWT implementation, as vulnerabilities here can completely compromise the authentication system. The verification process must not only check mathematical correctness but also resist various cryptographic attacks, particularly timing attacks that could leak information about valid signatures through execution time measurements.\n\nThe verification algorithm follows a structured approach that prioritizes security over performance optimizations. First, we parse the incoming JWT token to extract the header, payload, and signature components. This parsing must handle malformed tokens gracefully, rejecting invalid formats without revealing information about expected structures. Second, we reconstruct the signing input using the same process employed during token creation, ensuring byte-for-byte consistency. Third, we recompute the expected signature using our secret key and the reconstructed signing input. Finally, we compare the recomputed signature with the provided signature using constant-time comparison to prevent timing attacks.\n\n> The critical security insight in signature verification is that ANY deviation from constant-time operation can leak information to attackers. Even minor optimizations like early termination on the first differing byte can enable sophisticated attackers to gradually discover valid signatures through timing measurements.\n\nThe constant-time comparison requirement deserves particular attention as it differs from normal string or byte array comparison operations. Standard comparison functions typically terminate as soon as they encounter the first differing byte, returning immediately with a \"not equal\" result. While this optimization improves performance for legitimate uses, it creates a timing side channel for cryptographic applications. An attacker can submit many candidate signatures and measure verification times to determine how many bytes match the expected signature, eventually reconstructing the entire signature through this timing oracle.\n\n| Verification Step | Security Requirement | Implementation Approach | Failure Handling |\n|-------------------|---------------------|------------------------|------------------|\n| Token Parsing | Reject malformed tokens | Validate three-part structure separated by dots | Return generic \"invalid token\" error |\n| Signature Decoding | Handle invalid Base64URL | Decode signature with padding restoration | Return generic \"invalid signature\" error |\n| Signing Input Reconstruction | Maintain byte-level consistency | Use identical encoding process as signing | Internal error if encoding fails |\n| HMAC Recomputation | Protect secret key | Use same algorithm and key as original signing | Internal error if HMAC computation fails |\n| Signature Comparison | Prevent timing attacks | Compare every byte regardless of early differences | Return boolean result only |\n\nOur constant-time comparison implementation must examine every byte of both signatures, accumulating differences without early termination. The comparison continues through the entire signature length even after detecting differences, ensuring consistent execution time regardless of where differences occur. Only after examining all bytes does the function return a boolean result indicating whether the signatures match.\n\nThe verification process must also handle various edge cases that could indicate attack attempts or system errors. Zero-length signatures, signatures longer than the expected HMAC output size, and signatures containing invalid Base64URL characters all represent potential attack vectors or implementation bugs. Our verification should reject these cases explicitly while providing minimal information in error messages to avoid assisting attackers.\n\n```\nSignature Verification Algorithm:\n1. Parse the JWT token to extract header, payload, and signature components\n2. Validate that each component is properly formatted Base64URL\n3. Decode the provided signature from Base64URL to binary\n4. Reconstruct the signing input by concatenating encoded header and payload with dot\n5. Compute the expected signature using HMAC-SHA256 with our secret key\n6. Compare the provided signature with expected signature using constant-time comparison\n7. Return verification result without revealing details of any failures\n```\n\nError handling during verification must balance security with debugging needs. Detailed error messages help developers diagnose integration problems, but they can also provide information useful to attackers. Our approach distinguishes between development and production environments, providing detailed diagnostics in development while returning generic error messages in production. This allows effective debugging during implementation while maintaining security in deployed systems.\n\n![Token Verification Sequence](./diagrams/token-verification-sequence.svg)\n\nThe verification process integrates with the broader JWT validation pipeline, where signature verification represents just one of several security checks. Even if signature verification succeeds, the token may still be invalid due to expiration, incorrect audience claims, or other validation failures. Our signature verification component focuses solely on cryptographic integrity, delegating other validation concerns to the claims validation component described in Milestone 3.\n\n### Secret Key Handling\n\nSecret key management represents one of the most critical security aspects of JWT implementation, as key compromise completely undermines the authentication system. Our approach to key handling must address several concerns: secure storage in memory, validation of key strength, protection against key extraction, and proper cleanup when keys are no longer needed.\n\nThe fundamental principle guiding our key handling approach is that secret keys should be treated as sensitive material throughout their entire lifecycle. This means avoiding unnecessary copying, preventing keys from appearing in logs or error messages, and clearing key material from memory when possible. While complete protection against memory analysis attacks requires specialized hardware or operating system features beyond our scope, we can implement reasonable protections against casual key exposure.\n\nKey validation plays an essential role in preventing weak keys from compromising security. While HMAC-SHA256 can technically operate with keys of any length, cryptographic best practices recommend keys of at least 256 bits (32 bytes) to match the security level of the underlying SHA-256 hash function. Keys shorter than this recommendation may be vulnerable to brute-force attacks, particularly if attackers can obtain large numbers of signed tokens for analysis.\n\n> **Decision: Minimum Key Length Enforcement**\n> - **Context**: HMAC can operate with keys of any length, but short keys reduce security. We need to decide whether to enforce minimum key length and what that minimum should be.\n> - **Options Considered**:\n>   - No minimum: Accept any key length for maximum flexibility\n>   - 16-byte minimum: Balances security with compatibility for existing systems\n>   - 32-byte minimum: Matches SHA-256 security level for optimal protection\n> - **Decision**: Enforce 32-byte minimum key length with option to override for testing\n> - **Rationale**: 32-byte keys provide security equivalent to the underlying SHA-256 algorithm, preventing the key from becoming the weakest link. This matches industry best practices and recommendations from cryptographic experts.\n> - **Consequences**: May require key generation or expansion for applications currently using shorter keys, but significantly improves overall security posture.\n\nOur key storage approach maintains keys as byte arrays rather than strings to avoid encoding issues and ensure consistent handling across different character encodings. When applications provide keys as strings, we convert them to bytes using UTF-8 encoding, but we encourage applications to generate and store keys as base64-encoded byte sequences for maximum compatibility.\n\n| Key Handling Operation | Security Consideration | Implementation Approach | Error Handling |\n|------------------------|------------------------|------------------------|----------------|\n| Key Storage | Minimize copies in memory | Store as single byte array, pass by reference | N/A - internal operation |\n| Key Validation | Enforce minimum length | Check byte length >= 32, validate encoding | Reject with clear error message |\n| Key Usage | Protect during HMAC operations | Pass directly to HMAC function | Let HMAC library handle errors |\n| Key Cleanup | Clear from memory when possible | Zero out byte array contents | Best effort - not guaranteed |\n\nThe key validation process checks both length and format to catch common integration errors before they cause mysterious signature failures. Length validation ensures the key meets our security requirements, while format validation catches issues like accidentally passing base64-encoded keys where raw bytes are expected. These validations provide clear error messages during development while preventing weak configurations in production.\n\nSecret key cleanup attempts to remove key material from memory when it's no longer needed, though the effectiveness of this approach depends on programming language memory management and operating system behavior. In garbage-collected languages, we can zero out byte arrays before releasing references, though the garbage collector may have created additional copies during memory management operations. In manually managed languages, we can explicitly clear memory before freeing it, providing more reliable cleanup.\n\nThe key handling component also addresses practical concerns around key distribution and rotation. While implementing full key rotation is beyond our current scope, our design anticipates future key rotation support by accepting keys as parameters rather than storing them as global state. This allows applications to change keys between operations, enabling gradual migration to new keys or emergency key rotation in response to compromise.\n\nKey generation guidance helps applications create strong keys appropriate for HMAC-SHA256 use. We recommend generating keys using cryptographically secure random number generators, avoiding predictable sources like timestamps or user-provided passwords. For applications that must derive keys from passwords, we recommend using proper key derivation functions like PBKDF2 or scrypt rather than simple hashing.\n\n### Architecture Decisions\n\nThe cryptographic signing component required several critical design decisions that balance security, performance, and usability requirements. These decisions establish the foundation for secure JWT implementation while supporting the specific needs of our educational project.\n\n> **Decision: Symmetric vs Asymmetric Cryptography**\n> - **Context**: JWT supports both symmetric algorithms (HMAC-based) and asymmetric algorithms (RSA/ECDSA). We need to choose which approach to implement first, considering learning objectives and implementation complexity.\n> - **Options Considered**:\n>   - HMAC-only: Simpler implementation, symmetric key sharing required\n>   - RSA signatures: Asymmetric keys enable distributed verification, more complex\n>   - Both algorithms: Maximum flexibility, significantly more implementation work\n> - **Decision**: Focus on HMAC-SHA256 with architecture supporting future asymmetric algorithms\n> - **Rationale**: HMAC provides an excellent introduction to cryptographic signatures without the complexity of public key cryptography. The learning objectives focus on understanding signature concepts rather than advanced cryptographic protocols.\n> - **Consequences**: Initial implementation limited to scenarios where all parties can share secret keys, but clean architecture enables adding asymmetric algorithms later.\n\nThe algorithm selection decision reflects our educational focus while maintaining practical utility. HMAC-SHA256 provides strong security guarantees and enjoys broad support across programming languages and platforms. Students can focus on understanding signature concepts, constant-time comparison, and secure key handling without getting distracted by the mathematical complexity of RSA or elliptic curve cryptography.\n\n> **Decision: Error Handling Strategy**\n> - **Context**: Cryptographic operations can fail in various ways, from invalid inputs to system-level errors. We need consistent error handling that aids debugging without helping attackers.\n> - **Options Considered**:\n>   - Detailed errors: Maximum debugging information, potential security risk\n>   - Generic errors: Minimal information leakage, harder debugging\n>   - Contextual errors: Different detail levels based on environment\n> - **Decision**: Generic errors in production with detailed errors available in development mode\n> - **Rationale**: Balances security needs with developer productivity. Production systems should minimize information leakage, while development environments need detailed diagnostics.\n> - **Consequences**: Requires configuration to distinguish environments, but provides both security and usability benefits.\n\nOur error handling approach recognizes that cryptographic components serve as security boundaries where information leakage can have serious consequences. By providing different error detail levels based on environment, we enable effective development while maintaining production security.\n\n> **Decision: Timing Attack Prevention**\n> - **Context**: Signature verification must prevent timing attacks that could leak information about valid signatures. This requires careful implementation of comparison operations.\n> - **Options Considered**:\n>   - Standard comparison: Fast but vulnerable to timing attacks\n>   - Constant-time comparison: Secure but potentially slower\n>   - Hash-based comparison: Alternative approach using cryptographic hashes\n> - **Decision**: Implement constant-time comparison for all cryptographic comparisons\n> - **Rationale**: Timing attacks represent a real threat in network-accessible applications. Constant-time comparison provides strong protection with acceptable performance overhead.\n> - **Consequences**: Slightly slower signature verification, but eliminates entire class of cryptographic attacks.\n\nThe timing attack prevention decision prioritizes security over performance, recognizing that cryptographic vulnerabilities can completely compromise authentication systems. While the performance impact is minimal for most applications, the security benefit is substantial.\n\n| Architecture Decision | Security Impact | Performance Impact | Implementation Complexity |\n|----------------------|------------------|-------------------|--------------------------|\n| HMAC-SHA256 Only | High - proven algorithm | High - fast computation | Low - standard library support |\n| Constant-time comparison | Critical - prevents timing attacks | Low - minimal overhead | Medium - requires careful implementation |\n| Generic error messages | Medium - reduces information leakage | None | Low - simple message filtering |\n| Minimum key length enforcement | High - prevents weak key attacks | None | Low - simple length check |\n\nOur architecture decisions establish security as the primary concern while maintaining reasonable performance and implementation complexity. Each decision includes explicit consideration of security implications, ensuring that educational simplicity doesn't come at the cost of fundamental security properties.\n\nThe component architecture also anticipates future extensions without requiring major refactoring. The signing interface accepts algorithm identifiers, enabling support for additional HMAC variants (HS384, HS512) or asymmetric algorithms (RS256, ES256) in future iterations. This extensibility allows the educational progression from simple symmetric signatures to advanced public key cryptography.\n\nPerformance considerations influence several implementation details, though security requirements take precedence in case of conflicts. We use streaming approaches for large token processing and avoid unnecessary memory allocations during signature computation. However, we never sacrifice constant-time properties or other security requirements for performance gains.\n\n![Signature Verification Process](./diagrams/signature-verification-flowchart.svg)\n\nThe architectural decisions create a foundation that supports both educational objectives and real-world deployment requirements. Students learn essential cryptographic concepts through hands-on implementation, while the resulting code maintains security properties necessary for production use.\n\n### Common Pitfalls\n\nCryptographic implementations present numerous opportunities for subtle bugs that can completely compromise security. These pitfalls often involve implementation details that appear minor but have significant security implications. Understanding these common mistakes helps developers avoid vulnerabilities and build more secure systems.\n\n⚠️ **Pitfall: Using Standard String/Byte Comparison for Signatures**\n\nOne of the most dangerous mistakes involves using standard comparison operations for signature verification. Most programming languages provide comparison functions optimized for performance, which terminate as soon as they find the first differing byte. While this optimization works well for general purposes, it creates a timing side channel that attackers can exploit to gradually discover valid signatures.\n\nThe vulnerability works by measuring how long signature verification takes for different candidate signatures. A signature that differs in the first byte will be rejected very quickly, while a signature that matches the first several bytes but differs later will take longer to reject. By systematically trying different byte values and measuring response times, attackers can determine the correct value for each byte position, eventually reconstructing the entire signature.\n\nThe correct approach requires comparing every byte of both signatures regardless of any differences found earlier. This constant-time comparison ensures that verification takes the same amount of time whether signatures differ in the first byte or the last byte, eliminating the timing side channel.\n\n⚠️ **Pitfall: Exposing Secret Keys in Error Messages or Logs**\n\nDevelopers often include excessive detail in error messages and log statements to aid debugging, inadvertently exposing sensitive information. Secret keys might appear in error messages when key validation fails, in debug logs during signature computation, or in stack traces when exceptions occur during cryptographic operations.\n\nEven partial key exposure can be dangerous. If attackers learn the first few bytes of a key through log analysis, they can use this information to significantly reduce the search space for brute-force attacks. Additionally, keys might be exposed indirectly through related information like key derivation parameters or storage paths.\n\nThe solution involves treating secret keys as sensitive material throughout the application. Never include keys in error messages, use generic identifiers in logs instead of actual key values, and ensure that exception handling doesn't inadvertently expose key material in stack traces or debugging output.\n\n⚠️ **Pitfall: Accepting Weak or Predictable Keys**\n\nApplications sometimes use weak keys that appear random but are actually predictable or have insufficient entropy. Common examples include keys derived from timestamps, user passwords without proper key derivation, or keys generated using weak random number generators.\n\nWeak keys can be vulnerable to brute-force attacks, especially if attackers can obtain multiple tokens signed with the same key. Even keys that seem random might be predictable if they follow patterns or use insufficient entropy sources. For example, keys derived from current time might be discoverable by trying timestamps around the token creation time.\n\nProper key handling requires using cryptographically secure random number generators and enforcing minimum key length requirements. Keys should have at least 256 bits of entropy to match the security level of HMAC-SHA256, and they should be generated using platform-specific secure random facilities rather than general-purpose random number generators.\n\n⚠️ **Pitfall: Incorrect Base64URL Encoding/Decoding**\n\nJWT requires Base64URL encoding, which differs from standard Base64 in subtle but important ways. Base64URL uses different characters for positions 62 and 63 (- and _ instead of + and /), omits padding characters, and is designed to be URL-safe. Using standard Base64 encoding creates tokens that may work in some contexts but fail unpredictably in others.\n\nThe encoding difference can cause signature verification failures when tokens are created with one encoding variant and verified with another. Additionally, padding handling can cause issues when manually implementing Base64URL encoding/decoding rather than using library functions specifically designed for this variant.\n\nAlways use Base64URL-specific encoding functions rather than adapting standard Base64 implementations. Most cryptographic libraries provide proper Base64URL support that handles the character set differences and padding requirements automatically.\n\n⚠️ **Pitfall: Algorithm Confusion Attacks**\n\nWhile our implementation focuses on HMAC-SHA256, JWT's flexibility in algorithm selection creates opportunities for algorithm confusion attacks. These attacks exploit systems that accept multiple algorithms by tricking them into using weaker algorithms or algorithms with different security properties.\n\nA common attack involves submitting tokens with \"alg\": \"none\" in the header, attempting to bypass signature verification entirely. Another variant involves submitting HMAC-signed tokens to systems expecting RSA signatures, potentially allowing attackers to use known public keys as HMAC secrets.\n\nEven though our implementation only supports HS256, we should explicitly validate that incoming tokens specify this algorithm and reject tokens claiming to use other algorithms. This prevents future extensibility from inadvertently introducing algorithm confusion vulnerabilities.\n\n⚠️ **Pitfall: Insufficient Error Handling During Signature Verification**\n\nSignature verification can fail for many reasons beyond simple signature mismatches. Network issues during key retrieval, memory allocation failures during signature computation, and hardware security module errors can all cause verification to fail in unexpected ways. Insufficient error handling might cause the system to behave unpredictably or provide more information to attackers than intended.\n\nSome implementations make the mistake of treating all verification errors as \"invalid signature\" results, potentially accepting tokens that should be rejected for other reasons. Others provide too much detail in error responses, helping attackers understand system internals or identify attack vectors.\n\nProper error handling distinguishes between different failure types while providing consistent external behavior. Cryptographic errors should be logged for debugging purposes but should result in generic \"verification failed\" responses to prevent information leakage to attackers.\n\n| Pitfall | Security Impact | Detection Method | Prevention Strategy |\n|---------|----------------|------------------|-------------------|\n| Timing attack vulnerability | Critical - can leak signature information | Measure verification time variance | Implement constant-time comparison |\n| Key exposure in logs | High - enables token forgery | Review log outputs and error messages | Sanitize all output containing keys |\n| Weak key acceptance | High - enables brute force attacks | Test with short or predictable keys | Enforce minimum key length and entropy |\n| Wrong Base64 variant | Medium - causes interoperability issues | Test with URL-unsafe characters | Use Base64URL-specific functions |\n| Algorithm confusion | Variable - depends on accepted algorithms | Submit tokens with different algorithms | Explicitly validate algorithm field |\n| Poor error handling | Low to Medium - information leakage | Submit malformed tokens | Provide consistent error responses |\n\n### Implementation Guidance\n\nThe cryptographic signing component requires careful attention to security details while leveraging standard library cryptographic functions. This guidance provides practical approaches for implementing secure HMAC-SHA256 signing and verification.\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| HMAC Implementation | `hashlib.hmac` (built-in) | `cryptography` library for enterprise features |\n| Constant-time Comparison | `hmac.compare_digest` (built-in) | Custom implementation with explicit timing control |\n| Key Validation | Manual length checks | `cryptography.fernet` key derivation utilities |\n| Error Handling | Standard exceptions | Custom exception hierarchy with security context |\n\n**Recommended File Structure:**\n```\njwt_library/\n  signing/\n    __init__.py              ← exports main signing interface\n    hmac_signer.py          ← HMAC-SHA256 implementation (core learning component)\n    key_handler.py          ← secret key validation and storage utilities\n    timing_safe.py          ← constant-time comparison utilities (provided)\n    exceptions.py           ← signing-specific exception classes (provided)\n  tests/\n    test_signing.py         ← comprehensive signing tests\n    test_vectors.py         ← RFC test vectors for validation\n```\n\n**Infrastructure Starter Code - Timing Safe Comparison (`timing_safe.py`):**\n```python\n\"\"\"\nTiming-safe comparison utilities for cryptographic operations.\nThis module provides comparison functions that resist timing attacks.\n\"\"\"\nimport hmac\nfrom typing import Union\n\ndef constant_time_compare(a: Union[bytes, str], b: Union[bytes, str]) -> bool:\n    \"\"\"\n    Compare two values in constant time to prevent timing attacks.\n    \n    This function always examines every byte regardless of early differences,\n    ensuring consistent execution time that doesn't leak information about\n    where the values differ.\n    \n    Args:\n        a: First value to compare (bytes or string)\n        b: Second value to compare (bytes or string)\n        \n    Returns:\n        True if values are identical, False otherwise\n        \n    Security:\n        Uses hmac.compare_digest for cryptographically secure comparison\n    \"\"\"\n    # Convert strings to bytes for consistent comparison\n    if isinstance(a, str):\n        a = a.encode('utf-8')\n    if isinstance(b, str):\n        b = b.encode('utf-8')\n    \n    # Use hmac.compare_digest for timing-safe comparison\n    return hmac.compare_digest(a, b)\n\ndef validate_signature_length(signature: bytes, expected_length: int) -> bool:\n    \"\"\"\n    Validate signature length in constant time.\n    \n    Args:\n        signature: The signature to validate\n        expected_length: Expected signature length in bytes\n        \n    Returns:\n        True if signature has correct length, False otherwise\n    \"\"\"\n    # Length comparison is naturally constant-time in most implementations\n    return len(signature) == expected_length\n```\n\n**Infrastructure Starter Code - Exception Classes (`exceptions.py`):**\n```python\n\"\"\"\nException classes for JWT signing operations.\nProvides specific exception types for different signing failure modes.\n\"\"\"\n\nclass JWTSigningError(Exception):\n    \"\"\"Base exception for all JWT signing errors.\"\"\"\n    pass\n\nclass InvalidKeyError(JWTSigningError):\n    \"\"\"Raised when secret key is invalid or insufficient.\"\"\"\n    pass\n\nclass SignatureVerificationError(JWTSigningError):\n    \"\"\"Raised when signature verification fails.\"\"\"\n    pass\n\nclass InvalidTokenFormatError(JWTSigningError):\n    \"\"\"Raised when token format is invalid for signing operations.\"\"\"\n    pass\n\nclass CryptographicError(JWTSigningError):\n    \"\"\"Raised when underlying cryptographic operations fail.\"\"\"\n    pass\n```\n\n**Core Logic Skeleton - HMAC Signer (`hmac_signer.py`):**\n```python\n\"\"\"\nHMAC-SHA256 signing implementation for JWT tokens.\nThis module handles the core cryptographic operations for JWT signing.\n\"\"\"\nimport hashlib\nimport hmac\nfrom typing import bytes\nfrom .timing_safe import constant_time_compare\nfrom .exceptions import InvalidKeyError, SignatureVerificationError, CryptographicError\n\n# Minimum key length for security (32 bytes = 256 bits)\nMIN_KEY_LENGTH = 32\n# Expected signature length for HMAC-SHA256 (32 bytes)\nHMAC_SHA256_LENGTH = 32\n\nclass HMACSignerHS256:\n    \"\"\"HMAC-SHA256 signer for JWT tokens.\"\"\"\n    \n    def __init__(self, secret_key: bytes):\n        \"\"\"\n        Initialize HMAC signer with secret key.\n        \n        Args:\n            secret_key: Secret key for HMAC operations (minimum 32 bytes)\n            \n        Raises:\n            InvalidKeyError: If key is too short or invalid\n        \"\"\"\n        # TODO 1: Validate key length meets minimum security requirements\n        # TODO 2: Store key securely for later use in signing operations\n        # Hint: Check len(secret_key) >= MIN_KEY_LENGTH\n        pass\n    \n    def create_signing_input(self, encoded_header: str, encoded_payload: str) -> str:\n        \"\"\"\n        Create signing input string from encoded header and payload.\n        \n        Args:\n            encoded_header: Base64URL encoded JWT header\n            encoded_payload: Base64URL encoded JWT payload\n            \n        Returns:\n            Signing input in format \"header.payload\"\n        \"\"\"\n        # TODO 1: Concatenate header and payload with dot separator\n        # TODO 2: Return the complete signing input string\n        # Hint: Use f\"{encoded_header}.{encoded_payload}\"\n        pass\n    \n    def sign(self, signing_input: str) -> str:\n        \"\"\"\n        Generate HMAC-SHA256 signature for signing input.\n        \n        Args:\n            signing_input: String to sign (header.payload format)\n            \n        Returns:\n            Base64URL encoded signature\n            \n        Raises:\n            CryptographicError: If HMAC computation fails\n        \"\"\"\n        try:\n            # TODO 1: Convert signing input string to bytes using UTF-8 encoding\n            # TODO 2: Compute HMAC-SHA256 using self._secret_key and input bytes\n            # TODO 3: Encode resulting signature using base64url_encode function\n            # TODO 4: Return encoded signature as string\n            # Hint: Use hmac.new(key, message, hashlib.sha256).digest()\n            pass\n        except Exception as e:\n            # TODO 5: Wrap any exceptions in CryptographicError\n            pass\n    \n    def verify(self, signing_input: str, provided_signature: str) -> bool:\n        \"\"\"\n        Verify HMAC-SHA256 signature against signing input.\n        \n        Args:\n            signing_input: String that was signed\n            provided_signature: Base64URL encoded signature to verify\n            \n        Returns:\n            True if signature is valid, False otherwise\n            \n        Raises:\n            SignatureVerificationError: If verification process fails\n        \"\"\"\n        try:\n            # TODO 1: Decode provided signature from Base64URL to bytes\n            # TODO 2: Validate signature length matches HMAC-SHA256 output (32 bytes)\n            # TODO 3: Compute expected signature using same process as sign()\n            # TODO 4: Compare provided and expected signatures using constant_time_compare\n            # TODO 5: Return comparison result\n            # Hint: Use base64url_decode() and validate length before comparison\n            pass\n        except Exception as e:\n            # TODO 6: Convert exceptions to SignatureVerificationError\n            pass\n```\n\n**Core Logic Skeleton - Key Handler (`key_handler.py`):**\n```python\n\"\"\"\nSecret key handling utilities for JWT signing operations.\nProvides secure key validation and management functions.\n\"\"\"\nimport secrets\nimport os\nfrom typing import Union\nfrom .exceptions import InvalidKeyError\n\ndef validate_key_strength(key: bytes) -> None:\n    \"\"\"\n    Validate that secret key meets security requirements.\n    \n    Args:\n        key: Secret key to validate\n        \n    Raises:\n        InvalidKeyError: If key doesn't meet security requirements\n    \"\"\"\n    # TODO 1: Check key length meets minimum requirement (32 bytes)\n    # TODO 2: Optionally check for obviously weak keys (all zeros, repeated patterns)\n    # TODO 3: Raise InvalidKeyError with descriptive message if validation fails\n    # Hint: Use len(key) and consider checking for key == b'\\x00' * len(key)\n    pass\n\ndef generate_secure_key() -> bytes:\n    \"\"\"\n    Generate cryptographically secure random key for HMAC operations.\n    \n    Returns:\n        32-byte random key suitable for HMAC-SHA256\n    \"\"\"\n    # TODO 1: Generate 32 random bytes using cryptographically secure generator\n    # TODO 2: Return the generated key\n    # Hint: Use secrets.token_bytes(32)\n    pass\n\ndef key_from_string(key_string: str) -> bytes:\n    \"\"\"\n    Convert string key to bytes with consistent encoding.\n    \n    Args:\n        key_string: Key as string (will be UTF-8 encoded)\n        \n    Returns:\n        Key as bytes\n    \"\"\"\n    # TODO 1: Encode string to bytes using UTF-8\n    # TODO 2: Validate resulting key meets security requirements\n    # TODO 3: Return validated key bytes\n    # Hint: Use key_string.encode('utf-8') then validate_key_strength()\n    pass\n\nclass SecureKeyHandler:\n    \"\"\"Secure storage and management of JWT signing keys.\"\"\"\n    \n    def __init__(self, key: Union[bytes, str]):\n        \"\"\"\n        Initialize key handler with secure key storage.\n        \n        Args:\n            key: Secret key as bytes or string\n        \"\"\"\n        # TODO 1: Convert string keys to bytes if needed\n        # TODO 2: Validate key strength\n        # TODO 3: Store key securely (consider copying to avoid external modification)\n        # Hint: Use isinstance(key, str) to check type and bytes(key) to copy\n        pass\n    \n    def get_key(self) -> bytes:\n        \"\"\"\n        Retrieve stored key for cryptographic operations.\n        \n        Returns:\n            Secret key as bytes\n        \"\"\"\n        # TODO 1: Return copy of stored key to prevent external modification\n        # Hint: Return bytes(self._key) to create a copy\n        pass\n    \n    def clear_key(self) -> None:\n        \"\"\"\n        Attempt to clear key from memory (best effort).\n        \"\"\"\n        # TODO 1: Overwrite key bytes with zeros\n        # TODO 2: Set key reference to None\n        # Hint: Use bytearray to create mutable copy, then clear with zeros\n        pass\n```\n\n**Language-Specific Hints for Python:**\n- Use `hmac.new(key, message, hashlib.sha256)` for HMAC-SHA256 computation\n- Always use `hmac.compare_digest()` for cryptographic comparisons to prevent timing attacks\n- Import `secrets` module for cryptographically secure random number generation\n- Use `bytes()` constructor to create defensive copies of key material\n- Handle encoding carefully: strings should be UTF-8 encoded before cryptographic operations\n\n**Milestone Checkpoint:**\nAfter implementing the cryptographic signing component, verify functionality with these tests:\n\n1. **Basic Signing Test**: Create a simple JWT with known header/payload, sign it, and verify the signature format is valid Base64URL\n2. **Round-trip Verification**: Sign a token and immediately verify it with the same key - should return True\n3. **Invalid Signature Detection**: Modify one character in a valid signature and verify it's rejected\n4. **Key Length Validation**: Attempt to create signer with 16-byte key - should raise InvalidKeyError\n5. **Timing Attack Resistance**: Measure verification time for signatures differing in first vs last byte - times should be similar\n\nExpected behavior: All signatures should be exactly 43 characters (32 bytes Base64URL encoded), verification should complete in consistent time regardless of where signatures differ, and weak keys should be rejected with clear error messages.\n\nCommon debugging signs:\n- **Signature length wrong**: Check Base64URL encoding, should be 43 chars for 32-byte HMAC output\n- **Verification always fails**: Ensure identical signing input reconstruction in both sign/verify\n- **Timing variations**: Profile comparison function to ensure constant-time operation\n- **Key validation bypassed**: Verify MIN_KEY_LENGTH constant is being checked correctly\n\n\n## Claims Validation Component\n\n> **Milestone(s):** Milestone 3 (Claims Validation) - implements standard JWT claim validation including time-based security checks, issuer and audience verification, and custom claims processing\n\nThe claims validation component represents the final security checkpoint in our JWT library, ensuring that tokens contain valid, trustworthy information before granting access to protected resources. While signature verification confirms the token hasn't been tampered with, claims validation ensures the token is currently valid, comes from an authorized issuer, and is intended for the correct audience.\n\n### Mental Model: Ticket Inspection\n\nUnderstanding claims validation becomes intuitive when we think of it like comprehensive ticket inspection at a major event venue. Imagine you're a security guard at a concert venue, and patrons are presenting tickets (JWT tokens) for entry.\n\nThe signature verification component already confirmed the tickets are genuine (not counterfeit), but now you need to perform detailed inspection to ensure each ticket is actually valid for entry. You check multiple aspects systematically: Is this ticket for tonight's show, or did someone try to use last week's ticket? Has the show already started, or is this person trying to enter too early with a \"VIP early access\" ticket that isn't valid yet? Is this ticket for the correct venue, or did someone accidentally bring their ticket from the stadium across town? Is the ticket issued by an authorized ticket vendor we recognize, or is it from some unauthorized reseller we don't trust?\n\nJust as a thorough security guard checks expiration dates, venue information, authorized sellers, and timing restrictions, our claims validation component systematically verifies temporal claims (expiration, not-before dates), identity claims (issuer verification), audience claims (intended recipient), and any custom business logic encoded in the token. The goal is ensuring that even with a cryptographically valid token, we only grant access when all the contextual information confirms the token should be honored right now, for this specific request.\n\n### Time-Based Claim Validation\n\n![Token Validation State Machine](./diagrams/validation-state-machine.svg)\n\nTime-based validation forms the cornerstone of JWT security, preventing replay attacks and ensuring tokens have bounded lifetimes. The JWT specification defines three temporal claims that work together to create secure time windows for token validity.\n\nThe **expiration claim (`exp`)** specifies the absolute time after which a token must be rejected. This claim is expressed as a Unix timestamp (seconds since epoch) and represents the moment when the token becomes invalid. The validation logic compares the current UTC time against this timestamp, rejecting tokens where the current time exceeds the expiration. However, real-world distributed systems rarely have perfectly synchronized clocks, so validation must account for reasonable clock skew between the token issuer and validator.\n\nThe **not-before claim (`nbf`)** defines the earliest time at which a token becomes valid. This claim enables scenarios like scheduled access grants or delayed activation tokens. Validation rejects tokens where the current time is before the not-before timestamp, even if the signature is valid and the token hasn't expired. This claim is particularly valuable for time-delayed permissions or tokens that should only become active at a specific future moment.\n\nThe **issued-at claim (`iat`)** records when the token was created, serving both audit purposes and preventing unreasonably old tokens from being accepted. While not strictly required for security, the issued-at claim helps detect tokens that were issued suspiciously far in the past or future, which might indicate system clock problems or potential attacks.\n\nClock skew tolerance becomes critical in distributed environments where token issuers and validators run on different servers with slightly different system clocks. Network latency, system load, and imperfect time synchronization can create small timing discrepancies. The validation component addresses this through a configurable **leeway period** that extends both directions around time-based boundaries.\n\n| Claim | Purpose | Validation Logic | Clock Skew Handling |\n|-------|---------|------------------|-------------------|\n| `exp` | Token expiration | Reject if `current_time > exp` | Allow if `current_time <= exp + leeway` |\n| `nbf` | Not valid before | Reject if `current_time < nbf` | Allow if `current_time >= nbf - leeway` |\n| `iat` | Issued at time | Sanity check only | Warn if `abs(current_time - iat) > max_age` |\n\nThe temporal validation algorithm follows a specific sequence that accounts for clock skew while maintaining security:\n\n1. **Retrieve the current UTC timestamp** using a reliable time source, ensuring consistent timezone handling across all validations\n2. **Extract temporal claims** from the JWT payload, handling cases where claims might be missing or have incorrect types\n3. **Apply the configured leeway period** to create tolerance windows around each timestamp boundary\n4. **Validate the expiration claim** by checking if the current time (minus leeway) exceeds the expiration timestamp\n5. **Validate the not-before claim** by checking if the current time (plus leeway) is before the not-before timestamp\n6. **Sanity-check the issued-at claim** by warning if the token appears to be issued unreasonably far in the past or future\n7. **Record validation results** for audit logging and debugging purposes\n\n> **Decision: Default Leeway Period**\n> - **Context**: Distributed systems have imperfect clock synchronization, creating timing edge cases in token validation\n> - **Options Considered**: Zero leeway (strict), 60-second leeway (minimal), 300-second leeway (generous)\n> - **Decision**: 300 seconds (5 minutes) default leeway with configurability\n> - **Rationale**: Balances security with practical deployment reality - most clock drift falls within 5 minutes, and the risk of 5-minute replay windows is acceptable for most applications\n> - **Consequences**: Tokens remain valid for up to 5 minutes past expiration by default, but applications can configure stricter validation when needed\n\nThe validation context structure allows applications to customize temporal behavior based on their security requirements:\n\n| Configuration Field | Type | Purpose | Default Value |\n|---------------------|------|---------|---------------|\n| `leeway_seconds` | int | Clock skew tolerance | 300 |\n| `verify_expiration` | bool | Enable expiration checking | true |\n| `verify_not_before` | bool | Enable not-before checking | true |\n| `max_token_age` | int | Maximum allowed token age | 86400 (24 hours) |\n| `require_iat` | bool | Require issued-at claim | false |\n\n### Identity and Audience Validation\n\n![Claims Validation Decision Tree](./diagrams/claims-validation-flowchart.svg)\n\nIdentity and audience validation ensures tokens come from trusted sources and are intended for the correct recipient. These claims form the foundation of multi-tenant security and prevent tokens from being misused across different services or applications.\n\nThe **issuer claim (`iss`)** identifies who created the token, typically represented as a URL or unique identifier. Validation maintains an allowlist of trusted issuers and rejects tokens from unknown or untrusted sources. This prevents attackers from creating their own JWT issuers and attempting to forge tokens that would be accepted by the application.\n\nIssuer validation follows a strict allowlist approach rather than a blocklist, ensuring that only explicitly trusted issuers can create tokens. The validation logic performs exact string matching against the configured list of allowed issuers, with no partial matching or pattern-based validation that could introduce security vulnerabilities.\n\nThe **audience claim (`aud`)** specifies the intended recipients of the token, preventing tokens meant for one service from being used to access a different service. The JWT specification allows audiences to be represented as either a single string or an array of strings, accommodating tokens that are valid for multiple services.\n\nAudience validation presents unique challenges because the claim can be either a string or an array. The validation logic must handle both formats correctly, checking if the expected audience appears anywhere in the audience list when the claim is an array, or performing exact string matching when the claim is a single string.\n\n| Validation Type | Required Configuration | Validation Logic | Error Conditions |\n|----------------|----------------------|------------------|------------------|\n| Issuer | `allowed_issuers` list | Exact string match | Missing `iss`, unlisted issuer |\n| Audience | `expected_audience` string | String or array membership | Missing `aud`, audience mismatch |\n| Subject | Optional validation | Application-specific | Invalid format or unauthorized subject |\n\nThe identity validation algorithm incorporates both mandatory and optional checks:\n\n1. **Extract the issuer claim** from the token payload, handling cases where the claim is missing or has an incorrect type\n2. **Check the require_issuer flag** to determine if issuer validation is mandatory for this validation context\n3. **Validate against the allowlist** by performing exact string matching against each entry in the allowed_issuers configuration\n4. **Extract the audience claim** and determine its format (string or array) for appropriate validation logic\n5. **Check the require_audience flag** to determine if audience validation is mandatory for this validation context\n6. **Perform audience membership testing** by checking if the expected audience appears in the claim value\n7. **Extract and validate the subject claim** if application-specific subject validation is configured\n8. **Log validation decisions** for audit purposes and security monitoring\n\n> **Decision: Exact String Matching for Claims**\n> - **Context**: Claims validation could use exact matching, pattern matching, or more flexible string comparison\n> - **Options Considered**: Exact matching, regex patterns, case-insensitive matching\n> - **Decision**: Exact string matching only for security-critical claims\n> - **Rationale**: Pattern matching introduces complexity and potential bypass vulnerabilities; exact matching is more predictable and secure\n> - **Consequences**: Applications must ensure exact case and format matching in their issuer and audience configurations\n\nThe audience validation logic handles the specification's flexibility while maintaining security:\n\n```\nAudience Validation Algorithm:\n1. If audience claim is missing and require_audience is true → REJECT\n2. If audience claim is missing and require_audience is false → ACCEPT\n3. If audience claim is a string:\n   a. Compare exactly with expected_audience\n   b. ACCEPT if match, REJECT if no match\n4. If audience claim is an array:\n   a. Iterate through each audience value\n   b. ACCEPT if any value matches expected_audience exactly\n   c. REJECT if no values match\n5. If audience claim is neither string nor array → REJECT (invalid format)\n```\n\n### Custom Claims Processing\n\nCustom claims enable applications to embed business-specific information directly into tokens, eliminating the need for additional database queries during request processing. The claims validation component provides a flexible framework for extracting and validating application-defined claims while maintaining the security properties of standard claims.\n\nCustom claims fall into three categories defined by the JWT specification: **public claims** use collision-resistant names (typically URLs), **private claims** are agreed upon between token issuers and consumers, and **application-specific claims** contain business logic data unique to the particular system.\n\nThe custom claims processing system maintains a clear separation between claim extraction and claim validation. Extraction focuses on safely retrieving typed data from the JSON payload, while validation applies business logic rules to determine if the claim values are acceptable for the current request context.\n\n| Claim Category | Naming Convention | Collision Risk | Validation Approach |\n|---------------|------------------|----------------|-------------------|\n| Public | URL-based names | Low (collision-resistant) | Standard validation rules |\n| Private | Agreed-upon names | Medium (coordination required) | Application-specific rules |\n| Application | Internal names | High (namespace conflicts) | Custom validation logic |\n\nThe custom claims extraction process handles type safety and data validation systematically:\n\n1. **Parse the JWT payload** as a JSON object, ensuring all standard claims are handled separately from custom claims\n2. **Identify custom claim keys** by filtering out the standard registered claim names (iss, sub, aud, exp, nbf, iat, jti)\n3. **Extract claim values** with appropriate type checking, handling strings, numbers, booleans, arrays, and nested objects\n4. **Apply claim-specific validation rules** based on application configuration and business logic requirements\n5. **Populate the custom_claims dictionary** with successfully validated claim data for application use\n6. **Log validation failures** for custom claims that fail business logic validation without rejecting the entire token\n\nCustom claims validation configuration allows applications to specify validation rules declaratively:\n\n| Configuration Element | Purpose | Example Values |\n|----------------------|---------|----------------|\n| `required_claims` | Claims that must be present | [\"role\", \"tenant_id\", \"permissions\"] |\n| `claim_validators` | Type and format validation | {\"role\": \"string\", \"permissions\": \"array\"} |\n| `value_constraints` | Allowed values or ranges | {\"role\": [\"admin\", \"user\"], \"max_sessions\": 10} |\n\nThe validation framework provides common validation patterns while allowing custom validation logic:\n\n1. **Presence validation** ensures required claims are not missing from the token payload\n2. **Type validation** confirms claim values match expected JSON types (string, number, boolean, array, object)\n3. **Format validation** applies regular expressions or custom format checking to string claims\n4. **Range validation** ensures numeric claims fall within acceptable minimum and maximum bounds\n5. **Enumeration validation** restricts string claims to predefined allowed values\n6. **Custom validation** applies arbitrary application logic to complex claim structures\n\n> **Decision: Flexible Custom Claims Architecture**\n> - **Context**: Applications need to embed business logic in tokens while maintaining validation consistency\n> - **Options Considered**: Fixed claim schema, completely flexible claims, hybrid validation approach\n> - **Decision**: Hybrid approach with configurable validation rules and extensible validation logic\n> - **Rationale**: Provides type safety and common validation patterns while allowing application-specific business logic\n> - **Consequences**: Applications must configure validation rules explicitly, but gain flexibility for complex use cases\n\n### Architecture Decisions\n\nThe claims validation component incorporates several critical architectural decisions that balance security, performance, and developer experience. These decisions directly impact how the component integrates with the broader JWT library and how applications configure validation behavior.\n\n> **Decision: Fail-Fast Validation Strategy**\n> - **Context**: Claims validation could check all claims and return aggregate errors, or fail immediately on the first invalid claim\n> - **Options Considered**: Fail-fast (immediate rejection), comprehensive validation (check all claims), configurable strategy\n> - **Decision**: Fail-fast validation with early termination on any validation failure\n> - **Rationale**: Reduces attack surface by minimizing processing of potentially malicious tokens; simpler error handling; better performance for invalid tokens\n> - **Consequences**: Applications receive single-error feedback rather than comprehensive validation reports; debugging may require multiple fix-and-retry cycles\n\n| Validation Strategy | Pros | Cons | Security Impact |\n|-------------------|------|------|-----------------|\n| Fail-fast | Fast rejection, simple logic | Single error per attempt | Minimal attack surface |\n| Comprehensive | Complete error reporting | Complex error handling | Extended processing of invalid tokens |\n| Configurable | Flexible behavior | Increased complexity | Variable attack surface |\n\n> **Decision: Immutable Validation Context**\n> - **Context**: Validation configuration could be mutable (allowing runtime changes) or immutable (fixed at creation time)\n> - **Options Considered**: Mutable context with runtime updates, immutable context with factory creation, hybrid approach\n> - **Decision**: Immutable ValidationContext objects created through factory functions\n> - **Rationale**: Prevents accidental configuration changes during validation; enables safe concurrent use; clearer security boundaries\n> - **Consequences**: Applications must create new contexts for different validation requirements; no runtime configuration updates\n\nThe validation context factory approach ensures thread safety and prevents configuration tampering:\n\n| Factory Method | Purpose | Configuration Scope |\n|---------------|---------|-------------------|\n| `create_strict_context()` | Maximum security validation | All checks enabled, minimal leeway |\n| `create_permissive_context()` | Development-friendly validation | Optional checks, generous leeway |\n| `create_custom_context()` | Application-specific configuration | Fully configurable validation rules |\n\n> **Decision: Hierarchical Error Classification**\n> - **Context**: Validation failures could return generic errors or detailed, categorized error information\n> - **Options Considered**: Generic validation errors, detailed error codes, hierarchical error types\n> - **Decision**: Hierarchical error classification with security-appropriate detail levels\n> - **Rationale**: Enables appropriate error handling without leaking security-sensitive information; supports debugging while preventing information disclosure\n> - **Consequences**: Applications must handle multiple error types; error messages balance security with developer experience\n\nThe error hierarchy provides appropriate detail without security information leakage:\n\n| Error Category | Public Details | Internal Details | Security Rationale |\n|---------------|---------------|------------------|-------------------|\n| Temporal | \"Token expired\" | Exact expiration time | Prevents timing analysis |\n| Identity | \"Invalid issuer\" | Expected vs actual issuer | Prevents issuer enumeration |\n| Audience | \"Audience mismatch\" | Expected vs actual audience | Prevents service discovery |\n| Custom | \"Claim validation failed\" | Specific claim and reason | Prevents business logic exposure |\n\n### Common Pitfalls\n\nClaims validation presents numerous subtle edge cases that can introduce security vulnerabilities or cause legitimate tokens to be incorrectly rejected. Understanding these pitfalls helps developers build robust validation logic.\n\n⚠️ **Pitfall: Clock Skew Overcompensation**\n\nDevelopers often set excessively generous leeway periods to avoid clock synchronization issues, inadvertently creating security vulnerabilities. A leeway of several hours or days essentially defeats the purpose of token expiration, allowing expired tokens to remain valid indefinitely.\n\nThe problem manifests when applications experience occasional clock drift and developers respond by increasing the leeway period instead of addressing the underlying time synchronization issue. This creates a false sense of security where tokens appear to have bounded lifetimes but actually remain valid far beyond their intended expiration.\n\n**Fix**: Use the minimum leeway period necessary for your infrastructure (typically 300 seconds or less) and implement proper NTP synchronization across all servers. Monitor clock drift and alert when servers exceed acceptable time variance rather than increasing leeway periods.\n\n⚠️ **Pitfall: Audience Claim Type Confusion**\n\nThe JWT specification allows audience claims to be either strings or arrays, but many implementations incorrectly assume one format or the other. This leads to validation failures when tokens contain audience arrays but the validator expects strings, or vice versa.\n\nThe issue becomes particularly problematic in microservice architectures where some services generate tokens with single audience strings while others use audience arrays. Validation logic that doesn't handle both formats correctly will reject valid tokens unpredictably.\n\n**Fix**: Implement validation logic that explicitly checks the audience claim type and handles both string and array formats. Always test with both single-audience and multi-audience tokens during development.\n\n```\nAudience Validation Logic:\n1. Extract audience claim from payload\n2. Check if claim is string → validate as single audience\n3. Check if claim is array → validate as audience list\n4. If neither string nor array → reject as invalid format\n```\n\n⚠️ **Pitfall: Missing Claim vs. Null Claim Confusion**\n\nJSON parsing libraries handle missing object properties and null values differently, but validation logic often conflates these cases. A missing `exp` claim and an `exp` claim with a null value represent different scenarios and should be handled distinctly.\n\nMissing claims might indicate tokens created by older systems that don't include certain fields, while null claims might indicate explicit attempts to bypass validation or corrupted token data. Treating these cases identically can lead to either overly permissive or overly restrictive validation.\n\n**Fix**: Explicitly check for claim presence using JSON object key existence before checking claim values. Handle missing claims and null claims as separate validation cases with appropriate error messages.\n\n⚠️ **Pitfall: Integer Overflow in Timestamp Handling**\n\nUnix timestamps in JWT claims are represented as JSON numbers, but different languages and JSON parsers handle large integers differently. Timestamps near the year 2038 problem boundary (2^31 seconds since epoch) can cause integer overflow in 32-bit systems or unexpected behavior in languages with limited integer precision.\n\nAdditionally, some JWT implementations use millisecond timestamps instead of second timestamps, creating magnitude differences that cause all time-based validation to fail. The JWT specification requires second-precision Unix timestamps, but not all implementations follow this requirement.\n\n**Fix**: Use 64-bit integers for all timestamp handling and explicitly validate that timestamp values fall within reasonable ranges (between reasonable past and future dates). Detect and handle millisecond timestamps by checking if values are suspiciously large.\n\n⚠️ **Pitfall: Case Sensitivity in Claim Matching**\n\nString matching for issuer and audience claims is case-sensitive, but applications often assume case-insensitive matching will work. This leads to validation failures when token issuers use different capitalization than the validation configuration expects.\n\nThe problem is compounded when applications use URLs as issuer identifiers, since URLs can be represented with different schemes (HTTP vs HTTPS) or hostnames (different capitalization) that should be treated as distinct for security purposes.\n\n**Fix**: Use exact string matching for all security-critical claims and ensure consistent capitalization in both token generation and validation configuration. Document the case-sensitivity requirement clearly for application developers.\n\n⚠️ **Pitfall: Custom Claims Type Coercion**\n\nApplications often extract custom claims without proper type validation, allowing JSON type coercion to silently convert claim values in unexpected ways. A numeric permission level might be provided as a string \"5\" but converted to integer 5, or boolean flags might be provided as strings \"true\"/\"false\" but not converted to actual booleans.\n\nType coercion can create security vulnerabilities when validation logic expects specific types but receives coerced values that bypass validation rules. For example, a string comparison might succeed when an integer comparison would fail.\n\n**Fix**: Implement explicit type checking for all custom claims before performing validation logic. Reject tokens with claims that have incorrect types rather than attempting type coercion.\n\n⚠️ **Pitfall: Timezone Confusion in Time Validation**\n\nUTC timestamp handling can introduce subtle bugs when system clocks, application logic, or database storage use different timezone assumptions. Tokens validated on servers in different timezones might produce inconsistent results if timezone conversion isn't handled carefully.\n\nThe issue becomes particularly problematic when applications mix timezone-aware datetime objects with Unix timestamps, leading to incorrect time comparisons that can cause premature expiration or extended validity periods.\n\n**Fix**: Use UTC consistently throughout all timestamp handling, convert all datetime objects to UTC before Unix timestamp conversion, and validate that system clocks are configured for UTC rather than local timezones.\n\n### Implementation Guidance\n\nThe claims validation component requires careful attention to time handling, type safety, and security boundaries. The following implementation structure provides a robust foundation while maintaining flexibility for application-specific requirements.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Time Handling | `datetime.utcnow()` + manual UTC conversion | `pendulum` library for robust timezone handling |\n| JSON Validation | Built-in `json` module with manual type checking | `jsonschema` library for declarative validation |\n| Configuration | Simple dictionaries and dataclasses | `pydantic` models with validation |\n| Logging | Standard `logging` module | `structlog` for structured claim validation logs |\n\n#### Recommended File Structure\n\nThe claims validation component integrates with the broader JWT library architecture:\n\n```\njwt-library/\n  jwt/\n    __init__.py                 ← main library exports\n    validation/                 ← claims validation component\n      __init__.py              ← validation exports\n      claims_validator.py      ← main validation logic\n      time_validation.py       ← temporal claim handling\n      identity_validation.py   ← issuer/audience validation\n      custom_claims.py         ← custom claims processing\n      validation_context.py    ← configuration management\n      validation_errors.py     ← error hierarchy\n    core/                      ← core JWT components\n      encoding.py             ← token encoding (Milestone 1)\n      signing.py              ← HMAC signing (Milestone 2)\n  tests/\n    test_validation/           ← validation component tests\n      test_claims_validator.py\n      test_time_validation.py\n      test_identity_validation.py\n      test_custom_claims.py\n```\n\n#### Infrastructure Starter Code\n\n**validation_errors.py** - Complete error hierarchy for claims validation:\n\n```python\n\"\"\"\nJWT Claims Validation Error Hierarchy\nProvides security-appropriate error classification without information leakage\n\"\"\"\n\nfrom typing import Optional, Dict, Any\nfrom datetime import datetime\n\nclass JWTValidationError(Exception):\n    \"\"\"Base exception for all JWT validation failures\"\"\"\n    \n    def __init__(self, message: str, claim_name: Optional[str] = None):\n        super().__init__(message)\n        self.claim_name = claim_name\n        self.timestamp = datetime.utcnow()\n\nclass TemporalValidationError(JWTValidationError):\n    \"\"\"Raised when time-based claims fail validation\"\"\"\n    pass\n\nclass TokenExpiredError(TemporalValidationError):\n    \"\"\"Raised when token has expired (exp claim validation failure)\"\"\"\n    \n    def __init__(self, message: str = \"Token has expired\"):\n        super().__init__(message, claim_name=\"exp\")\n\nclass TokenNotYetValidError(TemporalValidationError):\n    \"\"\"Raised when token is not yet valid (nbf claim validation failure)\"\"\"\n    \n    def __init__(self, message: str = \"Token is not yet valid\"):\n        super().__init__(message, claim_name=\"nbf\")\n\nclass IdentityValidationError(JWTValidationError):\n    \"\"\"Raised when identity claims fail validation\"\"\"\n    pass\n\nclass InvalidIssuerError(IdentityValidationError):\n    \"\"\"Raised when issuer is not in allowed list\"\"\"\n    \n    def __init__(self, message: str = \"Token issuer is not trusted\"):\n        super().__init__(message, claim_name=\"iss\")\n\nclass InvalidAudienceError(IdentityValidationError):\n    \"\"\"Raised when audience doesn't match expected value\"\"\"\n    \n    def __init__(self, message: str = \"Token audience mismatch\"):\n        super().__init__(message, claim_name=\"aud\")\n\nclass CustomClaimValidationError(JWTValidationError):\n    \"\"\"Raised when custom claims fail validation\"\"\"\n    \n    def __init__(self, message: str, claim_name: str):\n        super().__init__(f\"Custom claim validation failed: {message}\", claim_name)\n\nclass MissingRequiredClaimError(JWTValidationError):\n    \"\"\"Raised when a required claim is missing from the token\"\"\"\n    \n    def __init__(self, claim_name: str):\n        super().__init__(f\"Required claim is missing\", claim_name)\n```\n\n**validation_context.py** - Complete validation configuration management:\n\n```python\n\"\"\"\nJWT Validation Context Configuration\nImmutable configuration objects for claims validation\n\"\"\"\n\nfrom dataclasses import dataclass, field\nfrom typing import List, Optional, Dict, Any, Callable\nfrom datetime import timedelta\n\n# Default configuration constants\nDEFAULT_LEEWAY_SECONDS = 300  # 5 minutes\nDEFAULT_MAX_TOKEN_AGE = 86400  # 24 hours\n\n@dataclass(frozen=True)\nclass ValidationContext:\n    \"\"\"Immutable validation configuration for JWT claims checking\"\"\"\n    \n    # Time-based validation settings\n    verify_expiration: bool = True\n    verify_not_before: bool = True\n    leeway_seconds: int = DEFAULT_LEEWAY_SECONDS\n    max_token_age_seconds: int = DEFAULT_MAX_TOKEN_AGE\n    require_iat: bool = False\n    \n    # Identity validation settings\n    allowed_issuers: List[str] = field(default_factory=list)\n    require_issuer: bool = True\n    expected_audience: Optional[str] = None\n    require_audience: bool = True\n    \n    # Custom claims validation settings\n    required_claims: List[str] = field(default_factory=list)\n    custom_validators: Dict[str, Callable[[Any], bool]] = field(default_factory=dict)\n    \n    def __post_init__(self):\n        \"\"\"Validate configuration after creation\"\"\"\n        if self.leeway_seconds < 0:\n            raise ValueError(\"Leeway seconds cannot be negative\")\n        if self.leeway_seconds > 3600:  # 1 hour\n            raise ValueError(\"Leeway seconds should not exceed 3600 (1 hour)\")\n        if self.max_token_age_seconds <= 0:\n            raise ValueError(\"Max token age must be positive\")\n\ndef create_strict_context(allowed_issuers: List[str], expected_audience: str) -> ValidationContext:\n    \"\"\"Create a strict validation context with minimal leeway and all checks enabled\"\"\"\n    return ValidationContext(\n        verify_expiration=True,\n        verify_not_before=True,\n        leeway_seconds=60,  # 1 minute only\n        require_issuer=True,\n        allowed_issuers=allowed_issuers,\n        require_audience=True,\n        expected_audience=expected_audience,\n        require_iat=True\n    )\n\ndef create_permissive_context() -> ValidationContext:\n    \"\"\"Create a permissive validation context for development/testing\"\"\"\n    return ValidationContext(\n        verify_expiration=True,\n        verify_not_before=False,\n        leeway_seconds=600,  # 10 minutes\n        require_issuer=False,\n        allowed_issuers=[],\n        require_audience=False,\n        expected_audience=None,\n        require_iat=False\n    )\n\ndef create_custom_context(**kwargs) -> ValidationContext:\n    \"\"\"Create a custom validation context with specified parameters\"\"\"\n    return ValidationContext(**kwargs)\n```\n\n#### Core Logic Skeleton Code\n\n**claims_validator.py** - Main validation orchestration logic:\n\n```python\n\"\"\"\nJWT Claims Validator - Main Validation Logic\nOrchestrates all claims validation including time, identity, and custom claims\n\"\"\"\n\nfrom typing import Dict, Any\nfrom datetime import datetime\nimport json\nimport logging\n\nfrom .validation_context import ValidationContext\nfrom .validation_errors import *\nfrom .time_validation import TimeValidator\nfrom .identity_validation import IdentityValidator\nfrom .custom_claims import CustomClaimsValidator\nfrom ..core.data_model import JWTPayload\n\nlogger = logging.getLogger(__name__)\n\nclass ClaimsValidator:\n    \"\"\"Main claims validation orchestrator\"\"\"\n    \n    def __init__(self, context: ValidationContext):\n        self.context = context\n        self.time_validator = TimeValidator(context)\n        self.identity_validator = IdentityValidator(context)\n        self.custom_claims_validator = CustomClaimsValidator(context)\n    \n    def validate_claims(self, payload_dict: Dict[str, Any]) -> JWTPayload:\n        \"\"\"\n        Validate all claims in a JWT payload and return structured payload object.\n        \n        Args:\n            payload_dict: Parsed JSON payload from JWT token\n            \n        Returns:\n            JWTPayload object with validated claims\n            \n        Raises:\n            JWTValidationError: If any validation check fails\n        \"\"\"\n        logger.info(\"Starting claims validation\", extra={\"payload_keys\": list(payload_dict.keys())})\n        \n        # TODO 1: Validate temporal claims (exp, nbf, iat) using time_validator\n        # - Extract time-based claims from payload_dict\n        # - Call time_validator.validate_temporal_claims()\n        # - Handle TemporalValidationError exceptions with appropriate logging\n        \n        # TODO 2: Validate identity claims (iss, aud, sub) using identity_validator  \n        # - Extract identity claims from payload_dict\n        # - Call identity_validator.validate_identity_claims()\n        # - Handle IdentityValidationError exceptions with appropriate logging\n        \n        # TODO 3: Validate custom claims using custom_claims_validator\n        # - Extract all non-standard claims from payload_dict\n        # - Call custom_claims_validator.validate_custom_claims()\n        # - Handle CustomClaimValidationError exceptions with appropriate logging\n        \n        # TODO 4: Construct and return JWTPayload object\n        # - Create JWTPayload with validated standard claims\n        # - Include custom_claims dictionary with validated custom data\n        # - Log successful validation completion\n        \n        pass\n    \n    def _extract_standard_claims(self, payload_dict: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Extract standard JWT claims from payload dictionary\"\"\"\n        # TODO: Extract iss, sub, aud, exp, nbf, iat, jti claims\n        # Handle missing claims according to context requirements\n        # Return dictionary with standard claims only\n        pass\n    \n    def _extract_custom_claims(self, payload_dict: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Extract custom claims by filtering out standard claim names\"\"\"\n        # TODO: Create new dictionary excluding standard JWT claim names\n        # Return only application-specific custom claims\n        pass\n```\n\n**time_validation.py** - Temporal claims validation logic:\n\n```python\n\"\"\"\nTime-Based Claims Validation\nHandles exp, nbf, and iat claim validation with clock skew tolerance\n\"\"\"\n\nfrom datetime import datetime, timezone\nfrom typing import Dict, Any, Optional\nimport time\nimport logging\n\nfrom .validation_context import ValidationContext\nfrom .validation_errors import TokenExpiredError, TokenNotYetValidError, TemporalValidationError\n\nlogger = logging.getLogger(__name__)\n\nclass TimeValidator:\n    \"\"\"Validates time-based JWT claims with clock skew tolerance\"\"\"\n    \n    def __init__(self, context: ValidationContext):\n        self.context = context\n    \n    def validate_temporal_claims(self, payload_dict: Dict[str, Any]) -> None:\n        \"\"\"\n        Validate all temporal claims in the payload.\n        \n        Args:\n            payload_dict: JWT payload containing potential time claims\n            \n        Raises:\n            TemporalValidationError: If any time validation fails\n        \"\"\"\n        current_timestamp = self._get_current_timestamp()\n        \n        # TODO 1: Validate expiration claim if present and verification enabled\n        # - Extract 'exp' claim from payload_dict\n        # - Check if context.verify_expiration is True\n        # - Call _validate_expiration() with current time and claim value\n        # - Log validation results\n        \n        # TODO 2: Validate not-before claim if present and verification enabled\n        # - Extract 'nbf' claim from payload_dict  \n        # - Check if context.verify_not_before is True\n        # - Call _validate_not_before() with current time and claim value\n        # - Log validation results\n        \n        # TODO 3: Validate issued-at claim if present and required\n        # - Extract 'iat' claim from payload_dict\n        # - Check if context.require_iat is True or claim is present\n        # - Call _validate_issued_at() with current time and claim value\n        # - Log validation results\n        \n        pass\n    \n    def _validate_expiration(self, current_time: int, exp_claim: Any) -> None:\n        \"\"\"Validate expiration claim against current time with leeway\"\"\"\n        # TODO 1: Validate exp_claim is an integer timestamp\n        # TODO 2: Apply leeway period to current time for comparison\n        # TODO 3: Check if token has expired: current_time > (exp + leeway)\n        # TODO 4: Raise TokenExpiredError if validation fails\n        # TODO 5: Log successful expiration validation\n        pass\n    \n    def _validate_not_before(self, current_time: int, nbf_claim: Any) -> None:\n        \"\"\"Validate not-before claim against current time with leeway\"\"\"\n        # TODO 1: Validate nbf_claim is an integer timestamp\n        # TODO 2: Apply leeway period to current time for comparison  \n        # TODO 3: Check if token is not yet valid: current_time < (nbf - leeway)\n        # TODO 4: Raise TokenNotYetValidError if validation fails\n        # TODO 5: Log successful not-before validation\n        pass\n    \n    def _validate_issued_at(self, current_time: int, iat_claim: Any) -> None:\n        \"\"\"Validate issued-at claim for reasonable time bounds\"\"\"\n        # TODO 1: Validate iat_claim is an integer timestamp\n        # TODO 2: Check if issued-at is unreasonably far in the past\n        # TODO 3: Check if issued-at is in the future (beyond leeway)\n        # TODO 4: Warn about suspicious timestamps but don't reject\n        # TODO 5: Log issued-at validation results\n        pass\n    \n    def _get_current_timestamp(self) -> int:\n        \"\"\"Get current UTC time as Unix timestamp\"\"\"\n        return int(time.time())\n    \n    def _validate_timestamp_type(self, claim_value: Any, claim_name: str) -> int:\n        \"\"\"Validate that a claim value is a valid Unix timestamp\"\"\"\n        # TODO: Check if claim_value is numeric (int or float)\n        # TODO: Convert to integer if necessary\n        # TODO: Validate timestamp is within reasonable bounds (not negative, not too far in future)\n        # TODO: Raise TemporalValidationError for invalid timestamps\n        # TODO: Return validated integer timestamp\n        pass\n```\n\n**identity_validation.py** - Issuer and audience validation logic:\n\n```python\n\"\"\"\nIdentity Claims Validation  \nHandles iss, aud, and sub claim validation against configured allowlists\n\"\"\"\n\nfrom typing import Dict, Any, List, Union\nimport logging\n\nfrom .validation_context import ValidationContext\nfrom .validation_errors import InvalidIssuerError, InvalidAudienceError, IdentityValidationError\n\nlogger = logging.getLogger(__name__)\n\nclass IdentityValidator:\n    \"\"\"Validates identity-related JWT claims\"\"\"\n    \n    def __init__(self, context: ValidationContext):\n        self.context = context\n    \n    def validate_identity_claims(self, payload_dict: Dict[str, Any]) -> None:\n        \"\"\"\n        Validate identity claims (issuer, audience, subject).\n        \n        Args:\n            payload_dict: JWT payload containing identity claims\n            \n        Raises:\n            IdentityValidationError: If any identity validation fails\n        \"\"\"\n        # TODO 1: Validate issuer claim if required or present\n        # - Extract 'iss' claim from payload_dict\n        # - Check context.require_issuer flag\n        # - Call _validate_issuer() if validation needed\n        # - Log validation results\n        \n        # TODO 2: Validate audience claim if required or present  \n        # - Extract 'aud' claim from payload_dict\n        # - Check context.require_audience flag\n        # - Call _validate_audience() if validation needed\n        # - Log validation results\n        \n        # TODO 3: Validate subject claim if present\n        # - Extract 'sub' claim from payload_dict\n        # - Apply any configured subject validation rules\n        # - Log validation results\n        \n        pass\n    \n    def _validate_issuer(self, iss_claim: Any) -> None:\n        \"\"\"Validate issuer against allowed issuers list\"\"\"\n        # TODO 1: Validate iss_claim is a string\n        # TODO 2: Check if context.allowed_issuers is configured\n        # TODO 3: Perform exact string matching against allowed_issuers list\n        # TODO 4: Raise InvalidIssuerError if issuer not in allowlist\n        # TODO 5: Log successful issuer validation\n        pass\n    \n    def _validate_audience(self, aud_claim: Any) -> None:\n        \"\"\"Validate audience claim (string or array) against expected audience\"\"\"\n        # TODO 1: Determine if aud_claim is string or array\n        # TODO 2: Handle string audience: exact match with context.expected_audience\n        # TODO 3: Handle array audience: check if expected_audience in array\n        # TODO 4: Raise InvalidAudienceError if no audience matches\n        # TODO 5: Log successful audience validation\n        pass\n    \n    def _validate_audience_string(self, audience: str) -> bool:\n        \"\"\"Validate single audience string against expected value\"\"\"\n        # TODO: Compare audience exactly with context.expected_audience\n        # TODO: Return True if match, False otherwise\n        pass\n    \n    def _validate_audience_array(self, audiences: List[str]) -> bool:\n        \"\"\"Validate audience array contains expected audience\"\"\"\n        # TODO 1: Iterate through audience array\n        # TODO 2: Check each audience string against expected_audience\n        # TODO 3: Return True if any audience matches\n        # TODO 4: Return False if no audiences match\n        pass\n```\n\n#### Milestone Checkpoint\n\nAfter implementing the claims validation component, verify the following behavior:\n\n**Test Command**: Run the validation test suite\n```bash\npython -m pytest tests/test_validation/ -v\n```\n\n**Expected Results**:\n- All temporal validation tests pass with various exp/nbf/iat combinations\n- Issuer validation correctly accepts/rejects based on allowlist configuration  \n- Audience validation handles both string and array formats correctly\n- Custom claims validation applies configured rules appropriately\n- Clock skew handling works within configured leeway periods\n\n**Manual Verification**: Create a test script that validates tokens with different claim combinations:\n```python\n# Test temporal validation with expired token\ncontext = create_strict_context([\"trusted-issuer\"], \"my-service\")\nvalidator = ClaimsValidator(context)\n\n# This should raise TokenExpiredError\nexpired_payload = {\"exp\": int(time.time()) - 3600, \"iss\": \"trusted-issuer\", \"aud\": \"my-service\"}\ntry:\n    validator.validate_claims(expired_payload)\n    print(\"ERROR: Should have rejected expired token\")\nexcept TokenExpiredError:\n    print(\"SUCCESS: Correctly rejected expired token\")\n```\n\n**Signs of Problems**:\n- Tokens with valid exp times are rejected → Check clock skew handling\n- Invalid issuers are accepted → Check allowlist configuration and string matching\n- Array audiences fail validation → Check audience array handling logic\n- Custom claims validation errors → Check claim extraction and type validation\n\n\n## Component Interactions and Data Flow\n\n> **Milestone(s):** All three milestones - demonstrates how token encoding (Milestone 1), HMAC signing (Milestone 2), and claims validation (Milestone 3) work together in complete token creation and verification workflows\n\nThe JWT library's three main components—Token Encoding, Cryptographic Signing, and Claims Validation—operate as an orchestrated system where data flows through carefully designed interfaces to ensure both security and correctness. Understanding how these components interact is crucial for implementing a robust JWT library that properly handles the complete lifecycle of token creation and verification.\n\n### Mental Model: The Document Authentication Office\n\nThink of JWT token processing like a government document authentication office with three specialized departments working in sequence. The **Preparation Department** (Token Encoding) formats documents into standardized forms with proper headers and content sections, ensuring everything follows official formatting rules. The **Seal Department** (Cryptographic Signing) applies tamper-evident seals using specialized equipment and secret stamps that prove the document's authenticity. Finally, the **Verification Department** (Claims Validation) inspects incoming documents, checking seals for authenticity, verifying expiration dates, confirming the issuing authority is authorized, and ensuring the document is intended for the right recipient.\n\nJust as these departments must coordinate carefully—with documents flowing in a specific order and each department trusting that previous departments completed their work correctly—our JWT components must interact through well-defined interfaces with clear error handling and data transformation contracts.\n\n![JWT Library Component Architecture](./diagrams/component-architecture.svg)\n\nThe architecture establishes clear separation of concerns where each component has distinct responsibilities while maintaining loose coupling through standardized data structures. The Token Encoding Component transforms structured data into standardized JWT format, the Cryptographic Signing Component adds and verifies cryptographic authenticity proofs, and the Claims Validation Component enforces business logic and security policies.\n\n### Token Creation Sequence\n\nThe token creation process follows a carefully orchestrated sequence where data flows through multiple transformation stages, with each component adding its specialized processing while maintaining the integrity of previous work.\n\n![Token Creation Sequence](./diagrams/token-creation-sequence.svg)\n\nThe token creation workflow begins when the application provides header metadata and payload claims, then progresses through encoding, signing, and assembly phases to produce a complete JWT token ready for transmission.\n\n#### Step-by-Step Creation Process\n\nThe token creation sequence follows these detailed steps, with each stage building upon the previous stage's output:\n\n1. **Input Validation and Preparation**: The `create_token` function receives a `JWTHeader` containing algorithm and type specifications, a `JWTPayload` with claims data, and a secret key for signing. The function first validates that required header fields (`alg` and `typ`) are present and that the algorithm matches the intended signer capability.\n\n2. **Header Serialization**: The `serialize_header` function converts the `JWTHeader` structure into canonical JSON format, ensuring consistent field ordering and proper escaping of special characters. The JSON serialization must be deterministic to ensure identical headers produce identical signatures across different library instances.\n\n3. **Payload Serialization**: The `serialize_payload` function transforms the `JWTPayload` into JSON format, handling both registered claims (iss, sub, aud, exp, nbf, iat, jti) and custom claims from the `custom_claims` dictionary. Special attention is paid to numeric timestamp formatting and array handling for audience claims that may contain multiple values.\n\n4. **Base64URL Encoding**: The `encode_token_parts` function applies Base64URL encoding to both serialized JSON strings, converting them to URL-safe representations without padding characters. This encoding must handle Unicode characters properly and ensure the output contains only characters valid in URLs and HTTP headers.\n\n5. **Signing Input Creation**: The `create_signing_input` function concatenates the encoded header and payload with a dot separator, creating the exact string that will be cryptographically signed. This signing input represents the immutable content that the signature will protect against tampering.\n\n6. **Signature Generation**: The HMAC signing component's `sign` function computes the HMAC-SHA256 signature over the signing input using the provided secret key. The raw signature bytes are then Base64URL encoded to create the final signature segment.\n\n7. **Token Assembly**: The `assemble_token` function combines the encoded header, encoded payload, and encoded signature with dot separators to create the final JWT token in the standard three-part format: `header.payload.signature`.\n\n8. **Final Validation**: Before returning the token, the creation process performs a self-verification step by parsing and validating the just-created token to ensure the creation process worked correctly and the token is well-formed.\n\nThe following table details the data transformations at each stage:\n\n| Stage | Input Type | Output Type | Transformation | Error Conditions |\n|-------|-----------|-------------|---------------|------------------|\n| Input Validation | `JWTHeader`, `JWTPayload`, `bytes` | Validated inputs | Structure validation, key strength check | Missing required fields, weak keys |\n| Header Serialization | `JWTHeader` | `str` (JSON) | Object to canonical JSON | JSON encoding errors, invalid characters |\n| Payload Serialization | `JWTPayload` | `str` (JSON) | Object to canonical JSON with timestamp handling | Invalid timestamps, encoding errors |\n| Base64URL Encoding | `str` (JSON) | `str` (Base64URL) | UTF-8 bytes to URL-safe Base64 | Character encoding errors |\n| Signing Input Creation | `str`, `str` | `str` | Concatenation with dot separator | String handling errors |\n| Signature Generation | `str`, `bytes` | `str` (Base64URL) | HMAC-SHA256 computation and encoding | Key errors, cryptographic failures |\n| Token Assembly | `str`, `str`, `str` | `str` | Three-part concatenation | String manipulation errors |\n| Final Validation | `str` | `str` | Parse and verify created token | Self-verification failures |\n\n#### Error Propagation in Token Creation\n\nError handling during token creation follows a fail-fast principle where any component failure immediately terminates the creation process and propagates a descriptive error to the caller. Each component validates its inputs and provides specific error messages that help developers diagnose problems quickly.\n\nThe Token Encoding Component raises encoding-specific exceptions when JSON serialization fails or Base64URL encoding encounters invalid characters. The Cryptographic Signing Component raises key-related exceptions for insufficient key strength or HMAC computation failures. The overall creation process wraps these component-specific errors in a general token creation error that preserves the underlying cause while providing context about which creation stage failed.\n\n> **Design Insight**: The token creation sequence is designed to be atomic—either a complete, valid token is produced, or the operation fails entirely with no partial state. This prevents the library from returning malformed tokens that could cause security issues or interoperability problems with other JWT implementations.\n\n### Token Verification Sequence\n\nToken verification represents a more complex workflow than creation because it must handle potentially malicious input while performing comprehensive validation across multiple security dimensions. The verification process assumes the input token is untrusted and validates every aspect before returning payload data to the application.\n\n![Token Verification Sequence](./diagrams/token-verification-sequence.svg)\n\nThe verification workflow begins with token parsing and structural validation, then proceeds through cryptographic verification and comprehensive claims validation before returning the validated payload to the application.\n\n#### Step-by-Step Verification Process\n\nThe token verification sequence implements defense-in-depth validation with these detailed steps:\n\n1. **Token Structure Parsing**: The `verify_token` function receives a token string and immediately validates its basic structure by splitting on dot separators and ensuring exactly three parts are present. Malformed tokens with incorrect part counts are rejected immediately without further processing.\n\n2. **Base64URL Decoding**: Each token part undergoes Base64URL decoding with proper padding restoration. The decoding process validates that each part contains only valid Base64URL characters and handles padding edge cases correctly. Invalid encoding triggers immediate rejection.\n\n3. **JSON Deserialization**: The decoded header and payload undergo JSON parsing with strict validation. The header must contain valid `alg` and `typ` fields with expected values. The payload is parsed into a dictionary structure for subsequent claims validation.\n\n4. **Algorithm Verification**: The parsed header's algorithm field is validated against the expected algorithm (HS256) to prevent algorithm confusion attacks where attackers attempt to trick the verifier into using a different cryptographic algorithm with known weaknesses.\n\n5. **Signature Verification**: The cryptographic signing component reconstructs the signing input from the parsed header and payload, then verifies the provided signature using constant-time comparison. Signature verification failure results in immediate token rejection.\n\n6. **Temporal Claims Validation**: The claims validation component checks time-based claims (exp, nbf, iat) against the current time with configurable leeway for clock skew. Expired tokens or tokens not yet valid are rejected with specific error messages indicating the temporal validation failure.\n\n7. **Identity Claims Validation**: The issuer (iss) and audience (aud) claims are validated against the configured validation context. The issuer must appear in the allowed issuers list, and the audience must match the expected audience identifier. Missing required identity claims trigger validation failures.\n\n8. **Custom Claims Processing**: Application-specific claims undergo validation according to the validation context configuration. Required custom claims are checked for presence, and custom validation logic can be applied to verify claim values meet application requirements.\n\n9. **Payload Construction and Return**: After all validation passes, the verification process constructs a validated `JWTPayload` object containing all claims and returns it to the application. The returned payload represents trusted, verified data that the application can use for authorization decisions.\n\nThe verification process uses strict validation by default but allows customization through the `ValidationContext` parameter:\n\n| Validation Type | Default Behavior | Customizable Aspects | Security Impact |\n|----------------|------------------|---------------------|-----------------|\n| Signature Verification | Always enabled | Cannot be disabled | Critical - prevents token tampering |\n| Expiration Check | Enabled with 5min leeway | Leeway duration, enable/disable | High - prevents replay of old tokens |\n| Not-Before Check | Enabled with same leeway | Leeway duration, enable/disable | Medium - prevents premature token use |\n| Issuer Validation | Strict allowlist checking | Allowed issuers list, required flag | High - prevents token forgery |\n| Audience Validation | Exact match required | Expected audience, required flag | Medium - prevents token misuse |\n| Custom Claims | Application-defined | Required claims list, custom validators | Variable - depends on application needs |\n\n#### Validation Context Configuration\n\nThe `ValidationContext` provides flexible control over verification strictness while maintaining security defaults. Applications can create contexts optimized for their specific security requirements:\n\n**Strict Validation Context**: Used in production environments where security is paramount. All validations are enabled with minimal leeway periods, strict issuer allowlists, and required audience checking.\n\n**Development Validation Context**: Provides relaxed validation for testing environments with extended leeway periods and optional claims validation, while still maintaining signature verification for basic security.\n\n**Custom Validation Context**: Allows fine-grained control over each validation aspect, enabling applications to implement domain-specific security policies while leveraging the library's validation infrastructure.\n\n> **Security Principle**: The verification sequence implements a \"fail-secure\" design where any validation failure results in complete token rejection. There are no warnings or partial validation states—tokens are either fully valid and trusted or completely rejected.\n\n### Error Handling Flow\n\nError handling in the JWT library follows a structured approach where errors are classified by type, carry sufficient context for debugging, and flow through the component hierarchy in a predictable manner. The error handling system balances security concerns (avoiding information leakage to attackers) with developer usability (providing actionable diagnostic information).\n\n#### Error Classification and Hierarchy\n\nThe library defines a comprehensive error hierarchy that enables precise error handling while maintaining clear separation between different failure modes:\n\n```\nJWTValidationError (base class)\n├── StructuralError (token format problems)\n│   ├── MalformedTokenError (invalid token structure)\n│   ├── EncodingError (Base64URL/JSON encoding issues)\n│   └── AlgorithmMismatchError (algorithm confusion prevention)\n├── CryptographicError (signature and key issues)\n│   ├── SignatureVerificationError (signature validation failures)\n│   ├── WeakKeyError (insufficient key strength)\n│   └── KeyHandlingError (key format or access problems)\n├── TemporalValidationError (time-based validation failures)\n│   ├── TokenExpiredError (exp claim validation)\n│   ├── TokenNotYetValidError (nbf claim validation)\n│   └── InvalidIssuedAtError (iat claim validation)\n├── IdentityValidationError (issuer and audience problems)\n│   ├── InvalidIssuerError (iss claim validation)\n│   ├── InvalidAudienceError (aud claim validation)\n│   └── UnauthorizedIssuerError (issuer not in allowlist)\n└── CustomClaimValidationError (application-specific failures)\n    ├── MissingRequiredClaimError (required claims absent)\n    ├── InvalidClaimValueError (claim value validation)\n    └── ClaimTypeError (unexpected claim data types)\n```\n\nEach error class carries specific context information relevant to its failure mode while inheriting common fields from the base `JWTValidationError` class.\n\n#### Error Context and Information Flow\n\nErrors flow through the component hierarchy with increasing context as they move from low-level components to the public API. Each component adds relevant diagnostic information while preserving the original error cause:\n\n| Error Source | Context Added | Information Included | Security Considerations |\n|-------------|---------------|---------------------|------------------------|\n| Token Encoding | Structural validation context | Token part that failed, encoding stage | Safe - no sensitive data exposure |\n| Cryptographic Signing | Signature verification details | Algorithm used, key validation status | Careful - avoid key material leakage |\n| Claims Validation | Claim-specific validation context | Claim name, expected vs actual values | Moderate - balance debugging vs info leakage |\n| Public API | Operation context | Function called, validation context used | Safe - high-level operation information |\n\nThe error handling system implements different information disclosure levels based on the deployment context:\n\n**Development Mode**: Provides detailed error messages including actual claim values, expected values, and specific validation failures. This mode helps developers debug integration issues quickly but should never be used in production.\n\n**Production Mode**: Provides general error categories without exposing sensitive details that could help attackers. Error messages indicate the type of validation failure without revealing specific claim values or validation logic details.\n\n**Audit Mode**: Logs detailed error information to secure audit logs while returning generic error messages to callers. This provides forensic capabilities for security teams while protecting against information disclosure.\n\n#### Component Error Handling Patterns\n\nEach component implements consistent error handling patterns that ensure predictable behavior across the library:\n\n**Token Encoding Component**: Validates input structure and encoding constraints, raising `StructuralError` subclasses for format violations. Encoding errors include sufficient context to identify the problematic data without exposing sensitive payload contents.\n\n**Cryptographic Signing Component**: Implements secure error handling that avoids timing side channels and information leakage about key material. All signature verification failures result in the same generic `SignatureVerificationError` regardless of the specific failure mode.\n\n**Claims Validation Component**: Provides detailed validation context while respecting security boundaries. Temporal validation errors include information about which time-based claim failed and the general nature of the violation (expired vs not-yet-valid) without exposing exact timestamps that might reveal clock information.\n\n#### Error Recovery and Fallback Strategies\n\nThe JWT library implements limited error recovery focused on handling common edge cases without compromising security:\n\n**Clock Skew Tolerance**: Temporal validation includes configurable leeway periods that automatically handle reasonable clock differences between token issuers and verifiers. This prevents legitimate tokens from being rejected due to minor time synchronization issues.\n\n**Encoding Robustness**: Base64URL decoding includes automatic padding restoration to handle tokens that may have been truncated or modified during transmission through systems that don't properly handle URL-safe encoding.\n\n**Graceful Degradation**: When optional validation features fail (such as custom claim validation), the library continues with core security validation while logging the optional validation failure. This prevents auxiliary validation logic from breaking core authentication functionality.\n\n> **Security Boundary**: Error handling never attempts to \"fix\" security-critical validation failures. Signature verification failures, algorithm mismatches, and expired tokens always result in complete rejection with no recovery attempts, as any \"fix\" would compromise the fundamental security guarantees JWT provides.\n\n### Implementation Guidance\n\nThe component interactions require careful orchestration to ensure data flows correctly between encoding, signing, and validation while maintaining security properties and error handling consistency.\n\n#### Technology Recommendations\n\n| Component Integration | Simple Approach | Advanced Approach |\n|----------------------|-----------------|-------------------|\n| Error Handling | Custom exception hierarchy with string messages | Structured error objects with error codes and context data |\n| State Management | Stateless functions with parameter passing | Context objects that carry state through the pipeline |\n| Logging Integration | Print statements for debugging | Structured logging with security-aware log levels |\n| Performance Monitoring | Simple timing measurements | Comprehensive metrics with component-level breakdowns |\n\n#### Recommended Module Structure\n\nThe component interactions are best organized with a facade pattern that provides simple public interfaces while managing complex component coordination internally:\n\n```\njwt_library/\n├── core/\n│   ├── __init__.py              ← Public API facade\n│   ├── token_manager.py         ← High-level token operations\n│   └── validation_context.py    ← Validation configuration\n├── encoding/\n│   ├── encoder.py               ← Token encoding component\n│   └── base64url.py             ← Base64URL utilities\n├── signing/\n│   ├── hmac_signer.py           ← HMAC-SHA256 implementation\n│   └── key_handler.py           ← Secret key management\n├── validation/\n│   ├── claims_validator.py      ← Main validation orchestrator\n│   ├── temporal_validator.py    ← Time-based claim validation\n│   └── identity_validator.py    ← Issuer and audience validation\n└── errors/\n    ├── __init__.py              ← Error hierarchy exports\n    ├── base_errors.py           ← Base error classes\n    ├── validation_errors.py     ← Validation-specific errors\n    └── error_context.py         ← Error context utilities\n```\n\n#### Complete Token Manager Implementation\n\n```python\n\"\"\"\nHigh-level token management facade that coordinates component interactions.\nThis module provides the main public API for token creation and verification.\n\"\"\"\n\nfrom datetime import datetime, timezone\nfrom typing import Dict, Any, Optional, List, Union\nimport json\nimport secrets\n\nfrom .encoding.encoder import TokenEncoder\nfrom .encoding.base64url import base64url_encode, base64url_decode\nfrom .signing.hmac_signer import HMACSignerHS256\nfrom .signing.key_handler import SecureKeyHandler\nfrom .validation.claims_validator import ClaimsValidator\nfrom .validation_context import ValidationContext\nfrom .errors import JWTValidationError, StructuralError, MalformedTokenError\n\n# Standard JWT constants\nHS256 = \"HS256\"\nJWT = \"JWT\"\nDEFAULT_LEEWAY_SECONDS = 300\nMIN_KEY_LENGTH = 32\n\nclass JWTTokenManager:\n    \"\"\"\n    High-level facade for JWT token operations that coordinates between\n    encoding, signing, and validation components.\n    \"\"\"\n    \n    def __init__(self, secret_key: bytes):\n        self.key_handler = SecureKeyHandler()\n        self.key_handler.validate_key_strength(secret_key)\n        self._secret_key = secret_key\n        \n        self.encoder = TokenEncoder()\n        self.signer = HMACSignerHS256(secret_key)\n        self.validator = ClaimsValidator()\n    \n    def create_token(self, header: 'JWTHeader', payload: 'JWTPayload') -> str:\n        \"\"\"\n        Create a signed JWT token from header and payload components.\n        Coordinates the complete token creation workflow.\n        \"\"\"\n        # TODO: Validate header contains required alg and typ fields\n        # TODO: Ensure algorithm matches signer capability (HS256)\n        # TODO: Serialize header and payload to canonical JSON\n        # TODO: Apply Base64URL encoding to both JSON strings\n        # TODO: Create signing input by concatenating encoded parts\n        # TODO: Generate HMAC-SHA256 signature over signing input\n        # TODO: Assemble final token in header.payload.signature format\n        # TODO: Perform self-verification to ensure token is well-formed\n        pass\n    \n    def verify_token(self, token: str, context: ValidationContext) -> 'JWTPayload':\n        \"\"\"\n        Verify a JWT token and return validated payload if all checks pass.\n        Implements comprehensive validation with configurable strictness.\n        \"\"\"\n        # TODO: Parse token structure and validate three-part format\n        # TODO: Decode each part from Base64URL with padding restoration\n        # TODO: Deserialize header and payload JSON with error handling\n        # TODO: Verify algorithm matches expected value (prevent confusion attacks)\n        # TODO: Verify signature using constant-time comparison\n        # TODO: Validate temporal claims (exp, nbf, iat) with leeway\n        # TODO: Validate identity claims (iss, aud) against context\n        # TODO: Process custom claims according to validation rules\n        # TODO: Construct and return validated JWTPayload object\n        pass\n\ndef create_token(header: 'JWTHeader', payload: 'JWTPayload', secret_key: bytes) -> str:\n    \"\"\"\n    Convenience function for creating tokens without managing a TokenManager instance.\n    \"\"\"\n    manager = JWTTokenManager(secret_key)\n    return manager.create_token(header, payload)\n\ndef verify_token(token: str, secret_key: bytes, context: ValidationContext) -> 'JWTPayload':\n    \"\"\"\n    Convenience function for verifying tokens without managing a TokenManager instance.\n    \"\"\"\n    manager = JWTTokenManager(secret_key)\n    return manager.verify_token(token, context)\n```\n\n#### Error Context Infrastructure\n\n```python\n\"\"\"\nError context management for tracking validation failures across components.\nProvides structured error information while respecting security boundaries.\n\"\"\"\n\nfrom typing import Dict, Any, Optional, List\nfrom enum import Enum\nfrom dataclasses import dataclass\n\nclass ErrorSeverity(Enum):\n    \"\"\"Classification of error severity levels for logging and handling.\"\"\"\n    CRITICAL = \"critical\"      # Security violations, signature failures\n    HIGH = \"high\"              # Expired tokens, invalid issuers\n    MEDIUM = \"medium\"          # Missing optional claims, format issues\n    LOW = \"low\"                # Clock skew warnings, encoding edge cases\n\nclass SecurityContext(Enum):\n    \"\"\"Deployment context that determines error information disclosure.\"\"\"\n    DEVELOPMENT = \"development\"  # Full error details for debugging\n    PRODUCTION = \"production\"    # Generic error messages for security\n    AUDIT = \"audit\"              # Detailed logging, generic responses\n\n@dataclass\nclass ValidationFailureContext:\n    \"\"\"\n    Structured context for validation failures that provides debugging\n    information while respecting security boundaries.\n    \"\"\"\n    component: str                    # Component that detected the failure\n    operation: str                    # Specific operation that failed\n    failure_type: str                 # Category of validation failure\n    severity: ErrorSeverity           # Impact level of the failure\n    debug_info: Dict[str, Any]        # Detailed context for development\n    safe_message: str                 # Production-safe error description\n    \n    def get_message(self, context: SecurityContext) -> str:\n        \"\"\"Return appropriate error message based on security context.\"\"\"\n        if context == SecurityContext.DEVELOPMENT:\n            return f\"{self.failure_type}: {self.debug_info}\"\n        elif context == SecurityContext.PRODUCTION:\n            return self.safe_message\n        else:  # AUDIT\n            # Log detailed info, return generic message\n            return self.safe_message\n\nclass ErrorContextManager:\n    \"\"\"\n    Manages error context propagation through component interactions.\n    \"\"\"\n    \n    def __init__(self, security_context: SecurityContext = SecurityContext.PRODUCTION):\n        self.security_context = security_context\n        self.error_history: List[ValidationFailureContext] = []\n    \n    def add_failure(self, context: ValidationFailureContext):\n        \"\"\"Add a validation failure to the error history.\"\"\"\n        self.error_history.append(context)\n    \n    def create_summary_error(self, primary_failure: str) -> str:\n        \"\"\"\n        Create a summary error message that respects security boundaries\n        while providing useful debugging information.\n        \"\"\"\n        if not self.error_history:\n            return \"Token validation failed\"\n        \n        primary = self.error_history[0]\n        return primary.get_message(self.security_context)\n```\n\n#### Component Integration Helpers\n\n```python\n\"\"\"\nUtility functions for coordinating data flow between JWT components.\n\"\"\"\n\nfrom typing import Tuple, Dict, Any\nimport json\n\ndef serialize_header(header: 'JWTHeader') -> str:\n    \"\"\"\n    Serialize JWT header to canonical JSON format.\n    Ensures consistent field ordering for signature generation.\n    \"\"\"\n    # TODO: Convert header object to dictionary with required fields\n    # TODO: Apply deterministic JSON serialization with sorted keys\n    # TODO: Handle special characters and Unicode properly\n    # Hint: Use json.dumps with sort_keys=True and separators=(',', ':')\n    pass\n\ndef serialize_payload(payload: 'JWTPayload') -> str:\n    \"\"\"\n    Serialize JWT payload to canonical JSON format.\n    Handles registered claims and custom claims properly.\n    \"\"\"\n    # TODO: Extract registered claims (iss, sub, aud, exp, nbf, iat, jti)\n    # TODO: Add custom claims from custom_claims dictionary\n    # TODO: Handle audience claim as either string or array\n    # TODO: Ensure timestamp claims are integers (not floats)\n    # TODO: Apply deterministic JSON serialization\n    pass\n\ndef encode_token_parts(header: 'JWTHeader', payload: 'JWTPayload') -> Tuple[str, str]:\n    \"\"\"\n    Encode header and payload to Base64URL format for token assembly.\n    \"\"\"\n    header_json = serialize_header(header)\n    payload_json = serialize_payload(payload)\n    \n    encoded_header = base64url_encode(header_json.encode('utf-8'))\n    encoded_payload = base64url_encode(payload_json.encode('utf-8'))\n    \n    return encoded_header, encoded_payload\n\ndef create_signing_input(encoded_header: str, encoded_payload: str) -> str:\n    \"\"\"\n    Create the signing input string from encoded header and payload.\n    This is the exact string that gets cryptographically signed.\n    \"\"\"\n    return f\"{encoded_header}.{encoded_payload}\"\n\ndef assemble_token(encoded_header: str, encoded_payload: str, signature: str) -> str:\n    \"\"\"\n    Assemble the final JWT token from all three encoded parts.\n    \"\"\"\n    return f\"{encoded_header}.{encoded_payload}.{signature}\"\n\ndef parse_token_structure(token: str) -> Tuple[str, str, str]:\n    \"\"\"\n    Parse JWT token structure and return the three parts.\n    Validates basic structure before returning components.\n    \"\"\"\n    parts = token.split('.')\n    if len(parts) != 3:\n        raise MalformedTokenError(f\"JWT must have exactly 3 parts, got {len(parts)}\")\n    \n    header_part, payload_part, signature_part = parts\n    \n    # Validate that no parts are empty\n    if not all(parts):\n        raise MalformedTokenError(\"JWT parts cannot be empty\")\n    \n    return header_part, payload_part, signature_part\n```\n\n#### Milestone Checkpoints\n\n**After Milestone 1 (JWT Structure)**:\nRun the following test to verify token encoding works correctly:\n```python\nfrom jwt_library.core import create_token\nfrom jwt_library.data_model import JWTHeader, JWTPayload\n\nheader = JWTHeader(alg=\"HS256\", typ=\"JWT\")\npayload = JWTPayload(\n    iss=\"test-issuer\",\n    sub=\"user123\",\n    aud=\"test-audience\",\n    exp=1234567890,\n    iat=1234567800\n)\nsecret_key = b\"test-secret-key-32-bytes-long-123\"\n\ntoken = create_token(header, payload, secret_key)\nprint(f\"Created token: {token}\")\n# Should see: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJ0ZXN0LWlzc3VlciIsInN1YiI6InVzZXIxMjMiLCJhdWQiOiJ0ZXN0LWF1ZGllbmNlIiwiZXhwIjoxMjM0NTY3ODkwLCJpYXQiOjEyMzQ1Njc4MDB9.signature\n```\n\n**After Milestone 2 (HMAC Signing)**:\nVerify signature generation and verification:\n```python\n# Create a token and verify it immediately\ntoken = create_token(header, payload, secret_key)\ncontext = ValidationContext(verify_signature=True, verify_expiration=False)\nverified_payload = verify_token(token, secret_key, context)\nprint(f\"Verified payload: {verified_payload.iss}\")\n# Should print: test-issuer\n\n# Test signature tampering detection\ntampered_token = token[:-5] + \"XXXXX\"  # Corrupt signature\ntry:\n    verify_token(tampered_token, secret_key, context)\n    print(\"ERROR: Tampered token should have failed!\")\nexcept JWTValidationError:\n    print(\"SUCCESS: Tampered token correctly rejected\")\n```\n\n**After Milestone 3 (Claims Validation)**:\nTest comprehensive claims validation:\n```python\nfrom datetime import datetime, timezone\n\n# Test expired token rejection\nexpired_payload = JWTPayload(\n    iss=\"test-issuer\",\n    sub=\"user123\", \n    aud=\"test-audience\",\n    exp=int(datetime(2020, 1, 1, tzinfo=timezone.utc).timestamp()),\n    iat=int(datetime(2020, 1, 1, tzinfo=timezone.utc).timestamp())\n)\nexpired_token = create_token(header, expired_payload, secret_key)\nstrict_context = ValidationContext(verify_expiration=True)\n\ntry:\n    verify_token(expired_token, secret_key, strict_context)\n    print(\"ERROR: Expired token should have failed!\")\nexcept TokenExpiredError:\n    print(\"SUCCESS: Expired token correctly rejected\")\n```\n\n#### Debugging Component Interactions\n\n| Symptom | Likely Cause | Diagnosis Steps | Fix |\n|---------|-------------|----------------|-----|\n| Token creation succeeds but verification fails | Component coordination issue | Print intermediate values at each stage | Check that encoding/decoding is symmetric |\n| Signatures don't match between creation and verification | Inconsistent JSON serialization | Compare signing input strings | Ensure deterministic JSON with sorted keys |\n| Claims validation passes individually but fails in integration | Validation context not passed correctly | Check ValidationContext propagation | Verify context parameter threading |\n| Performance degradation with multiple components | Inefficient component initialization | Profile component creation vs usage | Cache component instances, avoid recreation |\n| Error messages are unclear about which component failed | Poor error context propagation | Add logging at component boundaries | Implement structured error context with component info |\n\n\n## Error Handling and Edge Cases\n\n> **Milestone(s):** All three milestones - error handling for JWT structure (Milestone 1), HMAC signing failures (Milestone 2), and claims validation issues (Milestone 3)\n\nRobust error handling represents the difference between a toy JWT library and production-ready authentication infrastructure. While the happy path of token creation and verification appears straightforward, real-world JWT implementations must gracefully handle dozens of failure modes ranging from malformed input to sophisticated timing attacks. This section establishes a comprehensive error handling strategy that maintains security properties while providing actionable diagnostic information to developers.\n\nThe challenge lies in balancing security with usability. Security demands that error messages reveal minimal information to potential attackers - we cannot distinguish between \"token expired\" and \"invalid signature\" in ways that enable oracle attacks. Usability demands clear diagnostic information that helps developers identify and fix integration issues quickly. Our error handling design resolves this tension through structured error contexts that provide detailed information in development environments while maintaining secure, generic messages in production deployments.\n\n![Token Validation State Machine](./diagrams/validation-state-machine.svg)\n\n### Error Classification\n\nModern JWT libraries must handle errors across multiple dimensions: structural integrity, cryptographic validity, temporal constraints, and business logic requirements. Each category demands different handling strategies because the underlying failure modes represent fundamentally different security and usability concerns.\n\nOur error classification system organizes failures into a hierarchy that enables appropriate response strategies while maintaining clear diagnostic boundaries. The classification considers both the technical nature of the failure and the appropriate security response, ensuring that sensitive operations fail securely while providing maximum utility for legitimate debugging scenarios.\n\n> **Decision: Hierarchical Error Classification**\n> - **Context**: JWT validation involves multiple validation stages, each with distinct failure modes and security implications\n> - **Options Considered**: Flat error codes, exception hierarchy, structured error contexts\n> - **Decision**: Implement structured error contexts with severity levels and component attribution\n> - **Rationale**: Enables appropriate security responses while maintaining diagnostic utility across development and production environments\n> - **Consequences**: More complex error handling implementation but significantly better operational visibility and security posture\n\nThe error severity system provides clear guidance for application-level response strategies. Critical errors indicate potential security attacks and should trigger additional monitoring or defensive measures. High severity errors represent clear validation failures that should be logged and monitored for patterns. Medium severity errors indicate configuration or integration issues that require attention but pose minimal security risk. Low severity errors represent edge cases or warnings that applications can safely ignore in most scenarios.\n\n| Error Category | Examples | Security Risk | Response Strategy |\n|---|---|---|---|\n| **Structural** | Malformed tokens, invalid Base64URL, missing parts | Medium | Parse failure, clear diagnostic |\n| **Cryptographic** | Signature mismatch, algorithm confusion, key issues | Critical | Silent failure, security logging |\n| **Temporal** | Expiration, not-before, clock skew | High | Time-based rejection, leeway handling |\n| **Claims** | Missing required claims, invalid values, audience mismatch | Medium | Business logic failure, audit logging |\n\n| Severity Level | Description | Example Scenarios | Recommended Action |\n|---|---|---|---|\n| **CRITICAL** | Potential security attack or compromise | Signature tampering, algorithm downgrade | Silent failure, security alerting |\n| **HIGH** | Clear validation failure | Token expiration, invalid issuer | Rejection with generic message |\n| **MEDIUM** | Configuration or integration issue | Missing optional claims, format warnings | Detailed diagnostic in development |\n| **LOW** | Edge cases or informational | Clock skew warnings, unused claims | Logging only, continue processing |\n\nThe security context system adapts error handling behavior based on deployment environment. Development contexts provide maximum diagnostic information to accelerate debugging and integration. Production contexts prioritize security by minimizing information disclosure while maintaining sufficient logging for operational visibility. Audit contexts enhance logging and monitoring for compliance-sensitive deployments.\n\n| Security Context | Error Detail Level | Diagnostic Information | Logging Behavior |\n|---|---|---|---|\n| **DEVELOPMENT** | Full diagnostic details | Stack traces, intermediate values, timing information | Console output, detailed file logging |\n| **PRODUCTION** | Generic error messages | Component and operation only | Structured logging, security alerts |\n| **AUDIT** | Minimal error details | Sanitized diagnostic context | Enhanced audit trails, compliance logging |\n\n### Malformed Token Handling\n\nMalformed tokens represent the first line of defense in JWT validation, catching structural issues before they reach cryptographic or business logic validation. The challenge lies in distinguishing between innocent formatting errors and potential attack payloads while providing useful diagnostic information for legitimate integration scenarios.\n\nThink of malformed token handling as airport security screening - we need to quickly identify obviously problematic items without creating unnecessary delays for legitimate travelers. Just as security screeners follow standardized procedures to handle suspicious items consistently, our malformed token handler applies systematic validation rules to catch structural problems early in the validation pipeline.\n\nThe token structure validation process follows a fail-fast approach that immediately rejects tokens with obvious structural problems. This approach provides several security benefits: it prevents resource exhaustion attacks that might exploit expensive cryptographic operations, it provides clear diagnostic information for integration issues, and it establishes a clean boundary between structural and semantic validation concerns.\n\n| Validation Stage | Check Description | Failure Type | Recovery Action |\n|---|---|---|---|\n| **Initial Format** | Contains exactly two dots, three non-empty parts | `MalformedTokenError` | Immediate rejection with format diagnostic |\n| **Base64URL Validity** | Each part contains valid Base64URL characters | `StructuralError` | Report invalid characters and position |\n| **JSON Structure** | Header and payload decode to valid JSON objects | `StructuralError` | Report JSON parsing error with component |\n| **Required Fields** | Header contains `alg` and `typ`, payload has structure | `MissingRequiredClaimError` | List missing required fields |\n\nThe Base64URL validation process requires particular attention because standard Base64 libraries often accept invalid padding or non-URL-safe characters without errors. Our validation explicitly checks for URL-safe character sets and proper padding removal, ensuring that tokens conform strictly to the JWT specification.\n\n> **Decision: Strict Base64URL Validation**\n> - **Context**: Standard Base64 libraries may accept malformed padding or non-URL-safe characters\n> - **Options Considered**: Lenient parsing, strict validation, automatic correction\n> - **Decision**: Implement strict validation with clear error reporting for invalid characters\n> - **Rationale**: Prevents subtle interoperability issues and potential security bypasses through encoding manipulation\n> - **Consequences**: More restrictive than some implementations but ensures specification compliance and predictable behavior\n\nJSON structure validation must handle edge cases like deeply nested objects, extremely large payloads, and non-standard number representations. The validation process establishes reasonable limits on JSON complexity while providing clear diagnostic information when these limits are exceeded.\n\n| JSON Issue | Detection Method | Error Response | Diagnostic Information |\n|---|---|---|---|\n| **Invalid Syntax** | JSON parser exception | `StructuralError` with position | Line and character position of syntax error |\n| **Oversized Payload** | Length check before parsing | `StructuralError` with size | Actual size vs. maximum allowed size |\n| **Type Mismatch** | Field type validation after parsing | `StructuralError` with field | Expected vs. actual type for specific field |\n| **Encoding Issues** | UTF-8 validation during parsing | `StructuralError` with encoding | Character position and encoding problem |\n\n⚠️ **Pitfall: Accepting Malformed Base64URL**\nMany developers use standard Base64 libraries that silently accept padding characters or non-URL-safe characters in JWT tokens. This creates interoperability issues and potential security bypasses. Always validate that Base64URL input contains only URL-safe characters (A-Z, a-z, 0-9, -, _) with no padding characters (=). Implement explicit character set validation before attempting to decode.\n\n### Cryptographic Error Handling\n\nCryptographic errors represent the most security-sensitive category of JWT validation failures. These errors often indicate active attacks or system compromise, requiring careful handling that provides minimal information to attackers while maintaining sufficient diagnostic capability for legitimate operations.\n\nConsider cryptographic error handling as handling suspicious packages at a secure facility. Security personnel cannot reveal specific detection methods or failure reasons to unauthorized individuals, but they must maintain detailed internal logs for investigation and provide appropriate notifications to authorized personnel. Our cryptographic error handling follows similar principles - silent failure for external observers with comprehensive logging for authorized diagnostic access.\n\nThe signature verification process presents unique challenges because timing differences in error handling can reveal information about the validity of different token components. Constant-time comparison prevents timing attacks, but the broader error handling system must also avoid timing side channels through different code paths for different error types.\n\n> **Decision: Uniform Cryptographic Error Response**\n> - **Context**: Different cryptographic failure modes might reveal information through timing or error message differences\n> - **Options Considered**: Specific error messages, generic responses, silent failure with logging\n> - **Decision**: Return generic failure with detailed logging in security context\n> - **Rationale**: Prevents information disclosure while maintaining diagnostic capability for legitimate operations\n> - **Consequences**: Less specific error information for developers but stronger security posture against cryptographic attacks\n\nThe key validation system must handle various key-related failures without revealing information about key properties or validation logic. Key strength validation ensures that provided keys meet minimum security requirements, while key format validation catches encoding or structure issues that might indicate integration problems rather than attacks.\n\n| Cryptographic Failure | Detection Point | Public Response | Internal Logging |\n|---|---|---|---|\n| **Signature Mismatch** | HMAC comparison | Generic \"invalid token\" | Full token header, signature details, timing |\n| **Algorithm Confusion** | Header algorithm validation | Generic \"invalid token\" | Attempted algorithm, expected algorithm |\n| **Key Too Weak** | Key strength validation | Configuration error | Key length, strength requirements |\n| **Key Format Error** | Key parsing/validation | Configuration error | Key format details, expected format |\n\nThe HMAC computation process must handle edge cases like empty signing input, malformed keys, or hash function failures without revealing internal state. Error handling at this level requires particular care because exceptions or error conditions might leak information about the cryptographic implementation.\n\n| HMAC Issue | Cause | Detection | Handling Strategy |\n|---|---|---|---|\n| **Empty Signing Input** | Malformed token structure | String length check | Structural error before HMAC |\n| **Invalid Key Format** | Key encoding problems | Key validation failure | Configuration error response |\n| **Hash Function Failure** | Cryptographic library error | Exception during HMAC | Internal error with fallback |\n| **Memory Issues** | Large token or key size | Memory allocation failure | Resource exhaustion error |\n\n⚠️ **Pitfall: Information Disclosure Through Error Timing**\nDevelopers often implement different error handling paths for signature failures versus structural failures, creating timing side channels that reveal information about token validity. Always ensure that all cryptographic error paths take similar execution time. Use constant-time comparison for signature validation and avoid early returns that might reveal information about which validation step failed.\n\n### Temporal Edge Cases\n\nTime-based JWT validation presents unique challenges because distributed systems rarely maintain perfect clock synchronization. Temporal edge cases span from simple clock skew scenarios to complex edge cases involving leap seconds, daylight saving time transitions, and extreme timestamp values that might cause integer overflow or underflow.\n\nThink of temporal validation as coordinating a global conference call across multiple time zones. Participants may have slightly different clocks, some may join early or late due to scheduling confusion, and the conference system must gracefully handle these timing discrepancies while maintaining the intended access control. JWT temporal validation requires similar flexibility within well-defined security boundaries.\n\nClock skew tolerance represents a fundamental security trade-off between usability and temporal accuracy. Generous leeway periods improve interoperability between systems with slightly misaligned clocks but create larger windows where expired tokens remain valid. Conservative leeway settings provide tighter security at the cost of increased failure rates in normal operation.\n\n> **Decision: Configurable Leeway with Secure Defaults**\n> - **Context**: Systems in production often have modest clock differences, but security requires limiting temporal tolerance\n> - **Options Considered**: Fixed leeway, no leeway, fully configurable leeway, adaptive leeway\n> - **Decision**: Configurable leeway with security-focused default of 300 seconds maximum\n> - **Rationale**: Balances operational requirements with security constraints while preventing excessive temporal tolerance\n> - **Consequences**: Some systems may require clock synchronization improvements, but provides predictable security boundaries\n\nThe leap second handling system addresses rare but potentially significant edge cases where system clocks may become temporarily inconsistent during leap second events. While leap seconds occur infrequently, they can cause subtle timing validation failures that are difficult to diagnose without specific handling logic.\n\n| Temporal Edge Case | Scenario | Detection Method | Handling Strategy |\n|---|---|---|---|\n| **Clock Skew** | Servers with different system times | Timestamp comparison with leeway | Accept within configured tolerance |\n| **Leap Second** | UTC time adjustment events | Large clock discontinuity detection | Extended leeway during leap events |\n| **DST Transition** | Local time zone adjustments | UTC timestamp validation | Use UTC for all calculations |\n| **Timestamp Overflow** | Dates beyond system limits | Range validation before conversion | Reject with temporal range error |\n\nThe extreme timestamp validation system prevents integer overflow attacks and handles edge cases like year 2038 problems on 32-bit systems. Timestamp validation must consider both the mathematical validity of timestamp values and the practical limits of datetime libraries in the target programming language.\n\n| Timestamp Issue | Range Problem | Validation Check | Error Response |\n|---|---|---|---|\n| **Negative Timestamps** | Dates before Unix epoch | Value >= 0 check | Invalid timestamp format |\n| **Far Future Dates** | Beyond system datetime limits | Maximum timestamp validation | Timestamp out of range |\n| **Integer Overflow** | Values causing calculation overflow | Safe arithmetic checks | Temporal calculation error |\n| **Precision Loss** | Microseconds in integer timestamps | Precision validation during conversion | Timestamp precision warning |\n\nThe time zone handling system ensures that all temporal calculations use UTC to avoid ambiguity and inconsistency. Local time zone interpretation can create security vulnerabilities where tokens appear valid or invalid depending on server configuration, making UTC the only safe choice for distributed authentication systems.\n\n⚠️ **Pitfall: Using Local Time for JWT Validation**\nMany developers accidentally use local server time for JWT timestamp validation, creating inconsistencies when tokens are validated across different time zones or servers with different time zone configurations. Always convert all timestamps to UTC before performing any temporal validation. Use UTC-based libraries and explicitly validate that timestamp claims represent UTC values rather than local time.\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Silent Error Swallowing**\nDevelopers sometimes catch all exceptions during JWT validation and return generic \"invalid token\" responses without proper logging or error context. This makes debugging extremely difficult and can mask security issues. Instead, implement structured error handling that captures full error context internally while returning appropriate public error messages based on security context.\n\n⚠️ **Pitfall: Inconsistent Error Response Format**\nApplications often return different error response formats for different types of JWT validation failures - HTTP status codes for some errors, JSON responses for others, plain text for edge cases. This inconsistency complicates client-side error handling and may leak information about internal validation logic. Establish a consistent error response format that all validation failure modes use.\n\n⚠️ **Pitfall: Development Error Details in Production**\nMany JWT libraries provide detailed error messages that include token contents, internal state, or validation details that should never be exposed in production environments. Always implement security context-aware error messaging that provides detailed diagnostics in development while maintaining minimal information disclosure in production.\n\n### Implementation Guidance\n\nBuilding robust error handling for JWT validation requires careful attention to both security and operational concerns. The following implementation provides a foundation for handling the various error categories while maintaining appropriate security boundaries.\n\n#### A. Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|---|---|---|\n| **Error Hierarchy** | Built-in exceptions with custom messages | Custom exception classes with structured context |\n| **Logging** | Standard library logging with levels | Structured logging with security context awareness |\n| **Configuration** | Environment variables for security context | Configuration management with validation |\n| **Monitoring** | Basic error rate logging | Security event monitoring with alerting |\n\n#### B. Recommended File Structure\n\n```\njwt_library/\n├── errors/\n│   ├── __init__.py              ← Error class definitions and hierarchy\n│   ├── classification.py        ← Error severity and context management\n│   ├── handlers.py              ← Error handling strategies by context\n│   └── diagnostics.py           ← Diagnostic information formatting\n├── validation/\n│   ├── structural.py            ← Malformed token validation\n│   ├── cryptographic.py         ← Signature and key validation\n│   ├── temporal.py              ← Time-based validation\n│   └── claims.py                ← Claims validation with error handling\n└── utils/\n    ├── logging.py               ← Security-aware logging utilities\n    └── context.py               ← Security context management\n```\n\n#### C. Infrastructure Starter Code\n\n```python\n\"\"\"\nComplete error handling infrastructure for JWT validation.\nThis provides the foundation classes and utilities needed for\ncomprehensive error handling across all validation components.\n\"\"\"\n\nimport logging\nimport time\nimport traceback\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Dict, Any, Optional, List\nfrom dataclasses import dataclass\n\n\nclass ErrorSeverity(Enum):\n    \"\"\"Error severity levels for appropriate response handling.\"\"\"\n    CRITICAL = \"critical\"    # Potential security attacks\n    HIGH = \"high\"           # Clear validation failures  \n    MEDIUM = \"medium\"       # Configuration/integration issues\n    LOW = \"low\"            # Edge cases and warnings\n\n\nclass SecurityContext(Enum):\n    \"\"\"Security context for error handling behavior.\"\"\"\n    DEVELOPMENT = \"development\"  # Full diagnostic details\n    PRODUCTION = \"production\"    # Generic error messages\n    AUDIT = \"audit\"             # Enhanced logging and monitoring\n\n\n@dataclass\nclass ValidationFailureContext:\n    \"\"\"Structured context for validation failures.\"\"\"\n    component: str                    # Component that detected the failure\n    operation: str                   # Operation that was attempted  \n    failure_type: str               # Type of failure detected\n    severity: ErrorSeverity         # Severity level of the failure\n    debug_info: Dict[str, Any]      # Detailed diagnostic information\n    safe_message: str               # Safe message for external consumption\n    timestamp: float = None         # When the failure occurred\n    \n    def __post_init__(self):\n        if self.timestamp is None:\n            self.timestamp = time.time()\n\n\nclass SecurityAwareLogger:\n    \"\"\"Logger that adapts output based on security context.\"\"\"\n    \n    def __init__(self, name: str, security_context: SecurityContext):\n        self.logger = logging.getLogger(name)\n        self.security_context = security_context\n        \n    def log_validation_failure(self, context: ValidationFailureContext):\n        \"\"\"Log validation failure with appropriate detail level.\"\"\"\n        if self.security_context == SecurityContext.DEVELOPMENT:\n            self.logger.error(f\"Validation failure in {context.component}: {context.debug_info}\")\n        elif self.security_context == SecurityContext.PRODUCTION:\n            self.logger.warning(f\"Validation failure: {context.safe_message}\")\n        else:  # AUDIT\n            self.logger.info(f\"Audit: {context.component} {context.operation} failed\")\n\n\nclass ConstantTimeOperations:\n    \"\"\"Utilities for constant-time operations to prevent timing attacks.\"\"\"\n    \n    @staticmethod\n    def constant_time_compare(a: bytes, b: bytes) -> bool:\n        \"\"\"Compare two byte sequences in constant time.\"\"\"\n        if len(a) != len(b):\n            return False\n        \n        result = 0\n        for x, y in zip(a, b):\n            result |= x ^ y\n        return result == 0\n    \n    @staticmethod  \n    def safe_error_delay():\n        \"\"\"Add consistent delay for all error paths.\"\"\"\n        time.sleep(0.001)  # 1ms consistent delay\n```\n\n#### D. Core Logic Skeleton Code\n\n```python\n# TODO: Implement the main JWT error handling classes\n# These should be implemented by the learner following the patterns above\n\nclass JWTValidationError(Exception):\n    \"\"\"Base exception for all JWT validation failures.\"\"\"\n    \n    def __init__(self, context: ValidationFailureContext):\n        # TODO 1: Store the validation failure context\n        # TODO 2: Set appropriate exception message based on security context  \n        # TODO 3: Initialize parent exception with safe message\n        pass\n    \n    def get_safe_message(self) -> str:\n        # TODO: Return message appropriate for external consumption\n        pass\n        \n    def get_debug_info(self) -> Dict[str, Any]:\n        # TODO: Return diagnostic information for internal use\n        pass\n\n\nclass StructuralError(JWTValidationError):\n    \"\"\"Token structure and format validation failures.\"\"\"\n    pass\n\n\nclass MalformedTokenError(StructuralError):\n    \"\"\"Invalid token structure - wrong number of parts or format.\"\"\"\n    pass\n\n\ndef parse_token_structure(token: str) -> tuple[str, str, str]:\n    \"\"\"\n    Parse JWT token structure into header, payload, signature parts.\n    Validates basic token format and returns the three components.\n    \"\"\"\n    # TODO 1: Validate token is a string and not empty\n    # TODO 2: Split token on '.' character\n    # TODO 3: Validate exactly 3 parts exist (header.payload.signature)\n    # TODO 4: Validate each part is non-empty\n    # TODO 5: Return tuple of (header, payload, signature) parts\n    # Hint: Use ValidationFailureContext to structure any errors\n    pass\n\n\ndef validate_base64url_format(data: str, part_name: str) -> None:\n    \"\"\"\n    Validate that data contains only valid Base64URL characters.\n    Raises StructuralError if invalid characters are found.\n    \"\"\"\n    # TODO 1: Define valid Base64URL character set (A-Z, a-z, 0-9, -, _)  \n    # TODO 2: Check each character in data against valid character set\n    # TODO 3: Ensure no padding characters (=) are present\n    # TODO 4: Create ValidationFailureContext for any invalid characters\n    # TODO 5: Raise StructuralError with context if validation fails\n    pass\n\n\ndef handle_cryptographic_error(error: Exception, operation: str) -> JWTValidationError:\n    \"\"\"\n    Convert cryptographic errors to appropriate JWT validation errors.\n    Ensures consistent handling across different crypto failure modes.\n    \"\"\"\n    # TODO 1: Determine error severity based on exception type\n    # TODO 2: Create appropriate debug information without leaking crypto details\n    # TODO 3: Generate safe public message for the error\n    # TODO 4: Add consistent timing delay to prevent timing attacks\n    # TODO 5: Return appropriate JWTValidationError subclass\n    # Hint: Use ConstantTimeOperations.safe_error_delay()\n    pass\n\n\ndef validate_temporal_bounds(timestamp: int, claim_name: str, \n                           leeway_seconds: int = DEFAULT_LEEWAY_SECONDS) -> None:\n    \"\"\"\n    Validate timestamp is within reasonable bounds for system processing.\n    Prevents integer overflow and handles extreme timestamp values.\n    \"\"\"\n    # TODO 1: Define reasonable timestamp bounds (e.g., 1970 to 2099)\n    # TODO 2: Check timestamp is not negative\n    # TODO 3: Check timestamp is not beyond maximum system datetime\n    # TODO 4: Validate timestamp + leeway doesn't cause integer overflow\n    # TODO 5: Raise TemporalValidationError for out-of-bounds values\n    pass\n```\n\n#### E. Language-Specific Hints\n\n**Python-Specific Error Handling:**\n- Use `logging` module with structured formatters for security-aware logging\n- Implement custom exception hierarchy inheriting from `Exception`\n- Use `dataclasses` for structured error context objects\n- Use `time.time()` for consistent timestamp generation across error handling\n- Use `traceback` module carefully - include full traces only in development context\n\n**Security Considerations:**\n- Never include token contents in error messages outside development context\n- Use `secrets.compare_digest()` for constant-time string comparisons\n- Implement consistent error response timing using `time.sleep()` where needed\n- Use structured logging formats that can be easily filtered and monitored\n\n#### F. Milestone Checkpoint\n\n**After implementing error handling infrastructure:**\n\n1. **Basic Error Classification Test:**\n   ```bash\n   python -m pytest tests/test_error_classification.py -v\n   ```\n   Expected: All error severity levels and security contexts work correctly\n\n2. **Malformed Token Handling Test:**\n   ```bash\n   python -c \"\n   from jwt_library.validation.structural import parse_token_structure\n   try:\n       parse_token_structure('invalid')\n   except MalformedTokenError as e:\n       print('✓ Correctly caught malformed token')\n   \"\n   ```\n\n3. **Security Context Behavior Test:**\n   ```bash\n   python -c \"\n   from jwt_library.errors import SecurityContext, ValidationFailureContext\n   # Test that production context hides debug details\n   context = ValidationFailureContext(...)\n   # Verify safe_message is generic in production context\n   \"\n   ```\n\n#### G. Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---|---|---|---|\n| All tokens rejected as \"invalid\" | Error handling swallowing specific errors | Enable debug logging, check error contexts | Implement proper error classification |\n| Inconsistent validation behavior | Different error paths for same failure type | Add logging to all validation paths | Standardize error handling flow |\n| Performance issues during errors | Complex error formatting in hot paths | Profile error handling code | Cache formatted messages, simplify context |\n| Information leakage in errors | Development error details in production | Check security context configuration | Implement context-aware message formatting |\n\n\n## Testing Strategy\n\n> **Milestone(s):** All three milestones - provides comprehensive verification approach for JWT structure implementation (Milestone 1), HMAC signing security (Milestone 2), and claims validation correctness (Milestone 3)\n\nTesting a JWT library requires a multi-layered verification approach that goes beyond simple functional testing. Since JWTs form the foundation of authentication and authorization systems, our testing strategy must validate not only correctness but also security properties, edge cases, and resistance to common attacks. This section establishes concrete verification points for each milestone, reference test vectors for validation, security-focused test scenarios, and complete end-to-end workflows.\n\n### Mental Model: Quality Assurance Laboratory\n\nThink of our testing strategy as a quality assurance laboratory for security tokens - similar to how a mint tests newly produced currency. Just as currency testing involves multiple verification stations (weight, dimensions, security features, durability), JWT testing requires multiple validation layers. The structural tests verify the token \"looks right\" (proper format, encoding), cryptographic tests ensure it \"can't be counterfeited\" (signature integrity, timing attack resistance), and claims validation tests confirm it \"works as intended\" (expiration, audience, issuer verification). Each testing layer catches different classes of problems, and only tokens passing all layers can be trusted in production systems.\n\nThe testing laboratory analogy extends to our reference test vectors - these are like the \"gold standard\" samples that all production tokens must match. Security test scenarios are like stress tests that attempt to break or exploit the tokens using known attack techniques. End-to-end scenarios verify the complete workflow from token creation through validation, ensuring the entire system works cohesively rather than just individual components in isolation.\n\n### Milestone Verification Points\n\nEach development milestone has specific verification checkpoints that validate both functional correctness and security properties. These checkpoints build upon each other - Milestone 2 verification assumes Milestone 1 is working correctly, and Milestone 3 verification requires both previous milestones to function properly.\n\n#### Milestone 1: JWT Structure Verification\n\n| Verification Point | Expected Behavior | Failure Indicators | Recovery Actions |\n|-------------------|-------------------|-------------------|------------------|\n| Header JSON Generation | `JWTHeader` with `alg: \"HS256\"` and `typ: \"JWT\"` serializes to valid JSON | Malformed JSON, missing fields, incorrect field values | Check `serialize_header` JSON formatting, verify field names match specification |\n| Payload Claims Encoding | All standard claims (`iss`, `sub`, `aud`, `exp`, `nbf`, `iat`, `jti`) and custom claims serialize correctly | Missing required claims, incorrect timestamp format, malformed custom claims | Validate `serialize_payload` handles all claim types, check Unix timestamp conversion |\n| Base64URL Character Set | Encoded output contains only URL-safe characters (A-Z, a-z, 0-9, -, _) | Plus signs, forward slashes, or equals padding in output | Verify `base64url_encode` uses URL-safe alphabet, removes padding correctly |\n| Token Structure Assembly | Final token follows `header.payload.signature` format with exactly two dots | Missing dots, extra segments, empty segments | Check `assemble_token` concatenation logic and dot separator placement |\n| Round-trip Encoding Consistency | Encoding then parsing header/payload returns identical data structures | Field value changes, type conversions, missing custom claims | Verify JSON serialization is deterministic, check parsing logic |\n\n**Concrete Verification Steps:**\n\n1. **Header Structure Test**: Create a `JWTHeader` with algorithm \"HS256\" and type \"JWT\". Serialize using `serialize_header` and verify the resulting JSON contains exactly these fields with correct values. Parse the JSON back and confirm field values match the original structure.\n\n2. **Payload Claims Test**: Create a `JWTPayload` with all standard claims populated (issuer, subject, audience, expiration, not-before, issued-at, JWT ID) plus custom claims dictionary. Serialize using `serialize_payload` and verify all fields appear in the JSON with correct types (strings for text fields, integers for timestamps, appropriate handling of audience as string or list).\n\n3. **Base64URL Encoding Test**: Take known binary data and encode using `base64url_encode`. Verify the output contains no plus signs, forward slashes, or equals padding. Decode using `base64url_decode` and confirm the result matches the original binary data exactly.\n\n4. **Token Assembly Test**: Create encoded header and payload strings, add a mock signature, and use `assemble_token` to create the final token. Verify the result has exactly three segments separated by dots, with no empty segments or extra separators.\n\n#### Milestone 2: HMAC Signing Verification\n\n| Verification Point | Expected Behavior | Failure Indicators | Recovery Actions |\n|-------------------|-------------------|-------------------|------------------|\n| HMAC-SHA256 Computation | Signatures match RFC 7515 test vectors exactly | Signature mismatches, wrong signature length | Verify HMAC implementation, check key handling, validate input encoding |\n| Signature Verification Success | Valid tokens return `True` from `verify` method | False negatives on valid signatures | Check signature recomputation logic, verify input reconstruction |\n| Signature Verification Failure | Invalid, tampered, or truncated signatures return `False` | False positives on invalid signatures | Validate comparison logic, check error handling paths |\n| Constant-Time Comparison | `constant_time_compare` execution time independent of input differences | Timing variations correlate with input differences | Implement proper constant-time algorithm, avoid early returns |\n| Key Strength Validation | `validate_key_strength` rejects keys shorter than 32 bytes | Weak keys accepted, incorrect length calculations | Check minimum key length constant, validate byte length correctly |\n\n**Concrete Verification Steps:**\n\n1. **RFC Test Vector Validation**: Use the standard test vectors from RFC 7515 to verify HMAC-SHA256 computation. Create the exact signing input specified in the test vector, use the test key, and confirm our `sign` method produces the identical signature bytes specified in the RFC.\n\n2. **Signature Round-Trip Test**: Create a token using `create_token`, then immediately verify it using `verify_token` with the same secret key and permissive validation context. This should always succeed for properly formed tokens.\n\n3. **Tampering Detection Test**: Create a valid token, then systematically tamper with each part (header, payload, signature) and verify that `verify_token` correctly rejects all tampered variants.\n\n4. **Timing Attack Resistance Test**: Create two tokens with signatures that differ in the first byte versus signatures that differ in the last byte. Measure the execution time of `constant_time_compare` for both scenarios - the time differences should be statistically insignificant.\n\n#### Milestone 3: Claims Validation Verification\n\n| Verification Point | Expected Behavior | Failure Indicators | Recovery Actions |\n|-------------------|-------------------|-------------------|------------------|\n| Expiration Enforcement | Tokens with `exp` in the past raise `TokenExpiredError` | Expired tokens accepted, incorrect error types | Check `is_expired` logic, verify Unix timestamp comparison |\n| Not-Before Enforcement | Tokens with `nbf` in the future raise `TokenNotYetValidError` | Premature tokens accepted, missing nbf validation | Validate `is_not_before` implementation, check future time handling |\n| Clock Skew Tolerance | Tokens within leeway period are accepted despite slight time differences | Excessive clock skew rejection, incorrect leeway application | Verify leeway addition/subtraction logic in time comparisons |\n| Issuer Allowlist Validation | Only tokens from allowed issuers are accepted, others raise `InvalidIssuerError` | Unauthorized issuers accepted, allowlist bypass | Check issuer comparison logic, validate allowlist membership |\n| Audience Verification | Tokens match expected audience exactly, others raise `InvalidAudienceError` | Wrong audience accepted, audience list handling errors | Verify audience string/list handling, check exact matching |\n\n**Concrete Verification Steps:**\n\n1. **Time-Based Claims Test**: Create tokens with expiration times 10 minutes in the past, 10 minutes in the future, and exactly now. Validate with default leeway settings and verify only the future token is accepted.\n\n2. **Issuer Validation Test**: Create an allowed issuer list containing \"trusted-issuer\" and \"backup-issuer\". Create tokens from these issuers and from \"malicious-issuer\". Verify only tokens from allowed issuers pass validation.\n\n3. **Audience List Handling Test**: Create tokens with audience as a single string, as a list containing the expected audience, and as a list not containing the expected audience. Verify the validation handles all formats correctly.\n\n4. **Clock Skew Edge Cases Test**: Create tokens that expire exactly at the leeway boundary (e.g., 5 minutes and 1 second past expiration with 5 minute leeway). These should be rejected, while tokens expiring 4 minutes and 59 seconds ago should be accepted.\n\n### Reference Test Vectors\n\nReference test vectors provide known-good inputs and expected outputs for validating implementation correctness. These vectors come from official JWT specifications, established libraries, and carefully crafted edge cases that expose common implementation bugs.\n\n#### RFC 7515 Official Test Vectors\n\n| Test Vector Name | Input Data | Expected Output | Validation Purpose |\n|------------------|------------|-----------------|-------------------|\n| Basic HS256 Signature | Header: `{\"alg\":\"HS256\",\"typ\":\"JWT\"}`, Payload: `{\"sub\":\"1234567890\",\"name\":\"John Doe\",\"iat\":1516239022}`, Key: `your-256-bit-secret` (base64) | Signature: `SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c` | Validates core HMAC-SHA256 implementation |\n| Empty Payload Test | Header: `{\"alg\":\"HS256\",\"typ\":\"JWT\"}`, Payload: `{}`, Key: 32-byte random key | Valid signature for empty claims | Tests minimal valid JWT structure |\n| Custom Claims Vector | Header: standard, Payload: includes custom claims with various types (string, number, boolean, array), Key: test key | Expected signature for complex payload | Validates custom claims serialization |\n| Special Characters Test | Header: standard, Payload: contains Unicode characters, quotes, newlines in string fields | Valid signature despite special characters | Tests JSON escaping and encoding edge cases |\n\n**Base64URL Encoding Test Vectors:**\n\n| Input Bytes (Hex) | Expected Base64URL Output | Validation Purpose |\n|-------------------|--------------------------|-------------------|\n| `48656c6c6f` (\"Hello\") | `SGVsbG8` | Basic encoding without padding |\n| `48656c6c6f20` (\"Hello \") | `SGVsbG8g` | Encoding requiring 2 padding chars removed |\n| `48656c6c6f2057` (\"Hello W\") | `SGVsbG9X` | Encoding requiring 1 padding char removed |\n| Empty bytes | Empty string | Edge case of zero-length input |\n| `ff` (single byte 255) | `_w` | Tests URL-safe character substitution |\n\n**Claims Validation Test Vectors:**\n\n| Test Scenario | Token Claims | Validation Context | Expected Result |\n|---------------|--------------|-------------------|-----------------|\n| Valid Unexpired Token | `exp`: current time + 3600, `iss`: \"trusted-issuer\", `aud`: \"my-app\" | Standard context with \"trusted-issuer\" allowed, \"my-app\" expected audience | Success |\n| Expired Token | `exp`: current time - 3600 | Standard context with default leeway | `TokenExpiredError` |\n| Future NBF Token | `nbf`: current time + 3600 | Standard context | `TokenNotYetValidError` |\n| Clock Skew Acceptable | `exp`: current time - 200 | Context with 300 second leeway | Success |\n| Invalid Issuer | `iss`: \"malicious-issuer\" | Context allowing only \"trusted-issuer\" | `InvalidIssuerError` |\n| Wrong Audience | `aud`: \"other-app\" | Context expecting \"my-app\" | `InvalidAudienceError` |\n\n#### Edge Case Test Vectors\n\nThese vectors test boundary conditions and edge cases that often expose implementation bugs:\n\n| Edge Case | Test Data | Expected Behavior | Common Bug Exposed |\n|-----------|-----------|-------------------|-------------------|\n| Maximum Timestamp | `exp`: 2147483647 (2038-01-19) | Valid until that date | Integer overflow in timestamp handling |\n| Minimum Timestamp | `exp`: 0 (1970-01-01) | Expired (assuming current time > 1970) | Underflow or negative time handling |\n| Leap Second Timestamp | `exp`: timestamp during leap second | Graceful handling without crash | Time library edge case failures |\n| Very Long Custom Claim | Custom claim with 10KB string value | Either accept or reject gracefully | Buffer overflow or memory issues |\n| Unicode in Claims | Claims containing emoji, Chinese characters, mathematical symbols | Proper UTF-8 handling | Character encoding bugs |\n| Nested JSON in Custom Claims | Custom claim containing JSON object/array | Correct nested serialization | JSON escaping and structure bugs |\n\n### Security Test Scenarios\n\nSecurity testing focuses on validating resistance to known attack vectors and ensuring the library fails securely when faced with malicious inputs or exploitation attempts.\n\n#### Timing Attack Tests\n\nTiming attacks exploit variations in execution time to extract sensitive information. Our constant-time comparison implementation must resist these attacks:\n\n| Attack Scenario | Test Method | Success Criteria | Failure Indicators |\n|-----------------|-------------|------------------|-------------------|\n| Signature Comparison Timing | Compare execution time of `constant_time_compare` with signatures differing in first byte vs last byte | Time difference is statistically insignificant across 10,000 iterations | Measurable timing correlation with input differences |\n| Key Length Timing | Measure verification time with correct key vs wrong key of same length | Consistent timing regardless of key correctness | Faster failure with wrong keys due to early termination |\n| Signature Length Timing | Test signatures of correct length vs truncated signatures | Similar processing time for length validation | Different timing reveals signature length checking logic |\n\n**Timing Attack Test Implementation:**\n\nThe timing attack test requires statistical analysis to detect subtle timing differences. Create pairs of similar signatures where only one bit differs at position 0 (first byte) versus position 255 (last byte). Run the `constant_time_compare` function 10,000 times for each signature pair, measuring execution time in nanoseconds. Calculate the mean and standard deviation for each position. A secure implementation should show no statistically significant difference between first-byte and last-byte differences.\n\n#### Algorithm Confusion Attack Tests\n\nAlgorithm confusion attacks exploit JWT's algorithm flexibility to bypass security:\n\n| Attack Vector | Test Implementation | Expected Defense | Vulnerability Indicator |\n|---------------|-------------------|------------------|-------------------------|\n| None Algorithm | Create token with `alg: \"none\"` and empty signature | Reject with algorithm not supported error | Token accepted without signature verification |\n| Public Key as HMAC Key | Use RSA public key as HMAC secret for HS256 token | Reject due to key format validation | Signature verification succeeds with public key |\n| Algorithm Downgrade | Change `alg` field from HS256 to HS1 (weaker hash) | Reject unsupported algorithm | Weak algorithm accepted |\n| Missing Algorithm | Create header without `alg` field | Reject malformed header | Default algorithm assumed |\n\n**Algorithm Confusion Test Implementation:**\n\nCreate tokens with manipulated algorithm fields and verify the library rejects them appropriately. The test should modify only the algorithm field while keeping the payload and signature intact, then attempt verification. A secure implementation must validate the algorithm field matches the expected signing algorithm and reject any algorithm substitution attempts.\n\n#### Malformed Token Attack Tests\n\nThese tests verify robust handling of structurally invalid tokens:\n\n| Malformation Type | Test Input | Expected Behavior | Security Concern |\n|-------------------|------------|-------------------|------------------|\n| Too Few Segments | `header.payload` (missing signature) | `MalformedTokenError` with safe message | Information disclosure about expected format |\n| Too Many Segments | `header.payload.signature.extra` | `MalformedTokenError` | Parser confusion or buffer overflow |\n| Empty Segments | `header..signature` (empty payload) | Specific error for empty payload | Bypass of required claims validation |\n| Invalid Base64URL | `header.invalid+base64=.signature` | Base64 decoding error | Parser crash or unexpected behavior |\n| Non-JSON Header | Valid base64url encoding invalid JSON in header | JSON parsing error | Information disclosure about internal structure |\n| Massive Token Size | Token with 1MB+ payload | Resource exhaustion protection or graceful rejection | Denial of service vulnerability |\n\n#### Cryptographic Attack Simulation\n\nThese tests simulate cryptographic attacks to verify signature security:\n\n| Attack Type | Test Scenario | Expected Defense | Vulnerability Exposed |\n|-------------|---------------|------------------|----------------------|\n| Signature Stripping | Remove signature segment entirely | Reject unsigned token | Bypass signature verification |\n| Signature Replay | Use valid signature from different token | Reject due to signature mismatch | Cross-token signature acceptance |\n| Key Exhaustion | Try common/weak keys against captured token | No key should verify (assuming strong key used) | Weak key acceptance |\n| Truncated Signature | Use only first N bytes of valid signature | Reject due to signature length/format | Partial signature matching |\n\n### End-to-End Scenarios\n\nEnd-to-end scenarios validate complete workflows from token creation through validation, ensuring all components work together correctly and handle realistic usage patterns.\n\n#### Standard Authentication Flow\n\nThis scenario simulates the most common JWT usage pattern - user authentication with session management:\n\n**Scenario Setup:**\n- User \"john.doe\" authenticates to application \"web-app\" \n- Issuer is \"auth-service\" with 1-hour token lifetime\n- Custom claims include user roles and preferences\n\n**Test Sequence:**\n\n1. **Token Creation Phase:**\n   - Create `JWTHeader` with HS256 algorithm\n   - Create `JWTPayload` with issuer \"auth-service\", subject \"john.doe\", audience \"web-app\"\n   - Set expiration to current time + 3600 seconds\n   - Add custom claims: `{\"roles\": [\"user\", \"premium\"], \"preferences\": {\"theme\": \"dark\"}}`\n   - Generate secret key using `generate_secure_key`\n   - Call `create_token` and verify result has three dot-separated segments\n\n2. **Token Transmission Simulation:**\n   - Simulate network transmission by base64 encoding/decoding the token\n   - Introduce minor timing delays to simulate network latency\n   - Verify token survives transmission without corruption\n\n3. **Token Verification Phase:**\n   - Create `ValidationContext` with strict validation settings\n   - Set allowed issuers to [\"auth-service\"]\n   - Set expected audience to \"web-app\" \n   - Call `verify_token` and verify success\n   - Extract custom claims and verify roles and preferences are intact\n\n4. **Claims Usage Phase:**\n   - Use returned `JWTPayload` for authorization decisions\n   - Check \"premium\" role in roles array\n   - Access user preferences for application customization\n   - Verify all data types preserved correctly through serialization\n\n**Success Criteria:**\n- Token creation completes without errors\n- Token verification succeeds with correct claims\n- Custom claims maintain proper types (arrays remain arrays, nested objects preserved)\n- Entire flow completes in under 100ms on typical hardware\n\n#### Multi-Service Authorization Scenario\n\nThis scenario tests JWT usage across multiple microservices with different validation requirements:\n\n**Scenario Setup:**\n- Central authentication service issues tokens\n- User service validates tokens with user-specific claims\n- Payment service validates tokens with financial permissions\n- Each service has different validation strictness\n\n**Test Sequence:**\n\n1. **Central Token Issuance:**\n   - Authentication service creates token with multiple audiences: [\"user-service\", \"payment-service\"]\n   - Include hierarchical custom claims: `{\"permissions\": {\"user\": [\"read\", \"update\"], \"payment\": [\"view-balance\"]}}`\n   - Token lifetime: 30 minutes\n   - Strong secret key (32+ bytes random)\n\n2. **User Service Validation:**\n   - Create permissive `ValidationContext` (allows some clock skew)\n   - Validate token accepts \"user-service\" as audience\n   - Extract user permissions and verify \"read\" and \"update\" access\n   - Test succeeds even with 2-minute clock drift\n\n3. **Payment Service Validation:**\n   - Create strict `ValidationContext` (minimal clock skew tolerance)\n   - Validate token accepts \"payment-service\" as audience  \n   - Extract payment permissions and verify \"view-balance\" access\n   - Reject token if more than 30 seconds of clock drift\n\n4. **Cross-Service Token Reuse:**\n   - Same token should validate successfully in both services\n   - Each service extracts relevant permission subset\n   - Verify no interference between service-specific validations\n\n**Success Criteria:**\n- Single token validates successfully in multiple services\n- Each service extracts appropriate permission subset\n- Clock skew handling works correctly with different tolerance levels\n- No permission leakage between service boundaries\n\n#### Error Handling and Recovery Scenario\n\nThis scenario validates graceful error handling and recovery across the complete token lifecycle:\n\n**Test Sequence:**\n\n1. **Creation Error Simulation:**\n   - Attempt token creation with weak key (16 bytes) - should fail with key strength error\n   - Create token with malformed custom claims (circular references) - should fail with serialization error\n   - Create token with claims exceeding reasonable size limits - should fail gracefully\n   - Verify all creation errors include safe external messages and detailed internal diagnostics\n\n2. **Network Corruption Simulation:**\n   - Create valid token then introduce single-bit errors in each segment\n   - Test with truncated tokens (missing characters from end)\n   - Test with extended tokens (extra characters appended)\n   - Verify all corruption scenarios produce appropriate parsing errors\n\n3. **Temporal Edge Case Testing:**\n   - Create token that expires during the verification process\n   - Test verification exactly at expiration boundary (within millisecond precision)\n   - Test with extreme timestamps (year 2038, year 1970)\n   - Verify temporal validation handles edge cases gracefully\n\n4. **Recovery and Fallback Testing:**\n   - Simulate validation service temporary unavailability\n   - Test graceful degradation when strict validation fails\n   - Verify error context includes sufficient information for debugging\n   - Test error message safety (no key material or sensitive data leaked)\n\n**Success Criteria:**\n- All error scenarios produce appropriate error types\n- Error messages are safe for external consumption\n- Internal diagnostic information is available for debugging\n- No crashes or resource leaks during error conditions\n- System recovers cleanly from all error states\n\n### Implementation Guidance\n\nThe testing strategy implementation requires careful setup of test infrastructure, automated validation pipelines, and comprehensive coverage of both functional and security requirements.\n\n**Technology Recommendations:**\n\n| Test Category | Simple Option | Advanced Option |\n|---------------|---------------|-----------------|\n| Unit Testing | Python `unittest` with basic assertions | `pytest` with fixtures, parameterized tests, and coverage reporting |\n| Timing Attack Testing | Manual timing with `time.perf_counter()` | Statistical analysis with `scipy.stats` and automated significance testing |\n| Test Vector Validation | Hard-coded expected values in test files | JSON test vector files with automated loading and validation |\n| Security Testing | Manual malformed input testing | Property-based testing with `hypothesis` for fuzz testing |\n| Performance Testing | Simple execution time measurement | `pytest-benchmark` with statistical analysis and regression detection |\n\n**Recommended Test Structure:**\n\n```\njwt-library/\n  tests/\n    unit/\n      test_encoding.py           ← Milestone 1 tests\n      test_signing.py            ← Milestone 2 tests  \n      test_validation.py         ← Milestone 3 tests\n    integration/\n      test_end_to_end.py         ← Complete workflow tests\n    security/\n      test_timing_attacks.py     ← Security-focused tests\n      test_malformed_inputs.py   ← Robustness tests\n    vectors/\n      rfc_test_vectors.json      ← Official test vectors\n      edge_case_vectors.json     ← Custom edge case tests\n    conftest.py                  ← Shared test fixtures\n    test_utils.py                ← Testing utilities\n```\n\n**Test Infrastructure Starter Code:**\n\n```python\n# tests/conftest.py - Complete test infrastructure setup\nimport pytest\nimport time\nimport json\nimport secrets\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Any, Tuple\nfrom jwt_library.core import JWTHeader, JWTPayload, ValidationContext\nfrom jwt_library.utils import utc_now, to_unix_timestamp\n\n@pytest.fixture\ndef sample_header() -> JWTHeader:\n    \"\"\"Standard JWT header for testing.\"\"\"\n    return JWTHeader(alg=\"HS256\", typ=\"JWT\")\n\n@pytest.fixture  \ndef sample_payload() -> JWTPayload:\n    \"\"\"Standard JWT payload with all claim types.\"\"\"\n    now = utc_now()\n    return JWTPayload(\n        iss=\"test-issuer\",\n        sub=\"user123\", \n        aud=\"test-app\",\n        exp=to_unix_timestamp(now + timedelta(hours=1)),\n        nbf=to_unix_timestamp(now - timedelta(minutes=5)),\n        iat=to_unix_timestamp(now),\n        jti=\"unique-token-id\",\n        custom_claims={\"role\": \"admin\", \"permissions\": [\"read\", \"write\"]}\n    )\n\n@pytest.fixture\ndef test_secret_key() -> bytes:\n    \"\"\"Secure 32-byte test key.\"\"\"\n    return secrets.token_bytes(32)\n\n@pytest.fixture\ndef strict_validation_context() -> ValidationContext:\n    \"\"\"Strict validation for security testing.\"\"\"\n    return ValidationContext(\n        verify_signature=True,\n        verify_expiration=True, \n        verify_not_before=True,\n        leeway_seconds=0,\n        allowed_issuers=[\"test-issuer\"],\n        require_issuer=True,\n        expected_audience=\"test-app\",\n        require_audience=True,\n        required_claims=[\"iss\", \"sub\", \"aud\", \"exp\"]\n    )\n\nclass TimingTestHelper:\n    \"\"\"Utilities for timing attack detection.\"\"\"\n    \n    @staticmethod\n    def measure_execution_time(func, *args, iterations: int = 1000) -> List[float]:\n        \"\"\"Measure function execution time over multiple iterations.\"\"\"\n        times = []\n        for _ in range(iterations):\n            start = time.perf_counter()\n            func(*args)\n            end = time.perf_counter()\n            times.append(end - start)\n        return times\n    \n    @staticmethod\n    def detect_timing_difference(times_a: List[float], times_b: List[float], \n                               significance_level: float = 0.01) -> bool:\n        \"\"\"Detect statistically significant timing differences.\"\"\"\n        from scipy.stats import ttest_ind\n        statistic, p_value = ttest_ind(times_a, times_b)\n        return p_value < significance_level\n\n@pytest.fixture\ndef rfc_test_vectors() -> Dict[str, Any]:\n    \"\"\"Load official RFC test vectors.\"\"\"\n    with open('tests/vectors/rfc_test_vectors.json', 'r') as f:\n        return json.load(f)\n```\n\n**Core Test Skeletons:**\n\n```python\n# tests/unit/test_encoding.py - Milestone 1 verification\nimport pytest\nfrom jwt_library.encoding import base64url_encode, base64url_decode, encode_token_parts\n\nclass TestBase64URLEncoding:\n    \"\"\"Test Base64URL encoding implementation.\"\"\"\n    \n    def test_rfc_test_vectors(self, rfc_test_vectors):\n        \"\"\"Validate against official test vectors.\"\"\"\n        # TODO 1: Load Base64URL test vectors from rfc_test_vectors\n        # TODO 2: For each vector, encode input bytes and compare to expected output\n        # TODO 3: Decode the expected output and verify it matches original input\n        # TODO 4: Verify no padding characters (=) in encoded output\n        pass\n    \n    def test_url_safe_character_set(self):\n        \"\"\"Ensure only URL-safe characters in output.\"\"\" \n        # TODO 1: Create test input that would generate +, /, = in regular base64\n        # TODO 2: Encode using base64url_encode\n        # TODO 3: Assert no +, /, or = characters in result\n        # TODO 4: Assert only A-Z, a-z, 0-9, -, _ characters present\n        pass\n    \n    def test_round_trip_consistency(self):\n        \"\"\"Test encode/decode round trip.\"\"\"\n        # TODO 1: Generate random byte sequences of various lengths\n        # TODO 2: Encode each sequence with base64url_encode  \n        # TODO 3: Decode the result with base64url_decode\n        # TODO 4: Assert decoded bytes match original exactly\n        pass\n\nclass TestTokenStructureAssembly:\n    \"\"\"Test JWT token structure assembly.\"\"\"\n    \n    def test_three_segment_format(self, sample_header, sample_payload):\n        \"\"\"Verify proper three-segment token format.\"\"\"\n        # TODO 1: Encode header and payload using encode_token_parts\n        # TODO 2: Create mock signature string\n        # TODO 3: Assemble token with assemble_token\n        # TODO 4: Assert result has exactly 3 segments separated by dots\n        # TODO 5: Assert no empty segments\n        pass\n```\n\n**Security Test Implementation:**\n\n```python  \n# tests/security/test_timing_attacks.py - Security validation\nimport pytest\nimport secrets\nfrom jwt_library.signing import constant_time_compare\nfrom tests.conftest import TimingTestHelper\n\nclass TestTimingAttackResistance:\n    \"\"\"Validate resistance to timing side-channel attacks.\"\"\"\n    \n    def test_constant_time_signature_comparison(self):\n        \"\"\"Test constant-time comparison implementation.\"\"\"\n        # TODO 1: Generate two 32-byte signatures that differ in first byte\n        # TODO 2: Generate two 32-byte signatures that differ in last byte  \n        # TODO 3: Measure execution time of constant_time_compare for each pair\n        # TODO 4: Use TimingTestHelper.detect_timing_difference to check significance\n        # TODO 5: Assert no statistically significant timing difference detected\n        pass\n    \n    def test_key_length_timing(self):\n        \"\"\"Verify key validation timing is consistent.\"\"\"\n        # TODO 1: Create correct-length key and too-short key\n        # TODO 2: Measure validation time for both keys over many iterations\n        # TODO 3: Assert timing difference is not statistically significant\n        # TODO 4: Verify both keys produce appropriate validation results\n        pass\n\nclass TestAlgorithmConfusionResistance:\n    \"\"\"Test resistance to algorithm confusion attacks.\"\"\"\n    \n    def test_none_algorithm_rejection(self, sample_header, sample_payload, test_secret_key):\n        \"\"\"Verify 'none' algorithm is rejected.\"\"\"\n        # TODO 1: Create token with alg: \"none\" in header\n        # TODO 2: Attempt verification with any secret key\n        # TODO 3: Assert verification fails with appropriate error\n        # TODO 4: Verify error message doesn't leak algorithm support details\n        pass\n```\n\n**Milestone Checkpoints:**\n\n**Milestone 1 Checkpoint:**\nRun `python -m pytest tests/unit/test_encoding.py -v` and verify:\n- All Base64URL encoding tests pass\n- Token structure assembly creates proper three-segment format  \n- Round-trip encoding/decoding preserves data exactly\n- No URL-unsafe characters appear in encoded output\n\n**Milestone 2 Checkpoint:**  \nRun `python -m pytest tests/unit/test_signing.py tests/security/test_timing_attacks.py -v` and verify:\n- HMAC-SHA256 signatures match RFC test vectors exactly\n- Signature verification correctly accepts valid signatures\n- Signature verification correctly rejects invalid signatures  \n- Timing attack tests show no statistically significant timing differences\n- Key strength validation rejects weak keys appropriately\n\n**Milestone 3 Checkpoint:**\nRun `python -m pytest tests/unit/test_validation.py tests/integration/test_end_to_end.py -v` and verify:\n- Time-based claim validation correctly handles expiration and not-before\n- Clock skew tolerance works within configured leeway periods\n- Issuer and audience validation enforces allowlist restrictions\n- Custom claims are extracted and validated correctly\n- Complete end-to-end token creation and verification workflow succeeds\n\n**Debugging Tips:**\n\n| Test Failure Symptom | Likely Cause | Diagnostic Steps | Resolution |\n|---------------------|--------------|------------------|------------|\n| Base64URL test failures | Incorrect character substitution or padding handling | Print hex dump of encoded bytes, check for +/= characters | Use URL-safe Base64 alphabet, remove padding correctly |\n| Timing attack detection | Non-constant-time comparison implementation | Add debug timing prints, check for early returns | Implement proper constant-time algorithm |\n| RFC vector mismatches | Incorrect HMAC input or key handling | Log signing input string and key bytes | Verify header.payload concatenation and key encoding |\n| Claims validation errors | Incorrect timestamp comparison or missing leeway | Print current time vs claim timestamps with leeway applied | Check Unix timestamp conversion and arithmetic |\n| End-to-end failures | Component integration issues | Test each component individually, check data flow | Verify data structures match between components |\n\n\n## Debugging Guide\n\n> **Milestone(s):** All three milestones - debugging techniques for JWT structure issues (Milestone 1), HMAC signing problems (Milestone 2), and claims validation failures (Milestone 3)\n\nBuilding a secure JWT library involves intricate interactions between encoding, cryptography, and time-sensitive validation logic. Even experienced developers encounter subtle bugs that can compromise security or break authentication flows. This debugging guide provides systematic approaches to diagnose and resolve the most common implementation issues across all three milestones.\n\n**Mental Model: Detective Investigation**: Think of debugging JWT issues like conducting a criminal investigation. You have evidence (error messages, token contents, timestamps), witnesses (logs, test outputs), and a crime scene (the failing code). Your job is to follow the evidence systematically, ruling out innocent suspects (working components) and identifying the real culprit. Just as detectives use forensic tools to analyze evidence, JWT debugging requires specialized tools and techniques to examine token contents, verify signatures, and validate timing assumptions.\n\nThe key insight is that JWT bugs often manifest far from their root cause. A claims validation failure might actually stem from incorrect Base64URL encoding in Milestone 1, or a signature verification problem might be caused by JSON serialization inconsistencies. Effective JWT debugging requires understanding the entire token lifecycle and systematically eliminating possibilities.\n\n### Encoding and Parsing Issues\n\nThe JWT structure implementation from Milestone 1 forms the foundation for all token operations. Encoding problems create tokens that appear valid but fail verification in subtle ways. Base64URL encoding and JSON serialization bugs are particularly insidious because they often produce tokens that look correct but contain invisible formatting issues.\n\n**Understanding Base64URL Encoding Failures**\n\nBase64URL encoding differs from standard Base64 in three critical ways: character set replacement, padding removal, and URL safety requirements. The most common mistake is using Python's standard `base64.b64encode()` instead of the URL-safe variant, which produces tokens containing `+` and `/` characters that break when transmitted in URLs or HTTP headers.\n\nThe `base64url_encode()` function must handle padding removal correctly. Standard Base64 uses `=` characters for padding, but Base64URL omits these entirely. Many implementations forget to strip padding after encoding, creating tokens that work locally but fail when processed by other JWT libraries expecting strict Base64URL format.\n\n| Encoding Issue | Symptom | Root Cause | Diagnostic Method |\n|---|---|---|---|\n| Wrong character set | Token contains `+` or `/` | Using standard Base64 | Check token content for forbidden characters |\n| Incorrect padding | Token ends with `=` characters | Not stripping padding | Examine raw token string |\n| JSON key ordering | Inconsistent signatures | Non-deterministic serialization | Compare JSON output across runs |\n| Unicode handling | Signature verification fails | Encoding string to bytes incorrectly | Test with non-ASCII payload content |\n| Line breaks in output | Malformed token structure | Base64 encoding with line wrapping | Check for `\\n` characters in encoded parts |\n\n**JSON Serialization Consistency Problems**\n\nThe `serialize_header()` and `serialize_payload()` functions must produce identical JSON output for the same input data across all invocations. Python's `json.dumps()` with `sort_keys=True` ensures consistent key ordering, but developers often forget this parameter, leading to signatures that work sometimes but fail unpredictably.\n\nCustom claims processing introduces additional serialization challenges. The `JWTPayload.custom_claims` field contains arbitrary data that must serialize consistently. Nested objects, floating-point numbers, and special values like `None` can cause serialization inconsistencies that break signature verification.\n\nConsider a payload containing a custom claim with a floating-point timestamp: `{\"user_score\": 98.7654321}`. Different JSON serializers might produce `98.7654321` or `98.76543210000001` due to floating-point precision differences. The `serialize_payload()` function must handle these edge cases explicitly.\n\n**Token Structure Parsing Failures**\n\nThe `parse_token_structure()` function splits incoming tokens into header, payload, and signature components. Malformed tokens can cause parsing failures that expose internal errors instead of returning appropriate `MalformedTokenError` exceptions. Common parsing issues include tokens with fewer than three parts, empty parts, or parts containing invalid Base64URL characters.\n\nToken assembly problems occur when the `assemble_token()` function incorrectly concatenates encoded parts. The function must join the three parts with exactly one dot character: `header.payload.signature`. Extra dots, missing dots, or whitespace characters create structurally invalid tokens.\n\n> **Key Insight**: Base64URL encoding errors often manifest as signature verification failures rather than encoding errors, making them difficult to diagnose. Always verify encoding correctness before investigating cryptographic issues.\n\n**⚠️ Pitfall: Silent Encoding Corruption**\n\nThe most dangerous encoding bug is silent corruption where `base64url_encode()` produces output that looks valid but contains subtle errors. This happens when developers implement custom Base64URL encoding incorrectly, producing tokens that pass basic structure validation but fail cryptographic verification.\n\nTo avoid this pitfall, always test your encoding implementation against known reference vectors from the JWT specification. The `base64url_decode()` function should perfectly round-trip with `base64url_encode()` for all inputs.\n\n### Signature Verification Problems\n\nHMAC-SHA256 signature verification from Milestone 2 involves precise cryptographic operations where small implementation errors create complete security failures. Signature bugs are particularly dangerous because they can allow invalid tokens to appear valid, completely compromising authentication security.\n\n**HMAC Computation Consistency**\n\nThe `HMACSignerHS256` class must produce identical signatures for identical signing inputs across all platforms and execution environments. HMAC computation depends on the exact byte sequence of the signing input, which means any differences in string encoding, JSON serialization, or Base64URL encoding will produce different signatures.\n\nThe most common HMAC bug occurs in the `create_signing_input()` function when developers accidentally introduce encoding inconsistencies. The signing input must be the exact string `encoded_header.encoded_payload` with no additional whitespace, encoding transformations, or character substitutions.\n\n| Signature Issue | Symptom | Root Cause | Verification Method |\n|---|---|---|---|\n| Key encoding problems | All signatures fail | Converting key incorrectly | Test with known binary key |\n| String encoding issues | Inconsistent signatures | Unicode vs bytes confusion | Compare byte arrays |\n| Signing input format | Verification always fails | Wrong separator or format | Print signing input hex |\n| HMAC library usage | Cryptographic errors | Wrong hash algorithm | Verify SHA256 usage |\n| Constant-time comparison | Timing attacks possible | Using `==` for signature comparison | Implement secure comparison |\n\n**Secret Key Handling Errors**\n\nThe `SecureKeyHandler` class manages cryptographic keys that must meet specific security requirements. The `validate_key_strength()` function enforces a minimum key length of 32 bytes, but developers often provide keys as strings without considering encoding implications.\n\nWhen a key is provided as a UTF-8 string, it must be encoded to bytes using consistent encoding. Different encoding choices (UTF-8, Latin-1, ASCII) produce different byte sequences, leading to different HMAC signatures. The key handling system must document and enforce its encoding expectations clearly.\n\nKey generation using `generate_secure_key()` must produce cryptographically random bytes suitable for HMAC operations. Using predictable key generation methods or insufficient entropy sources creates keys that appear to work but provide no security against determined attackers.\n\n**Constant-Time Comparison Implementation**\n\nThe `constant_time_compare()` function prevents timing side-channel attacks by ensuring signature comparison takes the same amount of time regardless of input differences. Naive implementations using Python's `==` operator leak timing information that allows attackers to forge signatures.\n\nA secure constant-time comparison must process every byte of both signatures even when early differences are detected. The comparison must also handle length differences securely, avoiding early returns that leak length information.\n\n```python\n# WRONG - leaks timing information\ndef insecure_compare(a, b):\n    return a == b  # Early termination on first difference\n\n# CORRECT - constant time for same-length inputs\ndef constant_time_compare(a, b):\n    if len(a) != len(b):\n        return False\n    result = 0\n    for x, y in zip(a, b):\n        result |= ord(x) ^ ord(y)\n    return result == 0\n```\n\n**Signature Format and Encoding**\n\nThe `sign()` method must produce Base64URL-encoded signatures that match the JWT specification exactly. HMAC-SHA256 produces 32-byte binary signatures that must be encoded using the same Base64URL rules applied to header and payload sections.\n\nSignature verification in the `verify()` method must decode the provided signature back to binary form before comparison. Base64URL decoding errors indicate malformed tokens that should trigger appropriate error handling rather than cryptographic failures.\n\n> **Key Insight**: Signature verification bugs often appear as intermittent failures that work in development but fail in production due to environment differences in string encoding, JSON serialization, or cryptographic library versions.\n\n**⚠️ Pitfall: Algorithm Confusion Attacks**\n\nA critical security vulnerability occurs when the signature verification process doesn't validate that the token's algorithm claim matches the expected algorithm. An attacker can change the `alg` header field from `HS256` to `none` or a public-key algorithm, potentially bypassing signature verification entirely.\n\nThe verification process must explicitly check that the header contains `\"alg\": \"HS256\"` before attempting HMAC verification. Tokens with unexpected algorithm values should be rejected immediately.\n\n### Claims Validation Issues\n\nClaims validation from Milestone 3 involves time-sensitive logic that interacts with system clocks, timezone handling, and application-specific business rules. Time-based validation is particularly error-prone because it depends on external factors like server time synchronization and clock skew between systems.\n\n**Time-Based Validation Complexity**\n\nThe `TimeValidator` class handles expiration (`exp`), not-before (`nbf`), and issued-at (`iat`) claims that depend on accurate time comparison. Clock skew between token-issuing and token-validating systems can cause valid tokens to be rejected or expired tokens to be accepted.\n\nThe `DEFAULT_LEEWAY_SECONDS` constant provides a 300-second tolerance window for clock skew, but applications with strict security requirements might need shorter leeway periods. Conversely, distributed systems with poor time synchronization might require longer leeway periods.\n\nTime validation bugs often manifest as tokens that work in development but fail in production due to deployment time differences. The `utc_now()` function must return UTC timestamps consistently across all environments, avoiding timezone-related issues that cause validation failures.\n\n| Validation Issue | Symptom | Root Cause | Debugging Approach |\n|---|---|---|---|\n| Clock skew problems | Valid tokens rejected | Time differences between servers | Compare server timestamps |\n| Timezone confusion | Intermittent validation failures | Mixing UTC and local time | Standardize on UTC everywhere |\n| Leeway configuration | Unexpected expiration behavior | Wrong leeway period | Test with known timestamps |\n| Missing claims | Required claims not validated | Incomplete validation logic | Check claim presence explicitly |\n| Audience format | Audience validation fails | String vs array confusion | Handle both audience formats |\n\n**Identity Validation Edge Cases**\n\nThe `IdentityValidator` class verifies issuer (`iss`) and audience (`aud`) claims against application-specific allowlists. Issuer validation must perform exact string matching against the `allowed_issuers` list, but case sensitivity and whitespace handling can cause validation failures for otherwise valid tokens.\n\nAudience validation is complicated by the JWT specification's allowance for both string and array formats. A token might contain `\"aud\": \"api.example.com\"` or `\"aud\": [\"api.example.com\", \"mobile.example.com\"]`. The validation logic must handle both formats correctly while matching against the expected audience value.\n\nCustom claims processing in the `CustomClaimsValidator` introduces application-specific validation logic that can fail in unexpected ways. Custom claims might contain nested objects, arrays, or special values that require careful validation to prevent security issues or application errors.\n\n**Missing Required Claims Handling**\n\nThe `ValidationContext.required_claims` field specifies claims that must be present in every token. The `MissingRequiredClaimError` exception should provide specific information about which claims are missing to aid in debugging, but without leaking sensitive information in error messages.\n\nRequired claims validation must distinguish between claims that are missing entirely and claims that are present but invalid. A token with an empty `sub` field might satisfy presence requirements but fail business logic validation, requiring different error handling approaches.\n\n**Validation Context Configuration**\n\nThe `create_strict_context()`, `create_permissive_context()`, and `create_custom_context()` functions create validation configurations for different security requirements. Strict contexts reject tokens with any validation issues, while permissive contexts might allow missing optional claims or longer leeway periods.\n\nConfiguration bugs often appear when development uses permissive validation but production requires strict validation, causing tokens that work in testing to fail in production. Validation context settings should be explicitly documented and tested across all deployment environments.\n\n> **Key Insight**: Claims validation failures often indicate configuration mismatches between token issuers and validators rather than implementation bugs. Always verify that validation context settings match the security requirements of your deployment environment.\n\n**⚠️ Pitfall: Temporal Edge Cases**\n\nTime-based validation becomes unreliable around edge cases like leap seconds, daylight saving time transitions, and system clock adjustments. The `is_expired()` and `is_not_before()` functions must handle these edge cases gracefully without creating security vulnerabilities.\n\nA particularly dangerous edge case occurs when system clocks move backward due to NTP synchronization or manual adjustment. Tokens that were expired before the clock adjustment might become valid again, potentially allowing replay attacks or privilege escalation.\n\n### Debugging Tools and Techniques\n\nEffective JWT debugging requires a combination of specialized tools, systematic diagnostic procedures, and deep understanding of the token format and validation process. The debugging process should progress from high-level token structure validation to detailed cryptographic and claims analysis.\n\n**JWT.io Debugger Integration**\n\nThe JWT.io online debugger provides immediate visual feedback about token structure, claims, and signature validation. When debugging JWT library issues, always paste problematic tokens into JWT.io to verify basic structure and content before investigating implementation-specific problems.\n\nThe debugger shows the decoded header and payload in human-readable JSON format, making it easy to spot encoding issues, malformed claims, or unexpected content. The signature verification section can validate signatures using provided secrets, helping isolate whether problems lie in token generation or verification logic.\n\nHowever, JWT.io has limitations for debugging production issues. Never paste production tokens containing sensitive information into online tools. Instead, create test tokens with similar structure but fake data to verify behavior without security risks.\n\n**Systematic Diagnostic Procedures**\n\nJWT debugging should follow a structured process that eliminates possibilities systematically rather than randomly trying fixes. Start with basic structural validation before moving to cryptographic or claims-specific issues.\n\n| Debug Phase | Validation Steps | Tools Required | Success Criteria |\n|---|---|---|---|\n| Structure Check | Token contains three dot-separated parts | String splitting, length validation | Exactly 3 non-empty parts |\n| Encoding Check | Each part uses valid Base64URL | Base64URL decoder | No decoding errors |\n| Header Validation | Header contains required algorithm | JSON parser | Valid `alg` and `typ` fields |\n| Payload Validation | Payload contains expected claims | JSON parser, schema validator | Required claims present |\n| Signature Check | Signature matches computed value | HMAC computation | Signatures match exactly |\n| Claims Validation | Time and identity claims valid | System clock, configuration | All validations pass |\n\n**Self-Verification Techniques**\n\nThe most powerful debugging technique for JWT libraries is self-verification: creating a token with your library and immediately verifying it with the same library. This round-trip test exposes encoding inconsistencies, serialization problems, and configuration issues without involving external systems.\n\nSelf-verification should test edge cases like tokens with maximum allowed payload sizes, tokens with all possible claim types, and tokens created at boundary times (just before expiration, exactly at not-before time). These tests reveal issues that might not appear with simple happy-path testing.\n\n**Error Context and Information Disclosure**\n\nProduction JWT libraries must balance debugging information with security requirements. The `ValidationFailureContext` class provides structured error information that can be logged securely while providing sanitized error messages to external callers.\n\nDebug logging should adapt to the `SecurityContext` environment variable, providing detailed information in development and audit environments while limiting information disclosure in production. The `log_validation_failure()` function should never log secret keys, full token contents, or other sensitive information that could compromise security.\n\n```python\ndef create_debug_context(failure_type, component, operation):\n    if os.getenv('SECURITY_CONTEXT') == SecurityContext.DEVELOPMENT:\n        return ValidationFailureContext(\n            component=component,\n            operation=operation,\n            failure_type=failure_type,\n            severity=ErrorSeverity.HIGH,\n            debug_info={\"full_details\": True},\n            safe_message=f\"Detailed error in {component}.{operation}\"\n        )\n    else:\n        return ValidationFailureContext(\n            component=component,\n            operation=operation,\n            failure_type=failure_type,\n            severity=ErrorSeverity.HIGH,\n            debug_info={},\n            safe_message=\"Authentication token validation failed\"\n        )\n```\n\n**Reference Test Vector Validation**\n\nThe JWT specification includes reference test vectors with known inputs and expected outputs for each operation. Implementing these test vectors as part of your debugging process ensures that your library produces specification-compliant results.\n\nReference vectors should cover all supported algorithms, claim types, and edge cases. When debugging cryptographic issues, compare your HMAC computation results with reference vectors to isolate whether problems lie in key handling, signing input generation, or signature computation.\n\n**Performance and Timing Analysis**\n\nJWT libraries must balance security with performance, particularly in high-throughput applications. Debugging performance issues requires understanding the computational cost of each validation step and identifying bottlenecks that might indicate implementation problems.\n\nThe `constant_time_compare()` function should complete in consistent time regardless of input differences, but other validation steps can vary significantly based on token content and validation context. Time-based claims validation should be nearly instantaneous, while complex custom claims processing might require more computational resources.\n\n**⚠️ Pitfall: Production Debugging Without Security Context**\n\nThe most dangerous debugging mistake is enabling detailed error logging in production without considering information disclosure risks. Debug logs containing token contents, secret keys, or detailed validation failure reasons can expose sensitive information to attackers.\n\nAlways implement security-aware logging that provides detailed information in development environments but sanitized error messages in production. Use structured logging with appropriate log levels to ensure sensitive debugging information doesn't reach unauthorized log consumers.\n\n### Implementation Guidance\n\nBuilding robust debugging capabilities into your JWT library requires careful instrumentation and structured error handling that provides useful diagnostic information without compromising security.\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|---|---|---|\n| Logging | Python `logging` module | `structlog` with JSON output |\n| Error Handling | Standard exceptions | Custom exception hierarchy |\n| Testing | `unittest` with manual vectors | `pytest` with parameterized tests |\n| Time Handling | `datetime` module | `arrow` or `pendulum` for advanced cases |\n| Debug Output | Print statements | Structured logging with context |\n\n**Recommended File Structure:**\n```\njwt-library/\n  src/jwt_library/\n    core/\n      __init__.py\n      encoder.py              ← Token encoding (Milestone 1)\n      signer.py              ← HMAC signing (Milestone 2)\n      validator.py           ← Claims validation (Milestone 3)\n    exceptions/\n      __init__.py\n      base.py                ← Base exception classes\n      validation.py          ← Validation-specific exceptions\n      structural.py          ← Structure and encoding exceptions\n    debug/\n      __init__.py\n      diagnostics.py         ← Debugging utilities\n      test_vectors.py        ← Reference test cases\n      tools.py              ← Debug helper functions\n  tests/\n    unit/\n      test_encoding.py       ← Milestone 1 tests\n      test_signing.py        ← Milestone 2 tests\n      test_validation.py     ← Milestone 3 tests\n    integration/\n      test_end_to_end.py     ← Complete workflows\n      test_debugging.py      ← Debug scenario tests\n    vectors/\n      rfc_test_vectors.py    ← Official specification tests\n```\n\n**Debug Utilities Infrastructure Code:**\n\n```python\n\"\"\"\nDebug utilities for JWT library diagnostics and troubleshooting.\nCopy this code as-is and import the functions you need.\n\"\"\"\n\nimport json\nimport time\nimport hashlib\nimport binascii\nfrom datetime import datetime, timezone\nfrom typing import Dict, List, Any, Optional, Union\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nclass ErrorSeverity(Enum):\n    CRITICAL = \"critical\"\n    HIGH = \"high\"\n    MEDIUM = \"medium\"\n    LOW = \"low\"\n\nclass SecurityContext(Enum):\n    DEVELOPMENT = \"development\"\n    PRODUCTION = \"production\"\n    AUDIT = \"audit\"\n\n@dataclass\nclass ValidationFailureContext:\n    component: str\n    operation: str\n    failure_type: str\n    severity: ErrorSeverity\n    debug_info: Dict[str, Any]\n    safe_message: str\n    \n    def get_safe_message(self) -> str:\n        \"\"\"Return external-safe error message without sensitive details.\"\"\"\n        return self.safe_message\n    \n    def get_debug_info(self) -> Dict[str, Any]:\n        \"\"\"Return internal diagnostic information for logging.\"\"\"\n        return self.debug_info\n\ndef log_validation_failure(context: ValidationFailureContext):\n    \"\"\"Security-aware error logging that adapts to deployment context.\"\"\"\n    import os\n    import logging\n    \n    logger = logging.getLogger(\"jwt_library.debug\")\n    security_context = os.getenv('SECURITY_CONTEXT', SecurityContext.PRODUCTION.value)\n    \n    if security_context == SecurityContext.DEVELOPMENT.value:\n        logger.error(\n            f\"JWT validation failure: {context.component}.{context.operation} - \"\n            f\"{context.failure_type} - Debug info: {context.debug_info}\"\n        )\n    elif security_context == SecurityContext.AUDIT.value:\n        logger.warning(\n            f\"JWT validation failure: {context.component}.{context.operation} - \"\n            f\"{context.failure_type} - Severity: {context.severity.value}\"\n        )\n    else:  # PRODUCTION\n        logger.info(f\"Authentication validation failed - {context.safe_message}\")\n\ndef validate_base64url_format(data: str, part_name: str) -> None:\n    \"\"\"Validate Base64URL character set and format.\"\"\"\n    import re\n    \n    # Base64URL uses A-Z, a-z, 0-9, -, _ (no padding)\n    base64url_pattern = re.compile(r'^[A-Za-z0-9_-]*$')\n    \n    if not base64url_pattern.match(data):\n        invalid_chars = set(data) - set('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_')\n        raise ValueError(f\"Invalid characters in {part_name}: {invalid_chars}\")\n    \n    if '=' in data:\n        raise ValueError(f\"Base64URL {part_name} should not contain padding characters\")\n\ndef diagnose_token_structure(token: str) -> Dict[str, Any]:\n    \"\"\"Comprehensive token structure analysis for debugging.\"\"\"\n    diagnosis = {\n        \"valid_structure\": False,\n        \"part_count\": 0,\n        \"parts_analysis\": {},\n        \"encoding_issues\": [],\n        \"recommendations\": []\n    }\n    \n    # Basic structure check\n    parts = token.split('.')\n    diagnosis[\"part_count\"] = len(parts)\n    \n    if len(parts) != 3:\n        diagnosis[\"recommendations\"].append(\n            f\"Expected 3 parts, found {len(parts)}. JWT format is header.payload.signature\"\n        )\n        return diagnosis\n    \n    # Analyze each part\n    part_names = [\"header\", \"payload\", \"signature\"]\n    for i, (part, name) in enumerate(zip(parts, part_names)):\n        analysis = {\n            \"length\": len(part),\n            \"empty\": len(part) == 0,\n            \"base64url_valid\": False,\n            \"content\": None\n        }\n        \n        if len(part) == 0:\n            diagnosis[\"encoding_issues\"].append(f\"Empty {name} part\")\n            continue\n        \n        # Check Base64URL format\n        try:\n            validate_base64url_format(part, name)\n            analysis[\"base64url_valid\"] = True\n        except ValueError as e:\n            diagnosis[\"encoding_issues\"].append(f\"{name}: {str(e)}\")\n        \n        # Try to decode content (header and payload only)\n        if analysis[\"base64url_valid\"] and i < 2:  # Skip signature decoding\n            try:\n                from jwt_library.core.encoder import base64url_decode\n                decoded = base64url_decode(part)\n                if i < 2:  # Header and payload are JSON\n                    analysis[\"content\"] = json.loads(decoded.decode('utf-8'))\n            except Exception as e:\n                diagnosis[\"encoding_issues\"].append(f\"{name} decoding failed: {str(e)}\")\n        \n        diagnosis[\"parts_analysis\"][name] = analysis\n    \n    diagnosis[\"valid_structure\"] = len(diagnosis[\"encoding_issues\"]) == 0\n    return diagnosis\n\ndef compare_hmac_signatures(expected: str, actual: str, signing_input: str, key: bytes) -> Dict[str, Any]:\n    \"\"\"Detailed HMAC signature comparison for debugging.\"\"\"\n    import hmac\n    \n    comparison = {\n        \"signatures_match\": expected == actual,\n        \"expected_signature\": expected,\n        \"actual_signature\": actual,\n        \"signing_input_length\": len(signing_input),\n        \"signing_input_hash\": hashlib.sha256(signing_input.encode()).hexdigest()[:16],\n        \"key_length\": len(key),\n        \"key_hash\": hashlib.sha256(key).hexdigest()[:16],\n        \"recomputed_signature\": None\n    }\n    \n    # Recompute signature independently\n    try:\n        signature_bytes = hmac.new(key, signing_input.encode('utf-8'), hashlib.sha256).digest()\n        from jwt_library.core.encoder import base64url_encode\n        recomputed = base64url_encode(signature_bytes)\n        comparison[\"recomputed_signature\"] = recomputed\n        comparison[\"recomputation_matches_expected\"] = (recomputed == expected)\n        comparison[\"recomputation_matches_actual\"] = (recomputed == actual)\n    except Exception as e:\n        comparison[\"recomputation_error\"] = str(e)\n    \n    return comparison\n\ndef analyze_time_claims(payload: Dict[str, Any], leeway_seconds: int = 300) -> Dict[str, Any]:\n    \"\"\"Analyze time-based claims for debugging validation issues.\"\"\"\n    import time\n    \n    now = int(time.time())\n    analysis = {\n        \"current_timestamp\": now,\n        \"current_datetime\": datetime.fromtimestamp(now, tz=timezone.utc).isoformat(),\n        \"leeway_seconds\": leeway_seconds,\n        \"claims_analysis\": {}\n    }\n    \n    time_claims = [\"exp\", \"nbf\", \"iat\"]\n    for claim in time_claims:\n        if claim in payload:\n            claim_value = payload[claim]\n            claim_analysis = {\n                \"value\": claim_value,\n                \"datetime\": datetime.fromtimestamp(claim_value, tz=timezone.utc).isoformat(),\n                \"seconds_from_now\": claim_value - now,\n                \"within_leeway\": abs(claim_value - now) <= leeway_seconds\n            }\n            \n            if claim == \"exp\":\n                claim_analysis[\"is_expired\"] = claim_value < (now - leeway_seconds)\n            elif claim == \"nbf\":\n                claim_analysis[\"is_future\"] = claim_value > (now + leeway_seconds)\n            elif claim == \"iat\":\n                claim_analysis[\"is_reasonable\"] = -86400 <= (claim_value - now) <= leeway_seconds\n            \n            analysis[\"claims_analysis\"][claim] = claim_analysis\n        else:\n            analysis[\"claims_analysis\"][claim] = {\"present\": False}\n    \n    return analysis\n```\n\n**Core Debugging Function Skeletons:**\n\n```python\ndef debug_token_creation(header: JWTHeader, payload: JWTPayload, secret_key: bytes) -> Dict[str, Any]:\n    \"\"\"\n    Comprehensive debugging for token creation process.\n    Returns detailed information about each step in token generation.\n    \"\"\"\n    debug_info = {\"steps\": [], \"intermediate_values\": {}, \"final_result\": None}\n    \n    # TODO 1: Record header serialization and encoding\n    # Store serialized JSON, Base64URL encoded result, any encoding issues\n    \n    # TODO 2: Record payload serialization and encoding  \n    # Store serialized JSON, Base64URL encoded result, custom claims handling\n    \n    # TODO 3: Record signing input creation\n    # Store exact signing input string, length, character encoding\n    \n    # TODO 4: Record HMAC computation\n    # Store signature bytes (hex), Base64URL encoded signature, key validation\n    \n    # TODO 5: Record final token assembly\n    # Store assembled token, part lengths, structure validation\n    \n    # TODO 6: Perform self-verification test\n    # Try to verify the created token immediately, record any failures\n    \n    return debug_info\n\ndef debug_token_verification(token: str, secret_key: bytes, context: ValidationContext) -> Dict[str, Any]:\n    \"\"\"\n    Step-by-step debugging for token verification process.\n    Returns detailed information about each validation step.\n    \"\"\"\n    debug_info = {\"validation_steps\": [], \"failures\": [], \"context\": context}\n    \n    # TODO 1: Analyze token structure\n    # Use diagnose_token_structure() to check basic format\n    \n    # TODO 2: Debug signature verification\n    # Extract signature, recompute, compare with detailed logging\n    \n    # TODO 3: Debug claims validation\n    # Check each claim type with analyze_time_claims() and identity validation\n    \n    # TODO 4: Record validation context effects\n    # Show how leeway, required claims, etc. affect validation\n    \n    # TODO 5: Provide specific recommendations\n    # Based on failures found, suggest concrete fixes\n    \n    return debug_info\n\ndef create_test_scenarios() -> List[Dict[str, Any]]:\n    \"\"\"\n    Generate comprehensive test scenarios for debugging various failure modes.\n    Returns list of test cases with expected outcomes.\n    \"\"\"\n    scenarios = []\n    \n    # TODO 1: Create encoding failure scenarios\n    # Tokens with Base64URL issues, JSON problems, structure errors\n    \n    # TODO 2: Create signature failure scenarios  \n    # Wrong keys, algorithm confusion, timing attack tests\n    \n    # TODO 3: Create claims validation scenarios\n    # Expired tokens, future tokens, missing claims, wrong audience\n    \n    # TODO 4: Create edge case scenarios\n    # Clock skew, leap seconds, maximum sizes, Unicode content\n    \n    return scenarios\n```\n\n**Milestone Checkpoints:**\n\n**After Milestone 1 (JWT Structure):**\n- Run `python -m jwt_library.debug.diagnostics` with test tokens\n- Expected: Clean structure analysis with no encoding issues\n- Verify: `diagnose_token_structure()` returns `valid_structure: True` for your tokens\n- Debug: If structure fails, check Base64URL character set and padding removal\n\n**After Milestone 2 (HMAC Signing):**\n- Use `compare_hmac_signatures()` to verify signature computation\n- Expected: All three signature values (expected, actual, recomputed) match exactly\n- Verify: Self-verification test passes when creating and immediately verifying tokens\n- Debug: If signatures differ, check signing input format and key encoding\n\n**After Milestone 3 (Claims Validation):**\n- Test `analyze_time_claims()` with tokens at various time boundaries\n- Expected: Time-based validations respect leeway settings correctly\n- Verify: Expired and future tokens are rejected appropriately\n- Debug: If time validation fails, check system clock and leeway configuration\n\n\n## Future Extensions\n\n> **Milestone(s):** Foundation for extending beyond all three milestones - demonstrates how the JWT structure (Milestone 1), HMAC signing (Milestone 2), and claims validation (Milestone 3) components provide an extensible foundation for advanced features\n\nThe JWT library architecture we've designed provides a solid foundation for stateless authentication, but real-world applications often demand capabilities beyond basic HMAC-SHA256 signing and standard claims validation. Understanding how to extend the library while maintaining security and architectural integrity is crucial for evolving authentication systems. This section explores three major extension categories: additional cryptographic algorithms, performance optimizations, and advanced JWT features that enterprise applications commonly require.\n\n### Mental Model: The Security Toolkit Evolution\n\nThink of our JWT library as a master locksmith's toolkit that starts with essential tools but grows over time. Initially, the toolkit contains reliable basics: a sturdy key cutter (HMAC-SHA256 signing), measuring tools (claims validation), and assembly equipment (token encoding). As the locksmith encounters more sophisticated security challenges, they add specialized tools: precision instruments for delicate work (RSA signatures), high-speed equipment for volume operations (token caching), and advanced mechanisms for complex scenarios (key rotation systems). Each new tool integrates with the existing toolkit's foundation, sharing common principles while adding specialized capabilities. The locksmith doesn't replace their reliable basics—they enhance them with complementary tools that work together seamlessly.\n\nThis evolution mirrors how JWT libraries expand. The core encoding, signing, and validation components remain unchanged, but new algorithm implementations, optimization layers, and advanced features integrate through well-defined interfaces. The architecture accommodates growth while preserving the security properties and design principles that make the foundation trustworthy.\n\n### Extension Architecture Principles\n\nBefore examining specific extensions, we must establish architectural principles that guide library evolution. These principles ensure that new features enhance rather than compromise the existing security model.\n\n**Interface Stability**: The core `create_token` and `verify_token` functions maintain their signatures as the primary library interface. Extensions add new optional parameters or configuration objects rather than breaking existing integrations. This stability protects applications that depend on the library while enabling access to new capabilities.\n\n**Security Layering**: Each extension operates within the security boundaries established by the core architecture. Algorithm implementations cannot bypass signature verification, performance optimizations cannot weaken cryptographic properties, and advanced features cannot introduce timing vulnerabilities. The security context and constant-time comparison principles apply to all extensions.\n\n**Component Isolation**: Extensions integrate through well-defined interfaces without modifying core component internals. New signature algorithms implement standardized signer interfaces, performance enhancements operate as transparent middleware layers, and advanced features compose existing validation logic rather than replacing it.\n\n> **Design Principle: Backward Compatibility**\n> \n> Extensions must never break existing applications. A JWT created with basic HMAC-SHA256 signing continues to verify correctly even after RSA algorithm support is added. Configuration changes enable new features without affecting default behavior.\n\n### Additional Signature Algorithms\n\nThe HMAC-SHA256 implementation provides a solid foundation for symmetric key authentication, but production systems often require asymmetric cryptography for distributed verification scenarios. Public key algorithms like RSA and ECDSA enable token verification without sharing secret keys, while different hash functions provide varying security and performance characteristics.\n\n#### Mental Model: Document Authentication Methods\n\nConsider how important documents are authenticated in the physical world. A notary's seal (symmetric authentication) requires the same seal to create and verify signatures, limiting verification to parties who possess the physical seal. In contrast, a government official's signature (asymmetric authentication) can be verified by anyone who knows the official's handwriting patterns, without needing access to the official themselves. The verification process uses public knowledge (the signature style) while the creation process requires private knowledge (the actual ability to sign).\n\nJWT signature algorithms follow this same pattern. HMAC requires the same secret key for signing and verification, like sharing a notary seal between services. RSA uses a private key for signing but allows verification with a public key, enabling distributed verification without sharing sensitive material. ECDSA provides similar asymmetric properties with different mathematical foundations that offer performance and security trade-offs.\n\n#### RSA Signature Implementation (RS256)\n\nRSA with SHA-256 (RS256) provides asymmetric signing capabilities that enable distributed token verification. Unlike HMAC's shared secret approach, RS256 uses a private key for signing and a public key for verification, allowing multiple services to verify tokens without accessing signing credentials.\n\n**Algorithm Architecture**: The RS256 implementation follows the same signer interface as `HMACSignerHS256`, ensuring seamless integration with existing token creation workflows. The core difference lies in key management and signature computation, not in the overall signing process.\n\n| Component | Responsibility | Key Differences from HMAC |\n|-----------|----------------|---------------------------|\n| `RSASignerRS256` | Private key signing operations | Uses RSA private key instead of symmetric secret |\n| `RSAVerifierRS256` | Public key verification operations | Separate verifier class using public key |\n| `RSAKeyHandler` | RSA key pair management and validation | Handles key generation, storage, and public key distribution |\n| `PKCS1v15Padding` | RSA signature padding implementation | Implements PKCS#1 v1.5 padding for signature security |\n\n**Key Management Complexity**: RSA introduces significantly more complex key management requirements compared to HMAC's simple shared secrets. Private keys require secure storage with appropriate file permissions and potential hardware security module (HSM) integration. Public keys need reliable distribution mechanisms to verification services, often through certificate authorities or secure key distribution systems.\n\n**Signature Generation Process**:\n1. The RSA signer receives the signing input string (encoded header and payload)\n2. It computes a SHA-256 hash of the signing input\n3. The hash undergoes PKCS#1 v1.5 padding to reach the RSA key size\n4. The padded hash is encrypted with the RSA private key to produce the signature\n5. The signature is encoded using Base64URL for inclusion in the JWT token\n\n**Verification Process Modifications**:\n1. The verifier extracts the signature from the JWT token\n2. It decodes the signature from Base64URL to binary format\n3. The signature is decrypted using the RSA public key to recover the padded hash\n4. PKCS#1 v1.5 padding is removed and validated\n5. The recovered hash is compared against a freshly computed SHA-256 of the signing input\n6. Hash equality confirms signature validity\n\n> **Decision: Separate Signer and Verifier Classes for RSA**\n> - **Context**: RSA requires different keys for signing and verification operations, unlike HMAC's single shared secret\n> - **Options Considered**: Combined class with both keys, separate signer/verifier classes, or factory pattern with key type detection\n> - **Decision**: Implement separate `RSASignerRS256` and `RSAVerifierRS256` classes\n> - **Rationale**: Separation follows the principle of least privilege—verification services never receive private keys. It also simplifies key management and reduces the attack surface for each component\n> - **Consequences**: Slightly more complex initialization code, but much better security isolation and clearer component responsibilities\n\n#### ECDSA Implementation (ES256)\n\nElliptic Curve Digital Signature Algorithm with P-256 curve and SHA-256 (ES256) provides asymmetric authentication with smaller key sizes and potentially better performance than RSA. ECDSA signatures are probabilistic, producing different signature values for the same input, but all valid signatures verify correctly.\n\n**Mathematical Foundation**: ECDSA operates on elliptic curve mathematics rather than RSA's large integer factorization. This enables equivalent security levels with much smaller keys—a 256-bit ECDSA key provides roughly the same security as a 3072-bit RSA key, resulting in smaller tokens and faster operations.\n\n**Signature Variability**: Unlike RSA and HMAC signatures that are deterministic (same input always produces the same signature), ECDSA signatures incorporate randomness. Each signing operation produces a different signature value, but all signatures for the same input verify as valid. This property requires careful testing to ensure verification works correctly with signature variability.\n\n| ECDSA Component | Functionality | Unique Characteristics |\n|-----------------|---------------|------------------------|\n| `ECDSASignerES256` | P-256 curve signing | Probabilistic signatures with built-in randomness |\n| `ECDSAVerifierES256` | Signature verification on P-256 curve | Must handle signature format variations |\n| `P256CurveHandler` | Elliptic curve parameter management | Manages curve constants and point operations |\n| `ECDSASignatureEncoder` | DER/raw signature format conversion | Handles multiple signature encoding standards |\n\n**Implementation Considerations**: ECDSA signatures require careful attention to format handling, as different libraries and standards use varying signature encodings (DER, raw concatenation, or IEEE P1363 format). The implementation must choose a standard format and consistently apply it across signing and verification operations.\n\n#### Algorithm Selection Framework\n\nSupporting multiple signature algorithms requires a systematic approach to algorithm selection and instantiation. The framework must balance flexibility with security, preventing algorithm confusion attacks while enabling appropriate algorithm choice for different use cases.\n\n**Algorithm Registry Pattern**: A central registry maps algorithm identifiers (`HS256`, `RS256`, `ES256`) to appropriate signer and verifier implementations. This registry validates algorithm choices against security policies and instantiates the correct cryptographic components.\n\n```\nAlgorithm Selection Decision Flow:\n1. Extract algorithm identifier from JWT header\n2. Validate algorithm against allowed list in ValidationContext\n3. Check algorithm compatibility with provided key material\n4. Instantiate appropriate signer/verifier from registry\n5. Perform cryptographic operation with algorithm-specific implementation\n```\n\n**Security Policy Integration**: The `ValidationContext` expands to include allowed algorithm lists, preventing downgrade attacks where an attacker might modify a token's algorithm field to specify a weaker algorithm. For example, a system expecting RS256 tokens should reject HS256 tokens even if they verify correctly with the RSA public key treated as an HMAC secret.\n\n> **Decision: Explicit Algorithm Allowlists**\n> - **Context**: JWT's algorithm flexibility can enable attack scenarios where tokens are verified with unintended algorithms\n> - **Options Considered**: Accept any algorithm that verifies, require exact algorithm match, or use configurable allowlists\n> - **Decision**: Implement configurable algorithm allowlists in ValidationContext\n> - **Rationale**: Allowlists prevent algorithm confusion attacks while maintaining flexibility for systems that legitimately use multiple algorithms\n> - **Consequences**: Applications must explicitly configure allowed algorithms, but this prevents entire classes of cryptographic attacks\n\n#### Common Pitfalls in Algorithm Extensions\n\n⚠️ **Pitfall: Algorithm Confusion Attacks**\nAccepting tokens with any algorithm that happens to verify correctly can lead to security vulnerabilities. For example, if a system expects RS256 tokens but accepts HS256, an attacker might create an HS256 token using the RSA public key as the HMAC secret. Always validate the algorithm field against an explicit allowlist before verification.\n\n⚠️ **Pitfall: Key Format Mismatches**\nDifferent algorithms require different key formats (raw bytes for HMAC, PEM-encoded keys for RSA, specific curve parameters for ECDSA). Attempting to use the wrong key type with an algorithm results in cryptographic failures that may not be immediately obvious during testing. Implement key validation that checks format compatibility before attempting cryptographic operations.\n\n⚠️ **Pitfall: Signature Format Inconsistencies**\nECDSA signatures can be encoded in multiple formats (DER, raw bytes, IEEE P1363). Using different formats for signing and verification causes validation failures even with correct keys. Choose one format standard and apply it consistently across all ECDSA operations.\n\n⚠️ **Pitfall: Missing Security Parameter Validation**\nRSA and ECDSA have minimum security requirements (key sizes, curve parameters) that must be enforced. Accepting weak parameters (small RSA keys, weak curves) compromises security. Implement security parameter validation that rejects cryptographically weak configurations.\n\n### Performance Enhancements\n\nJWT operations involve cryptographic computations, JSON parsing, and Base64 encoding that can become performance bottlenecks in high-throughput applications. While security must never be compromised for performance, several optimization strategies can significantly improve library efficiency without weakening cryptographic properties.\n\n#### Mental Model: Document Processing Optimization\n\nImagine a busy government office that processes thousands of document authentication requests daily. Initially, each clerk handles documents one by one: checking format, verifying signatures, validating dates, and filing results. As volume increases, the office implements optimizations: clerks pre-process common document types, managers cache recently verified signature authorities, and the office batches similar documents for efficient processing. These optimizations maintain the same security standards while dramatically improving throughput.\n\nJWT performance optimization follows similar patterns. Token verification can be accelerated through caching verified tokens (like caching signature authorities), pre-parsing common header formats (like pre-processing document types), and batching multiple token operations (like processing similar documents together). Each optimization preserves security properties while reducing computational overhead.\n\n#### Token Caching Strategy\n\nCaching successfully verified tokens eliminates redundant cryptographic computations for frequently used tokens, but requires careful consideration of security implications and cache invalidation policies.\n\n**Cache Key Design**: The cache key must incorporate all factors that affect token validity, including the token content, validation context, and current time. Simply caching by token string is insufficient because validation context changes (different allowed issuers, audience requirements) or time progression (expiration status) can alter validity results.\n\n| Cache Component | Responsibility | Security Considerations |\n|-----------------|----------------|-------------------------|\n| `VerificationCache` | Stores verified token results | Must prevent cache poisoning attacks |\n| `CacheKeyGenerator` | Creates composite cache keys | Includes all validity-affecting factors |\n| `TimeAwareExpiration` | Manages cache TTL based on token exp claims | Never caches beyond token expiration |\n| `CacheInvalidator` | Removes stale entries on security events | Handles key rotation and policy changes |\n\n**Cache Invalidation Policies**: Token caches must invalidate entries based on multiple triggers. Time-based invalidation removes entries when tokens approach expiration or when system time advances significantly. Security-based invalidation clears caches when key material changes, allowed issuer lists update, or security incidents require cache clearing.\n\n**Security Boundary Enforcement**: The cache operates as a transparent optimization layer that never changes verification semantics. Cache hits return the same results that full verification would produce, and cache misses trigger complete verification with results stored for future use. The cache never bypasses security checks or returns results that wouldn't be produced by normal verification.\n\n```\nCache-Enhanced Verification Flow:\n1. Generate cache key from token content and validation context\n2. Check cache for existing verification result\n3. If cache hit and still valid, return cached result\n4. If cache miss, perform complete token verification\n5. Store verification result with appropriate expiration time\n6. Return verification result to caller\n```\n\n> **Decision: Time-Aware Cache Expiration**\n> - **Context**: Cached token results become invalid as time progresses due to exp, nbf, and iat claim validation\n> - **Options Considered**: Fixed TTL regardless of token claims, cache expiration matching token expiration, or no caching of time-sensitive tokens\n> - **Decision**: Set cache TTL to the minimum of configured maximum and token expiration time\n> - **Rationale**: This approach maximizes cache utilization while ensuring cached results never become incorrect due to time progression\n> - **Consequences**: More complex cache management but optimal balance between performance and correctness\n\n#### Signature Verification Optimization\n\nCryptographic signature verification typically dominates JWT processing time, making it the primary target for performance optimization. Several strategies can accelerate verification without compromising security.\n\n**Public Key Caching**: For RSA and ECDSA algorithms, parsing and preparing public keys for cryptographic operations involves significant computational overhead. Caching prepared key objects eliminates repeated parsing and mathematical setup for frequently used keys.\n\n**Signature Precomputation**: In scenarios where the same signing input appears frequently (common with short-lived tokens containing similar claims), precomputed signature values can accelerate verification. However, this optimization requires careful security analysis to ensure it doesn't introduce timing vulnerabilities.\n\n**Batch Verification**: Some cryptographic algorithms support batch verification where multiple signatures can be verified together more efficiently than individual verification. This optimization benefits high-throughput scenarios where applications verify many tokens simultaneously.\n\n| Optimization Technique | Performance Gain | Security Considerations |\n|------------------------|-------------------|-------------------------|\n| Public key caching | 30-50% reduction in key operations | Cache invalidation on key rotation |\n| Prepared key objects | 20-40% faster signature verification | Memory management for key lifecycle |\n| Signature precomputation | Up to 80% for repeated content | Must prevent timing information leakage |\n| Batch verification | 15-25% for high-volume operations | Requires careful error isolation |\n\n#### Memory Pool Management\n\nJWT processing creates many temporary objects: JSON parsers, Base64 decoders, cryptographic contexts, and intermediate data structures. Memory pool management can reduce allocation overhead and garbage collection pressure in high-throughput scenarios.\n\n**Object Pool Design**: Pre-allocated pools of reusable objects eliminate allocation overhead for common operations. Parsers, encoders, and cryptographic contexts can be borrowed from pools during token operations and returned for reuse after completion.\n\n**Buffer Management**: JWT operations involve substantial string and byte array manipulation. Maintaining pools of appropriately sized buffers reduces allocation pressure and can improve cache locality for cryptographic operations.\n\n**Lifecycle Coordination**: Pool management must coordinate with the library's security model to ensure that pooled objects are properly cleared between uses. Cryptographic contexts and intermediate buffers must be zeroed to prevent information leakage between different tokens or operations.\n\n#### Common Pitfalls in Performance Optimization\n\n⚠️ **Pitfall: Cache Poisoning Through Key Manipulation**\nIf cache keys don't incorporate all validation factors, attackers might manipulate validation contexts to cause incorrect cache hits. For example, if the cache key only includes the token string but not the allowed issuer list, changing the allowed issuers might return cached results from different validation contexts.\n\n⚠️ **Pitfall: Timing Information Leakage Through Caching**\nCache hits and misses can create timing differences that leak information about token usage patterns. Implement consistent timing behavior regardless of cache status, possibly through artificial delays or background verification operations.\n\n⚠️ **Pitfall: Memory Reuse Without Proper Clearing**\nReusing memory pools without proper clearing can leak token content between operations. Always zero sensitive buffers and reset object state when returning items to pools.\n\n⚠️ **Pitfall: Optimization Invalidation on Configuration Changes**\nCached results and optimized data structures can become invalid when system configuration changes (key rotation, allowed algorithm updates, policy modifications). Implement cache invalidation and optimization reset mechanisms that trigger on configuration changes.\n\n### Advanced JWT Features\n\nBeyond basic token signing and verification, enterprise applications often require sophisticated features like encrypted tokens, automatic key rotation, and complex claim validation rules. These advanced features build upon the foundational architecture while adding significant complexity in key management, operational procedures, and security models.\n\n#### Mental Model: Evolving Security Systems\n\nThink of JWT advancement like the evolution of bank security systems. Basic banks start with simple safes and manual ledgers (basic JWT signing). As they grow, they add armored transport (token encryption), automated vault systems (key rotation), and sophisticated audit trails (advanced claims processing). Each addition integrates with existing security measures rather than replacing them—the fundamental principles of authentication and authorization remain constant, but the implementation becomes more sophisticated to handle complex operational requirements.\n\nAdvanced JWT features follow this same evolutionary pattern. JWE encryption wraps existing JWT functionality in an additional security layer. Key rotation automates the operational aspects of key management without changing fundamental signing algorithms. Advanced claims processing extends basic validation with complex business logic while preserving the core security model.\n\n#### JWE (JSON Web Encryption) Integration\n\nJSON Web Encryption provides confidentiality protection for JWT content, encrypting the entire JWT token so that only authorized recipients can read the payload claims. JWE integration requires careful coordination between encryption and signing operations to maintain both confidentiality and authenticity properties.\n\n**Nested Token Architecture**: The most common JWE integration pattern creates nested tokens where a standard JWT is first signed, then the entire signed token becomes the payload for JWE encryption. This approach preserves existing JWT verification logic while adding an outer encryption layer.\n\n| JWE Component | Responsibility | Integration Points |\n|---------------|----------------|-------------------|\n| `JWEEncryptor` | Encrypts signed JWT tokens | Receives output from token signing operations |\n| `JWEDecryptor` | Decrypts JWE to reveal inner JWT | Feeds decrypted tokens to standard verification |\n| `KeyDerivationHandler` | Manages encryption key derivation | Coordinates with signature key management |\n| `ContentEncryptionManager` | Handles AES-GCM content encryption | Manages symmetric encryption for token payload |\n\n**Key Management Complexity**: JWE introduces additional key management requirements beyond signature keys. Content encryption keys (CEK) are typically generated per token and encrypted using key encryption keys (KEK). This multi-layer approach provides forward secrecy but requires sophisticated key derivation and management systems.\n\n**Encryption Algorithm Selection**: JWE supports multiple key agreement and content encryption algorithms. Common combinations include RSA-OAEP for key encryption with AES-256-GCM for content encryption, or ECDH-ES for key agreement with ChaCha20-Poly1305 for content encryption. Algorithm selection depends on performance requirements, security policies, and interoperability constraints.\n\n```\nJWE-Enhanced Token Creation Flow:\n1. Create and sign standard JWT using existing token creation process\n2. Generate random content encryption key (CEK) for this token\n3. Encrypt CEK using recipient's key encryption key (KEK)\n4. Encrypt signed JWT content using CEK and AES-GCM\n5. Assemble JWE token with encrypted key, IV, encrypted content, and authentication tag\n6. Return JWE token that contains encrypted JWT\n```\n\n**Performance Implications**: JWE operations add significant computational overhead due to key derivation and symmetric encryption operations. Content encryption scales with token size, making JWE particularly expensive for tokens with large claim sets or custom payload data.\n\n> **Decision: Nested JWT-in-JWE Rather Than JWE-First Design**\n> - **Context**: JWE can either encrypt unsigned claims or encrypt an already-signed JWT token\n> - **Options Considered**: Encrypt claims directly with JWE, sign JWE-encrypted content, or nest signed JWT within JWE\n> - **Decision**: Implement nested JWT-in-JWE where signed tokens are encrypted as JWE payload\n> - **Rationale**: Nested approach preserves existing JWT verification logic, enables gradual adoption, and provides clearer separation between authentication and confidentiality\n> - **Consequences**: Slightly larger tokens due to nested structure, but much cleaner integration with existing systems\n\n#### Automatic Key Rotation\n\nProduction JWT systems require periodic key rotation to limit the impact of potential key compromise and meet compliance requirements. Automatic key rotation must coordinate key generation, distribution, gradual transition periods, and secure disposal of old keys.\n\n**Multi-Key Verification Support**: During key rotation periods, the system must support tokens signed with both old and new keys. The verification process attempts multiple keys until finding one that produces a valid signature, enabling gradual transition without service disruption.\n\n**Key Versioning and Distribution**: Each key requires unique identification through key IDs (`kid` header claim) that enable recipients to select appropriate verification keys. Key distribution mechanisms must securely deliver new keys to all verification services before those keys are used for token signing.\n\n| Rotation Component | Responsibility | Operational Considerations |\n|--------------------|----------------|---------------------------|\n| `KeyRotationScheduler` | Manages rotation timing and triggers | Coordinates with operational maintenance windows |\n| `KeyGenerationService` | Creates new keys with appropriate security parameters | Ensures sufficient entropy and parameter validation |\n| `KeyDistributionManager` | Securely delivers keys to all services | Handles distribution failures and retry logic |\n| `GracefulTransitionHandler` | Manages overlap periods with multiple valid keys | Balances security and operational continuity |\n\n**Rotation Timeline Management**: Key rotation follows carefully orchestrated timelines that balance security and operational stability. New keys are generated and distributed before use, old keys remain valid for verification during transition periods, and expired keys are securely disposed of after all tokens using them have expired.\n\n**Emergency Rotation Procedures**: Security incidents may require immediate key rotation outside normal schedules. Emergency rotation procedures must balance rapid response with system stability, often involving shorter transition periods and more aggressive cache invalidation.\n\n```\nKey Rotation Timeline:\n1. Generate new key pair with incremented version identifier\n2. Distribute new public key to all verification services\n3. Wait for distribution confirmation from all services\n4. Begin signing new tokens with new private key\n5. Continue accepting tokens signed with old key during grace period\n6. Stop accepting old key signatures after grace period expires\n7. Securely destroy old private key material\n```\n\n#### Advanced Claims Processing\n\nEnterprise applications often require sophisticated claim validation beyond standard registered claims. Advanced processing includes dynamic validation rules, external claim enrichment, conditional validation logic, and integration with identity management systems.\n\n**Rule-Based Validation Engine**: A flexible rule engine allows applications to define custom validation logic using configuration rather than code changes. Rules can reference claim values, external context, and time-based conditions to make validation decisions.\n\n**Claim Enrichment Pipeline**: Some applications need to augment token claims with additional information retrieved from external systems during validation. For example, user tokens might be enriched with current group memberships or permission grants retrieved from identity management systems.\n\n**Conditional Validation Logic**: Advanced scenarios require different validation rules based on token content, request context, or environmental factors. Administrative tokens might have different validation requirements than user tokens, or validation strictness might change based on request sensitivity.\n\n| Advanced Processing Component | Functionality | Integration Complexity |\n|------------------------------|---------------|------------------------|\n| `RuleEngine` | Evaluates configurable validation rules | Requires rule definition language and parser |\n| `ClaimEnrichmentPipeline` | Augments tokens with external data | Must handle external service failures gracefully |\n| `ConditionalValidator` | Applies different validation based on context | Requires careful rule precedence management |\n| `IdentityIntegration` | Connects with external identity systems | Complex error handling and caching considerations |\n\n**External System Integration**: Claim enrichment and advanced validation often require integration with external systems like LDAP directories, database systems, or web services. These integrations introduce latency, failure modes, and caching considerations that must be carefully managed to maintain JWT verification performance and reliability.\n\n#### Common Pitfalls in Advanced Features\n\n⚠️ **Pitfall: JWE Key Confusion Between Signing and Encryption**\nUsing the same key material for both JWT signing and JWE encryption can create cryptographic vulnerabilities. Always use separate key hierarchies for signing operations and encryption operations, even if they use the same underlying algorithm family.\n\n⚠️ **Pitfall: Key Rotation Race Conditions**\nIf new keys are used for signing before all verification services receive them, tokens will fail verification during the transition period. Always ensure complete key distribution and confirmation before beginning to use new keys for token creation.\n\n⚠️ **Pitfall: Advanced Claim Validation Bypassing Core Security**\nComplex claim processing logic must never bypass fundamental security validations like signature verification and expiration checking. Implement advanced features as additional layers on top of core security, not as replacements for basic validation.\n\n⚠️ **Pitfall: External System Dependencies Breaking Token Verification**\nIf advanced claim processing depends on external systems that become unavailable, token verification might fail even for otherwise valid tokens. Implement graceful degradation modes and consider which validations are essential versus enhancement features.\n\n### Implementation Guidance\n\nThe extensions described in this section build upon the foundational JWT library architecture, requiring careful integration to maintain security properties while adding new capabilities. This guidance provides concrete implementation strategies for each extension category.\n\n#### Technology Recommendations\n\n| Extension Category | Simple Option | Advanced Option |\n|-------------------|---------------|-----------------|\n| Additional Algorithms | Python `cryptography` library with RSA/ECDSA | Hardware Security Module (HSM) integration |\n| Performance Caching | In-memory LRU cache with `functools.lru_cache` | Redis cluster with consistent hashing |\n| JWE Integration | `python-jose` library for JWE operations | Custom implementation with `cryptography` primitives |\n| Key Rotation | File-based key storage with version numbers | HashiCorp Vault with automatic rotation |\n| Advanced Claims | JSON Schema validation with `jsonschema` | Custom rule engine with external service integration |\n\n#### Recommended File Structure for Extensions\n\n```\njwt-library/\n  core/\n    encoder.py           ← existing JWT encoding (Milestone 1)\n    signer.py           ← existing HMAC signing (Milestone 2)  \n    validator.py        ← existing claims validation (Milestone 3)\n  extensions/\n    algorithms/\n      rsa_signer.py     ← RSA signing implementation\n      ecdsa_signer.py   ← ECDSA signing implementation\n      registry.py       ← algorithm selection and instantiation\n    performance/\n      cache.py          ← token verification caching\n      pools.py          ← object and memory pool management\n    advanced/\n      jwe.py            ← JWE encryption/decryption\n      rotation.py       ← automatic key rotation\n      rules.py          ← advanced claims processing\n  examples/\n    extension_usage.py  ← demonstration of extension features\n  tests/\n    extensions/         ← comprehensive extension testing\n```\n\nThis structure isolates extensions from core functionality while enabling clean integration through well-defined interfaces.\n\n#### RSA Algorithm Implementation Starter Code\n\n```python\n\"\"\"\nRSA signature algorithm implementation for JWT library extensions.\nProvides RS256 signing and verification with proper key management.\n\"\"\"\n\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import rsa, padding\nfrom cryptography.exceptions import InvalidSignature\nimport base64\nfrom typing import Union\n\nclass RSASignerRS256:\n    \"\"\"RSA-SHA256 token signer using private key for signature generation.\"\"\"\n    \n    def __init__(self, private_key_pem: str):\n        # TODO 1: Load private key from PEM string using cryptography library\n        # TODO 2: Validate that key is RSA type and meets minimum security requirements\n        # TODO 3: Store private key securely in instance variable\n        # TODO 4: Initialize PKCS1v15 padding for signature operations\n        # Hint: Use serialization.load_pem_private_key() for key loading\n        pass\n    \n    def sign(self, signing_input: str) -> str:\n        \"\"\"Generate RS256 signature for JWT signing input.\"\"\"\n        # TODO 1: Convert signing input string to bytes using UTF-8 encoding\n        # TODO 2: Sign the bytes using RSA private key with SHA256 hash and PKCS1v15 padding\n        # TODO 3: Base64URL encode the signature bytes to string format\n        # TODO 4: Return the encoded signature for JWT token assembly\n        # Hint: Use private_key.sign(data, padding.PKCS1v15(), hashes.SHA256())\n        pass\n\nclass RSAVerifierRS256:\n    \"\"\"RSA-SHA256 token verifier using public key for signature verification.\"\"\"\n    \n    def __init__(self, public_key_pem: str):\n        # TODO 1: Load public key from PEM string\n        # TODO 2: Validate key type and security parameters\n        # TODO 3: Store public key in instance variable\n        # TODO 4: Prepare verification padding configuration\n        pass\n    \n    def verify(self, signing_input: str, provided_signature: str) -> bool:\n        \"\"\"Verify RS256 signature against signing input using public key.\"\"\"\n        # TODO 1: Decode provided signature from Base64URL to bytes\n        # TODO 2: Convert signing input to bytes using UTF-8 encoding\n        # TODO 3: Attempt signature verification using public key\n        # TODO 4: Return True for valid signatures, False for invalid ones\n        # TODO 5: Handle cryptographic exceptions gracefully\n        # Hint: Use public_key.verify(signature, data, padding.PKCS1v15(), hashes.SHA256())\n        pass\n```\n\n#### Token Verification Cache Implementation\n\n```python\n\"\"\"\nPerformance-optimized token verification with security-aware caching.\nCaches verification results while maintaining all security properties.\n\"\"\"\n\nimport hashlib\nimport time\nfrom typing import Dict, Optional, Tuple\nfrom dataclasses import dataclass\nfrom .core.validator import ValidationContext, JWTPayload\n\n@dataclass\nclass CachedResult:\n    \"\"\"Cached verification result with expiration tracking.\"\"\"\n    payload: JWTPayload\n    cached_at: float\n    expires_at: float\n    context_hash: str\n\nclass VerificationCache:\n    \"\"\"Thread-safe cache for JWT verification results.\"\"\"\n    \n    def __init__(self, max_size: int = 1000, default_ttl: int = 300):\n        # TODO 1: Initialize thread-safe cache storage (use threading.RLock)\n        # TODO 2: Set up cache size limits and eviction policy\n        # TODO 3: Configure default TTL and cleanup intervals\n        # TODO 4: Initialize cache statistics tracking\n        pass\n    \n    def get_cache_key(self, token: str, context: ValidationContext) -> str:\n        \"\"\"Generate composite cache key from token and validation context.\"\"\"\n        # TODO 1: Create hash of validation context to capture all factors affecting validity\n        # TODO 2: Combine token content with context hash\n        # TODO 3: Include current time window to handle time-sensitive validations\n        # TODO 4: Return consistent cache key for identical inputs\n        # Hint: Use hashlib.sha256 to hash context parameters and token content\n        pass\n    \n    def get(self, cache_key: str) -> Optional[CachedResult]:\n        \"\"\"Retrieve cached result if still valid.\"\"\"\n        # TODO 1: Check if cache key exists in storage\n        # TODO 2: Verify cached result hasn't expired based on time\n        # TODO 3: Return cached result or None if invalid/expired\n        # TODO 4: Update cache hit/miss statistics\n        pass\n    \n    def put(self, cache_key: str, payload: JWTPayload, context: ValidationContext) -> None:\n        \"\"\"Store verification result with appropriate expiration.\"\"\"\n        # TODO 1: Calculate expiration time based on token exp claim and context\n        # TODO 2: Create CachedResult with current timestamp and expiration\n        # TODO 3: Store in cache with size limit enforcement\n        # TODO 4: Trigger cleanup if cache exceeds maximum size\n        pass\n```\n\n#### Key Rotation System Foundation\n\n```python\n\"\"\"\nAutomatic key rotation system with graceful transition support.\nManages key generation, distribution, and lifecycle coordination.\n\"\"\"\n\nimport os\nimport json\nfrom datetime import datetime, timedelta\nfrom typing import List, Dict, Optional\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.hazmat.primitives import serialization\n\n@dataclass\nclass KeyVersion:\n    \"\"\"Represents a single key version with metadata.\"\"\"\n    kid: str           # key identifier\n    created_at: datetime\n    expires_at: datetime\n    private_key: Optional[bytes]  # None for verification-only contexts\n    public_key: bytes\n    algorithm: str\n    status: str       # 'active', 'rotating', 'deprecated', 'revoked'\n\nclass KeyRotationManager:\n    \"\"\"Manages automatic key rotation with graceful transitions.\"\"\"\n    \n    def __init__(self, key_directory: str, rotation_interval: timedelta):\n        # TODO 1: Initialize key storage directory and file management\n        # TODO 2: Set up rotation scheduling and timeline management\n        # TODO 3: Load existing keys from storage\n        # TODO 4: Initialize key distribution tracking\n        pass\n    \n    def generate_new_key(self, algorithm: str = \"RS256\") -> KeyVersion:\n        \"\"\"Generate new key pair with proper security parameters.\"\"\"\n        # TODO 1: Generate RSA key pair with 2048-bit minimum size\n        # TODO 2: Create unique key identifier (kid) using timestamp and random data\n        # TODO 3: Set appropriate expiration time based on rotation policy\n        # TODO 4: Serialize keys to PEM format for storage\n        # TODO 5: Return KeyVersion object with all metadata\n        # Hint: Use rsa.generate_private_key(65537, 2048) for key generation\n        pass\n    \n    def initiate_rotation(self) -> KeyVersion:\n        \"\"\"Begin key rotation process with new key generation.\"\"\"\n        # TODO 1: Generate new key pair using generate_new_key()\n        # TODO 2: Mark current active key as 'rotating' status\n        # TODO 3: Set new key as 'active' for future token signing\n        # TODO 4: Persist key state changes to storage\n        # TODO 5: Return new key for distribution to verification services\n        pass\n    \n    def get_signing_key(self) -> KeyVersion:\n        \"\"\"Get current active key for token signing operations.\"\"\"\n        # TODO 1: Find key with 'active' status\n        # TODO 2: Check if key is approaching expiration\n        # TODO 3: Trigger rotation if necessary\n        # TODO 4: Return active key for signing operations\n        pass\n    \n    def get_verification_keys(self) -> List[KeyVersion]:\n        \"\"\"Get all keys valid for token verification.\"\"\"\n        # TODO 1: Return keys with 'active' or 'rotating' status\n        # TODO 2: Filter out expired keys based on current time\n        # TODO 3: Sort by creation time for consistent ordering\n        # TODO 4: Include public key material only\n        pass\n```\n\n#### Milestone Checkpoints for Extensions\n\n**Algorithm Extension Checkpoint**:\nAfter implementing RSA support, verify the extension by creating tokens with both HMAC and RSA algorithms:\n```python\n# Test command: python -m pytest tests/extensions/test_algorithms.py\n# Expected: All algorithm tests pass including cross-verification\n# Manual verification: Create RS256 token, verify with public key\n# Warning signs: Signature format errors, key loading failures\n```\n\n**Performance Enhancement Checkpoint**:\nAfter implementing caching, measure performance improvement with cache hit rates:\n```python\n# Test command: python extensions/examples/cache_benchmark.py\n# Expected: 50-80% cache hit rate with 3-5x verification speedup\n# Manual verification: Same token verified multiple times returns cached results\n# Warning signs: Cache key collisions, incorrect expiration behavior\n```\n\n**Advanced Features Checkpoint**:\nAfter implementing key rotation, verify seamless key transitions:\n```python\n# Test command: python extensions/examples/rotation_demo.py\n# Expected: Tokens verify during entire rotation cycle\n# Manual verification: Create token with old key, verify after rotation\n# Warning signs: Verification failures during transition periods\n```\n\n#### Debugging Extension Issues\n\n| Symptom | Likely Cause | Diagnosis | Fix |\n|---------|-------------|-----------|-----|\n| RSA signatures always invalid | Key format or padding mismatch | Check PEM encoding and PKCS1v15 usage | Verify key loading and padding configuration |\n| Cache never hits despite identical tokens | Context not included in cache key | Log cache key generation process | Include all context factors in key hash |\n| Key rotation breaks existing tokens | New key used before distribution | Check key distribution timing | Ensure distribution before signing with new key |\n| JWE tokens fail to decrypt | Key derivation or algorithm mismatch | Verify KEK and content encryption setup | Check algorithm compatibility and key formats |\n\n\n## Glossary\n\n> **Milestone(s):** Foundation for all three milestones - essential terminology for JWT structure (Milestone 1), HMAC signing (Milestone 2), and claims validation (Milestone 3)\n\nThis glossary provides comprehensive definitions of JWT terminology and cryptographic concepts used throughout our library implementation. Understanding these terms is crucial for implementing secure token-based authentication systems and avoiding common security pitfalls.\n\n### Mental Model: The Technical Dictionary\n\nThink of this glossary as a specialized technical dictionary for a new domain - just as learning a foreign language requires understanding both individual words and their contextual meanings, implementing JWT security requires mastering both the terminology and the security implications behind each concept. Each term represents a piece of the larger JWT security puzzle, and understanding how they interconnect is essential for building robust authentication systems.\n\n### JWT Core Terminology\n\nThe following table defines fundamental JWT concepts that form the foundation of token-based authentication:\n\n| Term | Definition | Security Implications |\n|------|------------|---------------------|\n| **JSON Web Token (JWT)** | A compact, URL-safe token format for representing claims between parties, consisting of three Base64URL-encoded parts separated by dots | Stateless authentication enabling distributed systems without shared session state |\n| **Stateless Authentication** | Authentication mechanism that doesn't require server-side session storage, with all necessary information contained within the token itself | Enables horizontal scaling but requires careful token security since compromise affects all services |\n| **Claims** | Statements about an entity (typically a user) and additional metadata contained within the JWT payload | Foundation of JWT security - incorrect validation allows unauthorized access |\n| **Header** | First part of JWT containing metadata about the token type and cryptographic algorithm used for signing | Algorithm specification prevents confusion attacks where attackers change signing method |\n| **Payload** | Second part of JWT containing the claims (user data, permissions, expiration times) | Contains sensitive information that determines authorization scope |\n| **Signature** | Third part of JWT providing cryptographic proof of token authenticity and integrity | Prevents token tampering - compromise enables complete authentication bypass |\n| **Base64URL Encoding** | URL-safe variant of Base64 encoding that replaces `+` with `-`, `/` with `_`, and removes padding `=` characters | URL safety prevents encoding issues in web contexts while maintaining data integrity |\n| **Token Assembly** | Process of combining encoded header, payload, and signature components with dot separators into final JWT format | Incorrect assembly can create malformed tokens that fail validation or create security vulnerabilities |\n\n### Cryptographic Concepts\n\nUnderstanding these cryptographic principles is essential for implementing secure JWT signing and verification:\n\n| Term | Definition | Security Implications |\n|------|------------|---------------------|\n| **HMAC-SHA256** | Keyed hash algorithm combining SHA-256 cryptographic hash with secret key authentication | Provides both integrity and authenticity - key compromise affects all tokens |\n| **Digital Signatures** | Cryptographic mechanism proving message authenticity and integrity using public-key or symmetric-key cryptography | Foundation of JWT trust - weak signature verification enables token forgery |\n| **Signature Verification** | Process of cryptographically validating token authenticity by recomputing and comparing signatures | Must use constant-time comparison to prevent timing attack vulnerabilities |\n| **Constant-time Comparison** | Comparison algorithm that takes identical time regardless of input differences, preventing timing side-channel attacks | Prevents attackers from learning signature information through execution time analysis |\n| **Timing Attack** | Cryptographic attack exploiting variations in execution time to extract sensitive information | Can reveal signature bytes through statistical analysis of verification timing |\n| **Algorithm Confusion Attack** | Attack exploiting JWT's algorithm flexibility to change verification method (e.g., HMAC to RSA) | Allows attackers to bypass signature verification by manipulating algorithm specification |\n| **Secret Key Handling** | Secure management of cryptographic keys including generation, storage, and validation | Key compromise renders all JWT security protections ineffective |\n| **Signing Input** | Concatenated string of encoded header and payload (`header.payload`) used for signature computation | Must be identical between signing and verification to ensure signature validity |\n| **HMAC-SHA256 Length** | Fixed 32-byte output length of HMAC-SHA256 algorithm | Signature truncation or extension indicates tampering or implementation errors |\n| **Minimum Key Length** | Security requirement for minimum cryptographic key size (32 bytes for HMAC-SHA256) | Shorter keys are vulnerable to brute-force attacks within practical timeframes |\n\n### Claims and Validation Terminology\n\nThese terms define how JWT claims are structured, validated, and secured:\n\n| Term | Definition | Security Implications |\n|------|------------|---------------------|\n| **Registered Claims** | Standard claim names defined in JWT specification (`iss`, `sub`, `aud`, `exp`, `nbf`, `iat`, `jti`) | Standardized validation rules prevent common security mistakes |\n| **Temporal Validation** | Verification of time-based claims including expiration, not-before, and issued-at timestamps | Prevents replay attacks and limits token abuse window |\n| **Clock Skew** | Time difference between servers that can cause legitimate tokens to fail validation | Requires leeway period to handle normal time synchronization variations |\n| **Leeway Period** | Time tolerance (typically 300 seconds) added to temporal validation to handle clock skew | Too much leeway extends attack windows, too little causes legitimate failures |\n| **Identity Validation** | Verification of issuer (`iss`) and audience (`aud`) claims against expected values | Prevents token misuse across different applications or services |\n| **Allowlist Validation** | Exact string matching of claim values against predefined approved lists | Stronger than pattern matching for preventing subtle bypass attacks |\n| **Custom Claims Processing** | Validation of application-specific payload fields beyond registered claims | Application security depends on proper validation of business logic claims |\n| **Fail-fast Validation** | Validation strategy that immediately rejects tokens upon first validation failure | Improves performance and simplifies error handling logic |\n| **Maximum Token Age** | Upper limit on token lifetime to prevent indefinite token usage | Balances user convenience with security exposure from compromised tokens |\n\n### Component Architecture Terms\n\nThese terms describe how our JWT library components interact and coordinate:\n\n| Term | Definition | Implementation Importance |\n|------|------------|--------------------------|\n| **Component Coordination** | Orchestrated interaction between encoding, signing, and validation components | Proper coordination ensures consistent security across all operations |\n| **Error Propagation** | Systematic passing of error context through component hierarchy | Security errors must preserve diagnostic information while preventing information disclosure |\n| **Self-verification** | Process of validating newly created tokens before returning them to callers | Catches implementation bugs that could produce invalid tokens |\n| **Validation Context** | Configuration object containing validation rules, security settings, and operational parameters | Centralized configuration prevents inconsistent security policies |\n| **Security Context** | Deployment environment classification affecting error detail levels and logging behavior | Production environments must limit error information to prevent information disclosure |\n| **Error Classification** | Systematic organization of failures by type, severity, and appropriate handling strategy | Enables appropriate response to different security threat levels |\n\n### Time-based Security Concepts\n\nUnderstanding temporal aspects of JWT security is crucial for preventing time-based attacks:\n\n| Term | Definition | Security Rationale |\n|------|------------|-------------------|\n| **Token Expiration (`exp`)** | Timestamp after which token should be rejected as invalid | Limits damage window if token is compromised or stolen |\n| **Not Before (`nbf`)** | Timestamp before which token should not be accepted | Prevents premature token usage and supports scheduled authorization |\n| **Issued At (`iat`)** | Timestamp when token was created | Enables token age validation and helps detect suspicious timing patterns |\n| **Temporal Edge Cases** | Unusual time scenarios like leap seconds, extreme dates, or timezone transitions | Can cause validation failures or security bypasses if not handled correctly |\n| **UTC Normalization** | Converting all timestamps to Coordinated Universal Time for consistent validation | Prevents timezone-based validation bypasses and ensures consistent behavior |\n| **Unix Timestamp** | Seconds since January 1, 1970 UTC - standard format for JWT time claims | Provides consistent time representation across different systems and languages |\n\n### Error Handling and Security Terms\n\nThese terms define how our library handles security-sensitive error conditions:\n\n| Term | Definition | Security Importance |\n|------|------------|-------------------|\n| **Validation Failure Context** | Structured error information including component, operation, severity, and diagnostic details | Enables appropriate error response while preventing information disclosure |\n| **Information Disclosure** | Unintended revelation of sensitive system details through error messages or behavior | Can provide attackers with information useful for crafting more effective attacks |\n| **Security-aware Logging** | Logging strategy that adapts detail level based on security context and potential information leakage | Balances debugging needs with operational security requirements |\n| **Cryptographic Error Handling** | Specialized handling of signature failures, key errors, and algorithm problems | Must prevent side-channel information leakage while providing useful diagnostics |\n| **Malformed Token Handling** | Processing strategy for tokens with structural or encoding problems | Must fail securely without revealing information about expected token structure |\n| **Error Severity Levels** | Classification system (`CRITICAL`, `HIGH`, `MEDIUM`, `LOW`) for prioritizing security responses | Enables appropriate incident response and monitoring alerting |\n\n### Advanced JWT Concepts\n\nThese terms describe extensions and advanced features that build upon basic JWT functionality:\n\n| Term | Definition | Advanced Applications |\n|------|------------|----------------------|\n| **Asymmetric Cryptography** | Public-private key cryptography enabling distributed verification without shared secrets | Allows token verification without access to signing keys |\n| **RSA-SHA256 (RS256)** | RSA signature algorithm with SHA-256 hash for JWT signing | Enables distributed verification with public keys |\n| **ECDSA-P256-SHA256 (ES256)** | Elliptic Curve Digital Signature Algorithm with P-256 curve and SHA-256 hash | Provides equivalent security to RSA with smaller key sizes |\n| **Key Rotation** | Periodic replacement of cryptographic keys to limit impact of key compromise | Essential for long-term security in production systems |\n| **Key Distribution** | Secure delivery of cryptographic keys to services requiring verification capability | Critical for distributed systems using asymmetric algorithms |\n| **JSON Web Encryption (JWE)** | Specification providing confidentiality for JWT content through encryption | Protects sensitive claims from disclosure even with token interception |\n| **Nested Tokens** | JWT tokens encrypted within JWE containers for both authenticity and confidentiality | Combines signature verification with content encryption |\n\n### Performance and Operational Terms\n\nThese terms describe efficiency and operational aspects of JWT implementation:\n\n| Term | Definition | Operational Impact |\n|------|------------|-------------------|\n| **Verification Cache** | Storage mechanism for caching successful token verification results | Improves performance but requires careful invalidation to maintain security |\n| **Cache Invalidation** | Process of removing stale or potentially compromised cache entries | Essential for maintaining security when keys rotate or policies change |\n| **Graceful Transition** | Smooth key rotation process that maintains service availability | Prevents authentication failures during security maintenance windows |\n| **Rule-based Validation** | Configurable claim validation using custom business logic rules | Enables complex authorization policies beyond standard JWT claims |\n| **Claim Enrichment** | Process of augmenting token claims with external data during validation | Allows dynamic authorization decisions based on current context |\n\n### Testing and Validation Terminology\n\nUnderstanding these terms is crucial for implementing comprehensive JWT library testing:\n\n| Term | Definition | Testing Importance |\n|------|------------|-------------------|\n| **Test Vectors** | Known-good input and output pairs used to validate implementation correctness | Ensures compatibility with JWT specification and other implementations |\n| **Reference Test Vectors** | Official test cases from JWT specification or trusted sources | Provides authoritative validation of cryptographic correctness |\n| **Security Test Scenarios** | Test cases specifically designed to detect timing attacks, algorithm confusion, and other vulnerabilities | Essential for validating security properties beyond functional correctness |\n| **End-to-end Scenarios** | Complete workflows testing token creation, transmission, and validation | Validates entire authentication flow including error handling |\n| **Milestone Verification Points** | Concrete checkpoints for validating completion of each development stage | Ensures progressive implementation maintains security properties |\n\n### Common Implementation Pitfalls\n\nUnderstanding these pitfalls helps developers avoid security vulnerabilities:\n\n⚠️ **Pitfall: Regular Base64 vs Base64URL**\nUsing standard Base64 encoding instead of Base64URL can cause tokens to break in URL contexts due to `+`, `/`, and `=` characters. Always use Base64URL encoding for JWT components to ensure URL safety.\n\n⚠️ **Pitfall: Padding Handling**\nIncorrectly handling Base64URL padding removal during encoding or restoration during decoding leads to malformed tokens. Implement proper padding logic according to RFC 4648.\n\n⚠️ **Pitfall: Timing Attack Vulnerability**\nUsing simple string or byte comparison for signature verification allows timing attacks. Always use constant-time comparison functions to prevent information leakage.\n\n⚠️ **Pitfall: Algorithm Confusion**\nNot validating the algorithm claim in JWT headers allows attackers to change from HMAC to RSA verification, bypassing signature checks. Always validate expected algorithm.\n\n⚠️ **Pitfall: Clock Skew Misconfiguration**\nSetting leeway periods too high extends attack windows, while too low causes legitimate authentication failures. Use 300 seconds as a reasonable default.\n\n⚠️ **Pitfall: Key Length Weakness**\nUsing keys shorter than 32 bytes for HMAC-SHA256 reduces security below acceptable levels. Always validate minimum key lengths.\n\n⚠️ **Pitfall: Information Disclosure**\nRevealing detailed error information in production environments helps attackers understand system internals. Implement security-aware error messages.\n\n### Implementation Guidance\n\nThis section provides practical guidance for implementing JWT terminology correctly in Python applications.\n\n#### Essential Libraries and Dependencies\n\n| Component | Recommended Library | Purpose |\n|-----------|-------------------|---------|\n| JSON Handling | `json` (standard library) | Header and payload serialization |\n| Base64 Encoding | `base64` (standard library) | Base64URL encoding/decoding |\n| Cryptography | `hmac` + `hashlib` (standard library) | HMAC-SHA256 implementation |\n| Time Handling | `datetime` + `time` (standard library) | Timestamp validation |\n| Secure Comparison | `hmac.compare_digest()` | Constant-time comparison |\n\n#### Recommended File Structure\n\n```\njwt_library/\n├── __init__.py                    # Public API exports\n├── core/\n│   ├── __init__.py\n│   ├── header.py                  # JWTHeader implementation\n│   ├── payload.py                 # JWTPayload implementation\n│   └── validation_context.py     # ValidationContext implementation\n├── encoding/\n│   ├── __init__.py\n│   ├── base64url.py              # Base64URL encoding utilities\n│   └── json_serializer.py       # JSON serialization utilities\n├── signing/\n│   ├── __init__.py\n│   ├── hmac_signer.py            # HMACSignerHS256 implementation\n│   └── key_handler.py            # SecureKeyHandler implementation\n├── validation/\n│   ├── __init__.py\n│   ├── claims_validator.py       # ClaimsValidator implementation\n│   ├── time_validator.py         # TimeValidator implementation\n│   └── identity_validator.py     # IdentityValidator implementation\n├── errors/\n│   ├── __init__.py\n│   └── exceptions.py             # All JWT exception classes\n└── utils/\n    ├── __init__.py\n    ├── time_utils.py             # UTC time handling utilities\n    └── constants.py              # All JWT constants\n```\n\n#### Core Constants Definition\n\n```python\n\"\"\"\nJWT Library Constants\nDefines all standard values and security parameters used throughout the library.\n\"\"\"\n\n# Algorithm identifiers\nHS256 = \"HS256\"\nRS256 = \"RS256\" \nES256 = \"ES256\"\n\n# Token type identifier\nJWT = \"JWT\"\n\n# Security parameters\nMIN_KEY_LENGTH = 32                    # bytes\nHMAC_SHA256_LENGTH = 32               # bytes\nMIN_RSA_KEY_SIZE = 2048              # bits\nDEFAULT_LEEWAY_SECONDS = 300          # seconds\nDEFAULT_MAX_TOKEN_AGE = 86400         # seconds (24 hours)\nDEFAULT_CACHE_TTL = 300               # seconds\nCACHE_MAX_SIZE = 1000                 # entries\nDEFAULT_ROTATION_INTERVAL = 90        # days\n\nclass ErrorSeverity:\n    \"\"\"Error severity levels for security classification.\"\"\"\n    CRITICAL = \"CRITICAL\"\n    HIGH = \"HIGH\" \n    MEDIUM = \"MEDIUM\"\n    LOW = \"LOW\"\n\nclass SecurityContext:\n    \"\"\"Security context classifications for environment-aware behavior.\"\"\"\n    DEVELOPMENT = \"DEVELOPMENT\"\n    PRODUCTION = \"PRODUCTION\"\n    AUDIT = \"AUDIT\"\n```\n\n#### Time Utilities Implementation\n\n```python\n\"\"\"\nTime handling utilities for JWT validation.\nProvides timezone-aware time operations and Unix timestamp conversion.\n\"\"\"\n\nfrom datetime import datetime, timezone\nimport time\nfrom typing import Union\n\ndef utc_now() -> datetime:\n    \"\"\"\n    Get current UTC time as timezone-aware datetime.\n    \n    Returns:\n        datetime: Current time in UTC timezone\n    \"\"\"\n    return datetime.now(timezone.utc)\n\ndef to_unix_timestamp(dt: Union[datetime, int]) -> int:\n    \"\"\"\n    Convert datetime to Unix timestamp.\n    \n    Args:\n        dt: datetime object or existing timestamp\n        \n    Returns:\n        int: Unix timestamp (seconds since epoch)\n        \n    Raises:\n        ValueError: If datetime is not timezone-aware\n    \"\"\"\n    if isinstance(dt, int):\n        return dt\n        \n    if dt.tzinfo is None:\n        raise ValueError(\"Datetime must be timezone-aware\")\n        \n    return int(dt.timestamp())\n\ndef is_expired(exp_timestamp: int, leeway: int = DEFAULT_LEEWAY_SECONDS) -> bool:\n    \"\"\"\n    Check if timestamp is in the past (considering leeway).\n    \n    Args:\n        exp_timestamp: Expiration timestamp to check\n        leeway: Seconds of tolerance for clock skew\n        \n    Returns:\n        bool: True if timestamp is expired\n    \"\"\"\n    current_time = time.time()\n    return current_time > (exp_timestamp + leeway)\n\ndef is_not_before(nbf_timestamp: int, leeway: int = DEFAULT_LEEWAY_SECONDS) -> bool:\n    \"\"\"\n    Check if current time is before nbf timestamp.\n    \n    Args:\n        nbf_timestamp: Not-before timestamp to check\n        leeway: Seconds of tolerance for clock skew\n        \n    Returns:\n        bool: True if token is not yet valid\n    \"\"\"\n    current_time = time.time()\n    return current_time < (nbf_timestamp - leeway)\n```\n\n#### Security Utilities Implementation\n\n```python\n\"\"\"\nSecurity utilities for cryptographically safe operations.\nProvides constant-time comparison and secure key handling.\n\"\"\"\n\nimport hmac\nimport secrets\nfrom typing import Union\n\ndef constant_time_compare(a: Union[bytes, str], b: Union[bytes, str]) -> bool:\n    \"\"\"\n    Perform constant-time comparison of two values.\n    \n    Args:\n        a: First value to compare\n        b: Second value to compare\n        \n    Returns:\n        bool: True if values are equal\n        \n    Note:\n        Uses hmac.compare_digest for timing attack resistance\n    \"\"\"\n    if isinstance(a, str):\n        a = a.encode('utf-8')\n    if isinstance(b, str):\n        b = b.encode('utf-8')\n        \n    return hmac.compare_digest(a, b)\n\ndef generate_secure_key() -> bytes:\n    \"\"\"\n    Generate cryptographically secure 32-byte key.\n    \n    Returns:\n        bytes: Random key suitable for HMAC-SHA256\n    \"\"\"\n    return secrets.token_bytes(MIN_KEY_LENGTH)\n\ndef validate_key_strength(key: bytes) -> None:\n    \"\"\"\n    Validate key meets minimum security requirements.\n    \n    Args:\n        key: Key bytes to validate\n        \n    Raises:\n        ValueError: If key is too short or weak\n    \"\"\"\n    if not isinstance(key, bytes):\n        raise ValueError(\"Key must be bytes\")\n        \n    if len(key) < MIN_KEY_LENGTH:\n        raise ValueError(f\"Key must be at least {MIN_KEY_LENGTH} bytes\")\n        \n    # Additional entropy check could be added here\n    # For now, length check provides basic security\n```\n\n#### Exception Base Classes\n\n```python\n\"\"\"\nJWT Library Exceptions\nDefines the exception hierarchy for JWT validation failures.\n\"\"\"\n\nfrom typing import Dict, Any, Optional\nfrom enum import Enum\n\nclass JWTValidationError(Exception):\n    \"\"\"\n    Base exception for all JWT validation failures.\n    \n    Attributes:\n        component: Component where error occurred\n        operation: Operation being performed\n        severity: Error severity level\n        safe_message: External-safe error description\n    \"\"\"\n    \n    def __init__(\n        self,\n        message: str,\n        component: str = \"unknown\",\n        operation: str = \"unknown\", \n        severity: str = ErrorSeverity.MEDIUM,\n        debug_info: Optional[Dict[str, Any]] = None\n    ):\n        super().__init__(message)\n        self.component = component\n        self.operation = operation\n        self.severity = severity\n        self.debug_info = debug_info or {}\n        self.safe_message = self._create_safe_message()\n    \n    def _create_safe_message(self) -> str:\n        \"\"\"Create production-safe error message without sensitive details.\"\"\"\n        return f\"JWT validation failed in {self.component}\"\n\nclass StructuralError(JWTValidationError):\n    \"\"\"Token format and structure validation failures.\"\"\"\n    pass\n\nclass MalformedTokenError(StructuralError):\n    \"\"\"Invalid token structure or encoding.\"\"\"\n    pass\n\nclass TemporalValidationError(JWTValidationError):\n    \"\"\"Time-based validation failures.\"\"\"\n    pass\n\nclass TokenExpiredError(TemporalValidationError):\n    \"\"\"Token expiration validation failure.\"\"\"\n    pass\n\nclass TokenNotYetValidError(TemporalValidationError):\n    \"\"\"Not-before validation failure.\"\"\"\n    pass\n\nclass IdentityValidationError(JWTValidationError):\n    \"\"\"Identity claim validation failures.\"\"\"\n    pass\n\nclass InvalidIssuerError(IdentityValidationError):\n    \"\"\"Issuer validation failure.\"\"\"\n    pass\n\nclass InvalidAudienceError(IdentityValidationError):\n    \"\"\"Audience validation failure.\"\"\"\n    pass\n\nclass CustomClaimValidationError(JWTValidationError):\n    \"\"\"Custom claim validation failure.\"\"\"\n    pass\n\nclass MissingRequiredClaimError(JWTValidationError):\n    \"\"\"Missing required claim failure.\"\"\"\n    pass\n```\n\n#### Validation Context Factory Functions\n\n```python\n\"\"\"\nValidation context factory functions for common JWT validation scenarios.\n\"\"\"\n\nfrom typing import List, Optional\n\ndef create_strict_context(\n    allowed_issuers: List[str],\n    expected_audience: str,\n    required_claims: Optional[List[str]] = None\n) -> ValidationContext:\n    \"\"\"\n    Create strict validation context for high-security environments.\n    \n    Args:\n        allowed_issuers: List of permitted issuer values\n        expected_audience: Required audience value\n        required_claims: Additional required claim names\n        \n    Returns:\n        ValidationContext: Configured for strict validation\n    \"\"\"\n    return ValidationContext(\n        verify_signature=True,\n        verify_expiration=True, \n        verify_not_before=True,\n        leeway_seconds=60,  # Reduced leeway for strict mode\n        allowed_issuers=allowed_issuers,\n        require_issuer=True,\n        expected_audience=expected_audience,\n        require_audience=True,\n        required_claims=required_claims or []\n    )\n\ndef create_permissive_context() -> ValidationContext:\n    \"\"\"\n    Create permissive validation context for development/testing.\n    \n    Returns:\n        ValidationContext: Configured for permissive validation\n    \"\"\"\n    return ValidationContext(\n        verify_signature=True,\n        verify_expiration=True,\n        verify_not_before=False,  # Skip nbf in development\n        leeway_seconds=DEFAULT_LEEWAY_SECONDS,\n        allowed_issuers=[],  # Accept any issuer\n        require_issuer=False,\n        expected_audience=\"\",\n        require_audience=False,\n        required_claims=[]\n    )\n\ndef create_custom_context(**kwargs) -> ValidationContext:\n    \"\"\"\n    Create custom validation context with specific requirements.\n    \n    Args:\n        **kwargs: ValidationContext field overrides\n        \n    Returns:\n        ValidationContext: Configured with custom settings\n    \"\"\"\n    defaults = {\n        'verify_signature': True,\n        'verify_expiration': True,\n        'verify_not_before': True,\n        'leeway_seconds': DEFAULT_LEEWAY_SECONDS,\n        'allowed_issuers': [],\n        'require_issuer': False,\n        'expected_audience': \"\",\n        'require_audience': False,\n        'required_claims': []\n    }\n    \n    defaults.update(kwargs)\n    return ValidationContext(**defaults)\n```\n\n#### Development and Testing Utilities\n\n```python\n\"\"\"\nDevelopment utilities for JWT library testing and debugging.\n\"\"\"\n\nimport json\nfrom typing import Dict, Any\n\ndef debug_token_structure(token: str) -> Dict[str, Any]:\n    \"\"\"\n    Parse and display JWT token structure for debugging.\n    \n    Args:\n        token: JWT token string\n        \n    Returns:\n        dict: Parsed token components\n        \n    Note:\n        For debugging only - does not validate signatures\n    \"\"\"\n    try:\n        parts = token.split('.')\n        if len(parts) != 3:\n            return {\"error\": \"Invalid token structure\"}\n            \n        header_data = base64url_decode(parts[0])\n        payload_data = base64url_decode(parts[1])\n        \n        return {\n            \"header\": json.loads(header_data.decode('utf-8')),\n            \"payload\": json.loads(payload_data.decode('utf-8')),\n            \"signature_length\": len(parts[2])\n        }\n    except Exception as e:\n        return {\"error\": str(e)}\n\ndef create_test_key() -> bytes:\n    \"\"\"\n    Generate test key for development use.\n    \n    Returns:\n        bytes: Test key (NOT for production)\n        \n    Warning:\n        This generates a predictable key for testing.\n        Never use in production environments.\n    \"\"\"\n    return b\"test_key_32_bytes_for_development_\"\n\ndef validate_implementation_completeness() -> Dict[str, bool]:\n    \"\"\"\n    Check if all required components are implemented.\n    \n    Returns:\n        dict: Implementation status for each component\n    \"\"\"\n    checks = {}\n    \n    try:\n        from jwt_library.core import JWTHeader, JWTPayload, ValidationContext\n        checks[\"core_types\"] = True\n    except ImportError:\n        checks[\"core_types\"] = False\n        \n    try:\n        from jwt_library.encoding import base64url_encode, base64url_decode\n        checks[\"encoding\"] = True\n    except ImportError:\n        checks[\"encoding\"] = False\n        \n    try:\n        from jwt_library.signing import HMACSignerHS256, SecureKeyHandler\n        checks[\"signing\"] = True\n    except ImportError:\n        checks[\"signing\"] = False\n        \n    try:\n        from jwt_library.validation import ClaimsValidator\n        checks[\"validation\"] = True\n    except ImportError:\n        checks[\"validation\"] = False\n        \n    return checks\n```\n\nThis comprehensive glossary provides the foundation for understanding JWT security concepts and implementing the library correctly. Refer to these definitions throughout the implementation process to ensure consistent terminology and security practices.\n"}